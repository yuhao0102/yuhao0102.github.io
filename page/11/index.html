<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zn-ch">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
<meta property="og:type" content="website">
<meta property="og:title" content="Hao Yu&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/11/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
<meta property="og:locale" content="zn_CH">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="HPC PC IA">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/11/"/>





  <title>Hao Yu's blog</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/03/%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/" itemprop="url">剑指offer Python题解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-03T17:54:00+08:00">
                2020-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3.数组中重复的数字"></a>3.数组中重复的数字</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]</span></span><br><span class="line">    <span class="comment"># 函数返回True/False</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">duplicate</span>(<span class="params">self, numbers, duplication</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> _, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(numbers):</span><br><span class="line">            <span class="keyword">if</span> v &gt;= <span class="built_in">len</span>(numbers) <span class="keyword">or</span> v &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numbers)):</span><br><span class="line">            <span class="keyword">while</span> numbers[i] != i:</span><br><span class="line">                <span class="keyword">if</span> numbers[i] == numbers[numbers[i]]:</span><br><span class="line">                    duplication[<span class="number">0</span>] = numbers[i]</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    idx = numbers[i]</span><br><span class="line">                    numbers[i], numbers[idx] = numbers[idx], numbers[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>使用 O(1) 空间的解法:</strong> 但条件一定要明确，存在重复数字。思维类似于寻找链表环的入口。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">duplicateInArray</span>(<span class="params">self, nums</span>):</span><br><span class="line">        f = s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> f == <span class="number">0</span> <span class="keyword">or</span> f != s:</span><br><span class="line">            f = nums[nums[f]]</span><br><span class="line">            s = nums[s]</span><br><span class="line">        f = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> f != s:</span><br><span class="line">            f = nums[f]</span><br><span class="line">            s = nums[s]</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4.二维数组中的查找"></a>4.二维数组中的查找</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Find</span>(<span class="params">self, target, array</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        row = <span class="built_in">len</span>(array)                <span class="comment"># 数组的行数</span></span><br><span class="line">        col = <span class="built_in">len</span>(array[<span class="number">0</span>])             <span class="comment"># 数组的列数</span></span><br><span class="line">        i， j = row - <span class="number">1</span>, <span class="number">0</span>                           <span class="comment"># i, j这样规定是从左下开始查找，也可以从右上</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; col:       <span class="comment"># 双指针来判断是否在array中</span></span><br><span class="line">            <span class="keyword">if</span> array[i][j] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span>             <span class="comment"># 如果等于输出True</span></span><br><span class="line">            <span class="keyword">elif</span> array[i][j] &gt; target:</span><br><span class="line">                i -= <span class="number">1</span>                  <span class="comment"># 如果大于则往上移一格</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span>                  <span class="comment"># 如果小于则往右移一格</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>                    <span class="comment">#如果最后走到了边界仍没有，则输出False</span></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5.替换空格"></a>5.替换空格</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为 We Are Happy .则经过替换之后的字符串为 We%20Are%20Happy  。</p>
<h4 id="解法：-1"><a href="#解法：-1" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">replaceSpace</span>(<span class="params">self, s</span>):</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                res.extend([<span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;0&#x27;</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6.从尾到头打印链表"></a>6.从尾到头打印链表</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<h4 id="解法：-2"><a href="#解法：-2" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printListFromTailToHead</span>(<span class="params">self, head</span>):</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            res.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>还可以递归实现：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printListReversingly</span>(<span class="params">self, head</span>):</span><br><span class="line">        self.res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">helper</span>(<span class="params">p</span>):</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                helper(p.<span class="built_in">next</span>)</span><br><span class="line">                self.res.append(p.val)</span><br><span class="line"></span><br><span class="line">        helper(head)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7.重建二叉树"></a>7.重建二叉树</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h4 id="解法：-3"><a href="#解法：-3" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reConstructBinaryTree</span>(<span class="params">self, pre, tin</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(<span class="number">0</span>)</span><br><span class="line">        root.val = pre[<span class="number">0</span>]</span><br><span class="line">        idx = tin.index(pre[<span class="number">0</span>])</span><br><span class="line">        root.left = self.reConstructBinaryTree(pre[<span class="number">1</span>: idx + <span class="number">1</span>], tin[:idx])</span><br><span class="line">        root.right = self.reConstructBinaryTree(pre[idx + <span class="number">1</span>:], tin[idx + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder, inorder</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">stop</span>):</span><br><span class="line">            <span class="keyword">if</span> preorder <span class="keyword">and</span> inorder[-<span class="number">1</span>] != stop:</span><br><span class="line">                root = TreeNode(preorder.pop())</span><br><span class="line">                root.left = dfs(root.val)</span><br><span class="line">                inorder.pop()</span><br><span class="line">                root.right = dfs(stop)</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        preorder, inorder = preorder[::-<span class="number">1</span>], inorder[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="8-二叉树的下一个节点"><a href="#8-二叉树的下一个节点" class="headerlink" title="8.二叉树的下一个节点"></a>8.二叉树的下一个节点</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个二叉树和其中的一个节点，请找出中序遍历顺序的下一个节点并且返回。注意，树中的节点不仅包含左右子节点，同时包含指向父节点的指针。</p>
<h4 id="解法：-4"><a href="#解法：-4" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#         self.father = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderSuccessor</span>(<span class="params">self, q</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> q: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> q.right:</span><br><span class="line">            q = q.right</span><br><span class="line">            <span class="keyword">while</span> q.left:</span><br><span class="line">                q = q.left</span><br><span class="line">            <span class="keyword">return</span> q</span><br><span class="line">        <span class="keyword">while</span> q.father <span class="keyword">and</span> q.father.right == q:</span><br><span class="line">            q = q.father</span><br><span class="line">        <span class="keyword">return</span> q.father</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9.用两个栈实现队列"></a>9.用两个栈实现队列</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h4 id="解法：-5"><a href="#解法：-5" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.s1 = []</span><br><span class="line">        self.s2 = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="keyword">while</span> self.s1:</span><br><span class="line">            self.s2.append(self.s1.pop())</span><br><span class="line">        self.s1.append(node)</span><br><span class="line">        <span class="keyword">while</span> self.s2:</span><br><span class="line">            self.s1.append(self.s2.pop())</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.s1.pop()</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="10-斐波那契数列"><a href="#10-斐波那契数列" class="headerlink" title="10.斐波那契数列"></a>10.斐波那契数列</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39</p>
<h4 id="解法：-6"><a href="#解法：-6" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Fibonacci</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">return</span> self.Fibonacci(n - <span class="number">1</span>) + self.Fibonacci(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Fibonacci</span>(<span class="params">self, n</span>):</span><br><span class="line">        res=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            res[<span class="number">0</span>], res[<span class="number">1</span>], res[<span class="number">2</span>] = res[<span class="number">1</span>], res[<span class="number">2</span>], res[<span class="number">1</span>] + res[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>] <span class="keyword">if</span> n &gt; <span class="number">2</span> <span class="keyword">else</span> res[n]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Fibonacci</span>(<span class="params">self, n</span>):</span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            a, b = a+b, a</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="11-旋转数组中的最小数字"><a href="#11-旋转数组中的最小数字" class="headerlink" title="11.旋转数组中的最小数字"></a>11.旋转数组中的最小数字</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h4 id="解法：-7"><a href="#解法：-7" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[r]:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] == nums[r]:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> nums[l]</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12.矩阵中的路径"></a>12.矩阵中的路径</h3><h4 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h4><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。</p>
<p>注意：</p>
<p>输入的路径不为空；<br>所有出现的字符均为大写英文字母；</p>
<h4 id="解法：-8"><a href="#解法：-8" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasPath</span>(<span class="params">self, matrix, string</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>] <span class="keyword">or</span> <span class="keyword">not</span> string:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        state = [[<span class="literal">True</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j, pos</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= j &lt; n <span class="keyword">and</span> state[i][j]:</span><br><span class="line">                state[i][j] = ret = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == string[pos]:</span><br><span class="line">                    <span class="keyword">if</span> pos == <span class="built_in">len</span>(string) - <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    ret = dfs(i, j-<span class="number">1</span>, pos+<span class="number">1</span>) <span class="keyword">or</span> dfs(i, j+<span class="number">1</span>, pos+<span class="number">1</span>) <span class="keyword">or</span> dfs(i-<span class="number">1</span>, j, pos+<span class="number">1</span>) <span class="keyword">or</span> dfs(i+<span class="number">1</span>, j, pos+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">                    state[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == string[<span class="number">0</span>]:</span><br><span class="line">                    <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13.机器人的运动范围"></a>13.机器人的运动范围</h3><h4 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h4><p>地上有一个 m 行和 n 列的方格，横纵坐标范围分别是 0∼m−1 和 0∼n−1。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格。但是不能进入行坐标和列坐标的数位之和大于 k 的格子。请问该机器人能够达到多少个格子？</p>
<h4 id="解法：-9"><a href="#解法：-9" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">movingCount</span>(<span class="params">self, threshold, rows, cols</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x, y</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;rows <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;cols <span class="keyword">and</span> <span class="keyword">not</span> dp[x][y]:</span><br><span class="line">                dp[x][y] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> threshold &gt;= <span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">list</span>(<span class="built_in">str</span>(x)) + <span class="built_in">list</span>(<span class="built_in">str</span>(y)))):</span><br><span class="line">                    self.res += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">for</span> dx, dy <span class="keyword">in</span> delta:</span><br><span class="line">                        dfs(x+dx, y+dy)</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span>] * cols <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        delta = ((-<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="14-剪绳子"><a href="#14-剪绳子" class="headerlink" title="14.剪绳子"></a>14.剪绳子</h3><h4 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一根长度为 n 绳子，请把绳子剪成 m 段（m、n 都是整数，2≤n≤58 并且 m≥2）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]k[1] … k[m] 可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p>
<h4 id="解法：-10"><a href="#解法：-10" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProductAfterCutting</span>(<span class="params">self,n</span>):</span><br><span class="line">        dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i):</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(dp[j]*(i-j), j*(i-j)))</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProductAfterCutting</span>(<span class="params">self,n</span>):</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">4</span> <span class="keyword">else</span> <span class="number">3</span> ** ((n-<span class="number">2</span>) // <span class="number">3</span>) * ((n-<span class="number">2</span>) % <span class="number">3</span> + <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="15-二进制中-1-的个数"><a href="#15-二进制中-1-的个数" class="headerlink" title="15.二进制中 1 的个数"></a>15.二进制中 1 的个数</h3><h4 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h4 id="解法：-11"><a href="#解法：-11" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">NumberOf1</span>(<span class="params">self, n</span>):</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            n &amp;= <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            n &amp;= (n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16.数值的整数次方"></a>16.数值的整数次方</h3><h4 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h4><p>实现函数double Power(double base, int exponent)，求base的 exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<h4 id="解法：-12"><a href="#解法：-12" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:  <span class="comment"># 简单快速幂解法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Power</span>(<span class="params">self, base, exponent</span>):</span><br><span class="line">        exp = <span class="built_in">abs</span>(exponent)</span><br><span class="line">        r = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> exp:</span><br><span class="line">            <span class="keyword">if</span> exp &amp; <span class="number">1</span>:</span><br><span class="line">                r *= base</span><br><span class="line">            base *= base</span><br><span class="line">            exp &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> r <span class="keyword">if</span> exponent &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>/r</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="18-删除列表中重复的节点"><a href="#18-删除列表中重复的节点" class="headerlink" title="18.删除列表中重复的节点"></a>18.删除列表中重复的节点</h3><h4 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个排序的链表中，存在重复的节点，请删除该链表中重复的节点，重复的节点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h4 id="解法：-13"><a href="#解法：-13" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplication</span>(<span class="params">self, pHead</span>):</span><br><span class="line">        dummy = tmp = ListNode(<span class="number">0</span>)</span><br><span class="line">        tmp.<span class="built_in">next</span> = pHead</span><br><span class="line">        <span class="keyword">while</span> pHead <span class="keyword">and</span> pHead.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> pHead.val == pHead.<span class="built_in">next</span>.val:</span><br><span class="line">                <span class="keyword">while</span> pHead.<span class="built_in">next</span> <span class="keyword">and</span> pHead.val == pHead.<span class="built_in">next</span>.val:</span><br><span class="line">                    pHead = pHead.<span class="built_in">next</span></span><br><span class="line">                tmp.<span class="built_in">next</span> = pHead.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = tmp.<span class="built_in">next</span></span><br><span class="line">            pHead = pHead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19.正则表达式匹配"></a>19.正则表达式匹配</h3><h4 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配。</p>
<h4 id="解法：-14"><a href="#解法：-14" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isMatch</span>(<span class="params">self, s, p</span>):</span><br><span class="line">        dp = [[<span class="literal">False</span>] * (<span class="built_in">len</span>(p)+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(p)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[j-<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(p)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j-<span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] <span class="keyword">and</span> p[j-<span class="number">1</span>] <span class="keyword">in</span> (s[i-<span class="number">1</span>], <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j-<span class="number">2</span>] <span class="keyword">or</span> dp[i-<span class="number">1</span>][j] <span class="keyword">and</span> p[j-<span class="number">2</span>] <span class="keyword">in</span> (s[i-<span class="number">1</span>], <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20.表示数值的字符串"></a>20.表示数值的字符串</h3><h4 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<h4 id="解法：-15"><a href="#解法：-15" class="headerlink" title="解法："></a>解法：</h4><p><strong>两种写法</strong>： 第一种是一次遍历所有条件判断，第二种就好理解很多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isNumber</span>(<span class="params">self, s</span>):</span><br><span class="line">        s = s.strip()</span><br><span class="line">        met_dot = met_e = met_digit = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> <span class="string">&#x27;+-&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> s[i-<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;eE&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> char == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> met_dot <span class="keyword">or</span> met_e: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                met_dot = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> char == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> char == <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> met_e <span class="keyword">or</span> <span class="keyword">not</span> met_digit:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                met_e, met_digit = <span class="literal">True</span>, <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> char.isdigit():</span><br><span class="line">                met_digit = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> met_digit</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isNumber</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        s = s.strip()</span><br><span class="line">        validList = <span class="built_in">set</span>([<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;E&#x27;</span>])</span><br><span class="line">        isFirst = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                isFirst = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> validList:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;e&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> isFirst:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                isFirst = <span class="literal">True</span></span><br><span class="line">                validList = <span class="built_in">set</span>([<span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>])</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                validList = <span class="built_in">set</span>([<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;E&#x27;</span>])</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> isFirst:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                validList.remove(<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                validList.remove(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">and</span> <span class="keyword">not</span> isFirst</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21.调整数组顺序使奇数位于偶数前面"></a>21.调整数组顺序使奇数位于偶数前面</h3><h4 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分。</p>
<h4 id="解法：-16"><a href="#解法：-16" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reOrderArray</span>(<span class="params">self, array</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(array) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">while</span> i &lt;= <span class="built_in">len</span>(array) - <span class="number">1</span> <span class="keyword">and</span> array[i] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> array[j] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            array[i], array[j] = array[j], array[i]</span><br><span class="line">        <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="22-链表中倒数第-k-个节点"><a href="#22-链表中倒数第-k-个节点" class="headerlink" title="22.链表中倒数第 k 个节点"></a>22.链表中倒数第 k 个节点</h3><h4 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，输出该链表中倒数第k个节点。</p>
<h4 id="解法：-17"><a href="#解法：-17" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findKthToTail</span>(<span class="params">self, head, k</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast = slow = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k): <span class="comment"># 快慢指针来走，之所以先判断是为了防止 k 等于链表长度的情况。</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            fast, slow = fast.<span class="built_in">next</span>, slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="23-链表中环的入口节点"><a href="#23-链表中环的入口节点" class="headerlink" title="23.链表中环的入口节点"></a>23.链表中环的入口节点</h3><h4 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h4><p>给一个链表，若其中包含环，请找出该链表的环的入口节点，否则，输出null。</p>
<h4 id="解法：-18"><a href="#解法：-18" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">EntryNodeOfLoop</span>(<span class="params">self, pHead</span>):</span><br><span class="line">        pre = post = pHead</span><br><span class="line">        <span class="keyword">while</span> pre <span class="keyword">and</span> pre.<span class="built_in">next</span>:       <span class="comment"># 确保快指针有意义没有到头</span></span><br><span class="line">            post = post.<span class="built_in">next</span>          <span class="comment"># 慢指针走一步</span></span><br><span class="line">            pre = pre.<span class="built_in">next</span>.<span class="built_in">next</span>       <span class="comment"># 快指针走两步</span></span><br><span class="line">            <span class="keyword">if</span> pre == post:           <span class="comment"># 相遇的时候即是有环</span></span><br><span class="line">                post = pHead          <span class="comment"># 慢指针再从头走</span></span><br><span class="line">                <span class="keyword">while</span> pre != post:    <span class="comment"># 两个指针都是每次一步直到相遇</span></span><br><span class="line">                    pre = pre.<span class="built_in">next</span></span><br><span class="line">                    post = post.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> post           <span class="comment"># 相遇的地方即是环的入口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24.反转链表"></a>24.反转链表</h3><h4 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<h4 id="解法：-19"><a href="#解法：-19" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ReverseList</span>(<span class="params">self, pHead</span>):</span><br><span class="line">        pre, cur = <span class="literal">None</span>, pHead</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"><span class="comment"># 简化如下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ReverseList</span>(<span class="params">self, pHead</span>):</span><br><span class="line">        pre, cur = <span class="literal">None</span>, pHead</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            pre, pre.<span class="built_in">next</span>, cur = cur, pre, cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"><span class="comment"># 递归法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ReverseList</span>(<span class="params">self, pHead</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> <span class="keyword">not</span> pHead.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            newHead = self.ReverseList(pHead.<span class="built_in">next</span>)</span><br><span class="line">            pHead.<span class="built_in">next</span>.<span class="built_in">next</span> = pHead</span><br><span class="line">            pHead.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> newHead</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">while</span> head.<span class="built_in">next</span>:</span><br><span class="line">            cur = head.<span class="built_in">next</span></span><br><span class="line">            head.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = dummy.<span class="built_in">next</span></span><br><span class="line">            dummy.<span class="built_in">next</span> = cur</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25.合并两个排序的链表"></a>25.合并两个排序的链表</h3><h4 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<h4 id="解法：-20"><a href="#解法：-20" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Merge</span>(<span class="params">self, pHead1, pHead2</span>):</span><br><span class="line">        dummy = tmp = ListNode(-<span class="number">1</span>)  <span class="comment"># 创建一个新链表来合并两个旧链表</span></span><br><span class="line">        p1, p2 = pHead1, pHead2</span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:            <span class="comment"># 都不为空的情况</span></span><br><span class="line">            <span class="keyword">if</span> p1.val &lt;= p2.val:</span><br><span class="line">                tmp.<span class="built_in">next</span> = p1</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp.<span class="built_in">next</span> = p2</span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">            tmp = tmp.<span class="built_in">next</span></span><br><span class="line">        tmp.<span class="built_in">next</span> = p1 <span class="keyword">or</span> p2         <span class="comment"># 一开始都为空或者其中一个为空或者经过while循环后其中一个为空的情况都包含了</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26.树的子结构"></a>26.树的子结构</h3><h4 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两棵二叉树A，B，判断B是不是A的子结构。我们规定空树不是任何树的子结构。</p>
<h4 id="解法：-21"><a href="#解法：-21" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasSubtree</span>(<span class="params">self, p1, p2</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p1 <span class="keyword">or</span> <span class="keyword">not</span> p2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> self.isPart(p1, p2):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.hasSubtree(p1.left, p2) <span class="keyword">or</span> self.hasSubtree(p1.right, p2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPart</span>(<span class="params">self, p1, p2</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p1 <span class="keyword">or</span> p1.val != p2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isPart(p1.left, p2.left) <span class="keyword">and</span> self.isPart(p1.right, p2.right)</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h3><h4 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h4><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树</span><br><span class="line">    	    <span class="number">8</span></span><br><span class="line">    	   /  \</span><br><span class="line">    	  <span class="number">6</span>   <span class="number">10</span></span><br><span class="line">    	 / \  / \</span><br><span class="line">    	<span class="number">5</span>  <span class="number">7</span> <span class="number">9</span> <span class="number">11</span></span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    <span class="number">8</span></span><br><span class="line">    	   /  \</span><br><span class="line">    	  <span class="number">10</span>   <span class="number">6</span></span><br><span class="line">    	 / \  / \</span><br><span class="line">    	<span class="number">11</span> <span class="number">9</span> <span class="number">7</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="解法：-22"><a href="#解法：-22" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Mirror</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        <span class="keyword">if</span> root.left:                <span class="comment"># 简洁的话可以不加下面这两个判断，</span></span><br><span class="line">            self.Mirror(root.left)   <span class="comment"># 因为递归调用后第一个判断和这个等效，</span></span><br><span class="line">        <span class="keyword">if</span> root.right:               <span class="comment"># 但是涉及函数调用，会让速度更慢</span></span><br><span class="line">            self.Mirror(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28.对称的二叉树"></a>28.对称的二叉树</h3><h4 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，用来判断一棵二叉树是不是对称的。</p>
<p>如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<h4 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">如下图所示二叉树[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,null,null,null,null,null,null,null,null]为对称二叉树：</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br><span class="line"></span><br><span class="line">如下图所示二叉树[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,null,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,null,null,null,null,null,null]不是对称二叉树：</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line">   \ / \</span><br><span class="line">   <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h4 id="解法：-23"><a href="#解法：-23" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isSym</span>(<span class="params">p, q</span>):</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">and</span> q:</span><br><span class="line">                <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> isSym(p.left, q.right) <span class="keyword">and</span> isSym(p.right, q.left)</span><br><span class="line">            <span class="keyword">return</span> p <span class="keyword">is</span> q</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isSym(root.left, root.right)</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29.顺时针打印矩阵"></a>29.顺时针打印矩阵</h3><h4 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<h4 id="解法：-24"><a href="#解法：-24" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printMatrix</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> res</span><br><span class="line">        x = y = i = <span class="number">0</span></span><br><span class="line">        delta = ((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">        pos = [<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(matrix[<span class="number">0</span>])-<span class="number">1</span>, <span class="built_in">len</span>(matrix)-<span class="number">1</span>] <span class="comment"># 左、上、右、下。后面懒得判断推出来的。</span></span><br><span class="line">        <span class="keyword">while</span> pos[<span class="number">0</span>] &lt;= pos[<span class="number">2</span>] <span class="keyword">and</span> pos[<span class="number">1</span>] &lt;= pos[<span class="number">3</span>]:</span><br><span class="line">            <span class="keyword">while</span> pos[<span class="number">0</span>] &lt;= y &lt;= pos[<span class="number">2</span>] <span class="keyword">and</span> pos[<span class="number">1</span>] &lt;= x &lt;= pos[<span class="number">3</span>]:</span><br><span class="line">                res.append(matrix[x][y])</span><br><span class="line">                x, y = x+delta[i][<span class="number">0</span>], y+delta[i][<span class="number">1</span>]</span><br><span class="line">            x, y = x-delta[i][<span class="number">0</span>], y-delta[i][<span class="number">1</span>]</span><br><span class="line">            i = (i+<span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">            pos[i] += <span class="built_in">sum</span>(delta[i])</span><br><span class="line">            x, y = x+delta[i][<span class="number">0</span>], y+delta[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>动用了hin多空间</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printMatrix</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> matrix:</span><br><span class="line">            res += matrix[<span class="number">0</span>]</span><br><span class="line">            matrix = <span class="built_in">list</span>(<span class="built_in">zip</span>(*matrix[<span class="number">1</span>:]))[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30.包含min函数的栈"></a>30.包含min函数的栈</h3><h4 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<h4 id="解法：-25"><a href="#解法：-25" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack = []</span><br><span class="line">        self.stkmin = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stkmin <span class="keyword">or</span> self.getMin() &gt; x:</span><br><span class="line">            self.stkmin.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.stkmin.append(self.getMin())</span><br><span class="line">        self.stack.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            self.stkmin.pop()</span><br><span class="line">            <span class="keyword">return</span> self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.stkmin:</span><br><span class="line">            <span class="keyword">return</span> self.stkmin[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>进阶牛逼版 O(1)空间复杂度 O(1)时间复杂度</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack = []</span><br><span class="line">        self.mins = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack:</span><br><span class="line">            self.mins = x</span><br><span class="line">            self.stack.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            compare = x - self.mins</span><br><span class="line">            self.stack.append(compare)</span><br><span class="line">            self.mins = x <span class="keyword">if</span> compare &lt; <span class="number">0</span> <span class="keyword">else</span> self.mins            </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        top1 = self.stack.pop()</span><br><span class="line">        <span class="keyword">if</span> top1 &lt; <span class="number">0</span>:</span><br><span class="line">            self.mins = self.mins - top1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> self.stack[-<span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.mins + self.stack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.mins</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.mins</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="31-栈的压入弹出序列"><a href="#31-栈的压入弹出序列" class="headerlink" title="31.栈的压入弹出序列"></a>31.栈的压入弹出序列</h3><h4 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。</p>
<p>假设压入栈的所有数字均不相等。</p>
<p>例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。</p>
<p>注意：若两个序列长度不等则视为并不是一个栈的压入、弹出序列。若两个序列都为空，则视为是一个栈的压入、弹出序列。</p>
<h4 id="解法：-26"><a href="#解法：-26" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPopOrder</span>(<span class="params">self, pushV, popV</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pushV) != <span class="built_in">len</span>(popV): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack, i = [], <span class="number">0</span>       <span class="comment"># 用 stack 来模拟进出栈。</span></span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> pushV:</span><br><span class="line">            stack.append(v)</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[-<span class="number">1</span>] == popV[i]:</span><br><span class="line">                stack.pop()</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="32-从上到下打印二叉树"><a href="#32-从上到下打印二叉树" class="headerlink" title="32.从上到下打印二叉树"></a>32.从上到下打印二叉树</h3><h4 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h4><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h4 id="解法：-27"><a href="#解法：-27" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">PrintFromTopToBottom</span>(<span class="params">self, root</span>):</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            level = [root]</span><br><span class="line">            <span class="keyword">while</span> level:</span><br><span class="line">                res.extend([x.val <span class="keyword">for</span> x <span class="keyword">in</span> level])</span><br><span class="line">                level = [leaf <span class="keyword">for</span> node <span class="keyword">in</span> level <span class="keyword">for</span> leaf <span class="keyword">in</span> (node.left, node.right) <span class="keyword">if</span> leaf]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.二叉搜索树的后序遍历序列</h3><h4 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true，否则返回false.假设输入的数组的任意两个数字都互不相同。</p>
<h4 id="解法：-28"><a href="#解法：-28" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">verifySequenceOfBST</span>(<span class="params">self, sequence</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 看 OJ 要求 True or False</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">Max, stop</span>):</span><br><span class="line">            <span class="keyword">if</span> sequence <span class="keyword">and</span> Max &gt;= sequence[-<span class="number">1</span>] &gt;= stop:</span><br><span class="line">                x = sequence.pop()</span><br><span class="line">                dfs(Max, x)</span><br><span class="line">                dfs(x, stop)</span><br><span class="line">        dfs(<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> sequence</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34.二叉树中和为某一值的路径"></a>34.二叉树中和为某一值的路径</h3><h4 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。<br>从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<h4 id="解法：-29"><a href="#解法：-29" class="headerlink" title="解法："></a>解法：</h4><p><strong>分析：</strong> 分为两个解法，一种是递归的做法，另外一种是迭代的做法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: TreeNode, tsum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root :</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        temp, res = [], []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFTS</span>(<span class="params">root</span>):</span><br><span class="line">            temp.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> <span class="built_in">sum</span>(temp) == tsum:</span><br><span class="line">                res.append(temp.copy())</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                DFTS(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                DFTS(root.right)</span><br><span class="line">            temp.pop()</span><br><span class="line"></span><br><span class="line">        DFTS(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>迭代法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: TreeNode, Psum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack, res = [(root, [root.val])], []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, cur = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> <span class="built_in">sum</span>(cur) == Psum:</span><br><span class="line">                res.append(cur)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                stack.append((node.left, cur + [node.left.val]))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                stack.append((node.right, cur + [node.right.val]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><a href="#00">返回目录</a></p>
<h3 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35.复杂链表的复制"></a>35.复杂链表的复制</h3><h4 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<h4 id="解法：-30"><a href="#解法：-30" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class RandomListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.label = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="comment">#         self.random = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 返回 RandomListNode</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Clone</span>(<span class="params">self, pHead</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        p1 = p2 = p3 = pHead</span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            tmp = RandomListNode(p1.label)</span><br><span class="line">            tmp.<span class="built_in">next</span> = p1.<span class="built_in">next</span></span><br><span class="line">            tmp.random = <span class="literal">None</span></span><br><span class="line">            p1.<span class="built_in">next</span> = tmp</span><br><span class="line">            p1 = p1.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            tmp = p2.<span class="built_in">next</span></span><br><span class="line">            tmp.random = p2.random.<span class="built_in">next</span> <span class="keyword">if</span> p2.random <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            p2 = p2.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        dummy = tmp = p3.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> p3:</span><br><span class="line">            p3.<span class="built_in">next</span> = p3.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            tmp.<span class="built_in">next</span> = p3.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">if</span> p3.<span class="built_in">next</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            p3, tmp = p3.<span class="built_in">next</span>, tmp.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36.二叉搜索树与双向链表"></a>36.二叉搜索树与双向链表</h3><h4 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。<br>注意：需要返回双向链表最左侧的节点。</p>
<h4 id="解法：-31"><a href="#解法：-31" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            node.left = prev</span><br><span class="line">            <span class="keyword">if</span> prev:</span><br><span class="line">                prev.right = node</span><br><span class="line">            root = node.right</span><br><span class="line">            prev = node</span><br><span class="line">        cur = prev</span><br><span class="line">        <span class="keyword">while</span> cur.left:</span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37.序列化二叉树"></a>37.序列化二叉树</h3><h4 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树。<br>您需要确保二叉树可以序列化为字符串，并且可以将此字符串反序列化为原始树结构。</p>
<h4 id="解法：-32"><a href="#解法：-32" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">doit</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                vals.append(<span class="built_in">str</span>(node.val))</span><br><span class="line">                doit(node.left)</span><br><span class="line">                doit(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vals.append(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        vals = []</span><br><span class="line">        doit(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;,&#x27;</span>.join(vals)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">doit</span>():</span><br><span class="line">            val = <span class="built_in">next</span>(vals)</span><br><span class="line">            <span class="keyword">if</span> val == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            node = TreeNode(<span class="built_in">int</span>(val))</span><br><span class="line">            node.left = doit()</span><br><span class="line">            node.right = doit()</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        vals = <span class="built_in">iter</span>(data.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> doit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="#00">返回目录</a></p>
<h3 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38.字符串的排列"></a>38.字符串的排列</h3><h4 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一组数字（可能包含重复数字），输出其所有的排列方式。</p>
<h4 id="解法：-33"><a href="#解法：-33" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permutation</span>(<span class="params">self, nums</span>):</span><br><span class="line">        perms = [[]]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            perms = [</span><br><span class="line">                p[:i] + [n] + p[i:]</span><br><span class="line">                <span class="keyword">for</span> p <span class="keyword">in</span> perms</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>((p+[n]).index(n)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> perms</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39.数组中出现次数超过一半的数字"></a>39.数组中出现次数超过一半的数字</h3><h4 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h4 id="解法：-34"><a href="#解法：-34" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">MoreThanHalfNum_Solution</span>(<span class="params">self, numbers</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        candidate = numbers[<span class="number">0</span>]</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(numbers)):</span><br><span class="line">            <span class="keyword">if</span> numbers[i] == candidate:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                    candidate = numbers[i]</span><br><span class="line">                    count = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 上面是摩尔投票法，下面为验证，这样可以保证时间复杂度在 O(n) 。</span></span><br><span class="line">        <span class="keyword">if</span> numbers.count(candidate) * <span class="number">2</span> &gt; <span class="built_in">len</span>(numbers):</span><br><span class="line">            <span class="keyword">return</span> candidate</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="40-最大的k个数"><a href="#40-最大的k个数" class="headerlink" title="40.最大的k个数"></a>40.最大的k个数</h3><h4 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h4><p>在未排序的数组中找到前k个大的元素。 请注意，它们是排序顺序中前k个大的元素，而不是前k个不同的元素。</p>
<h4 id="解法：-35"><a href="#解法：-35" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="41-数据流的中位数"><a href="#41-数据流的中位数" class="headerlink" title="41.数据流的中位数"></a>41.数据流的中位数</h3><h4 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h4><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<h4 id="解法：-36"><a href="#解法：-36" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.heaps = [], []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, num</span>):</span><br><span class="line">        small, large = self.heaps</span><br><span class="line">        heappush(small, -heappushpop(large, num))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(large) &lt; <span class="built_in">len</span>(small):</span><br><span class="line">            heappush(large, -heappop(small))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMedian</span>(<span class="params">self</span>):</span><br><span class="line">        small, large = self.heaps</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(large) &gt; <span class="built_in">len</span>(small):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">float</span>(large[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> (large[<span class="number">0</span>] - small[<span class="number">0</span>]) / <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42.连续子数组的最大和"></a>42.连续子数组的最大和</h3><h4 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个整数数组中的元素有正有负，在该数组中找出一个连续子数组，要求该连续子数组中各元素的和最大，这个连续子数组便被称作最大连续子数组。比如数组{2,4,-7,5,2,-1,2,-4,3}的最大连续子数组为{5,2,-1,2}，最大连续子数组的和为5+2-1+2=8。</p>
<h4 id="解法：-37"><a href="#解法：-37" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindGreatestSumOfSubArray</span>(<span class="params">self, array</span>):</span><br><span class="line">        best = cur = array[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(array)):</span><br><span class="line">            cur = <span class="built_in">max</span>(array[i], array[i] + cur)</span><br><span class="line">            best = <span class="built_in">max</span>(best, cur)</span><br><span class="line">        <span class="keyword">return</span> best</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="43-1-n整数中1出现的次数"><a href="#43-1-n整数中1出现的次数" class="headerlink" title="43.1~n整数中1出现的次数"></a>43.1~n整数中1出现的次数</h3><h4 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含“1”的数字有1，10，11和12，其中“1”一共出现了5次。</p>
<h4 id="解法：-38"><a href="#解法：-38" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOf1Between1AndN_Solution</span>(<span class="params">self, n</span>):</span><br><span class="line">        count, i = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= n:</span><br><span class="line">            a, b = n // i, n % i</span><br><span class="line">            count += (a+<span class="number">8</span>) // <span class="number">10</span> * i + (a%<span class="number">10</span> == <span class="number">1</span>) * (b+<span class="number">1</span>)</span><br><span class="line">            i *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44.数字序列中某一位的数字"></a>44.数字序列中某一位的数字</h3><h4 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h4><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数求任意位对应的数字。</p>
<h4 id="解法：-39"><a href="#解法：-39" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):    <span class="comment"># 快速跳过不用检查的位数，确定区间。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">digitAtIndex</span>(<span class="params">self, n</span>):</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">            first = <span class="number">10</span> ** (digit - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> n &lt; <span class="number">9</span> * first * digit:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">str</span>(first + n // digit)[n % digit])</span><br><span class="line">            n -= <span class="number">9</span> * first * digit</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45.把数组排成最小的数"></a>45.把数组排成最小的数</h3><h4 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组[3, 32, 321]，则打印出这3个数字能排成的最小数字321323。</p>
<h4 id="解法：-40"><a href="#解法：-40" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printMinNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">set</span>(nums) == &#123;<span class="number">0</span>&#125;: <span class="keyword">return</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">        diff = <span class="built_in">len</span>(<span class="built_in">str</span>(<span class="built_in">max</span>(nums))) - <span class="built_in">len</span>(<span class="built_in">str</span>(<span class="built_in">min</span>(nums))) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">sorted</span>(<span class="built_in">map</span>(<span class="built_in">str</span>,nums),key= <span class="keyword">lambda</span> x: x*diff))</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46.把数字翻译成字符串"></a>46.把数字翻译成字符串</h3><h4 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数字，我们按照如下规则把它翻译为字符串：<br>0翻译成”a”，1翻译成”b”，……，11翻译成”l”，……，25翻译成”z”。<br>一个数字可能有多个翻译。例如12258有5种不同的翻译，它们分别是”bccfi”、”bwfi”、”bczi”、”mcfi”和”mzi”。<br>请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。</p>
<h4 id="解法：-41"><a href="#解法：-41" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getTranslationCount</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">or</span> s[i] == <span class="string">&#x27;2&#x27;</span> <span class="keyword">and</span> s[i+<span class="number">1</span>] &lt; <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">                dp[i] += dp[i+<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p><strong>可简化为 O(1) 空间</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getTranslationCount</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l = r = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">or</span> s[i] == <span class="string">&#x27;2&#x27;</span> <span class="keyword">and</span> s[i+<span class="number">1</span>] &lt; <span class="string">&#x27;6&#x27;</span>:</span><br><span class="line">                l, r = l + r, l</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = l</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47.礼物的最大价值"></a>47.礼物的最大价值</h3><h4 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个m×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。<br>你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格直到到达棋盘的右下角。<br>给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？</p>
<h4 id="解法：-42"><a href="#解法：-42" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMaxValue</span>(<span class="params">self, grid</span>):</span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                    dp[j] = grid[i][j] + <span class="built_in">max</span>(dp[j-<span class="number">1</span>], dp[j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = grid[i][j] + dp[j]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48.最长不含重复字符的子字符串"></a>48.最长不含重复字符的子字符串</h3><h4 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串，找到最长子字符串的长度而不重复字符。</p>
<h4 id="解法：-43"><a href="#解法：-43" class="headerlink" title="解法："></a>解法：</h4><p><strong>分析：</strong> 滑动窗口解决问题，如果遍历一遍 s，如果遍历到没有出现的元素，窗口右端立马扩张，并计算最大长度。如果遍历到之前出现的元素，则将窗口左端置为上次出现的位置的后一位。只有出现没有遍历过的元素才会计算最大长度。因为一旦是遍历过的元素，只有可能是保持不变或者缩小。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="params">self, s</span>):</span><br><span class="line">        start = maxLength = <span class="number">0</span></span><br><span class="line">        used = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> used <span class="keyword">and</span> start &lt;= used[c]:</span><br><span class="line">                start = used[c] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxLength = <span class="built_in">max</span>(maxLength, i - start + <span class="number">1</span>)</span><br><span class="line">            used[c] = i</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br></pre></td></tr></table></figure>
<p><a href="#00">返回目录</a></p>
<h3 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49.丑数"></a>49.丑数</h3><h4 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h4><p>我们把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。求第n个丑数的值。</p>
<h4 id="解法：-44"><a href="#解法：-44" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nthUglyNumber</span>(<span class="params">self, n</span>):</span><br><span class="line">        ugly = [<span class="number">1</span>]</span><br><span class="line">        i2 = i3 = i5 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(ugly) &lt; n:</span><br><span class="line">            <span class="keyword">while</span> ugly[i2] * <span class="number">2</span> &lt;= ugly[-<span class="number">1</span>]: i2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> ugly[i3] * <span class="number">3</span> &lt;= ugly[-<span class="number">1</span>]: i3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> ugly[i5] * <span class="number">5</span> &lt;= ugly[-<span class="number">1</span>]: i5 += <span class="number">1</span></span><br><span class="line">            ugly.append(<span class="built_in">min</span>(ugly[i2] * <span class="number">2</span>, ugly[i3] * <span class="number">3</span>, ugly[i5] * <span class="number">5</span>))</span><br><span class="line">        <span class="keyword">return</span> ugly[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    ugly = <span class="built_in">sorted</span>(<span class="number">2</span>**a * <span class="number">3</span>**b * <span class="number">5</span>**c</span><br><span class="line">                  <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>) <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14</span>))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nthUglyNumber</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="keyword">return</span> self.ugly[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50.第一个只出现一次的字符"></a>50.第一个只出现一次的字符</h3><h4 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h4><p>在字符串中找出第一个只出现一次的字符。如输入”abaccdeff”，则输出b。如果字符串中不存在只出现一次的字符，返回#字符。</p>
<h4 id="解法：-45"><a href="#解法：-45" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">firstNotRepeatingChar</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span></span><br><span class="line">        <span class="keyword">import</span> collections</span><br><span class="line">        count = collections.Counter(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">set</span>(s):</span><br><span class="line">            <span class="keyword">if</span> count[i] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52.两个链表的第一个公共节点"></a>52.两个链表的第一个公共节点</h3><h4 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入两个链表，找出它们的第一个公共节点。</p>
<h4 id="解法：-46"><a href="#解法：-46" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindFirstCommonNode</span>(<span class="params">self, pHead1, pHead2</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead1 <span class="keyword">or</span> <span class="keyword">not</span> pHead2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        l1, l2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        p1, p2 = pHead1, pHead2</span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            p1 = p1.<span class="built_in">next</span></span><br><span class="line">            l1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            p2 = p2.<span class="built_in">next</span></span><br><span class="line">            l2 += <span class="number">1</span></span><br><span class="line">        p1, p2 = pHead1, pHead2</span><br><span class="line">        <span class="keyword">if</span> l1 &gt;= l2:</span><br><span class="line">            <span class="keyword">while</span> l1 - l2:</span><br><span class="line">                p1 = p1.<span class="built_in">next</span></span><br><span class="line">                l1 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> l2 - l1:</span><br><span class="line">                p2 = p2.<span class="built_in">next</span></span><br><span class="line">                l2 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p1 <span class="keyword">and</span> p2:</span><br><span class="line">            <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                <span class="keyword">return</span> p1</span><br><span class="line">            p1 = p1.<span class="built_in">next</span></span><br><span class="line">            p2 = p2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindFirstCommonNode</span>(<span class="params">self, pHead1, pHead2</span>):</span><br><span class="line">        p1, p2 = pHead1, pHead2</span><br><span class="line">        <span class="keyword">while</span> p1 != p2:          <span class="comment"># 1.判断是否为同一个相交处 2.判断是否走完了一整遍</span></span><br><span class="line">            p1 = p1.<span class="built_in">next</span> <span class="keyword">if</span> p1 <span class="keyword">else</span> pHead2</span><br><span class="line">            p2 = p2.<span class="built_in">next</span> <span class="keyword">if</span> p2 <span class="keyword">else</span> pHead1</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="53-在排序数组中查找数字"><a href="#53-在排序数组中查找数字" class="headerlink" title="53.在排序数组中查找数字"></a>53.在排序数组中查找数字</h3><h4 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h4><p>统计一个数字在排序数组中出现的次数。如果不存在返回 0。<br>例如输入排序数组[1, 2, 3, 3, 3, 3, 4, 5]和数字3，由于3在这个数组中出现了4次，因此输出4。</p>
<h4 id="解法：-47"><a href="#解法：-47" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNumberOfK</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">lo, hi</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[lo] == k == nums[hi]:</span><br><span class="line">                <span class="keyword">return</span> [lo, hi]</span><br><span class="line">            <span class="keyword">if</span> nums[lo] &lt;= k &lt;= nums[hi]:</span><br><span class="line">                mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">                l, r = search(lo, mid), search(mid+<span class="number">1</span>, hi)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(l, r) <span class="keyword">if</span> -<span class="number">1</span> <span class="keyword">in</span> l+r <span class="keyword">else</span> [l[<span class="number">0</span>], r[<span class="number">1</span>]]</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        l, r = search(<span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> l == -<span class="number">1</span> <span class="keyword">else</span> r - l + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="54-二叉搜索树的第k个结点"><a href="#54-二叉搜索树的第k个结点" class="headerlink" title="54.二叉搜索树的第k个结点"></a>54.二叉搜索树的第k个结点</h3><h4 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一棵二叉搜索树，请找出其中的第k小的结点。</p>
<p>你可以假设树和k都存在，并且1≤k≤树的总结点数。</p>
<h4 id="解法：-48"><a href="#解法：-48" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthNode</span>(<span class="params">self, root, k</span>):</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> k: <span class="keyword">return</span> node</span><br><span class="line">            root = node.right</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="55-二叉树的深度"><a href="#55-二叉树的深度" class="headerlink" title="55.二叉树的深度"></a>55.二叉树的深度</h3><h4 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一棵二叉树，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h4 id="解法：-49"><a href="#解法：-49" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">TreeDepth</span>(<span class="params">self, pRoot</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        depthleft = self.TreeDepth(pRoot.left)</span><br><span class="line">        depthright = self.TreeDepth(pRoot.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(depthleft, depthright) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="56-数组中数字出现的次数"><a href="#56-数组中数字出现的次数" class="headerlink" title="56.数组中数字出现的次数"></a>56.数组中数字出现的次数</h3><h3 id="56-1-数组中只出现一次的两个数字"><a href="#56-1-数组中只出现一次的两个数字" class="headerlink" title="56-1.数组中只出现一次的两个数字"></a>56-1.数组中只出现一次的两个数字</h3><h4 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。你可以假设这两个数字一定存在。</p>
<h4 id="解法：-50"><a href="#解法：-50" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findNumsAppearOnce</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>: <span class="keyword">return</span> []</span><br><span class="line">        diff = functools.reduce(<span class="keyword">lambda</span> r, x: r ^ x, nums)</span><br><span class="line">        idx = <span class="built_in">len</span>(<span class="built_in">bin</span>(diff)) - <span class="built_in">bin</span>(diff).rfind(<span class="string">&#x27;1&#x27;</span>) - <span class="number">1</span></span><br><span class="line">        num1 = num2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> (num &gt;&gt; idx) &amp; <span class="number">1</span>:</span><br><span class="line">                num1 ^= num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                num2 ^= num</span><br><span class="line">        <span class="keyword">return</span> [num1, num2]</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="56-2-数组中唯一只出现一次的数字"><a href="#56-2-数组中唯一只出现一次的数字" class="headerlink" title="56-2.数组中唯一只出现一次的数字"></a>56-2.数组中唯一只出现一次的数字</h3><h4 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。你可以假设满足条件的数字一定存在。<br>思考题：<br>如果要求只使用 O(n) 的时间和额外 O(1) 的空间，该怎么做呢？</p>
<h4 id="解法：-51"><a href="#解法：-51" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:  <span class="comment"># 面试用装x解法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findNumberAppearingOnce</span>(<span class="params">self, nums</span>):</span><br><span class="line">        a = b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            a = (a ^ n) &amp; ~b</span><br><span class="line">            b = (b ^ n) &amp; ~a</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:  <span class="comment"># 常规解法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findNumberAppearingOnce</span>(<span class="params">self, nums</span>):</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> (n &gt;&gt; i) &amp; <span class="number">1</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt % <span class="number">3</span>:</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt; <span class="number">2</span>**<span class="number">31</span> <span class="keyword">else</span> ans - <span class="number">2</span>**<span class="number">32</span></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="57-和为S的两个数"><a href="#57-和为S的两个数" class="headerlink" title="57.和为S的两个数"></a>57.和为S的两个数</h3><h4 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<h4 id="解法：-52"><a href="#解法：-52" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindNumbersWithSum</span>(<span class="params">self, array, tsum</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> array:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(array) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> array[i] + array[j] &gt; tsum:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> array[i] + array[j] &lt; tsum:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> array[i], array[j]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h5 id="57-1-和为S的连续正数序列"><a href="#57-1-和为S的连续正数序列" class="headerlink" title="57 - 1.和为S的连续正数序列"></a>57 - 1.和为S的连续正数序列</h5><h6 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h6><p>输入一个正数s,打印出所有和为s的连续正数序列（至少含有两个数）。例如输入15，由于1+2+3+4+5=4+5+6=7+8=15；所以打印出三个连续序列1 ~ 5, 4 ~ 6, 7 ~ 8</p>
<h6 id="解法：-53"><a href="#解法：-53" class="headerlink" title="解法："></a>解法：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FindContinuousSequence</span>(<span class="params">self, tsum</span>):</span><br><span class="line">        low, high = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> low &lt;= tsum // <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>(<span class="built_in">range</span>(low, high + <span class="number">1</span>)) == tsum:</span><br><span class="line">                res.append(<span class="built_in">list</span>(<span class="built_in">range</span>(low, high + <span class="number">1</span>)))</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">sum</span>(<span class="built_in">range</span>(low, high + <span class="number">1</span>)) &lt; tsum:</span><br><span class="line">                high += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="58-翻转字符串"><a href="#58-翻转字符串" class="headerlink" title="58.翻转字符串"></a>58.翻转字符串</h3><h4 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串“I am a student.”，则输出“student. a am I”</p>
<h4 id="解法：-54"><a href="#解法：-54" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ReverseSentence</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(s.split(<span class="string">&#x27; &#x27;</span>)[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="59-队列的最大值"><a href="#59-队列的最大值" class="headerlink" title="59.队列的最大值"></a>59.队列的最大值</h3><h4 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组和滑动窗口的大小，请找出所有滑动窗口的最大值。例如，输入数组{2,3,4,2,6,2,5,1}和数字3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}。</p>
<h4 id="解法：-55"><a href="#解法：-55" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dq = collections.deque()             <span class="comment"># 使用双向队列解决本题</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">while</span> dq <span class="keyword">and</span> nums[dq[-<span class="number">1</span>]] &lt; v:   <span class="comment"># dq中如果存在多个元素</span></span><br><span class="line">                dq.pop()                     <span class="comment"># 一定是降序排列的</span></span><br><span class="line">            dq += i,</span><br><span class="line">            <span class="keyword">if</span> dq[<span class="number">0</span>] == i - k:               <span class="comment"># 判断dq中第一位是否有效</span></span><br><span class="line">                dq.popleft()</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:                   <span class="comment"># 满足滑动窗口长度才有输出</span></span><br><span class="line">                res += nums[dq[<span class="number">0</span>]],</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60.n个骰子的点数"></a>60.n个骰子的点数</h3><h4 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h4><p>将一个骰子投掷n次，获得的总点数为s，s的可能范围为n~6n。掷出某一点数，可能有多种掷法，例如投掷2次，掷出3点，共有[1,2],[2,1]两种掷法。请求出投掷n次，掷出n~6n点分别有多少种掷法。</p>
<h4 id="解法：-56"><a href="#解法：-56" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfDice</span>(<span class="params">self, n</span>):</span><br><span class="line">        dp = [<span class="number">0</span>] * (<span class="number">6</span> * n)</span><br><span class="line">        dp[<span class="number">0</span>:<span class="number">6</span>] = [<span class="number">1</span>] * <span class="number">6</span></span><br><span class="line">        <span class="keyword">for</span> time <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>): <span class="comment"># time 是次数，从 2 开始是因为下一行要计算本次的上限索引。</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>*time-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[i]=<span class="number">0</span>     <span class="comment"># 因为上一轮的计算到这没有用了，因为点不为 0，所以清空重新计算。</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> i &lt; j:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    dp[i] += dp[i - j]</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title="61.扑克牌中的顺子"></a>61.扑克牌中的顺子</h3><h4 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h4><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，大小王可以看做任意数字。为了方便，大小王均以0来表示，并且假设这副牌中大小王均有两张。</p>
<h4 id="解法：-57"><a href="#解法：-57" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isContinuous</span>(<span class="params">self, numbers</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        nums = [x <span class="keyword">for</span> x <span class="keyword">in</span> numbers <span class="keyword">if</span> x]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums) - <span class="built_in">min</span>(nums) &lt; <span class="number">5</span> <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="built_in">len</span>(<span class="built_in">set</span>(nums)) <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62.圆圈中最后剩下的数字"></a>62.圆圈中最后剩下的数字</h3><h4 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h4><p>题目：0,1,…,n-1这n个数字拍成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里身下的最后一个数字。</p>
<h4 id="解法：-58"><a href="#解法：-58" class="headerlink" title="解法："></a>解法：</h4><p><strong>递归法</strong> 代码不好理解并且递归深度大，不推荐。在牛客网上无法 AC 。但思路正确。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LastRemaining_Solution</span>(<span class="params">self, n, m</span>):</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span> <span class="keyword">or</span> m &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">else</span> (self.LastRemaining_Solution(n - <span class="number">1</span>, m) + m) % n</span><br></pre></td></tr></table></figure>
<p><strong>循环迭代法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">LastRemaining_Solution</span>(<span class="params">self, n, m</span>):</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span> <span class="keyword">or</span> m &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        last = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n + <span class="number">1</span>):</span><br><span class="line">            last = (last + m) % i</span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63.股票的最大利润"></a>63.股票的最大利润</h3><h4 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<h4 id="解法：-59"><a href="#解法：-59" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices</span>):</span><br><span class="line">        min_p, max_p = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices)):</span><br><span class="line">            min_p = <span class="built_in">min</span>(min_p, prices[i])</span><br><span class="line">            max_p = <span class="built_in">max</span>(max_p, prices[i] - min_p)</span><br><span class="line">        <span class="keyword">return</span> max_p</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="64-求-1-2-3-…-n"><a href="#64-求-1-2-3-…-n" class="headerlink" title="64.求 1+2+3+…+n"></a>64.求 1+2+3+…+n</h3><h4 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h4><p>求1+2+…+n,要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h4 id="解法：-60"><a href="#解法：-60" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getSum</span>(<span class="params">self, n</span>):  <span class="comment"># 递归也可以实现，但是数大了以后会超出递归栈的上限，所以 reduce 很棒。</span></span><br><span class="line">        <span class="keyword">import</span> functools</span><br><span class="line">        <span class="keyword">return</span> functools.reduce(<span class="keyword">lambda</span> x, y: x+y, <span class="built_in">range</span>(n+<span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65.不用加减乘除做加法"></a>65.不用加减乘除做加法</h3><h4 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h4><p>写一个函数，求两个整数之和，要求在函数体内不得使用四则运算符号。</p>
<h4 id="解法：-61"><a href="#解法：-61" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Add</span>(<span class="params">self, num1, num2</span>):</span><br><span class="line">        mask = <span class="number">0xffffffff</span>    <span class="comment"># 因为 Python 没有整型溢出，所以需要规定个范围掩码</span></span><br><span class="line">        <span class="keyword">while</span> num2 &amp; mask:   <span class="comment"># 当 num2 超过 mask 时，num1 也要和 mask 做 与</span></span><br><span class="line">            num1, num2 = num1 ^ num2, (num1 &amp; num2) &lt;&lt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num1 &amp; mask <span class="keyword">if</span> num2 &gt; mask <span class="keyword">else</span> num1</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>
<h3 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66.构建乘积数组"></a>66.构建乘积数组</h3><h4 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em> A[1]</em> …<em> A[i-1]</em> A[i+1]<em> …</em> A[n-1]。不能使用除法。</p>
<h4 id="解法：-62"><a href="#解法：-62" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">self, A</span>):</span><br><span class="line">        B = [<span class="number">1</span>] * <span class="built_in">len</span>(A)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(A)):</span><br><span class="line">            B[i] = B[i - <span class="number">1</span>] * A[i- <span class="number">1</span>]</span><br><span class="line">        tmp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            tmp *= A[j + <span class="number">1</span>]</span><br><span class="line">            B[j] *= tmp</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>
<p><a href="#00">回到目录</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/20/%E5%9B%BD%E9%98%B2%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/20/%E5%9B%BD%E9%98%B2%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" itemprop="url">国防科技大学 - 计算机体系结构笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-20T12:43:00+08:00">
                2020-02-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="体系结构技术发展"><a href="#体系结构技术发展" class="headerlink" title="体系结构技术发展"></a>体系结构技术发展</h1><p>流量强调的是在一定时间内完成的工作量，又称之为带宽；响应时间强调的是在一个请求提出之后得到回复的时间间隔，又称之为延迟。二者的核心内容是时间。</p>
<p>两个不同的计算机，X比Y快n倍，表示一个程序在X上的执行时间比在Y的执行时间快n倍。</p>
<ul>
<li>墙钟时间，wall time不一定是单调递增的。因为wall-time是指现实中的实际时间，如果系统要与网络中某个节点时间同步、或者由系统管理员觉得这个wall-time与现实时间不一致，有可能任意的改变这个wall-time。</li>
<li>response time响应时间</li>
<li>elapsed time</li>
</ul>
<p>benchmark用来评估计算机性能，有五种：真实程序、核心程序（应用内挖出来的典型应用）、简单程序（素数筛选等）、synthetic benchmark（组合程序）、benchmark suites（测试组件）。</p>
<p>最著名的测试组件：SPEC（system performance and evaluation cooperative），是一个benchmark suite，侧重于CPU内部的性能，是研究计算机的人员所侧重的，用来测试Unix工作站。</p>
<p>CPU performance：大部分计算机在一个特定时钟周期下工作，Clock time（CPU时钟）越高越快。</p>
<p>一个程序的CPU时间表示为占用的时钟周期乘以时钟周期数，或者占用的CPU时钟周期/CPU时钟工作频率，得到一共用了多少拍。</p>
<p>Instruction Count（IC）是指令数，与机器的指令系统和编译系统有关。<br>Cycles Per Instruction（CPI）用（CPU时钟周期数）除以指令数，是每条指令占用的节拍数，与硬件组织有关。IPC是二者倒过来。</p>
<p>所以，<code>CPU时间 = IC * CPI * Clock cycle time</code>，或者<code>CPU time = IC * CPI / clock_rate</code>。</p>
<p>3个基本原则：</p>
<ul>
<li>大概率事件优先，让最常见的事执行的最快。</li>
<li>Amdahl定律，可以找到系统的瓶颈在什么地方，且系统的性能是由系统最差的部分决定，一个系统是均衡优化的系统。</li>
<li>程序局部性原理，时间局部性（将来用的东西最大概率是我现在用的）、空间局部性（这次访问的下次可能再访问，出现内存中的热点部分）。</li>
</ul>
<h1 id="指令系统和基本流水线"><a href="#指令系统和基本流水线" class="headerlink" title="指令系统和基本流水线"></a>指令系统和基本流水线</h1><p>计算机指令系统：</p>
<ul>
<li>所有机器的指令系统相似，但都不一样；</li>
<li>桌面计算、服务器和嵌入式系统的指令系统有差别<ul>
<li>桌面系统要求同时有整数和浮点数，对容量的消耗不敏感</li>
<li>服务器中，浮点数运算不如整数运算和字符串处理重要</li>
<li>嵌入式系统对容量和大小更敏感</li>
</ul>
</li>
</ul>
<p>指令集分类是根据CPU访问存储器的方式分类的</p>
<ul>
<li>堆栈型，少见，最大的好处是程序员事先组织好数据，之后不需要管；</li>
<li>累加器型，部件少；</li>
<li>寄存器型，有寄存器-存储器、寄存器-寄存器型</li>
<li>存储器型。</li>
</ul>
<p>指令的四个方面：</p>
<ul>
<li>存储器地址</li>
<li>操作类型</li>
<li>操作数类型</li>
<li>指令编码</li>
</ul>
<p>访问内存时，首先要告诉，访问哪个地址，访问地址有多长。注意字节对准，对一个地址的访问需要成块成块的访问。</p>
<p>大端小端：如果数据超过一个字节，则数据的第一个字节放在哪个位置？第一个字节放的是高八位，则是大端。</p>
<p>寻址模式：可以减少指令数，但是增加了复杂性。越丰富的寻址方式给程序设计人员带来更大的便利，过于复杂的寻址方式降低了利用率。</p>
<p>现在所使用的数据有8位的、16位的、32位的、64位的。</p>
<p>常用的指令系统：</p>
<ul>
<li>逻辑运算指令，ADD，AND，OR</li>
<li>数据传输，LOADS、STORES</li>
<li>控制类指令，指令执行方向的改变所需的指令，jump、call、trap</li>
<li>系统类指令，实模式切换到保护模式等一些系统调用；进程切换时需要cache的清空指令</li>
<li>浮点类指令</li>
<li>字符串类指令</li>
<li>图形类指令，即数字图像处理类指令。MX、MXR等</li>
</ul>
<p>指令功能设计中，有一类指令是改变控制流的：</p>
<ul>
<li>条件分支，有条件转移</li>
<li>跳转，无条件转移</li>
<li>子程序调用</li>
<li>子程序返回</li>
</ul>
<p>这一类指令会影响到系统的性能，导致机器在运行中频繁执行切换，可以：</p>
<ul>
<li>直接形成条件码，设置特殊标志位</li>
<li>条件特别多，做一个条件寄存器</li>
<li>比较完直接拿结果</li>
</ul>
<p>操作数问题：最常见的操作数有如下几种:</p>
<ul>
<li>字符型</li>
<li>整数型，半字、字。</li>
<li>浮点型，32位短浮点和64位长浮点，尽量使用64位的，因为浮点数的误差和累计误差很大</li>
<li>十进制数，不紧缩的可以看成串，紧缩的是按照BCD码调整的，直接进行运算，一个字节放两位十进制数</li>
</ul>
<p>指令编码：经典的RISC机器都是固定四字节的指令长度，80x86指令长度从8位到48位，译码的时间过长，需要使常用的指令较短。</p>
<p>编译器大概有如下的过程：</p>
<ul>
<li>前端的语言处理</li>
<li>高级优化，与机器关联，考虑如何优化</li>
<li>全局优化，考虑寄存器分配和全局变量的存储</li>
<li>代码生成，依据机器进行生成代码</li>
</ul>
<p>一个地址会有很多中表示方法，这叫做“别名”，给编译优化带来了很大的问题。</p>
<p>MIPS实现：</p>
<ul>
<li>MIPS整数部分的子集，还包括存取字，整数ALU，基本浮点功能部件</li>
<li>过程<ul>
<li>Instruction Fetch：取出指令放到指令寄存器中，生成下一条指令的地址，当前指令地址+4，</li>
<li>Instruction Decode：译码，读取寄存器</li>
<li>execution/effective address：处理地址。<ul>
<li>访存指令，ALU得到地址，将结果放到寄存器中</li>
<li>register-register运算类指令， ALU执行操作码指定的运算，将两个寄存器中的值进行运算</li>
<li>register-immediate运算类指令，</li>
<li>分支指令，</li>
</ul>
</li>
<li>memory access：访存，访存阶段如果是运算类指令，则绕过访存直接进入寄存器，如果是分支类指令则有其他操作。</li>
<li>write back：写回，结果写入寄存器中，不管是从memory sytem或者ALU中来的。目标寄存器在两个位置之一（rd或rt），取决于操作码</li>
<li>这是一个五拍的工作过程</li>
</ul>
</li>
<li>流水线MIPS是再流水阶段增加流水线寄存器（锁存器），寄存器名字与它们连接的状态有关：<ul>
<li>IF/ID — ID/EX — EX/MEM — MEM/WB</li>
<li>共有四个。</li>
</ul>
</li>
</ul>
<p>提高并行化有三种出路：资源的大量使用、时间重叠、资源的共享。流水线以时间重叠实现并行。</p>
<p>流水线的操作步骤</p>
<ul>
<li>取指令：<ul>
<li>把存储器中的当前需要执行的指令，取出来放到IF/ID寄存器中</li>
<li>如果操作码是分支类指令，并且分支条件为true，把后边流水线计算的结果放到寄存器中，这个地方可能出现等待；否则就PC+4</li>
</ul>
</li>
<li>译码段：<ul>
<li>两个源操作数寄存器送到ID/EX</li>
<li>指令和下一个PC从IF/ID传到ID/EX</li>
<li>立即数进行扩展，因为立即数都是8/16位的，需要扩展后参加运算</li>
</ul>
</li>
<li>执行段：</li>
<li>访存段：<ul>
<li>对load/store指令，把锁存器的指令传过来</li>
<li>存储器的输出接过来</li>
</ul>
</li>
<li>写回段：<ul>
<li>写回到rd或者rt，因为其中一个是register-register指令，一个是register-immediate，所涉及的寄存器不同。</li>
</ul>
</li>
</ul>
<p>指令流出：指令从译码段进入执行段，并不是所有指令都可以流出，有的译码之后不能执行。</p>
<p>数据冒险：在一个指令执行的时候，所需要的数据（状态）对前边指令产生依赖关系，只有在流水线上才发生如此的依赖关系。</p>
<ul>
<li>四种可能的组合<ul>
<li>read after write</li>
<li>write after read</li>
<li>write after write</li>
<li>read after read(不是冒险)</li>
</ul>
</li>
</ul>
<p>空转（Stall）：机器并没有停但是没有干什么，出现冒险时控制器插入stall，避免某些指令的提前，可以通过比较流水线寄存器来检测冒险。</p>
<p>定向（旁路，bypass）：为了尽早获得数据，减少因为数据冒险而导致的空转，越早拿到数据，空转的周期越少。</p>
<p>流水线的分支会产生问题，已经有一组指令进来了，但是可能会进入另一个分支，在译码阶段就知道了，将需要进行计算的分支条件进行提前判断。</p>
<p>例外/异常（Exception）：</p>
<ul>
<li>IO设备请求</li>
<li>调用操作系统服务，通过和异常类似的方法处理操作系统的使用</li>
<li>断点</li>
<li>整数上下溢出</li>
<li>浮点计算异常</li>
<li>缺页</li>
<li>寄存器访问未对准</li>
<li>使用了非法指令</li>
<li>硬件故障</li>
</ul>
<p>有一些例外是同步的，有一些是异步的（网络请求，IO请求）；<br>可屏蔽的中断和不可屏蔽的中断；<br>指令间的和指令内部的；</p>
<p>机器能够在碰到例外后进入一种有序的状态，作为体系结构设计的时候，当发生例外并被处理之后，可以实现状态“可预测”，有很多种策略：</p>
<ul>
<li>强迫指令流中止，但是如果流水线长且可以乱序执行时难以实现；</li>
<li>不允许产生例外的指令把结果放入寄存器；</li>
<li>例外处理程序将PC保存下来。</li>
</ul>
<p>精确异常：明确地确定哪一条指令导致了例外，这种情况下称为精确的异常处理。机器内部导致的例外可以精确定位，外部请求导致的例外不用定位。例外和指令处理的各个步骤均相关：</p>
<ul>
<li>IF：取指令时的缺页中断，内存访问的不对齐，存储器保护错误</li>
<li>ID：译出来的指令不知道是什么</li>
<li>EX：计算意外</li>
<li>MEM：页失效，不对准等</li>
</ul>
<p>流水线中的多周期：有些指令耗时长，有些耗时短，如果指令执行时间差距不大倒还好，可以均切分。指令过长导致流水线出现：指令在执行中间出现机器调度不确定性；导致浮点部件在结构上出现冒险，搞不清楚指令到底执行完了没有，或者在等待结果的时候不知道能不能等到。</p>
<p>如果不能把所有部件设计成等长，则设计成不等长，在MIPS中，把执行段设计为4个部件：整数部件、浮点加、乘、除四个部件，其他不变。</p>
<p>流水线的延迟和执行下一条指令要等多久，这两个时间是流水线的重要属性。</p>
<p>流水线中结构不足所导致的风险，和流水线密度所导致的风险（每一拍所产生的结果与前后都有依赖，具有反馈性，需要保证旁路通道多）</p>
<p>指令结束的次序与指令输入的顺序不一定一样，先写后读的风险大得多。</p>
<p>动态调度和静态调度：静态调度又称为编译器调度，在程序执行之前对程序的指令进行排序；动态调度是开始执行发现执行顺序不好，则重新进行排序，通过硬件办法重新排序减少机器空转，优点是对于程序静态分析时看不出来的情况可以进行调度，编译器也可以简化，且硬件的事可以交给硬件自己去做，但是硬件成本大大增加，复杂性增加。</p>
<p>为实现动态调度，流水线必须具备以下功能：</p>
<ul>
<li>允许按序取多条指令和发射多条指令——取指(IF)流水级允许按顺序取多条指令进入单口暂存器(single-entry latch)或队列(queue), 指令然后从latch或queue取出，进入ID节拍。</li>
<li>能检查并消除hazards——将ID流水级分为独立的两级：Issue级和Read operand级：<ul>
<li>Issue级功能——指令译码，检查是否存在结构冲突(即在这一流水级解决结构冲突问题)；</li>
<li>Read operands级功能——等到无数据冲突(RAW)后， 读出操作数，即在这一流水级解决数据冲突问题。 </li>
</ul>
</li>
</ul>
<p>记分牌算法。需要足够资源和没有数据相关，记分牌是枢纽，所有的指令都要经过它留下执行的记录和依赖条件，如果记分牌决定指令不能立即执行，会将指令进行重排并决定何时可以执行。</p>
<p>记分牌是一集中控制部件，其功能是控制数据寄存器与处理部件之间的数据传送。在记分牌中保存有与各个处理部件相联系的寄存器中的数据装载情况。当一个处理部件所要求的数据都已就绪（装载完毕），记分牌允许处理部件开始执行。当执行完成后，处理部件通知记分牌释放相关资源。记分牌中记录了数据寄存器和多个处理部件状态的变化情况，通过它来检测和消除或减少数据相关性，加快程序执行速度。</p>
<p>如果在MIPS上做记分牌，要在指令的译码阶段检查结构和数据冒险。可以解决：写后读相关，解决乱序结束。把指令译码阶段分成两个部分，指令的结构冒险和数据冒险给它分开，所以要拆成两步。</p>
<ul>
<li>第一步：指令流出，条件是它所使用的功能部件是空闲的且所要写的目标寄存器没有被别人写，检查了结构冒险和数据冒险中的写后写冒险，因为前边可能有超长的指令还没完成。</li>
<li>第二步：读操作数，指令流出之后，所要的数据还没来，这条指令读操作数就读不出来，就要等结果。</li>
<li>第三步：运算，直到运算完成。</li>
<li>第四步：写回，检查读后写冒险，等别人把数据读走之后再写。</li>
</ul>
<p>记分牌并没有发挥定向通道的优势，必须读写分开。</p>
<p>总结一下：<br>动态调度技术需要将ID译码段分成两个阶段：1是发射，2是读取操作数。发射阶段对指令进行译码，检查结构冒险（例如有四个运算器：整数运算、加法器、乘法器、除法器，检查该指令需要使用的运算器是否正在被占用）读取操作数阶段检查数据冒险（读之前检查寄存器的值是否已经写回，或者是否会覆盖了之前的值）。数据冒险的解决方法（读写冒险(RAW)：将指令和操作数保存起来，然后只能在读操作数阶段进行读取；写写冒险(WAW)：检测是否有其它指令会写回到相同的寄存器（检测到冒险），有则等待，直到其它的完成）</p>
<p>发射阶段：假如检测到没有结构冒险和数据冒险，那么记分板将会将指令发射到相关的运算器，假如结构冒险或者写写冒险发生了，那么该指令将会等待，直到冒险消失为止。我要使用的功能部件忙标志位为否且指令所要写的状态是空。填写三个寄存器（目标寄存器，第一、二操作数寄存器，填写的是寄存器编号）</p>
<p>读取操作数：没有数据相关了以后（之前的指令不会写回源寄存器或者正在写寄存器的情况时，读写冒险），读取操作数。读取操作数后将交给运算器，之后开始运算。发送到运算器的顺序可能是乱序的。</p>
<p>之后就是执行段以及写回段了。没啥好说的。执行段在完成计算以后会通知记分板。记分板直到计算已经完成了，那么它进行读写冒险检验（即写之前是否已经读取了寄存器的值，例如 ADD F10,F0,F8 SUB F8,F8,F14，这里SUB指令写回时要检查ADD指令的F8是否已经读取了，仅此而已）假如检测到冒险，则等待，不然就可以写寄存器了。</p>
<p>记分牌的构成：</p>
<ul>
<li>指令状态，</li>
<li>功能部件状态，很多个域<ul>
<li>Busy 标识该器件是否正被使用</li>
<li>OP 该器件正在执行的运算 例如 + - * / 等等</li>
<li>FI 目标寄存器</li>
<li>Fj，Fk：源操作寄存器</li>
<li>Qj，Qk： 如果这两个数据没有谁将生成这个数据（源操作寄存器正在被什么单元所处理），如果是NO的话说明已经拿到数据了或者数据尚未准备好</li>
<li>Rj, Rk 表示Fj Fk是否准备好的标志位</li>
</ul>
</li>
<li>寄存器状态，标识哪一个存储器将会被写回</li>
</ul>
<p>这是一种以记分牌电路为核心的设计方法。 </p>
<h1 id="指令级并行（ILP）"><a href="#指令级并行（ILP）" class="headerlink" title="指令级并行（ILP）"></a>指令级并行（ILP）</h1><p>指令之间有一种特征，可能会并行地执行而不影响结果，正是要挖掘这个特点使指令并行地执行。一种是动态办法（依赖硬件定位并行性），一种是静态办法（依赖软件）。</p>
<p>流水线CPI = 理想流水CPI + structural stalls + data hazard stalls + control stalls</p>
<p>先进的流水线：不区分动态静态和软硬件，所有的技术都与编译器结合。</p>
<p>ILP的概念：</p>
<ul>
<li>基本块：一个没有分支的指令块</li>
<li>串行代码：只有少量的并行性。</li>
<li>操作系统代码的基本块较长</li>
</ul>
<p>跨越多个基本块的指令级并行主要是在循环级探讨并行性，这是最常用的提高并行性的方法。需要将循环级并行转成指令级并行。最常用的方法是循环展开，可以通过编译器或者硬件实现。循环的每一次迭代执行可以与其他迭代重叠，需要确保循环中涉及的数据不会干扰。</p>
<p>向量处理器作为专用部件应用在图形处理器中。</p>
<p>数据相关和数据冒险：相关导致冒险，冒险导致空转，空转导致流水线效率下降。数据相关可能会产生冒险，尽可能减少机器的空转。</p>
<p>名相关：分为两条指令都写相同寄存器和读后写两种，读后写可以通过名字的改变消除。</p>
<p>区分数据相关和名相关：是否在指令之间发生了数据传输，数据相关发生了，名相关没发生。克服名相关可以寄存器重命名。</p>
<p>控制依赖的调度有两个基本原则：与分支指令控制相关的指令不能调度到分支指令之前去，与分支指令无关的指令不能调度到分支之后。</p>
<p>数据流前后的依赖关系需要数据依赖和控制依赖的协调，且数据流依赖设计链式依赖。</p>
<h1 id="Tomasulo算法"><a href="#Tomasulo算法" class="headerlink" title="Tomasulo算法"></a>Tomasulo算法</h1><p>核心思想：硬件的动态指针技术。动态解决RAW，允许指令乱序流出。</p>
<p>两点显著不同：冒险检测机制不像记分牌一样集中在电路上，而是分布在算法中的。不检查WAR和WAW，因为已经被算法消除了。</p>
<p>重要概念：保留站（一种虚拟功能部件）。就是一个缓冲，每个保留站中保存一条已经流出并等待到本功能部件执行的指令（相关信息）。里边保存了指令和操作数，以及等待执行的所有条件。</p>
<p>在一条指令流出到保留站的时候，如果该指令的源操作数已经在寄存器中就绪，则将之取到该保留站中。如果操作数还没有计算出来，则在该保留站中记录将产生这个操作数的保留站的标识。</p>
<p>也发挥了寄存器重命名的功能，原来访问寄存器a，缓冲以后，不再访问寄存器a，而是去访问缓冲。</p>
<p>记录和检测指令间的相关，操作数一旦就绪就立即执行，把发生RAW冲突的可能性减少到最小；通过寄存器换名来消除WAR冲突和WAW冲突。 </p>
<p>过程：</p>
<ul>
<li>从指令队列的头部取一条指令。<ul>
<li>如果其操作数在寄存器中已经就绪，就将这些操作数送入保留站r。</li>
<li>如果其操作数还没有就绪，就把将产生该操作数的保留站的标识送入保留站r。</li>
<li>一旦被记录的保留站完成计算，它将直接把数据送给保留站r。</li>
<li>如果没有空闲的保留站，指令就不能流出。</li>
</ul>
</li>
<li>操作数来了之后运算。两个操作数都就绪后，本保留站就用相应的功能部件开始执行指令规定的操作。</li>
<li>得到结果后放到共用区域（common data bus），共用区域链接所有可能需要数据的部件，cdb发出广播，所有需要这个结果的部件将同时拿到这个结果，这样可以大大减少连线量。在具有多个执行部件且采用多流出（即每个时钟周期流出多条指令）的流水线中，需要采用多条CDB。每个保留站都有一个标识字段，唯一地标识了该保留站。</li>
<li>拿到结果之后结果再消失，数据放到了公共区域，那么要写的目标寄存器也要到公共寄存器去拿，减少了仲裁机构调派部件拿数据的过程。</li>
<li>所有保留站有各种标志，用来进行各种数据状态的检查。</li>
</ul>
<p>执行步骤：</p>
<ul>
<li>首先把浮点指令送到指令队列</li>
<li>没有结构风险的时候就把指令流出</li>
<li>根据需要送到确定的运算部件或访存部件</li>
<li>load或store把指令送到访存的缓冲中去</li>
<li>如果访存操作数没有被取到，就把产生这个数的浮点功能部件的编号取过来，实现了寄存器到保留站的重命名过程，把寄存器重命名到保留站，消除了同名。</li>
<li>结果有效时，写到cdb中。</li>
</ul>
<p>每个保留站有以下6个字段：</p>
<ul>
<li>Op：要对源操作数进行的操作。</li>
<li>Qj，Qk：将产生源操作数的保留站号。<ul>
<li>等于0表示操作数已经就绪且在Vj或Vk中，或者不需要操作数。</li>
</ul>
</li>
<li>Vj，Vk：源操作数的值。<ul>
<li>对于每一个操作数来说，V或Q字段只有一个有效。</li>
<li>对于load来说，Vk字段用于保存偏移量。</li>
</ul>
</li>
<li>Busy：为“yes”表示本保留站或缓冲单元“忙”。</li>
<li>A：仅load和store缓冲器有该字段。开始是存放指令中的立即数字段，地址计算后存放有效地址。</li>
<li>Qi：寄存器状态表。<ul>
<li>每个寄存器在该表中有对应的一项，用于存放将把结果写入该寄存器的保留站的站号。</li>
<li>为0表示当前没有正在执行的指令要写入该寄存器，也即该寄存器中的内容就绪；非全0的时候时保留站的编号。</li>
</ul>
</li>
</ul>
<h1 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h1><p>当指令流出速度快时，流水线中的指令是多指令流出，如果遇到分支则会出现问题。前边讲过静态的分支预测，假设分支总是成功/不成功等条件，很好的帮助程序提高性能。动态分支预测使用硬件对程序进行预测，依赖于程序的动态特征和执行过程。在分支预测时，假设分支指令是成功或不成功。</p>
<p>分支预测的精确程度、预测正确和不正确的开销比较都会影响分支预测是否成功。最简单的分支预测方法是看上次的分支结果。</p>
<p>一种办法是BPB（Branch Prediction Buffer），记录分支历史的进入分支数，用于下一次分支特征的预测。记录一个分支指令成功或不成功，放入缓冲中，下一次指令再来的时候查这个缓冲，有多大程序就有多大缓冲，因为程序中哪个是分支不知道。通过指令地址进行记录的同等检索，下次再进入的时候再检查是成功还是不成功。BPB的buffer还是个小的寄存器，用指令的地址进行同等检索，所记录的是分支指令发生还是不发生。</p>
<p>绝大部分指令不是分支指令，如何把分支预测缓冲做的小，比如做到一半那么大。采用地址折半，上半截主存和下半截主存映射到同一块地址，并且实际预测正确率不降低。减到一半还嫌多，那就先做一个512个入口的缓冲，使用指令地址的低位来访问缓冲，效果也不错。这样就是取模了，可能会冲突，如果问题严重的话就加大分支预测缓冲，分支预测错了则将那一位反转。根据被预测指令是否成功画出状态转移图：<br><img src="/img/20200225001.jpg" alt=""></p>
<p>上图只有一位，比较浅薄。可以让历史更深一点，再加一个位，构成两位的分支预测。一个预测必须失败两次后才能改变。对4k的缓冲，最高命中率达到82-99%，这么高的命中是因为可能有的程序有很多循环。<br><img src="/img/20200225002.jpg" alt=""></p>
<p>浮点指令猜错的概率要比整数指令猜错的概率小，因为浮点计算主要面向科学计算，循环多，所以猜错概率小。</p>
<p>预测器的位数在2位和n位的时候差别不大，所以很多系统只使用2位的分支预测。做4k个入口和更多的入口效果差不多，所以只有4k个入口就够了。</p>
<p>相关分支预测，现在的分支预测是不是成功要根据上一个分支预测是不是成功，实际上是做两级，即做两个1位分支预测器，如果上一次预测成功则使用一个预测器，如果上一次预测不成功则使用另一个预测器，使得本条分支预测的结果基于上一次分支预测。</p>
<p>多指令流出：每个中期发出4-8条指令，必须要使得指令流得到更大的带宽，有三种方法：</p>
<ul>
<li>分支目标缓冲（BTB），另外一种动态分支预测方法，在取指令阶段对btb进行搜索，如果不在表中就看是不是分支指令，而且是不是成功的分支指令，如果是，但是表中没有，则放进去，如果表中有了就直接拿出来执行；如果不在btb中且不是成功分支（不是分支或不是成功的分支），这种情况下IF没有困难，都是PC+1，。通过查表提前知道对应的pc值和next program counter，只要之前这个指令来过，就记下来分支地址和它的转移目标地址，下一个IF到来的时候就不需要取指令了。</li>
<li>集成化指令分派部件</li>
<li>预测返回地址</li>
</ul>
<p>分支预测的一个变种：branch folder，不仅有PC和next PC，还把指令放到表中，直接在译码段就开始比对。</p>
<p>两种办法可以使得机器一拍流出一堆指令，使CPI小于1，超级标量处理器，一种是VLIW（very long instruction word）。超标量是标量集合，把彼此不太关联的一些指令组合起来，一次发出的是若干个指令，每拍流出的指令数是变化的。可以采用动静态方法实现超标量，机器不存在在执行中调整指令顺序的能力，编译器对指令顺序进行调配，调整了优化参数打开超标量之后可能会不对！</p>
<p>VLIW指的是一条超长指令字，经典的概念是不允许乱序流出的。它是一个拥有固定数量指令的指令包，有若干种特定类型的指令组成，机器一次发出的是一个指令包。</p>
<p>静态调度超标量：指令有序流出，所有的流水线冒险都必须在编译时预先检查，在流出时如果有冒险就不允许流出。编译器的工作量非常大。</p>
<p>现在使用的超标量是把指令打一个包，让他去执行，这个指令包一般会对指令有要求，指令流出时一拍内流出多条，指令总线做宽一点，大家排好队一起往前走，这样很简单，但是电路实现很复杂，指令要控制好先后顺序，不能出现无序流出。还可以把指令流出这一步切成流水线，把流水线本身的一站作为子流水线。</p>
<p>超标量机器指令取：取指令并用64位译码器译码。</p>
<ul>
<li>从cache中取两条指令；</li>
<li>确定是没有指令、1条指令还是两条指令；</li>
<li>把它们送到正确的功能部件。</li>
</ul>
<p>静态超标量不允许乱序流出，有一些特定的顺序不可乱。</p>
<p>指令流出的过程中，允许两个指令同时流出，有一个限制，浮点指令流出时需要一个整数指令寄存器，在进行整数和浮点调度时，不能分开调度，要统筹考虑。</p>
<p>现在所使用的超标量寄存器每个时钟4条以上，包括了上述两种方法。实际上对RISC机器流出4条多。像x86机器可能流出3条，但是这三条CISC指令可以拆出20多条指令。</p>
<p>超标量的时候有一些限制：</p>
<ul>
<li>浮点功能部件不能被充分利用，需要更少的整数操作；</li>
<li>需要大量的指令级并行（相关性很小的部分）；</li>
<li>超标量时一个循环的判断分支带来了不能并行的阻碍。</li>
</ul>
<p>控制的相关性引发的控制冒险可能会导致指令的“空槽”，超标零的性能被限制，需要前瞻执行，用来克服类似分支指令导致的麻烦。最好能够把分支指令当成普通指令直接扔进去执行。</p>
<p>基于硬件的前瞻和预测：允许指令提前流出执行。必须有动态分支预测，前瞻是一种保证，保证预测不会影响全局。加上动态调度。必须要有undo的功能，来处理前瞻执行不正确的情况，这样实质上是基于大量缓冲的功能。</p>
<p>基于硬件的前瞻性执行做了一个确认段，实行基于数据流的检查，只要数据流是正确的，就可以保证执行是正确的，因此要添加确认段，确认正确了再写进去。这里隐含了一点，指令可以乱序流出执行，但是确认是顺序的，这说明指令在通过指令流出部件的时候被打上了某种标记来标志它的顺序。所有的结果包括例外都要得到确认。</p>
<p>机器基于硬件实现前瞻，采用复杂电路解决的是分支问题（控制相关问题），指令级并行开发的深的话，如果不能提供足够的并行度，则造成浪费。硬件的前瞻执行是分支指令的预测过程，很多指令通过这种办法在控制相关未解决的情况下执行了。确认执行错了之后，可以回退，撤销之前的执行。</p>
<p>执行乱序、确认有序是一个排队等待的过程，要有一种排队机制来支持确认，它实际上是一个缓冲过程，这个排队过程称为ROB（再定序缓冲，Reorder Buffer），保存对机器执行有影响的状态。保存已经执行完但是没有提交的指令的结果，提供额外的寄存器作为保留站。</p>
<p>三个重要的ROB域：</p>
<ul>
<li>操作域，用来保存指令，例如分支指令、load/store指令、寄存器操作指令；</li>
<li>目标域，记录目标寄存器，可能是寄存器也可能是存储器的地址，这个结果要被写到哪里；</li>
<li>值域，在确认的时候保存结果，直到指令真正被执行。</li>
</ul>
<p>工作流程：</p>
<ul>
<li>指令流出<ul>
<li>如果有保留站且再定序缓冲有空，指令流出，一条指令流出至少要占用两个资源。如果指令所需数据在寄存器中或再定序缓冲中存在，则取出来送到保留站。</li>
<li>指令流出的时候先做一些分类，之后做译码，决定做什么操作，扔到运算部件去。</li>
<li>进行标志状态的修改</li>
</ul>
</li>
<li>指令执行<ul>
<li>如果有操作数未准备好，就监视CDB（common data bus），这个过程检查数据相关；</li>
<li>指令可能会等很多拍</li>
</ul>
</li>
<li>写结果</li>
<li>确认过程</li>
</ul>
<p>一个store指令的确认：前提是被确认的指令到了再定序缓冲的顶部，要把结果寄存器更新掉，把它从ROB种清除掉。</p>
<p>一个不正确的分支预测表明前瞻执行是错误的，刷新ROB，重新从正确的分支开始执行，一个正确的分支预测则使得这个分支与正常的指令类似。</p>
<p>浮点程序中的分支是有极强的规律性的，整数程序中的分支不明显。</p>
<p>基于存储器地址的前瞻性执行：减少对于顺序地址计算的限制，使用硬件预测依赖。</p>
<p>堆栈、寄存器的使用对ILP的效率影响。<br>别名分析：对程序执行的并行性有影响。</p>
<p>只有发现依赖之后才前瞻，首先找到相关性，相关性基础上处理器进入前瞻状态。</p>
<p>数据值预测/地址值预测：很难，是一种很精确的前瞻方法，不允许有误差，。如果能进行完美的值预测，则不需要编程啦。</p>
<p>线程级并行：可以以线程的方式组织程序运行，一个线程是一个独立拥有数据和指令的实体。可以根据需要派生线程。多个线程并发执行有一个重要概念：同时多线程（SMT），既能同时执行，也要同步。</p>
<h1 id="编译调度"><a href="#编译调度" class="headerlink" title="编译调度"></a>编译调度</h1><p>使用编译技术提高流水线性能，减少因为数据冒险导致的阻塞和分支预测。</p>
<p>假定使用5站流水线，已经完全流水，如果没有相关性则会顺畅地流下去，没有任何阻塞；如果有分支指令则在分支指令及其前一个指令之间有1拍延迟，整数部件load有1拍延迟，整数部件无延迟。</p>
<p>如果是分支指令，取指令1拍，指令译码1拍，产生结果得到分支目标1拍，这个结果不经过任何过程再返回。如果采用锁定机制（发现是分支指令就不取下下一条指令了），这时已经到指令译码了，刚好已经取进来一条了，这就叫做分支延迟槽，再往后的指令先停下，跟进来的这条指令就允许向下流，或者更彻底，只要发现了是分支指令，跟着进来的那个也不管了，这会导致两拍的开销。</p>
<p>循环展开、指令调度、寄存器重命名。</p>
<ul>
<li>确定指令的调整是否是有效的，移动的指令不影响执行结果；</li>
<li>确定循环和循环之间不存在相关性；</li>
<li>使用不同寄存器避免在使用相同寄存器时的不必要约束；</li>
<li>在循环展开时注意处理结尾的迭代；</li>
<li>明确load和store在循环展开时是否可以交换，不同迭代的load/store相互独立，分析内存地址明确是否是同一地址</li>
<li>如果存在相关性，必须确定和原始代码的相关性一致。</li>
</ul>
<p>通过使用寄存器重命名，在两次迭代之间减少相关性，而不影响一个迭代内部的相关性，也有代价，比如多用几个寄存器，或者代码体积会增大，编译器更复杂。</p>
<p>有的情况下编译时就能预测分支是否成功，它的成功率分布很离散，从9%到59%。改成基于方向的，如果程序到了分支，如果程序往前走（可能是if），认为不成功的概率居多，如果往回走（循环），成功的概率居多，猜错率在30%-40%。</p>
<p>改一下，使用程序的上下文信息，每次预测的时候使用上一次预测的结果，可能会生成更精确的预测；再进一步地，基于统计信息，先得到一些统计信息，基于统计预测分支的走向，这种方法的指导性很不强。</p>
<p>超长指令字机器，首先要确定机器的最大并行度，全靠软件做，先把指令打包，确定封装包之间的相关性，在所有的指令中间，确定一条指令跟正在被处理的所有指令是否相关。</p>
<p>静态超标量通过编译器调度来帮助处理器达到更高的性能，动态超标量不需要编译器调度，但是需要硬件的开销。</p>
<p>超长指令字是对编译器及其依赖的一种技术，最小化潜在的数据冒险延迟，将一些指令封装进一个流出包中，也不需要检查潜在的相关性，执行中认为去拿的数据一定是对的，如果没有一定的保障，则可能会拿不对的数据，需要编译器进行控制，编译器需要控制指令包内、包之间的相关性，好处就是硬件会很简单，不需要考虑前瞻和相关性，仍然能达到很高的性能，VLIW使用多个独立的功能部件，把一组指令按某种方式组合，构成一个长指令字向外发送。</p>
<p>每一个VLIW功能部件需要16-24个二进制位来表述功能部件完成的工作和寄存器。可能包含七个部件：2个整型部件，2个浮点部件，2个内存，1个分支部件。一个长指令字里出去的指令应该都是无关的，部件之间不存在数据交换通道。</p>
<p>早期超长指令字格式非常死板，这个地方是一个整数就是一个整数，指令部件就是一条一条往运行部件送，代码二进制不兼容，必须要依靠硬件和软件的适配。所以很难见到超长指令字机器。如果打包的时候没有要求的操作往里填，则填空指令，指令槽的利用率可能会比较低。</p>
<p>VLIW问题：</p>
<ul>
<li>代码数量增加了；</li>
<li>每个指令之间是互锁的，在执行的时候如果一个指令被卡住，后边都会被卡住；</li>
<li>二进制代码不兼容，如果有部件的增删，则要重新编译代码。</li>
<li>VLIW对循环展开的次数要求很高，可能不够展开的；</li>
<li>对功能部件利用率比较低，需要插入很多的空指令。</li>
</ul>
<p>VLIW有压缩的余地：把立即数提出来生成一个立即数域；程序在执行之前可以压缩，从存储器中取出来的时候再解压缩。</p>
<p>互锁机制：所有功能部件操作是同步的，不用判断数据相关，编译器解决，硬件就不用解决了，有一条指令阻塞了，其他的都会被堵住。如果在访存的时候碰到了，访存时间可能很长，指令之间的互锁机制会使性能不可忍受。很多机器在处理时将一些部件从互锁机制解开了，编译器也会解决互锁。对指令流出之后，可以不同步执行。</p>
<p>二进制代码的兼容性跟指令集、流水线结构、功能部件的结构/数量相关，这是超标量机器占主导的主要原因。</p>
<p>代码迁移过程：实用的是对代码进行调整和转换，例如在执行的时候把串行转换成VLIW。</p>
<p>指令的多流出和向量处理器：成本是相当的，向量处理器性能高些；多指令流出对代码要求比较低，不需要向量化，且多存储器的带宽要求比较低。向量往往作为处理器的加速部件。</p>
<h1 id="开发ILP的高级编译技术"><a href="#开发ILP的高级编译技术" class="headerlink" title="开发ILP的高级编译技术"></a>开发ILP的高级编译技术</h1><p>通过一部分硬件的支持（前瞻），通过软件技术的方法（编译）提高并行性。</p>
<ul>
<li>循环级并行：检测和减少迭代之间的依赖，找到并行性。</li>
<li>软件流水线：一种循环展开的过程，解决面向不同应用的问题，不用根据体系结构进行优化。</li>
<li>路径调度：控制指令相关的调度策略，将执行过程看成一个路径。</li>
</ul>
<p>检测相关性：</p>
<ul>
<li>进行代码调度</li>
<li>检测循环是否有并行性，检测在执行中时间上的概念</li>
<li>减少名相关</li>
</ul>
<p>一旦涉及到循环，数组和指针是最头疼的，一个有效工作的循环一般都有数组和指针，也就存在别名（alias）问题，这往往因为数组或向量下标引起的。也需要去找是否存在环状的相关性。</p>
<p>相关发生在两遍循环之间的问题经常存在，一次迭代使用了上一次迭代的结果。只要不存在这种相关性，即使存在其他的相关性，也可以同时流出。</p>
<p>如果一个for循环存在两边循环之间的相关，需要破坏掉相关才能实现并行性，如果没有相关环的话就可以破坏，如果能把上一遍循环的计算拉到这一次循环中计算，这样就能不依赖于另外一次循环。对于两次相关的爹地啊，相关的语句放到一起，不相关的语句拆开放到两次迭代中。语句之间影响并行的因素就清除掉了，但是循环之间必须保存的有序性也要保存。</p>
<p>相关性的检测：可以获得的并行性收到循环次数的限制，循环展开的次数越多越好，有的循环没有那么多次可以供你展开，循环展开也需要更多的硬件资源。需要知道循环不同遍之间是不是访问的相同的地址？更复杂的分析需要知道两次访存是不是请求的相同的（多个）地址。</p>
<p>递归：存在某种相关性，关联很确定，存在比较多的并行性。</p>
<p>两边循环出现循环相关的距离即为相关元素的间隔。相关距离越大，相关的冒险越小，导致机器阻塞的概率也越小，通过循环展开获得的潜在并行性也越大。如果相关距离是5，那可以循环展开得到4个副本，循环距离变为1，如果把循环距离为1的循环展开的话，循环距离不会改变。 </p>
<p>如果展开的话可能会增加一些相关性，因为要把一些计算提前，越是循环次数远的，相关性就越长，这样就给并行以机会。</p>
<p>编译器检测相关性：水平极其有限，假设下标函数构成仿射函数，就是一个线性函数，被写成<code>a ( x * i + b)</code>的形式，a和b是常数。</p>
<p>检测循环中是否有相关性，即检测可能数据相关的两个语句所代表的两个仿射函数是否有整数解，如果有，则可能相关。</p>
<p>从理论上说，编译时不能确定认为变量相关，可能会存在一组整数解，但是可能取不到这一组解，可能与加载的运行负载有关。相关检测可能会成本很高，基本就是程序执行的一个过程，每一次迭代之间都可能存在这个问题。</p>
<p>GCD Test：如果不是存在整数解，而在两个仿射函数<code>a ( x * i + b)</code>和<code>c ( x * i + d)</code>中，GCD(c, a)能被(d-b)整除，则可能存在相关性。</p>
<p>编译器如何工作：在检测相关性时进行分类，识别名相关并通过重命名或副本技术消除掉，在分析时主要分析真相关（先写后读相关）、输出相关（写后写相关）、反相关（先读后写相关），其他的都是伪相关。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">	Y[i] = X[i] / c;  /* S1 */</span><br><span class="line">	X[i] = X[i] + c;  /* S2 */</span><br><span class="line">	Z[i] = Y[i] + c;  /* S3 */</span><br><span class="line">	Y[i] = c - Y[i];  /* S4 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Y[i]存在很多相关，写后读、写后写等，S1 S3与S4中的Y[i]存在相关，可以消除，S1中的Y[i]使用中间变量替代；X[i]存在读后写相关，S2中的左边X[i]是最终结果了，不能用临时变量替换，要生成一个临时数组。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">	T[i] = X[i] / c;  /* S1 */</span><br><span class="line">	X1[i] = X[i] + c;  /* S2 */</span><br><span class="line">	Z[i] = T[i] + c;  /* S3 */</span><br><span class="line">	Y[i] = c - T[i];  /* S4 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在的结果是都用了数组，其实对Y的处理可以使用临时变量。编译器可以把替换Y的临时变量使用寄存器搞。</p>
<p>编译器可以：做指令的相关性分析，确定访存地址和循环展开的成本；对循环级并行，是不是循环有利于并行；访存是不是存在相关。</p>
<h1 id="软件流水和路径调度"><a href="#软件流水和路径调度" class="headerlink" title="软件流水和路径调度"></a>软件流水和路径调度</h1><p>对硬件需求少。<br>软件流水是一种展开技术，相关性更少一些，得到更大的并行性。是一种对循环的重组技术，从每一遍循环里面提取公用的指令，构成新的循环，这个循环过程中间，从循环体来看，看不到一遍一遍的循环展开，但是从执行上看是在一遍一遍循环执行。</p>
<p>循环的每次迭代是一个指令序列，按照每个循环指令序列平行展开，认为一次循环内的相关指令的相关距离小于两次循环之间的相关指令的相关距离。<br><img src="/img/20200229001.jpg" alt=""></p>
<p>竖着的四条指令更可能相关，横着的四条指令相关指令距离更大，相关距离越大则相关冒险更小，所以可以横着实现并行且指令的顺序跟竖着是一样的。对循环重组，横向取指令，总的想法是把原本竖着的循环翻转过来。构成了一个像新的循环像流水线一样的相关距离更大的循环。</p>
<p><img src="/img/20190229002.jpg" alt=""><br>把“load、add、store”三条指令展开，开始三句是补偿代码，称为填充期，最后三句称为排空期。循环指令越多，排空期和填充期的指令也就越多。一边循环的指令的长度决定了补偿代码的长度，第一遍循环的最后一条指令作为软件循环的第一条指令，所以第一遍循环的前边所有指令作为补偿代码，类似的，后边作为排空代码。都有一个问题是偏移量的计算都必须要单独计算。</p>
<p>两条指令之间由于一条指令延迟过长，耽误了下一条指令的计算，就可以用常规循环展开进行展开。</p>
<p>软件流水的代码空间比循环展开小一些，没有大量的展开。循环展开有效的减少控制变量造成的损耗，软件流水降低空转、阻塞。</p>
<p>循环展开减少了循环控制变量的修正，如果是多层嵌套的循环，会乘上上一层循环的循环次数，更优化。软件流水主要减少每次循环引发的阻塞，在机器以峰值计算的时候更有效，腾出更多的空间使两条指令的相关距离更大。</p>
<p>基本代码调度：基本块本身是没有分支的程序块，超越基本块研究指令集并行。全局代码调度是跨越分支指令的调度，在循环体内部存在分支指令，调动循环体内部的控制流，从非循环的指令之间也存在并行性，对内部非循环控制流的代码比控制指令调度更复杂。</p>
<p>关键路径：全局代码调度的目的是把代码压缩，压缩到最短的指令序列，不包含分支指令的序列，形成的代码就叫关键路径，这段代码的所有指令会以最大概率从头到尾顺一遍，最可能没有分支指令。</p>
<p>代码的调度：数据的生产消费关系流（写后读）不能改变，代码的例外特征不能改变。在全局指令调度的时候，尽量减少可能产生例外的指令的调度。</p>
<p>全局代码调度实际上需要权衡，是否将一个语句调度到前方，需要进一步分析变量的依赖，这种调度可能会好，可能会坏。</p>
<p>路径调度产生一段可以并行执行的代码，针对分支，首先把程序中的分支抽离，剩下的是路径，这样找到了一个主干，认为主干有并行性，真正执行效果跟程序有关。路径调度比循环展开更进一步，发现跨越分支指令的并行性。路径调度的主要原因是每一拍都要流出大量的指令。</p>
<p>第一步是路径选择，选到一条路分为两步，路径选择大概有一条指令序列可以产生最短指令代码序列完成功能，经过选择的这一段代码就是路径，如果把循环连着控制指令一起展开，如果不成功就出去，呐循环展开本身就是一个关机按路径，产生一个代码序列，如果把控制变量去掉，则变成代码块；第二步是路径压缩，进行代码调整等一系列的修正，得到一串代码，就是可以执行的代码，之后压缩完的代码可以组合成超长指令字的指令包，它是一个全局的代码调度过程，在产生关键路径的中间，保证相关性不被破坏。</p>
<p>路径调度比简单的流水线调度获得更高的并发性，在控制相关上有特点；通过代码的调度跨越非循环的分支指令来预测程序的分支特征。如果对分支指令的信息足够精确，就能够得到非常快的代码。</p>
<p>路径选择第一步需要选择可能正确的路径，认为为真的概率比较高。代码不管经过什么调整，保证结果正确。</p>
<p>路径压缩需要挑出一个指令序列，填满机器所需要的指令。做分支指令调度的时候，有分支指令做好代码补偿，在路径的出入口做好。其中一个关键假设是关键路径执行概率最高，否则做代码补偿就得不偿失。</p>
<p>代码的移动可能导致控制相关的局部特征发生变化，导致某些指令的控制相关性发生变化。</p>
<p>软件ILP策略：</p>
<ul>
<li>循环展开</li>
<li>软件流水</li>
<li>路径调度</li>
</ul>
<p>编译器完成指令级并行的实现所需要的硬件支持，把精力集中到分支指令上。软件需要更多了解分支指令的特征，分支指令的特征并不好预测，它的执行是动态的，硬件可以提供一定的支持，例如前瞻性的执行，特别是对指令出故障的时候，对故障断定很精确，也提供一种机制，需要软件来执行这种机制，入条件指令，把if语句转成单条的指令，可以消除相关，把控制相关转成数据相关，在分支指令出现的代码段中也不出现调度问题了，只是数据操作问题，也没有相关问题。最后一种支持是前瞻的，一种是静态的在编译时就处理，设置抑制标志，不让前瞻性的过程扩散，如果扩散了则挂起，或者硬件提供寄存器，软件使用寄存器；动态调度是前边讲的算法。</p>
<p>条件指令是使用编译克服分支相关的一种方法，任何一条指令都带一个条件，如果条件是真的话就执行，是假的话就是一个空操作。这个过程内含了一个控制分支，完成后边数据的操作与前边相关，不再存在控制相关，而是转变成数据相关。第二个是把程序条件处理变成后端。</p>
<p>条件分支指令不允许产生意外，仍然占用运行时间，控制变量必须要预先产生，只有一个条件，只能做很简单的操作，最后是导致机器总体性能受影响。大部分机器支持条件传送指令。</p>
<p>指令作废：程序在执行时，条件应该尽早产生，以避免数据冒险等问题，否则应该作废。</p>
<p>条件指令的限制：</p>
<ul>
<li>作废的指令依然占用资源</li>
<li>指令的控制变量应该尽早产生</li>
<li>只能对简单的指令采用条件指令</li>
<li>产生性能阻碍</li>
</ul>
<p>前瞻操作的三种功能：</p>
<ul>
<li>数据流正确性</li>
<li>例外正确处理</li>
<li>访存的冲突应该被正确识别</li>
</ul>
<p>执行前瞻的四种方法：</p>
<ul>
<li>硬件和OS对指令前瞻执行，对某些应用很难实现，需要OS作标志</li>
<li>前瞻指令不允许产生意外，需要编译器在编译时确认哪条指令是前瞻指令</li>
<li>一定范围的指令，如果是前瞻的话，打上指令，抑制影响范围</li>
<li>后援机制，在执行的时候，把结果放到后援存储中，数据也不最终写回，直到前瞻被确认。</li>
</ul>
<p>指令进行全局调度的时候，例外和相关性不能改变，如果前瞻出现错误且对机器状态产生影响了，那这个前瞻就不能被采纳。</p>
<p>例外大概两种，一种是终止性的，程序不能被继续执行，如访存的保护错误；一种是可恢复的，当例外发生后，机器的机制对其处理，处理完之后可以正常执行，比如缺页。</p>
<p>软硬件联合前瞻，由操作系统和硬件可以处理可恢复的故障。如果前瞻的指令导致了一次终止性的故障，那就返回一个没有定义的值，当OS因为前瞻的故障发现返回一个无意义的值，则认为这是一个不可恢复的故障，进行一系列处理。如果引起终止的指令不是前瞻的，且引起了终止性的意外，那就终止。</p>
<p>既然是前瞻的过程，那最后的时候被前瞻的指令可能会系统忽视掉，它引发的终止性意外也可能被忽视掉。正常情况下一个程序返回一个无定义的值，则会崩掉；但是前瞻执行的时候会加上一个标志，增加确认过程，不会遇到例外就终止。或者加上一个前缀，当加上前缀之后，说明这条指令是前瞻的。或者所有寄存器加上抑制标志，每一条指令都有一条附加标志，告诉系统是不是前瞻的，如果是前瞻的，当碰到例外的时候，这个例外并不是马上就处理，先放一会，一直放到前瞻指令被确认的时候再处理。</p>
<p>这个例外在执行的时候可能会影响到一大批寄存器，也可能带来例外，但是这里的例外只能在指令被确认的时候再处理，所以记录下已经影响到的寄存器，如果一个前瞻指令使用了抑制位被置为抑制的寄存器，即某个操作数被抑制，那这个指令的另一个操作数也会被抑制，这是抑制的传递关系。如果正常指令访问被抑制的寄存器，机器就出故障了。</p>
<p>抑制位带来问题：操作系统需要单独指令控制抑制位。</p>
<p>后援问题：在分支指令之间调整指令，把这条指令定义为前瞻，提供一个reorder buffer，指令执行结束之后进行确认，把结果送到寄存器中。</p>
<p>设置专用check指令，用它顶替要进行前瞻执行的load，这个load就可以到处挪，这个check和load是一对，check检查保存在手里的load的地址和之前的地址，看前边是不是有写后读地址。</p>
<h1 id="多处理器和线程级并行"><a href="#多处理器和线程级并行" class="headerlink" title="多处理器和线程级并行"></a>多处理器和线程级并行</h1><p>并行体系结构的分类：</p>
<ul>
<li>single instruction stream, single data stream(SISD)</li>
<li>single instruction stream, multiple data stream(SIMD)</li>
<li>multiple instruction stream, single data stream(MISD)</li>
<li>multiple instruction stream, multiple data stream(MIMD)</li>
</ul>
<p>多指令流多数据流处理机采用的通用的芯片，提供了一种灵活性，通过软件和硬件的支持，对操作者来讲等价于一个单用户的多处理机，通过多个芯片提供很高的加速比，由于有多个处理器，对n个处理器来说至少有n个线程才能发挥处理能力。</p>
<p>依据互联策略，现有的MIMD有两类，一个是集中共享存储器体系结构，对于处理器和存储器，采用共享特征，多个处理器采用共享的存储器，总线把处理器和存储器联系在一起。由于多个处理器共享存储器，在时间和优先权上是一样的，因此总线采用仲裁机制判断哪个处理器使用了存储器，表现出一种对称。通过对称的策略，把这种机器叫做对称多处理机（SMP），实现了均匀访问，又可以叫做UMA。</p>
<p>把多个存储器分布到节点上，多个节点互联形成机器，带来的系统规模和可扩展性比较好，每个处理器访问存储器的时候大部分时候访问节点上局部的存储器，只有有必要的时候才访问远程存储器，远程访问经过互联网络，有较大时延，每个节点都有处理器、存储器、IO、互连网络接口，形成一个大的存储空间。两个好处：扩大带宽规模，局部存储器的访问是整个系统的大部分，远程访问量小得多，充分利用节点上的带宽，延迟小。缺陷是处理器之间的通信通过互联网络完成，变得比较复杂且有比较大的延迟。</p>
<p>多个处理器之间通信的话，一个是共享地址空间进行通信，多个处理器访问同一个地址单元，假如物理存储器是分布的，则叫做distributed shared memory（DSM），也叫做NUMA，对存储器访问不一样。</p>
<p>对共享地址空间来说，地址空间是共享的，一个空间只有一个地址单元，访问所采用的指令就是直接操作。对于多个地址空间来说，一个逻辑地址可能指的是多个地址空间，实际上是信息传递的多处理器，通过显式的数据传输完成。</p>
<p>对信息传递来说，通过同步方式实现，首先要传送一个请求，才得到一个应答。从另外一种角度，先把数据写过去再发送通知，当处理器之间的通信比较清楚的时候这种方式更简洁，这是异步的方式，提高运行效率。</p>
<p>通讯结构的性能问题：三个影响性能的主要因素：</p>
<ul>
<li>通信带宽，有处理器、内存和互联机构影响</li>
<li>通信延迟，包括发送开销（数据送上通信的端口）、飞行时间（第一个二进制位从发送端口到接收端口的时间）、传送时间（所有数据除以速率）、接收开销。</li>
<li>通信延迟隐藏，假如是一个串行程序改成并行，在通信延迟期间做其他的事情，把通信延迟隐藏掉，这个隐藏过程是一个重叠过程，把通信延迟的影响降到最低。</li>
</ul>
<p>算法决定了各个处理器之间的通信量，通常计算和通信之比随着处理器数量增加逐渐降低，处理器数量增加了，通信代价大了。处理的数据增大的时候，计算量增大，通信量也增大，二者之比增大。</p>
<p>小规模时，集中共享存储器是最简单的；围绕处理共享数据解决同步问题。</p>
<p>通过多级cache解决提高整体性能，私有数据一定要进cache，共享数据涉及多个处理器共享，在多个cache都有拷贝，需要解决cache相关性问题，着重从多个备份之间的关系。</p>
<p>如果系统是相关的，必须可以读出最近写入的正确数据，两个方面，相关性（能够读出来哪个值，指的是内容的问题，正确的还是错误的？）和一致性（什么时候能把写进去的值读出来，时间上的问题）。</p>
<p>满足以下条件一个存储系统才是相关的：</p>
<ul>
<li>一个处理器P对x进行写之后进行读，其他处理器不对x进行写操作，这时返回的数据是P写进去的。</li>
<li>一个处理器对x进行读是在另一个处理器对x进行写之后，两次操作相隔时间很长且没有其他处理器对x进行写操作，读出来的值是另一个处理器写进去的值。</li>
<li>对同一个单元的写必须是串行化的，同一单元被两个不同的处理器执行的两个<br>写被所有处理器看上去都是相同的顺序。</li>
</ul>
<p>相关性（coherence）定义了对同一单元的读和写问题，指内容上的问题，一致性（consistency）定义了读和写相对于其他存储单元的访问的行为问题，指时间上的问题。</p>
<p>读可以是乱序，但是写必须是按照程序规定顺序的。</p>
<p>相关性cache提供了迁移功能，是指数据项能够从远程移动到局部的cache中使用，为了减低延迟和带宽需求。复制指的是把当前的数据拷贝同时在多个cache中存在，也能从降低延迟方面获得好处。</p>
<p>cache相关性协议的关键问题是跟踪任何共享数据的状态，根据状态采取策略，有两类协议。首先是基于目录的方法，专门有一个物理存储器用于保留共享数据状态，查阅目录存储器就能找到共享数据的状态，适合分布式共享存储器结构。snooping（监听）使cache块中既存在数据，又包含了状态，状态是分布式存放的。</p>
<p>通过两种方式完成跟踪，维护相关性，为了保证处理器在对数据进行写之前，进入“专有”状态，把除了我要写的拷贝之外的所有其他拷贝都作废，称为“写作废”，当前要写的处理器对当前要写的数据进行专有访问。由于这是最简单的方法，广泛使用。可以用于监听或目录策略。专有状态保证没有其他的处理器可以读写，所有其他的cache拷贝都作废。通过仲裁把多个要写的请求进行仲裁，把其他的拷贝进行作废，其他的处理器重新读入一个拷贝，基于新写入的数据再写。强制所有的写操作串行化。</p>
<p>写广播（写更新）方式：当新的数据项写入一个拷贝的时候，要更新所有其他的拷贝，这里需要把所有的拷贝都更新。</p>
<p>对于同一个字的多次写，写广播代价大，每次写都要广播，对写作废来说只需要一次广播，这时已经进入独占状态，再次写的话不需要广播了。对于cache块中间的每一个字的写，在写更新协议中多次广播，在写作废中只有第一次需要写。不管是对一个字的多次写还是对多个字的写，写作废都只需要一次广播。</p>
<p>读和写一个数值之间，一个处理器写进入，另一个处理器要看到的话，写广播的延迟比较短，写作废需要重新调入数据块，更慢。</p>
<p>写广播占用带宽多，写作废的带宽需求比较小。</p>
<p>为了完成写作废，首先完成总线的访问，并且把共享数据地址送上总线，让其他的拷贝作废掉，其他处理机监听总线，检测到这个地址在其他处理机的cache内存在，则作废掉。对总线的访问串行化导致了对写的串行化。对共享数据的写要等到获得总线访问权之后。</p>
<p>对于写直达cache，写进数据之后存储器也要生效，如果其他的处理机获得最新值比较容易，从存储器里边取到最新值送到需要的处理器上。</p>
<p>写回cache，大部分最新的数据保存在cache中，存储器和cache不一样。监听总线上的地址，处理器发现总线上的地址和内部的一个cache一致，就把已经修改的数据提供给需要的存储器，因为现在数据已经被修改了，这里的是最新的。</p>
<p>通常的cache块都有自己的tag，标志当前的共享数据状态。有个无效位，说明是不是有效的。增加一个额外的共享状态位表示这个块是否是共享的，增加一个脏位看是否被修改过。</p>
<p>当只有一个拷贝时，这个处理器就是这个cache块的拥有者。cache地址和总线地址需要对比，地址的对比是串行的，cache只能满足一个的请求，所以监听控制器的操作会影响访问速度，如何提高对比速度，分成两份，一份由CPU对比，一份由总线对比；或者多级cache，CPU访问一级cache，总线访问其他cache，CPU和总线互不干扰，提高效率。</p>
<p>如果CPU操作了一级cache，总线可以操作其他cache。基于总线的相关性协议通过有限状态控制器实现的，控制器分布在每一个节点上，相应来自处理器和总线的不同请求，对两边的不同操作进行处理，并比较地址。对写命中和写失效都要出现总线事务，合并起来共同看作写失效的状态，减少要处理的事务。</p>
<p>最重要的是事务的处理是原子性的，操作必须是一气呵成不能中断的，全部过程不能有其他的插入。非原子性的事务可能会引入死锁风险。只要保证原子性的逻辑性，中间可以插入其他操作，只要不改变数据值，特别是写操作。为了充分利用并行性，且保证原子性，执行一些状态转移操作。</p>
<p>把状态变迁用状态转移图表示出来。</p>
<p>处理机之间的通信引起的失效叫相关性失效，可以分成两个部分，真共享失效、假共享失效，区别在于对同一块中间同一个字/不同一个字的共享，因为cache的共享是基于块的。</p>
<p>失效可分为三种：</p>
<ul>
<li>强制性失效：第一次读入这个块的时候一定会失效</li>
<li>相关性失效：对相关数据处理引起的失效</li>
<li>容量失效：cache容量不足导致替换引起的失效</li>
</ul>
<p>cache增大失效率降低，块大的话失效率也降低。</p>
<p>在监听协议里，每一个cache的状态分布到每一个cache块中，这种情况对分布可变规模的存储器有影响，因为分布可变的存储器使用互连网络，再使用监听协议就不适合了。一种可能的替代方法是目录存储器，把所有存储器共享的状态存下来。</p>
<p>现有的目录协议将每个块设置一个目录项，目录项的数量是存储块和存储器数量的乘积。为了防止目录成为整个系统的瓶颈，把目录存储器分布到系统中间，每个节点增加一个目录存储器。</p>
<p>目录协议两种必须实现的操作：处理读失效，处理对于共享的干净的cache的写，处理对共享块的写失效是上述二者的结合。目录要跟踪cache块的状态。首先在共享状态下，一个或多个处理器都有拷贝，未缓冲状态没有处理器有这个cache块的拷贝，专有状态是只有一个处理器有这个cache块的拷贝，如果这时候写的话，存储器的拷贝就是旧的，写完之后处理器是这个块的拥有者。</p>
<p>考虑到要写，分布共享存储器结构中，更需要写作废的支持，因为通过互联网络进行广播的话代价更大。共享状态最简单的支持是位向量，当块被共享的时候，每一位都标志出这个处理机是否有这个块的拷贝。</p>
<p>使用互连网络无法使用仲裁功能，仲裁是总线特有的；互连网络是面向信息传递的，总线是面向事务的，因此互连网络必须采用发送确认的方法。</p>
<p>局部节点是请求产生的节点。home节点是请求的存储单元和目录项所在的节点。远程节点是有cache块拷贝的节点。物理地址空间是竞态分布的，存储器地址清楚的话，节点号也清楚了。例如，地址高位代表节点号，低位代表位移。</p>
<p>目录协议的实现：目录存储器中，cache状态是反应数据状态的真实状态的，为了解决相关性，存储器中每个数据项变化时都引起目录项的变化，所以分布共享存储器中目录的操作占了总操作数的一半。送到目录中的信息导致2个操作，首先是更新目录的状态，由共享进入专有等；然后发送相应的信息，以满足请求。存储块可能是未缓冲的，可能是有多个缓冲的，或者专有的。三个状态下，目录所执行的操作不同。</p>
<p>未缓冲时，即在数据块还在存储器中时，读失效的时候，请求的处理器要求存储器将数据送到处理器cache中，置为唯一共享节点，块置为共享状态。当写失效时，首先要送给请求方处理器这个数据块的值，把它在共享集合上置1，变成共享状态。</p>
<p>处于共享状态时：读失效时，请求处理器从存储器中收到数据，请求的处理器被添加到共享集合中，写失效时，请求的处理器要进行写，首先拿到数据，所有在共享集合中的处理器收到失效信息，只留下请求的这个处理器，共享集合仅包含请求的处理器。</p>
<p>在专有状态下，所有处理器中只有一个拷贝。读失效意味着这个数据块将进入共享状态，发送取数据信息到拥有这个块的处理器，导致了块的状态变成共享状态，拥有者把数据发送到存储器，在从存储器把数据发送到请求的处理器，把标识进行更新。数据写回执行把cache中的脏数据写回到存储器中，拥有者把块送回地址所在的节点，这个块成了未缓冲的。写失效意味着专有的写状态要转移到另一个处理器，这个块将有一个新的拥有者，首先要发送信息到老的拥有者，使得cache作废，然后把原来的数值送回到目录，在把数据送回到请求方，请求方拿到了数据，成为新的拥有者。</p>
<p>当块处在专有状态时，读写失效时，先把数据送回到目录，从目录再存储再送到请求的节点。为了提高效率，把数据直接送到请求节点，再送到存储器节点，这个操作可以把间接的变成直接的，但是在实现中增加了复杂性，同时使得死锁可能性增加了，在送给使用方的同时送给存储器。</p>
<p>基于目录的方法用空间换时间，减少了访问量但是增加了目录存储器，大小与系统规模N的平方成正比，为了改进，提出了有限映射和链式结构两种。</p>
<ul>
<li>有限映射假定在不同cache中的拷贝数量小于一个常数，可以通过比较少的位向量标识块，但是有m个的限制。</li>
<li>链表结构不存在有限映射中m的限制。</li>
</ul>
<p>数据分布引起整个系统中的带宽使用效率的不同。</p>
<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p>多个处理器在时间上协调一致。典型的同步机构时系统在硬件原语的支持下通过软件实现的例程。高竞争状态中同步起到一致协调的作用，也成为系统的瓶颈。</p>
<p>硬件原语是面对用户的一些汇编指令，与基本指令不同的是涉及硬件操作多。实现同步的最主要能力是使用一组硬件原语，自动读取修改共享数据。硬件原语是构成面向用户的同步操作的主要组成。对存储单元的读写需要多条语句，如果在这多条语句中插入其他的指令，可能会造成同步失败，使用原语可以降低出错减少时间。</p>
<p>典型的硬件原语操作是“自动交换”，把寄存器的数据和存储单元的数据交换，通过交换，把存储单元中的数值拿到。假设建立一个锁，0代表这个锁可用，1代表不可用，要实现最后读出来是0，表明得到了锁。</p>
<p>存储单元的读写通过仲裁，只能有一个首先完成，多个处理器竞争单元时不会产生冲突。</p>
<p>使用交换指令使用原语的根源在这个原语的操作是一气呵成的，没有其他间隔打断。读和写这两点在实现同步上是不可缺的，如果没有这两点构成一个同步原语，不能实现的。</p>
<p>test-and-set：首先读出来一个数据，测试是不是满足，如果满足则置入一个新数据。</p>
<p>fetch-and-increment：取出来单元数据，自动加一，然后再写进去。</p>
<p>使用一致性实现一个旋转锁，一个处理器不停的测试看是否能获得锁，直至成功，修改锁为占有状态。旋转的过程通常在用户希望这个锁持有的时间很短，低延迟使用时间短的时候适合旋转锁。</p>
<p>很多处理器竞争一个锁的延迟和复杂度不是线性增长的，几乎是二次方，也造成比较大的流量。串行化是锁开销大的最主要原因。竞争大的时候降低串行化，形成有序的通信。软件实现的方法：所有进程争抢这个锁但是只有一个进程能抢到，第一次获得锁失败的话第二次就要延迟一会再去试探。</p>
<p>或者排队锁方法，通过软件构造等待处理器队列，通过队列进行排序，通过顺序有序使用资源。</p>
<p>组合树方法：在软件上实现对大规模机器同步的方法，把大量的竞争化解为对多个小点的竞争，使用n元树结构，一般来说使用k表示树的扇入（fan-in）。在k元树的最底层开始同步，逐级向上，直至根节点。如16个节点的话，就是一个二层的树，之前的代价是16的平方，现在是两倍的4的平方。</p>
<p>总线上10个处理器，同时完成对锁的竞争，假设每个总线事务100个时钟周期，忽略读写占用时间，只计算在竞争锁的时候的代价，对10个处理器获得锁的时候要占用多少总线事务。当i个处理器在竞争时，有i个链取获得锁、i个条件写来尝试获得锁，1个写，一共2i+1个总线事务，要全部通过要进行累加，对n个处理器来说，一共n(n+1)个总线事务。在同步点上进行同步造成相当长的延迟，同时影响了总线的访问。</p>
<p>栅栏同步（barrier）：强制所有进程等待，直到所有进程到达栅栏，再一起释放。这个过程通过两个旋转锁实现，一个是保护计数器，计算到达栅栏的进程数；一个是用于把所有进程卡在这，一旦所有进程都到了就释放。可能会出现进程组中的一个进程永远离不开barrier。</p>
<p>通过sense-reversing区分不同进程到达的barrier是否是同一次进入barrier，如果不是同一次的话可能会造成死锁。</p>
<p>硬件对大规模同步的支持：有些机器通过硬件实现了栅栏同步，类似组合树的方法。保存关于同步的处理器并对其排队，叫做排队锁，硬件上使用位阵列，把先后到达的每一个处理器进行排队，通常是与目录结构结合在一起。</p>
<p>排队锁：当对锁变量第一次失效的时候，这次失效被送同步控制器，如果锁被释放，直接从队列里返回下一个处理器，如果锁不可用则创建一个排队记录。当锁释放的时候，选择下一个处理器进入使用状态，把下一个处理器拿到队列前端。</p>
<p>区别是首次访问锁还是一直在锁里边，这样可以实现排队操作或者释放锁的操作；</p>
<p>另外一个原语是fetch-and-incement，自动取出一个变量并增加数值。这个指令会使barrier指令有改进的空间，因为它将取并增量两个操作结合在一起。现有的MPP机器都采用的是硬件barrier方法。</p>
<p>一致性问题：什么时候能看到被其他处理器更新过的数字，什么时间生效，通常使用共享变量通信。通过读出被写进去的数据来检测是否已经更新过。</p>
<p>两个代码段：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P1:</span><br><span class="line">A = 0;</span><br><span class="line">...</span><br><span class="line">A = 1;</span><br><span class="line"></span><br><span class="line">L1:</span><br><span class="line">if (B==0) ...</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">P2:</span><br><span class="line">B = 0;</span><br><span class="line">...</span><br><span class="line">B = 1;</span><br><span class="line"></span><br><span class="line">L2:</span><br><span class="line">if (A==0) ...</span><br></pre></td></tr></table></figure><br>如果这个程序能同步正确执行的话，A和B都在cache里，如果写总是能马上生效，那两个if都绝不可能同时为真，因为如果到达两个if，A和B都被赋值为1了。假设写作废被延迟，处理机允许继续向前推进，可能出现P1和P2两个都没看到作废，这种情况就与预计的正确程序行为相违背。</p>
<p>最简单的一致性模型是顺序一致性，需要任何访存顺序一致的程序运行结果一致，它消除了含糊的执行方式，处理器延迟对任何存储器访问的过程，直到所有的写生效；同样的可以将下次访存延迟直到本次访存结束。</p>
<p>一致性涉及到不同变量和不同时间的问题，因此对两个变量的访问必须按照一定的顺序。</p>
<p>在上边的代码中，必须在写操作完成后在进行读A或B，在顺序一致性中也不能简单地把写放到缓存中而已就继续往下执行。</p>
<p>一个处理机对变量的写和另一个处理机对变量的访问通过一对同步操作进行排序，意味着同步操作把数据引用进行了排序，同步把顺序定下来，这就确定了一致性，两个处理器的操作通过同步确定了顺序。如果没有同步操作，变量在读写期间出现顺序不定的情况，称为数据竞争，因为此时对数据的访问基于处理器之间的相对速度，输出是不可预计的，结果正确性不能保证。</p>
<p>同步原语在实现上提供了较为宽松的顺序一致性，即便系统提供了较为宽松的一致性模型，一个同步的程序也会按照标准顺序一致性那样执行，这实际上提供了一种时间上的重叠，为并行的开发提供了条件。</p>
<p>松弛一致性模型的主要思想是允许读写无序进行，而是使用同步操作来强制实现有序，这样的话处理器的操作就像顺序一致性一样。依据松弛的情况分为3种主要的类型。</p>
<p>写后读：写完全生效之后才能进行读，这叫做全存序模型，或者处理器一致性，因为只保留了写的一致性，许多程序在这个模型下保持顺序一致性。旁路和写缓冲是两种主要方法。写缓冲中如果有要读的地址，就先在缓冲中拿到。</p>
<p>写后写：多次写的一个模型，部分存序，在流水线中，第一个写还没有完成的时候第二个写已经启动，两个写之间存在并行，因为两个写之间存在节拍的差距。</p>
<p>读后读/写：弱排序模型。</p>
<p>顺序松弛可以使处理器获得明显的性能提升，在实现上需要硬件的支撑。</p>
<h1 id="线程级并行"><a href="#线程级并行" class="headerlink" title="线程级并行"></a>线程级并行</h1><p>多线程使多个线程共享处理机，处理机必须对每个线程的状态进行复制，便于进程切换，没有硬件支撑条件也谈不上多线程并行。比如，对线程所需要的文件来说，有寄存器文件，分开的PC等，提供对不同线程的切换能力，不同节拍可以切换到不同线程，线程切换也要比进程切换更快。</p>
<p>通常有两种方式实现多线程，一个是细粒度的，在指令之间就能完成线程的切换，使多线程的执行是交错的，切换经常采用时间片轮转的方式，优点是隐藏吞吐率上的损失，充分利用CPU的时间，如果线程执行IO时就可以先被切换先来，但是它的总执行时间被延长了。粗粒度的线程级并行在比较长的停顿出现时才进行切换，比如局部cache的失效，它依赖于程序执行的特点，缺点是受限于吞吐率，在有比较大的输入输出时才切换，没有办法充分利用短停顿。粗粒度多线程经常要填充流水线，产生一个起步时间，存在局限性，只有在停顿时间比较长的时候才有效。</p>
<p>SMT（simultaneous multithreading）是多线程的一种，使用处理器的多流出和动态调度能力，在指令级并行的同时实现线程级并行。SMT的基础是处理器有多个功能部件可以并行执行。寄存器换名和动态调度是为了支持不同线程的指令级并行。同时多线程是在多流出支持下，每拍流出的指令可以是来自多个线程的，第一拍是来自两个不同的线程，第二拍是来自另外的线程，以此类推，在线程和指令两个层面实现并行。</p>
<p>有多少个活跃的线程？有多少缓冲区？取指能力是否能满足流水线的需要？等都是SMT的问题，不能完全百分百的利用每一个流水槽。每个线程都要有自己的寄存器组、缓冲等。各个线程的指令要能够独立提交，结果要回到各个线程本身，这要求在逻辑上要提供每个线程的独立重排序缓冲区。</p>
<p>优先线程基于同时多线程，把执行的时间最小化，在多个线程并行的时候，只要有可能，首先流出的就是优先线程的指令，优先线程调度不出的空槽填充其他线程的指令。为最大化单个线程的性能，优先线程的取指、分支预测等应尽可能往前。如果有两个优先线程的话，两个线程就都要优先，两条指令流都要优先服务。</p>
<p>多线程每个都有寄存器，寄存器文件需要很大，保存多现场；保持系统低开销，优先线程需要优先取指；由SMT引起的cache冲突上需要良好处理，引起系统性能下降反而得不偿失。</p>
<h1 id="交叉问题"><a href="#交叉问题" class="headerlink" title="交叉问题"></a>交叉问题</h1><p>许多多处理器使用多级cache较少对全局通信的需求，如果cache提供了多级包含特性，即近一级的cache一定是远一级cache的子集，一级cache中的内容一定是二级cache中的子集。</p>
<p>如果L2是L1容量的4倍，在L2中1个起始地址的块，在L1中是4个块。如果L1中的块大小是b，L2中的块大小是4b，则如果在L2中作废一个块x，需要作废以x，x+b，x+2b，x+3b为起始地址的小块（这在L2中被看作是一个块，在L1中被看作是4个块），在L1中同样要作废起始地址为x的一个块，但是没有作废起始地址为x+b的块（如果有的话），这就违背了包含原则。任何时候都要遵守包含特性。</p>
<p>非封锁cache和延迟隐藏：多处理机的失效处罚比较大，延迟也较大，这意味着有更大的延迟可以被隐藏，还有因为流水线失效的延迟可以被隐藏；cache使用非封锁cache支撑了弱一致性模型实现，弱一致性模型可以实现对访存的重排序，重复利用；非封锁cache对实现预取很有必要，利用尽可能空的时候实现存储的迁移，充分利用时间，实现多端口的并行访问。</p>
<p>非绑定是指一个cache的数值要根据其最新数值的变化而变化，不跟随某一个局部拷贝，对全局来说都是一致的。如果是预取到寄存器中，就是绑定的，因为如果数据进入了寄存器就是脱离了地址空间，跟存储地址空间的数据就没有关系了，存储器里的变化跟寄存器里没有关联了。非绑定是在硬件预取设计中不可获取的，只能在地址空间中实现预取。</p>
<p>有几个问题：局部节点需要对多个未完成的访问进行跟踪，跟踪预取地址；流出请求之前，节点必须保证在流出请求之前，对同一个块没有流出其他请求。</p>
<p>定义一个内存一致性模型的另一个原因是针对共享数据，确定合法的编译优化范围。最简单的来说是实现同步（硬件支撑下的对存储器访问的同步）。</p>
<p>通过虚拟存储器实现共享内存，不必从物理内存上考虑容量。共享数据如何从共享cache块移向更大的单元。通过OS进行调度页面。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/19/Taichi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/19/Taichi/" itemprop="url">Taichi编程语言—高性能稀疏视觉计算与可微编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-19T16:30:00+08:00">
                2020-02-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Why-new-programming-language"><a href="#Why-new-programming-language" class="headerlink" title="Why new programming language"></a>Why new programming language</h1><p>Taichi is a high-performance programming language for computer graphics applications. The goals are:</p>
<ul>
<li>performance</li>
<li>productivity</li>
<li>spatially sparse computation，空间稀疏计算，CG中的提速需要</li>
<li>differentiable programming，可微编程，dl里的导数求解</li>
<li>meta programming</li>
</ul>
<h1 id="design-decisions"><a href="#design-decisions" class="headerlink" title="design decisions"></a>design decisions</h1><ul>
<li>计算和数据结构的解耦</li>
<li>领域特定编译器自动优化，广义编译器没有领域支持</li>
<li>megakernels，我的计算并不是表示成一个kernel中有一个很简单的操作</li>
<li>自动微分中的两个尺度</li>
<li>包到python中。</li>
</ul>
<p><img src="/img/202002191636.jpg" alt=""></p>
<p>把python的AST通过TaiChi前端编译到TaiChi的AST，或者说执行一段代码，输出TaiChi的AST。得到前端AST后输入AST Lowering，所有中间变量只复制一次，对CPU做循环向量化等优化，对GPU则不用；之后在CPU上对内存访问优化。自动微分之后到LLVM。把数据结构的信息很显式的使用，因为很多优化如果不知道数据结构就很难优化。</p>
<h1 id="High-Performance-Spatially-Sparse-Computation"><a href="#High-Performance-Spatially-Sparse-Computation" class="headerlink" title="High-Performance Spatially Sparse Computation"></a>High-Performance Spatially Sparse Computation</h1><p><img src="/img/202002191700.jpg" alt=""></p>
<p>之前做类似模拟的时候需要开辟一个大的buffer，即使使用到的只是其中一小部分，这就是空间稀疏性。这里的空间稀疏性在局部比较稠密。<br><img src="/img/202002191702.jpg" alt=""></p>
<p>VDB用于处理类似的结构，类似文件系统的B-Tree，一个哈希表，底部是一些指针数组，第一层的指针数组有64个孩子，第二层的指针数组有16个孩子，降低访问延迟。</p>
<p><img src="/img/202002191717.png" alt=""></p>
<p>SPGrid使用了Virtral Memory中的TLB做了硬件的Hash Table。</p>
<p>使用稀疏的数据结构是很难的：</p>
<ul>
<li>Boundary Conditions，边界条件对么</li>
<li>Maintaining，维持这个数据结构而存在的</li>
<li>内存管理</li>
<li>并行和负载均衡</li>
<li>数据结构的开销<ul>
<li>可能会去查哈希表</li>
<li>可能会使用指针，cache miss</li>
<li>节点的分配，barrier</li>
<li>分支预测，misprediction</li>
</ul>
</li>
</ul>
<p>底层的工程减少了数据结构的开销，但是降低了生产了，把算法和数据结构耦合在一起，让不同数据结构的使用产生了困难。稀疏数据结构<br>的开销比核心计算更大，cache miss更多，先过Hash Table，然后去某个数组查询。</p>
<h1 id="TaiChi的方法："><a href="#TaiChi的方法：" class="headerlink" title="TaiChi的方法："></a>TaiChi的方法：</h1><h2 id="Decouple-computation-from-data-structures"><a href="#Decouple-computation-from-data-structures" class="headerlink" title="Decouple computation from data structures"></a>Decouple computation from data structures</h2><p>提供了命令式的编程语言，转换成中间表示，并做优化，然后有一套runtime system做内存管理。</p>
<p>如何描述数据结构？</p>
<ul>
<li>dense：固定长度连续数组</li>
<li>hash：使用哈希表维护坐标映射</li>
<li>dynamic：预定义长度的数组，用来维护块中的粒子</li>
</ul>
<h2 id="Access-Simplification"><a href="#Access-Simplification" class="headerlink" title="Access Simplification"></a>Access Simplification</h2><p>TaiChi是怎样针对数据结构优化使计算变快的。</p>
<p>access lowering，common subexpression elimination：把端到端的看起来稠密的访问（i到j），分解成比较小的指令并做优化，像传统编译器中的“表达式消除“。例如在AST中时，不需要每次都从root向leaf搜索，在子节点开始搜索，省略不必要的遍历和检查。</p>
<p>对AOS（array of structure）和SOA（structure of array），如果顺序访问的话SOA确实对cache很友好，后来发现AOS更好？数据上是这样的。</p>
<h2 id="vectorized-FEM-Access-Optimization"><a href="#vectorized-FEM-Access-Optimization" class="headerlink" title="vectorized FEM Access Optimization"></a>vectorized FEM Access Optimization</h2><p>在做有限元运算时如何从内存中load一些element，比如，在对矩阵进行访问时，预先加载一个块中的数据，在访问时就可直接从块中进行查找，避免多次的访问。</p>
<p>为什么传统的编译器做不了这样的优化？</p>
<ul>
<li>Index analysis，下标分析，利用某些数据结构信息使下标计算满足一些性质，就可以针对这些下标进行预取优化</li>
<li>合适指令粒度，可以把一个访问表示成<code>x[i, j]</code>，指令粒度大了存在大量优化空间；也可以把访问表示成更low level的代码指令，这样比较难分析。指令越来越细就越难分析，但是如果指令大，则隐藏潜在优化空间。</li>
<li>data access semantics<ul>
<li>no pointer aliasing: a[x, y] and b[i, j] never overlaps if a != b，pointer alias是阻止编译器进行优化的东西，注意避免，传进参数的时候加上restrict告诉编译器两个指针从来不会overlap</li>
<li>all memory accesses are done through sparse_grid[indices]</li>
<li>the only way data structures get modified, is through write accesses of form sparse_grid[indices]</li>
<li>读取操作不会修改任何变量。</li>
</ul>
</li>
</ul>
<h2 id="differentiable-programming-on-Taichi"><a href="#differentiable-programming-on-Taichi" class="headerlink" title="differentiable programming on Taichi"></a>differentiable programming on Taichi</h2><p>可微编程，是在Taichi中的一个模块（Reverse Mode Autodiff），比deep learning更general。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/04/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AE%9E%E9%AA%8C%E8%AF%BE%E4%BB%B6-%E4%B8%B2%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/04/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E5%AE%9E%E9%AA%8C%E8%AF%BE%E4%BB%B6-%E4%B8%B2%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url">高性能计算实验课件-串行程序性能优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-04T14:57:00+08:00">
                2020-02-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ILP"><a href="#ILP" class="headerlink" title="ILP"></a>ILP</h2><p>指令级并行（ILP）是用于在同一CPU内核中同时执行多个指令的一组技术。<br>（请注意，ILP与多核无关。）<br>问题：CPU内核有很多电路，并且在任何给定时间，大多数都处于空闲状态，这很浪费。 解决方案：让CPU内核的不同部分同时执行不同的操作：如果CPU内核能够一次执行10次操作，则该程序原则上可以运行多达10次。 （尽管实际上并没有那么多）。</p>
<p>指令好像是必须按照程序顺序来执行，但是独立的指令可以同时执行，不会影响程序正确性。</p>
<p>超标量执行：处理器在指令序列中动态选择独立的指令并并行执行他们。</p>
<ul>
<li>超标量：同时执行多项运算（例如，同时执行加，乘和加运算）。</li>
<li>流水线：开始对一个数据执行操作，同时对另一数据完成相同的操作-同时对不同的操作数集执行同一操作的不同阶段（如组装线）。</li>
<li>超流水线：超标量和流水线的结合–同时执行多个流水线操作。</li>
<li>向量：将多个数据加载到特殊寄存器中，并同时对所有这些数据执行相同的操作。使用SSE，AVX等，一条指令产生多个结果。</li>
</ul>
<h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><p>Copy Propagation复制传播<br>从<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = y</span><br><span class="line">z = 1 + x</span><br></pre></td></tr></table></figure><br>转换成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = y</span><br><span class="line">z = 1 + y</span><br></pre></td></tr></table></figure><br>消除数据依赖。</p>
<p>Constant Folding常量折叠<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add = 100;</span><br><span class="line">aug = 200;</span><br><span class="line">sum = add + aug;</span><br></pre></td></tr></table></figure><br>变为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = 300;</span><br></pre></td></tr></table></figure><br>注意，sum实际上是两个常量的和，因此编译器可以对其进行预先计算，从而消除了否则会在运行时执行的加法运算。</p>
<p>删除死代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var = 5;</span><br><span class="line">printf(&quot;%d&quot;, var);</span><br><span class="line">exit(-1);</span><br><span class="line">printf(&quot;%d&quot;, var * 2);</span><br></pre></td></tr></table></figure><br>变为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var = 5;</span><br><span class="line">printf(&quot;%d&quot;, var);</span><br><span class="line">exit(-1);</span><br></pre></td></tr></table></figure></p>
<p>强度降低<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = pow(y, 2.0);</span><br><span class="line">a = c / 2.0;</span><br></pre></td></tr></table></figure><br>变为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = y * y;</span><br><span class="line">a = c * 0.5;</span><br></pre></td></tr></table></figure><br>计算一个值的乘方或进行除法要比乘法更昂贵。 如果编译器可以判断出幂是一个小整数，或者分母是一个常数，那么它将使用乘法。</p>
<p>常见子表达消除<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = c * (a / b);</span><br><span class="line">e = (a / b) * 2.0;</span><br></pre></td></tr></table></figure><br>变为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adivb = a / b;</span><br><span class="line">d = c * adivb;</span><br><span class="line">e = adivb * 2.0;</span><br></pre></td></tr></table></figure><br>子表达式（a / b）出现在两个赋值语句中，因此没有必要进行两次计算。通常只有在通用子表达式的计算成本很高的情况下，才值得这样做。</p>
<p>变量重命名<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y * z;</span><br><span class="line">q = r + x * 2;</span><br><span class="line">x = a + b;</span><br></pre></td></tr></table></figure><br>变为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x0 = y * z;</span><br><span class="line">q = r + x0 * 2;</span><br><span class="line">x = a + b;</span><br></pre></td></tr></table></figure><br>原始代码具有输出依赖性，而新代码则没有输出依赖性，但是x的最终值仍然正确。</p>
<p>循环优化</p>
<ul>
<li>循环内不变的代码称为循环不变式。 不需要一遍又一遍地计算。</li>
<li>我们可以通过剥离特殊的迭代来消除IF</li>
<li>分组迭代消除IF</li>
<li>数组元素<code>a[i][j]</code>和<code>a[i][j+1]</code>在内存中彼此靠近，而<code>a[i+1][j]</code>可能很远，因此使j循环为内循环。 （在Fortran中是相反的。）</li>
<li>循环展开。上次我们看到，具有很多操作的循环可以获得更好的性能（在某种程度上），特别是在有很多算术操作但主存储器加载和存储很少的情况下。展开会创建多个操作，这些操作通常从相同或相邻的缓存行加载。 因此，展开的循环可以执行更多的操作，而不会增加太多的内存访问。同样，展开将减少循环计数器变量上比较的次数，并减少到循环顶部的分支数。</li>
</ul>
<p>循环融合<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">	a[i] = b[i] + 1;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">	c[i] = a[i] / 2;</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">	d[i] = 1 / c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>变为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">	a[i] = b[i] + 1;</span><br><span class="line">	c[i] = a[i] / 2;</span><br><span class="line">	d[i] = 1 / c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>与展开一样，这具有较少的分支。 它还具有较少的总内存引用。</p>
<p>从理论上讲，编译器和硬件可以“理解”所有这些内容，并可以优化您的程序；实际上，他们没有。</p>
<ul>
<li>他们不会知道与处理器更好的“匹配”的不同算法</li>
<li>但是实际上编译器可能需要您的帮助- 选择其他编译器，优化标志等，其中包括控制单处理器优化的选项：超标量，流水线，矢量化，标量优化，循环优化，内联等。</li>
<li>重新排列代码以使事情变得更明显</li>
<li>使用特殊功能（“固有”）或编写汇编</li>
</ul>
<p>高级优化：过程间优化 (IPO)</p>
<ul>
<li>ip: 源程序文件内部的过程间优化</li>
<li>ipo: 多个源程序的过程间优化</li>
<li>函数内联是ipo中最重要性能优化手段</li>
</ul>
<p>为什么循环不向量化</p>
<ul>
<li>独立</li>
<li>循环迭代通常必须独立</li>
<li>一些相关的限定词：</li>
<li>某些依赖循环可以向量化。</li>
<li>大多数函数调用无法向量化。</li>
<li>一些条件分支会阻止矢量化。</li>
<li>循环必须是可数的。</li>
<li>无法对嵌套的外循环进行矢量化处理。</li>
<li>混合数据类型无法向量化</li>
</ul>
<p>处理内存延迟的方法</p>
<ul>
<li>通过将值保存在小型快速内存（缓存）中并重新使用它们来消除内存操作</li>
<li>在程序中需要时间局部性</li>
<li>通过获取一块内存并将其保存在小型快速内存（高速缓存）中并使用整个内存块，来利用更好的带宽</li>
<li>带宽改善快于延迟</li>
<li>在程序中需要空间局部性</li>
<li>通过允许处理器一次向存储系统发出多次读取来利用更好的带宽</li>
<li>指令流中的并发，例如 像矢量处理器一样加载整个数组； 或预取</li>
<li>重叠计算和内存操作</li>
<li>预取</li>
</ul>
<p>如果有两个以上的内存级别怎么办？</p>
<ul>
<li>需要最小化所有级别之间的沟通<ul>
<li>在L1和L2缓存，缓存和DRAM，DRAM和磁盘之间…</li>
</ul>
</li>
<li>算法需要找到合适的块大小<ul>
<li>机器相关</li>
<li>需要在最里面的循环中“阻止” b x b矩阵乘法<ul>
<li>1级内存-&gt;3个嵌套循环（幼稚算法）</li>
<li>2级内存-&gt;6个嵌套循环</li>
<li>3级内存-&gt;9个嵌套循环…</li>
</ul>
</li>
</ul>
</li>
<li>缓存遗忘算法提供了另一种选择<ul>
<li>将nxn矩阵乘法视为一组较小的问题</li>
<li>最终，这些将适合缓存</li>
<li>将最小化在每个内存级别之间移动的＃个单词</li>
<li>“遗忘”级别的数量和大小</li>
</ul>
</li>
</ul>
<p>向量化通用准则</p>
<ul>
<li>优先考虑可计数的单入口和单出口“for”循环。它可以作为外部循环索引的功能，也可以作为嵌套循环中最里面的循环的函数。</li>
<li>编写序列代码（避免使用诸如switch，goto或return语句之类的分支，大多数函数调用或不能视为掩码分配的“if”构造）。</li>
<li>避免循环迭代之间的依赖关系，或者至少避免读后写依赖关系。</li>
<li>array首选使用数组表示法而不是指针，尤其是对于C语言。尽可能在数组下标中直接使用循环索引，而不是增加单独的计数器以用作数组地址。</li>
<li>使用有效的内存访问，例如连续访问和对齐访问（16/32字节边界）。并最大程度地减少间接寻址</li>
<li>首选结构阵列（struct of array, SoA）优于结构阵列（array of structure, AoS）</li>
<li>尝试使用矢量化库，包括英特尔®MKL和英特尔®IPP</li>
</ul>
<p>profiling<br>profiling意味着收集有关程序执行的数据。两种主要的性能分析是：</p>
<ul>
<li>Subroutine profiling：插装</li>
<li>Hardware counters：统计</li>
</ul>
<p>假设您有一个hot循环，您认为应该进行矢量化，但没有进行矢量化（如在Vtune，SDE或其他热循环工具中发现的那样）。首先使用适当的编译器选项尝试基本的自动矢量化。使用“ -vec-report2”或更高版本可获取有关循环是否正在向量化的调试信息。要为Intel Xeon E5-2680要求AVX自动矢量化，请使用编译器命令行选项“ -xAVX –O3”。要为Intel Xeon Phi本机可执行文件要求Xeon Phi自动矢量化，请使用编译器命令行选项“ -mmic –O3”。离线编译通常应该给您提供–mmic自动矢量化功能，但是如果需要，您可以使用主机编译器选项-offload-option，compiler，mic，“将任何其他选项传递给Xeon Phi编译器。<br>其他可尝试的内容包括：<br>1.尝试使用“#pragma vector”来禁用编译器的矢量化成本模型。引入此选项后，请始终检查性能。您需要知道的主要事情是向量化器使用启发式算法。根据定义，启发式方法并不总是正确的。<br>2.如果您知道没有真正的依赖关系可以阻止矢量化，请尝试使用“ #pragma ivdep”。引入此选项后，请始终检查正确性和可能的​​崩溃。<br>3.尝试“ #pragma simd”。如果以上两种方法都无法为您提供矢量化代码，请尝试使用此选项。引入此选项后，请始终检查性能，正确性和可能的​​崩溃。<br>不要忘记通过使用编译器–S选项检查汇编并交叉检查源代码行号来“检查工作”。如果您从未编写过汇编文件，那么“检查汇编”听起来可能是一项艰巨的任务。</p>
<p>向量化建议：</p>
<ul>
<li>首先找到您的热循环/热基本块（Vtune，SDE等）</li>
<li>确保数组边界对齐（如果可能）</li>
<li>确保您没有不良依赖关系（即算法可向量化）</li>
<li>首先尝试自动矢量化，例如：<code>–O3 –xAVX –vec-report2 –openmp</code></li>
<li>分析为什么编译器无法进行矢量化，然后尝试：<code>#pragma vector always</code></li>
<li>然后尝试：<code>#pragma ivdep</code></li>
<li>使用：<code>#pragma vector aligned</code>，如果编译器未注意到您的数组已对齐。</li>
<li>然后尝试：<code>#pragma simd</code>：如果它是可向量化的循环，通常将对其向量化。<ul>
<li>无论安全性如何，都强制进行矢量化：检查正确性并进行彻底测试</li>
</ul>
</li>
<li>在工作时定期查阅编译器的–S程序集列表</li>
<li>您可能需要专门标记减少操作，例如<ul>
<li>如果您知道行程计数（循环计数），请使用#pragma loop_count帮助编译器。</li>
<li>在循环周围测试#pragma unroll(N)，以查看它是否有助于提高性能。</li>
</ul>
</li>
</ul>
<p>CP是基本3d形状匹配算法。 ICP基准相对而言一个简单的500行程序，该程序执行ICP算法的复杂度是O(N^2)。由于程序的简单性，我们不仅可以测量单精度和双精度结果，测量阵列结构（structure of array, SoA）和结构阵列（array of structure, AoS）的性能也非常容易。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#if defined(AOS)</span><br><span class="line">#define AOSFLAG 1 // 1 for AoS</span><br><span class="line">#else</span><br><span class="line">#define AOSFLAG 0 // 0 for SoA (default)</span><br><span class="line">#endif</span><br><span class="line">#if defined(DOUBLEPREC)</span><br><span class="line">#define FPPRECFLAG 2 // 2 for Double precision</span><br><span class="line">#define FLOATINGPTPRECISION double</span><br><span class="line">#else</span><br><span class="line">#define FPPRECFLAG 1 // 1 for Single precision (default)</span><br><span class="line">#define FLOATINGPTPRECISION float</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">// AoS </span><br><span class="line">typedef struct Point3d</span><br><span class="line">&#123;</span><br><span class="line">FLOATINGPTPRECISION x,y,z,t; // use of t padding is optional</span><br><span class="line">&#125; Point3d,*Point3dPtr;</span><br><span class="line"></span><br><span class="line">#if AOSFLAG == 1</span><br><span class="line">Point3dPtr org = NULL;</span><br><span class="line">Point3dPtr tfm = NULL;</span><br><span class="line">#endif</span><br><span class="line">#if AOSFLAG == 0 // SoA (set of arrays here, structure of arrays normally)</span><br><span class="line">FLOATINGPTPRECISION *orgx = NULL;</span><br><span class="line">FLOATINGPTPRECISION *orgy = NULL;</span><br><span class="line">FLOATINGPTPRECISION *orgz = NULL;</span><br><span class="line">FLOATINGPTPRECISION *tfmx = NULL;</span><br><span class="line">FLOATINGPTPRECISION *tfmy = NULL;</span><br><span class="line">FLOATINGPTPRECISION *tfmz = NULL;</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>源代码如下，因此我们将列出一个简单的循环以显示程序中的代码类型。 点集的简单旋转和平移明确表示如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#if AOSFLAG == 1</span><br><span class="line">#pragma omp parallel for shared(tfm,Rf,Tf,nxfmpts) private(x,y,z)</span><br><span class="line">for(i=0;i&lt;nxfmpts;i++)</span><br><span class="line">&#123;</span><br><span class="line">	x = tfm[i].x; y = tfm[i].y; z = tfm[i].z;</span><br><span class="line">	tfm[i].x = Rf[0][0]*x + Rf[0][1]*y + Rf[0][2]*z + Tf[0];</span><br><span class="line">	tfm[i].y = Rf[1][0]*x + Rf[1][1]*y + Rf[1][2]*z + Tf[1];</span><br><span class="line">	tfm[i].z = Rf[2][0]*x + Rf[2][1]*y + Rf[2][2]*z + Tf[2];</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#if AOSFLAG == 0</span><br><span class="line">#pragma omp parallel for shared(tfmx,tfmy,tfmz,Rf,Tf,nxfmpts) private(x,y,z)</span><br><span class="line">for(i=0;i&lt;nxfmpts;i++)</span><br><span class="line">&#123;</span><br><span class="line">	x = tfmx[i]; y = tfmy[i]; z = tfmz[i];</span><br><span class="line">	tfmx[i] = Rf[0][0]*x + Rf[0][1]*y + Rf[0][2]*z + Tf[0];</span><br><span class="line">	tfmy[i] = Rf[1][0]*x + Rf[1][1]*y + Rf[1][2]*z + Tf[1];</span><br><span class="line">	tfmz[i] = Rf[2][0]*x + Rf[2][1]*y + Rf[2][2]*z + Tf[2];</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>SoA is better than AoS on “Intel Xeon Phi and Intel Xeon_E5-2680 for both Single and Double Precision.<br>该代码的属性可帮助实现此应用程序的源代码，如下所示：</p>
<ul>
<li>几乎所有读和写都发生第1步访问。</li>
<li>所有数组都是64字节对齐的，并且编译器知道它们是64字节对齐的。</li>
<li>编译器成功地向量化了所有热循环。</li>
<li>循环是高速缓存友好的，以减少内存访问。</li>
<li>主循环中没有除法。</li>
<li>循环非常简单。</li>
</ul>
<p>MPI编程模型：全局地址空间</p>
<ul>
<li>程序由一组命名线程组成。<ul>
<li>通常在程序启动时固定</li>
<li>本地和共享数据，如共享内存模型中一样</li>
<li>但是，共享数据在本地进程中分区</li>
<li>成本模型表明远程数据非常昂贵</li>
</ul>
</li>
<li>示例：UPC，Co-Array Fortran</li>
<li>全局地址空间编程是消息传递和共享内存之间的中间点<ul>
<li>线程等全局地址空间（可编程性）</li>
<li>SPMD并行性，例如MPI（性能）</li>
<li>本地/全局区别，即布局很重要（性能）</li>
</ul>
</li>
</ul>
<p>主流并行程序模型－数据并行</p>
<ul>
<li>单线程模式<ul>
<li>并行操作于聚合数据结构上，一般是数组</li>
<li>隐式相互作用，不需要显式同步</li>
<li>隐式数据分配</li>
</ul>
</li>
<li>缺点<ul>
<li>相对严格的计算结构要求，不是所有应用模式都适合这种模型</li>
<li>在粗粒度的并行机上难于映射</li>
</ul>
</li>
</ul>
<p>现代机器中的“自动”并行性</p>
<ul>
<li>位级并行<ul>
<li>在浮点运算等中</li>
</ul>
</li>
<li>指令级并行性（ILP）<ul>
<li>每个时钟周期执行多个指令</li>
</ul>
</li>
<li>内存系统并行<ul>
<li>内存操作与计算重叠</li>
</ul>
</li>
<li>OS并行性<ul>
<li>在商品SMP上并行运行多个作业</li>
</ul>
</li>
</ul>
<p>常见的并行开销有哪些？</p>
<ul>
<li>创建和销毁并行进程、线程的开销<ul>
<li>创建和销毁进程本身是高开销的工作<ul>
<li>PowerPC 700MHz(每个周期 15ns 执行4flops; 创建一个进程1.4ms，可执行372,000flops)</li>
</ul>
</li>
<li>创建和销毁多个进程的开销在系统中随进程数增加<ul>
<li>启动万规模进程需要s级时间</li>
</ul>
</li>
</ul>
</li>
<li>通信开销是并行开销的主要部分<ul>
<li>多机间的通信开销相对于计算很大</li>
<li>通信模型参数会因很多因素不同而变化<ul>
<li>同时通信的进程数</li>
<li>同时发送的消息数</li>
<li>消息的大小</li>
<li>网络的拓扑结构</li>
<li>网络的拥挤程度</li>
<li>不同的MPI实现</li>
<li>群集消息通信算法</li>
<li>之前发送的消息情况</li>
</ul>
</li>
</ul>
</li>
<li>并行化过程中引入的空间和相应的时间开销<ul>
<li>多进程并行化过程中引入的空间和相应的时间开销<ul>
<li>消息缓冲区准备</li>
<li>交叠数据的分配和使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>回顾编程模型1：共享内存</p>
<ul>
<li>程序是控制线程的集合。</li>
<li>可以在某些语言中执行时动态创建</li>
<li>每个线程都有一组私有变量，例如局部堆栈变量</li>
<li>还有一组共享变量，例如静态变量，共享公共块，全局堆。</li>
<li>线程通过读写共享来隐式通信变量。</li>
<li>线程通过共享变量同步来协调。</li>
</ul>
<p>几个线程库/系统</p>
<ul>
<li>PTHREADS是POSIX标准<ul>
<li>相对较低的水平</li>
<li>便携式但可能很慢； 相对较重</li>
</ul>
</li>
<li>用于应用程序级编程的OpenMP标准<ul>
<li>支持对共享内存进行科学编程</li>
</ul>
</li>
</ul>
<p>POSIX线程概述</p>
<ul>
<li>POSIX：便携式操作系统接口<ul>
<li>与操作系统实用程序的接口</li>
</ul>
</li>
<li>PThreads：POSIX线程接口<ul>
<li>系统调用以创建和同步线程</li>
<li>在类似UNIX的OS平台上应该相对统一</li>
</ul>
</li>
<li>PThread包含对以下几点的支持<ul>
<li>创建并行</li>
<li>同步</li>
<li>不明确支持通信，因为共享内存是隐式的；指向共享数据的指针被传递给线程</li>
</ul>
</li>
</ul>
<p>OpenMP的主要特点</p>
<ul>
<li>面向共享存储体系结构，特别是SMP系统</li>
<li>显式并行方法</li>
<li>基于fork-join的多线程执行模型，但同样可以开发SPMD（Single Program Multi-Data )类型的程序</li>
<li>可以进行增量式并行开发( Incremental development )，支持条件编译( Conditional Compilation )和条件并行</li>
<li>允许嵌套的并行性（nested Parallelism )和动态线程<ul>
<li>并不是在所有的编译器实现中支持</li>
</ul>
</li>
</ul>
<p>线程数目的讨论</p>
<ul>
<li>通常情况下线程组内线程数目由环境变量OMP_NUM_THREADS控制</li>
<li>如果parallel语句有num_threads子句，或者用户调用了omp_set_num_threads函数，线程数目由它们给出，num_threads具有高优先级</li>
<li>上述三种设置方法作用域分别为系统、并行块级以及程序级</li>
<li>这里给出的线程数目可以大于系统中处理器个数，它是一个上限值</li>
<li>系统实际产生的线程数目可能由于资源的限制而比上限值要小</li>
</ul>
<p>并行结构：Work-sharing Construct(1) - loop</p>
<ul>
<li>为线程分配了一组独立的迭代</li>
<li>线程必须在工作共享结构的末尾等待</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp parallel</span><br><span class="line">#pragma omp for</span><br><span class="line">	for(i = 1, i &lt; 13, i++)</span><br><span class="line">		c[i] = a[i] + b[i]</span><br></pre></td></tr></table></figure>
<p>Work-sharing Construct(2): Parallel Sections<br>section中代码的独立部分可以同时执行。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp parallel sections</span><br><span class="line">&#123;</span><br><span class="line">	#pragma omp section</span><br><span class="line">	phase1();</span><br><span class="line">	#pragma omp section</span><br><span class="line">	phase2();</span><br><span class="line">	#pragma omp section</span><br><span class="line">	phase3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Work-sharing Construct(3): Single Construct<br>表示仅由一个线程执行的代码块</p>
<ul>
<li>选择第一个到达的线程</li>
<li>隐式障碍</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp parallel</span><br><span class="line">&#123;</span><br><span class="line">	DoManyThings();</span><br><span class="line">	#pragma omp single</span><br><span class="line">	&#123;</span><br><span class="line">		ExchangeBoundaries();</span><br><span class="line">	&#125; // threads wait here for single</span><br><span class="line">	DoManyMoreThings();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分配迭代：schedule子句影响循环迭代如何映射到线程上</p>
<ul>
<li>schedule(static [,chunk])<ul>
<li>线程大小为“块”的迭代块</li>
<li>循环分配</li>
<li>默认值= N / t</li>
<li>对于Ni个迭代和Nt个线程，每个线程获得Ni/Nt个循环迭代的一个块：</li>
</ul>
</li>
<li>schedule(dynamic[,chunk])<ul>
<li>线程获取“块”迭代</li>
<li>完成迭代后，线程将请求下一组请求</li>
<li>默认值= 1</li>
<li>对于Ni个迭代和Nt个线程，每个线程都会获得k个循环迭代的固定大小的块，当特定线程完成其迭代块时，将为其分配新的块。因此，迭代与线程之间的关系是不确定的。<ul>
<li>优势：非常灵活</li>
<li>缺点：高开销–关于哪个线程获取每个块的大量决策</li>
</ul>
</li>
</ul>
</li>
<li>schedule(guided [，chunk])<ul>
<li>动态计划以大块开始</li>
<li>块的尺寸缩小； 不小于“块”</li>
<li>默认值= 1</li>
<li>对于Ni迭代和Nt线程，最初，每个线程都会获得k &lt;Ni/Nt循环迭代的固定大小的块：</li>
<li>每个线程完成其k次迭代的块之后，它将获得k / 2次迭代的块，然后是k / 4个，依此类推。当线程完成其先前的块时，将动态分配块。<ul>
<li>优于静态：可处理不平衡负载</li>
<li>动态优势：更少的决策，因此更少的开销</li>
</ul>
</li>
</ul>
</li>
<li>schedule(runtime)<ul>
<li>OMP_SCHEDULE</li>
</ul>
</li>
</ul>
<p>现在的消息传递系统多使用三种通信模式:</p>
<ul>
<li>同步的消息传递 (Synchronous Message Passing)</li>
<li>阻塞的消息传递 (Blocking Message Passing)</li>
<li>非阻塞的消息传递 (Nonblocking Message Passing) </li>
</ul>
<p>非阻塞模式为计算和通信重叠带来机会，但本身也会带来一些额外开销:</p>
<ul>
<li>作为临时缓冲区用的内存空间</li>
<li>分配缓冲区的操作</li>
<li>将消息拷入和拷出临时缓冲区</li>
<li>执行一个额外的检测和等待函数</li>
</ul>
<p>消息缓冲(message buffer, 简称buffer), 在不同的消息传递使用场合有不同的含义. 下面给出一些例子:</p>
<ul>
<li>消息缓冲指的是由程序员定义的应用程序的存储区域, 用于存放消息的数据值.例如, 在Send(A, 16, Q, tag)中, 缓冲A是在用户应用程序中声明的变量.</li>
<li>缓冲的起始地址在消息例程中被使用.</li>
<li>消息缓冲也可以指由消息传递系统(而非用户)创建和管理的一些内存区, 它用于发送消息时暂存消息. 这种缓冲不在用户的应用程序中出现, 有时被称为(消息传递)统消息缓冲(或系统缓冲).</li>
<li>MPI允许第三种可能的定义. 用户可以划出一定大小的内存区, 作为出现在其应用中的任意消息的中间缓冲. </li>
</ul>
<p>用在MPI中的通信模式(communication mode)：</p>
<ul>
<li>同步的(synchronous)：直到相应的接收已经启动，发送才返回<ul>
<li>阻塞的同步发送：发送缓冲区可用，发送完成</li>
<li>非阻塞的同步发送：它的返回不意味着消息已经被发出! 它的实现不需要在接收端有附加的缓冲, 但需要在发送端有一个系统缓冲. 为了消除额外的消息拷贝, 应使用阻塞的同步发送</li>
</ul>
</li>
<li>缓冲的(buffered)：缓冲的发送假定能得到一定大小的缓冲空间, 它必须事先由用户程序分配和管理。通过调用子例程<code>MPI_Buffer_attch(buffer,size)</code>来定义, 由它来分配大小为size的用户缓冲. 这个缓冲可以用<code>MPI_Buffer_detach(*buffer, *size )</code>来实现.无缓冲区时，返回错误.</li>
<li>就绪的(ready)：<ul>
<li>在肯定相应的接收已经开始才进行发送. 它不像在同步模式中那样需要等待. 这就允许在相同的情况下实际使用一个更有效的通信协议.使用较少，程序员要保证程序正确性</li>
</ul>
</li>
<li>标准的(standard)：最常用的模式。发送可以是同步的或缓冲的(系统缓冲), 取决于实现，给予系统以灵活选择的机会；发送的返回意味着消息缓冲区可用</li>
</ul>
<p>常见错误调试心得</p>
<ul>
<li>确保栈空间分配的有效性<ul>
<li>ulimit –s unlimited (可以根据需要调整)</li>
<li>export KMP_STACKSIZE=16000000 (可以根据需要调整)</li>
</ul>
</li>
<li>确保串行程序的正确执行（OMP_NUM_THREADS=1）</li>
<li>验证private变量使用的正确性</li>
<li>逐项确保变量的使用了然于胸，特别是f90: SAVE, DATA, default(none), private(…), shared(…)</li>
<li>利用增量级开发的特性进行代码二分查找</li>
<li>确认是否由于舍入误差导致</li>
<li>对于连加等可能由于计算次序导致不同计算结果的操作，不使用reduction子句，将加法部分放到串行区完成</li>
<li>借助Intel Inspector，totalview等工具寻找数据竞争问题</li>
</ul>
<p>处理器：多核时代</p>
<ul>
<li>想法1：使用增加的晶体管数量添加更多处理器核心，而不是使用晶体管来增加。先进的处理器逻辑加速单个指令流（例如，乱序和投机操作）</li>
<li>想法2：添加ALU以提高计算能力。摊销跨多个ALU管理指令流的成本/复杂性。SIMD处理，一条指令，多个数据向所有ALU广播相同的指令在所有ALU上并行执行</li>
</ul>
<p>指令流一致性（“一致性执行”）</p>
<ul>
<li>相同的指令序列适用于同时操作的所有元素</li>
<li>要有效利用SIMD处理资源，必须执行一致的执行</li>
<li>由于每个内核都具有获取/解码不同指令流的能力，因此对于内核之间的高效并行化而言，一致性执行不是必需的</li>
<li>“分散”执行<ul>
<li>缺乏指令流一致性</li>
</ul>
</li>
</ul>
<p>在现代CPU上执行SIMD</p>
<ul>
<li>SSE指令：128位操作：4x32位或2x64位（4宽格式向量）</li>
<li>AVX2指令：256位操作：8x32位或4x64位（8宽格式向量）</li>
<li>AVX512指令：512位操作：16x32位…</li>
<li>指令由编译器生成<ul>
<li>程序员使用内在函数明确要求的并行性</li>
<li>使用并行语言语义传达的并行性（例如，forall示例）</li>
<li>通过对循环的依赖性分析推断出并行性（困难的问题，即使是最好的编译器也不能在任意C / C ++代码上使用）</li>
</ul>
</li>
<li>术语：“显式SIMD”：SIMD并行化在编译时执行</li>
</ul>
<p>在许多现代GPU上执行SIMD</p>
<ul>
<li>“隐含SIMD”<ul>
<li>编译器生成标量二进制（标量指令）</li>
<li>但是程序的N个实例始终在处理器上<strong>一起运行</strong>，<code>execute(my_function，N)</code>，执行my_function N次</li>
</ul>
</li>
<li>换句话说，硬件本身的接口是数据并行的</li>
<li>硬件（不是编译器）负责同时从多个实例对SIMD ALU上的不同数据执行同一条指令</li>
<li>大多数现代GPU的SIMD宽度为8到32</li>
<li>分歧可能是个大问题（写得不好的代码可能以机器峰值能力的1/32执行！）</li>
</ul>
<p>摘要：并行执行</p>
<ul>
<li>现代处理器中的几种并行执行形式<ul>
<li>多核：使用多个处理核<ul>
<li>提供线程级并行性：在每个内核上同时执行完全不同的指令流</li>
<li>软件决定何时创建线程（例如，通过pthreads API）</li>
</ul>
</li>
<li>SIMD：使用同一指令流（在内核内）控制的多个ALU<ul>
<li>高效的数据并行工作负载设计：控制可摊销许多ALU</li>
<li>矢量化可以由编译器（显式SIMD）完成，也可以在运行时由硬件完成</li>
<li>[缺乏]依赖关系在执行之前就已经知道（通常由程序员声明，但可以通过高级编译器的循环分析来推断）</li>
</ul>
</li>
<li>超标量：在指令流中利用ILP。 处理来自相同的指令流并行（在内核内）<ul>
<li>硬件在执行过程中自动动态发现并行性（程序员看不到）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>多线程减少了停顿</p>
<ul>
<li>想法：对同一核心上的多个线程进行交错处理以隐藏停顿</li>
<li>与预取一样，多线程隐藏了延迟，而不是减少延迟的技术</li>
</ul>
<p>硬件支持的多线程</p>
<ul>
<li>Core管理多个线程的执行上下文<ul>
<li>从可运行线程运行指令（处理器决定每个时钟运行哪个线程，而不是操作系统的运行）</li>
<li>核心仍然具有相同数量的ALU资源：多线程仅在面对诸如内存访问之类的高延迟操作时才有助于更有效地使用它们</li>
</ul>
</li>
<li>交错多线程（也称为时间多线程）<ul>
<li>每个时钟，内核都会选择一个线程，并在ALU上运行来自该线程的指令（交织多线程）</li>
</ul>
</li>
<li>同时多线程（SMT，同时多线程）<ul>
<li>每个时钟，内核从多个线程中选择指令以在ALU上运行</li>
<li>扩展超标量CPU设计</li>
<li>示例：英特尔超线程（每个内核2个线程）</li>
</ul>
</li>
</ul>
<p>多线程摘要</p>
<ul>
<li>优势：更有效地利用核心的ALU资源<ul>
<li>隐藏内存延迟</li>
<li>填充超标量架构的多个功能单元（当一个线程的ILP不足时）</li>
</ul>
</li>
<li>劣势<ul>
<li>需要额外存储线程上下文</li>
<li>增加任何单线程的运行时间（通常不是问题，我们通常关心并行应用程序中的吞吐量）</li>
<li>需要程序中的其他独立工作（比ALU更加独立！）</li>
<li>严重依赖内存带宽</li>
<li>更多线程→更大的工作集→每个线程更少的缓存空间</li>
<li>可能会更频繁地进入内存，但可以隐藏延迟</li>
</ul>
</li>
</ul>
<p>带宽是至关重要的资源。高性能并行程序将：</p>
<ul>
<li>组织计算以减少从内存中获取数据的频率<ul>
<li>重用先前由同一线程加载的数据（传统的线程内时间局部性优化）</li>
<li>跨线程共享数据（线程间协作）</li>
</ul>
</li>
<li>减少请求数据的频率（取而代之的是做更多的算术：“免费”）<ul>
<li>有用的术语：“算术强度” —指令流中数学运算与数据访问运算的比率</li>
<li>要点：程序必须具有很高的算术强度才能有效利用现代处理器</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/28/cpp11%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/28/cpp11%E7%89%B9%E6%80%A7/" itemprop="url">C++11特性笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-28T20:13:00+08:00">
                2020-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用C-11让程序更简洁"><a href="#使用C-11让程序更简洁" class="headerlink" title="使用C++11让程序更简洁"></a>使用C++11让程序更简洁</h1><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>引入auto和decltype。</p>
<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto i = 10; // i是int</span><br><span class="line">auto pu = new auto(1); // pu是int*</span><br><span class="line">const auto *v = &amp;i, u = 6; // v是const int*，u是const int</span><br><span class="line">auto s; //错误，无法推断</span><br></pre></td></tr></table></figure>
<p>初始化不能使编译器推导产生二义性，如把u写成<code>u=6.0</code>则不予通过。<br>使用auto声明的变量必须马上初始化，以让编译器推断出类型并在编译时将auto替换为真正的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int x = 0;  //</span><br><span class="line">auto * a = &amp;x;  // a是int*，auto被推导为int</span><br><span class="line">auto b = &amp;x;  // b是int*，auto被推导为int*</span><br><span class="line">auto &amp; c = x;  // c是int&amp;，auto被推导为int</span><br><span class="line">auto d = c;  // d是int，auto被推导为int</span><br><span class="line"></span><br><span class="line">const auto e = x;  // e是const int</span><br><span class="line">auto f = e;  // f是int</span><br><span class="line">cosnt auto &amp; g = x;  // g是const int&amp;</span><br><span class="line">auto &amp; h = g;  // h是const int&amp;</span><br></pre></td></tr></table></figure>
<p>a和c的类型推导结果很明显，auto在编译时被替换为int，b的推导结果表明auto不声明为指针，也可以推导出指针类型；d的推导结果表明当表达式是一个引用类型时，auto会把引用类型抛弃，直接推导成原始类型int。f的推导结果表明表达式带有const时，auto会把const属性抛弃掉，推导成non-const的int。规则如下：</p>
<ul>
<li>当不声明为指针或引用时，auto的推导结果和初始化表达式抛弃引用和cv限定符（const和volatile）后类型一致</li>
<li>当声明为指针或引用时，auto的推导结果将保留初始化表达式的cv属性。</li>
<li>auto不能用为函数参数。</li>
<li>auto无法定义数组！</li>
</ul>
<p>auto的推导和函数模板参数的自动推导有相似之处。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; void func(T x) &#123;&#125; // T -&gt; auto</span><br><span class="line">template &lt;typename T&gt; void func(T *x)&#123;&#125; // T -&gt; auto*</span><br><span class="line">template &lt;typename T&gt; void func(T&amp; x)&#123;&#125; // T&amp;-&gt; auto&amp;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; void func(const T x) &#123;&#125; // const T -&gt; const auto</span><br><span class="line">template &lt;typename T&gt; void func(const T* x)&#123;&#125; // const T*-&gt; const auto *</span><br><span class="line">template &lt;typename T&gt; void func(const T&amp; x)&#123;&#125; // const T&amp;-&gt; const auto &amp;</span><br><span class="line">注意:auto是不能用于函数参数的。</span><br></pre></td></tr></table></figure></p>
<p>何时使用auto？看一个例子，在一个unordered_multimap中查找一个范围,代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	std::unordered_multimap&lt;int, int&gt; resultMap;</span><br><span class="line">	std::pair&lt;std::unordered_multimap&lt;int, int&gt;::iterator, std::unordered_multimap&lt;int, int&gt;::iterator&gt; range = resultMap.equal_range(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个 equal_ange返回的类型声明显得烦琐而冗长,而且实际上并不关心这里的具体类型（大概知道是一个std::pair就够了）。这时,通过auto就能极大的简化书写,省去推导具体类型的过程<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	std::unordered_multimap&lt;int, int&gt; map;</span><br><span class="line">	auto range_map.equal_range(key);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>auto所修饰的变量必须被初始化，C++11新增了decltype关键字，用来在编译时推导出一个表达式的类型。<code>decltype(exp)</code>，exp是一个表达式。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int x = 0;</span><br><span class="line">decltype(x) y = 1; // y -&gt; int</span><br><span class="line">decltype(x + y) z = 0; // z -&gt; int</span><br><span class="line"></span><br><span class="line">const int&amp; i = x;</span><br><span class="line">decltype(i) j = y; // j -&gt; const int &amp;</span><br><span class="line"></span><br><span class="line">const decltype(z) * p = &amp;z; // *p -&gt; const int, p -&gt; const int *</span><br><span class="line">decltype(z) * pi = &amp;z; // * pi -&gt; int, pi -&gt; int*</span><br><span class="line">decltype(pi) * pp = &amp;pi; // *pp -&gt; int *, pp -&gt; int **</span><br></pre></td></tr></table></figure></p>
<p>y和z的结果表明，decltype可以根据表达式直接推导出它的类型本身。这个功能和上节的auto很像,但又有所不同。auto只能根据变量的初始化表达式推导出变量应该具有的类型。若想要通过某个表达式得到类型,但不希望新变量和这个表达式具有同样的值,此时auto就显得不适用了。<br>j的结果表明decltype通过表达式得到的类型,可以保留住表达式的引用及const限定符。实际上，对于一般的标记符表达式(id-expression)，decltype将精确地推导出表达式定义本身的类型，不会像auto那样在某些情况下舍弃掉引用和cv限定符。p、pi的结果表明decltype可以像auto一样，加上引用和指针，以及cv限定符。</p>
<p>pp的推导则表明,当表达式是一个指针的时候，decltype仍然推导出表达式的实际类型（指针类型），之后结合pp定义时的指针标记，得到的pp是一个二维指针类型。这也是和auto推导不同的一点。</p>
<p>推导规则：</p>
<ul>
<li>exp是标识符、类访问表达式，decltype(type)和exp的类型一致；</li>
<li>exp是函数调用，decltype(type)和函数返回值类型一致；</li>
<li>若exp是一个左值，则decltype(type)是exp类型的左值引用，否则和exp类型一致。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Foo &#123;int x;&#125;;</span><br><span class="line">const Foo foo = Foo();</span><br><span class="line"></span><br><span class="line">decltype(foo.x) a = 0;   // a -&gt; int</span><br><span class="line">decltype((foo.x)) b = a; // b -&gt; const int &amp;</span><br></pre></td></tr></table></figure>
<p>a的类型就是foo.x的类型，foo.x是一个左值，可知括号表达式也是一个左值，decltype的类型是一个左值引用。</p>
<p>在泛型编程中，可能需要通过参数运算获得返回值类型：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename R, typename T, typename U&gt;</span><br><span class="line">R add(T t, U u) &#123;</span><br><span class="line">	return t+u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a = 1;</span><br><span class="line">float b = 2.0;</span><br><span class="line">auto c = add&lt;decltype(a+b)&gt;(a, b);</span><br></pre></td></tr></table></figure><br>改成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line">decltype(T()+U()) add(T t, U u) &#123;</span><br><span class="line">	return t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>考虑到T、U可能是没有无参构造函数的类，可以如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line">decltype((*(T*)0) + (*(U*)0)) add(T t, U u) &#123;</span><br><span class="line">	return t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回类型后置语法通过auto和decltype结合使用，可以写成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line">auto add(T t, U u) -&gt; decltype(t + u) &#123;</span><br><span class="line">	return t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>返回类型后置语法解决了返回值类型依赖于参数而导致难以确定返回值类型的问题。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int&amp; foo(int&amp; i);</span><br><span class="line">float foo(float&amp; f);</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">auto func(T&amp; val) -&gt; decltype(foo(val)) &#123;</span><br><span class="line">	return foo(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="模板的细节改进"><a href="#模板的细节改进" class="headerlink" title="模板的细节改进"></a>模板的细节改进</h2><h3 id="模板的右尖括号"><a href="#模板的右尖括号" class="headerlink" title="模板的右尖括号"></a>模板的右尖括号</h3><p>尽可能将多个右尖括号解析成模板参数结束符。</p>
<h3 id="模板的别名"><a href="#模板的别名" class="headerlink" title="模板的别名"></a>模板的别名</h3><p>重定义一个模板<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Val&gt;</span><br><span class="line">using str_map_t = std::map&lt;std::string, Val&gt;;</span><br><span class="line"></span><br><span class="line">str_map_t&lt;int&gt; map1;</span><br></pre></td></tr></table></figure><br>使用新的using别名语法定义了std::map的模板别名str_map_t。<br>实际上，using的别名语法覆盖了typedef的全部功能，两种使用方法等效。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef unsigned int uint_t;</span><br><span class="line">using uint_t = unsigned int;</span><br><span class="line"></span><br><span class="line">typedef std::map&lt;std::string, int&gt; map_int_t;</span><br><span class="line">using map_int_t = std::map&lt;std::string, int&gt;;</span><br></pre></td></tr></table></figure></p>
<p>using定义模板别名：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">using func_t = void(*)(T, T);</span><br><span class="line">func_t&lt;int&gt; xx_2;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数模板的默认模板参数"><a href="#函数模板的默认模板参数" class="headerlink" title="函数模板的默认模板参数"></a>函数模板的默认模板参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T = int&gt;</span><br><span class="line">void func(void) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>当所有模板参数都有默认参数时，函数模板的调用如同一个普通参数，对于类模板而言，哪怕所有参数都有默认参数，在使用时也要在模板名后跟一个“&lt;&gt;”实例化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename R = int, typename U&gt;</span><br><span class="line">R func(U val) &#123;</span><br><span class="line">	val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	func(123);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用函数模板时，若显式指定模板参数，由于参数填充顺序是从左往右的，因此，像下面这个调用，<code>func&lt;long&gt;(123)</code>，func的返回值是long，而不是int。</p>
<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>在C++98/03中的对象初始化方法有多种。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int i_arr[3] = &#123;1, 2, 3&#125;;</span><br><span class="line"></span><br><span class="line">struct A &#123;</span><br><span class="line">	int x;</span><br><span class="line">	struct B &#123;</span><br><span class="line">		int i;</span><br><span class="line">		int j;</span><br><span class="line">	&#125; b;</span><br><span class="line">&#125; a = &#123; 1, &#123;2, 3&#125; &#125;;</span><br><span class="line"></span><br><span class="line">int i = 0;</span><br><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	Foo(int) &#123;&#125;</span><br><span class="line">&#125; foo = 123;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>C++11中提出了列表初始化的概念。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo a3 = &#123;123&#125;;</span><br><span class="line">Foo a4 &#123;123&#125;;</span><br><span class="line"></span><br><span class="line">int a5 = &#123;3&#125;;</span><br><span class="line">int s6 &#123;3&#125;;</span><br></pre></td></tr></table></figure><br>a3虽然使用了等于号，但是仍然是列表初始化，因此，私有的拷贝构造不会影响到它。<br>a4和a6的写法是C++98/03不具备的，可以直接在变量名后跟上初始化列表，来进行对象的初始化。</p>
<p>new操作符等可以用圆括号初始化的地方可以使用初始化列表：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* a = new int &#123;123&#125;;</span><br><span class="line">double b = double &#123;123&#125;;</span><br><span class="line">int* arr = new int[3] &#123;1, 2, 3&#125;;</span><br></pre></td></tr></table></figure></p>
<p>聚合类型：</p>
<ul>
<li>类型是一个普通数组</li>
<li>类型是一个类，且<ul>
<li>无用户定义的构造函数</li>
<li>无私有或保护的非静态数据成员</li>
<li>无基类</li>
<li>无虚函数</li>
<li>不能有{}和=直接初始化的非静态数据成员</li>
</ul>
</li>
</ul>
<p>对数组而言，只要该类型是一个普通数组，哪怕数组的元素并非聚合类型，这个数组本身也是一个聚合类型：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x[] = &#123;1, 3, 5&#125;;</span><br><span class="line">float y[4][3] = &#123;</span><br><span class="line">	&#123;1, 3, 5&#125;,</span><br><span class="line">	&#123;2, 4, 6&#125;,</span><br><span class="line">	&#123;3, 5, 7&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当类型是一个类时，首先是存在用户自定义构造函数时，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Foo &#123;</span><br><span class="line">	int x;</span><br><span class="line">	double y;</span><br><span class="line">	int z;</span><br><span class="line">	Foo(int, int) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Foo foo&#123;1, 2.5, 1&#125;;  // ERROR!</span><br></pre></td></tr></table></figure><br>这时无法将Foo看成一个聚合类型，必须以自定义构造函数构造对象。<br>如果受保护（protected）成员是一个static的，则可以不放在初始化列表里。<br>如果类定义里的成员变量已经有了赋值，则不可以使用初始化列表。</p>
<p><strong>上述不可使用初始化列表的情况可以通过自定义构造函数实现使用初始化列表</strong></p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><h4 id="任意长度初始化列表"><a href="#任意长度初始化列表" class="headerlink" title="任意长度初始化列表"></a>任意长度初始化列表</h4><p>C++11中的stl容器拥有和未显示指定长度的数组一样的初始化能力：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int arr[] = &#123;1, 2, 3&#125;;</span><br><span class="line">std::map&lt;std::string, int&gt; mm = &#123; &#123;&quot;1&quot;, 1&#125;, &#123;&quot;2&quot;, 2&#125;, &#123;&quot;3&quot;, 3&#125; &#125;;</span><br><span class="line">std::set&lt;int&gt; ss = &#123;1, 2, 3&#125;;</span><br><span class="line">std::vector&lt;int&gt; arr = &#123;1, 2, 3, 4, 5&#125;;</span><br></pre></td></tr></table></figure><br>这里arr未显式指定长度，因此它的初始化列表可以是任意长度。<br>实际上stl中的容器是通过使用<code>std::initializer_list</code>这个类模板完成上述功能的，如果在类Foo中添加一个<code>std::initializer_list</code>构造函数，它也将拥有这种能力。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">	std::vector&lt;int&gt; content;</span><br><span class="line">public:</span><br><span class="line">	Foo(std::initializer_list&lt;int&gt; list) &#123;</span><br><span class="line">		for(auto it = list.begin(); it != list.end(); it ++)&#123;</span><br><span class="line">			content.push_back(*it);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Foo1 &#123;</span><br><span class="line">	std::map&lt;int, int&gt; content;</span><br><span class="line">	using pair_t = std::map&lt;int, int&gt;::value_type;</span><br><span class="line">public:</span><br><span class="line">	Foo1(std::initializer_list&lt;int&gt; list) &#123;</span><br><span class="line">		for(auto it = list.begin(); it != list.end(); it ++)&#123;</span><br><span class="line">			content.insert(*it);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo foo = &#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">Foo1 foo1 = &#123; &#123;1, 2&#125;, &#123;2, 3&#125;, &#123;3, 4&#125; &#125;;</span><br></pre></td></tr></table></figure><br>用来传递同类型的数据集合：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func(std::initializer_list&lt;int&gt; list) &#123;</span><br><span class="line">	for(auto it = list.begin(); it != list.end(); it ++)&#123;</span><br><span class="line">		std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>std::initializer_list</code>的一些特点：</p>
<ul>
<li>轻量级容器类型，内部定义了iterator等；</li>
<li>对于<code>std::initializer_list&lt;T&gt;</code>，可以接受任意长度的初始化列表，但要求必须时同种类型；</li>
<li>有三个成员接口：<code>size()</code>、<code>begin()</code>、<code>end()</code>；</li>
<li>只能被整体初始化或赋值。</li>
<li>只能通过begin和end循环遍历，遍历时取得的迭代器是只读的，因此无法修改其中一个值。</li>
<li>实际上，<code>std::initializer_list</code>非常高效，内部并不负责保存初始化列表中元素的拷贝，而是只储存列表中元素的引用而已。</li>
</ul>
<h3 id="防止类型收窄"><a href="#防止类型收窄" class="headerlink" title="防止类型收窄"></a>防止类型收窄</h3><p>类型收窄指导致数据内容发生变化或精度损失的隐式类型转换，包含以下几种：</p>
<ul>
<li>从浮点数隐式转换为整型；</li>
<li>从高精度浮点数转换为低精度浮点数，如从long double转换为double或float；</li>
<li>从整型数隐式转换为浮点数，并超过了浮点数表示范围；</li>
<li>从整型数隐式转换为长度较短的整型数。</li>
</ul>
<p>初始化列表不会允许类型收窄的转换发生。</p>
<h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><h3 id="for循环的新用法"><a href="#for循环的新用法" class="headerlink" title="for循环的新用法"></a>for循环的新用法</h3><p>在<code>&lt;algorithm&gt;</code>中有<code>for_each</code>可以用于遍历：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void do_cout(int n) &#123;</span><br><span class="line">	std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	std::vector&lt;int&gt; arr;</span><br><span class="line">	std::for_each(arr.begin(), arr.end(), do_cout);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以改成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	std::vector&lt;int&gt; arr;</span><br><span class="line">	for(auto n : arr) &#123;</span><br><span class="line">		std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>n表示arr中的一个个元素，auto则是让编译器自动推导n的类型，在这里n的类型被自动推导为vector中的元素类型int。<br>基于范围的for循环对于冒号前边的局部变量声明只要求能支持容器类型的隐式转换。<br>如果需要在遍历时修改容器中的值，则需要使用引用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(auto&amp; n : arr) &#123;</span><br><span class="line">	std::cout &lt;&lt; n++ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="基于范围的for循环的细节"><a href="#基于范围的for循环的细节" class="headerlink" title="基于范围的for循环的细节"></a>基于范围的for循环的细节</h3><p>auto自动推导出的类型是容器中的value_type，而不是迭代器：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, int&gt; mm = &#123; &#123;&quot;1&quot;, 1&#125;, &#123;&quot;2&quot;, 2&#125;, &#123;&quot;3&quot;, 3&#125; &#125;;</span><br><span class="line">for(auto ite = mm.begin(); ite != mm.end(); ite ++)</span><br><span class="line">	std::cout &lt;&lt; ite-&gt;first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; ite-&gt;second &lt;&lt; std::endl;</span><br><span class="line">for(auto&amp; val : mm) </span><br><span class="line">	std::cout &lt;&lt; ite.first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; ite.second &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><br>从这里就可以看出，在基于范围的for循环中每次迭代时使用的类型和普通for循环有何不同。</p>
<p><strong>对基于范围的for循环而言，冒号后边的表达式只会被执行一次</strong></p>
<p><strong>基于范围的for循环倾向于在循环开始之前确定好迭代的范围，而不是在每次迭代之前都调用一次arr.end()</strong></p>
<h3 id="让基于范围的for循环支持自定义类型"><a href="#让基于范围的for循环支持自定义类型" class="headerlink" title="让基于范围的for循环支持自定义类型"></a>让基于范围的for循环支持自定义类型</h3><p>基于范围的for循环将以以下方式查找容器的begin和end：</p>
<ul>
<li>若容器是一个普通的array对象，那么begin将为array的首地址；</li>
<li>若容器是一个类对象，那么range-based for将试图通过查找类的begin()和end()方法来定位begin和end迭代器；</li>
<li>否则range-based for将试图使用全局的begin和end函数定位begin和end；</li>
</ul>
<p>对于自定义类型来说，实现begin和end方法即可，通过定义一个range对象看看具体的实现方法。<br>首先需要一个迭代器实现范围取值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class iterator &#123;</span><br><span class="line">public:</span><br><span class="line">	using value_type = T;</span><br><span class="line">	using size_type = size_t;</span><br><span class="line"></span><br><span class="line">	iterator(size_type cur_start, value_type begin_val, value_type step_val);</span><br><span class="line">	value_type operator*() const;</span><br><span class="line">	bool operator!=(const iterator&amp; rhs);</span><br><span class="line">	iterator&amp; operator++(void);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>构造函数传递三个参数初始化，分别是开始的迭代次数，初始值和迭代步长。<code>operator*</code>用于取得迭代器中的值；<code>operator!=</code>用于和另一个迭代器比较；<code>operator++</code>用于对迭代器做正向迭代。</p>
<p>迭代器类的实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class iterator &#123;</span><br><span class="line">private:</span><br><span class="line">	size_type cursor_;</span><br><span class="line">	const value_type step_;</span><br><span class="line">	value_type value_;</span><br><span class="line">public:</span><br><span class="line">	using value_type = T;</span><br><span class="line">	using size_type = size_t;</span><br><span class="line"></span><br><span class="line">	iterator(size_type cur_start, value_type begin_val, value_type step_val):</span><br><span class="line">	cursor_(cur_start), step_(step_val), value_(begin_val) &#123;</span><br><span class="line">		value_ += (step_ * cursor_);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	value_type operator*() const &#123; return value_; &#125;</span><br><span class="line">	bool operator!=(const iterator&amp; rhs) const &#123; return (cursor_ != rhs.cursor_); &#125;</span><br><span class="line">	iterator&amp; operator++(void) &#123; </span><br><span class="line">		value_ += step_;</span><br><span class="line">		++ cursor_;</span><br><span class="line">		return (*this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="std-function和bind绑定器"><a href="#std-function和bind绑定器" class="headerlink" title="std::function和bind绑定器"></a>std::function和bind绑定器</h2><h3 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h3><p>可调用对象有如下几种定义：</p>
<ul>
<li>是一个函数指针</li>
<li>是一个具有operator()成员函数的类对象</li>
<li>是一个可被转换为函数指针的类对象</li>
<li>是一个类成员指针</li>
</ul>
<p>应用如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void func(void) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">struct Foo &#123;</span><br><span class="line">	void operator()(void) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Bar &#123;</span><br><span class="line">	using fr_t = void(*)(void);</span><br><span class="line"></span><br><span class="line">	static void func(void) &#123; ... &#125;</span><br><span class="line">	operator fr_t(void) &#123; return func; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct A &#123;</span><br><span class="line">	int a_;</span><br><span class="line">	void mem_func(void) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	void(* func_ptr)(void) = &amp;func; // 1.函数指针</span><br><span class="line">	func_ptr();</span><br><span class="line"></span><br><span class="line">	Foo foo;</span><br><span class="line">	foo();	// 2. 仿函数</span><br><span class="line"></span><br><span class="line">	Bar bar;</span><br><span class="line">	bar();	// 3. 可被转换为函数指针的类对象</span><br><span class="line"></span><br><span class="line">	void (A::*mem_func_ptr)(void) = &amp;A::mem_func;	// 4. 类成员函数指针</span><br><span class="line">	int A::*mem_obj_ptr = &amp;A::a_;	// 或是类成员指针</span><br><span class="line"></span><br><span class="line">	A aa;</span><br><span class="line">	(aa.*mem_func_ptr)();</span><br><span class="line">	aa.*mem_obj_ptr = 123;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="可调用对象包装器-std-function"><a href="#可调用对象包装器-std-function" class="headerlink" title="可调用对象包装器-std::function"></a>可调用对象包装器-std::function</h3><p>std::function是可调用对象包装器。它是一个类模板，可以容纳除了类成员指针之外的所有可调用对象。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">void func(void) &#123;</span><br><span class="line">	std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">	static int foo_func(int a) &#123;</span><br><span class="line">		std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;) -&gt;: &quot;;</span><br><span class="line">		return a; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Bar &#123;</span><br><span class="line">public:</span><br><span class="line">	int operator()(int a) &#123;</span><br><span class="line">		std::cout &lt;&lt; __FUNCTION__ &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;) -&gt;: &quot;;</span><br><span class="line">		return a; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	std::function&lt;void(void)&gt; fr1 = func;</span><br><span class="line">	fr1();</span><br><span class="line"></span><br><span class="line">	std::function&lt;int(int)&gt; fr2 = Foo::foo_func;</span><br><span class="line">	std::cout &lt;&lt; fr2(123) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	Bar bar;</span><br><span class="line">	fr2 = bar;</span><br><span class="line">	std::cout &lt;&lt; fr2(123) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>结果是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func</span><br><span class="line">foo_func(123) -&gt;: 123</span><br><span class="line">operator()(123) -&gt;: 123</span><br></pre></td></tr></table></figure></p>
<p>给std::function填入合适的函数名，它就变成一个可以容纳所有这一类调用方式的函数包装器。</p>
<p>std::function作为函数入参：<code>void call(int x, std::function&lt;void(int)&gt;&amp; f)</code></p>
<h2 id="std-bind绑定器"><a href="#std-bind绑定器" class="headerlink" title="std::bind绑定器"></a>std::bind绑定器</h2><p>std::bind绑定器用来将可调用对象与其参数一起进行绑定，绑定后的结果使用std::function保存，并延迟调用到任何我们需要的时候，用途为：</p>
<ul>
<li>将可调用对象与其参数一起绑定成为一个仿函数；</li>
<li>将多元可调用对象转成一元或者(n-1)元可调用对象，即只绑定部分参数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	auto fr = std::bind(output, std::placeholders::_l);</span><br><span class="line">	for( int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">		call_when_even(i, fr);</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	auto fr2 = std::bind(output_2, std::placeholders::_l);</span><br><span class="line">	for( int i = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">		call_when_even(i, fr);</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们使用了std::bind，在函数外部通过绑定不同的函数，控制了最后的执行结果。我们使用<code>auto fr</code>保存<code>std::bind</code>的返回结果，是因为我们并不关心<code>std::bind</code>真正的返回类型（实际上<code>std::bind</code>的返回类型是一个stl内部定义的仿函数类型），只需要知道它是一个仿函数，可以直接赋值给一个std::function。当然，这里直接使用<code>std::function</code>类型来保存<code>std::bind</code>的返回值也是可以的。</p>
<p><code>std::placeholders::_1</code>是一个占位符，代表这个位置将在函数调用时，被传入的第一个参数所替代。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">void output(int x, int y) &#123;</span><br><span class="line">	std::cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	std::bind(output, 1, 2)();</span><br><span class="line">	std::bind(output, std::placeholders::_1, 2)(1);</span><br><span class="line">	std::bind(output, 2, std::placeholders::_1)(1);</span><br><span class="line">	std::bind(output, 2, std::placeholders::_2)(1);</span><br><span class="line">	std::bind(output, 2, std::placeholders::_2)(1, 2);</span><br><span class="line">	std::bind(output, std::placeholders::_1, std::placeholders::_2)(1, 2);</span><br><span class="line">	std::bind(output, std::placeholders::_2, std::placeholders::_1)(1, 2);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式有如下优点：</p>
<ul>
<li>声明式编程风格：就地匿名定义目标函数或函数对象，不需要额外写一个命名函数或者函数对象。以更直接的方式去写程序，有更好的可读性和可维护性。</li>
<li>简洁：不需要额外再写一个函数或者函数对象，避免了代码膨胀和功能分散，让开发者更加集中精力在手边的问题，同时也获取了更高的生产率。</li>
<li>在需要的时间和地点实现功能闭包，使程序更灵活。</li>
</ul>
<h3 id="lambda表达式的概念和基本用法"><a href="#lambda表达式的概念和基本用法" class="headerlink" title="lambda表达式的概念和基本用法"></a>lambda表达式的概念和基本用法</h3><p>lambda表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。 lambda表达式的语法形式可简单归纳如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture] (params) opt -&gt; ret &#123; body; &#125;</span><br></pre></td></tr></table></figure><br>其中：capture是捕获列表； params是参数表；opt是函数选项；ret是返回值类型；body是函数体。一个完整的lambda表达式看起来像这样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto f = [](int a)-&gt; int &#123; return a + 1; &#125;;</span><br><span class="line">std::cout &lt;&lt; f(1) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><br>输出：<code>2</code>。可以看到，上面通过一行代码定义了一个小小的功能闭包，用来将输入加1并返回。</p>
<p>在C++11中，lambda表达式的返回值是通过前面介绍的返回值后置语法来定义的。其实很多时候，lambda表达式的返回值是非常明显的，比如上例。因此，C++中允许省略lambda表达式的返回值定义：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f= [] (int a) return a + 1; &#125;;</span><br></pre></td></tr></table></figure><br>这样编译器就会根据 return语句自动推导出返回值类型。</p>
<p>另外，lambda表达式在没有参数列表时，参数列表是可以省略的。因此像下面的写法都是正确的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto fl =[]()&#123; return 1; &#125;;</span><br><span class="line">auto f2 = []&#123; return 1; &#125;;</span><br><span class="line">//省略空参数表</span><br></pre></td></tr></table></figure><br>lambda表达式可以通过捕获列表捕获一定范围内的变量：</p>
<ul>
<li>[]不捕获任何变量。</li>
<li>[&amp;]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li>
<li>[=]捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</li>
<li>[=, &amp;foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。</li>
<li>[bar]按值捕获bar变量，同时不捕获其他变量。</li>
<li>[this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&amp;或=，就默认添加此选项。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">	int i_ = 0;</span><br><span class="line"></span><br><span class="line">	void func(int x, int y) &#123;</span><br><span class="line">		auto x1 = []&#123; return i_; &#125;;          // error，没有捕获外部变量</span><br><span class="line">		auto x2 = [=]&#123; return i_ + x + y; &#125;; // ok，捕获所有外部变量</span><br><span class="line">		auto x3 = [&amp;]&#123; return i_ + x + y; &#125;; // ok，捕获所有外部变量</span><br><span class="line">		auto x4 = [this]&#123; return i_; &#125;;      // ok，捕获this指针</span><br><span class="line">		auto x5 = [this]&#123; return i_ + x + y; &#125;; // error，没有捕获x、y</span><br><span class="line">		auto x6 = [this, x, y]&#123; return i_ + x + y; &#125;; // ok，捕获this指针、x、y</span><br><span class="line">		auto x7 = [this]&#123; return i_ ++; &#125;; 	 // ok，捕获this指针，并修改成员变量。</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a =0, b=1;</span><br><span class="line">auto fl = [] &#123; return a; &#125;; // error，没有捕获外部变量</span><br><span class="line">auto f2 = [&amp;]&#123; return a++; &#125;; // OK，捕获所有外部变量，并对a执行自加运算</span><br><span class="line">auto f3 = [=]&#123; return a;&#125;; //OK，捕获所有外部变量，并返回a</span><br><span class="line">auto f4 = [=]&#123; return a++;&#125;; //error，a是以复制方式捕获的，无法修改</span><br><span class="line">auto f5 = [a]&#123; return a + b;&#125;; //error，没有捕获变量b</span><br><span class="line">auto f6=[a，&amp;b]&#123; return a+(b++);&#125;; //OK，捕获a和b的引用，并对b做自加运算</span><br><span class="line">auto f7=[=，&amp;b]&#123; return a+(b++);&#125;; //OK，捕获所有外部变量和b的引用，并对b做自加运算</span><br></pre></td></tr></table></figure>
<p>一个容易出错的细节是，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">auto f = [=] &#123;return a;&#125;;</span><br><span class="line"></span><br><span class="line">a += 1;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; f() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><br>在这个例子中，lambda表达式按值捕获了所有外部变量，在捕获的一瞬间a的值就被复制到f中了，之后a被修改，但此时f中存储的a的值仍然是捕获时候的值，因此，最终输出结果是0。希望修改这些变量的话，我们需使用引用方式捕获。</p>
<p>按值捕获得到的外部变量值是在lambda表达式定义时的值。此时所有外部变量均被复制了一份存储在lambda表达式变量中。此时虽然修改 lambda表达式中的这些外部变量并不会真正影响到外部，我们却仍然无法修改它们。那么如果希望去修改按值捕获的外部变量应当怎么办呢?这时，需要显式指明lambda表达式为 mutable：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">auto f1 = [=] &#123; return a++; &#125;; // error，修改按值捕获的外部变量</span><br><span class="line">auto f2 = [=]() mutable &#123; return a++; &#125;; // ok</span><br></pre></td></tr></table></figure><br>被mutable修饰的lambda表达式就算没有参数也要写明参数列表。</p>
<p>lambda表达式的类型在C++11中被称为“闭包类型”。它是一个特殊的匿名的非nunion的类类型。因此，我们可以认为它是一个带有 operator()的类，即仿函数。因此，我们可以使用std::function和std::bind来存储和操作lambda表达式。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;int(int)&gt; f1 = [](int a) &#123; return a; &#125;;</span><br><span class="line">std: function&lt;int(void)&gt;f2 = std::bind([](int a) &#123; return a;&#125;, 123);</span><br></pre></td></tr></table></figure><br>另外，对于没有捕获任何变量的lambda表达式，还可以被转换成一个普通的函数指针：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using func_t= int(*)(int);</span><br><span class="line">func_t f = [](int a)&#123; return a; &#125;;</span><br><span class="line">f(123);</span><br></pre></td></tr></table></figure><br>lambda表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终均会变为闭包类型的成员变量。而一个使用了成员变量的类的 operator()，如果能直接被转换为普通的函数指针，那么lambda表达式本身的this指针就丢失掉了。而没有捕获任何外部变量的 lambda表达式则不存在这个问题。</p>
<p>这里也可以很自然地解释为何按值捕获无法修改捕获的外部变量。因为按照C++标准，lambda表达式的operator默认是const的。一个const成员函数是无法修改成员变量的值的。而mutable的作用，就在于取消operator()的const。需要注意的是，没有捕获变量的lambda表达式可以直接转换为函数指针，而捕获变量的lambda表达式则不能转换为函数指针。看看下面的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef void(*Ptr)(int*);</span><br><span class="line">//正确，没有捕获的lambda表达式可以直接转换为函数指针</span><br><span class="line">Ptr p = [](int* p) &#123;delete p;&#125;;</span><br><span class="line">Ptr pl = [&amp;](int* p) &#123;delete p;&#125;;</span><br><span class="line">∥错误，有状态的1 ambda不能直接转换为函数指针</span><br></pre></td></tr></table></figure><br>上面第二行代码能编译通过，而第三行代码不能编译通过，因为第三行的代码捕获了变量，不能直接转换为函数指针</p>
<h2 id="tuple元组"><a href="#tuple元组" class="headerlink" title="tuple元组"></a>tuple元组</h2><p>tuple元组是一个固定大小的不同类型值的集合。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;const char*, int&gt; tp = make_tuple(sendPack, nSendSize);</span><br></pre></td></tr></table></figure><br>等价于一个结构体：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">	char* p;</span><br><span class="line">	int len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>还有一种方法也可创建元组：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = 1;</span><br><span class="line">int y = 2;</span><br><span class="line">string s = &quot;aa&quot;;</span><br><span class="line">auto tp = std::tie(x, s, y);</span><br></pre></td></tr></table></figure><br>tp的类型是<code>std::tuple&lt;int&amp;, string&amp;, int&amp;&gt;</code></p>
<p>再看看如何获取元组的值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取第一个值</span><br><span class="line">const char* data = tp.get&lt;0&gt;();</span><br><span class="line">//获取第二个值</span><br><span class="line">int len = tp.get&lt;1&gt;();</span><br></pre></td></tr></table></figure><br>还有一种方法也可以获取元组的值，通过std::tie解包tuple<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x, y;</span><br><span class="line">string a;</span><br><span class="line">std::tie(x, a, y) = tp;</span><br></pre></td></tr></table></figure><br>通过tie解包后，tp中3个值会自动赋值给3个变量。解包时，如果只想解某个位置值时，可以用std::ignore占位符来表示不解某个位置的值。比如我们只想解第3个值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::tie(std::ignore, std::ignore, y) = tp;</span><br></pre></td></tr></table></figure><br>还有一个创建右值的引用元组方法： <code>forward_as_tuple</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;int, std::string&gt; m;</span><br><span class="line">m.emplace(std::piecewise_construct, std::forward_as_tuple(10), std::forward_as_tuple (20, &#x27;a));</span><br></pre></td></tr></table></figure><br>它实际上创建了一个类似于<code>std::tuple&lt;int&amp;&amp;，std::string&amp;&amp;&gt;</code>类型的tuple。</p>
<p>我们还可以通过tuple_cat连接多个tuple，代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	std::tuple&lt;int, std::string, float&gt; t1(10, &quot;Test&quot;, 3.14);</span><br><span class="line">	int n = 7;</span><br><span class="line">	auto t2 = std::tuple_cat(t1, std::make_pair(&quot;Foo&quot;, &quot;bar&quot;), t1, std::tie(n));</span><br><span class="line">	n = 10;</span><br><span class="line">	print(t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(10, Test, 3.14, Foo, bar, 10, Test, 3.14, 10)</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章主要介绍了通过一些C++11的特性简化代码，使代码更方便、简洁和优雅。首先讨论了自动类型推断的两个关键字auto和decltype，通过这两个关键字可以化繁为简，使我们不仅能方便地声明变量，还能获取复杂表达式的类型，将二者和返回值后置组合起来能解决函数的返回值难以推断的难题。</p>
<p>模板别名和模板默认参数可以使我们更方便地定义模板，将复杂的模板定义用一个简短更可读的名称来表示，既减少了烦琐的编码又提高了代码的可读性。</p>
<p>range-based for循环可以用更简洁的方式去遍历数组和容器，它还可以支持自定义的类型，只要自定义类型满足3个条件即可。</p>
<p>初始化列表和统一的初始化使得初始化对象的方式变得更加简单、直接和统一。</p>
<p>std::function不仅是一个函数语义的包装器，还能绑定任意参数，可以更灵活地实现函数的延迟执行。</p>
<p>lambda表达式能更方便地使用STL算法，就地定义的匿名函数免除了维护一大堆函数对象的烦琐，也提高了程序的可读性。</p>
<p>tuple元组可以作为一个灵活的轻量级的小结构体，可以用来替代简单的结构体，它有一个很好的特点就是能容纳任意类型和任意数量的元素，比普通的容器更灵活，功能也更强大。但是它也有复杂的一面， tuple的解析和应用往往需要模板元的一些技巧，对使用者有一定的要求。</p>
<h1 id="使用C-11改进程序性能"><a href="#使用C-11改进程序性能" class="headerlink" title="使用C++11改进程序性能"></a>使用C++11改进程序性能</h1><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用标记为<code>T &amp;&amp;</code>。</p>
<p>左值是指表达式结束后仍然存在的持久对象，右值是指表达式结束后就不再存在的临时对象。所有的具名变量或对象都是左值，而右值不具名。在C++11中，右值由两个概念构成，一个是将亡值，另一个则是纯右值。比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++1l新增的、与右值引用相关的表达式，如将要被移动的对象、T&amp;&amp;函数返回值，std::move返回值。</p>
<p>C+11中所有的值必属于左值、将亡值、纯右值三者之一，将亡值和纯右值都属于右值。区分表达式的左右值属性有一个简便方法：若可对表达式用<code>&amp;</code>符取址，则为左值，否则为右值。比如，简单的赋值语句<code>int i = 0</code>，在这条语句中，i是左值，0是字面量，就是右值。在上面的代码中，i可以被引用，0就不可以了。字面量都是右值。</p>
<h2 id="amp-amp-的特性"><a href="#amp-amp-的特性" class="headerlink" title="&amp;&amp;的特性"></a><code>&amp;&amp;</code>的特性</h2><p>右值引用就是对一个右值进行引用的类型。因为右值不具名，所以我们只能通过引用的方式找到它。<br>无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样，只要该变量还活着，该右值临时量将会直存活下去。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int g_constructCount = 0;</span><br><span class="line">int g_copyConstructCount = 0;</span><br><span class="line">int g_destructCount = 0;</span><br><span class="line">struct A &#123;</span><br><span class="line">	A() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;construct: &quot; &lt;&lt; ++g_constructCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A(const A&amp; a) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;copy construct: &quot; &lt;&lt; ++g_copyConstructCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~A() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;destruct: &quot; &lt;&lt; ++g_destructCount &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">A getA() &#123;</span><br><span class="line">	return A();</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A a = getA();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">g++ -fno-elide-constructors -std=c++0x -O0 1.cpp -o 1</span><br><span class="line"></span><br><span class="line">construct: 1</span><br><span class="line">copy construct: 1</span><br><span class="line">destruct: 1</span><br><span class="line">copy construct: 2</span><br><span class="line">destruct: 2</span><br><span class="line">destruct: 3</span><br></pre></td></tr></table></figure><br>在没有返回值优化的情况下，拷贝构造函数调用了两次，一次是getA()函数内部创建的对象返回后构造一个临时对象产生的，一次是在main构造a对象产生的。得如此的destruct是因为临时对象在构造a对象之后就销毁了。修改程序：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A&amp;&amp; a = getA();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出为:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">construct: 1</span><br><span class="line">copy construct: 1</span><br><span class="line">destruct: 1</span><br><span class="line">destruct: 2</span><br></pre></td></tr></table></figure><br>通过右值引用，少了一次拷贝构造和一次析构，原因在于右值引用绑定了右值，让临时右值的生命周期延长了。避免临时对象的拷贝构造和析构，事实上，在C++98/03中，也通过常量左值引用来做性能优化。</p>
<p>实际上<code>T&amp;&amp;</code>并不是一定表示右值，它绑定的类型是未定的，既可能是左值又可能是右值。看看这个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void f(T&amp;&amp; param);</span><br><span class="line"></span><br><span class="line">f(10);</span><br><span class="line">// 10是右值</span><br><span class="line"></span><br><span class="line">int x = 10;</span><br><span class="line">f(x);</span><br><span class="line">//x是左值</span><br></pre></td></tr></table></figure><br>从这个例子可以看出， param有时是左值，有时是右值，因为在上面的例子中有&amp;&amp;，这表示param实际上是一个未定的引用类型。这个未定的引用类型称为 universal references（可以认为它是一种未定的引用类型），它必须被初始化，它是左值还是右值引用取决于它的初始化，如果&amp;&amp;被一个左值初始化，它就是一个左值；如果它被一个右值初始化，它就是个右值。</p>
<p>需要注意的是，只有当发生自动类型推断时（如函数模板的类型自动推导，或auto关键字），&amp;&amp;才是一个<br>universal references。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void f(T&amp;&amp; param);</span><br><span class="line">//这里T的类型需要推导，所以&amp;&amp;是一个 universal references</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Test &#123;</span><br><span class="line">	Test(Test&amp;&amp; rhs); // 已经定义了一个特定的类型，没有类型推断</span><br><span class="line">					  // &amp;&amp;是一个右值引用</span><br><span class="line">&#125;;</span><br><span class="line">void f(Test&amp;&amp; param);</span><br><span class="line">// 已经定义了一个确定的类型，没有类型推断，&amp;&amp;是一个右值引用</span><br></pre></td></tr></table></figure></p>
<p>由于存在T&amp;&amp;这种未定的引用类型，当它作为参数时，有可能被一个左值引用或右值引用的参数初始化，这时经过类型推导的T&amp;&amp;类型，相比右值引用（&amp;&amp;）会发生类型的变化，这种变化被称为引用折叠：</p>
<ul>
<li>所有的右值引用叠加到右值引用上还是一个右值引用；</li>
<li>所有的其他引用类型之间的叠加都将变成左值引用。</li>
</ul>
<p>编译器会将已命名的右值引用视为左值，而将未命名的右值引用视作右值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void PrintValue(int&amp; i) &#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;lvalue: &quot; &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void PrintValue(int&amp;&amp; i) &#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;rvalue: &quot; &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">void Forward(int&amp;&amp; i) &#123;</span><br><span class="line">	PrintValue(i);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	PrintValue(i);</span><br><span class="line">	PrintValue(1);</span><br><span class="line">	Forward(2);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lvalue: 0</span><br><span class="line">rvalue: 1</span><br><span class="line">lvalue: 2</span><br></pre></td></tr></table></figure><br>Forward函数接收的是一个右值，但是在转发给PrintValue时，因为右值i变成一个命名对象，所以变成了左值。</p>
<p>&amp;&amp;的总结如下：</p>
<ul>
<li>左值和右值是独立于它们的类型的，右值引用类型可能是左值也可能是右值。</li>
<li>auto&amp;&amp;或函数参数类型自动推导的T&amp;&amp;是一个未定的引用类型，被称为universal references，它可能是左值引用也可能是右值引用类型，取决于初始化的值类型。</li>
<li>所有的右值引用叠加到右值引用上仍然是一个右值引用，其他引用折叠都为左值引用，当T&amp;&amp;为模板参数时，输入左值，它会变成左值引用；输入右值时变为具名的右值引用。</li>
<li>编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。</li>
</ul>
<p>在编写拷贝函数时，应该提供深拷贝的拷贝构造函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">	A() : m_ptr(new int(0)) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;construct&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A(const A&amp; a) : m_ptr(new int(*a.m_ptr)) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~A() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;destruct&quot; &lt;&lt; endl;</span><br><span class="line">		delete m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line">A get(bool flag) &#123;</span><br><span class="line">	A a;</span><br><span class="line">	A b;</span><br><span class="line">	if (flag)</span><br><span class="line">		return a;</span><br><span class="line">	else</span><br><span class="line">		return b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A a = get(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct</span><br><span class="line">construct</span><br><span class="line">copy construct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br></pre></td></tr></table></figure><br>这样可以保证拷贝的安全性。但这样的开销很大，get函数返回临时变量，然后通过这个临时变量拷贝构造了新的对象b，临时变量在拷贝完之后就销毁了，可以避免这种性能损耗：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">	A() : m_ptr(new int(0)) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;construct&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A(const A&amp; a) : m_ptr(new int(*a.m_ptr)) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A(A&amp;&amp; a) : : m_ptr(a.m_ptr) &#123;</span><br><span class="line">		a.m_ptr = nullptr;</span><br><span class="line">		cout &lt;&lt; &quot;move construct: &quot;&lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~A() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;destruct&quot; &lt;&lt; endl;</span><br><span class="line">		delete m_ptr;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line">A get(bool flag) &#123;</span><br><span class="line">	A a;</span><br><span class="line">	A b;</span><br><span class="line">	if (flag)</span><br><span class="line">		return a;</span><br><span class="line">	else</span><br><span class="line">		return b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A a = get(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct</span><br><span class="line">construct</span><br><span class="line">move construct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br><span class="line">destruct</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中没有了拷贝构造，取而代之的是移动构造（ Move Construct）。从移动构造函数的实现中可以看到，它的参数是一个右值引用类型的参数<code>A&amp;&amp;</code>，这里没有深拷贝，只有浅拷贝，这样就避免了对临时对象的深拷贝，提高了性能。这里的<code>A&amp;&amp;</code>用来根据参数是左值还是右值来建立分支，如果是临时值，则会选择移动构造函数。移动构造函数只是将临时对象的资源做了浅拷贝，不需要对其进行深拷贝，从而避免了额外的拷贝，提高性能。也就是所谓的移动语义（move语义），右值引用的一个重要目的是用来支持移动语义的。</p>
<p>移动语义可以将资源（堆、系统对象等）通过浅拷贝方式从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，可以大幅度提高C++应用程序的性能，消除临时对象的维护（创建和销毁）对性能的影响。<br>以代码清单22所示为示例，实现拷贝构造函数和拷贝赋值操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Element &#123;</span><br><span class="line">	Element() &#123;&#125;</span><br><span class="line">	Element(Element&amp;&amp; other) : m_children(std::move(other.m_children)) &#123;&#125;</span><br><span class="line">	Element(const Element&amp; other) : m_children(other.m_children) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">	vector&lt;ptree&gt; m_children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test() &#123;</span><br><span class="line">	Element t1 = Init();</span><br><span class="line">	vector&lt;Element&gt; v;</span><br><span class="line">	v.push_back(t1);</span><br><span class="line">	v.push_back(std::move(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先构造了一个临时对象t1，这个对象中存放了很多对象，数量可能很多，如果直接将这个t1用 push_back插入到vector中，没有右值版本的构造函数时，会引起大量的拷贝，这种拷贝会造成额外的严重的性能损耗。通过定义右值版本的构造函数以及std::move(t1)就可以避免这种额外的拷贝，从而大幅提高性能。</p>
<p>有了右值引用和移动语义，在设计和实现类时，对于需要动态申请大量资源的类，应该设计右值引用的拷贝构造函数和赋值函数，以提高应用程序的效率。需要注意的是，我们般在提供右值引用的构造函数的同时，也会提供常量左值引用的拷贝构造函数，以保证移动不成还可以使用拷贝构造。</p>
<h3 id="关于左值和右值的定义"><a href="#关于左值和右值的定义" class="headerlink" title="关于左值和右值的定义"></a>关于左值和右值的定义</h3><p>左值和右值在C中就存在，不过存在感不高，在C++尤其是C++11中这两个概念比较重要，左值就是有名字的变量（对象），可以被赋值，可以在多条语句中使用，而右值呢，就是临时变量（对象），没有名字，只能在一条语句中出现，不能被赋值。</p>
<p>在 C++11 之前，右值是不能被引用的，最大限度就是用常量引用绑定一个右值，如 :<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int&amp; i = 3;</span><br></pre></td></tr></table></figure><br>在这种情况下，右值不能被修改的。但是实际上右值是可以被修改的，如 :<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T().set().get();</span><br></pre></td></tr></table></figure><br>T 是一个类，set 是一个函数为 T 中的一个变量赋值，get 用来取出这个变量的值。在这句中，T() 生成一个临时对象，就是右值，set() 修改了变量的值，也就修改了这个右值。<br>既然右值可以被修改，那么就可以实现右值引用。右值引用能够方便地解决实际工程中的问题，实现非常有吸引力的解决方案。</p>
<h3 id="右值引用-1"><a href="#右值引用-1" class="headerlink" title="右值引用"></a>右值引用</h3><p>左值的声明符号为”&amp;”， 为了和左值区分，右值的声明符号为”&amp;&amp;”。</p>
<p>给出一个实例程序如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void process_value(int&amp; i) </span><br><span class="line">&#123; </span><br><span class="line">	std::cout &lt;&lt; &quot;LValue processed: &quot; &lt;&lt; i &lt;&lt; std::endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void process_value(int&amp;&amp; i) </span><br><span class="line">&#123; </span><br><span class="line">	std::cout &lt;&lt; &quot;RValue processed: &quot; &lt;&lt; i &lt;&lt; std::endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">	int a = 0; </span><br><span class="line">	process_value(a);</span><br><span class="line">	process_value(1); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wxl@dev:~$ g++ -std=c++11  test.cpp</span><br><span class="line">wxl@dev:~$ ./a.out </span><br><span class="line">LValue processed: 0</span><br><span class="line">RValue processed: 1</span><br></pre></td></tr></table></figure><br>Process_value 函数被重载，分别接受左值和右值。由输出结果可以看出，临时对象是作为右值处理的。</p>
<p>下面涉及到一个问题：<br>x的类型是右值引用，指向一个右值，但x本身是左值还是右值呢？C++11对此做出了区分：</p>
<p>Things that are declared as rvalue reference can be lvalues or rvalues. The distinguishing criterion is: if it has a name, then it is an lvalue. Otherwise, it is an rvalue.</p>
<p>对上面的程序稍作修改就可以印证这个说法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void process_value(int&amp; i) </span><br><span class="line">&#123; </span><br><span class="line">	std::cout &lt;&lt; &quot;LValue processed: &quot; &lt;&lt; i &lt;&lt; std::endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void process_value(int&amp;&amp; i) </span><br><span class="line">&#123; </span><br><span class="line">	std::cout &lt;&lt; &quot;RValue processed: &quot;  &lt;&lt; std::endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">	int a = 0; </span><br><span class="line">	process_value(a);</span><br><span class="line">	int&amp;&amp; x = 3;</span><br><span class="line">	process_value(x); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wxl@dev:~$ g++ -std=c++11  test.cpp</span><br><span class="line">wxl@dev:~$ ./a.out </span><br><span class="line">LValue processed: 0</span><br><span class="line">LValue processed: 3</span><br></pre></td></tr></table></figure><br>x 是一个右值引用，指向一个右值3，但是由于x是有名字的，所以x在这里被视为一个左值，所以在函数重载的时候选择为第一个函数。</p>
<h3 id="右值引用的意义"><a href="#右值引用的意义" class="headerlink" title="右值引用的意义"></a>右值引用的意义</h3><p>直观意义：为临时变量续命，也就是为右值续命，因为右值在表达式结束后就消亡了，如果想继续使用右值，那就会动用昂贵的拷贝构造函数。（关于这部分，推荐一本书《深入理解C++11》）<br>右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。<br>转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。<br>通过转移语义，临时对象中的资源能够转移其它的对象里。<br>在现有的 C++ 机制中，我们可以定义拷贝构造函数和赋值函数。要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。<br>普通的函数和操作符也可以利用右值引用操作符实现转移语义。</p>
<p>转移语义以及转移构造函数和转移复制运算符<br>以一个简单的 string 类为示例，实现拷贝构造函数和拷贝赋值操作符。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class MyString &#123; </span><br><span class="line">private: </span><br><span class="line">	char* _data; </span><br><span class="line">	size_t   _len; </span><br><span class="line">	void _init_data(const char *s) &#123; </span><br><span class="line">	  _data = new char[_len+1]; </span><br><span class="line">	  memcpy(_data, s, _len); </span><br><span class="line">	  _data[_len] = &#x27;\0&#x27;; </span><br><span class="line">	&#125; </span><br><span class="line">public: </span><br><span class="line">	MyString() &#123; </span><br><span class="line">		_data = NULL; </span><br><span class="line">		_len = 0; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	MyString(const char* p) &#123; </span><br><span class="line">		_len = strlen (p); </span><br><span class="line">		_init_data(p); </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	MyString(const MyString&amp; str) &#123; </span><br><span class="line">		_len = str._len; </span><br><span class="line">		_init_data(str._data); </span><br><span class="line">		std::cout &lt;&lt; &quot;Copy Constructor is called! source: &quot; &lt;&lt; str._data &lt;&lt; std::endl; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	MyString&amp; operator=(const MyString&amp; str) &#123; </span><br><span class="line">		if (this != &amp;str) &#123; </span><br><span class="line">		 	_len = str._len; </span><br><span class="line">			_init_data(str._data); </span><br><span class="line">		&#125; </span><br><span class="line">		std::cout &lt;&lt; &quot;Copy Assignment is called! source: &quot; &lt;&lt; str._data &lt;&lt; std::endl; </span><br><span class="line">		return *this; </span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">virtual ~MyString() &#123; </span><br><span class="line">	if (_data) </span><br><span class="line">		free(_data); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">int main() &#123; </span><br><span class="line">	MyString a; </span><br><span class="line">	a = MyString(&quot;Hello&quot;); </span><br><span class="line">	std::vector&lt;MyString&gt; vec; </span><br><span class="line">	vec.push_back(MyString(&quot;World&quot;)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy Assignment is called! source: Hello </span><br><span class="line">Copy Constructor is called! source: World</span><br></pre></td></tr></table></figure><br>这个 string 类已经基本满足我们演示的需要。在 main 函数中，实现了调用拷贝构造函数的操作和拷贝赋值操作符的操作。MyString(“Hello”) 和 MyString(“World”) 都是临时对象，也就是右值。虽然它们是临时的，但程序仍然调用了拷贝构造和拷贝赋值，造成了没有意义的资源申请和释放的操作。如果能够直接使用临时对象已经申请的资源，既能节省资源，有能节省资源申请和释放的时间。这正是定义转移语义的目的。</p>
<p>我们先定义转移构造函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> MyString(MyString&amp;&amp; str) &#123; </span><br><span class="line">   std::cout &lt;&lt; &quot;Move Constructor is called! source: &quot; &lt;&lt; str._data &lt;&lt; std::endl; </span><br><span class="line">   _len = str._len; </span><br><span class="line">   _data = str._data; </span><br><span class="line">   str._len = 0; </span><br><span class="line">   str._data = NULL; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有下面几点需要对照代码注意：</p>
<ol>
<li>参数（右值）的符号必须是右值引用符号，即“&amp;&amp;”。</li>
<li>参数（右值）不可以是常量，因为我们需要修改右值。</li>
<li>参数（右值）的资源链接和标记必须修改。否则，右值的析构函数就会释放资源。转移到新对象的资源也就无效了。</li>
</ol>
<p>现在我们定义转移赋值操作符。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> MyString&amp; operator=(MyString&amp;&amp; str) &#123; </span><br><span class="line">   std::cout &lt;&lt; &quot;Move Assignment is called! source: &quot; &lt;&lt; str._data &lt;&lt; std::endl; </span><br><span class="line">   if (this != &amp;str) &#123; </span><br><span class="line">     _len = str._len; </span><br><span class="line">     _data = str._data; </span><br><span class="line">     str._len = 0; </span><br><span class="line">     str._data = NULL; </span><br><span class="line">   &#125; </span><br><span class="line">   return *this; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里需要注意的问题和转移构造函数是一样的。<br>增加了转移构造函数和转移复制操作符后，我们的程序运行结果为 :</p>
<p>由此看出，编译器区分了左值和右值，对右值调用了转移构造函数和转移赋值操作符。节省了资源，提高了程序运行的效率。<br>有了右值引用和转移语义，我们在设计和实现类时，对于需要动态申请大量资源的类，应该设计转移构造函数和转移赋值函数，以提高应用程序的效率。</p>
<p>但是这几点总结的不错</p>
<ul>
<li>std::move执行一个无条件的转化到右值。它本身并不移动任何东西；</li>
<li>std::forward把其参数转换为右值，仅仅在那个参数被绑定到一个右值时；</li>
<li>std::move和std::forward在运行时（runtime）都不做任何事。</li>
</ul>
<h2 id="move语义"><a href="#move语义" class="headerlink" title="move语义"></a>move语义</h2><p>std::move将左值转换为右值，从而方便应用移动语义。move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移没有拷贝。</p>
<p>move实际上并不移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用，是我们可以通过右值引用使用该值，以用于移动语义。</p>
<p>仅仅转移资源的所有者，将资源的拥有者改为被赋值者。假设一个临时容器很大，赋值给另一个容器：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;std::string&gt; tokens;</span><br><span class="line">std::list&lt;std::string&gt; t = tokens;</span><br><span class="line"></span><br><span class="line">std::list&lt;std::string&gt; tokens;</span><br><span class="line">std::list&lt;std::string&gt; t = std::move(tokens);</span><br></pre></td></tr></table></figure><br>如果不用std::move，拷贝的代价很大，性能较低，使用move几乎没有任何代价，只是转换了资源的所有权，实际上是将左值转换为右值引用，然后应用move语义调用构造函数，就避免了拷贝。</p>
<h2 id="forward和完美转发"><a href="#forward和完美转发" class="headerlink" title="forward和完美转发"></a>forward和完美转发</h2><p>需要一种方法能按照参数原来的类型转发到另一个函数，这种转发被称作<strong>完美转发</strong>，即在函数模板中，完全依照模板的参数的类型（保持参数的左右值特征），将参数传递给函数模板中调用的另一个函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void PrintT(int&amp; t) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;lvalue&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PrintT(int&amp;&amp; t) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;rvalue&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void TestForward(T &amp;&amp; t) &#123;</span><br><span class="line">	PrintT(t);</span><br><span class="line">	PrintT(std::forward&lt;T&gt;(t));</span><br><span class="line">	PrintT(std::move(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	TestForward(1);</span><br><span class="line">	int x = 1;</span><br><span class="line">	TestForward(x);</span><br><span class="line">	TestForward(std::forward&lt;int&gt;(x));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lvalue</span><br><span class="line">rvalue</span><br><span class="line">rvalue</span><br><span class="line">lvalue</span><br><span class="line">lvalue</span><br><span class="line">rvalue</span><br><span class="line">lvalue</span><br><span class="line">rvalue</span><br><span class="line">rvalue</span><br></pre></td></tr></table></figure><br>TestForward(1)时，1是右值，所以未定义的引用类型<code>T&amp;&amp; t</code>被一个右值初始化后变成一个右值引用。但是在TestForward中调用PrintT(t)时，t变成一个左值。调用<code>PrintT(std::forward&lt;T&gt;(t))</code>时，<code>std::forward</code>会按照原来的参数类型转发，所以它还是一个右值。</p>
<p>TestForward(x)未定的引用类型<code>T&amp;&amp; t</code>被一个左值初始化后变成一个左值引用，因此，在调用<code>PrintT(std::forward&lt;T&gt;(t))</code>时它会被转发到<code>PrintT(T&amp; t)</code></p>
<h2 id="emplace-back减少内存拷贝和移动"><a href="#emplace-back减少内存拷贝和移动" class="headerlink" title="emplace_back减少内存拷贝和移动"></a>emplace_back减少内存拷贝和移动</h2><p>emplace_back能就地通过参数构造对象，不需要拷贝或者移动内存，相比push_back能更好地避免内存的拷贝与移动，使容器插入元素的性能得到进一步提升。在大多数情况下应该优先使用emplace_back来代替push_back。</p>
<p>所有的标准库容器（array除外，因为它的长度不可改变，不能插入元素）都增加了类似的方法： emplace、 emplace_hint、 emplace_front、emplace_after和emplace_back。</p>
<p>vector的emplace_back的基本用法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct A &#123;</span><br><span class="line">	int x;</span><br><span class="line">	double y;</span><br><span class="line">	A(int a, double b): x(a), y(b);</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">	vector&lt;A&gt; v;</span><br><span class="line">	v.emplace_back(1, 2);</span><br><span class="line">	cout&lt;&lt;v.size()&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出， emplace_back的用法比较简单，直接通过构造函数的参数就可以构造对象。因此，也要求对象有对应的构造函数，如果没有对应的构造函数，编译器会报错。</p>
<p>其他容器相应的 emplace方法也是类似的。<br>相对 push_back而言， emplace_back更具性能优势。</p>
<p>在引入右值引用，转移构造函数，转移复制运算符之前，通常使用push_back()向容器中加入一个右值元素（临时对象）的时候，首先会调用构造函数构造这个临时对象，然后需要调用拷贝构造函数将这个临时对象放入容器中。原来的临时变量释放。这样造成的问题是临时变量申请的资源就浪费。<br>引入了右值引用，转移构造函数（请看这里）后，push_back()右值时就会调用构造函数和转移构造函数。</p>
<h2 id="unordered-container无序容器"><a href="#unordered-container无序容器" class="headerlink" title="unordered container无序容器"></a>unordered container无序容器</h2><p>C++11增加了无序容器 unordered_map/unordered_multimap和unordered_set/unordered_multiset，由于这些容器中的元素是不排序的，因此，比有序容器 map/multimap和set/multiset效率更高。</p>
<p>map和set内部是红黑树，在插入元素时会自动排序，而无序容器内部是散列表（ Hash Table），通过哈希（Hash），而不是排序来快速操作元素，使得效率更高。由于无序容器内部是散列表，因此无序容器的key需要提供hash_value函数，其他用法和map/set的用法是一样的。不过对于自定义的key，需要提供Hash函数和比较函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;bitset&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line"></span><br><span class="line">struct Key &#123;</span><br><span class="line">	std::string first;</span><br><span class="line">	std::string second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct KeyHash &#123;</span><br><span class="line">	std::size_t operator()(const Key&amp; k) const &#123;</span><br><span class="line">		return std::hash&lt;std::string&gt;()(k.first)^(std::hash&lt;std::string&gt;()(k.second) &lt;&lt; 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct keyEqual &#123;</span><br><span class="line">	bool operator()(const Key&amp; lhs, const Key&amp; rhs) const &#123;</span><br><span class="line">		return lhs.first == rhs.first &amp;&amp; lhs.second == rhs.second;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	std::unordered_map&lt;std::string, std::string&gt; m1;</span><br><span class="line"></span><br><span class="line">	std::unordered_map&lt;int, std::string&gt; m2 = &#123;</span><br><span class="line">		&#123;1, &quot;foo&quot;&#125;,</span><br><span class="line">		&#123;2, &quot;bar&quot;&#125;,</span><br><span class="line">		&#123;3, &quot;baz&quot;&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	std::unordered_map&lt;int, std::string&gt; m3 = m2;</span><br><span class="line">	std::unordered_map&lt;int, std::string&gt; m4 = std::move(m2);</span><br><span class="line"></span><br><span class="line">	std::vector&lt;std::pair&lt;std::bitset&lt;8&gt;, int&gt;&gt; v = &#123; &#123;0x12, 1&#125;, &#123;0x01, -1&#125; &#125;;</span><br><span class="line">	std::unordered_map&lt;std::bitset&lt;8&gt;, double&gt; m5(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">	// constructor for a custom type</span><br><span class="line">	std::unordered_map&lt;Key, std::string, KeyHash, KeyEqual&gt; m6 = &#123;</span><br><span class="line">		&#123; &#123;&quot;john&quot;, &quot;doe&quot;&#125;, &quot;example&quot;&#125;,</span><br><span class="line">		&#123; &#123;&quot;mary&quot;, &quot;Sue&quot;&#125;, &quot;another&quot;&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="使用C-11消除重复，提高代码质量"><a href="#使用C-11消除重复，提高代码质量" class="headerlink" title="使用C++11消除重复，提高代码质量"></a>使用C++11消除重复，提高代码质量</h1><h2 id="type-traits——类型萃取"><a href="#type-traits——类型萃取" class="headerlink" title="type_traits——类型萃取"></a>type_traits——类型萃取</h2><p>type_traits的类型判断功能在编译期就可以检查出是否是正确的类型，以便能编写更安全的代码。</p>
<h3 id="基本的type-traits"><a href="#基本的type-traits" class="headerlink" title="基本的type_traits"></a>基本的type_traits</h3><p>在之前的C++中，在类中定义编译期常量的方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct GetLeftSize &#123;</span><br><span class="line">	static const int value = 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在C++11中定义编译期常量，无需自己定义<code>static const int</code>或<code>enum</code>类型，只需要从<code>std::integral_constant</code>派生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct GetLeftSize : std::integral_constant&lt;int, 1&gt; &#123; &#125;;</span><br></pre></td></tr></table></figure>
<p>将编译期常量包装为一个类型的type_trait——integral_constant：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, T v&gt;</span><br><span class="line">struct integral_constant &#123;</span><br><span class="line">	static const T value = v;</span><br><span class="line">	typedef T value_type;</span><br><span class="line">	typedef integral_constant&lt;T, v&gt; type;</span><br><span class="line">	operator value_type() &#123; return value;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常见的用法是从integral_constant派生从而可以通过继承得到value</p>
<p>派生的type_traits可用于检查模板类型是否为某种类型，通过这些trait可以获取编译期检查的bool值结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">struct is_integral;</span><br></pre></td></tr></table></figure>
<p>这是用来检查T是否为bool、char、int、long、long long等整型类型的，派生于std::integral_constant，因此可以通过std::is_xxx::value是否为true判断模板类型是否为目标类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;int&quot; &lt;&lt; std::is_const&lt;int&gt;::value &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;const int&quot; &lt;&lt; std::is_const&lt;const int&gt;::value &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;const int*&quot; &lt;&lt; std::is_const&lt;const int*&gt;::value &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;const int&amp;&quot; &lt;&lt; std::is_const&lt;const int&amp;&gt;::value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++提供了判断类型之间的关系的traits：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, class U&gt;</span><br><span class="line">struct is_same        // 判断两个类型是否相同 </span><br><span class="line">struct is_base_of     // 判断base类型是否是derived类型的积累</span><br><span class="line">struct is_convertible // 判断模板参数类型是否能转换</span><br></pre></td></tr></table></figure>
<p>C++提供了类型转换traits，包括对const的修改，引用的移除和添加，指针和数组的修改等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">struct remove_const</span><br><span class="line">strcut add_const</span><br></pre></td></tr></table></figure>
<p>有时需要添加引用类型，比如从智能指针中获取对象的引用时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; </span><br><span class="line">struct Construct &#123;</span><br><span class="line">	typedef typename std::remove_reference&lt;T&gt;::type U;</span><br><span class="line">	Construct() : m_ptr(new U) &#123; &#125;</span><br><span class="line"></span><br><span class="line">	typename std::add_lvalue_reference&lt;U&gt;:: type</span><br><span class="line">	Get() const &#123; return *m_ptr.get(); &#125;</span><br><span class="line">private:</span><br><span class="line">	std::unique_ptr&lt;U&gt; m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	Construct&lt;int&gt; c;</span><br><span class="line">	int a = c.Get();</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移除引用和cv符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; </span><br><span class="line">typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type*</span><br><span class="line">Create() &#123;</span><br><span class="line">	typedef typename std::remove_cv&lt;typename std::remove_reference&lt;T&gt;::type&gt;::type U;</span><br><span class="line">	return new U();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先移除引用，再移除cv符，最终获得原始类型，这样可以解决问题，但是较为繁琐，用<code>decay</code>来简化代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; </span><br><span class="line">typename std::decay&lt;T&gt;::type* Create() &#123;</span><br><span class="line">	typedef typename std::decay&lt;T&gt;::type U;</span><br><span class="line">	return new U();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于普通类型来说，<code>std::decay</code>是移除引用和cv符，大大简化了我们的书写。除了普通类型之外，<code>std::decay</code>还可以用于数组和函数，具体的转换规则如下：</p>
<ul>
<li>先移除T类型的引用，得到类型U，U定义为<code>remove_reference&lt;T&gt;::type</code></li>
<li>如果<code>is_array&lt;U&gt;::value</code>为true，修改类型type为<code>remove_extent&lt;U&gt;::type*</code></li>
<li>否则，如果<code>is_function&lt;U&gt;::value</code>为true，修改类型type为<code>add_pointer&lt;U&gt;::type</code></li>
<li>否则，修改类型type为<code>remove_cv&lt;U&gt;::type</code></li>
</ul>
<p>根据上面的规则，再对照用法示例，就能清楚地理解<code>std::decay</code>的含义了。下面是<code>std::decay</code>的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef std::decay&lt;int&gt;::type A; // int</span><br><span class="line">typedef std::decay&lt;int&amp;&gt;::type B; // int</span><br><span class="line">typedef std::decay&lt;int&amp;&amp;&gt;::type C; // int</span><br><span class="line">typedef std::decay&lt;const int&amp;&gt;::type D; // int</span><br><span class="line">typedef std::decay&lt;int[2]&gt;::type E; //int*</span><br><span class="line">typedef std::decay&lt;int(int)&gt;::type F: //int(*)(int)</span><br></pre></td></tr></table></figure>
<p>由于std::decay对于函数来说是添加指针，利用这一点，我们可以将函数变成函数指针类型，从而将函数指针变量保存起来，以便在后面延迟执行。</p>
<p><code>std::conditional</code>在编译期根据一个判断式选择两个类型中的一个，和条件表达式的语义类似，类似一个三元表达式。它的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt; bool B, class T, class F&gt;</span><br><span class="line">struct conditional</span><br></pre></td></tr></table></figure>
<p><code>std::conditional</code>模板参数中，如果B为true，则conditional::type为T，否则为F。<br><code>std::conditional</code>测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef std::conditional&lt;true, int, float&gt;::type A; // int</span><br><span class="line">typedef std::conditional&lt;false, int, float&gt;::type B, // float</span><br><span class="line"></span><br><span class="line">typedef std::conditional&lt;std::is_integral&lt;A&gt;::value, long, int&gt;:: type C; // long</span><br><span class="line">typedef std::conditional&lt;std::is_integral&lt;B&gt;::value, long, int&gt;:: type D; // int</span><br></pre></td></tr></table></figure>
<p>比较两个类型，输出较大的那个类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef std::conditional&lt;(sizeof(long long) &gt; sizeof(long double)), long long, long double&gt;::type max_size_t;</span><br><span class="line">cout&lt;&lt;typeid(max_size_t).name()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>将会输出： <code>long double</code><br>我们可以通过编译期的判断式来选择类型，这给我们动态选择类型提供了很大的灵活性，在后面经常和其他的C++11特性配合起来使用，是比较常用的特性之一。</p>
<p>有时要获取函数的返回类型是一件比较困难的事情，C++提供了std::result_of，用来在编译期获取一个可调用对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::result_of&lt;A(int)&gt;::type i = 4;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(std::declval&lt;A&gt;()(std::declval&lt;int&gt;()));</span><br></pre></td></tr></table></figure>
<p><code>std::result_of</code>原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class F, class ... ArgTypes&gt;</span><br><span class="line">class result_of&lt;F(ArgTypes...)&gt;;</span><br></pre></td></tr></table></figure>
<p>第一个模板参数为可调用对象的类型，第二个模板参数为参数的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int fn(int) &#123; return int(); &#125;</span><br><span class="line">typedef int(&amp;fn_ref)(int);</span><br><span class="line">typedef int(*fn_ref)(int);</span><br><span class="line">struct fn_class &#123; int operator()(int i) &#123;return i;&#125; &#125;;</span><br><span class="line"></span><br><span class="line">int main &#123;</span><br><span class="line">	typedef std::result_of&lt;decltype(fn)&amp;(int)&gt;:: type A; // int</span><br><span class="line">	typedef std::result_of&lt;fn_ref(int)&gt;::type B;         // int</span><br><span class="line">	typedef std::result_of&lt;fn_ptr(int)&gt;::type C;         // int</span><br><span class="line">	typedef std::result_of&lt;fn_class(int)&gt;::type D;       // int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::result_of&lt;Fn(ArgTypes...)&gt;</code>要求Fn为一个可调用对象（不能是个函数类型，因为函数类型不是一个可调用对象，因此，下面这种方式是错误的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef std::result_of&lt;decltype(fn)(int)&gt;::type A;</span><br></pre></td></tr></table></figure>
<p>如果要对某个函数使用std::result_of，要先将函数转换为可调用对象。可以通过以下方式来获取函数返回类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef std::result_of&lt;decltype(fn)&amp;(int)&gt;::type A;</span><br><span class="line">typedef std::result_of&lt;decltype(fn)*(int)&gt;::type B;</span><br><span class="line">typedef std::result_of&lt;typename std::decay&lt;decltype(fn)&gt;::type(int)&gt;::type C;</span><br><span class="line">A B C 类型相同</span><br></pre></td></tr></table></figure>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>声明可变参数模板时需要在typename或class后边带上’…’。</p>
<ul>
<li>声明一个参数包，这个参数包中可以包含0到任意个模板参数</li>
<li>在模板定义的右边，可以把参数包展开成一个一个独立的参数</li>
</ul>
<h3 id="可变参数模板函数"><a href="#可变参数模板函数" class="headerlink" title="可变参数模板函数"></a>可变参数模板函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ... T&gt;</span><br><span class="line">void f(T... args) &#123;</span><br><span class="line">	cout &lt;&lt; sizeof...(args) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">f(); // 0</span><br><span class="line">f(1, 2); // 2</span><br><span class="line">f(1, 2.5, &quot;&quot;); // 3</span><br></pre></td></tr></table></figure>
<p>如果要用参数包中的参数，则一定要将参数包展开，有两种展开参数包的方法，一种是递归的模板函数展开，一种是通过逗号表达式和初始化列表方式展开。</p>
<p>通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//递归终止函数</span><br><span class="line">void print() &#123;</span><br><span class="line">	cout &lt;&lt; &quot;Empty&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//展开函数</span><br><span class="line">template &lt;class T, class... Args&gt;</span><br><span class="line">void print(T head, Args... rest) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;parameter &quot; &lt;&lt; head &lt;&lt; endl;</span><br><span class="line">	print(rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	print(1,2,3,4);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parameter 1</span><br><span class="line">parameter 2</span><br><span class="line">parameter 3</span><br><span class="line">parameter 4</span><br><span class="line">Empty</span><br></pre></td></tr></table></figure>
<p>递归终止函数可以写成如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename T1, typename T2&gt;</span><br><span class="line">void print(T t, T1 t1) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; t1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T, typename T1, typename T2&gt;</span><br><span class="line">void print(T t, T1 t1, T2 t2) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; &quot; &quot; &lt;&lt; t1 &lt;&lt; &quot; &quot; &lt;&lt; t2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt; </span><br><span class="line">void printarg(T t) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;class ...Args&gt;</span><br><span class="line">void expand(Args... args) &#123;</span><br><span class="line">	int arr[] = &#123; (printarg(args), 0)...&#125;</span><br><span class="line">&#125;</span><br><span class="line">expand(1,2,3,4);</span><br></pre></td></tr></table></figure>
<p>这种就地展开参数包的方式关键是<strong>逗号表达式</strong>，它会按顺序执行逗号前边的表达式。<code>expand()</code>函数中的<code>(printarg(args), 0)</code>，先执行<code>printarg(args)</code>，再得到逗号表达式的结果0。同时用到了初始化列表，通过初始化列表来初始化一个变长数组。<code>&#123;(printargs(args), 0)...&#125;</code>将会展开成<code>((printargs(arg1), 0), (printargs(arg2), 0), (printargs(arg3), 0), etc...)</code>，最终会创建一个所有元素为0的数组<code>int arr[sizeof(Args)]</code>，会先执行表达式前面的printarg打印出参数。</p>
<h3 id="可变参数模板类"><a href="#可变参数模板类" class="headerlink" title="可变参数模板类"></a>可变参数模板类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class... Types&gt;</span><br><span class="line">class tuple;</span><br></pre></td></tr></table></figure>
<p>这个可变参数模板类可以携带任意类型任意个数的模板参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;int&gt; tp1 = std::make_tuple(1);</span><br><span class="line">std::tuple&lt;int, double&gt; tp2 = std::make_tuple(1, 2.5);</span><br><span class="line">std::tuple&lt;int, double, string&gt; tp3 = std::make_tuple(1, 2.5, &quot;hello&quot;);</span><br></pre></td></tr></table></figure>
<h4 id="模板递归和特化方式展开参数包"><a href="#模板递归和特化方式展开参数包" class="headerlink" title="模板递归和特化方式展开参数包"></a>模板递归和特化方式展开参数包</h4><p>可变参数模板类的展开一般需要定义2 ~ 3个类，包含类声明和特化的模板类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename... nums&gt; struct Sum;// 变长模板的声明</span><br><span class="line"></span><br><span class="line">template &lt;typename First, typename... last&gt;</span><br><span class="line">struct Sum&lt;first, last...&gt; // 变长模板类</span><br><span class="line">&#123;</span><br><span class="line">    static const long val = first * Sum&lt;last...&gt;::val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">struct Sum&lt;&gt; // 边界条件</span><br><span class="line">&#123;</span><br><span class="line">    static const long val = 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个基本的可变参数模板应用类由三部分组成：</p>
<p>第一个是<code>template&lt;typename... Args&gt; struct Sum</code>，这是前向声明，声明这个类是可变参数模板类</p>
<p>第二个是类的定义，它定义了一个部分展开的可变参数模板类，告诉编译器如何递归展开参数包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename First, typename... last&gt; </span><br><span class="line">struct Sum&lt;first, last...&gt; // 变长模板类</span><br><span class="line">&#123;</span><br><span class="line">    static const long val = first * Sum&lt;last...&gt;::val;</span><br><span class="line">&#125;;`</span><br></pre></td></tr></table></figure>
<p>第三个是特化的递归终止类，这是在展开到0个参数时终止，也可以在展开到2个时终止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">struct Sum&lt;&gt; // 边界条件</span><br><span class="line">&#123;</span><br><span class="line">    static const long val = 1;</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename First, typename Last&gt;</span><br><span class="line">struct sum&lt;First, Last&gt; &#123;</span><br><span class="line">	static const long val = First * Last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可变参数消除重复代码"><a href="#可变参数消除重复代码" class="headerlink" title="可变参数消除重复代码"></a>可变参数消除重复代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Print(T t) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T, typename ... Args&gt;</span><br><span class="line">void Print(T t) &#123;</span><br><span class="line">	cout &lt;&lt; t ;</span><br><span class="line">	Print(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过可变模板参数可以消除重复，同时去掉参数个数限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename ... Args&gt;</span><br><span class="line">T* Instance(Args... args) &#123;</span><br><span class="line">	return new T(args...);</span><br><span class="line">&#125;</span><br><span class="line">A* pa = Instance&lt;A&gt;(1);</span><br><span class="line">B* pb = Instance&lt;B&gt;(1, 2);</span><br></pre></td></tr></table></figure>
<p>上边的代码<code>T* Instance(Args... args)</code>的Args是值拷贝的，存在性能损耗，可以通过完美转发来消除损耗：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename ... Args&gt;</span><br><span class="line">T* Instance(Args&amp;&amp;... args) &#123;</span><br><span class="line">	return new T(std::forward&lt;Args &gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可变参数模板和type-traits的综合应用"><a href="#可变参数模板和type-traits的综合应用" class="headerlink" title="可变参数模板和type_traits的综合应用"></a>可变参数模板和type_traits的综合应用</h2><h3 id="optional的实现"><a href="#optional的实现" class="headerlink" title="optional的实现"></a>optional的实现</h3><p>C+14中将包含一个<code>std::optional</code>类，它的功能及用法和boost的optional类似。<code>optional&lt;T&gt;</code>内部存储空间可能存储了T类型的值也可能没有存储T类型的值，只有当optional被T初始化之后，这个optional才是有效的，否则是无效的，它实现了未初始化的概念。</p>
<p>optional可以用于解决函数返回无效值的问题，有时根据某个条件去查找对象时，如果查找不到对象，就会返回一个无效值，这不表明函数执行失败，而是表明函数正确执行了，只是结果不是有用的值。这时就可以返回一个未初始化的optional对象，判断这个optional对象是否是有效对象需要判断它是否被初始化，如果没有被初始化就表明这个值是无效的。boost中的optional就实现了这种未初始化的概念。 boost.optional的基本用法很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">optional&lt;int&gt; op;</span><br><span class="line">if(op)</span><br><span class="line">	cout &lt;&lt; *op &lt;&lt; endl;</span><br><span class="line">optional&lt;int&gt; op1 = 1;</span><br><span class="line">if(op1)</span><br><span class="line">	cout &lt;&lt; *op1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>第一个op由于没有被初始化，所以它是一个无效值，将不会输出打印信息；第二个op被初始化为1，所以它是一个有效值，将会输出1。optional经常用于函数返回值。</p>
<p>由于optional<T>需要容纳T的值，所以需要一个缓冲区保存这个T，这个缓冲区不可用普通的char数组，需要使用内存对齐的缓冲区<code>std::aligned_storage</code>，原型如下，其中，Len表示所存储类型的size，Align表示该类型内存对齐的大小，通过sizeof(T)可以获取T的size，通过alignof(T)可以获取T内存对齐的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt; std::size_t Len, std::size_t Align = /* default-alignment */ &gt;</span><br><span class="line">struct aligned_storage;</span><br><span class="line"></span><br><span class="line">std::aligned_storage&lt;sizeof(T), alignof(T)&gt; 或</span><br><span class="line">std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;</span><br></pre></td></tr></table></figure>
<p>需要注意拷贝和赋值时，内部状态和缓冲区销毁的问题。内部状态用来标示该optional是否被初始化，当已经初始化时需要先将缓冲区清理一下。需要增加右值版本优化效率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Optional</span><br><span class="line">&#123;</span><br><span class="line">    using data_t = typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type;</span><br><span class="line">public:</span><br><span class="line">    Optional() : m_hasInit(false) &#123;&#125;</span><br><span class="line">    Optional(const T&amp; v)</span><br><span class="line">    &#123;</span><br><span class="line">        Create(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional(T&amp;&amp; v) : m_hasInit(false)</span><br><span class="line">    &#123;</span><br><span class="line">        Create(std::move(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Optional()</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional(const Optional&amp; other) : m_hasInit(false)</span><br><span class="line">    &#123;</span><br><span class="line">        if (other.IsInit())</span><br><span class="line">            Assign(other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional(Optional&amp;&amp; other) : m_hasInit(false)</span><br><span class="line">    &#123;</span><br><span class="line">        if (other.IsInit())</span><br><span class="line">        &#123;</span><br><span class="line">            Assign(std::move(other));</span><br><span class="line">            other.Destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional&amp; operator=(Optional &amp;&amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        Assign(std::move(other));</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Optional&amp; operator=(const Optional &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        Assign(other);</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;class... Args&gt;</span><br><span class="line">    void emplace(Args&amp;&amp;... args)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy();</span><br><span class="line">        Create(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool IsInit() const &#123; return m_hasInit; &#125;</span><br><span class="line"></span><br><span class="line">    explicit operator bool() const &#123; return IsInit(); &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; operator*()</span><br><span class="line">    &#123;</span><br><span class="line">        return *((T*) (&amp;m_data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T const&amp; operator*() const</span><br><span class="line">    &#123;</span><br><span class="line">        if (IsInit())</span><br><span class="line">        &#123;</span><br><span class="line">            return *((T*) (&amp;m_data));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw std::exception(&quot;is not init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator == (const Optional&lt;T&gt;&amp; rhs) const</span><br><span class="line">    &#123;</span><br><span class="line">        return (!bool(*this)) != (!rhs) ? false : (!bool(*this) ? true : (*(*this)) == (*rhs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator &lt; (const Optional&lt;T&gt;&amp; rhs) const</span><br><span class="line">    &#123;</span><br><span class="line">        return !rhs ? false : (!bool(*this) ? true : (*(*this) &lt; (*rhs)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator != (const Optional&lt;T&gt;&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        return !(*this == (rhs));</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    template&lt;class... Args&gt;</span><br><span class="line">    void Create(Args&amp;&amp;... args)</span><br><span class="line">    &#123;</span><br><span class="line">        new (&amp;m_data) T(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        m_hasInit = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Destroy()</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_hasInit)</span><br><span class="line">        &#123;</span><br><span class="line">            m_hasInit = false;</span><br><span class="line">            ((T*) (&amp;m_data))-&gt;~T();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Assign(const Optional&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        if (other.IsInit()) &#123;</span><br><span class="line">            Copy(other.m_data);</span><br><span class="line">            m_hasInit = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            Destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Assign(Optional&amp;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        if (other.IsInit()) &#123;</span><br><span class="line">            Move(std::move(other.m_data));</span><br><span class="line">            m_hasInit = true;</span><br><span class="line">            other.Destroy();</span><br><span class="line">        &#125; </span><br><span class="line">        else &#123;</span><br><span class="line">            Destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Move(data_t&amp;&amp; val)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy();</span><br><span class="line">        new (&amp;m_data) T(std::move(*((T*)(&amp;val))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Copy(const data_t&amp; val)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy();</span><br><span class="line">        new (&amp;m_data) T(*((T*) (&amp;val)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    bool m_hasInit;</span><br><span class="line">    data_t m_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="惰性求值类lazy的实现"><a href="#惰性求值类lazy的实现" class="headerlink" title="惰性求值类lazy的实现"></a>惰性求值类lazy的实现</h3><p>惰性求值（Lazy Evaluation）是相对常用的编程语言中的及早求值而言的另一种求值策略，也被称之为按需调用（call-by-need），或者叫延时求值。简单地讲，惰性求值是在谋求一种平衡，一种在节省开发与节约计算资源的一种平衡策略。一个庞大的类实例可能一次只有一小部分会发生更改，如果把其他的东西都盲目的添加进来，就会额外造成不少的计算资源的浪费。因此，在开发时，开发人员不仅要知道高级语言的语法糖，也需要一定的底层 AST 的实现原理，这样能够避免很多不必要的运行时开销。所以，这里的惰性，更多的是指等待的意思：一旦等到了明确的调用命令，自然会把运行结果正确送出。</p>
<p>借助lambda表达式，将函数封装到lambda表达式中，而不是马上求值，是在需要的时候再调用lambda表达式来求值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct Lazy &#123;</span><br><span class="line">	Lazy() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	template &lt;typename Func, typename ... Args&gt;</span><br><span class="line">	Lazy(Func&amp; f, Args &amp;&amp; ... args) &#123;</span><br><span class="line">		m_func = [&amp;f, &amp;args...]&#123; return f(args...); &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T&amp; value() &#123;</span><br><span class="line">		if (!m_value.IsInit()) &#123;</span><br><span class="line">			m_vlaue = m_func(); </span><br><span class="line">		&#125;</span><br><span class="line">		return *m_value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool IsValueCreated() const &#123;</span><br><span class="line">		return m_value.IsInit();</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	std::function&lt;T()&gt; m_func;</span><br><span class="line">	Optional&lt;T&gt; m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class Func, typename... Args&gt;</span><br><span class="line">Lazy&lt;typename std::result_of&lt;Func(Args...)&gt;::type&gt; lazy(Func &amp;&amp; fun, Args &amp;&amp; ... args) &#123;</span><br><span class="line">	return Lazy&lt;typename std::result_of&lt;Func(Args...)&gt;::type&gt;(std::forward&lt;Func&gt;(fun), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lazy类用到了std::function和optional，其中std::function用来保存传入的函数，不马上执行，而是延迟到后面需要使用值的时候才执行，函数的返回值被放到一个optional对象中，如果不用optional，则需要增加一个标识符来标识是否已经求值，而使用optional对象可以直接知道对象是否已经求值，用起来更简便。</p>
<p>通过optional对象我们就知道是否已经求值，当发现已经求值时直接返回之前计算的结果，起到缓存的作用。<br>代码清单后一部分定义了一个辅助函数，该辅助函数的作用是更方便地使用Lazy，因为Lazy类需要一个模板参数来表示返回值类型，而type_traits中的std::result_of可以推断出函数的返回值类型，所以这个辅助函数结合std::result_of就无须显式声明返回类型了，同时可变参数模板消除了重复的模板定义和模板参数的限制，可以满足所有的函数入参，在使用时只需要传入一个函数和其参数就能实现延迟计算。</p>
<p>Lazy内部的std::function<T()>用来保存传入的函数，以便在后面延迟执行，这个function定义是没有参数的，因为可以通过一个lambda表达式去初始化一个function，而lambda表达式可以捕获参数，所以无须定义function的参数，当然还可以通过std::bind绑定器来将N元的入参函数变为sdtd::function<T()>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct BigObject &#123;</span><br><span class="line">	BigObject() &#123; cout &lt;&lt; &quot;lazy load big object&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct MyStruct &#123;</span><br><span class="line">	MyStruct() &#123;</span><br><span class="line">		m_obj = lazy( [] &#123; return std::make_shared&lt;BigObject&gt;(); &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	void Load() &#123;</span><br><span class="line">		m_obj.Value();</span><br><span class="line">	&#125;</span><br><span class="line">	Lazy&lt; std::shared_ptr&lt;BigObject&gt; &gt; m_obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Foo(int x) &#123; return x * 2; &#125;</span><br><span class="line"></span><br><span class="line">void TestLazy() &#123;</span><br><span class="line">	int y = 4;</span><br><span class="line">	auto lazyer1 = lazy(Foo, y);</span><br><span class="line">	cout &lt;&lt; lazyer1.Value() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Lazy&lt;int&gt; lazyer2 = lazy([] &#123;return 12;&#125;);</span><br><span class="line">	cout &lt;&lt; lazyer2.Value() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	std::function &lt;int(int)&gt; f = [](int x) &#123; return x + 3; &#125;;</span><br><span class="line">	auto lazyer3 = lazy(f, 3);</span><br><span class="line">	cout &lt;&lt; lazyer3.Value() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	MyStruct t;</span><br><span class="line">	t.Load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">12</span><br><span class="line">6</span><br><span class="line">lazy load big object</span><br></pre></td></tr></table></figure>
<h3 id="dll帮助类"><a href="#dll帮助类" class="headerlink" title="dll帮助类"></a>dll帮助类</h3><p>如果要按照</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ret CallDllFunc(const string&amp; funName, T arg)</span><br></pre></td></tr></table></figure>
<p>这种方式调用，则首先要把函数指针转换成一种函数对象或泛型函数，这样可以用std::function做这件事。</p>
<p>封装GetProcAddress，将函数指针转换成std::function</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">std::function&lt;T&gt; GetFunction(const string&amp; funName) &#123;</span><br><span class="line">	FARPROC funAddress = GetProcAddress(m_hMod, funcName.c_str());</span><br><span class="line">	return std::function&lt;T&gt;((T*)funAddress)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T是std::function的模板参数，即函数类型的签名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto fmax = GetFunction&lt;int(int, int)&gt;(&quot;Max&quot;);</span><br><span class="line">auto fget = GetFunction&lt;int(int)&gt;(&quot;Get&quot;);</span><br></pre></td></tr></table></figure>
<p>解决函数返回值与入参不一样的问题，通过result_of和可变参数模板解决：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename ... Args&gt;</span><br><span class="line">typename std::result_of&lt;std::function&lt;T&gt;(Args...)&gt;::type ExecuteFunc(const string&amp; funcName, Args&amp;&amp; ... args) &#123;</span><br><span class="line">	return GetFunction&lt;T&gt;(funcName)(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto max = ExecuteFunc&lt;int(int, int)&gt;(&quot;Max&quot;, 5, 8);</span><br><span class="line">auto ret = ExecuteFunc&lt;int(int)&gt;(&quot;Get&quot;, 5);</span><br></pre></td></tr></table></figure>
<h3 id="lambda链式调用"><a href="#lambda链式调用" class="headerlink" title="lambda链式调用"></a>lambda链式调用</h3><p>将多个函数按照前一个的输出作为下一个输入串起来再推迟到某个时刻计算。</p>
<p>首先创建一个task对象，然后连续调用then的函数，只需要保证前一个函数的输出为后一个的输入即可。最后在需要的时候调用计算结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Task;</span><br><span class="line"></span><br><span class="line">template&lt;typename R, typename...Args&gt;</span><br><span class="line">class Task&lt;R(Args...)&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Task(std::function&lt;R(Args...)&gt;&amp;&amp; f) : m_fn(std::move(f)) &#123;&#125;</span><br><span class="line">    Task(std::function&lt;R(Args...)&gt;&amp; f) : m_fn(f) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    R run(Args&amp;&amp;... args)</span><br><span class="line">    &#123;</span><br><span class="line">        return m_fn(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;typename F&gt;</span><br><span class="line">    auto Then(F&amp;&amp; f) -&gt; Task&lt;typename std::result_of&lt;F(R)&gt;::type(Args...)&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        using return_type = typename std::result_of&lt;F(R)&gt;::type;</span><br><span class="line"></span><br><span class="line">        auto func = std::move(m_fn);</span><br><span class="line">        return Task&lt;return_type(Args...)&gt;([func, &amp;f](Args&amp;&amp;...args) &#123;</span><br><span class="line">            return f(func(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::function&lt;R(Args...)&gt; m_fn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void tesk()</span><br><span class="line">&#123;</span><br><span class="line">    Task&lt;int(int)&gt; task([](int i) &#123;return i; &#125;);</span><br><span class="line"></span><br><span class="line">    auto f = task</span><br><span class="line">        .Then([](int i) &#123;return i + 1; &#125;)</span><br><span class="line">        .Then([](int i) &#123;return i + 2; &#125;)</span><br><span class="line">        .Then([](int i) &#123;return i + 3; &#125;);</span><br><span class="line"></span><br><span class="line">    auto result = f.run(0);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;run task result:&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run task result:6</span><br></pre></td></tr></table></figure>
<h3 id="any类的实现"><a href="#any类的实现" class="headerlink" title="any类的实现"></a>any类的实现</h3><p>boost库有一个Any类，是一个特殊的只能容纳一个元素的容器，他可以擦除类型，给任何类型赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">boost::any a = 1;</span><br><span class="line">boost::any a = 1.1;</span><br><span class="line"></span><br><span class="line">std::vector&lt;boost::any&gt; v;</span><br><span class="line">v.push_back(a);</span><br><span class="line">v.push_back(b);</span><br><span class="line"></span><br><span class="line">int va = boost::any_cast&lt;int&gt;(a); // 1</span><br><span class="line">double vb = boost::any_cast&lt;double&gt;(b); // 2.5</span><br></pre></td></tr></table></figure>
<p>vector中可以存放int和double，因为any擦除了int和double的类型，当通过any_cast<T>取出实际类型时，如果T不是原来的类型，会报错。</p>
<p>any能容纳所有类型的数据，因此，当赋值给any时，需要将值的类型擦除，即以一种通用的方式保存所有类型的数据。这里可以通过继承去擦除类型，基类是不含模板参数的，派生类中才有模板参数，这个模板参数类型正是赋值的类型。在赋值时，将创建的派生类对象赋值给基类指针，基类的派生类携带了数据类型，基类只是原始数据的一个占位符，通过多态的隐式转换擦除了原始数据类型，因此，任何数据类型都可以赋值给它，从而实现能存放所有类型数据的目标。当取数据时需要向下转换成派生类型来获取原始数据，当转换失败时打印详情，并抛出异常。由于向any赋值时需要创建一个派生类对象，所以还需要管理该对象的生命周期，这里用unique_ptr智能指针去管理对象的生命周期。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">class Any</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    //默认构造函数</span><br><span class="line">    Any() : m_tpIndex(std::type_index(typeid(void))) &#123;&#125;</span><br><span class="line">    Any(const Any&amp; other) : m_ptr(other.clone()), m_tpIndex(other.m_tpIndex) &#123;&#125;</span><br><span class="line">    Any(Any&amp;&amp; other) : m_ptr(std::move(other.m_ptr)), m_tpIndex(std::move(other.m_tpIndex)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    //通用的右值构造</span><br><span class="line">    template&lt;typename T, class = typename std::enable_if&lt;!std::is_same&lt;typename std::decay&lt;T&gt;::type, Any&gt;::value, T&gt;::type&gt;</span><br><span class="line">    Any(T &amp;&amp; value) : m_ptr(new Derived&lt;typename std::decay&lt;T&gt;::type&gt;(std::forward&lt;T&gt;(value)))</span><br><span class="line">        , m_tpIndex(std::type_index(typeid(std::decay&lt;T&gt;::type))) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    //判断是否为空</span><br><span class="line">    bool isNull() &#123;</span><br><span class="line">        return !bool(m_ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //是否可以类型转换</span><br><span class="line">    template&lt;class T&gt;</span><br><span class="line">    bool is() const &#123;</span><br><span class="line">        return m_tpIndex == std::type_index(typeid(T));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //类型转换</span><br><span class="line">    template&lt;class T&gt;</span><br><span class="line">    T&amp; cast()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!is&lt;T&gt;())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;can not cast &quot; &lt;&lt; typeid(T).name() &lt;&lt; &quot; to &quot;</span><br><span class="line">                &lt;&lt; m_tpIndex.name() &lt;&lt; endl;</span><br><span class="line">            throw bad_cast();</span><br><span class="line">        &#125;</span><br><span class="line">        auto ptr = dynamic_cast&lt;Derived&lt;T&gt;*&gt;(m_ptr.get());</span><br><span class="line">        return ptr-&gt;m_value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Any&amp; operator=(const Any&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_ptr == other.m_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return *this;</span><br><span class="line">        &#125;</span><br><span class="line">        m_ptr = other.clone();</span><br><span class="line">        m_tpIndex = other.m_tpIndex;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    struct Base;</span><br><span class="line">    using BasePtr = std::unique_ptr&lt;Base&gt;;</span><br><span class="line"></span><br><span class="line">    //非模板擦除类型</span><br><span class="line">    struct Base</span><br><span class="line">    &#123;</span><br><span class="line">        virtual BasePtr clone() const = 0;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    struct Derived : public Base</span><br><span class="line">    &#123;</span><br><span class="line">        template&lt;typename...Args&gt;</span><br><span class="line">        Derived(Args&amp;&amp;...args) : m_value(std::forward&lt;Args&gt;(args)...)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        BasePtr clone() const</span><br><span class="line">        &#123;</span><br><span class="line">            return BasePtr(new Derived(m_value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T m_value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    //拷贝使用</span><br><span class="line">    BasePtr clone() const</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            return m_ptr-&gt;clone();</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BasePtr         m_ptr;      //具体数据</span><br><span class="line">    std::type_index m_tpIndex;  //数据类型</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="function-traits"><a href="#function-traits" class="headerlink" title="function_traits"></a>function_traits</h3><p>可以获得普通函数、函数指针、std::function、函数对象和成员函数的函数类型、返回类型、参数个数和参数的具体类型。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int func(int a, string b);</span><br><span class="line"></span><br><span class="line">//获取函数类型</span><br><span class="line">function_traits&lt;decltype(func)&gt;::function_type; //int __cdecl(int, string)</span><br><span class="line"></span><br><span class="line">//获取函数返回值</span><br><span class="line">function_traits&lt;decltype(func)&gt;::return_type; //int</span><br><span class="line"></span><br><span class="line">//获取函数的参数个数</span><br><span class="line">function_traits&lt;decltype(func)&gt;::arity; //2</span><br><span class="line"></span><br><span class="line">//获取函数第一个入参类型</span><br><span class="line">function_traits&lt;decltype(func)&gt;::arg_type&lt;0&gt;; //int</span><br><span class="line"></span><br><span class="line">//获取函数第二个入参类型</span><br><span class="line">function_traits&lt;decltype(func)&gt;::arg_type&lt;1&gt;; //string</span><br></pre></td></tr></table></figure>
<p>通过function_traits可以很方便地获取所有函数语义类型丰富的信息，对于实际开发很有用。</p>
<h4 id="实现-function-traits的关键技术"><a href="#实现-function-traits的关键技术" class="headerlink" title="实现 function_traits的关键技术"></a>实现 function_traits的关键技术</h4><p>实现function_traits关键是要通过模板特化和可变参数模板来获取函数类型和返回类型。<br>先定义一个基本的function_traits的模板类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct function traits</span><br></pre></td></tr></table></figure>
<p>再通过特化，将返回类型和可变参数模板作为模板参数，就可以获取函数类型、函数返回值和参数的个数了。基本的特化版本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename Ret, typename... Args&gt;</span><br><span class="line">struct function_traits&lt;Ret(Args...)&gt; </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	enum &#123; arity = sizeof...(Args) &#125;;</span><br><span class="line">	typedef Ret function_type(Args...);</span><br><span class="line">	typedef Ret return_type;</span><br><span class="line">	using stl_function_type = std::function&lt;function_type&gt;;</span><br><span class="line">	typedef Ret(*pointer)(Args...);</span><br><span class="line"></span><br><span class="line">	template&lt;size_t I&gt;</span><br><span class="line">	struct args &#123;</span><br><span class="line">		using type = typename std::tuple_element&lt;I, std::tuple&lt;Args...&gt;&gt;::type;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="variant的实现"><a href="#variant的实现" class="headerlink" title="variant的实现"></a>variant的实现</h3><p>variant类似于union，它能代表定义的多种类型，允许将不同类型的值赋给它。它的具体类型是在初始化赋值时确定。boost中的variant的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef variant&lt;int,char, double&gt; vt;</span><br><span class="line">vt v = 1;</span><br><span class="line">v = &#x27;2&#x27;;</span><br><span class="line">v = 12.32;</span><br></pre></td></tr></table></figure>
<p>用variant一个好处是可以擦除类型，不同类型的值都统一成一个variant，虽然这个variant只能存放已定义的类型，但这在很多时候已经够用了。 取值的时候，通过get<T>(v)来获取真实值。然而，当T类型与v的类型不匹配时，会抛出一个bad_cast的异常来。boost的variant抛出的异常往往没有更多的信息，不知道到底是哪个类型转换失败，导致发生异常调试时很不方便。因此，就考虑用c++11去实现一个vairiant, 这个variant可以很容易知道取值时，是什么类型转换失败了。</p>
<h4 id="打造variant需要解决的问题"><a href="#打造variant需要解决的问题" class="headerlink" title="打造variant需要解决的问题"></a>打造variant需要解决的问题</h4><p>第一，要在内部定义一个char缓冲区。缓冲区用来存放variant的值，这个值是variant定义的多种类型中的某种类型的值，因此，这个缓冲区要足够大，能够存放类型最大（sizeof(Type)）的值才可以，这个缓冲区的大小还必须在编译期计算出来。因此需要首先要解决的是variant值存放的缓冲区定义的问题。同时注意内存对齐，使用<code>std::aligned_storage</code>作为variant值存放的缓冲区。</p>
<p>第二，要解决赋值的问题。将值赋给vairiant时，需要将该值的类型ID记录下来，以便在后面根据类型取值。将值保存到内部缓冲区时，还需要用palcement new在缓冲区创建对象。另外，还要解决一个问题，就是赋值时需要检查variant中已定义的类型中是否含有该类型，如果没有则编译不通过，以保证赋值是合法的。</p>
<p>variant的赋值函数要做两件事：第一是从原来的variant中取出缓冲区中的对象；第二是通过缓冲区中取出的对象构造出当前variant中的对象。赋值函数的左值和右值的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Variant(Variant&lt;Types...&gt;&amp;&amp; old) : m_typeIndex(old.m_typeIndex) &#123;</span><br><span class="line">	Helper_t::move(old.m_typeIndex, &amp;old.m_data, &amp;m_data);</span><br><span class="line">&#125;</span><br><span class="line">Variant(const Variant&lt;Types...&gt;&amp; old) : m_typeIndex(old.m_typeIndex) &#123;</span><br><span class="line">	Helper_t::copy(old.m_typeIndex, &amp;old.m_data, &amp;m_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三，解决取值的问题，通过类型取值时，要判断类型是否匹配，如果不匹配，将详情打印出来，方便调试。</p>
<h4 id="打造variant的关键技术："><a href="#打造variant的关键技术：" class="headerlink" title="打造variant的关键技术："></a>打造variant的关键技术：</h4><p>找出最大的typesize。第一个问题中需要解决的问题是如何找出多种类型中，size最大的那个类型的size。看看如何从多种类型中找出最大类型的size。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename... Args&gt;</span><br><span class="line">struct MaxType : std::integral_constant&lt;int,</span><br><span class="line">(sizeof(T)&gt;MaxType&lt;Args...&gt;::value ? sizeof(T) : MaxType&lt;Args...&gt;::value) &gt; </span><br><span class="line"></span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct MaxType&lt;T&gt; : std::integral_constant&lt;int, sizeof(T) &gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>通过这个MaxType就可以在编译期获取类型中最大的maxsize了：<code>MaxType&lt;Types...&gt;::value</code>。</p>
<p>这里通过继承和递归方式来展开参数包，在展开参数包的过程中将第一个参数的size和后面一个参数的size做比较，获取较大的那个size，直到比较完所有的参数，从而获得所有类型中最大的size，比较的过程和冒泡排序的过程类似。内存对齐的缓冲区aligned_storage需要两个模版参数，第一个是缓冲区大小，第二个是内存对齐的大小。 variant中的aligned_storage中的缓冲区大小就是最大类型的sice，我们已经找出，下一步是找出最大的内存对齐大小。我们可以在MaxType的基础上来获取MaxAligin。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename... Args&gt;</span><br><span class="line">struct MaxAlign : std::integral_constant&lt;int, IntegreMax&lt;std::alignment_of&lt;Args&gt;::value...&gt;::value&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">enum &#123;</span><br><span class="line">	data_size = MaxType&lt;sizeof(Types)...&gt;::value;</span><br><span class="line">	align_size = MaxAlign&lt;Types...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line">using data_t = typename std::aligned_storage&lt;data_size, align_size&gt;::type;</span><br></pre></td></tr></table></figure>
<h4 id="类型检查和缓冲区中创建对象"><a href="#类型检查和缓冲区中创建对象" class="headerlink" title="类型检查和缓冲区中创建对象"></a>类型检查和缓冲区中创建对象</h4><p>第二个问题中需要解决两个问题，1.检查赋值的类型是否在已定义的类型中；2.在缓冲区中创建对象及析构；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt; typename T, typename... List &gt;</span><br><span class="line">struct Contains : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line">template &lt; typename T, typename Head, typename... Rest &gt;</span><br><span class="line">struct Contains&lt;T, Head, Rest...&gt;</span><br><span class="line">    : std::conditional&lt; std::is_same&lt;T, Head&gt;::value, std::true_type, Contains&lt;T, Rest...&gt;&gt;::type&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template &lt; typename T &gt;</span><br><span class="line">struct Contains&lt;T&gt; : std::false_type&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>通过bool值Contains<T, Types>::vaule就可以判断是否含有某种类型。</p>
<p>再看看如何在缓冲区中创建对象。</p>
<p>通过placement new在该缓冲区上创建对象，<code>new(data) T(value);</code>，其中data表示一个char缓冲区，T表示某种类型。在缓冲区上创建的对象还必须通过<code>~T</code>去析构，因此还需要一个析构vairiant的帮助类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename... Args&gt;</span><br><span class="line">struct VariantHelper&lt;T, Args...&gt; &#123;</span><br><span class="line">	inline static void Destroy(type_index id, void * data) &#123;</span><br><span class="line">		if (id == type_index(typeid(T)))</span><br><span class="line">			((T*) (data))-&gt;~T();</span><br><span class="line">		else</span><br><span class="line">			VariantHelper&lt;Args...&gt;::Destroy(id, data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt; struct VariantHelper&lt;&gt;  &#123;</span><br><span class="line">	inline static void Destroy(type_index id, void * data) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="取值问题"><a href="#取值问题" class="headerlink" title="取值问题"></a>取值问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">typename std::decay&lt;T&gt;::type&amp; Get() &#123;</span><br><span class="line">	using U = typename std::decay&lt;T&gt;::type;</span><br><span class="line">	if (!Is&lt;U&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; typeid(U).name() &lt;&lt; &quot; is not defined. &quot; &lt;&lt; &quot;current type is &quot; &lt;&lt; m_typeIndex.name() &lt;&lt; endl;</span><br><span class="line">		throw std::bad_cast();</span><br><span class="line">	&#125;</span><br><span class="line">	return *(U*) (&amp;m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">int GetIndexOf() &#123;</span><br><span class="line">    return Index&lt;T, Types...&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename F&gt;</span><br><span class="line">void Visit(F&amp;&amp; f)</span><br><span class="line">&#123;</span><br><span class="line">　　using T = typename function_traits&lt;F&gt;::arg&lt;0&gt;::type;</span><br><span class="line">　　if (Is&lt;T&gt;())</span><br><span class="line">　　　　f(Get&lt;T&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename F, typename... Rest&gt;</span><br><span class="line">void Visit(F&amp;&amp; f, Rest&amp;&amp;... rest)</span><br><span class="line">&#123;</span><br><span class="line">　　using T = typename function_traits&lt;F&gt;::arg&lt;0&gt;::type;</span><br><span class="line">　　if (Is&lt;T&gt;())</span><br><span class="line">　　　　Visit(std::forward&lt;F&gt;(f));</span><br><span class="line">　　else</span><br><span class="line">　　　　Visit(std::forward&lt;Rest&gt;(rest)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void TestVariant()</span><br><span class="line">&#123;</span><br><span class="line">    typedef Variant&lt;int, char, double&gt; cv;</span><br><span class="line">    int x = 10;</span><br><span class="line"></span><br><span class="line">    cv v =x;</span><br><span class="line">    v = 1;</span><br><span class="line">    v = 1.123;</span><br><span class="line">    v = &quot;&quot;;//compile error</span><br><span class="line">    v.Get&lt;int&gt;(); //1</span><br><span class="line">    v.Get&lt;double&gt;(); //1.23</span><br><span class="line">    v.Get&lt;short&gt;(); //exception: short is not defined. current type is int</span><br><span class="line">    v.Is&lt;int&gt;();//true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ScopeGuard"><a href="#ScopeGuard" class="headerlink" title="ScopeGuard"></a>ScopeGuard</h3><p>ScopeGuard的作用是确保资源面对异常时总能被成功释放，就算没有正常返回。惯用法让我们在构造函数里获取资源，当因为异常或者正常作用域结束，那么在析构函数里释放资源。总是能释放资源。如果没有异常抛出则正常结束，只是有异常发生或者没有正常退出时释放资源。</p>
<p>通过局部变量析构函数来管理资源，根据是否正常退出来确定是否需要清理资源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename F&gt;</span><br><span class="line">class ScopeGuard</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit ScopeGuard( F &amp;&amp; f) : m_func(std::move(f)), m_dismiss(false)&#123;&#125;</span><br><span class="line">    explicit ScopeGuard(const F&amp; f) : m_func(f), m_dismiss(false)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~ScopeGuard() &#123;</span><br><span class="line">        if (!m_dismiss &amp;&amp; m_func != nullptr)</span><br><span class="line">            m_func();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ScopeGuard(ScopeGuard &amp;&amp; rhs) : m_func(std::move(rhs.m_func)), m_dismiss(rhs.m_dismiss) &#123;rhs.Dismiss();&#125;</span><br><span class="line"></span><br><span class="line">    void Dismiss() &#123;</span><br><span class="line">        m_dismiss = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    F m_func;</span><br><span class="line">    bool m_dismiss;</span><br><span class="line"></span><br><span class="line">    ScopeGuard();</span><br><span class="line">    ScopeGuard(const ScopeGuard&amp;);</span><br><span class="line">    ScopeGuard&amp; operator=(const ScopeGuard&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename F&gt;</span><br><span class="line">ScopeGuard&lt;typename std::decay&lt;F&gt;::type&gt; MakeGuard(F &amp;&amp; f)</span><br><span class="line">&#123;</span><br><span class="line">　　return ScopeGuard&lt;typename std::decay&lt;F&gt;::type&gt;(std::forward&lt;F&gt;(f));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="tuple-helper"><a href="#tuple-helper" class="headerlink" title="tuple_helper"></a>tuple_helper</h3><p><code>std::tuple</code>作为一个泛化的<code>std::pair</code>，它的一个独特特性是能容纳任意个数任意类型的元素。</p>
<p>tuple还需要一些常用操作，比如打印、遍历、根据元素值获取索引位置、反转和应用于函数。</p>
<ul>
<li>打印：由于tuple中的元素是可变参数模板，外面并不知道内部到底是什么数据，有时调试需要知道其具体值，希望能打印出tuple中所有的元素值。</li>
<li>根据元素值获取索引位置： tuple接口中有根据索引位置获取元素的接口，根据元素值来获取索引位置是相反的做法。</li>
<li>获取索引：在运行期根据索引获取索引位置的元素。</li>
<li>遍历：类似于std::for_each算法，可以将函数对象应用于tuple的每个元素。</li>
<li>反转：将tuple中的元素逆序。</li>
<li>应用于函数：将tuple中的元素进行一定的转换，使之成为函数的入参。</li>
</ul>
<h4 id="打印tuple"><a href="#打印tuple" class="headerlink" title="打印tuple"></a>打印tuple</h4><p>tuple不同于数组和集合，不能通过for循环的方式枚举并打印元素值，需要借助可变参数模板的展开方式来打印出元素值。但是 tuple又不同于可变参数模板不能直接通过展开参数包的方式来展开，因为tuple中的元素需要用<code>std::get&lt;T&gt;(tuple)</code>来获取，展开tuple需要带索引参数。有两种方法可以展开并打印tuple，第一种方法是通过模板类的特化和递归调用结合来展开 tuple；另一种方法是通过一个索引序列来展开tuple。</p>
<p>（1）通过模板特化和递归来展开并打印tuple<br>因为tuple内部的元素个数和类型是不固定的，如果要打印tuple中的元素，需要在展开tuple时一一打印，展开并打印tuple的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class Tuple, std::size_t N&gt;</span><br><span class="line">struct TuplerPrinter &#123;</span><br><span class="line">	static void print (const Tuple&amp; t) &#123;</span><br><span class="line">		TuplerPrinter&lt;Tuple, N - 1 &gt;::print(t);</span><br><span class="line">		std::cout &lt;&lt; &quot;, &quot; &lt;&lt; std::get&lt;N - 1&gt;(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class Tuple&gt;</span><br><span class="line">struct TuplerPrinter&lt;Tuple, 1&gt; &#123;</span><br><span class="line">	static void print(const Tuple&amp; t) &#123;</span><br><span class="line">		std::cout &lt;&lt; std::get(0)&lt;t&gt;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class... Args&gt;</span><br><span class="line">void PrintTuple(const std::tuple&lt;Args...&gt;&amp; t) &#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;(&quot;;</span><br><span class="line">	TuplePrinter&lt;decltype(t), sizeof...(Args)&gt;::print(t);</span><br><span class="line">	std::cout &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板类TuplePrinter带有一个模板参数<code>std::size_t N</code>，这个N是用来控制递归调用的，每调用一次，这个N就减1，直到减为1为止。 PrintTuple是一个帮助函数，目的是为了更方便地调用TuplePrinter，因为Tupleprinter需要两个参数，一个是tuple，另一个是tuple的size。tuple的size是可以通过<code>sizeof</code>来获取的，在帮助函数中获取tuple的size并调用TuplePrinter，就可以减少外面调用的入参。测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void TestPrint() &#123;</span><br><span class="line">	std::tuple&lt;int, short, double, char&gt; tp = std: make tuple(1, 2, 3, &#x27;a&#x27;);</span><br><span class="line">	PrintTuple(tp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<code>(1, 2, 3, &#39;a&#39;)</code></p>
<p>调用过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tupleprinter&lt;std::tuplecint, short, double, char&gt;, 4&gt;:: print(tp);</span><br><span class="line">TuplePrinter&lt;std::tuple&lt;int, short, double, char&gt;, 3&gt;:: print(tp);</span><br><span class="line">TuplePrintersstd::tuple&lt;int, short, double, char&gt;, 2&gt;:: print(tp);</span><br><span class="line">TuplePrintersstd::tuple&lt;int, short, double, char&gt;, 1&gt;:: print(tp);</span><br></pre></td></tr></table></figure>
<p>当递归终止时，打印第一个元素的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::get&lt;0&gt;(t);</span><br></pre></td></tr></table></figure>
<p>接着返回上一层递归打印第二个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::get&lt;1&gt;(t);</span><br><span class="line">std::cout &lt;&lt; std::get&lt;2&gt;(t);</span><br><span class="line">std::cout &lt;&lt; std::get&lt;3&gt;(t);</span><br></pre></td></tr></table></figure>
<p>（2）根据索引序列展开并打印tuple<br>将tuple变为一个可变参数模板需要一个可变索引序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int...&gt;</span><br><span class="line">struct IndexTuple&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>再通过<code>std::get&lt;IndexTuple&gt;(tuple)...</code>来获取参数序列，从而将tuple转换为可变参数模板<code>Args...</code>。<br>先创建一个索引序列，通过这个索引序列来取tuple中对应位置的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int...&gt;</span><br><span class="line">struct IndexTuple&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;int N, int... Indexes&gt;</span><br><span class="line">struct MakeIndexes : MakeIndexes&lt;N-1, N-1, Indexes...&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;int... indexes&gt;</span><br><span class="line">struct MakeIndexes&lt;0, indexes...&gt; &#123;</span><br><span class="line">	typedef IndexTuple&lt;indexes...&gt; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在生成一个元素对应的索引位置序列之后，就可以通过<code>std::get</code>来获取tuple中的所有元素并将其变为可变参数模板。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">void Print(T t) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T, typename... Args&gt;</span><br><span class="line">void Print(T t, Args... args) &#123;</span><br><span class="line">	cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">	Print(args...);</span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename Tuple, int... Indexes&gt;</span><br><span class="line">void Transform(IndexTuple&lt; Indexes... &gt;&amp; in, Tuple&amp; tp) &#123;</span><br><span class="line">	Print(get&lt;indexes&gt;(tp)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	using Tuple = std::tuple&lt;int, double&gt;;</span><br><span class="line">	Tuple tp = std::make_tuple&lt;1, 2&gt;;</span><br><span class="line">	Transform(MakeIndexes&lt;std::tuple_size&lt;Tuple&gt;::value&gt;::type(), tp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="反转Tuple"><a href="#反转Tuple" class="headerlink" title="反转Tuple"></a>反转Tuple</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int I, int... Indexes, typename T, typename... Types&gt;</span><br><span class="line">struct make_indexes_reverse_impl&lt;I, IndexTuple&lt;Indexes...&gt;, T, Types...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    using type = typename make_indexes_reverse_impl&lt;I-1, IndexTuple&lt;Indexes..., I-1&gt;, Types...&gt;::type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//递归终止</span><br><span class="line">template&lt;int I, int... Indexes&gt;</span><br><span class="line">struct make_indexes_reverse_impl&lt;I, IndexTuple&lt;Indexes...&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    using type = IndexTuple&lt;Indexes...&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//类型萃取</span><br><span class="line">//调用方法如：make_indexes&lt;double, char, int&gt;</span><br><span class="line">template&lt;typename... Types&gt; </span><br><span class="line">struct make_reverse_indexes : make_indexes_reverse_impl&lt;sizeof...(Types), IndexTuple&lt;&gt;, Types...&gt;</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class... Args, int... Indexes&gt;</span><br><span class="line">auto reverse_impl(std::tuple&lt;Args...&gt;&amp;&amp; tup, IndexTuple&lt;Indexes...&gt;&amp;&amp;) -&gt;</span><br><span class="line">decltype(std::make_tuple(std::get&lt;Indexes&gt;(std::forward&lt;std::tuple&lt;Args...&gt;&gt;(tup))...))</span><br><span class="line">&#123;</span><br><span class="line">    return std::make_tuple(std::get&lt;Indexes&gt;forward&lt;tuple&lt;Args...&gt;&gt;(tup))...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class... Args&gt;</span><br><span class="line">auto tuple_reverse(std::tuple&lt;Args...&gt;&amp;&amp; tup)-&gt;</span><br><span class="line">decltype(reverse_impl(std::forward&lt;std::tuple&lt;Args...&gt;&gt;(tup),typename make_reverse_indexes&lt;Args...&gt;::type()))</span><br><span class="line">&#123;</span><br><span class="line">    return reverse_impl(std::forward&lt;std::tuple&lt;Args...&gt;&gt;(tup), typename make_reverse_indexes&lt;Args...&gt;::type());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="应用于函数"><a href="#应用于函数" class="headerlink" title="应用于函数"></a>应用于函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int...&gt;</span><br><span class="line">struct IndexTuple&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;int N, int... Indexes&gt;</span><br><span class="line">struct MakeIndexes : MakeIndexes&lt;N-1, N-1, Indexes...&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;int... indexes&gt;</span><br><span class="line">struct MakeIndexes&lt;0, indexes...&gt; &#123;</span><br><span class="line">	typedef IndexTuple&lt;indexes...&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename F, typename Tuple, int... Indexes&gt;</span><br><span class="line">auto apply_helper(F&amp;&amp; f, IndexTuple&lt;Indexes...&gt;&amp;&amp; in, Tuple&amp;&amp; tup)-&gt;</span><br><span class="line">decltype(std::forward&lt;F&gt;(f)(std::get&lt;Indexes&gt;(tup)...))</span><br><span class="line">&#123;</span><br><span class="line">    return std::forward&lt;F&gt;(f)(std::get&lt;Indexes&gt;(tup)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestF(int a, double b) &#123;</span><br><span class="line">	cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test() &#123;</span><br><span class="line">	apply_helper(TestF, MakeIndexes&lt;2&gt;::type(), std::make_tuple(1, 2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：3</p>
<h1 id="使用C-11解决内存泄漏的问题"><a href="#使用C-11解决内存泄漏的问题" class="headerlink" title="使用C++11解决内存泄漏的问题"></a>使用C++11解决内存泄漏的问题</h1><p>智能指针可以自动删除分配的内存，是存储指向动态分配（堆）对象指针的累，用于生存期控制，能够确保在离开指针所在作用域时能够自动正确地销毁动态分配的对象，防止内存泄漏。它的一种通用实现技术是<strong>引用计数</strong>，每使用它一次内部的引用计数加一，每析构一次内部的引用计数减一，减为0时，删除所指向的堆内存。</p>
<h2 id="shared-ptr共享的智能指针"><a href="#shared-ptr共享的智能指针" class="headerlink" title="shared_ptr共享的智能指针"></a>shared_ptr共享的智能指针</h2><p><code>shared_ptr</code>使用引用计数，每一个<code>shared_ptr</code>的拷贝都指向同一个内存，在最后一个<code>shared_ptr</code>析构时，内存才被释放。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>通过构造函数、<code>std::make_shared&lt;T&gt;</code>辅助函数和reset方法来初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p(new int(1));</span><br><span class="line">std::shared_ptr&lt;int&gt; p2 = p;</span><br><span class="line">std::shared_ptr&lt;int&gt; ptr;</span><br><span class="line">ptr.reset(new int(1));</span><br></pre></td></tr></table></figure>
<p>优先使用<strong><code>make_shared</code></strong>来构造智能指针。<br>不能将一个原始指针直接赋值给一个智能指针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr p ＝ new int(1) ;　　　// 编译报错，不允许直接赋值</span><br></pre></td></tr></table></figure>
<p>通过get方法来返回原始指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; ptr( new int(1) ) ;</span><br><span class="line">int* p = ptr.get() ;</span><br></pre></td></tr></table></figure>
<p>智能指针初始化可以指定删除器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void DeleteIntPtr ( int * p ) &#123;</span><br><span class="line">	delete p ;</span><br><span class="line">&#125;</span><br><span class="line">std::shared_ptr&lt;int&gt; p( new int , DeleteIntPtr ) ;</span><br></pre></td></tr></table></figure>
<p>当p的引用技术为０时，自动调用删除器来释放对象的内存。删除器也可以是一个lambda表达式，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p( new int , [](int * p)&#123;delete p&#125; ) ;</span><br></pre></td></tr></table></figure>
<p>当我们使用shared_ptr管理动态数组时，需要指定删除器，因为<code>std::shared_ptr</code>默认的删除器不能处理数组对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p(new int[10], [](int* p)&#123;delete[] p;&#125;);</span><br></pre></td></tr></table></figure>
<p>或者通过封装一个<code>make_shared_array</code>方法来让shared_ptr支持数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">shared_ptr&lt;T&gt; make_shared_array(size_t size) &#123;</span><br><span class="line">	return shared_ptr&lt;T&gt;(new T[size], default_delete&lt;T[]&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要用一个原始指针初始化多个shared_ptr，以下是错误的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int* ptr = new int;</span><br><span class="line">shared_ptr&lt;int&gt; p1(ptr);</span><br><span class="line">shared_ptr&lt;int&gt; p2(ptr);</span><br></pre></td></tr></table></figure>
<p>不要在函数实参中创建shared_ptr，在调用函数之前先定义以及初始化它。</p>
<p>不要将this指针作为shared_ptr返回出来，因为this指针是一个裸指针，这样做可能会重复析构。正确返回this的shared_ptr的做法是：让目标类通过派生<code>std::enable_shared_from_this&lt;A&gt;</code>类，然后使用基类的成员函数<code>shared_from_this</code>来返回this的shared_ptr：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A : public std::enable_shared_from_this&lt;A&gt; &#123;</span><br><span class="line">	std::shared_ptr&lt;A&gt; GetSelf() &#123;</span><br><span class="line">		return shared_from_this();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要避免循环引用，循环引用会导致内存泄漏。</p>
<h2 id="unique-ptr独占的智能指针"><a href="#unique-ptr独占的智能指针" class="headerlink" title="unique_ptr独占的智能指针"></a><code>unique_ptr</code>独占的智能指针</h2><p><code>unique_ptr</code>是一个独占的智能指针，他不允许其他的智能指针共享其内部的指针，不允许通过赋值将一个unique_ptr赋值给另外一个unique_ptr，虽然不允许复制，但可以通过函数返回给其他的unique_ptr，还可以通过std::move来转移到其他的unique_ptr，这样它本身就不再拥有原来指针的所有权了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;T&gt; my_ptr(new T);</span><br><span class="line">unique_ptr&lt;T&gt; my_other_ptr = std::move(my_ptr);</span><br><span class="line">unique_ptr&lt;T&gt; ptr = my_ptr; // ERROR</span><br></pre></td></tr></table></figure>
<p>可以自己实现一个make_unique，C++尚未提供这个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, class... Args&gt; inline</span><br><span class="line">typename enable_if&lt;!is_array&lt;T&gt;::value, unique_ptr&lt;T&gt;&gt;::type</span><br><span class="line">make_unique(Args&amp;&amp; ... args) &#123;</span><br><span class="line">	return unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt; inline</span><br><span class="line">typename enable_if&lt;is_array&lt;T&gt;::value &amp;&amp; extent&lt;T&gt;::value==0, unique_ptr&lt;T&gt;&gt;::type</span><br><span class="line">make_unique(size_t size) &#123;</span><br><span class="line">	typedef typename remove_extent&lt;T&gt;::type U;</span><br><span class="line">	return unique_ptr&lt;T&gt;(new U[size]());</span><br><span class="line">&#125;</span><br><span class="line">template&lt;class T, class... Args&gt;</span><br><span class="line">typename enable_if&lt;extent&lt;T&gt;::value!=0, void&gt;::type</span><br><span class="line">make_unique(Args&amp;&amp;&amp; ...) = delete;</span><br></pre></td></tr></table></figure>
<p>如果不是数组，则直接创建unique_ptr，如果是数组，则先判断是否为定长数组，如果是定长数组则编译不通过，若为非定常数组，则获取数组中的元素类型，再根据入参size创建动态数组的unique_ptr。</p>
<p>unique_ptr还可指向一个数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int []&gt; ptr(new int[10]);</span><br><span class="line">ptr[9] = 9;</span><br></pre></td></tr></table></figure>
<p>unique_ptr指定删除器需要确定删除器的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int, void(*)(int*)&gt; ptr(new int(1), [](int* p)&#123; delete p; &#125;);</span><br></pre></td></tr></table></figure>
<p>如果lambda表达式没有捕获变量，这样写是对的，因为可以直接转换成函数指针。捕获了变量后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;int, std::function&lt;void(int*)&gt;&gt; ptr(new int(1), [&amp;](int* p)&#123; delete p; &#125;);</span><br></pre></td></tr></table></figure>
<p>如果希望只有一个智能指针管理资源或管理数组就用unique_ptr，如果希望多个智能指针管理同一个资源就用shared_ptr。 </p>
<h2 id="weak-ptr弱引用的智能指针"><a href="#weak-ptr弱引用的智能指针" class="headerlink" title="weak_ptr弱引用的智能指针"></a><code>weak_ptr</code>弱引用的智能指针</h2><p>弱引用的智能指针<code>weak_ptr</code>是用来监视<code>shared_ptr</code>的，不会使引用计数加一，它不管理<code>shared_ptr</code>内部的指针，主要是为了监视<code>shared_ptr</code>的生命周期，更像是<code>shared_ptr</code>的一个助手。</p>
<p><code>weak_ptr</code>没有重载运算符<code>*</code>和<code>-&gt;</code>，因为它不共享指针，不能操作资源，主要是为了通过<code>shared_ptr</code>获得资源的监测权，它的构造不会增加引用计数，它的析构不会减少引用计数，纯粹只是作为一个旁观者来监视<code>shared_ptr</code>中管理的资源是否存在。weak_ptr还可以用来返回this指针和解决循环引用的问题。</p>
<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p>通过<code>use_count()</code>获得当前观测资源的引用计数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt; sp(new int(10));</span><br><span class="line">weak_ptr&lt;int&gt; wp(sp);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; wp.use_count() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>通过<code>expired()</code>方法判断观测的资源是否已经释放：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt; sp(new int(10));</span><br><span class="line">weak_ptr&lt;int&gt; wp(sp);</span><br><span class="line">if (wp.expired())</span><br><span class="line">	cout &lt;&lt; &quot;weak_ptr useless&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>通过lock方法来获取所监视的<code>shared_ptr</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;int&gt; gw;</span><br><span class="line">void f() &#123;</span><br><span class="line">	if (gw.expired()) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;already expired&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		auto spt = gw.lock();</span><br><span class="line">		cout &lt;&lt; *spt &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		auto sp = std::make_shared&lt;int&gt;(43);</span><br><span class="line">		gw = sp;</span><br><span class="line">		f(); // 43</span><br><span class="line">	&#125;</span><br><span class="line">	f(); // already expired</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前提到不能直接将this指针返回为<code>shared_ptr</code>，需要通过派生<code>std::enable_shared_from_this</code>类，并通过其方法<code>shared_from_this</code>来返回智能指针，原因是<code>std::enable_shared_from_this</code>类中有一个<code>weak_ptr</code>，这个<code>weak_ptr</code>用来观测this智能指针，调用<code>shared_from_this()</code>方法时，会调用内部这个<code>weak_ptr</code>的<code>lock()</code>方法，将所观测的<code>shared_ptr</code>返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct A : public std::enable_shared_from_this&lt;A&gt; &#123;</span><br><span class="line">	std::shared_ptr&lt;A&gt; Getself() &#123;</span><br><span class="line">		return shared_from_this();</span><br><span class="line">	&#125;</span><br><span class="line">	~A() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;A is delete&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">std::shared_ptr&lt;A&gt; spy(newA);</span><br><span class="line">std::shared_ptr&lt;A&gt; p = spy-&gt;Getself();</span><br></pre></td></tr></table></figure>
<h3 id="解决循环引用"><a href="#解决循环引用" class="headerlink" title="解决循环引用"></a>解决循环引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct A;</span><br><span class="line">struct B;</span><br><span class="line">struct A &#123;</span><br><span class="line">	std::shared_ptr&lt;B&gt; bptr;</span><br><span class="line">	~A() &#123; cout &lt;&lt; &quot;A is deleted!&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct B &#123;</span><br><span class="line">	std::shared_ptr&lt;A&gt; aptr;</span><br><span class="line">	~B() &#123; cout &lt;&lt; &quot;B is deleted!&quot; &lt;&lt; endl; &#125; </span><br><span class="line">&#125;</span><br><span class="line">void TestPtr() &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::shared_ptr&lt;A&gt; ap(new A);</span><br><span class="line">		std::shared_ptr&lt;B&gt; bp(new B);</span><br><span class="line">		ap-&gt;bptr = bp;</span><br><span class="line">		bp-&gt;aptr = ap;</span><br><span class="line">	&#125; // Objects should be destroyed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，由于循环引用导致ap和bp的引用计数都是2，离开作用域后减为1，不会去删除指针，导致内存泄漏，通过weak_ptr解决这个问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct A;</span><br><span class="line">struct B;</span><br><span class="line">struct A &#123;</span><br><span class="line">	std::shared_ptr&lt;B&gt; bptr;</span><br><span class="line">	~A() &#123; cout &lt;&lt; &quot;A is deleted!&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct B &#123;</span><br><span class="line">	std::weak_ptr&lt;A&gt; aptr; // 改为weak_ptr</span><br><span class="line">	~B() &#123; cout &lt;&lt; &quot;B is deleted!&quot; &lt;&lt; endl; &#125; </span><br><span class="line">&#125;</span><br><span class="line">void TestPtr() &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		std::shared_ptr&lt;A&gt; ap(new A);</span><br><span class="line">		std::shared_ptr&lt;B&gt; bp(new B);</span><br><span class="line">		ap-&gt;bptr = bp;</span><br><span class="line">		bp-&gt;aptr = ap;</span><br><span class="line">	&#125; // Objects should be destroyed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过智能指针管理第三方库分配的内存"><a href="#通过智能指针管理第三方库分配的内存" class="headerlink" title="通过智能指针管理第三方库分配的内存"></a>通过智能指针管理第三方库分配的内存</h2><p>第三方库分配的内存一般需要通过第三方库提供的释放接口才能释放，由于第三方库返回的指针一般都是原始指针，用完之后如果没有调用第三方库的释放接口，就很容易造成内存泄露。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *p = GetHandle()-&gt;Create();</span><br><span class="line">//do something</span><br><span class="line">GetHandle()-&gt;Realease(p);</span><br></pre></td></tr></table></figure>
<p>用智能指针来管理第三方库的内存就比较方便，不用担心中途返回或者发生异常导致无法调用释放接口的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void *p = GetHandle()-&gt;Create();</span><br><span class="line">//do something</span><br><span class="line">std::shared_ptr&lt;void&gt; sp(p, [this](void* p) &#123;GetHandle()-&gt;Realease(p); &#125;);</span><br></pre></td></tr></table></figure>
<p>将其提炼成函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;void&gt; Guard(void*p)</span><br><span class="line">&#123;</span><br><span class="line">	 std::shared_ptr&lt;void&gt; sp(p, [this](void* p) &#123;GetHandle()-&gt;Realease(p); &#125;);</span><br><span class="line">	 return sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在使用时</span><br><span class="line">void* p = GetHandle()-&gt;Create();</span><br><span class="line">Guard(p); //危险，这句结束后p就被释放了</span><br><span class="line">//do something</span><br></pre></td></tr></table></figure>
<p>执行<code>Guard();</code>这句后，函数返回的是一个右值，没有被存储，用完就把p释放了。</p>
<p>可以用宏的方式来解决这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define GUARD(p) std::shared_ptr&lt;void&gt; p##p(p, [](void *p)&#123;release(p);&#125;)</span><br><span class="line"></span><br><span class="line">//使用时</span><br><span class="line">void* p = GetHandle()-&gt;Create();</span><br><span class="line">GUARD(p);  //安全</span><br></pre></td></tr></table></figure>
<p>也可以用unique_ptr来管理第三方的内存：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define GUARD(p) std::unique_ptr&lt;void&gt; p##p(p, [](void *p)&#123;release(p);&#125;)</span><br></pre></td></tr></table></figure>
<p>对于宏中的##，其实也很好理解，就是将##前后的字符串连接起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define GUARD(p) std::shared_ptr&lt;void&gt; p##p(p, [](void *p)&#123;release(p);&#125;)</span><br><span class="line"></span><br><span class="line">//使用时</span><br><span class="line">void* p = GetHandle()-&gt;Create();</span><br><span class="line">GUARD(p);  //安全</span><br><span class="line">//会有一个std::shared_ptr&lt;void&gt; pp的智能指针，不信就进行测试。原因去找刚才的#define中有p##p</span><br><span class="line">std::cout &lt;&lt; pp.use_count() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>为了验证原作者的这些，写一些demo来帮助理解，也有利于更好掌握：<br>创建一个Base类：<br>Base.h文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Base();</span><br><span class="line">	~Base();</span><br><span class="line"></span><br><span class="line">	void print();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Base.cpp文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Base.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">Base::Base()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;Base constructor&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base::~Base()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;Base desctructor&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Base::print()</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;print something&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main.cpp中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Base.h&quot;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#define GUARD(p) std::shared_ptr&lt;Base&gt; p##p(p, [](Base*p)&#123;release(p);&#125;)</span><br><span class="line"></span><br><span class="line">Base* create()</span><br><span class="line">&#123;</span><br><span class="line">	return new Base();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void release(Base* base)</span><br><span class="line">&#123;</span><br><span class="line">	delete base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;Base&gt; Guard(Base *p)</span><br><span class="line">&#123;</span><br><span class="line">	 std::shared_ptr&lt;Base&gt; sp(p, [](Base*p) &#123;release(p); &#125;);</span><br><span class="line">	 return sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		Base* p = create();</span><br><span class="line">		</span><br><span class="line">		std::shared_ptr&lt;Base&gt; sp(p, [](Base*p) &#123;release(p); &#125;);</span><br><span class="line">		//Guard(p);</span><br><span class="line"></span><br><span class="line">		//GUARD(p);</span><br><span class="line">		//std::cout &lt;&lt; &quot;sp.use_count():&quot; &lt;&lt; sp.use_count() &lt;&lt; std::endl;;</span><br><span class="line">		p-&gt;print();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">print something</span><br><span class="line">Base desctructor</span><br></pre></td></tr></table></figure>
<p>【修改一】 当我们对main()中修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		Base* p = create();</span><br><span class="line">		</span><br><span class="line">		//std::shared_ptr&lt;Base&gt; sp(p, [](Base*p) &#123;release(p); &#125;);</span><br><span class="line">		Guard(p);</span><br><span class="line"></span><br><span class="line">		//GUARD(p);</span><br><span class="line">		//std::cout &lt;&lt; &quot;sp.use_count():&quot; &lt;&lt; sp.use_count() &lt;&lt; std::endl;;</span><br><span class="line">		p-&gt;print();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Base desctructor</span><br><span class="line">print something</span><br></pre></td></tr></table></figure>
<p>发现这时候的p被提前释放了，print something已经是在Base类析构之后做的，此时已经出问题了。</p>
<p>【修改二】将main函数进行修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		Base* p = create();</span><br><span class="line">		</span><br><span class="line">		//std::shared_ptr&lt;Base&gt; sp(p, [](Base*p) &#123;release(p); &#125;);</span><br><span class="line">		//Guard(p);</span><br><span class="line"></span><br><span class="line">		GUARD(p);</span><br><span class="line">		std::cout &lt;&lt; &quot;pp.use_count(): &quot; &lt;&lt; pp.use_count() &lt;&lt; std::endl;;</span><br><span class="line">		p-&gt;print();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">pp.use_count(): 1</span><br><span class="line">print something</span><br><span class="line">Base desctructor</span><br></pre></td></tr></table></figure>
<p>果然如我们所想，一切正常。</p>
<h1 id="使用C-11让多线程开发变得简单"><a href="#使用C-11让多线程开发变得简单" class="headerlink" title="使用C++11让多线程开发变得简单"></a>使用C++11让多线程开发变得简单</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>用<code>std::thread</code>创建线程非常简单，只需要提供线程函数或者函数对象即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void func() &#123;</span><br><span class="line">	cout &lt;&lt; &quot;thread test&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	thread t(func);</span><br><span class="line">	t.join();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数func会运行于线程对象t中，join函数会阻塞线程，直到线程函数执行结束，如果线程函数有返回值，返回值被忽略。如果不希望线程被阻塞执行，调用detach将线程和线程对象分离,让线程作为后台线程去执行，当前线程也不会阻塞了。需要注意的是detach()之后就无法再和线程发生联系了，比如detach之后就不能通过join来等待线程执行完，线程何时执行完我们也无法控制了。</p>
<p>线程可以接受任意个数的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void func(int i, double d, const std::string&amp; s) &#123;</span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; d &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	std::thread t(func, 1, 2.0, &quot;heoo&quot;);</span><br><span class="line">	t.join();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>std::thread出了作用域后会析构，保证线程函数的生命周期在线程变量的生命周期之内</strong></p>
<p>线程不能复制，但是可以移动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	std::thread t(func);</span><br><span class="line">	std::thread t1(std::move(t));</span><br><span class="line">	t.join(); // error</span><br><span class="line">	t1.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程被移动之后，线程对象t就不再代表任何线程。另外可以通过<code>std::bind</code>和lambda表达式来创建线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	std::thread t(std::bind(func));</span><br><span class="line">	std::thread t1([](int a, double b)&#123;&#125;, 1, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将线程存放到容器中，保证线程对象的生命周期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;thread&gt; g_list;</span><br><span class="line">vector&lt;shared_ptr&lt;thread&gt;&gt; g_list2;</span><br><span class="line"></span><br><span class="line">void CreateThread() &#123;</span><br><span class="line">	thread t(func);</span><br><span class="line">	g_list.push_back(move(t));</span><br><span class="line">	g_list2.push_back(make_shared&lt;thread&gt;(func));</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	CreateThread();</span><br><span class="line">	for (auto&amp; thread : g_list) &#123;</span><br><span class="line">		thread.join();</span><br><span class="line">	&#125;</span><br><span class="line">	for (auto&amp; thread : g_list2) &#123;</span><br><span class="line">		thread-&gt;join();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程可以获取当前线程的ID，还可以获取CPU核心数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	thread t1(func);</span><br><span class="line">    cout &lt;&lt; t1.get_id() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    cout &lt;&lt; t1.get_id() &lt;&lt; endl;//获取当前线程id,0，表示已经执行结束了.</span><br><span class="line">    cout &lt;&lt; std::thread::hardware_concurrency() &lt;&lt; endl;//8核</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>互斥量是一种同步原语，是一种线程同步的手段，用来保护多线程同时访问的共享数据。</p>
<ul>
<li>std::mutex: 独占的互斥量,不能递归使用.</li>
<li>std::timed_mutex: 带超时的独占互斥量,不能递归使用.</li>
<li>std::recursive_mutex: 递归互斥量,不带超时功能.</li>
<li>std::recursive_timed_mutex: 带超时的递归互斥量.</li>
</ul>
<p>这些互斥量的基本接口十分相近，都是通过lock()来阻塞线程，直到获得互斥量的所有权为止。在线程获得互斥量并完成任务后，就必须使用unlock()来解除对互斥量的占用，lock和unlock必须成对出现。try_lock()尝试锁定互斥量，成功返回true，失败返回false，他是非阻塞的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::mutex g_lock;</span><br><span class="line"></span><br><span class="line">void lock_unlock()</span><br><span class="line">&#123;</span><br><span class="line">    //上锁</span><br><span class="line">    g_lock.lock();</span><br><span class="line">    cout &lt;&lt; &quot;in id: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span><br><span class="line">    this_thread::sleep_for(chrono::seconds(1));</span><br><span class="line">    cout &lt;&lt; &quot;out id: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span><br><span class="line">    //解锁</span><br><span class="line">    g_lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用lock_guard可以简化lock/unlock的写法，因为lock_guard在构造时可以自动锁定互斥量，在退出作用域后进行析构时会自动解锁，从而保证了互斥量的正确操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void f_lock_guard()</span><br><span class="line">&#123;</span><br><span class="line">    //lock_guard在构造时会自动锁定互斥量,而在退出作用域后进行析构时就会自动解锁.</span><br><span class="line">    lock_guard&lt;std::mutex&gt; lock(g_lock);</span><br><span class="line">    cout &lt;&lt; &quot;in id: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span><br><span class="line">    this_thread::sleep_for(chrono::seconds(1));</span><br><span class="line">    cout &lt;&lt; &quot;out id: &quot; &lt;&lt; this_thread::get_id() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归的独占互斥量<code>std::recursive_mutex</code>允许同一线程多次获得该互斥锁，可以用来解决同一线程需要多次获取互斥量时死锁的问题，来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct Complex &#123;</span><br><span class="line">	std::recursive_mutex mutex;</span><br><span class="line">	int i;</span><br><span class="line">	Complex() : i(0) &#123;&#125;</span><br><span class="line">	void mul(int x) &#123;</span><br><span class="line">		std::lock_guard&lt;std::recursive_mutex&gt; lock(mutex);</span><br><span class="line">		i *= x;</span><br><span class="line">	&#125;</span><br><span class="line">	void div(int x) &#123;</span><br><span class="line">		std::lock_guard&lt;std::recursive_mutex&gt; lock(mutex);</span><br><span class="line">		i /= x;</span><br><span class="line">	&#125;</span><br><span class="line">	void both(int x, int y) &#123;</span><br><span class="line">		std::lock_guard&lt;std::recursive_mutex&gt; lock(mutex);</span><br><span class="line">		// 因为同一线程可以多次获取同一互斥量，不会发生死锁。</span><br><span class="line">		mul(x);</span><br><span class="line">		div(y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽量不要使用递归锁，因为：</p>
<ul>
<li>需要用到递归锁定的多线程互斥处理往往本身就是可以简化的，允许递归互斥很容易放纵复杂逻辑的产生，从而导致一些多线程同步引起的晦涩问题</li>
<li>递归锁比起非递归锁，效率会低一些。</li>
<li>递归锁虽然允许同一个线程多次获得同一个互斥量，可重复获得的最大次数并未具体说明，一旦超过一定次数，再对lock进行调用就会抛出<code>std::system</code>错误。</li>
</ul>
<p>带超时的互斥量<code>std::timed_mutex</code>和<code>std::recursive_timed_mutex</code>。<code>std::timed_mutex</code>是超时的独占锁，<code>std::recursive_timed_mutex</code>是超时的递归锁，主要用在获取锁时增加超时等待功能，因为有时不知道获取锁需要多久，为了不至于一直在等待获取互斥量，就设置一个等待超时时间，在超时后还可以做其他的事情。</p>
<p><code>std::timed_mutex</code>比<code>std::mutex</code>多了两个超时获取锁的接口：<code>try_lock_for</code>和<code>try_lock_until</code>，这两个接口是用来设置获取互斥量的超时时间，使用时可以用一个while循环去不断地获取互斥量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">std::timed_mutex mutex;</span><br><span class="line">void work() &#123;</span><br><span class="line">	std::chrono::milliseconds timeout(100);</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		if (mutex.try_lock_for(timeout)) &#123;</span><br><span class="line">			std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;: do work with the mutex&quot; &lt;&lt; endl;</span><br><span class="line">			std::chrono::milliseconds sleepDuration(250);</span><br><span class="line">			std::this_thread::sleep_for(sleepDuration);</span><br><span class="line">			mutex.unlock();</span><br><span class="line">			std::this_thread_sleep_for(sleepDuration);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot;: do work without the mutex&quot; &lt;&lt; endl;</span><br><span class="line">			std::chrono::milliseconds sleepDuration(100);</span><br><span class="line">			std::this_thread::sleep_for(sleepDuration);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p><code>&lt;condition_variable&gt;</code>头文件主要包含了与条件变量相关的类和函数。相关的类包括<code>std::condition_variable</code>和<code>std::condition_variable_any</code>，还有枚举类型<code>std::cv_status</code>。另外还包括函数<code>std::notify_all_at_thread_exit()</code>。</p>
<p><code>condition_variable</code>配合<code>std::unique_lock&lt;std::mutex&gt;</code>进行wait操作。<code>condition_variable_any</code>，和任意带有lock、unlock语义的mutex搭配使用，比较灵活，但效率比<code>condition_variable</code>差一些。条件变量的使用过程如下：</p>
<ul>
<li>拥有条件变量的线程获取互斥量。</li>
<li>循环检查某个条件，如果条件不满足，则阻塞直到条件满足；如果条件满足，则向下执行。</li>
<li>某个线程满足条件执行完之后调用<code>notify_one</code>或<code>notify_all</code>唤醒一个或者所有的等待线程。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; </span><br><span class="line">class SyncQueue &#123;</span><br><span class="line">	bool isFull() const &#123;</span><br><span class="line">		return m_queue.size() == m_maxSize;</span><br><span class="line">	&#125;</span><br><span class="line">	bool isEmpty() const &#123;</span><br><span class="line">		return m_queue.empty();</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	SyncQueue(int maxSize) : m_maxSize(maxSize) &#123;&#125;</span><br><span class="line">	void Put(const T&amp; x) &#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">		while(isFull())&#123;</span><br><span class="line">			m_notFull.wait(m_mutex);</span><br><span class="line">		&#125;</span><br><span class="line">		m_queue.push_back(x);</span><br><span class="line">		m_notEmpty.notify_one();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void Take(T&amp; x) &#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">		while(isEmpty())&#123;</span><br><span class="line">			m_notEmpty.wait(m_mutex);</span><br><span class="line">		&#125;</span><br><span class="line">		x = m_queue.front();</span><br><span class="line">		m_queue.pop_front();</span><br><span class="line">		m_notFull.notify_one();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool Empty() &#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">		return m_queue.empty();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool Full() &#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">		return m_queue.size() == m_maxSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	size_t Size() &#123;</span><br><span class="line">		std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">		return m_queue.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int Count() &#123;</span><br><span class="line">		return m_queue.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	std::list&lt;T&gt; m_queue;</span><br><span class="line">	std::mutex m_mutex;</span><br><span class="line">	std::condition_variable_any m_notEmpty;</span><br><span class="line">	std::condition_variable_any m_notFull;</span><br><span class="line">	int m_maxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个同步队列在没有满的情况下可以插入数据，如果满了，则会调用m_notFull阻塞等待，待消费线程取出数据之后发一个未满的通知，然后前面阻塞的线程就会被唤醒继续往下执行；如果队列为空，就不能取数据，会调用m_notEmpty条件变量阻塞，等待插入数据的线程发出不为空的通知时，才能继续往下执行。以上过程是同步队列的工作过程。</p>
<p>当<code>std::condition_variable</code>对象的某个 wait 函数被调用的时候，它使用<code>std::unique_lock</code>(通过<code>std::mutex</code>) 来锁住当前线程。当前线程会一直被阻塞，直到另外一个线程在相同的<code>std::condition_variable</code>对象上调用了 notification 函数来唤醒当前线程。</p>
<p><code>std::condition_variable</code>对象通常使用<code>std::unique_lock&lt;std::mutex&gt;</code>来等待，如果需要使用另外的<code>lockable</code>类型，可以使用<code>std::condition_variable_any</code>类，本文后面会讲到<code>std::condition_variable_any</code>的用法。</p>
<p>首先我们来看一个简单的例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                // std::cout</span><br><span class="line">#include &lt;thread&gt;                // std::thread</span><br><span class="line">#include &lt;mutex&gt;                // std::mutex, std::unique_lock</span><br><span class="line">#include &lt;condition_variable&gt;    // std::condition_variable</span><br><span class="line"></span><br><span class="line">std::mutex mtx; // 全局互斥锁.</span><br><span class="line">std::condition_variable cv; // 全局条件变量.</span><br><span class="line">bool ready = false; // 全局标志位.</span><br><span class="line"></span><br><span class="line">void do_print_id(int id)</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock &lt;std::mutex&gt; lck(mtx);</span><br><span class="line">    while (!ready) // 如果标志位不为 true, 则等待...</span><br><span class="line">        cv.wait(lck); // 当前线程被阻塞, 当全局标志位变为 true 之后,</span><br><span class="line">    // 线程被唤醒, 继续往下执行打印线程编号id.</span><br><span class="line">    std::cout &lt;&lt; &quot;thread &quot; &lt;&lt; id &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void go()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock &lt;std::mutex&gt; lck(mtx);</span><br><span class="line">    ready = true; // 设置全局标志位为 true.</span><br><span class="line">    cv.notify_all(); // 唤醒所有线程.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::thread threads[10];</span><br><span class="line">    // spawn 10 threads:</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">        threads[i] = std::thread(do_print_id, i);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;10 threads ready to race...\n&quot;;</span><br><span class="line">    go(); // go!</span><br><span class="line"></span><br><span class="line">  for (auto &amp; th:threads)</span><br><span class="line">        th.join();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10 threads ready to race...</span><br><span class="line">thread 1</span><br><span class="line">thread 0</span><br><span class="line">thread 2</span><br><span class="line">thread 3</span><br><span class="line">thread 4</span><br><span class="line">thread 5</span><br><span class="line">thread 6</span><br><span class="line">thread 7</span><br><span class="line">thread 8</span><br><span class="line">thread 9</span><br></pre></td></tr></table></figure>
<p>好了，对条件变量有了一个基本的了解之后，我们来看看<code>std::condition_variable</code>的各个成员函数。</p>
<p><code>std::condition_variable</code>提供了两种 wait() 函数。当前线程调用 wait() 后将被阻塞(此时当前线程应该获得了锁（mutex），不妨设获得锁 lck)，直到另外某个线程调用<code>notify_*</code>唤醒了当前线程。</p>
<p>在线程被阻塞时，该函数会自动调用<code>lck.unlock()</code>释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，一旦当前线程获得通知(notified，通常是另外某个线程调用<code>notify_*</code>唤醒了当前线程)，wait() 函数也是自动调用<code>lck.lock()</code>，使得 lck 的状态和 wait 函数被调用时相同。</p>
<p>在第二种情况下（即设置了 Predicate），只有当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred 为 true 时才会被解除阻塞。因此第二种情况类似以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while (!pred()) wait(lck);</span><br></pre></td></tr></table></figure>
<p>请看下面例子（参考）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                // std::cout</span><br><span class="line">#include &lt;thread&gt;                // std::thread, std::this_thread::yield</span><br><span class="line">#include &lt;mutex&gt;                // std::mutex, std::unique_lock</span><br><span class="line">#include &lt;condition_variable&gt;    // std::condition_variable</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line">int cargo = 0;</span><br><span class="line">bool shipment_available()</span><br><span class="line">&#123;</span><br><span class="line">    return cargo != 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消费者线程.</span><br><span class="line">void consume(int n)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        std::unique_lock &lt;std::mutex&gt; lck(mtx);</span><br><span class="line">        cv.wait(lck, shipment_available);</span><br><span class="line">        std::cout &lt;&lt; cargo &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">        cargo = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::thread consumer_thread(consume, 10); // 消费者线程.</span><br><span class="line"></span><br><span class="line">    // 主线程为生产者线程, 生产 10 个物品.</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        while (shipment_available())</span><br><span class="line">            std::this_thread::yield();</span><br><span class="line">        std::unique_lock &lt;std::mutex&gt; lck(mtx);</span><br><span class="line">        cargo = i + 1;</span><br><span class="line">        cv.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumer_thread.join();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">concurrency ) ./ConditionVariable-wait </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>std::condition_variable::wait_for() 介绍</p>
<p>unconditional (1)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Rep, class Period&gt;</span><br><span class="line">  cv_status wait_for (unique_lock&lt;mutex&gt;&amp; lck,</span><br><span class="line">                      const chrono::duration&lt;Rep,Period&gt;&amp; rel_time);</span><br></pre></td></tr></table></figure>
<p>predicate (2)    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Rep, class Period, class Predicate&gt;</span><br><span class="line">       bool wait_for (unique_lock&lt;mutex&gt;&amp; lck,</span><br><span class="line">                      const chrono::duration&lt;Rep,Period&gt;&amp; rel_time, Predicate pred);</span><br></pre></td></tr></table></figure>
<p>与 std::condition_variable::wait() 类似，不过 wait_for 可以指定一个时间段，在当前线程收到通知或者指定的时间 rel_time 超时之前，该线程都会处于阻塞状态。而一旦超时或者收到了其他线程的通知，wait_for 返回，剩下的处理步骤和 wait() 类似。</p>
<p>另外，wait_for 的重载版本（predicte(2)）的最后一个参数 pred 表示 wait_for 的预测条件，只有当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred 为 true 时才会被解除阻塞，因此相当于如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return wait_until (lck, chrono::steady_clock::now() + rel_time, std::move(pred));</span><br></pre></td></tr></table></figure>
<p>请看下面的例子（参考），下面的例子中，主线程等待 th 线程输入一个值，然后将 th 线程从终端接收的值打印出来，在 th 线程接受到值之前，主线程一直等待，每个一秒超时一次，并打印一个 “.”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;           // std::cout</span><br><span class="line">#include &lt;thread&gt;             // std::thread</span><br><span class="line">#include &lt;chrono&gt;             // std::chrono::seconds</span><br><span class="line">#include &lt;mutex&gt;              // std::mutex, std::unique_lock</span><br><span class="line">#include &lt;condition_variable&gt; // std::condition_variable, std::cv_status</span><br><span class="line"></span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line">int value;</span><br><span class="line"></span><br><span class="line">void do_read_value()</span><br><span class="line">&#123;</span><br><span class="line">    std::cin &gt;&gt; value;</span><br><span class="line">    cv.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Please, enter an integer (I&#x27;ll be printing dots): \n&quot;;</span><br><span class="line">    std::thread th(do_read_value);</span><br><span class="line"></span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lck(mtx);</span><br><span class="line">    while (cv.wait_for(lck,std::chrono::seconds(1)) == std::cv_status::timeout) &#123;</span><br><span class="line">        std::cout &lt;&lt; &#x27;.&#x27;;</span><br><span class="line">        std::cout.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;You entered: &quot; &lt;&lt; value &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line"></span><br><span class="line">    th.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std::condition_variable::wait_until 介绍</p>
<p>unconditional (1)    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Clock, class Duration&gt;</span><br><span class="line">  cv_status wait_until (unique_lock&lt;mutex&gt;&amp; lck,</span><br><span class="line">                        const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time);</span><br></pre></td></tr></table></figure>
<p>predicate (2)    </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Clock, class Duration, class Predicate&gt;</span><br><span class="line">       bool wait_until (unique_lock&lt;mutex&gt;&amp; lck,</span><br><span class="line">                        const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time,</span><br><span class="line">                        Predicate pred);</span><br></pre></td></tr></table></figure>
<p>与<code>std::condition_variable::wait_for</code>类似，但是 wait_until 可以指定一个时间点，在当前线程收到通知或者指定的时间点 abs_time 超时之前，该线程都会处于阻塞状态。而一旦超时或者收到了其他线程的通知，wait_until 返回，剩下的处理步骤和 wait_until() 类似。</p>
<p>另外，wait_until 的重载版本（predicte(2)）的最后一个参数 pred 表示 wait_until 的预测条件，只有当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred 为 true 时才会被解除阻塞，因此相当于如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (!pred())</span><br><span class="line">  if ( wait_until(lck,abs_time) == cv_status::timeout)</span><br><span class="line">    return pred();</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure>
<p>std::condition_variable::notify_one() 介绍<br>唤醒某个等待(wait)线程。如果当前没有等待线程，则该函数什么也不做，如果同时存在多个等待线程，则唤醒某个线程是不确定的(unspecified)。</p>
<p>请看下例（参考）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                // std::cout</span><br><span class="line">#include &lt;thread&gt;                // std::thread</span><br><span class="line">#include &lt;mutex&gt;                // std::mutex, std::unique_lock</span><br><span class="line">#include &lt;condition_variable&gt;    // std::condition_variable</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"></span><br><span class="line">int cargo = 0; // shared value by producers and consumers</span><br><span class="line"></span><br><span class="line">void consumer()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock &lt; std::mutex &gt; lck(mtx);</span><br><span class="line">    while (cargo == 0)</span><br><span class="line">        cv.wait(lck);</span><br><span class="line">    std::cout &lt;&lt; cargo &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    cargo = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void producer(int id)</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock &lt; std::mutex &gt; lck(mtx);</span><br><span class="line">    cargo = id;</span><br><span class="line">    cv.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::thread consumers[10], producers[10];</span><br><span class="line"></span><br><span class="line">    // spawn 10 consumers and 10 producers:</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        consumers[i] = std::thread(consumer);</span><br><span class="line">        producers[i] = std::thread(producer, i + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // join them back:</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        producers[i].join();</span><br><span class="line">        consumers[i].join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std::condition_variable::notify_all() 介绍<br>唤醒所有的等待(wait)线程。如果当前没有等待线程，则该函数什么也不做。请看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;                // std::cout</span><br><span class="line">#include &lt;thread&gt;                // std::thread</span><br><span class="line">#include &lt;mutex&gt;                // std::mutex, std::unique_lock</span><br><span class="line">#include &lt;condition_variable&gt;    // std::condition_variable</span><br><span class="line"></span><br><span class="line">std::mutex mtx; // 全局互斥锁.</span><br><span class="line">std::condition_variable cv; // 全局条件变量.</span><br><span class="line">bool ready = false; // 全局标志位.</span><br><span class="line"></span><br><span class="line">void do_print_id(int id)</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock &lt;std::mutex&gt; lck(mtx);</span><br><span class="line">    while (!ready) // 如果标志位不为 true, 则等待...</span><br><span class="line">        cv.wait(lck); // 当前线程被阻塞, 当全局标志位变为 true 之后,</span><br><span class="line">    // 线程被唤醒, 继续往下执行打印线程编号id.</span><br><span class="line">    std::cout &lt;&lt; &quot;thread &quot; &lt;&lt; id &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void go()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock &lt;std::mutex&gt; lck(mtx);</span><br><span class="line">    ready = true; // 设置全局标志位为 true.</span><br><span class="line">    cv.notify_all(); // 唤醒所有线程.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::thread threads[10];</span><br><span class="line">    // spawn 10 threads:</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">        threads[i] = std::thread(do_print_id, i);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;10 threads ready to race...\n&quot;;</span><br><span class="line">    go(); // go!</span><br><span class="line"></span><br><span class="line">  for (auto &amp; th:threads)</span><br><span class="line">        th.join();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> std::condition_variable_any 介绍<br>与<code>std::condition_variable</code>类似，只不过<code>std::condition_variable_any</code>的 wait 函数可以接受任何 lockable 参数，而<code>std::condition_variable</code>只能接受<code>std::unique_lock&lt;std::mutex&gt;</code>类型的参数，除此以外，和<code>std::condition_variable</code>几乎完全一样。</p>
<p>std::cv_status 枚举类型介绍</p>
<p><code>cv_status::no_timeout</code>：wait_for 或者 wait_until 没有超时，即在规定的时间段内线程收到了通知。<br><code>cv_status::timeout</code>：wait_for 或者 wait_until 超时。</p>
<p>std::notify_all_at_thread_exit<br>函数原型为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void notify_all_at_thread_exit (condition_variable&amp; cond, unique_lock&lt;mutex&gt; lck);</span><br></pre></td></tr></table></figure>
<p>当调用该函数的线程退出时，所有在 cond 条件变量上等待的线程都会收到通知。请看下例（参考）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;           // std::cout</span><br><span class="line">#include &lt;thread&gt;             // std::thread</span><br><span class="line">#include &lt;mutex&gt;              // std::mutex, std::unique_lock</span><br><span class="line">#include &lt;condition_variable&gt; // std::condition_variable</span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line">bool ready = false;</span><br><span class="line"></span><br><span class="line">void print_id (int id) &#123;</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; lck(mtx);</span><br><span class="line">  while (!ready) cv.wait(lck);</span><br><span class="line">  // ...</span><br><span class="line">  std::cout &lt;&lt; &quot;thread &quot; &lt;&lt; id &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void go() &#123;</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; lck(mtx);</span><br><span class="line">  std::notify_all_at_thread_exit(cv,std::move(lck));</span><br><span class="line">  ready = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  std::thread threads[10];</span><br><span class="line">  // spawn 10 threads:</span><br><span class="line">  for (int i=0; i&lt;10; ++i)</span><br><span class="line">    threads[i] = std::thread(print_id,i);</span><br><span class="line">  std::cout &lt;&lt; &quot;10 threads ready to race...\n&quot;;</span><br><span class="line"></span><br><span class="line">  std::thread(go).detach();   // go!</span><br><span class="line"></span><br><span class="line">  for (auto&amp; th : threads) th.join();</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h2><p>C++11提供了一个原子类型std::atomic<T>，可以使用任意类型作为模板参数，C++11内置了整型的原子变量，可以更方便地使用原子变量，使用原子变量就不需要使用互斥量来保护该变量了，因为对该变量的操作保证其是原子的，是不可中断的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int value;</span><br><span class="line">std::mutex mutex;</span><br><span class="line">void increment() &#123;</span><br><span class="line">	std::lock_guard&lt;std::mutex&gt; lock(mutex);</span><br><span class="line">	++value;</span><br><span class="line">&#125;</span><br><span class="line">void decrement() &#123;</span><br><span class="line">	std::lock_guard&lt;std::mutex&gt; lock(mutex);</span><br><span class="line">	--value;</span><br><span class="line">&#125;</span><br><span class="line">void get() &#123;</span><br><span class="line">	return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以改成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::atmoic&lt;int&gt; value;</span><br><span class="line">void increment() &#123;</span><br><span class="line">	++value;</span><br><span class="line">&#125;</span><br><span class="line">void decrement() &#123;</span><br><span class="line">	--value;</span><br><span class="line">&#125;</span><br><span class="line">void get() &#123;</span><br><span class="line">	return value.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="call-once-once-flag的使用"><a href="#call-once-once-flag的使用" class="headerlink" title="call_once/once_flag的使用"></a>call_once/once_flag的使用</h2><p>为了保证在多线程环境中某个函数仅被调用一次，比如，需要初始化某个对象，而这个对象只能初始化一次时，就可以用std::call_once来保证函数在多线程环境中只被调用一次。使用std::call_once时，需要一个once_flag作为call_one的入参，它的用法比较简单。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;thread&gt;</span><br><span class="line">#include&lt;mutex&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">std::once_flag flag;</span><br><span class="line"></span><br><span class="line">void do_once()</span><br><span class="line">&#123;</span><br><span class="line">    std::call_once(flag,[]&#123;std::cout&lt;&lt;&quot;Called once&quot;&lt;&lt;endl;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::thread t1(do_once);</span><br><span class="line">    std::thread t2(do_once);</span><br><span class="line">    std::thread t3(do_once);</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Called once</span><br></pre></td></tr></table></figure>
<h2 id="异步操作类"><a href="#异步操作类" class="headerlink" title="异步操作类"></a>异步操作类</h2><p>C++11 提供了异步操作相关的类：</p>
<ul>
<li><code>std::future</code>作为异步结果的传输通道，用于获取线程函数的的返回值；</li>
<li><code>std::promise</code>用于包装一个值，将数据和future绑定起来，方便线程赋值；</li>
<li><code>std::package_task</code>将函数和future绑定起来，以便异步调用。</li>
</ul>
<h3 id="std-future"><a href="#std-future" class="headerlink" title="std::future"></a><code>std::future</code></h3><p>thread库提供了future用来访问异步操作的结果，因为一个异步操作的结果不能马上获取，只能在未来某个时候从某个地方获取，这个异步操作的结果是一个未来的期待值，所以被称为future，future提供了获取异步操作结果的通道。可以以同步等待的方式获取结果，可以通过查询future的状态（future_status)来获取异步操作的结果。future_status有如下3种状态：</p>
<ul>
<li>Deferred:异步操作还没开始</li>
<li>Ready:异步操作已经完成</li>
<li>Timeout:异步操作超时</li>
</ul>
<p>我们可以查询future状态，通过它内部的状态可以知道异步任务的执行情况:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::future_status status；</span><br><span class="line">do&#123;</span><br><span class="line">    status=future.wait_for(std::chrono::seconds(1));</span><br><span class="line">    if(status==std::future_status::deferred)&#123;&#125;</span><br><span class="line">    else if(status==std::future_status::timeout)&#123;&#125;</span><br><span class="line">    else if(status==std::future_status::ready)&#123;&#125;</span><br><span class="line">&#125;while(status!=std::future_status::ready);</span><br></pre></td></tr></table></figure>
<p>获取future结果有三种方式：</p>
<ul>
<li>get： 等待异步操作结束并返回结果</li>
<li>wait：只是等待异步操作完成，没有返回值</li>
<li>wait_for：是超时等待返回结果</li>
</ul>
<h3 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a><code>std::promise</code></h3><p><code>std::promise</code>将数据和future绑定起来，在线程函数中为外面传进来的promise赋值，在线程函数执行完之后就可以通过promise的future获取该值了。取值是间接地通过promise内部提供的future来获取的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;int&gt; pr;</span><br><span class="line">std::thread t([](std::promise&lt;int&gt; &amp;p)&#123;p.set_value_at_thread_exit(9);&#125;,std::ref(pr));</span><br><span class="line">std::future&lt;int&gt; f=pr.get_future();</span><br><span class="line">auto f=f.get();</span><br></pre></td></tr></table></figure>
<h3 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a><code>std::packaged_task</code></h3><p><code>std::packaged_task</code>包装了一个可调用对象的包装类（如function、lambda expression、bind expression和another function object)，将函数和future绑定起来，以便异步调用，它和std::promise在某种程度上有点像，promise保存了一个共享状态的值，而packaged_task保存的是一个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::packaged_task&lt;int()&gt; task([]()&#123;return 7;&#125;);</span><br><span class="line">std::thread t1(std::ref(task));</span><br><span class="line">std::future&lt;int&gt; f1=task.get_future();</span><br><span class="line">auto r1=f1.get();</span><br></pre></td></tr></table></figure>
<h3 id="std-promise、std-packaged-task和std-future三者之间的关系"><a href="#std-promise、std-packaged-task和std-future三者之间的关系" class="headerlink" title="std::promise、std::packaged_task和std::future三者之间的关系"></a><code>std::promise</code>、<code>std::packaged_task</code>和<code>std::future</code>三者之间的关系</h3><p><code>std::future</code>提供了一个访问异步操作结果的机制，它和线程是一个级别的，属于低层次的对象。<code>std::promise</code>和<code>std::packaged_task</code>，它们内部都有future以便访问异步操作结果，<code>std::packaged_task</code>包装的是一个异步操作，而<code>std::promise</code>包装的是一个值，都是为了方便异步操作的返回值。</p>
<p><code>std::promise</code>:需要获取线程中的某个值<br><code>std::packaged_task</code>:需要获取一个异步操作的返回值</p>
<p>future被promise和packaged_task用来作为异步操作或者异步结果的连接通道，用<code>std::future</code>和<code>std::shared_future</code>来获取异步调用的结果。future是不可拷贝的，只能移动，shared_future是可以拷贝的，当需要将future放到容器中则需要用shared_future。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">#include &lt;random&gt;</span><br><span class="line"></span><br><span class="line">namespace parallel</span><br><span class="line">&#123;</span><br><span class="line">  template &lt;class InputIt, class T&gt;</span><br><span class="line">  InputIt find(InputIt first, InputIt last, const T&amp; value)</span><br><span class="line">  &#123;</span><br><span class="line">      /*</span><br><span class="line">      * 计算合适的线程数</span><br><span class="line">      * std::thread::hardware_concurrency()用于返回当前系统支持的并发数</span><br><span class="line">      */</span><br><span class="line">      auto count = std::distance(first, last);</span><br><span class="line">      auto avaThreadNums = std::thread::hardware_concurrency();</span><br><span class="line">      auto perThreadMinNums = 20;</span><br><span class="line">      auto maxThreadNums = ((count + (perThreadMinNums - 1)) &amp; (~(perThreadMinNums - 1))) / perThreadMinNums;</span><br><span class="line">      auto threadNums =</span><br><span class="line">          avaThreadNums == 0 ?</span><br><span class="line">          maxThreadNums :</span><br><span class="line">          std::min(static_cast&lt;int&gt;(maxThreadNums), static_cast&lt;int&gt;(avaThreadNums));</span><br><span class="line">      auto blockSize = count / threadNums;</span><br><span class="line"></span><br><span class="line">      /* 主线程创建std::promise实例，模板参数是返回值类型 */</span><br><span class="line">      std::promise&lt;InputIt&gt; result;</span><br><span class="line">      /* 因为不同线程会并发查找，当一个线程找到后其他线程就可以停止查找了，原子变量done用于标记是否找到 */</span><br><span class="line">      std::atomic&lt;bool&gt; done(false);</span><br><span class="line">      &#123;</span><br><span class="line">          std::vector&lt;std::thread&gt; threads;</span><br><span class="line">          auto front = first;</span><br><span class="line">          for (int i = 0; i &lt; threadNums; ++i)</span><br><span class="line">          &#123;</span><br><span class="line">              auto back = front;</span><br><span class="line">              if (i != threadNums - 1)</span><br><span class="line">                  std::advance(back, blockSize);</span><br><span class="line">              else</span><br><span class="line">                  back = last;</span><br><span class="line">              threads.emplace_back(</span><br><span class="line">                  [front, back, &amp;value, &amp;result, &amp;done]</span><br><span class="line">              &#123;</span><br><span class="line">                  /* 当一个线程找到后所有线程都会退出，通过done标记管理 */</span><br><span class="line">                  for (auto it = front; !done &amp;&amp; it != back; ++it)</span><br><span class="line">                  &#123;</span><br><span class="line">                      if (*it == value)</span><br><span class="line">                      &#123;</span><br><span class="line">                          done.store(true);</span><br><span class="line">                          /* 如果找到，记录找到的值 */</span><br><span class="line">                          result.set_value(it);</span><br><span class="line">                          return;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              );</span><br><span class="line">          &#125;</span><br><span class="line">          /* 回收线程资源 */</span><br><span class="line">          for (auto &amp;th : threads)</span><br><span class="line">              th.join();</span><br><span class="line">      &#125;</span><br><span class="line">      /* 通过std::promise::get_future获得std::future对象，然后调用get获取结果 */</span><br><span class="line">      return done ? result.get_future().get() : last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;int&gt; v(100000000);</span><br><span class="line">  int n = 0;</span><br><span class="line">  std::generate(v.begin(), v.end(), [&amp;n] &#123; return ++n; &#125;);</span><br><span class="line">  auto value = std::random_device()() % 65536;</span><br><span class="line">  auto it1 = parallel::find(v.begin(), v.end(), value);</span><br><span class="line">  auto it2 = std::find(v.begin(), v.end(), value);</span><br><span class="line">  assert(it1 == it2);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int func(int x) &#123; return x + 2; &#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	packaged_task&lt;int(int)&gt; tsk(func);</span><br><span class="line">	future&lt;int&gt; fut = tsk.get_future();</span><br><span class="line"></span><br><span class="line">	thread(move(tsk), 2).detach();</span><br><span class="line"></span><br><span class="line">	int value = fut.get();</span><br><span class="line">	cout &lt;&lt; &quot;The result is &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	vector&lt;shared_future&lt;int&gt;&gt; v;</span><br><span class="line">	auto f = async(launch::async, [](int a, int b)&#123;return a + b;&#125;, 2, 3);</span><br><span class="line">	v.push_back(f);</span><br><span class="line">	cout &lt;&lt; &quot;The shared_future result is &quot; &lt;&lt; v[0].get() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The result is 4</span><br><span class="line">The shared_future result is 5</span><br></pre></td></tr></table></figure>
<h2 id="线程异步操作函数async"><a href="#线程异步操作函数async" class="headerlink" title="线程异步操作函数async"></a>线程异步操作函数async</h2><p><code>std::async</code>比<code>std::promise</code>、<code>std::package_task</code>和<code>std::thread</code>更上层，它可以用来直接创建异步的task，异步任务返回的结果保存在future中，当需要获取线程执行的结果，可以通过future.get()来获取，如果不关注异步任务的结果，只是简单的等待任务执行完成，则调用future.wait()即可。</p>
<p><code>std::async</code>是更高层次的异步操作，使我们不关心线程创建的内部细节，就能方便的获取线程异步执行的结果，还可以指定线程创建策略，更多的时候应该使用 <code>std::async</code>来创建线程，成为异步操作的首选。</p>
<p><code>std::async</code>原型为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::async(std::launch::async | std::launch::deferred,f,args...)</span><br></pre></td></tr></table></figure>
<p>第一个参数为线程的创建策略，第二个为线程函数，其他的为线程函数的参数。</p>
<p>关于创建策略有两种：</p>
<ul>
<li><code>std::launch::async</code>：在调用async就开始创建线程；</li>
<li><code>std::launch::deferred</code>：延迟加载的方式创建线程，调用async的时候不创建线程，直到调用了future的get或者wait方法来创建线程。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;    </span><br><span class="line">#include &lt;iostream&gt;   </span><br><span class="line">#include &lt;mutex&gt;  </span><br><span class="line">#include &lt;future&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::future&lt;int&gt; f1 = std::async(std::launch::async, []()&#123; return 8; &#125;);</span><br><span class="line">    std::cout &lt;&lt; f1.get() &lt;&lt; std::endl; //output 8</span><br><span class="line"></span><br><span class="line">    std::future&lt;void&gt; f2 = std::async(std::launch::async, []()&#123; std::cout &lt;&lt; 8 &lt;&lt; std::endl; &#125;);</span><br><span class="line">    f2.wait(); //output 8</span><br><span class="line"></span><br><span class="line">    std::future&lt;int&gt; f3 = std::async(std::launch::async, []()</span><br><span class="line">    &#123; </span><br><span class="line">        std::this_thread::sleep_for(std::chrono::seconds(3));</span><br><span class="line">        return 8;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Wating...&quot; &lt;&lt; std::endl;</span><br><span class="line">    std::future_status status;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        status = f3.wait_for(std::chrono::seconds(1));</span><br><span class="line">        if (status == std::future_status::deferred)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;deferred.&quot; &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (status == std::future_status::timeout)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;timeout.&quot; &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;ready.&quot; &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (status != std::future_status::ready);</span><br><span class="line">    std::cout &lt;&lt; &quot;result:&quot; &lt;&lt; f3.get() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//执行结果：</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">Wating...</span><br><span class="line">timeout.</span><br><span class="line">timeout.</span><br><span class="line">ready.</span><br><span class="line">result:8</span><br></pre></td></tr></table></figure>
<ul>
<li>线程的创建和使用简单方便，可以通过多种方式创建，还可以根据需要获取线程的一些信息及休眠线程。</li>
<li>互斥量可以通过多种方式来保证线程安全，既可以用独占的互斥量保证线程安全，又可以通过递归的互斥量来保护共享资源以避免死锁，还可以设置获取互斥量的超时时间，避免一直阻塞等待。</li>
<li>条件变量提供了另外一种用于等待的同步机制，它能阻塞一个或多个线程，直到收到另外一个线程发出的通知或者超时，才会唤醒当前阻塞的线程。条件变量的使用需要配合互斥量。</li>
<li>原子变量可以更方便地实现线程保护。</li>
<li>call_once保证在多线程情况下函数只被调用一次，可以用在在某些只能初始化一次的场景中。</li>
<li>future、promise和std::package_task用于异步调用的包装和返回值。</li>
<li>async更方便地实现了异步调用，应该优先使用async取代线程的创建。</li>
</ul>
<h1 id="使用C-11中的便利工具"><a href="#使用C-11中的便利工具" class="headerlink" title="使用C++11中的便利工具"></a>使用C++11中的便利工具</h1><h2 id="处理日期和时间的chrono库"><a href="#处理日期和时间的chrono库" class="headerlink" title="处理日期和时间的chrono库"></a>处理日期和时间的chrono库</h2><p>chrono库主要包含了三种类型：时间间隔Duration、时钟Clocks和时间点Time point。</p>
<h3 id="记录时长的duration"><a href="#记录时长的duration" class="headerlink" title="记录时长的duration"></a>记录时长的duration</h3><p>duration表示一段时间间隔，用来记录时间长度，可以表示几秒钟、几分钟或者几个小时的时间间隔，duration的原型是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class Rep, class Period = std::ratio&lt;1&gt;&gt; class duration;</span><br></pre></td></tr></table></figure>
<p>第一个模板参数Rep是一个数值类型，表示时钟个数；第二个模板参数是一个默认模板参数std::ratio，它的原型是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;std::intmax_t Num, std::intmax_t Denom = 1&gt; class ratio;</span><br></pre></td></tr></table></figure>
<p>它表示每个时钟周期的秒数，其中第一个模板参数Num代表分子，Denom代表分母，分母默认为1，ratio代表的是一个分子除以分母的分数值，比如<code>ratio&lt;2&gt;</code>代表一个时钟周期是两秒，<code>ratio&lt;60&gt;</code>代表了一分钟，<code>ratio&lt;60*60&gt;</code>代表一个小时，<code>ratio&lt;60*60*24&gt;</code>代表一天。而<code>ratio&lt;1, 1000&gt;</code>代表的则是1/1000秒即一毫秒，<code>ratio&lt;1, 1000000&gt;</code>代表一微秒，<code>ratio&lt;1, 1000000000&gt;</code>代表一纳秒。标准库为了方便使用，就定义了一些常用的时间间隔，如时、分、秒、毫秒、微秒和纳秒，在chrono命名空间下，它们的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef duration &lt;Rep, ratio&lt;3600,1&gt;&gt; hours;</span><br><span class="line">typedef duration &lt;Rep, ratio&lt;60,1&gt;&gt; minutes;</span><br><span class="line">typedef duration &lt;Rep, ratio&lt;1,1&gt;&gt; seconds;</span><br><span class="line">typedef duration &lt;Rep, ratio&lt;1,1000&gt;&gt; milliseconds;</span><br><span class="line">typedef duration &lt;Rep, ratio&lt;1,1000000&gt;&gt; microseconds;</span><br><span class="line">typedef duration &lt;Rep, ratio&lt;1,1000000000&gt;&gt; nanoseconds;</span><br></pre></td></tr></table></figure>
<p>通过定义这些常用的时间间隔类型，我们能方便的使用它们，比如线程的休眠：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::this_thread::sleep_for(std::chrono::seconds(3)); //休眠三秒</span><br><span class="line">std::this_thread::sleep_for(std::chrono::milliseconds (100)); //休眠100毫秒</span><br></pre></td></tr></table></figure>
<p>chrono还提供了获取时间间隔的时钟周期个数的方法count()，它的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::chrono::milliseconds ms&#123;3&#125;; // 3 毫秒</span><br><span class="line">    // 6000 microseconds constructed from 3 milliseconds</span><br><span class="line">    std::chrono::microseconds us = 2*ms; //6000微秒</span><br><span class="line">    // 30Hz clock using fractional ticks</span><br><span class="line">    std::chrono::duration&lt;double, std::ratio&lt;1, 30&gt;&gt; hz30(3.5);</span><br><span class="line">    std::cout &lt;&lt;  &quot;3 ms duration has &quot; &lt;&lt; ms.count() &lt;&lt; &quot; ticks\n&quot;&lt;&lt;  &quot;6000 us duration has &quot; &lt;&lt; us.count() &lt;&lt; &quot; ticks\n&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 ms duration has 3 ticks</span><br><span class="line">6000 us duration has 6000 ticks</span><br></pre></td></tr></table></figure>
<p>时间间隔之间可以做运算，比如下面的例子中计算两端时间间隔的差值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::chrono::minutes t1( 10 );</span><br><span class="line">std::chrono::seconds t2( 60 );</span><br><span class="line">std::chrono::seconds t3 = t1 - t2;</span><br><span class="line">std::cout &lt;&lt; t3.count() &lt;&lt; &quot; second&quot; &lt;&lt; std::endl; // 540 second</span><br></pre></td></tr></table></figure>
<p>其中，t1 是代表 10 分钟、 t2 是代表 60 秒，t3 则是 t1 減去 t2，也就是 600 - 60 = 540 秒。通过t1-t2的count输出差值为540个时钟周期即540秒（因为每个时钟周期为一秒）。我们还可以通过duration_cast&lt;&gt;()来将当前的时钟周期转换为其它的时钟周期，比如我可以把秒的时钟周期转换为分钟的时钟周期，然后通过count来获取转换后的分钟时间间隔：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; chrono::duration_cast&lt;chrono::minutes&gt;( t3 ).count() &lt;&lt;” minutes”&lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>将会输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 minutes</span><br></pre></td></tr></table></figure>
<h3 id="Time-point"><a href="#Time-point" class="headerlink" title="Time point"></a>Time point</h3><p>time_point表示一个时间点，用来获取1970.1.1以来的秒数和当前的时间, 可以做一些时间的比较和算术运算，可以和ctime库结合起来显示时间。time_point必须要clock来计时，time_point有一个函数<code>time_since_epoch()</code>用来获得1970年1月1日到time_point时间经过的duration。下面的例子计算当前时间距离1970年1月一日有多少天：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;ratio&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">  using namespace std::chrono;</span><br><span class="line">  typedef duration&lt;int,std::ratio&lt;60*60*24&gt;&gt; days_type;</span><br><span class="line">  time_point&lt;system_clock,days_type&gt; today = time_point_cast&lt;days_type&gt;(system_clock::now());</span><br><span class="line">  std::cout &lt;&lt; today.time_since_epoch().count() &lt;&lt; &quot; days since epoch&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>time_point还支持一些算术元算，比如两个time_point的差值时钟周期数，还可以和duration相加减。下面的例子输出前一天和后一天的日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	using namespace std::chrono;</span><br><span class="line">	system_clock::time_point now = system_clock::now();</span><br><span class="line">	std::time_t last = system_clock::to_time_t(now - std::chrono::hours(24));</span><br><span class="line">	std::time_t next= system_clock::to_time_t(now - std::chrono::hours(24));</span><br><span class="line">	std::cout &lt;&lt; &quot;One day ago, the time was &quot;&lt;&lt; std::put_time(std::localtime(&amp;last), &quot;%F %T&quot;) &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">	std::cout &lt;&lt; &quot;Next day, the time was &quot;&lt;&lt; std::put_time(std::localtime(&amp;next), &quot;%F %T&quot;) &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">One day ago, the time was 2014-3-2622:38:27</span><br><span class="line">Next day, the time was 2014-3-2822:38:27</span><br></pre></td></tr></table></figure>
<h3 id="Clocks"><a href="#Clocks" class="headerlink" title="Clocks"></a>Clocks</h3><p>表示当前的系统时钟，内部有time_point, duration, Rep, Period等信息，它主要用来获取当前时间，以及实现time_t和time_point的相互转换。Clocks包含三种时钟：</p>
<ul>
<li>system_clock：从系统获取的时钟；</li>
<li>steady_clock：不能被修改的时钟；</li>
<li>high_resolution_clock：高精度时钟，实际上是system_clock或者steady_clock的别名。</li>
</ul>
<p>可以通过now()来获取当前时间点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	std::chrono::steady_clock::time_point t1 = std::chrono::system_clock::now();</span><br><span class="line">	std::cout &lt;&lt; &quot;Hello World\n&quot;;</span><br><span class="line">	std::chrono::steady_clock::time_point t2 = std::chrono:: system_clock::now();</span><br><span class="line">	std::cout &lt;&lt; (t2-t1).count()&lt;&lt;” tick count”&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">20801 tick count</span><br></pre></td></tr></table></figure>
<p>通过时钟获取两个时间点之相差多少个时钟周期，我们可以通过duration_cast将其转换为其它时钟周期的duration：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;( t2-t1 ).count() &lt;&lt;” microseconds”&lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20 microseconds</span><br></pre></td></tr></table></figure>
<p>system_clock的to_time_t方法可以将一个time_point转换为ctime：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::time_t now_c = std::chrono::system_clock::to_time_t(time_point);</span><br></pre></td></tr></table></figure>
<p>而from_time_t方法则是相反的，它将ctime转换为time_point。</p>
<p>steady_clock可以获取稳定可靠的时间间隔，后一次调用now()的值和前一次的差值是不因为修改了系统时间而改变，它保证了稳定的时间间隔。它的用法和system用法一样。</p>
<p>system_clock和std::put_time配合起来使用可以格式化日期的输出，std::put_time能将日期格式化输出。下面的例子是将当前时间格式化输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	auto t = chrono::system_clock::to_time_t(std::chrono::system_clock::now());</span><br><span class="line">	cout&lt;&lt; std::put_time(std::localtime(&amp;t), &quot;%Y-%m-%d %X&quot;)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt; std::put_time(std::localtime(&amp;t), &quot;%Y-%m-%d %H.%M.%S&quot;)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2014-3-27 22:11:49</span><br><span class="line">2014-3-27 22.11.49</span><br></pre></td></tr></table></figure>
<h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p>可以利用high_resolution_clock来实现一个类似于boost.timer的定时器，这样的timer在测试性能时会经常用到，经常用它来测试函数耗时，它的基本用法是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;hello word&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">         timer t; //开始计时</span><br><span class="line">         fun()</span><br><span class="line">         cout&lt;&lt;t.elapsed()&lt;&lt;endl; //打印fun函数耗时多少毫秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c++11中增加了chrono库，现在用来实现一个定时器是很简单的事情，还可以移除对boost的依赖。它的实现比较简单，下面是具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;chrono&gt;</span><br><span class="line">usingnamespace std;</span><br><span class="line">usingnamespace std::chrono;</span><br><span class="line"></span><br><span class="line">classTimer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Timer() : m_begin(high_resolution_clock::now()) &#123;&#125;</span><br><span class="line">    void reset() &#123; m_begin = high_resolution_clock::now(); &#125;</span><br><span class="line"></span><br><span class="line">//默认输出秒</span><br><span class="line">　　double elapsed() const</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　return duration_cast&lt;duration&lt;double&gt;&gt;(high_resolution_clock::now() - m_begin).count();</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">//默认输出毫秒</span><br><span class="line">    int64_t elapsed() const</span><br><span class="line">    &#123;</span><br><span class="line">      //return duration_cast&lt;chrono::milliseconds&gt;(high_resolution_clock::now() - m_begin).count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //微秒</span><br><span class="line">    int64_t elapsed_micro() const</span><br><span class="line">    &#123;</span><br><span class="line">        return duration_cast&lt;chrono::microseconds&gt;(high_resolution_clock::now() - m_begin).count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //纳秒</span><br><span class="line">    int64_t elapsed_nano() const</span><br><span class="line">    &#123;</span><br><span class="line">        return duration_cast&lt;chrono::nanoseconds&gt;(high_resolution_clock::now() - m_begin).count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //秒</span><br><span class="line">    int64_t elapsed_seconds() const</span><br><span class="line">    &#123;</span><br><span class="line">        return duration_cast&lt;chrono::seconds&gt;(high_resolution_clock::now() - m_begin).count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //分</span><br><span class="line">    int64_t elapsed_minutes() const</span><br><span class="line">    &#123;</span><br><span class="line">        return duration_cast&lt;chrono::minutes&gt;(high_resolution_clock::now() - m_begin).count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //时</span><br><span class="line">    int64_t elapsed_hours() const</span><br><span class="line">    &#123;</span><br><span class="line">        return duration_cast&lt;chrono::hours&gt;(high_resolution_clock::now() - m_begin).count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    time_point&lt;high_resolution_clock&gt; m_begin;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;”hello word”&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	timer t; //开始计时</span><br><span class="line">	fun()</span><br><span class="line">	cout&lt;&lt;t.elapsed()&lt;&lt;endl; //打印fun函数耗时多少毫秒</span><br><span class="line">	cout&lt;&lt;t.elapsed_micro ()&lt;&lt;endl; //打印微秒</span><br><span class="line">	cout&lt;&lt;t.elapsed_nano ()&lt;&lt;endl; //打印纳秒</span><br><span class="line">	cout&lt;&lt;t.elapsed_seconds()&lt;&lt;endl; //打印秒</span><br><span class="line">	cout&lt;&lt;t.elapsed_minutes()&lt;&lt;endl; //打印分钟</span><br><span class="line">	cout&lt;&lt;t.elapsed_hours()&lt;&lt;endl; //打印小时</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数值类型和字符串的相互转换"><a href="#数值类型和字符串的相互转换" class="headerlink" title="数值类型和字符串的相互转换"></a>数值类型和字符串的相互转换</h2><p>C++11提供了to_string方法，可以方便地将各种数值类型转换为字符串类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::string to_string(int value);</span><br><span class="line">std::string to_string(long int value);</span><br><span class="line">std::string to_string(long long int value);</span><br><span class="line">std::string to_string(unsigned int value);</span><br><span class="line">std::string to_string(unsigned long long int value);</span><br><span class="line">std::string to_string(float value);</span><br><span class="line">std::string to_string(double value);</span><br><span class="line"></span><br><span class="line">std::wstring to_wstring(int value);</span><br><span class="line">std::wstring to_wstring(long int value);</span><br><span class="line">std::wstring to_wstring(long long int value);</span><br><span class="line">std::wstring to_wstring(unsigned int value);</span><br><span class="line">std::wstring to_wstring(unsigned long int value);</span><br><span class="line">std::wstring to_wstring(unsigned long long int value);</span><br><span class="line">std::wstring to_wstring(float value);</span><br><span class="line">std::wstring to_wstring(double value);</span><br><span class="line">std::wstring to_wstring(long double value);</span><br></pre></td></tr></table></figure>
<p>还提供了stoxxx方法，将string转换为各种类型的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::string str = &quot;1000&quot;;</span><br><span class="line">int val = std::stoi(str);</span><br><span class="line">long val = std::stol(str);</span><br><span class="line">float val = std::stof(str);</span><br></pre></td></tr></table></figure>
<p>c++11还提供了字符串(<code>char*</code>)转换为整数和浮点类型的方法：</p>
<ul>
<li>atoi: 将字符串转换为 int</li>
<li>atol: 将字符串转换为long</li>
<li>atoll:将字符串转换为 long long</li>
<li>atof: 将字符串转换为浮点数</li>
</ul>
<h1 id="宽窄字符转换"><a href="#宽窄字符转换" class="headerlink" title="宽窄字符转换"></a>宽窄字符转换</h1><p>c++11增加了unicode字面量的支持，可以通过<strong><code>L</code></strong>来定义宽字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::wstring wide_str = L&quot;中国人&quot;; //定义了宽字符字符串 </span><br></pre></td></tr></table></figure>
<p>将宽字符转换为窄字符需要用到<code>condecvt</code>库中的<code>std::wstring_convert</code>，它需要如下几个转换器：</p>
<ul>
<li><code>std::codecvt_utf8</code>，封装了UTF-8与UCS2及UTF-8与UCS4的编码转换；</li>
<li><code>std::codecvt_utf16</code>，封装了UTF-16与UCS2及UTF-16与UCS4的编码转换；</li>
<li><code>std::codecvt_utf8_utf16</code>，封装了UTF-8与UTF-16的编码转换；</li>
</ul>
<p><code>std::wstring_convert</code>使<code>std::string</code>和<code>std::wstring</code>之间的相互转换变得很方便，如代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::wstring wide_str = L&quot;中国人&quot;;</span><br><span class="line">std::wstring_convert&lt;std::condecvt&lt;wchar_t, char, std::mbstate_t&gt;&gt; converter(new std::codecvt&lt;wchar_t, char, std::mbstate_t&gt;(&quot;CHS&quot;);</span><br><span class="line"></span><br><span class="line">std::string narrow_str = converter.to_bytes(wide_str);</span><br><span class="line">std::wstring wstr = converter.from_bytes(narrow_str);</span><br><span class="line">std::cout &lt;&lt; narrow_str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">wcout.imbue(std::locale(&quot;chs&quot;));</span><br><span class="line">std::wcout &lt;&lt; wstr &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; wstr.size() &lt;&lt; &quot; &quot; &lt;&lt; wstr.length() &lt;&lt; endl;</span><br><span class="line">std::cout &lt;&lt; narrow_str.size() &lt;&lt; &quot; &quot; &lt;&lt; narrow_str.length() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中国人</span><br><span class="line">中国人</span><br></pre></td></tr></table></figure>
<h1 id="C-11的其他特性"><a href="#C-11的其他特性" class="headerlink" title="C++11的其他特性"></a>C++11的其他特性</h1><h2 id="委托构造函数和继承构造函数"><a href="#委托构造函数和继承构造函数" class="headerlink" title="委托构造函数和继承构造函数"></a>委托构造函数和继承构造函数</h2><p>委托构造函数允许在同一个类中一个构造函数可以调用另一个构造函数，从而可以在初始化时简化变量的初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class class_c &#123;</span><br><span class="line">public:</span><br><span class="line">	int max;</span><br><span class="line">	int min;</span><br><span class="line">	int middle;</span><br><span class="line"></span><br><span class="line">	class_c() &#123;&#125;</span><br><span class="line">	class_c(int my_max) &#123;</span><br><span class="line">		max = my_max &gt; 0 ? my_max : 10;</span><br><span class="line">	&#125;</span><br><span class="line">	class_c(int my_max, int my_min) &#123;</span><br><span class="line">		max = my_max &gt; 0 ? my_max : 10;</span><br><span class="line">		min = my_min &gt; 0 &amp;&amp; my_min &lt; my_max ? my_min : 1;</span><br><span class="line">	&#125;</span><br><span class="line">	class_c(int my_max, int my_min, int my_middle) &#123;</span><br><span class="line">		max = my_max &gt; 0 ? my_max : 10;</span><br><span class="line">		min = my_min &gt; 0 &amp;&amp; my_min &lt; my_max ? my_min : 1;</span><br><span class="line">		middle = my_middle &lt; max &amp;&amp; my_middle &gt; min ? my_middle : 5;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过委托构造函数简化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class class_c &#123;</span><br><span class="line">public:</span><br><span class="line">	int max;</span><br><span class="line">	int min;</span><br><span class="line">	int middle;</span><br><span class="line"></span><br><span class="line">	class_c() &#123;&#125;</span><br><span class="line">	class_c(int my_max) &#123;</span><br><span class="line">		max = my_max &gt; 0 ? my_max : 10;</span><br><span class="line">	&#125;</span><br><span class="line">	class_c(int my_max, int my_min) : class_c(my_max) &#123;</span><br><span class="line">		min = my_min &gt; 0 &amp;&amp; my_min &lt; my_max ? my_min : 1;</span><br><span class="line">	&#125;</span><br><span class="line">	class_c(int my_max, int my_min, int my_middle) : class_c(my_max, my_min) &#123;</span><br><span class="line">		middle = my_middle &lt; max &amp;&amp; my_middle &gt; min ? my_middle : 5;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意，<strong>如果使用了委托构造函数，则不能使用类成员初始化</strong>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    A(int a):a_(a)&#123;&#125;; //单独使用类成员初始化，可以</span><br><span class="line">    A(int a, int b):A(a), b_(b)&#123;&#125;; //同时使用了委托构造函数和类成员初始化，错误！</span><br><span class="line">private:</span><br><span class="line">    int a_;</span><br><span class="line">    int b_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个派生类继承自一个基类，如果其构造函数想要使用和基类相同的构造函数，如果构造函数有多个，则在派生类中要写多个构造函数，每个都用基类构造， 在c++11中，可以使用继承构造函数来简化这一操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">    Base(int a);</span><br><span class="line">    Base(int a, int b);</span><br><span class="line">    Base(int a, int b, double c);</span><br><span class="line">    ~Base();</span><br><span class="line">&#125;;</span><br><span class="line">struct Derived : Base &#123;</span><br><span class="line">	using Base::Base; //声明使用基类构造函数</span><br><span class="line">&#125;；</span><br><span class="line">int main() &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原始的字面量"><a href="#原始的字面量" class="headerlink" title="原始的字面量"></a>原始的字面量</h2><p>原始字面量可以直接表示字符串的实际含义，因为有些字符串带一些特殊字符，比如在转义字符串中，我们往往要专门处理。如windows路径名：<code>D:\A\B\test.txt</code><br>在c++11中，使用<code>R&quot;xx(string)xx&quot;</code>来获得括号中的string部分的字符串形式，不需要使用转义字符等附加字符，比如： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string a = R&quot;(D:\A\B\test.txt)&quot; </span><br></pre></td></tr></table></figure>
<p>注意，<code>R&quot;xxx(raw string)xxx&quot;</code>，其中原始字符串必须用括号()括起来，括号前后可以加其他字符串，所加的字符串是会被忽略的，而且加的字符串必须在括号两边同时出现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = R&quot;test(D:A\B\test.test)test&quot;;</span><br><span class="line">// 实际上是“D:A\B\test.test”</span><br></pre></td></tr></table></figure>
<h2 id="final和override标识符"><a href="#final和override标识符" class="headerlink" title="final和override标识符"></a>final和override标识符</h2><p>c++11中增加了final关键字来限制某个类不能被继承（类似java）或者某个虚函数不能别重写（类似c#中的sealed）。如果修饰函数，final只能修饰虚函数，并且要放到类或者函数的后面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    virtual void foo() final; // foo 声明为final的虚函数，不能被重写</span><br><span class="line">    void test() final; // 错误，final只能修饰虚函数</span><br><span class="line">&#125;;</span><br><span class="line">struct B final : A&#123; //B声明为final，表示不能被继承</span><br><span class="line">	void foo(); // 错误，foo不可被重写</span><br><span class="line">&#125;;</span><br><span class="line">struct C : B&#123; //错误，B不能被继承</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>c++11中还增加了override关键字确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，还可以防止因疏忽把原来想重写基类的虚函数声明为重载。override关键字要放到方法的后面</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    virtual void func();</span><br><span class="line">&#125;;</span><br><span class="line">struct D:A&#123;</span><br><span class="line">    void func() override&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><h3 id="内存对齐介绍"><a href="#内存对齐介绍" class="headerlink" title="内存对齐介绍"></a>内存对齐介绍</h3><p>cpu访问内存的时候，起始地址并不是随意的，例如有些cpu访问内存起始地址要是4的倍数，因为内存总线的宽度为32位，每次读写操作都4个字节4个字节进行。如果某个数据在内存中不是字节对齐的，则会在访问的时候比较麻烦，比如4字节的int32类型，没有4字节对齐，则需要访问两次内存才能读到完整的数据。因此，内存对齐可以提高程序的效率。 </p>
<p>因为有了内存对齐，所以数据在内存中的存放就不是紧挨着的，而是会出现一些空隙。C++数据内存对齐的含义是，数据在内存中的起始地址是数据size的倍数。c++结构体内存对齐的原则是：结构体内的每个变量都自身对齐，按照字节对齐，中间加入padding，；整个结构体按照结构体内的最大size变量的对齐方式对齐，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char c;</span><br><span class="line">    double d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体按照最大size的变量对齐，即按照double的8字节对齐。</p>
<h3 id="堆内存的内存对齐"><a href="#堆内存的内存对齐" class="headerlink" title="堆内存的内存对齐"></a>堆内存的内存对齐</h3><p>malloc一般使用当前平台默认的最大内存对齐数对齐内存。当我们需要分配一块特定内存对齐的内存块时，使用<code>memalign</code>等函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;assert.h&gt;</span><br><span class="line"></span><br><span class="line">inline void* aligned_malloc(size_t size, size_t alignment) &#123;</span><br><span class="line">	// 检查alignment是否是2^N</span><br><span class="line">	assert(!alignment &amp; (alignment - 1));</span><br><span class="line">	// 计算最大offset</span><br><span class="line">	size_t offset = sizeof(void*) + (-- alignment);</span><br><span class="line"></span><br><span class="line">	// 分配一块带有offset的内存</span><br><span class="line">	char* p = static_cast&lt;char*&gt;(malloc(offset + size));</span><br><span class="line">	if (!p) return nullptr;</span><br><span class="line"></span><br><span class="line">	// 通过“&amp;(~alignment)”把多计算的offset减掉</span><br><span class="line">	void* r = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;size_t&gt;(p + offset) &amp; (~alignment));</span><br><span class="line"></span><br><span class="line">	// 将r作为一个指向void*的指针，在r当前地址前面放入原始地址</span><br><span class="line">	static_cast&lt;void**&gt;(r)[-1] = p;</span><br><span class="line">	return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用alignas指定内存对齐大小"><a href="#利用alignas指定内存对齐大小" class="headerlink" title="利用alignas指定内存对齐大小"></a>利用alignas指定内存对齐大小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alignas(32) long long a = 0; </span><br></pre></td></tr></table></figure>
<p>指定a为32字节对齐。 alignas可以将内存对齐改大，而不能改小，因此，可以有 alignas(32) long long a; 而不能有alignas(1) long long a;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define XX 1</span><br><span class="line">struct alignas(XX) MyStruct&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>指定为1字节对齐，因为MyStruct内部没有数据，自然为1字节对齐。如果内部含有int类型数据，则alignas只能将对齐方式改大不能改小，故不能为1字节对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alignas(int) char c;</span><br></pre></td></tr></table></figure>
<p>这个char就按照int的方式对齐了。</p>
<h3 id="利用alignof和std-alignment-of获取内存对齐大小"><a href="#利用alignof和std-alignment-of获取内存对齐大小" class="headerlink" title="利用alignof和std::alignment_of获取内存对齐大小"></a>利用alignof和std::alignment_of获取内存对齐大小</h3><p>alignof用来获取内存对齐大小，只能返回size_t。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyStruct xx;</span><br><span class="line">cout &lt;&lt; alignof(xx) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; alignof(MyStruct) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>alignment_of继承自<code>std::integral_constant</code>，因此拥有value_type、type和value成员</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; std::alignment_of&lt;MyStruct&gt;::value &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h3 id="内存对齐的类型std-aligned-storage"><a href="#内存对齐的类型std-aligned-storage" class="headerlink" title="内存对齐的类型std::aligned_storage"></a>内存对齐的类型<code>std::aligned_storage</code></h3><p>aligned_storage可以看成一个内存对齐的缓冲区，原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;std::size_t Len, std::size_t Align = /*default-alignment*/&gt;</span><br><span class="line">struct aligned_storage;</span><br></pre></td></tr></table></figure>
<p>Len代表所存储类型的size，Align代表所存储类型的对齐大小，通过<code>sizeof(T)</code>获取T的size，通过<code>alignof(T)</code>获取T内存对齐的大小，所以<code>std::aligned_storage</code>的声明是这样的：<code>std::aligned_storage&lt;sizeof(T), align(T)&gt;</code>或者<code>std::aligned_storage&lt;sizeof(T), std::alignment_of(T)::value&gt;</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct A&#123;</span><br><span class="line">    int a;</span><br><span class="line">    double c;</span><br><span class="line">    A(int aa, double cc):a(aa), c(cc)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">typedef std::aligned_storage&lt;sizeof&lt;A&gt;, alignof(A)&gt;::type Aligned_A;</span><br><span class="line">int main()&#123;</span><br><span class="line">    Aligned_A a, b; //声明一块内存对齐的内存</span><br><span class="line">    new (&amp;a)A(10, 20.0); //原地构造函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要使用<code>std::aligned_storage</code>呢？很多时候需要分配一块单纯的内存块，之后再使用placement new在这块内存上构建对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char xx[32];</span><br><span class="line">::new xx MyStruct;</span><br></pre></td></tr></table></figure>
<p>但是char[32]是1字节对齐的，xx很有可能不在指定的对齐位置上，这是调用placement new构造内存块引起效率问题，所以应该使用<code>std::aligned_storage</code>构造内存块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef std::aligned_storage&lt;sizeof&lt;A&gt;, alignof(A)&gt;::type Aligned_A;</span><br><span class="line">::new (&amp;Aligned_A) A;</span><br></pre></td></tr></table></figure>
<h3 id="std-max-align-t和std-align操作符"><a href="#std-max-align-t和std-align操作符" class="headerlink" title="std::max_align_t和std::align操作符"></a><code>std::max_align_t</code>和<code>std::align</code>操作符</h3><p><code>std::max_align_t</code>返回当前平台的最大默认内存对齐类型。通过下面这个方式获得当前平台的默认最大内存对齐数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; alignof(std::max_align_t) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p><code>std::align</code>用来在一大块内存中获取一个符合指定内存要求的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char buffer[] = &quot;---------------&quot;;</span><br><span class="line">void* pt = buffer;</span><br><span class="line">std::size_t space = sizeof(buffer) - 1;</span><br><span class="line">std::align(alignof(int), sizeof(char), pt, space);</span><br></pre></td></tr></table></figure>
<p>在buffer这个大内存中，指定内存对齐为<code>align(int)</code>，找一块<code>sizeof(char)</code>大小的内存，并在找到这块内存后把地址放入pt中。</p>
<h2 id="新增的便利算法"><a href="#新增的便利算法" class="headerlink" title="新增的便利算法"></a>新增的便利算法</h2><h3 id="all-of、any-of、none-of"><a href="#all-of、any-of、none-of" class="headerlink" title="all_of、any_of、none_of"></a><code>all_of</code>、<code>any_of</code>、<code>none_of</code></h3><p>算法库新增了三个用于判断的算法all_of、any_of和none_of：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class InputIt, class UnaryPredicate &gt;</span><br><span class="line">bool all_of( InputIt first, InputIt last, UnaryPredicate p );</span><br><span class="line"></span><br><span class="line">template&lt; class InputIt, class UnaryPredicate &gt;</span><br><span class="line">bool any_of( InputIt first, InputIt last, UnaryPredicate p );</span><br><span class="line"></span><br><span class="line">template&lt; class InputIt, class UnaryPredicate &gt;</span><br><span class="line">bool none_of( InputIt first, InputIt last, UnaryPredicate p );</span><br></pre></td></tr></table></figure>
<ul>
<li>all_of:检查区间[first, last)中是否所有的元素都满足一元判断式p，所有的元素都满足条件返回true，否则返回false。</li>
<li>any_of：检查区间[first, last)中是否至少有一个元素都满足一元判断式p，只要有一个元素满足条件就返回true，否则返回true。</li>
<li>none_of：检查区间[first, last)中是否所有的元素都不满足一元判断式p，所有的元素都不满足条件返回true，否则返回false。</li>
</ul>
<p>下面是这几个算法的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; v = &#123; 1, 3, 5, 7, 9 &#125;;</span><br><span class="line">	auto isEven = [](int i)&#123;return i % 2 != 0;&#125;;</span><br><span class="line">	bool isallOdd = std::all_of(v.begin(), v.end(), isEven);</span><br><span class="line">	if (isallOdd)</span><br><span class="line">		cout &lt;&lt; &quot;all is odd&quot; &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	bool isNoneEven = std::none_of(v.begin(), v.end(), isEven);</span><br><span class="line">	if (isNoneEven)</span><br><span class="line">		cout &lt;&lt; &quot;none is even&quot; &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	vector&lt;int&gt; v1 = &#123; 1, 3, 5, 7, 8, 9 &#125;;</span><br><span class="line">	bool anyof = std::any_of(v1.begin(), v1.end(), isEven);</span><br><span class="line">	if (anyof)</span><br><span class="line">		cout &lt;&lt; &quot;at least one is even&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">all is odd</span><br><span class="line">none is odd</span><br><span class="line">at least one is even</span><br></pre></td></tr></table></figure>
<h3 id="find-if-not"><a href="#find-if-not" class="headerlink" title="find_if_not"></a>find_if_not</h3><p>算法库的查找算法新增了一个find_if_not，它的含义和find_if是相反的，即查找不符合某个条件的元素，find_if也可以实现find_if_not的功能，只需要将判断式改为否定的判断式即可，现在新增了find_if_not之后，就不需要再写否定的判断式了，可读性也变得更好。下面是它的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; v = &#123; 1, 3, 5, 7, 9, 4 &#125;;</span><br><span class="line">	auto isEven = [](int i)&#123;return i % 2 == 0;&#125;;</span><br><span class="line">	auto firstEven = std::find_if(v.begin(), v.end(), isEven);</span><br><span class="line">	if (firstEven!=v.end())</span><br><span class="line">		cout &lt;&lt; &quot;the first even is &quot; &lt;&lt;* firstEven &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	//用find_if来查找奇数则需要重新写一个否定含义的判断式</span><br><span class="line">	auto isNotEven = [](int i)&#123;return i % 2 != 0;&#125;;</span><br><span class="line">	auto firstOdd = std::find_if(v.begin(), v.end(),isNotEven);</span><br><span class="line">	</span><br><span class="line">	if (firstOdd!=v.end())</span><br><span class="line">		cout &lt;&lt; &quot;the first odd is &quot; &lt;&lt;* firstOdd &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	//用find_if_not来查找奇数则无需新定义判断式</span><br><span class="line">	auto odd = std::find_if_not(v.begin(), v.end(), isEven);</span><br><span class="line">	if (odd!=v.end())</span><br><span class="line">		cout &lt;&lt; &quot;the first odd is &quot; &lt;&lt;* odd &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">the first even is 4</span><br><span class="line">the first odd is 1</span><br><span class="line">the first odd is 1</span><br></pre></td></tr></table></figure>
<p>可以看到使用find_if_not不需要再定义新的否定含义的判断式了，更简便了。</p>
<h3 id="copy-if"><a href="#copy-if" class="headerlink" title="copy_if"></a>copy_if</h3><p>算法库还增加了一个copy_if算法，它相比原来的copy算法多了一个判断式，用起来更方便了，下面是它的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; v = &#123; 1, 3, 5, 7, 9, 4 &#125;;</span><br><span class="line">	std::vector&lt;int&gt; v1(v.size());</span><br><span class="line">	//根据条件拷贝</span><br><span class="line">	auto it = std::copy_if(v.begin(), v.end(), v1.begin(), [](int i)&#123;return i%2!=0;&#125;);</span><br><span class="line">	//缩减vector到合适大小</span><br><span class="line">	v1.resize(std::distance(v1.begin(),it));</span><br><span class="line">	for(int i : v1)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>算法库新增了iota用来方便的生成有序序列，比如我们需要一个定长数组，这个数组中的元素都是在某一个数值的基础之上递增的，那么用iota可以很方便的生成这个数组了。下面是它的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;array&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;int&gt; v(4) ;</span><br><span class="line">//循环遍历赋值来初始化数组</span><br><span class="line">//for(int i=1; i&lt;=4; i++)</span><br><span class="line">//&#123;</span><br><span class="line">//    v.push_back(i);</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//直接通过iota初始化数组，更简洁</span><br><span class="line">    std::iota(v.begin(), v.end(), 1);</span><br><span class="line">    for(auto n: v) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    std::array&lt;int, 4&gt; array;</span><br><span class="line">    std::iota(array.begin(), array.end(), 1);</span><br><span class="line">    for(auto n: array) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure>
<p>可以看到使用iota比遍历赋值来初始化数组更简洁，需要注意的是iota初始化的序列需要指定大小，如果上面的代码中：vector<int> v(4) ;没有指定初始化大小为4的话，则输出为空。</p>
<h3 id="minmax-element"><a href="#minmax-element" class="headerlink" title="minmax_element"></a>minmax_element</h3><p>算法库还新增了一个同时获取最大值和最小值的算法minmax_element，这样我们如果想获取最大值和最小值的时候就不用分别调用max_element和max_element算法了，用起来会更方便，minmax_element会将最小值和最大值的迭代器放到一个pair中返回，下面是它的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // your code goes here</span><br><span class="line">    vector&lt;int&gt; v = &#123; 1, 2, 5, 7, 9, 4 &#125;;</span><br><span class="line">    auto result = minmax_element(v.begin(), v.end());</span><br><span class="line">   </span><br><span class="line">    cout&lt;&lt;*result.first&lt;&lt;&quot; &quot;&lt;&lt;*result.second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 9</span><br></pre></td></tr></table></figure>
<h3 id="is-sorted和is-sorted-until"><a href="#is-sorted和is-sorted-until" class="headerlink" title="is_sorted和is_sorted_until"></a>is_sorted和is_sorted_until</h3><p>算法库新增了is_sorted和is_sorted_until算法，is_sort用来判断某个序列是否是排好序的，is_sort_until则用来返回序列中前面已经排好序的部分序列。下面是它们的基本用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; v = &#123; 1, 2, 5, 7, 9, 4 &#125;;</span><br><span class="line">    auto pos = is_sorted_until(v.begin(), v.end());</span><br><span class="line">   </span><br><span class="line">    for(auto it=v.begin(); it!=pos; ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    bool is_sort = is_sorted(v.begin(), v.end());</span><br><span class="line">    cout&lt;&lt; is_sort&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 5 7 9</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>总结：这些新增的算法让我们用起来更加简便，也增强了代码的可读性。</p>
<h1 id="C-11改进我们的模式"><a href="#C-11改进我们的模式" class="headerlink" title="C++11改进我们的模式"></a>C++11改进我们的模式</h1><h2 id="改进单例模式"><a href="#改进单例模式" class="headerlink" title="改进单例模式"></a>改进单例模式</h2><p>单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点。在c++11之前，我们写单例模式的时候会遇到一个问题，就是多种类型的单例可能需要创建多个类型的单例，主要是因为创建单例对象的构造函数无法统一，各个类型的形参不尽相同，导致我们不容易做一个所有类型都通用的单例。现在c+11帮助我们解决了这个问题，解决这个问题靠的是c++11的可变模板参数。</p>
<p>将原有的多个构造函数合并：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T0, typename T1, typename T2, typename T3, typename T4, typename T5&gt;</span><br><span class="line">static T* Instance(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) &#123;</span><br><span class="line">	if (m_pInstance == nullptr)</span><br><span class="line">		m_pInstance = new T(arg0, arg1, arg2, arg3, arg4, arg5);</span><br><span class="line">	return m_pInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">　　static T* Instance(Args&amp;&amp;... args)</span><br><span class="line">　　&#123;</span><br><span class="line">		if(m_pInstance==nullptr)</span><br><span class="line">			m_pInstance = new T(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">		return m_pInstance;</span><br><span class="line">	&#125;</span><br><span class="line">　　static T* GetInstance() &#123;</span><br><span class="line">　　　　if (m_pInstance == nullptr)</span><br><span class="line">　　　　　　throw std::logic_error(&quot;the instance is not init, please initialize the instance first&quot;);</span><br><span class="line">　　　　return m_pInstance;</span><br><span class="line">　　&#125;</span><br><span class="line">	static void DestroyInstance()</span><br><span class="line">	&#123;</span><br><span class="line">		delete m_pInstance;</span><br><span class="line">		m_pInstance = nullptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">		Singleton(void);</span><br><span class="line">		virtual ~Singleton(void);</span><br><span class="line">		Singleton(const Singleton&amp;);</span><br><span class="line">		Singleton&amp; operator = (const Singleton&amp;);</span><br><span class="line">private:</span><br><span class="line">	static T* m_pInstance;</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line">template &lt;class T&gt; T*  Singleton&lt;T&gt;::m_pInstance = nullptr;</span><br></pre></td></tr></table></figure>
<p>/<strong><strong><em>*</em></strong></strong>更新说明<strong><strong><strong><em>**</em></strong></strong></strong>/</p>
<p>由于原来的接口中，单例对象的初始化和取值都是一个接口，可能会遭到误用，更新之后，初始化和取值分为两个接口，单例的用法为：先初始化，后面取值，如果中途销毁单例的话，需要重新取值。如果没有初始化就取值则会抛出一个异常。</p>
<p>增加Multiton的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt; typename T, typename K = string&gt;</span><br><span class="line">class Multiton</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">	static std::shared_ptr&lt;T&gt; Instance(const K&amp; key, Args&amp;&amp;... args)</span><br><span class="line">	&#123;</span><br><span class="line">		return GetInstance(key, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">	static std::shared_ptr&lt;T&gt; Instance(K&amp;&amp; key, Args&amp;&amp;... args)</span><br><span class="line">	&#123;</span><br><span class="line">		return GetInstance(key, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	template&lt;typename Key, typename... Args&gt;</span><br><span class="line">	static std::shared_ptr&lt;T&gt; GetInstance(Key&amp;&amp; key, Args&amp;&amp;...args)</span><br><span class="line">	&#123;</span><br><span class="line">		std::shared_ptr&lt;T&gt; instance = nullptr;</span><br><span class="line">		auto it = m_map.find(key);</span><br><span class="line">		if (it == m_map.end())</span><br><span class="line">		&#123;</span><br><span class="line">			instance = std::make_shared&lt;T&gt;(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">			m_map.emplace(key, instance);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			instance = it-&gt;second;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	Multiton(void);</span><br><span class="line">	virtual ~Multiton(void);</span><br><span class="line">	Multiton(const Multiton&amp;);</span><br><span class="line">	Multiton&amp; operator = (const Multiton&amp;);</span><br><span class="line">private:</span><br><span class="line">	static map&lt;K, std::shared_ptr&lt;T&gt;&gt; m_map;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename T, typename K&gt;</span><br><span class="line">map&lt;K, std::shared_ptr&lt;T&gt;&gt; Multiton&lt;T, K&gt;::m_map;</span><br></pre></td></tr></table></figure>
<h2 id="改进观察者模式"><a href="#改进观察者模式" class="headerlink" title="改进观察者模式"></a>改进观察者模式</h2><p>观察者模式定义对象间一种一对多关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。和单例模式面临的是同样的问题，主题更新的接口难以统一，很难做出一个通用的观察者模式，还是用到可变模板参数解决这个问题，其次还用到了右值引用，避免多余的内存移动。c++11版本的观察者模式支持注册的观察者为函数、函数对象和lamda表达式，也避免了虚函数调用，更简洁更通用。</p>
<p>主要改进的地方有两个：通过被通知接口参数化和<code>std::function</code>来代替继承，通过可变参数模板和完美转发来消除接口变化产生的影响。直接看代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">class NonCopyable &#123;</span><br><span class="line">protected:</span><br><span class="line">	NonCopyable() = default;</span><br><span class="line">	~NonCopyable() = default;</span><br><span class="line">	NonCopyable(const NonCopyable&amp;) = delete;</span><br><span class="line">	NonCopyable&amp; operator = (const NonCopyable&amp;) = delete;</span><br><span class="line">	// 禁用复制构造和赋值构造</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">template&lt;typename Func&gt;</span><br><span class="line">class Events : NonCopyable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Events() &#123;&#125;</span><br><span class="line">	~Events()&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	int Connect(Func&amp;&amp; f) &#123;</span><br><span class="line">		return Assgin(std::forward&lt;Func&gt;(f));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int Connect(const Func&amp; f) &#123;</span><br><span class="line">		return Assgin(f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void Disconnect(int key) &#123;</span><br><span class="line">		m_connections.erase(key);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">	void Notify(Args&amp;&amp;... args) &#123;</span><br><span class="line">		for (auto&amp; it : m_connections) &#123;</span><br><span class="line">			it.second(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int operator += (Func&amp;&amp; f) &#123;</span><br><span class="line">		return Connect(std::forward&lt;Func&gt;(f));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int operator += (Func&amp; f) &#123;</span><br><span class="line">		return Connect(f);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">	void operator()(Args&amp;&amp;... args) &#123;</span><br><span class="line">		Notify(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Events&amp; operator -= (int key) &#123;</span><br><span class="line">		Disconnect(key);</span><br><span class="line">		return *this;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void Clear() &#123;</span><br><span class="line">		m_connections.clear();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">	template&lt;typename F&gt;</span><br><span class="line">	int Assgin(F&amp;&amp; f) &#123;</span><br><span class="line">		int index = m_nextKey++;</span><br><span class="line">		m_connections.emplace(index, std::forward&lt;F&gt;f);</span><br><span class="line">		return index;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int m_nextKey;</span><br><span class="line">	std::map&lt;int, Func&gt; m_connections;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>增加了+=和-=运算符，使用法更接近c#，这里+=会返回一个key，这个key用来-=删除委托时用到，这种做法不太好，只是一个简单的处理。如果内部用vector的话，-=时，根据function去删除指定的委托的话，用法就和c#完全一致了，不过，这里遇到的问题是function不支持比较操作，导致将function存入容器后，后面再根据function去删除时就找不到对应的function了。</p>
<h2 id="改进访问者模式"><a href="#改进访问者模式" class="headerlink" title="改进访问者模式"></a>改进访问者模式</h2><p>访问者表示一个作用于某对象结构中的各元素的操作，可用于不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<p>访问者模式需要注意定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。定义一个稳定的访问者接口层，即不会因为增加新的被访问者而修改接口层。通过可变参数模板实现一个稳定的接口层，利用可变参数模板可以支持任意个数的参数的特点，可以让访问者接口层访问任意个数的被访问者。</p>
<p>访问者模式是GOF23个设计模式中比较复杂的模式之一，但是它的功能也很强大，非常适合稳定的继承层次中对象的访问，可以在不修改被访问对象的情况下，动态添加职责，这正是访问者模式强大的地方，但是它的实现又造成了两个继承层次的强烈耦合，这也是被人诟病的地方，可以说是让人爱又让人恨的模式。c++11实现的访问者模式将会解决这个问题。我们将在c++11版本的访问者模式中看到，定义新的访问者是很容易的，扩展性很好，被访问者的继承层次也不用做任何修改。具体代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename... Types&gt;</span><br><span class="line">struct Visitor;</span><br><span class="line"> </span><br><span class="line">template&lt;typename T, typename... Types&gt;</span><br><span class="line">struct Visitor&lt;T, Types...&gt; : Visitor&lt;Types...&gt;</span><br><span class="line">&#123;</span><br><span class="line">    using Visitor&lt;Types...&gt;::Visit;</span><br><span class="line">    virtual void Visit(const T&amp;) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct Visitor&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    virtual void Visit(const T&amp;) = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码为每个类型都定义了一个纯虚函数Visit。</p>
<p>下面看看被访问的继承体系如何使用Visitor访问该继承体系的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct stA;</span><br><span class="line">struct stB; </span><br><span class="line"> </span><br><span class="line">struct Base</span><br><span class="line">&#123;    </span><br><span class="line">    typedef Visitor&lt;stA, stB&gt; MytVisitor;     </span><br><span class="line">    virtual void Accept(MytVisitor&amp;) = 0;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">struct stA: Base</span><br><span class="line">&#123;    </span><br><span class="line">    double val;     </span><br><span class="line">    void Accept(Base::MytVisitor&amp; v)    </span><br><span class="line">    &#123;        </span><br><span class="line">        v.Visit(*this);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">struct stB: Base</span><br><span class="line">&#123;    </span><br><span class="line">    int val;    </span><br><span class="line">    void Accept(Base::MytVisitor&amp; v)    </span><br><span class="line">    &#123;        </span><br><span class="line">        v.Visit(*this);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">struct PrintVisitor: Base::MytVisitor</span><br><span class="line">&#123;    </span><br><span class="line">    void Visit(const stA&amp; a)    </span><br><span class="line">    &#123;        </span><br><span class="line">        std::cout &lt;&lt; &quot;from stA: &quot; &lt;&lt; a.val &lt;&lt; std::endl;    </span><br><span class="line">    &#125;     </span><br><span class="line">    void Visit(const stB&amp; b)    </span><br><span class="line">    &#123;        </span><br><span class="line">        std::cout &lt;&lt; &quot;from stB: &quot; &lt;&lt; b.val &lt;&lt; std::endl;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void TestVisitor()</span><br><span class="line">&#123;</span><br><span class="line">    PrintVisitor vis;    </span><br><span class="line">    stA a;    </span><br><span class="line">    a.val = 8.97;    </span><br><span class="line">    stB b;    </span><br><span class="line">    b.val = 8;     </span><br><span class="line">    Base* base = &amp;a;    </span><br><span class="line">    base-&gt;Accept(vis);    </span><br><span class="line">    base = &amp;b;    </span><br><span class="line">    base-&gt;Accept(vis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　测试结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from stA: 8.97</span><br><span class="line">from stB: 8</span><br></pre></td></tr></table></figure>
<p><code>typedef Visitor&lt;stA, stB&gt; MytVisitor;</code>会自动生成stA和stB的visit虚函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Visitor&lt;stA, stB&gt; &#123;</span><br><span class="line">	virtual void Visit(const stA &amp;) = 0;</span><br><span class="line">	virtual void Visit(const stB &amp;) = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当被访者需要增加stC、stD时，增加就行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`typedef Visitor&lt;stA, stB, stC, stD&gt; MytVisitor;</span><br></pre></td></tr></table></figure>
<p>类型自动生成接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Visitor&lt;stA, stB, stC, stD&gt; &#123;</span><br><span class="line">	virtual void Visit(const stA &amp;) = 0;</span><br><span class="line">	virtual void Visit(const stB &amp;) = 0;</span><br><span class="line">	virtual void Visit(const stC &amp;) = 0;</span><br><span class="line">	virtual void Visit(const stD &amp;) = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="改进命令模式"><a href="#改进命令模式" class="headerlink" title="改进命令模式"></a>改进命令模式</h2><p>命令模式的作用是将请求封装为一个对象，将请求的发起者和执行者解耦，支持对请求排队以及撤销和重做。将请求封装成一个个命令对象，使得我们可以集中处理或延迟处理这些命令请求，而且不同的客户对象可以共享命令，控制请求的优先级、排队、支持请求命令撤销和重做。</p>
<p>命令模式的这些好处是显而易见的，但是，在实际使用过程中它的问题也暴露出来了。随着请求的增多，请求的封装类—命令类也会越来越多，尤其是GUI应用中，请求是非常多的。越来越多的命令类会导致类爆炸，难以管理。关于类爆炸这个问题，GOF很早就意识到了，他们提出了一个解决方法：对于简单的不能取消和不需要参数的命令，可以用一个命令类模板来参数化该命令的接收者，用接收者类型来参数化命令类，并维护一个接收者对象和一个动作之间的绑定，而这一动作是用指向同一个成员函数的指针存储的。具体代码是这样的：<br>简单命令类的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Receiver&gt;</span><br><span class="line">class SimpleCommand: public Command &#123;</span><br><span class="line">public :</span><br><span class="line">	typedef void (Receiver:: *Action) ();</span><br><span class="line">	SimpleCormnand(Receiver* r, Action a) : _receiver (r) , _action (a) &#123; &#125;</span><br><span class="line">	virtual void Execute ();</span><br><span class="line">private :</span><br><span class="line">	Action _action;</span><br><span class="line">	Receiver* _receiver ;</span><br><span class="line">&#125;;</span><br><span class="line">template &lt;class Receiver&gt;</span><br><span class="line">void SimpleCommand&lt;Receiver&gt;::Execute() &#123;</span><br><span class="line">	(_receiver-&gt;*_action)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">	void Action();</span><br><span class="line">&#125;</span><br><span class="line">void dummy() &#123;</span><br><span class="line">	MyClass* receiver = new MyClass;</span><br><span class="line">	Command* aCommand = new SimpleCommand&lt;MyClass&gt;(receiver, &amp;MyClass::Action);</span><br><span class="line">	aCommand-&gt;Execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个泛型的简单命令类来避免不断创建新的命令类，是一个不错的办法，但是，这个办法不完美，即它只能是简单的命令类，不能对复杂的，甚至所有的命令类泛化，这是它的缺陷，所以，它只是部分的解决了问题。我想我可以改进这个办法缺陷，完美的解决类爆炸的问题。在c++11之前我不知道有没有人解决过这个问题，至少我没看到过。现在可以通过c++11来完美的解决这个问题了。</p>
<p>要完美的解决命令模式类爆炸问题的关键是如何定义个通用的泛化的命令类，这个命令类可以泛化所有的命令，而不是GOF提到的简单命令。我们再回过头来看看GOF中那个简单的命令类的定义，它只是泛化了没有参数和返回值的命令类，命令类内部引用了一个接收者和接收者的函数指针，如果接收者的行为函数指针有参数就不能通用了，所以我们要解决的关键问题是如何让命令类能接受所有的成员函数指针或者函数对象。</p>
<p>我们需要一个函数包装器，它可以接受所有的函数对象、fucntion和lamda表达式等。接受function、函数对象、lamda和普通函数的包装器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class F, class... Args, class = typename std::enable_if&lt;!std::is_member_function_pointer&lt;F&gt;::value&gt;::type&gt;</span><br><span class="line">void Wrap(F &amp;&amp; f, Args &amp;&amp; ... args)</span><br><span class="line">&#123;</span><br><span class="line">	return f(std::forward&lt;Args&gt;(args)...); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接受成员函数的包装器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class R, class C, class... DArgs, class P, class... Args&gt;</span><br><span class="line">void Wrap(R(C::*f)(DArgs...), P &amp;&amp; p, Args &amp;&amp; ... args)</span><br><span class="line">&#123;</span><br><span class="line">	return (*p.*f)(std::forward&lt;Args&gt;(args)...); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过重载的Wrap让它能接收成员函数。这样一个真正意义上的万能的函数包装器就完成了。现在再来看，它是如何应用到命令模式中，完美的解决类爆炸的问题。</p>
<p>一个通用的泛化的命令类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">template&lt;typename R=void&gt;</span><br><span class="line">struct CommCommand</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	std::function &lt; R()&gt; m_f;</span><br><span class="line">public:</span><br><span class="line">	template&lt; class F, class... Args, class = typename std::enable_if&lt;!std::is_member_function_pointer&lt;F&gt;::value&gt;::type&gt;</span><br><span class="line">	void Wrap(F &amp;&amp; f, Args &amp;&amp; ... args)</span><br><span class="line">	&#123;</span><br><span class="line">		m_f = [&amp;]&#123;return f(args...); &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	template&lt;class C, class... DArgs, class P, class... Args&gt;</span><br><span class="line">	void Wrap(R(C::*f)(DArgs...) const, P &amp;&amp; p, Args &amp;&amp; ... args)</span><br><span class="line">	&#123;</span><br><span class="line">		m_f = [&amp;, f]&#123;return (*p.*f)( args...); &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// non-const member function </span><br><span class="line">	template&lt;class C, class... DArgs, class P, class... Args&gt;</span><br><span class="line">	void Wrap(R(C::*f)(DArgs...), P &amp;&amp; p, Args &amp;&amp; ... args)</span><br><span class="line">	&#123;</span><br><span class="line">		m_f = [&amp;, f]&#123;return (*p.*f)( args...); &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	R Excecute()</span><br><span class="line">	&#123;</span><br><span class="line">		return m_f();</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">struct STA</span><br><span class="line">&#123;</span><br><span class="line">	int m_a;</span><br><span class="line">	int operator()()&#123; return m_a; &#125;</span><br><span class="line">	int operator()(int n)&#123; return m_a + n; &#125;</span><br><span class="line">	int triple0()&#123; return m_a * 3; &#125;</span><br><span class="line">	int triple(int a)&#123; return m_a * 3 + a; &#125;</span><br><span class="line">	int triple1() const &#123; return m_a * 3; &#125;</span><br><span class="line">	const int triple2(int a) const &#123; return m_a * 3+a; &#125;</span><br><span class="line">	void triple3()&#123; cout &lt;&lt; &quot;&quot; &lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int add_one(int n) &#123;</span><br><span class="line">	return n + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestWrap() &#123;</span><br><span class="line"></span><br><span class="line">	CommCommand&lt;int&gt; cmd;</span><br><span class="line">	// free function </span><br><span class="line">	cmd.Wrap(add_one, 0);</span><br><span class="line">	</span><br><span class="line">	// lambda function</span><br><span class="line">	cmd.Wrap([](int n)&#123;return n + 1; &#125;, 1);</span><br><span class="line">	</span><br><span class="line">	// functor </span><br><span class="line">	cmd.Wrap(bloop);</span><br><span class="line">	cmd.Wrap(bloop, 4);</span><br><span class="line">	</span><br><span class="line">	STA t = &#123; 10 &#125;;</span><br><span class="line">	int x = 3;</span><br><span class="line">	// member function </span><br><span class="line">	cmd.Wrap(&amp;STA::triple0, &amp;t);</span><br><span class="line">	cmd.Wrap(&amp;STA::triple, &amp;t, x);</span><br><span class="line">	cmd.Wrap(&amp;STA::triple, &amp;t, 3);</span><br><span class="line">	</span><br><span class="line">	cmd.Wrap(&amp;STA::triple2, &amp;t, 3);</span><br><span class="line">	auto r = cmd.Excecute();</span><br><span class="line">	</span><br><span class="line">	CommCommand&lt;&gt; cmd1;</span><br><span class="line">	cmd1.Wrap(&amp;Bloop::triple3, &amp;t);</span><br><span class="line">	cmd1.Excecute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在通用的命令类内部定义了一个万能的函数包装器，使得我们可以封装所有的命令，增加新的请求都不需要重新定义命令了，完美的解决了命令类爆炸的问题。</p>
<h2 id="改进对象池模式"><a href="#改进对象池模式" class="headerlink" title="改进对象池模式"></a>改进对象池模式</h2><p>对象池对于创建比较大的对象来说很有意义，为了避免重复创建开销比较大的对象，可以通过对象池来优化，实现创建好一批对象，放到一个集合里，每当程序需要新对象时，就从对象池中获取，程序用完该对象后会把对象归还给对象池。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MaxObjectNum = 10;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class ObjectPool : NonCopyable</span><br><span class="line">&#123;</span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">	using Constructor = std::function&lt;std::shared_ptr&lt;T&gt;(Args...)&gt;;</span><br><span class="line">public:</span><br><span class="line">	//默认创建多少个对象</span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">	void Init(size_t num, Args&amp;&amp;... args)</span><br><span class="line">	&#123;</span><br><span class="line">		if (num&lt;= 0 || num&gt; MaxObjectNum)</span><br><span class="line">			throw std::logic_error(&quot;object num out of range.&quot;);</span><br><span class="line"></span><br><span class="line">		auto constructName = typeid(Constructor&lt;Args...&gt;).name(); //不区分引用</span><br><span class="line">		for (size_t i = 0; i &lt;num; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			m_object_map.emplace(constructName, shared_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...), [this, constructName](T* p) //删除器中不直接删除对象，而是回收到对象池中，以供下次使用</span><br><span class="line">			&#123;</span><br><span class="line">				m_object_map.emplace(std::move(constructName), std::shared_ptr&lt;T&gt;(p));</span><br><span class="line">			&#125;));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//从对象池中获取一个对象</span><br><span class="line">	template&lt;typename... Args&gt;</span><br><span class="line">	std::shared_ptr&lt;T&gt; Get()</span><br><span class="line">	&#123;</span><br><span class="line">		string constructName = typeid(Constructor&lt;Args...&gt;).name();</span><br><span class="line"></span><br><span class="line">		auto range = m_object_map.equal_range(constructName);</span><br><span class="line">		for (auto it = range.first; it != range.second; ++it)</span><br><span class="line">		&#123;</span><br><span class="line">			auto ptr = it-&gt;second;</span><br><span class="line">			m_object_map.erase(it);</span><br><span class="line">			return ptr;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return nullptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	multimap&lt;string, std::shared_ptr&lt;T&gt;&gt; m_object_map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="使用C-11实现一个半同步半异步线程池"><a href="#使用C-11实现一个半同步半异步线程池" class="headerlink" title="使用C++11实现一个半同步半异步线程池"></a>使用C++11实现一个半同步半异步线程池</h1><p>实际中，主要有两种方法处理大量的并发任务，一种是一个请求由系统产生一个相应的处理请求的线程（一对一）；另外一种是系统预先生成一些用于处理请求的进程，当请求的任务来临时，先放入同步队列中，分配一个处理请求的进程去处理任务，线程处理完任务后还可以重用，不会销毁，而是等待下次任务的到来。（一对多的线程池技术）线程池技术，能避免大量线程的创建和销毁动作，节省资源，对于多核处理器，由于线程被分派配到多个cpu，会提高并行处理的效率。线程池技术分为半同步半异步线程池和领导者追随者线程池。</p>
<p>一个半同步半异步线程池分为三层。</p>
<ul>
<li>同步服务层：它处理来自上层的任务请求,上层的请求可能是并发的,这些请求不是马上就会被处理的,而是将这些任务放到一个同步排队层中,等待处理。</li>
<li>同步排队层: 来自上层的任务请求都会加到排队层中等待处理，排队层实际就是一个std::queue。</li>
<li>异步服务层: 这一层中会有多个线程同时处理排队层中的任务,异步服务层从同步排队层中取出任务并行的处理。</li>
</ul>
<p>上层只需要将任务丢到同步队列中，主线程也不会阻塞，还能继续发起新的请求。排队曾居于核心地位，实现时，排队曾就是一个同步队列，允许多个线程同时去添加或取出任务。线程池有两个活动过程，一个是往同步队列中添加任务的过程，一个是从同步队列中取任务的过程。</p>
<p>一开始线程池会启动一定数量的线程，这些线程属于异步层，主要用来并行处理排队层中的任务，如果排队层中的任务数为空，则这些线程等待任务的到来，如果发现排队层中有任务了，线程池则会从等待的这些线程中唤醒一个来处理新任务。同步服务层则会不断地将新的任务添加到同步排队层中，这里有个问题值得注意，有可能上层的任务非常多，而任务又是非常耗时的，这时，异步层中的线程处理不过来，则同步排队层中的任务会不断增加，如果同步排队层不加上<br>限控制，则可能会导致排队层中的任务过多，内存暴涨的问题。因此，排队层需要加上限的控制，当排队层中的任务数达到上限时，就不让上层的任务添加进来，起到限制和保护的作用。</p>
<p>同步队列即为线程中三层结构中的中间那一层，它的主要作用是保证队列中共享数据线程安全，还为上一层同步服务层提供添加新任务的接口，以及为下一层异步服务层提供取任务的接口。同时，还要限制任务数的上限，避免任务过多导致内存暴涨的问题。同步队列的实现比较简单，我们会用到C++11的锁、条件变量、右值引用、std::move以及std::forwardo。move是为了实现移动语义，forward是为了实现完美转发。同步队列的锁是用来线程同步的，条件变量是用来实现线程通信的，即线程池空了就要等待，不为空就通知一个线程去处理；线程池满了就等待，直到没有满的时候才通知上层添加新任务。</p>
<p>这三个层次之间需要使用std::mutex、std::condition_variable来进行事件同步，线程池的实现代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class SyncQueue</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    SyncQueue(int maxSize) : m_maxSize(maxSize),m_needStop(false)&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    void Put(const T&amp; x) &#123;</span><br><span class="line">		Add(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Put(T&amp;&amp; x) &#123;</span><br><span class="line">    	Add(std::forward&lt;T&gt;(x));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void Take(std::list&lt;T&gt;&amp; list) &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">        m_notEmpty.wait(locker,[this]&#123;return m_needStop || NotEmpty();&#125;);</span><br><span class="line">        if(m_needStop)</span><br><span class="line"> 			return;</span><br><span class="line">        list = std::move(m_queue);   //move semantics,avoid copy.</span><br><span class="line">        m_notFull.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Take(T&amp; x) &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">        m_notEmpty.wait(locker,[this]&#123;return m_needStop || NotEmpty();&#125;);</span><br><span class="line">        if(m_needStop)</span><br><span class="line">            return;</span><br><span class="line">        x=m_queue.front();</span><br><span class="line">        m_queue.pop_front();</span><br><span class="line">        m_notFull.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void Stop() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">            m_needStop = true;</span><br><span class="line">        &#125;</span><br><span class="line">        m_notFull.notify_all();</span><br><span class="line">        m_notEmpty.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool Empty() &#123;</span><br><span class="line">    	std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">    	return m_queue.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool Full() &#123;</span><br><span class="line">    	std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">    	return m_queue.size() == m_maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    std::size_t Size()</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">        return m_queue.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int Count() &#123;</span><br><span class="line">    	return m_queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    bool NotFull() const &#123;</span><br><span class="line">        bool full = m_queue.size() &gt;= m_maxSize;</span><br><span class="line">        if(full)</span><br><span class="line">            std::cout &lt;&lt; &quot;the buffer is full,waiting...\n&quot;;</span><br><span class="line">        return !full;</span><br><span class="line">    &#125;</span><br><span class="line">    bool NotEmpty()</span><br><span class="line">    &#123;</span><br><span class="line">        bool empty = m_queue.empty();</span><br><span class="line">        if(empty)</span><br><span class="line">            std::cout &lt;&lt; &quot;the buffer is empty,waiting...\n&quot;;</span><br><span class="line">        return !empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename F&gt; </span><br><span class="line">    void Add(F&amp;&amp; x) &#123;</span><br><span class="line">    	std::unique_lock&lt;std::mutex&gt; locker(m_mutex);</span><br><span class="line">    	m_notFull.wait(locker, [this]&#123; return m_needStop || NotFull(); &#125;);</span><br><span class="line">    	if (m_needStop) </span><br><span class="line">    		return ;</span><br><span class="line">    	m_queue.push_back(std::forward&lt;F&gt;(x));</span><br><span class="line">    	m_notEmpty.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::list&lt;T&gt; m_queue;</span><br><span class="line">    std::mutex m_mutex;</span><br><span class="line">    std::condition_variable m_notEmpty;</span><br><span class="line">    std::condition_variable m_notFull;</span><br><span class="line">    int m_maxSize;</span><br><span class="line">    bool m_needStop;   //stop flag</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Take函数先创建一个unique_lock获取，然后再通过条件变量m_notEmpty来等待判断式，判断式由两个条件组成，一个是停止的标志，另一个是不为空的条件，当不满足任何一个条件时，条件变量会释放mutex并将线程置于waiting状态，等待其他线程调用notify_one/notify-all将其唤醒；当满足任何一个条件时，则继续往下执行后面的逻辑，即将队列中的任务取出，并唤醒一个正处于等待状态的添加任务的线程去添加任务。当处于waiting状态的线程被或notify_all唤醒时，条件变量会先重新获取mutex，然后再检查条件是否满足，如果满足，则往下执行，如果不满足，则释放mutex继续等待。</p>
<p>Add函数的过程与Take类似，先获取mutex，不满足条件时，释放继续等待，如果满足条件，则将新的任务插人到队列中，并唤醒取任的线程去取数据。</p>
<p>Stop函数先获取mutex，然后将停止标志置为true。注意，为了保证线程安全，这里需要先获取mutex，在将其标志置为之后，再唤醒所有等待的线程，因为等待的条件是m_needStop，并且满足条件，所以线程会继续往下执行。由于线程在m_needStop为true时会退出，所以所有的等待线程会相继退出。另外一个值得注意的地方是，我们把m_notFull.notify_all()放到lock_guard保护范围之外了，这里也可以将m_notFull.notify_all()放到lock_guard保护范围之内，放到外面是为了做一点优化。因为notify-one或notify-all会唤醒一个在等待的线程，线程被唤醒后会先获取mutex再检查条件是否满足，如果这时被lock_guard保护，被唤醒的线程则需要lock_guard析构释放mutex才能获取。如果在lock_guard之外notify_one或notify_all，被唤醒的线程获取锁的时候不需要等待lock-guard释放锁，性能会<br>好一点，所以在执行notify-one或notify-all时不需要加锁保护。</p>
<p>线程池：<br>一个完整的线程池包括三层：同步服务层、排队层和异步服务层，其实这也是一种生产者一消费者模式，同步层是生产者，不断将新任务丢到排队层中，因此，线程池需要提供一个添加新任务的接口供生产者使用；消费者是异步层，具体是由线程池中预先创建的线程去处理排队层中的任务。排队层是一个同步队列，它内部保证了上下两层对共享数据的安全访问，同时还要保证队列不会被无限制地添加任务导致内存暴涨，这个同步队列将使用上一节中实现的线程池。另外，线程池还要提供一个停止的接口，让用户能够在需要的时候停止线程池的运行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">const int MaxTaskCount = 100;</span><br><span class="line">class ThreadPool</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    using Task = std::function&lt;void()&gt;; </span><br><span class="line"> </span><br><span class="line">    ThreadPool(int numThreads = std::thread::hardware_concurrency()) :</span><br><span class="line">    		m_taskQueue(MaxTaskCount)</span><br><span class="line">    &#123;</span><br><span class="line">        Start(numThreads);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~ThreadPool()&#123; Stop();&#125;;</span><br><span class="line">    void Stop() &#123;</span><br><span class="line">        std::call_once(m_once_flag,[this]&#123;StopThreadGroup();&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void AddTask(Task&amp;&amp; task) &#123;</span><br><span class="line">    	m_queue.Put(std::forward&lt;Task&gt;(task));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void AddTask(const Task&amp; task) &#123;</span><br><span class="line">        m_taskQueue.Put(task);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    std::size_t SyncQueueSize() &#123;</span><br><span class="line">        return m_taskQueue.Size();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    void Start(int numThreads) &#123;</span><br><span class="line">        m_running = true;</span><br><span class="line">        for( int i = 0;i &lt; numThreads; ++i) &#123;</span><br><span class="line">            m_threadGrop.push_back(std::make_shared&lt;std::thread&gt;(&amp;ThreadPool::RunInThread,this));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void RunInThread() &#123;</span><br><span class="line">        while(m_running) &#123;</span><br><span class="line">            std::list&lt;Task&gt; list;</span><br><span class="line">            m_taskQueue.Take(list);</span><br><span class="line"></span><br><span class="line">            for(auto&amp; task : list) &#123;</span><br><span class="line">                if(!m_running)</span><br><span class="line">                    return;</span><br><span class="line">                 task();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void StopThreadGroup() &#123;</span><br><span class="line">        m_taskQueue.Stop();</span><br><span class="line">        m_running = false;</span><br><span class="line">        for(auto thread : m_threadGrop) &#123;</span><br><span class="line">            if(thread)</span><br><span class="line">                thread-&gt;join();</span><br><span class="line">        &#125;</span><br><span class="line">        m_threadGrop.clear();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    std::list&lt;std::shared_ptr&lt;std::thread&gt;&gt; m_threadGrop;   //thread group</span><br><span class="line">    SyncQueue&lt;Task&gt; m_taskQueue;</span><br><span class="line">    std::atomic_bool m_running;</span><br><span class="line">    std::once_flag m_once_flag;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h1 id="C-11实现一个轻量级的AOP框架"><a href="#C-11实现一个轻量级的AOP框架" class="headerlink" title="C++11实现一个轻量级的AOP框架"></a>C++11实现一个轻量级的AOP框架</h1><p>AOP（Aspect-Oriented Programming，面向方面编程），可以解决面向对象编程中的一些问题，是OOP的一种有益补充。面向对象编程中的继承是一种从上而下的关系，不适合定义从左到右的横向关系，如果继承体系中的很多无关联的对象都有一些公共行为，这些公共行为可能分散在不同的组件、不同的对象之中，通过继承方式提取这些公共行为就不太合适了。使用AOP还有一种情况是为了提高程序的可维护性，AOP将程序的非核心逻辑都“横切”出来，将非核心逻辑和核心逻辑分离，使我们能集中精力在核心逻辑上，如图所示的这种情况。<br><img src="/img/468725-20150831100452169-1977975177.png" alt=""></p>
<p>在图中，每个业务流程都有日志和权限验证的功能，还有可能增加新的功能，实际上我们只关心核心逻辑，其他的一些附加逻辑，如日志和权限，我们不需要关注，这时，就可以将日志和权限等非核心逻辑“横切”出来，使核心逻辑尽可能保持简洁和清晰，方便维护。这样“横切”的另外一个好处是，这些公共的非核心逻辑被提取到多个切面中了，使它们可以被其他组件或对象复用，消除了重复代码。</p>
<p>AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，它们经常发生在核心关注点的多处，而各处都基本相似，比如权限认证、日志、事务处理。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<p>实现AOP的技术分为：静态织入和动态织入。静态织入一般采用抓们的语法创建“方面”，从而使编译器可以在编译期间织入有关“方面”的代码，AspectC++就是采用的这种方式。这种方式还需要专门的编译工具和语法，使用起来比较复杂。我将要介绍的AOP框架正是基于动态织入的轻量级AOP框架。动态织入一般采用动态代理的方式，在运行期对方法进行拦截，将切面动态织入到方法中，可以通过代理模式来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;memory&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class IHello</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    IHello() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    virtual ~IHello() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    virtualvoid Output(const string&amp; str) &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">class Hello : public IHello &#123;</span><br><span class="line">public:</span><br><span class="line">    void Output(const string&amp; str) override &#123;</span><br><span class="line">        cout &lt;&lt;str&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class HelloProxy : public IHello &#123;</span><br><span class="line">public:</span><br><span class="line">    HelloProxy(IHello* p) : m_ptr(p) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    ~HelloProxy() &#123;</span><br><span class="line">        delete m_ptr;</span><br><span class="line">        m_ptr = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Output(const string&amp; str) final &#123;</span><br><span class="line">        cout &lt;&lt;&quot;Before real Output&quot;&lt;&lt; endl;</span><br><span class="line">        m_ptr-&gt;Output(str);</span><br><span class="line">        cout &lt;&lt;&quot;After real Output&quot;&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    IHello* m_ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void TestProxy()</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;IHello&gt; hello = std::make_shared&lt;HelloProxy&gt;(newHello());</span><br><span class="line">    hello-&gt;Output(&quot;It is a test&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码将输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before real Output</span><br><span class="line">It is a test</span><br><span class="line">Before real Output</span><br></pre></td></tr></table></figure>
<p>可以看到我们通过HelloProxy代理对象实现了对Output方法的拦截，这里Hello::Output就是核心逻辑，HelloProxy实际上就是一个切面，我们可以把一些非核心逻辑放到里面，比如在核心逻辑之前的一些校验，在核心逻辑执行之后的一些日志等。</p>
<p>要实现灵活组合各种切面，一个比较好的方法是将切面作为模板的参数，这个参数是可变的，支持1到N（N&gt;0）切面，先执行核心逻辑之前的切面逻辑，执行完之后再执行核心逻辑，然后再执行核心逻辑之后的切面逻辑。这里，我们可以通过可变参数模板来支持切面的组合。AOP实现的关键是动态织入，实现技术就是拦截目标方法，只要拦截了目标方法，我们就可以在目标方法执行前后做一些非核心逻辑，通过继承方式来实现拦截，需要派生基类并实现基类接口，这使程序的耦合性增加了。为了降低耦合性，这里通过模板来做解耦，即每个切面对象需要提供Before(Args…)或After(Args…)方法，用来处理核心逻辑执行前后的非核心逻辑。</p>
<p>为了实现切面的充分解耦合，我们的切面不必通过继承方式实现，而且也不必要求切面必须具备Before和After方法，只要具备任意一个方法即可，给使用者提供最大的便利性和灵活性。实现这个功能稍微有点复杂，复杂的地方在于切面可能具有某个方法也可能不具有某个方法，具有就调用，不具有也不会出错。问题的本质上是需要检查类型是否具有某个方法，在C++中是无法在运行期做到这个事情的，因为C++像不托管语言c#或java那样具备反射功能，然而，我们可以在编译期检查类型是否具有某个方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#define HAS_MEMBER(member)\</span><br><span class="line">template&lt;typename T, typename... Args&gt;struct has_member_##member\</span><br><span class="line">&#123;\</span><br><span class="line">private:\</span><br><span class="line">        template&lt;typename U&gt; static auto Check(int) -&gt; decltype(std::declval&lt;U&gt;().member(std::declval&lt;Args&gt;()...), std::true_type()); \</span><br><span class="line">    template&lt;typename U&gt; static std::false_type Check(...);\</span><br><span class="line">public:\</span><br><span class="line">    enum&#123;value = std::is_same&lt;decltype(Check&lt;T&gt;(0)), std::true_type&gt;::value&#125;;\</span><br><span class="line">&#125;;\</span><br><span class="line"></span><br><span class="line">HAS_MEMBER(Foo)</span><br><span class="line">HAS_MEMBER(Before)</span><br><span class="line">HAS_MEMBER(After)</span><br><span class="line"></span><br><span class="line">#include &lt;NonCopyable.hpp&gt;</span><br><span class="line">template&lt;typename Func, typename... Args&gt;</span><br><span class="line">struct Aspect : NonCopyable</span><br><span class="line">&#123;</span><br><span class="line">    Aspect(Func&amp;&amp; f) : m_func(std::forward&lt;Func&gt;(f)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    typename std::enable_if&lt;has_member_Before&lt;T, Args...&gt;::value&amp;&amp;has_member_After&lt;T, Args...&gt;::value&gt;::type Invoke(Args&amp;&amp;... args, T&amp;&amp; aspect)</span><br><span class="line">    &#123;</span><br><span class="line">        aspect.Before(std::forward&lt;Args&gt;(args)...);//核心逻辑之前的切面逻辑</span><br><span class="line">        m_func(std::forward&lt;Args&gt;(args)...);//核心逻辑</span><br><span class="line">        aspect.After(std::forward&lt;Args&gt;(args)...);//核心逻辑之后的切面逻辑</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    typename std::enable_if&lt;has_member_Before&lt;T, Args...&gt;::value&amp;&amp;!has_member_After&lt;T, Args...&gt;::value&gt;::type Invoke(Args&amp;&amp;... args, T&amp;&amp; aspect)</span><br><span class="line">    &#123;</span><br><span class="line">        aspect.Before(std::forward&lt;Args&gt;(args)...);//核心逻辑之前的切面逻辑</span><br><span class="line">        m_func(std::forward&lt;Args&gt;(args)...);//核心逻辑</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename T&gt;</span><br><span class="line">    typename std::enable_if&lt;!has_member_Before&lt;T, Args...&gt;::value&amp;&amp;has_member_After&lt;T, Args...&gt;::value&gt;::type Invoke(Args&amp;&amp;... args, T&amp;&amp; aspect)</span><br><span class="line">    &#123;</span><br><span class="line">        m_func(std::forward&lt;Args&gt;(args)...);//核心逻辑</span><br><span class="line">        aspect.After(std::forward&lt;Args&gt;(args)...);//核心逻辑之后的切面逻辑</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template&lt;typename Head, typename... Tail&gt;</span><br><span class="line">    void Invoke(Args&amp;&amp;... args, Head&amp;&amp;headAspect, Tail&amp;&amp;... tailAspect)</span><br><span class="line">    &#123;</span><br><span class="line">        headAspect.Before(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">        Invoke(std::forward&lt;Args&gt;(args)..., std::forward&lt;Tail&gt;(tailAspect)...);</span><br><span class="line">        headAspect.After(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Func m_func; //被织入的函数</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typenameT&gt; using identity_t = T;</span><br><span class="line"></span><br><span class="line">//AOP的辅助函数，简化调用</span><br><span class="line">template&lt;typename... AP, typename... Args, typename Func&gt;</span><br><span class="line">void Invoke(Func&amp;&amp;f, Args&amp;&amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">    Aspect&lt;Func, Args...&gt; asp(std::forward&lt;Func&gt;(f));</span><br><span class="line">    asp.Invoke(std::forward&lt;Args&gt;(args)..., identity_t&lt;AP&gt;()...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现思路很简单，将需要动态织入的函数保存起来，然后根据参数化的切面来执行Before(Args…)处理核心逻辑之前的一些非核心逻辑，在核心逻辑执行完之后，再执行After(Args…)来处理核心逻辑之后的一些非核心逻辑。上面的代码中的has_member_Before和has_member_After这两个traits是为了让使用者用起来更灵活，使用者可以自由的选择Before和After，可以仅仅有Before或After，也可以二者都有。</p>
<p>需要注意的是切面中的约束，因为通过模板参数化切面，要求切面必须有Before或After函数，这两个函数的入参必须和核心逻辑的函数入参保持一致，如果切面函数和核心逻辑函数入参不一致，则会报编译错误。从另外一个角度来说，也可以通过这个约束在编译期就检查到某个切面是否正确。</p>
<p>下面看一个简单的测试AOP的例子，这个例子中我们将记录目标函数的执行时间并输出日志，其中计时和日志都放到切面中。在执行函数之前输出日志，在执行完成之后也输出日志，并对执行的函数进行计时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct TimeElapsedAspect</span><br><span class="line">&#123;</span><br><span class="line">    void Before(int i) &#123;</span><br><span class="line">        m_lastTime = m_t.elapsed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void After(int i) &#123;</span><br><span class="line">        cout &lt;&lt;&quot;time elapsed: &quot;&lt;&lt; m_t.elapsed() - m_lastTime &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    double m_lastTime;</span><br><span class="line">    Timer m_t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct LoggingAspect</span><br><span class="line">&#123;</span><br><span class="line">    void Before(int i) &#123;</span><br><span class="line">        std::cout &lt;&lt;&quot;entering&quot;&lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void After(int i) &#123;</span><br><span class="line">        std::cout &lt;&lt;&quot;leaving&quot;&lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void foo(int a) &#123;</span><br><span class="line">    cout &lt;&lt;&quot;real HT function: &quot;&lt;&lt;a&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Invoke&lt;LoggingAspect, TimeElapsedAspect&gt;(&amp;foo, 1); //织入方法</span><br><span class="line">	cout &lt;&lt;&quot;-----------------------&quot;&lt;&lt; endl;</span><br><span class="line">    Invoke&lt;TimeElapsedAspect, LoggingAspect&gt;(&amp;foo, 1);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用C-开发一个轻量级的IoC容器"><a href="#使用C-开发一个轻量级的IoC容器" class="headerlink" title="使用C++开发一个轻量级的IoC容器"></a>使用C++开发一个轻量级的IoC容器</h1><p>让对象不再直接依赖于外部对象的创建，而是依赖于某种机制，这种机制可以让对象之间的关系在外面组装，外界可以根据需求灵活地配置这种机制的对象创建策略，从而获得想要的目标对象，这种机制被称为控制反转。控制反转就是应用本身不负责依赖对象的创建和维护，而交给一个外部容器来负责。这样控制权就由应用转移到了外部容器，即实现了所谓的控制反转。IoC用来降低对象之间直接依赖产生的耦合性。</p>
<p>具体做法是将对象的依赖关系从代码中移出去，放到一个统一的配置文件中或者在IoC容器中配置这种依赖关系，由容器来管理对象的依赖关系。比如可以这样来初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void IocSample() &#123;</span><br><span class="line">	//通过IOC容器来配A和Base对象的关系</span><br><span class="line">	IocContainer ioc;</span><br><span class="line">	ioc.RegisterType&lt;A, DerivedB&gt;(&quot;B&quot;);</span><br><span class="line">	ioc.RegisterType&lt;A, DerivedC&gt;(&quot;C&quot;);</span><br><span class="line">	ioc.RegisterType&lt;A, DerivedD&gt;(&quot;D&quot;);</span><br><span class="line"></span><br><span class="line">	//由IoC容器去初始化A对象</span><br><span class="line">	A* a = ioc.Resolve&lt;A&gt;(&quot;B&quot;)；</span><br><span class="line">	a-&gt;Func();</span><br><span class="line">	delete a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们在外面通过IoC容器配置了A和Base对象的关系，然后由IoC容器去创建A对象，这里A对象的创建不再依赖于工厂或者Base对象，彻底解耦了二者之间的关系。</p>
<p>IoC使得我们在对象创建上获得了最大的灵活性，大大降低了依赖对象创建时的耦合性，即使需求变化了，也只需要修改配置文件就可以创建想要的对象，而不需要修改代码了。我们一般是通过依赖注人（Dependency Injection）来将对象创建的依赖关系注人到目标类型的构造函数中。</p>
<p>IoC容器实际上具备两种能力，一种是对象工厂的能力，不仅可以创建所有的对象，还能根据配置去创建对象；另一种能力是可以去创建依赖对象，应用不需要直接创建依赖对象，由IoC容器去创建，实现控制反转。</p>
<h2 id="IoC创建对象"><a href="#IoC创建对象" class="headerlink" title="IoC创建对象"></a>IoC创建对象</h2><p>因为IoC容器本质上是为了创建对象及依赖的对象，所以实现loc容器第一个要解决的问题是如何创建对象。IoC容器要创建所有类型对象的能力，并且还能根据配置来创建依赖对象。我们先看看如何实现一个可配置的对象工厂。</p>
<p>一个可配置的对象工厂实现思路如下：先注册可能需要创建的对象类型的构造函数，将其放到一个内部关联容器中，设置键为类型的名称或者某个唯一的标识，值为类型的构造函数，然后在创建的时候根据类型名称或某个唯一标识来查找对应的构造函数并最终创建出目标对象。对于外界来说，不需要关心对象具体是如何创建的，只需要告诉工厂要创建的类型名称即可，工厂获取了类型名称或唯一标识之后就可以创建需要的对象了。由于工厂是根据唯一标识来创建对象，所以这个唯一标识是可以写到配置文件中的，这样就可以根据配置动态生成所需要的对象了，我们一般是将类型的名称作为这个唯一标识。</p>
<p>类型擦除就是将原有类型消除或者隐藏。为什么要擦除类型？因为很多时候我们不关心只体类型是什么或者根本就不需要这个类型。类型擦除可以获取很多好处，比如使得程序有更好的扩展性，还能消除耦合以及消除一些重复行为，使程序更加简洁高效。下面是一些常用的类型擦除方式：</p>
<ul>
<li>通过多态来擦除类型。</li>
<li>通过模板来擦除类型。</li>
<li>通过某种类型容器来擦除类型。</li>
<li>通过某种通用类型来擦除类型。</li>
<li>通过闭包来擦除类型。</li>
</ul>
<p>第一种类型擦除方式是最简单的，也是经常用的，通过将派生类型隐式转换成基类型，再通过基类去调用虚函数。在这种情况下，我们不用关心派生类的具体类型，只需要以一种统一的方式去做不同的事情，所以就把派生类型转成基类型隐藏起来，这样不仅可以多态调用，还使程序具有良好的可扩展性。然而这种方式的类型擦除仅是将部分类型擦除，因为基类型仍然存在，而且这种类型擦除的方式还必须继承这种强耦合的方式。正是因为这些缺点，通过多态来擦除类型的方式有较多局限性，并且效果也不好。这时通过第二种方式来擦除类型，可以以解决第一种方式的一些问题。通过模板来擦除类型，本质上是把不同类型的共同行为进行了抽象，这时不同类型彼此之间不需要通过继承这种强耦合的方式去获得共同的行为，仅仅是通过模板就能获取共同行为，降低了不同类型之间的耦合，是一种很好的类型擦除方式。然而，第二种方式虽然降低了对象间的耦合，但是还有一个问题没解决，就是基本类型始终需要指定，并没有消除基本类型，例如，不可能把一个T本身作为容器元素，必须在容器初始化时指定T为某个具体类型。</p>
<p>有时，希望有一种通用的类型，可以让容器容纳所有的类型，作为所有类型的基类，可以当作一种通用的类型。之前实现的Variant类可以把不同的类型抱起来，获得一种统一的类型，而且不同类型之间没有耦合关系。比如，可以通过Variant这样来擦除类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义通用的类型，这个类型可能容纳多种类型</span><br><span class="line">typedef Variant&lt;double, int, uint32_t, char*&gt;Value;</span><br><span class="line">vt.pushback(l);</span><br><span class="line">vt.pushback(&quot;test&quot;);</span><br><span class="line">vt.pushback(1.22);</span><br></pre></td></tr></table></figure>
<p>上面的代码擦除了不同类型，使得不同的类型都可以放到一个容器中了，如果要取出来就很简单，通过Get<T>()就可以获取对应类型的值。这种方式是通过类型容器把类型包起来了，从而达到类型擦除的目的。这种方式的缺点是通用的类型必须事先定义好，它只能容<br>纳声明的那些类型，是有限的，超出定义的范围就不行了。</p>
<p>通过某种通用类型来擦除原有类型的方式可以消除这个缺点，这种通用类型就是Any类型，下面介绍怎么用Any来擦除类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Any&gt; v;</span><br><span class="line">v.pushback(1);</span><br><span class="line">v.pushback(&quot;test&quot;);</span><br><span class="line">v.pushback(2.35);</span><br><span class="line">auto r1 = v[0].AnyCast&lt;int&gt;();</span><br><span class="line">auto r2 = v[1].AnyCast&lt;const char*&gt;();</span><br><span class="line">auto r3 = v[2].AnyCast&lt;double&gt;();</span><br><span class="line"></span><br><span class="line">Any a = 1;</span><br><span class="line">if(a.Is&lt;int&gt;()) &#123;</span><br><span class="line">	int I = a.AnyCast&lt;int&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，不需要预先定义类型的范围，允许任何类型的对象都赋值给Any对象，消除了Variant类型只支持有限类型的问题，但是Any的缺点是：在取值的时候仍然需要具体的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;Any&gt;</span><br><span class="line">#include&lt;NonCopyable&gt;</span><br><span class="line"></span><br><span class="line">class IocContainer &#123;</span><br><span class="line">public:</span><br><span class="line">    IocContainer(void)&#123;&#125;</span><br><span class="line">    ~IocContainer(void)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class T, typename Depend&gt;</span><br><span class="line">    void RegisterType(const string&amp; strKey) &#123;</span><br><span class="line">        std::function&lt;T*()&gt; function = []&#123; return new T(new Depend());&#125;;</span><br><span class="line">        RegisterType(strKey, function);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class I&gt;</span><br><span class="line">    I* Resolve(string strKey)</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_creatorMap.find(strKey) == m_creatorMap.end())</span><br><span class="line">            return nullptr;</span><br><span class="line"></span><br><span class="line">        Any resolver = m_creatorMap[strKey];</span><br><span class="line">        std::function&lt;I* ()&gt; function = resolver.AnyCast&lt;std::function&lt;I*()&gt;&gt;(); </span><br><span class="line">        return function();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class I&gt;</span><br><span class="line">    std::shared_ptr&lt;I&gt; ResolveShared(const string&amp; strKey)</span><br><span class="line">    &#123;</span><br><span class="line">        auto b = Resolve&lt;I&gt;(strKey);</span><br><span class="line">        return std::shared_ptr&lt;I&gt;(b);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">	void RegisterType(const string&amp; strKey, Any constructor)</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_creatorMap.find(strKey) != m_creatorMap.end())</span><br><span class="line">            throw std::logic_exception(&quot;this key has already exist!&quot;);</span><br><span class="line"></span><br><span class="line">        m_creatorMap.insert(make_pair(strKey, constructor));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;string, Any&gt; m_creatorMap;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">	IocContainer ioc;</span><br><span class="line">	ioc.RegisterType&lt;A, DerivedB&gt;(&quot;B&quot;);</span><br><span class="line">	ioc.RegisterType&lt;A, DerivedC&gt;(&quot;C&quot;);</span><br><span class="line">	ioc.RegisterType&lt;A, DerivedD&gt;(&quot;D&quot;);</span><br><span class="line"></span><br><span class="line">	auto pa = ioc.ResolveShared&lt;A&gt;(&quot;B&quot;);</span><br><span class="line">	pa-&gt;Func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样仍然不太方便，但是可以改进，可以借助闭包，将一些类型信息保存在闭包中，闭包将类型隐藏起来了，从而实现了类型擦除的目的。由于闭包本身的类型是确定的，所以能放到普通的容器中，在需要的时候从闭包中取出具体的类型。下面看看如何通过闭包来擦除类型，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Func(T t) &#123;</span><br><span class="line">	cout&lt;&lt;t&lt;&lt;endl；</span><br><span class="line">&#125;</span><br><span class="line">void TestErase() &#123;</span><br><span class="line">	int x = 1;</span><br><span class="line">	char y = &#x27;s&#x27;;</span><br><span class="line"></span><br><span class="line">	vector&lt;std::function&lt;void()&gt;&gt; v;</span><br><span class="line">	v.push_back([x]&#123;Func(x);&#125;);</span><br><span class="line">	v.push_back([y]&#123;Func(y);&#125;);</span><br><span class="line"></span><br><span class="line">	for(auto item : v) &#123;</span><br><span class="line">		item();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的可变参数模板改进IoC容器，支持带参数对象的创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &lt;Any&gt;</span><br><span class="line">#include&lt;NonCopyable&gt;</span><br><span class="line"></span><br><span class="line">class IocContainer : NonCopyable</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    IocContainer(void)&#123;&#125;</span><br><span class="line">    ~IocContainer(void)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class T, typename Depend, typename ... Args&gt;</span><br><span class="line">    void RegisterType(const string&amp; strKey)</span><br><span class="line">    &#123;</span><br><span class="line">        std::function&lt;T*(Args...)&gt; function = [](Args... args)&#123; return new T(new Depend(args...));&#125;;</span><br><span class="line">        RegisterType(strKey, function);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class T, typename ... Args&gt;</span><br><span class="line">    I* Resolve(const string&amp; strKey, Args ... args)</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_creatorMap.find(strKey) == m_creatorMap.end())</span><br><span class="line">            return nullptr;</span><br><span class="line"></span><br><span class="line">        Any resolver = m_creatorMap[strKey];</span><br><span class="line">       std::function&lt;T*(Args...)&gt; function  = resolver.AnyCast&lt;std::function&lt;T*(Args...)&gt;&gt;(); </span><br><span class="line">        return function(args...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    template &lt;class I, typename... Args&gt;</span><br><span class="line">    std::shared_ptr&lt;I&gt; ResolveShared(const string&amp; strKey, Args... args)</span><br><span class="line">    &#123;</span><br><span class="line">        I* i = Resolve&lt;I&gt;(strKey, args...);</span><br><span class="line">        return std::shared_ptr&lt;I&gt;(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	void RegisterType(const string&amp; strKey, Any constructor)</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_creatorMap.find(strKey) != m_creatorMap.end())</span><br><span class="line">            throw std::logic_exception(&quot;this key has already exist!&quot;);</span><br><span class="line"></span><br><span class="line">        m_creatorMap.emplace(strKey, constructor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;string, Any&gt; m_creatorMap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	IocContainer ioc;</span><br><span class="line">	ioc.RegisterType&lt;A, DerivedC&gt;(&quot;C&quot;);</span><br><span class="line">	auto c = ioc.ResolveShared&lt;A&gt;(&quot;C&quot;);</span><br><span class="line"></span><br><span class="line">	ioc.RegisterType&lt;A, DerivedB, int, double&gt;(&quot;C&quot;);</span><br><span class="line">	auto b = ioc.ResolveShared&lt;A&gt;(&quot;C&quot;, 1, 2.0);</span><br><span class="line">	b-&gt;Func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型注册分成三种方式注册，一种是简单方式注册，它只需要具体类型信息和key，类型的构造函数中没有参数，从容器中取也只需要类型和key；另外一种简单注册方式需要接口类型和具体类型，返回实例时，可以通过接口类型和key来得到具体对象；第三种是构造函数中带参数的类型注册，需要接口类型、key和参数类型，获取对象时需要接口类型、key和参数。返回的实例可以是普通的指针也可以是智能指针。需要注意的是key是唯一的，如果不唯一，会产生一个断言错误，推荐用类型的名称作为key，可以保证唯一性，std::string strKey = typeid(T).name()。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/13/effective_cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/13/effective_cpp/" itemprop="url">Effective C++笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-13T20:13:00+08:00">
                2020-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦"></a>视C++为一个语言联邦</h2><ol>
<li>C语言</li>
<li>面对对象：构造函数、析构函数、封装、继承、多态、virtual函数</li>
<li>C++模板：template metaprogramming</li>
<li>STL容器：对容器、迭代器、算法以及函数对象的规约有极佳的紧密配合与协调</li>
</ol>
<h2 id="尽量以const，enum，inline替换-define"><a href="#尽量以const，enum，inline替换-define" class="headerlink" title="尽量以const，enum，inline替换#define"></a>尽量以const，enum，inline替换#define</h2><p>const的好处：</p>
<ul>
<li>define直接常量替换，出现编译错误不易定位(不知道常量是哪个变量)</li>
<li>define盲目的将宏名替换，导致目标码出现多份</li>
<li>define没有作用域，const有作用域提供了封装性</li>
</ul>
<p>定义常量指针：有必要将指针（而不只是指针所指之物）声明为const：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char* const authorName = &quot;Scott Meyers&quot;</span><br></pre></td></tr></table></figure></p>
<p>enum的好处：</p>
<ul>
<li>提供了封装性</li>
<li>编译器肯定不会分配额外内存空间(其实const也不会)</li>
</ul>
<p>inline的好处：</p>
<ul>
<li>define宏函数容易造成误用(下面有个例子)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) a &gt; b ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line">MAX(++a, b) <span class="comment">//a++调用2次</span></span><br><span class="line">MAX(++a, b+<span class="number">10</span>) <span class="comment">//a++调用一次</span></span><br></pre></td></tr></table></figure>
<p>使用template inline 函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void callWithMax(const T&amp; a, const T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	f(a &gt; b ? a : b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>对单纯常量，最好以const对象或enums替换#define</strong><br><strong>形似函数的宏，最好改用inline函数替换#define</strong></p>
<h3 id="宏实现工厂模式"><a href="#宏实现工厂模式" class="headerlink" title="宏实现工厂模式"></a>宏实现工厂模式</h3><p>需要一个全局的map用于存储类的信息以及创建实例的函数<br>需要调用全局对象的构造函数用于注册</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(*register_fun)();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCFactory</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> *<span class="title function_">NewInstance</span><span class="params">(<span class="built_in">string</span> class_name)</span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = map_.find(class_name);</span><br><span class="line">    <span class="keyword">if</span>(it == map_.end())&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> it-&gt;second();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">static</span> <span class="type">void</span> <span class="title function_">Register</span><span class="params">(<span class="built_in">string</span> class_name, register_fun func)</span>&#123;</span><br><span class="line">    map_[class_name] = func;</span><br><span class="line">  &#125;</span><br><span class="line">private:</span><br><span class="line">  <span class="type">static</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, register_fun&gt; map_; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, register_fun&gt; CCFactory::map_;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span>&#123;</span></span><br><span class="line">public:</span><br><span class="line">  Register(<span class="built_in">string</span> class_name, register_fun func)&#123;</span><br><span class="line">    CCFactory::Register(class_name, func);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER_CLASS(class_name); \</span></span><br><span class="line"><span class="meta">  const Register class_name_register(#class_name, []()-&gt;void *&#123;return new class_name;&#125;);</span></span><br></pre></td></tr></table></figure>
<h2 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h2><p>const指定一个语义约束，编译器会强制实施这项约束。可以用const在class外部修饰global或namespace作用域中的常量，可以指出指针自身、指针所指物，或者两者都是const。</p>
<ul>
<li><code>char greeting[] = &quot;hello&quot;</code></li>
<li><code>char* p = greeting</code>：non-const pointer，non-const data</li>
<li><code>const char* p = greeting</code>：non-const pointer，const data</li>
<li><code>char* const p = greeting</code>：const point，non-const data</li>
<li><code>const char* const p = greeting</code>：const pointer，const data</li>
</ul>
<p>如果关键字const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针自身是常量。<br>STL迭代器系以指针为根据塑模出来，所以迭代器的作用也像是<code>T*</code>指针，声明迭代器为const表示这个迭代器不得指向不同的东西，但它所指的东西的值是可以改动的。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const std::vector&lt;int&gt;::iterator iter = vec.begin()</span><br><span class="line">可以：*iter=10</span><br><span class="line">不可以：++iter</span><br></pre></td></tr></table></figure></p>
<ul>
<li>const定义接口，防止对返回值误用</li>
<li>const成员函数，代表这个成员函数承诺不会改变对象值，可以操作const对象</li>
<li>两个函数如果只是常量值不同，可以被重载</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class CTextBlock &#123;</span><br><span class="line">public:</span><br><span class="line">	char&amp; operator[](std::size_t position) const</span><br><span class="line">	&#123; return pText[position]; &#125;</span><br><span class="line">private:</span><br><span class="line">	char* pText;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const CtextBlock cctb(&quot;Hello&quot;);</span><br><span class="line">char* pc = &amp;ccb[0];</span><br><span class="line">*pc = &#x27;C&#x27;</span><br></pre></td></tr></table></figure>
<p>这个class不适当的将其operator[]声明为const成员函数，但是该函数却返回一个reference指向对象内部值。<br>上述代码调用了const成员函数，但是允许修改值。</p>
<h3 id="const和non-const成员函数中避免重复"><a href="#const和non-const成员函数中避免重复" class="headerlink" title="const和non-const成员函数中避免重复"></a>const和non-const成员函数中避免重复</h3><p>常量性转除：将常量性消除掉，比如const operator[]实现了non-const版本的一切，唯一不同是其返回类型多了一个const资格修饰。转除的方法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char&amp; operator[] (std::size_t position) &#123;</span><br><span class="line">	return const_cast&lt;char&amp;&gt;(static_cast&lt;const TextBlock&amp;&gt;(*this)[position]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这份代码有两个转型动作，让non_const operator[]调用其const兄弟，而且明确指出调用的是const operator[]，因此第一次为<code>*this</code>添加const，第二次从const operator[]返回值中移除const。</p>
<p>如果在const函数中调用了non-const函数，则打破了不改变其对象的承诺。</p>
<p>const成员只能调用const成员函数(加-fpermissive编译选项就可以了)。<br>非const成员可以调用所有成员函数</p>
<h2 id="确定对象使用前已被初始化"><a href="#确定对象使用前已被初始化" class="headerlink" title="确定对象使用前已被初始化"></a>确定对象使用前已被初始化</h2><p>永远在使用对象之前将其初始化。<br>对于无任何成员的内置类型，需要在定义时初始化，C++不保证初始化它们。</p>
<p>至于内置类型之外的其他，初始化责任落在构造函数上，C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，因此最好使用初始化序列(序列顺序与声明顺序相同)，而不是在构造函数中赋值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::ABEntry(const std::string&amp; name, </span><br><span class="line">				const std::string&amp; address, </span><br><span class="line">				const std::list&lt;PhoneNumber&gt;&amp; phones)</span><br><span class="line">				: theName(name),</span><br><span class="line">				theAddress(address),</span><br><span class="line">				thePhones(phones),</span><br><span class="line">				numTimesConsulted(0)					</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个版本的构造函数效率较高，基于赋值的构造函数首先调用default构造函数为theName，theAddress等设初值，然后再对他们赋值，成员初值列的做法避免了这一问题。</p>
<p>如果有的变量是const或static的，就一定要赋初值，使用初值列，最简单的做法是使用初值列，又比赋值更为高效。</p>
<p>C++有着固定的成员初始化次序，base calss总是早于其derived class被初始化，而class的成员变量总是以其声明次序被初始化。</p>
<h3 id="不同编译单元内定义的non-local-static对象的初始化次序"><a href="#不同编译单元内定义的non-local-static对象的初始化次序" class="headerlink" title="不同编译单元内定义的non-local static对象的初始化次序"></a>不同编译单元内定义的non-local static对象的初始化次序</h3><p>static对象，其寿命从被构造出来直到程序结束为止，这种对象包括global对象，定义于namespace作用域内的对象，在class内、在函数内被声明为static的对象。函数内的static对象称为local static对象，其他的是non-local static对象。</p>
<p>编译单元是指产出同一目标文件的源码，基本上是单一源码文件加上其所含入的头文件。</p>
<p>如果某编译单元内的某个non-local static对象的初始化动作使用了另一编译单元内的某个non-local static对象，它所用到的这个对象可能未被初始化。</p>
<p>C++对不同编译单元内定义的non-local static对象的初始化次序并无规定。</p>
<p>将每个non-local static对象放入一个函数，该对象在函数中被声明为static，这些函数返回一个reference指向它所含的对象，因为C++保证函数内的local static对象会在“函数被调用期间”“首次遇上该对象之定义式”时被初始化。（Singleton模式）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fuck&amp; fuck()&#123;</span><br><span class="line">    static Fuck f;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造/析构/赋值运算"></a>构造/析构/赋值运算</h1><h2 id="了解C-默默编调用了哪些函数"><a href="#了解C-默默编调用了哪些函数" class="headerlink" title="了解C++默默编调用了哪些函数"></a>了解C++默默编调用了哪些函数</h2><p>如果类中没有定义，程序却调用了，编译器会产生一些函数(public且inline)：</p>
<ul>
<li>一个 default 构造函数</li>
<li>一个 copy 构造函数</li>
<li>一个 copy assignment 操作符</li>
<li>一个析构函数(non virtual)</li>
</ul>
<p>default构造函数和析构函数主要是给编译器一个地方用来放置“藏身幕后”的代码，编译器产生的析构函数时non-virtual函数。至于copy和copy assignment函数，单纯将来源对象的每一个non-static成员变量拷贝到目标对象。</p>
<p>如果要在一个内含reference成员的class内支持赋值操作，则必须自己定义一个copy assignment操作，因为reference不能随意的重新赋值。因此，含有引用成员变量或者const成员变量不产生赋值操作符。</p>
<p>如果自己构造了带参数的构造函数，编译器不会产生default构造函数。</p>
<p>base class如果把拷贝构造函数或者赋值操作符设置为private，则不会产生这两个函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Fuck&#123;</span><br><span class="line">private:</span><br><span class="line">    std::string&amp; str;//引用定义后不能修改绑定对象</span><br><span class="line">    const std::string con_str;//const对象定义后不能修改</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="若不想使用编译器自动生成的函数，就该明确拒绝"></a>若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>将默认生成的函数声明为private，由明确声明一个成员函数，阻止编译器自动生成。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Uncopyable&#123;</span><br><span class="line">private:</span><br><span class="line">    Uncopyable(const Uncopyable&amp;);</span><br><span class="line">    Uncopyable&amp; operator= (const Uncopyable&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="为多态基类声明virtual析构函数"><a href="#为多态基类声明virtual析构函数" class="headerlink" title="为多态基类声明virtual析构函数"></a>为多态基类声明virtual析构函数</h2><p>当derived class对象经由一个base calss指针被删除，而该base class自带一个non-virtual析构函数，其结果未有定义，实际执行时通常发生的是对象的derived成分未被删除，而derived class的析构函数也未被执行。</p>
<p>因此给多态基类应该主动声明virtual析构函数。非多态基类，没有virtual函数，不要声明virtual析构函数。</p>
<p>欲实现出virtual函数，对象必须携带某些信息用来在运行期决定那一个virtual函数被调用，通常是由一个vptr指针指出，它指向一个由函数指针构成的数组，成为vtbl，每一个带有virtual函数的class都有一个vtbl。</p>
<p>如果class中带有virtual函数，则对象的体积会增加，因此当class内至少一个virtual函数，才为它声明virtual析构函数。</p>
<p>pure virtual函数导致abstract class——也就是不能被实体化的class。为希望成为抽象的那个class提供一个pure virtual析构函数，并为析构函数提供一份定义。</p>
<p>析构函数的运作：最深层派生的那个class其析构函数最早被调用，然后是其每一个base calss的析构函数被调用。</p>
<h2 id="别让异常逃离析构函数"><a href="#别让异常逃离析构函数" class="headerlink" title="别让异常逃离析构函数"></a>别让异常逃离析构函数</h2><p>构造函数可以抛出异常，析构函数不能抛出异常。</p>
<p>因为析构函数有两个地方可能被调用。一是用户调用，这时抛出异常完全没问题。二是前面有异常抛出，正在清理堆栈，调用析构函数。这时如果再抛出异常，两个异常同时存在，异常处理机制只能terminate()。</p>
<p>构造函数抛出异常，会有内存泄漏吗？<br>不会！<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    // 第二步，调用构造函数构造对象</span><br><span class="line">    new (p)T;       // placement new: 只调用T的构造函数</span><br><span class="line">&#125;</span><br><span class="line">catch(...) &#123;</span><br><span class="line">    delete p;     // 释放第一步分配的内存</span><br><span class="line">    throw;          // 重抛异常，通知应用程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="绝不在构造和析构过程中调用virtual函数"><a href="#绝不在构造和析构过程中调用virtual函数" class="headerlink" title="绝不在构造和析构过程中调用virtual函数"></a>绝不在构造和析构过程中调用virtual函数</h2><p>derived calss对象的base class成分会在derived class自身成分被构造之前先妥善构造，如果在构造base class成分之后即调用virtual function，则这个virtual function指向的可能是base class中的function，不是derived class中的function，即在base class构造期间，virtual函数不是virtual函数。</p>
<p>构造和析构过程中，虚表指针指向的虚表在变化。调用的是对应虚表指针指向的函数。</p>
<p>一种可行的做法是：在base class中将函数改为non-virtual函数，然后要求derived class构造函数传递必要信息给base class构造函数，而后那个构造函数会安全地调用non-virtual的函数。</p>
<h2 id="令operator-返回一个reference-to-this"><a href="#令operator-返回一个reference-to-this" class="headerlink" title="令operator= 返回一个reference to *this"></a>令operator= 返回一个reference to <code>*this</code></h2><p>连锁赋值：赋值操作符必须返回一个reference指向操作符的左侧实参。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; operator=(const Widget&amp; rhs) &#123;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="在operator-里处理自我赋值"><a href="#在operator-里处理自我赋值" class="headerlink" title="在operator= 里处理自我赋值"></a>在operator= 里处理自我赋值</h2><p>传统做法是借由operator=最前面的一个“证同测试”达到“自我赋值”的检验目的<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::operator== (const Widget&amp; rhs)&#123;</span><br><span class="line">    if(this == &amp;rhs) return *this</span><br><span class="line">    </span><br><span class="line">    delete pb;</span><br><span class="line">    pb = new Bitmap(*rhs.pb);</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>或者使用copy and swap技术：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::operator== (const Widget&amp; rhs) &#123;</span><br><span class="line">	Widget temp(rsh);</span><br><span class="line">	swap(temp);   // 将this同上述复件的副本交换</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其原理是某class的copy assignment操作符可能被声明为“以by value的方式接受实参”；以by value方式传递东西会生成一份复件</p>
<h2 id="复制对象时务忘其每一个成分"><a href="#复制对象时务忘其每一个成分" class="headerlink" title="复制对象时务忘其每一个成分"></a>复制对象时务忘其每一个成分</h2><p>记得实现拷贝构造函数和赋值操作符的时候，调用base的相关函数<br>可以让拷贝构造函数和赋值操作符调用一个共同的函数，例如init()<br>如果为derived class撰写copying 函数，必须也很小心地复制其base class成分，应该让derived class的copying函数调用相应的base class。</p>
<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="以对象管理资源"><a href="#以对象管理资源" class="headerlink" title="以对象管理资源"></a>以对象管理资源</h2><p>为了确保资源总是被释放，需要将资源放进对象内，当控制流离开函数，对象的析构函数将自动释放那些资源，这实际上是依赖了C++的“析构函数自动调用机制”。<br>auto_ptr正是用于在控制流离开函数时释放对象用的，其析构函数自动对其所指的对象调用delete。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void f() &#123;</span><br><span class="line">	std::auto_ptr&lt;Investment&gt; pInv(createInvestment());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>获得资源后立刻放进管理管理对象，createInvestment()返回的资源被当作其管理者auto_ptr的初值，实际上“以对象管理资源”的观念被称为“资源取得时机便是初始化时机（RAII）”</li>
<li>管理对象运用析构函数确保资源被释放。不论控制流如何离开函数，一旦对象被销毁其析构函数自然会被调用，于是资源被释放。</li>
<li>别让多个auto_ptr同时指向同一对象，这样的话对象会被删除一次以上。所以它并不是管理动态分配资源的利器。</li>
</ul>
<p>auto_ptr的替代方案是“引用计数型智慧指针（RCSP）”，持续追踪共有多少对象指向某笔资源，并在无人指向它时自动删除该对象，类似垃圾回收，但是无法打破环状引用。</p>
<p>shared_ptr是RCSP<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment());</span><br></pre></td></tr></table></figure></p>
<p>auto_ptr和tr1::shared_ptr两者都在其析构函数内做delete而不是delete[]动作，在动态分配而得的array身上使用auto_ptr或tr1::shared_ptr不可以，还是使用vector或者string吧。</p>
<h2 id="在资源管理类小心copy行为"><a href="#在资源管理类小心copy行为" class="headerlink" title="在资源管理类小心copy行为"></a>在资源管理类小心copy行为</h2><p>常见的RAII对象copy行为：</p>
<ul>
<li>禁止copy：可以将copying操作声明为private</li>
<li>引用计数：保有资源直到它的最后一个使用者被销毁</li>
</ul>
<p>tr1::shared_ptr允许指定所谓的“删除器”，那是一个函数或函数对象，当引用次数为0时便被调用。</p>
<ul>
<li>深度复制：复制资源管理对象也要复制其包覆的资源</li>
<li><p>转移底部资源拥有权：某些场景下可能希望确保永远只有一个RAII对象指向一个未加工资源，即使RAII对象被复制之后依然如此。</p>
</li>
<li><p>复制RAII对象必须一并赋值它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</p>
</li>
<li>普遍而常见的RAII class copying行为是：抑制copying，实行引用计数法。</li>
</ul>
<h2 id="在资源管理类中提供对原始资源的访问"><a href="#在资源管理类中提供对原始资源的访问" class="headerlink" title="在资源管理类中提供对原始资源的访问"></a>在资源管理类中提供对原始资源的访问</h2><p>如果需要一个<code>Investment*</code>指针，但是函数返回一个tr1::shared_ptr<Investment>对象，则需要一个函数将RAII class对象转换为其所含的原始资源。</p>
<ul>
<li>提供显示调用接口：auto_ptr和tr1::shared_ptr都提供一个get成员函数，用来执行显式转换。</li>
<li>提供隐式转换接口(不推荐)：auto_ptr和tr1::shared_ptr也重载了指针取值操作符（<code>operator-&gt;</code>和<code>operator*</code>）</li>
</ul>
<h2 id="成对使用new和delete要采用相同的格式"><a href="#成对使用new和delete要采用相同的格式" class="headerlink" title="成对使用new和delete要采用相同的格式"></a>成对使用new和delete要采用相同的格式</h2><p>当使用new时，两件事发生：内存被分配出来，针对此内存会有多个构造函数被调用。当使用delete时，也有两件事发生：针对此内存会有一个或多个析构函数被调用，然后内存被释放。</p>
<p>分清即将被释放的内存是单一对象还是对象数组？即保证new和delete对应；new []和delete []对应。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在分配的内存块前面还分配了4个字节代表数组的个数</span><br><span class="line">int *A = new int[10];</span><br><span class="line"></span><br><span class="line">//在分配的内存块前面分配了8个字节，分别代表对象的个数和Object的大小</span><br><span class="line">Object *O = new Object[10];</span><br></pre></td></tr></table></figure></p>
<h2 id="以独立的语句将newd对象置入智能指针"><a href="#以独立的语句将newd对象置入智能指针" class="headerlink" title="以独立的语句将newd对象置入智能指针"></a>以独立的语句将newd对象置入智能指针</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int priority();</span><br><span class="line">void processWidget(std::tr1::shared_ptr&lt;Widget&gt; pw, int priority)；</span><br></pre></td></tr></table></figure>
<p>在<code>processWidget(new Widget, priority())</code>函数中，tr1::shared_ptr需要一个原始指针，但是该构造函数是个explicit构造函数，无法进行隐式转换，将得自new Widget的原始指针转换为processWidget所要求的tr1::shared_ptr。可以写成这样：<br><code>processWidget(std::tr1::shared_ptr&lt;Widget&gt;(new Widget), priority())</code></p>
<p>但是在调用processWidget之前，需要做以下三件事：</p>
<ul>
<li>调用priority()</li>
<li>执行new Widget</li>
<li>调用tr1::shared_ptr构造函数</li>
</ul>
<p>万一对priority调用导致异常，new Widget返回的指针会遗失，因为它尚未被置入tr1::shared_ptr内。避免这类问题只需要使用分离语句：</p>
<ul>
<li><code>std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget)</code></li>
<li><code>processWidget(pw, priority())</code></li>
</ul>
<h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><h2 id="让接口容易被正确使用，不易被误用"><a href="#让接口容易被正确使用，不易被误用" class="headerlink" title="让接口容易被正确使用，不易被误用"></a>让接口容易被正确使用，不易被误用</h2><p>好的接口很容易被正确使用，不容易被误用。努力达成这些性质(例如 explicit关键字)<br>明智而审慎地导入新类型对预防“接口被误用”有奇效。例如，一年只有12个有效月份，因此class Month应该反应这一事实，办法之一是利用enum表现月份，或者预先定义所有有效的Month：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Month &#123;</span><br><span class="line">public:</span><br><span class="line">	static Month Jan() &#123; return Month(1); &#125;</span><br><span class="line">	static Month Feb() &#123; return Month(2); &#125;</span><br><span class="line">	static Month Mar() &#123; return Month(3); &#125;</span><br><span class="line">	...</span><br><span class="line">	static Month Dec() &#123; return Month(12); &#125;</span><br><span class="line">private:</span><br><span class="line">	explicit Month(int m);</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line">Date d(Month::Mar(), Day(30), Year(1995))</span><br></pre></td></tr></table></figure><br>tr1::shared_ptr提供地某个构造函数接受两个实参，一个是被管理的指针，一个是引用次数变为0的时候将被调用的“删除器”，这启发我们创建一个null tr1::shared_ptr并以某函数变为其删除器。</p>
<p>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容<br>“防治误用”包括建立新类型，限制类型上的操作，束缚对象值，以及消除用户的资源管理责任<br>shared_ptr支持定制deleter，需要灵活使用</p>
<h2 id="设计class犹如设计type"><a href="#设计class犹如设计type" class="headerlink" title="设计class犹如设计type"></a>设计class犹如设计type</h2><ul>
<li>新type的对象应该如何被创建和销毁？构造函数和析构函数应该好好设计</li>
<li>对象的初始化和赋值应该有什么区别？</li>
<li>新type的对象如果被pass-by-value该如何？</li>
<li>什么是新type的合法值？维护约束条件</li>
<li>新type需要配合某个继承图系么？如果继承自某些既有的class，就需要受到那些class设计的限制，特别是受到“他们的函数是virtual或者non-virtual的”</li>
<li>新type需要什么样的转换？是否需要在class T1内写一个class T2的类型转换函数</li>
</ul>
<h2 id="宁以pass-by-refrence-to-const替换pass-by-value"><a href="#宁以pass-by-refrence-to-const替换pass-by-value" class="headerlink" title="宁以pass-by-refrence-to-const替换pass-by-value"></a>宁以pass-by-refrence-to-const替换pass-by-value</h2><p>缺省情况下C++以by-value的方式传递对象到函数，除非另外指定，否则参数都是以实际实参的复件为初值。<br>尽量以pass-by-reference-to-const替换pass-by-value，比较高效，无需调用额外的copy构造函数或者构造函数/析构函数，加入了const也避免了可能的修改。</p>
<p>避免切割问题：当一个derived class对象以by-value的方法传递并被视为一个base class对象，调用base class的构造函数使得derived class的特性被切割，pass-by-refrence-to-const避免了这一问题。</p>
<p>references往往以指针的形式实现，因此pass-by-refrence-to-const真正传递的是指针。pass-by-value比pass-by-refrence-to-const效率高些，尤其是对内置类型而言。</p>
<p>以上规则并不适用内置类型，以及STL迭代器，和函数对象。它们采用pass-by-value更合适(其实采用pass-by-reference-to-const也可以)</p>
<h2 id="必须返回对象时，别妄想返回其reference"><a href="#必须返回对象时，别妄想返回其reference" class="headerlink" title="必须返回对象时，别妄想返回其reference"></a>必须返回对象时，别妄想返回其reference</h2><p>如果定义一个local变量，就是在stack上，不要返回pointer或者reference指向一个on stack对象，在函数返回时就被析构。<br>不要返回pointer或者reference指向一个on heap对象(需要用户delete，我觉得必要的时候也不是不可以)<br>不要返回pointer或者reference指向local static对象，却需要多个这样的对象(static只能有一份)</p>
<p>让诸如<code>operator*</code>这样的函数返回reference，只是浪费时间吧。</p>
<p>一个必须返回新对象的函数的正确写法：让那个函数返回一个新对象，例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline const Rational operator*(const Rational &amp;lhs, const Rational &amp;rhs) &#123;</span><br><span class="line">	return Rational(lhs.n*rhs.n, lhs.d*rhs.d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当然，这样需要承受构造成本和析构成本。</p>
<h2 id="将成员变量申明为private"><a href="#将成员变量申明为private" class="headerlink" title="将成员变量申明为private"></a>将成员变量申明为private</h2><p>切记将成员变量申明为private，使用getter和setter实现对private变量的操作，将成员变量隐藏在函数接口的背后。<br>protected并不比public更有封装性(用户可能继承你的base class)</p>
<h2 id="宁以non-member，non-friend替换member"><a href="#宁以non-member，non-friend替换member" class="headerlink" title="宁以non-member，non-friend替换member"></a>宁以non-member，non-friend替换member</h2><p>作者说多一个成员函数，就多一分破坏封装性，好像有点道理，但是我们都没有这样遵守。直接写member函数方便一些。<br>面向对象守则要求，数据以及操作数据的那些函数应该捆绑在一起，这意味着建议member函数是合适的，但是提供non-member函数可允许对相关机能有更好的封装性。</p>
<h2 id="若所有参数都需要类型转换，请为此采用non-member函数"><a href="#若所有参数都需要类型转换，请为此采用non-member函数" class="headerlink" title="若所有参数都需要类型转换，请为此采用non-member函数"></a>若所有参数都需要类型转换，请为此采用non-member函数</h2><p>如果调用member函数，就使得第一个参数的类失去一次类型转换的机会。<br>当实现一个Rational类时，（构造函数刻意不为explicit，允许int-to-Rational的隐式转换。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Rational &#123;</span><br><span class="line">public:</span><br><span class="line">	Rational(int numerator = 0,</span><br><span class="line">			int denominator = 1);</span><br><span class="line">	int numerator() const;</span><br><span class="line">	int denominator() const;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rational oneEight(1, 8), oneHalf(1, 2);</span><br><span class="line">Rational result = oneHalf * oneEight; // 正确</span><br></pre></td></tr></table></figure><br>如果希望能实现混合运算，即：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf * 2; // 正确</span><br><span class="line">result = 2 * oneHalf; // 错误</span><br></pre></td></tr></table></figure><br>上述两式变成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf.operator*(2);</span><br><span class="line">result = 2.operator*(oneHalf);</span><br></pre></td></tr></table></figure><br>这里第二个式子之所以会出错，是因为发生了隐式类型转换，编译器知道正在传递一个int，但是函数需要的是Rational，而且它也知道只要调用Rational的构造函数并赋予所提供的int即可，但是这样是不对的。</p>
<p>只有当参数被列于参数列表，这个参数才是隐式类型转换的合格参与者。让<code>operator*</code>成为一个non-member函数，允许在每一个实参上执行隐式类型转换。</p>
<h2 id="考虑写一个不抛出异常的swap函数"><a href="#考虑写一个不抛出异常的swap函数" class="headerlink" title="考虑写一个不抛出异常的swap函数"></a>考虑写一个不抛出异常的swap函数</h2><p>std::swap置换两对象值，只要类型T支持copying（通过copy构造函数和copy assignment操作符完成）缺省的swap代码就会帮你置换类型为T的对象。</p>
<p>一种方法是“以指针指向一个对象，内含真正数据”，一旦要置换两个对象值，唯一要做的事置换其指针，但缺省的swap函数不知道这一点，将swap函数针对该类特化。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">namespace std &#123;</span><br><span class="line">	template&lt;&gt;</span><br><span class="line">	void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123;</span><br><span class="line">		swap(a.pImpl, b.pImpl);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数一开始的template&lt;&gt;表示它是std::swap的一个全特化版本，函数名称后的<Widget>代表针对这一类<Widget>特化。</p>
<p>当std::swap效率不高(std::swap调用拷贝构造函数和赋值操作符，如果是深拷贝，效率不会高)，提供一个swap成员函数，并确定不会抛出异常。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Obj&#123;</span><br><span class="line">    Obj(const Obj&amp;) &#123;</span><br><span class="line">    	//深拷贝</span><br><span class="line">    &#125;</span><br><span class="line">    Obj&amp; operator= (const Obj&amp;) &#123;</span><br><span class="line">    	//深拷贝</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    OtherClass *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如果提供一个member swap做置换工作，然后将std::swap特化，令他调用该函数<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">	void swap(Widget&amp; other) &#123;</span><br><span class="line">		std::swap(pImpl, other.pImpl);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">namespace std &#123;</span><br><span class="line">	template&lt;&gt;</span><br><span class="line">	void swap&lt;Widget&gt; (Widget&amp; a, Widget b) &#123;</span><br><span class="line">		a.swap(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>调用swap时应该针对std::swap使用using声明式，然后调用swap不带任何”命名空间修饰”<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void doSomething(Obj&amp; o1, Obj&amp; o2)&#123;</span><br><span class="line">    //这样可以让编译器自己决定调用哪个swap，万一用户没有实现针对Obj的swap，还能调用std::swap</span><br><span class="line">    using std::swap;</span><br><span class="line">    </span><br><span class="line">    swap(o1, o2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果swap缺省实现的效率不足，则：</p>
<ol>
<li>提供一个public swap成员函数，让它高效地置换那个类型的两个对象值；</li>
<li>在你的class或namespace所在的命名空间中提供一个non-member swap，并令它调用上述swap成员函数；</li>
<li>如果正在编写一个class，为class特化一个std::swap，并令他调用你的swap成员函数；</li>
<li>如果调用swap，请确定包含一个using声明式，以便让std::swap在你的函数内曝光可见，然后不加任何namespace修饰符，赤裸裸的调用swap；</li>
<li>成员版swap不可抛出异常。</li>
</ol>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="尽可能延后变量定义式出现的时间"><a href="#尽可能延后变量定义式出现的时间" class="headerlink" title="尽可能延后变量定义式出现的时间"></a>尽可能延后变量定义式出现的时间</h2><p>C语言推荐在函数开始的时候定义所有变量(最开始的C语言编译器要求，现在并不需要)，C++推荐在使用对象前才定义对象，尽量延后变量的定义，直到确实需要它，避免没有用到这个变量但是却承担了构造和析构成本。<br>不止延后到真正使用这个变量，而且要延后到能够给这个变量一个初值实参为止，如果这样，不仅能避免构造和析构非必要对象，还能避免无意义的default构造行为。</p>
<h2 id="尽量少做转型动作"><a href="#尽量少做转型动作" class="headerlink" title="尽量少做转型动作"></a>尽量少做转型动作</h2><p>转型的语法:</p>
<p>旧式转型：</p>
<ul>
<li>(T)expression</li>
<li>T(expression)</li>
</ul>
<p>新式转型：</p>
<ul>
<li>const_cast<T> (expression)：用来将对象的常量性移除；</li>
<li>dynamic_cast<T> (expression)：执行安全向下转型，用来决定对象是不是归属继承体系的某个类型；</li>
<li>reinterpret_cast<T> (expression)：低级转型，例如将一个pointer to int转型为一个int；</li>
<li>static_cast<T> (expression)：强迫隐式转换，例如将non-const转为const，将int转为double等，但无法将const转为non-const。</li>
</ul>
<p>例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d;</span><br></pre></td></tr></table></figure><br>这里建立一个base calss指针指向一个derived class对象，但是有时候上述两个指针并不相同，这时会有一个偏移量在运行期被施加到Derived指针上，用以取得正确的Base指针。因此，单一对象可能拥有一个以上的指针。</p>
<p>如果想要在子类中执行父类的函数，可以如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class SpecialWindow : public Window &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void onResize() &#123;</span><br><span class="line">		Window::onResize();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。<br>之所以需要dynamic_cast是因为想要在一个你认为是derived class对象身上执行derived class操作函数，但是你手上只有一个指向base的pointer，有两个一般的方法可以解决这个问题：</p>
<ol>
<li>使用容器并在其中直接存储指向derived class对象的指针，如此便消除了通过base class接口处理对象的需要。</li>
<li>在base class中提供virtual函数做你想对各个派生类做的事。</li>
</ol>
<ul>
<li>如果转型是必要的，试着将它隐藏于某个函数后。客户可以随时调用该函数，而不需要将转型放入自己的代码。</li>
<li>使用C++风格的转型。</li>
</ul>
<h2 id="避免返回handles指向对象内部成分"><a href="#避免返回handles指向对象内部成分" class="headerlink" title="避免返回handles指向对象内部成分"></a>避免返回handles指向对象内部成分</h2><p>成员变量的封装性最多等于“返回其reference的函数”的访问级别。<br>如果const成员函数传出一个reference，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。<br>简单说，就是成员函数返回指针或者非const引用不要指向成员变量，这样会破坏封装性</p>
<h2 id="为“异常安全”而努力是值得的"><a href="#为“异常安全”而努力是值得的" class="headerlink" title="为“异常安全”而努力是值得的"></a>为“异常安全”而努力是值得的</h2><p>当异常被抛出时，异常安全性函数会：</p>
<ul>
<li>不泄露任何资源</li>
<li>不允许数据破坏</li>
</ul>
<p>“异常安全函数”承诺即使发生异常也不会有资源泄漏。在这个基础下，它有3个级别</p>
<ul>
<li>基本保证：抛出异常，程序内的任何事物仍然保持在有效状态下，没有对象或数据结构会被破坏，所有对象处于一种内部前后一致的状态。需要用户处理程序状态改变(自己写代码保证这个级别就行了把)</li>
<li>强烈保证：抛出异常，程序状态不改变，如果函数失败，程序状态恢复到调用前；</li>
<li>不抛异常：承诺绝不抛出异常，因为他们总是能完成原先承诺的任务。内置类型的操作就绝不会抛出异常</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class PrettyMenu &#123;</span><br><span class="line">	std::tr1::shared_ptr&lt;Image&gt; bgImage;</span><br><span class="line">&#125;;</span><br><span class="line">void PrettyMenu::changeBackground(std::istream&amp; imgSrc) &#123;</span><br><span class="line">	Lock ml(&amp;mutex);</span><br><span class="line">	bgImage.reset(new Image(imgSrc));</span><br><span class="line">	++imageChange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码使用一个用于资源管理的智能指针，重新排列了changeBackground的语句次序，使得在更换图像之后才累加imageChanges，一般而言这是个好策略，不要为了表示某件事发生而改变对象状态，除非这件事真的发生了。</p>
<p>另外，使用了Lock使得不需要在末尾手动unlock，在析构函数中已经自动unlock。使用智能指针也不需要再手动delete旧图像。</p>
<p>“强烈保证”往往可以通过copy-and-swap实现，为你打算修改的对象原件做一份副本，然后在那份副本上做修改，若有任何修改动作抛出异常，原对象仍保持未修改状态，待所有修改完成后再将修改后的副本和原对象在一个不抛出异常的操作中置换。</p>
<p>但是”强烈保证”并非对所有函数都具有实现意义<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void doSomething(Object&amp; obj)&#123;</span><br><span class="line">    Object new_obj(obj);</span><br><span class="line">    new_obj++;</span><br><span class="line">    swap(obj, new_obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="透彻了解inline函数的里里外外"><a href="#透彻了解inline函数的里里外外" class="headerlink" title="透彻了解inline函数的里里外外"></a>透彻了解inline函数的里里外外</h2><p>“免除函数调用成本”<br>当你inline某个函数，编译器或许可以对函数本体执行语境相关最优化，大部分编译器绝不会对着一个outline函数调用动作执行如此优化。<br>inline函数将“对此函数的每一个调用都用函数本体替换之”，这样做可能增加目标码的大小，即使拥有虚内存，inline造成的代码膨胀亦会造成额外的<strong>换页</strong>行为，降低指令高速缓存的命中率，以及伴随而来的效率损失。</p>
<p>inline只是对编译器的一个申请而不是强制命令。这项申请可以隐喻指出，也可以明确提出。隐喻方式是将函数定义于class定义式内：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	int age() const &#123;return theAge; &#125;</span><br><span class="line">private:</span><br><span class="line">	int theAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>明确声明inline的做法则是在其定义式前加上关键字inline：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline const T&amp; std::max(const T&amp; a, const T&amp; b) &#123;</span><br><span class="line">	return a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>inline函数通常被定义在头文件中，因为大多数build环境在编译过程中进行inlining，而为了将一个“函数调用”替换为“被调用函数本体”，编译器必须知道那个函数长啥样，某些build环境可以在链接的时候完成inline。<br>大部分编译器拒绝将太过复杂的函数inlining，而所有对virtual函数的调用都会使inline落空。<br>一个表面上看似inline的函数是否真的inline，取决于你的编译环境，主要取决于编译器。<br>构造函数和析构函数如果inline的话很麻烦。<br>inline无法随着程序库的升级而升级，换句话说如果f是程序库内的一个inline函数，客户将f函数本体编译进代码，一旦程序库改变，所有用到f的函数都需要重新编译。如果f是non-inline函数，则只需要重新编译f就好。</p>
<p>这里插播一个C++处理定义的重要原则，一处定义原则：</p>
<p>全局变量，静态数据成员，非内联函数和成员函数只能整个程序定义一次<br>类类型(class，struct,union)，内联函数可以每个翻译单元定义一次</p>
<h2 id="将文件的编译依存关系降到最低"><a href="#将文件的编译依存关系降到最低" class="headerlink" title="将文件的编译依存关系降到最低"></a>将文件的编译依存关系降到最低</h2><p>C++并没有将接口从实现中分离。在定义文件和其含入文件之间形成了一种编译依存关系。如果头文件中有任何一个被改变或者这些头文件依赖的任何一个头文件改变，则任何使用这个类的文件都需要重新编译。</p>
<p>当编译器看到一个定义式时，它必须知道要给这个定义式分配多少内存才够维持一个对象，这个问题在Java里并不存在，因为Java编译器只分配一个足够指向该对象的指针那么大的空间。</p>
<p>支持”编译依存最小化”的一般构想是：相依于声明式，不要相依于定义式；现实中要让头文件尽可能地自我满足，万一做不到则让它与其他文件中的声明式相依。基于此构想的两个手段是Handle classes(impl对象提供服务)和Interface classes。<br>其实就是使用前置声明，在main class中只有一个指针指向其实现类，这样的设计使得那些classes的修改都不需要main class重新编译。</p>
<ul>
<li>如果使用object reference或者object pointer可以完成任务，则就不要使用object</li>
<li>如果能够，尽量以class声明式替换class定义式</li>
<li>为声明式和定义式提供不同的头文件，当然这些文件要保持一致性。</li>
</ul>
<p>制作handler class的办法是，令基函数成为abstract baseclass， 称为interface class，这种函数的目的是详细叙述derived class的接口，因此它通常不带成员变量，只有一个virtual析构函数和一组pure virtual函数。一个针对Person而写的interface class也许是这样的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual ~Persion();</span><br><span class="line">	virtual std::string name() const = 0;</span><br><span class="line">	virtual std::string date() const = 0;</span><br><span class="line">	virtual std::string address() const = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不可能针对“内含pure virtual函数”的Person class具现出实例。</p>
<p>interface class的客户必须有办法为这种class创建新对象。他们调用一个特殊函数，此函数扮演真正将被具现化的derived class的构造函数的角色，这样的函数通常称为“工厂函数”。他们返回指针，指向动态分配所得对象，而该对象支持interface class的接口，这样的函数又往往在interface class中被声明为static：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Persion &#123;</span><br><span class="line">public:</span><br><span class="line">	static std::tr1::shared_ptr&lt;Person&gt; create(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string name;</span><br><span class="line">Date dateOfBirth;</span><br><span class="line">Address address;</span><br><span class="line"></span><br><span class="line">std::tr1::shared_ptr&lt;Person&gt; pp(Person::create(name, dateOfBirth, address));</span><br></pre></td></tr></table></figure><br>支持interface class接口的那个具象类必须被定义出来，而且真正的构造函数必须被调用。一切都在virtual构造函数实现码所在的文件内秘密发生。假设interface class Person有个具象的derived class RealPerson，后者提供继承而来的virtual函数的实现。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class RealPerson: public Person &#123;</span><br><span class="line">public:</span><br><span class="line">	RealPerson(const std::string&amp; name, const Date&amp; birthday, const Address&amp; addr) : theName(name), theBirthDate(birthday), theAddress(addr) &#123;&#125;</span><br><span class="line">	virtual ~RealPerson();</span><br><span class="line">	std::string name();</span><br><span class="line">	std::string date();</span><br><span class="line">	std::string address();</span><br><span class="line">private:</span><br><span class="line">	std::string theName;</span><br><span class="line">	Date theBirthDate;</span><br><span class="line">	Address theAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有了RealPerson后，写出Person::create就顺理成章了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::tr1::shared_ptr&lt;Person&gt; Person::create(onst std::string&amp; name, const Date&amp; birthday, const Address&amp; addr) &#123;</span><br><span class="line">	return std::tr1::shared_ptr&lt;Person&gt;(new RealPerson(name, birthday, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在handler class上，成员函数必须通过implementation pointer取得对象数据，那会为每一次访问增加一层间接性，而每一个对象消耗的内存数量必须增加。至于interface class，由于每一个函数都是virtual，必须为每次函数调用付出一个间接跳跃的成本。</p>
<p>下面有个需要注意的点<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Obj.h</span><br><span class="line">class ObjImpl;</span><br><span class="line">class Obj&#123;</span><br><span class="line">public:</span><br><span class="line">private:</span><br><span class="line">    std::shared_ptr&lt;ObjImpl&gt; pObjImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>上面的写法会报错，因为编译器会再.h文件里面产生默认的析构函数，<br>析构函数要调用ObjImpl的析构函数，然后我们现在只有声明式，不能调用ObjImpl的实现。<br>下面的实现才是正确的<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Obj.h</span><br><span class="line">class ObjImpl;</span><br><span class="line">class Obj&#123;</span><br><span class="line">public:</span><br><span class="line">    //声明</span><br><span class="line">    ~Obj();</span><br><span class="line">private:</span><br><span class="line">    std::shared_ptr&lt;ObjImpl&gt; pObjImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Obj.cpp</span><br><span class="line">//现在可以看到ObjImpl的实现</span><br><span class="line">#include&lt;ObjImpl&gt;</span><br><span class="line">	Obj::~Obj()&#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="继承与面对对象设计"><a href="#继承与面对对象设计" class="headerlink" title="继承与面对对象设计"></a>继承与面对对象设计</h1><h2 id="确定你的public继承塑模出is-a模型"><a href="#确定你的public继承塑模出is-a模型" class="headerlink" title="确定你的public继承塑模出is-a模型"></a>确定你的public继承塑模出is-a模型</h2><p>public继承意味着is-a。适用于base class身上的每一个函数也一定适用于derived class。<br>令class D以public形式继承class B，便是告诉C++编译器每一个类型为D的对象同时也是一个类型为B的对象，反之不成立。</p>
<h2 id="避免遮掩继承而来的名称"><a href="#避免遮掩继承而来的名称" class="headerlink" title="避免遮掩继承而来的名称"></a>避免遮掩继承而来的名称</h2><p>当位于一个derived class成员函数内指涉base class内的某物的时候，编译器可以找到我们所指涉的东西，因为derived class继承了声明于base class的所有东西。实际运作方式是derived class作用域被嵌套进base class作用域内。</p>
<p>如果继承base class并加上重载函数，而你又希望重新定义或覆写其中一部分，那么你必须为那些原本会被遮掩的每个名称引入一个using声明式，否则某些你希望继承的名称会被遮掩。    </p>
<p>子作用域会遮掩父作用域的名称。一般来讲，我们可以有以下几层作用域</p>
<ul>
<li>global作用域</li>
<li>namespace作用域</li>
<li>Base class作用域</li>
<li>Derived class作用域</li>
<li>成员函数</li>
<li>控制块作用域</li>
</ul>
<p>注意：遮掩的是上一层作用域的名称，重载(不同参数)的函数也会直接遮掩<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">    void f1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Drive&#123;</span><br><span class="line">public:</span><br><span class="line">    //会遮掩f1()，子类并没有继承f1()</span><br><span class="line">    void f1(int);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Drive d;</span><br><span class="line">d.f1();  //错误</span><br><span class="line">d.f1(3); //正确</span><br></pre></td></tr></table></figure><br>可以通过using声明式或者inline转交解决这一问题<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">    void f1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//using 声明式</span><br><span class="line">class Drive&#123;</span><br><span class="line">public:</span><br><span class="line">    using Base::f1;</span><br><span class="line">    void f1(int);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//inline转交</span><br><span class="line">class Drive&#123;</span><br><span class="line">public:</span><br><span class="line">    void f1()&#123;</span><br><span class="line">        Base::f1();</span><br><span class="line">    &#125;</span><br><span class="line">    void f1(int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="区分接口继承和实现继承"><a href="#区分接口继承和实现继承" class="headerlink" title="区分接口继承和实现继承"></a>区分接口继承和实现继承</h2><p>public继承由两部分组成，一个是函数接口继承，一个是函数实现继承。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">	public:</span><br><span class="line">	virtual void draw() const = 0;</span><br><span class="line">	virtual void error(const std::string&amp; msg);</span><br><span class="line">	int objectID() const;</span><br><span class="line">&#125;;</span><br><span class="line">class Rectangle: public Shape &#123; ... &#125;;</span><br><span class="line">class Ellipse: public Shape &#123; ... &#125;;</span><br></pre></td></tr></table></figure><br>Shape是个抽象类，它的pure virtual函数draw使它成为一个抽象类，所以只能创建其derived class的对象。draw是个纯虚函数，error是个impure virtual函数，objectID是个non-virtual函数。</p>
<p>pure函数必须被任何“继承了它们”的class重新声明，且它们在抽象类中没有定义，所以声明一个纯虚函数的目的是让derived class只继承函数接口。竟然可以为纯虚函数提供定义，只是在调用时要指明。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Shape* ps = new Shape;</span><br><span class="line">shape* ps1 = new Rectangle;</span><br><span class="line">ps1-&gt;draw();</span><br><span class="line">ps1-&gt;Shape::draw();</span><br></pre></td></tr></table></figure><br>虚函数会提供一份定义代码，derived class可以覆写它，声明虚函数的目的是让derived class继承该函数的接口和缺省实现。<br>继承non-virtual函数的目的是让derived class继承函数的接口和一份强制实现。</p>
<p>纯虚函数：提供接口继承<br>Drived class必须实现纯虚函数<br>不能构造含有纯虚函数的类</p>
<h2 id="考虑virtual函数以外的选择"><a href="#考虑virtual函数以外的选择" class="headerlink" title="考虑virtual函数以外的选择"></a>考虑virtual函数以外的选择</h2><h3 id="借由non-virtual-interface实现template-method模式"><a href="#借由non-virtual-interface实现template-method模式" class="headerlink" title="借由non-virtual interface实现template method模式"></a>借由non-virtual interface实现template method模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Object&#123;</span><br><span class="line">public:</span><br><span class="line">    void Interface()&#123;</span><br><span class="line">        ···</span><br><span class="line">        doInterface()；</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">private/protected:</span><br><span class="line">    virtual doInterface()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让用户通过调用public non-virtual成员函数间接调用private virtual函数。<br>优点：</p>
<ul>
<li>可以在调用虚函数的前后，做一些准备工作(抽出一段重复代码)</li>
<li>提供良好的ABI兼容性</li>
<li>没有必要让这个函数一定是private</li>
</ul>
<h3 id="借由Function-Pointer实现Strategy模式"><a href="#借由Function-Pointer实现Strategy模式" class="headerlink" title="借由Function Pointer实现Strategy模式"></a>借由Function Pointer实现Strategy模式</h3><p>某个实体的某个功能函数可以在运行期变更，且同一个类的不同实体可以有不同的功能函数。</p>
<h3 id="借由tr1-function完成Strategy模式"><a href="#借由tr1-function完成Strategy模式" class="headerlink" title="借由tr1::function完成Strategy模式"></a>借由tr1::function完成Strategy模式</h3><p>可以不再使用函数指针而是使用类型为tr1::function的对象。</p>
<h3 id="聊一聊ABI兼容性"><a href="#聊一聊ABI兼容性" class="headerlink" title="聊一聊ABI兼容性"></a>聊一聊ABI兼容性</h3><p>我们知道，程序库的优势之一是库版本升级，只要保证接口的一致性，用户不用修改任何代码。一般一个设计完好的程序库都会提供一份C语言接口，为什么呢，我们来看看C++ ABI有哪些脆弱性。</p>
<p>虚函数的调用方式，通常是 vptr/vtbl 加偏移量调用<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//Object.h</span><br><span class="line">class Object&#123;</span><br><span class="line">public:</span><br><span class="line">···</span><br><span class="line">    virtual print()&#123;&#125;//第3个虚函数</span><br><span class="line">···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用户代码</span><br><span class="line">int main()&#123;</span><br><span class="line">    Object *p = new Object;</span><br><span class="line">    p-&gt;print();                    //编译器：vptr[3]()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果加了虚函数，用户代码根据偏移量找到的是newfun函数</span><br><span class="line">//Object.h</span><br><span class="line">class Object&#123;</span><br><span class="line">public:</span><br><span class="line">···</span><br><span class="line">    virtual newfun()//第3个虚函数</span><br><span class="line">    virtual print()&#123;&#125;//第4个虚函数</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="name-mangling-名字粉碎实现重载"><a href="#name-mangling-名字粉碎实现重载" class="headerlink" title="name mangling 名字粉碎实现重载"></a>name mangling 名字粉碎实现重载</h3><p>C++没有为name mangling制定标准。例如void fun(int)，有的编译器定为fun<em>int</em>，有的编译器指定为fun%int%。</p>
<p>因此，C++接口的库要求用户必须和自己使用同样的编译器(这个要求好过分)</p>
<p>其实C语言接口也不完美<br>例如struct和class。编译阶段，编译器将struct或class的对象对成员的访问通过偏移量来实现</p>
<h3 id="古典策略模式"><a href="#古典策略模式" class="headerlink" title="古典策略模式"></a>古典策略模式</h3><p>用另外一个继承体系替代<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Object&#123;</span><br><span class="line">public:</span><br><span class="line">    void Interface()&#123;</span><br><span class="line">        ···</span><br><span class="line">        p-&gt;doInterface()；</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">private/protected:</span><br><span class="line">    BaseInterface *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BaseInterface&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void doInterface()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="绝不重新定义继承而来的non-virtual函数"><a href="#绝不重新定义继承而来的non-virtual函数" class="headerlink" title="绝不重新定义继承而来的non-virtual函数"></a>绝不重新定义继承而来的non-virtual函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">	void mf();</span><br><span class="line">&#125;</span><br><span class="line">class D: public B &#123;</span><br><span class="line">public:</span><br><span class="line">	void mf();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">D x;</span><br><span class="line">B* pb = &amp;x;</span><br><span class="line">D* pd = &amp;x;</span><br><span class="line"></span><br><span class="line">pb-&gt;mf();</span><br><span class="line">pd-&gt;mf(); </span><br></pre></td></tr></table></figure>
<p>上边调用的一个是B的mf()，一个是D的mf()，因为mf是在两个类中都有定义的，所以尽管都是x的指针，但是两个调用的mf不一样。non-virtual函数如B::mf()和D::mf()是静态绑定的，由于pb是一个B类的指针，通过pb调用的non-virtual函数永远是B所定义的版本。</p>
<p>virtual函数却是动态绑定的，所以它们不受这个问题困扰，如果mf是个virtual函数，则通过pb还是pd调用到的都是D的mf()。</p>
<h2 id="绝不重新定义继承而来的缺省参数值"><a href="#绝不重新定义继承而来的缺省参数值" class="headerlink" title="绝不重新定义继承而来的缺省参数值"></a>绝不重新定义继承而来的缺省参数值</h2><p>virtual函数是动态绑定，而缺省参数值是静态绑定</p>
<p>静态类型是它在程序中被声明时所采用的类型。有缺省参数值的成员函数，不可以在子类中赋予不同的缺省参数值，但是如果在子类中实现这个函数时未赋予缺省参数，则当调用时要指定参数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void draw(Shapecolor color = Red) const = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Circle : public Shape &#123;</span><br><span class="line">public:</span><br><span class="line">	virtual void draw(Shapecolor color) const;</span><br><span class="line">&#125;</span><br><span class="line">这么写的话当客户调用此函数，一定要指定参数。</span><br><span class="line">因为静态绑定下这个函数并不从其base中继承缺省参数。</span><br></pre></td></tr></table></figure><br>缺省参数值是静态绑定<br>虚函数是动态绑定<br>遵守这条规定防止出错</p>
<p>动态类型指的是目前所指对象的类型，也就是说这个对象将会有什么行为。动态类型可以在程序执行过程中改变。<br>我们可能在调用一个定义于derived class中的virtual函数时，使用了base class中为它指定的缺省参数值。</p>
<h2 id="通过复合塑模出has-a或者”根据某物实现出”"><a href="#通过复合塑模出has-a或者”根据某物实现出”" class="headerlink" title="通过复合塑模出has-a或者”根据某物实现出”"></a>通过复合塑模出has-a或者”根据某物实现出”</h2><p>复合是当某种类型的对象内含它种类型的对象，如，Person类中有Address类和PhoneNumber类，意味着has-a的关系。<br>根据某物实现出和is-a的区别：<br>这个也是什么时候使用继承，什么时候使用复合。复合代表使用了这个对象的某些方法，但是却不想它的接口入侵。</p>
<h2 id="明智而审慎地使用private继承"><a href="#明智而审慎地使用private继承" class="headerlink" title="明智而审慎地使用private继承"></a>明智而审慎地使用private继承</h2><p>private继承是<strong>根据某物实现出</strong>，如果继承关系是private的，则编译器不会自动将一个derived class对象转换为一个base class对象。<br>由private继承来的所有成员在derived class中都会变成private的，而不管它在base class中是何种。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Empty &#123;&#125;</span><br><span class="line">class HoldInt &#123;</span><br><span class="line">	int x;</span><br><span class="line">	Empty e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++ 设计者在设计这门语言要求所有的对象必须要有不同的地址(C语言没有这个要求)。C++编译器的实现方式是给让空类占据一个字节。</p>
<p>C++裁定凡是独立的对象都要有非0的大小，所以<code>sizeof(HoldInt) &gt; sizeof(int)</code>，一个Empty成员竟然要一些空间。实际上这个Empty类可能会被编译器默默加上一个char，然后由于对齐的缘故要再加上一些内存成为一个int。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Base&#123;</span><br><span class="line">public:</span><br><span class="line">    void fun()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//8个字节</span><br><span class="line">class Object&#123;</span><br><span class="line">private:</span><br><span class="line">    int a;</span><br><span class="line">    Base b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//4个字节</span><br><span class="line">class　Object : private Base&#123;</span><br><span class="line">private:</span><br><span class="line">    int a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>唯一一个使用private继承的理由就是，可以使用空白基类优化技术，节约内存空间<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class HoldInt : private Empty &#123;</span><br><span class="line">	int x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样的话<code>sizeof(HoldInt) == sizeof(int)</code>，这就是所谓的<strong>空白基类最优化</strong>。</p>
<h2 id="明智而审慎地使用多重继承"><a href="#明智而审慎地使用多重继承" class="headerlink" title="明智而审慎地使用多重继承"></a>明智而审慎地使用多重继承</h2><p>程序有可能从一个以上的基类中继承相同名字（函数，typedef等）需要明确的指出调用哪一个基类中的函数，如<code>a.B::bbb()</code>。<br>首先我们来了解一下多重继承的内存布局。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//包含A对象</span><br><span class="line">class A&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">//包含A,B对象</span><br><span class="line">class B:public A&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">//包含A,C对象</span><br><span class="line">class C:public A&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">//包含A,A,B,C,D对象</span><br><span class="line">class D:public B, public C&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于菱形继承，基类被构造了两次。其实，C++也提供了针对菱形继承的解决方案的<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//包含A对象</span><br><span class="line">class A&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">//包含A,B对象</span><br><span class="line">class B:virtual public A&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">//包含A,C对象</span><br><span class="line">class C:virtual public A&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line">//包含A,B,C,D对象</span><br><span class="line">class D:public B, public C&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用虚继承，B,C对象里面会产生一个指针指向唯一一份A对象。这样付出的代价是必须再运行期根据这个指针的偏移量寻找A对象。</p>
<p>从正确行为的观点看，public继承应该总是virtual的。规则很简单：任何时候当你使用public继承，请改用virtual public继承。但是正确性并不是唯一观点。为避免继承得来的成员变量重复，编译器必须提供若干幕后戏法，而其后果是：</p>
<ul>
<li>使用 virtual继承的那些 classes所产生的对象往往比使用 non-virtual继承的兄弟们体积大；</li>
<li>访问 virtual base classes的成员变量时，也比访问 non-virtual base classes的成员变量速度慢；</li>
</ul>
<p>种种细节因编译器不同而异，但基本重点很清楚：你得为 virtual继承付出代价</p>
<p>virtual继承的成本还包括其他方面。支配“virtual base classes初始化”的规则比起 non-virtual bases的情况远为复杂且不直观。 virtual base的初始化责任是由继承体系中的最低层（ most derived） class负责，这暗示：</p>
<ol>
<li>classes若派生自 virtual bases而需要初始化，必须认知其 virtual bases-不论那些 bases距离多远；</li>
<li>当一个新的 derived class加入继承体系中，它必须承担其 virtual bases（不论直接或间接）的初始化责任。</li>
<li>如果必须使用virtual，则尽可能避免在其中放置数据</li>
</ol>
<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><h2 id="了解隐式接口和编译期多态"><a href="#了解隐式接口和编译期多态" class="headerlink" title="了解隐式接口和编译期多态"></a>了解隐式接口和编译期多态</h2><p>接口：强制用户实现某些函数<br>多态：相同的函数名，却有不同的实现<br>继承和模板都支持接口和多态<br>对继承而言，接口是显式的，以函数为中心，多态发生在运行期；显式接口由函数的签名式（函数名、参数类型、返回类型）构成，<br>对模板而言，接口是隐式的，多态表现在template具象化和函数重载，隐式接口基于“有效表达式”组成。如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//这里接口要求T必须实现operator &gt;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void doProcessing(T&amp; w)&#123;</span><br><span class="line">	if (w.size() &gt; 10 &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>T的隐式接口提供一下约束：</p>
<ul>
<li>它必须提供一个名为size的函数，该函数返回一个数字</li>
<li>它必须支持一个operator!=函数，用来比较两个T类型的对象。</li>
</ul>
<p>加诸于template上的隐式接口，就像加诸于class对象身上的显式接口一样真实，而且二者都在编译期完成检查。</p>
<h2 id="了解typename的双重意义"><a href="#了解typename的双重意义" class="headerlink" title="了解typename的双重意义"></a>了解typename的双重意义</h2><p>声明template参数时，前缀关键字class和typename可以互换<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; class Widget;</span><br><span class="line">template&lt;typename T&gt; class Widget;</span><br><span class="line">一致</span><br></pre></td></tr></table></figure><br>然而C++并不总是把class和typename看作等价，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename C&gt;</span><br><span class="line">void print2nd(const C&amp; container) &#123;</span><br><span class="line">	if (container.size() &gt; 2) &#123;</span><br><span class="line">		C::const_iterator iter(container.begin());</span><br><span class="line">		++iter;</span><br><span class="line">		int value = *iter;</span><br><span class="line">		std::cout&lt;&lt;value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>iter的类型是C::const_iterator，它的类型取决于template参数C。template内出现的名称如果相依于某个参数，则称之为从属参数；如果从属名在class内成嵌套状，则称为嵌套从属名称。如iter。</p>
<p>嵌套从属名称可能造成解析困难。如果C命名空间中有一个变量叫做const_iterator，则就奇怪了。因此上述代码可能会造成错误。iter声明式只在C::const_iterator是个类型时才合理，我们必须告诉C++说C::const_iterator是个类型，只要加上typename即可：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (container.size() &gt; 2) &#123;</span><br><span class="line">	typename C::const_iterator iter(container.begin());</span><br></pre></td></tr></table></figure><br>任何时候如果想要在template中指涉一个嵌套从属类型名称，就必须在紧邻它的前一个位置放上关键字<strong>typename</strong><br>typename只被用来验明嵌套从属类型名称。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typaname C&gt;</span><br><span class="line">void f(const C&amp; container,		// 不用使用typename</span><br><span class="line">	typename C::iterator iter); // 需要使用typename</span><br></pre></td></tr></table></figure><br>使用typename表明嵌套类型(防止产生歧义)</p>
<h2 id="学习处理模板化基类内的名称"><a href="#学习处理模板化基类内的名称" class="headerlink" title="学习处理模板化基类内的名称"></a>学习处理模板化基类内的名称</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">	void sendclear(const std::string&amp; msg);</span><br><span class="line">	void sendencrypted(const std::string&amp; msg);</span><br><span class="line">&#125;;</span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">	void sendclear(const std::string&amp; msg);</span><br><span class="line">	void sendencrypted(const std::string&amp; msg);</span><br><span class="line">&#125;;</span><br><span class="line">class MsgInfo &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename Company&gt;</span><br><span class="line">class MsgSender &#123;</span><br><span class="line">public:</span><br><span class="line">	void sendclear(const MsgInfo&amp; info) &#123;</span><br><span class="line">		std::string msg;</span><br><span class="line">		Company c;</span><br><span class="line">		c.sendclear(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	void sendencryted(const MsgInfo&amp; info) &#123;</span><br><span class="line">	... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename Company&gt;</span><br><span class="line">class LoggingMsgSender: public MsgSender&lt;Company&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">	void sendclear(const MsgInfo&amp; info) &#123;</span><br><span class="line">		sendClearMsg(info);</span><br><span class="line">	&#125;</span><br><span class="line">	void sendencryted(const MsgInfo&amp; info) &#123;</span><br><span class="line">	... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>derived class的信息传送函数有一个不同的名称，避免了遮掩继承而来的名称。问题是，当编译器遭遇class LoggingMsgSender: public MsgSender<Company>时，不知道继承的是哪个类，不到LoggingMsgSender具现化的时候，无法确切知道它是什么。</p>
<p>如果有个类Z，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Z &#123;</span><br><span class="line">public:</span><br><span class="line">	void sendEncrypted(const std::string&amp; msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>针对Z产生一个特化版，这既不是template也不是class，而是特化版的MsgSender template。在template实参是Z时被使用，这就是所谓的模板全特化。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">class MsgSender&lt;Z&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">	void sendSecret(const MsgInfo&amp; info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>考虑derived class LoggingMsgSender，如果在derived class中调用了MsgSender<Z>中因为被特化而不存在的函数（sendclear），则可以使用如下两种方法：</p>
<ul>
<li>在base class函数调用前加上<code>this-&gt;</code></li>
<li>使用using声明式，将被掩盖的base class名称带入一个derived class中。</li>
<li>明白指出被调用的函数在哪：<code>MsgSender&lt;company&gt;::sendclear</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">class Base&#123;                                                                      </span><br><span class="line">  public:                                                                          </span><br><span class="line">    void print(T a) &#123;cout &lt;&lt;&quot;Base &quot;&lt;&lt; a &lt;&lt;endl;&#125;;                                  </span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;                                                             </span><br><span class="line">class Drive : public Base&lt;T&gt;&#123;                                                    </span><br><span class="line">public:                                                                          </span><br><span class="line">  void printf(T a)&#123;                                                          </span><br><span class="line">  </span><br><span class="line">  //error 编译器不知道基类有print函数</span><br><span class="line">    print(a);  </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line">//解决方案</span><br><span class="line">//this-&gt;print();</span><br><span class="line">//using Base&lt;T&gt;::print</span><br><span class="line">//base&lt;T&gt;::print直接调用</span><br></pre></td></tr></table></figure>
<h2 id="将参数无关代码抽离template"><a href="#将参数无关代码抽离template" class="headerlink" title="将参数无关代码抽离template"></a>将参数无关代码抽离template</h2><p>避免使用template导致的代码膨胀问题，其二进制代码带着几乎重复的代码、数据，结果可能使源码看起来合身或整齐，但是目标码却不是那么回事，使用“共性与变形分析”</p>
<p>编写template时，把共同部分抽离。<br>比如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, std::size_t n&gt;</span><br><span class="line">class SquareMatrix &#123;</span><br><span class="line">public:</span><br><span class="line">	void invert();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个template接受一个类型参数T，还接受一个类型为size_t的参数，那个是个非类型参数，这种参数和类型参数不一样，考虑：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SquareMatrix&lt;double, 5&gt; sm1;</span><br><span class="line">SquareMatrix&lt;double, 10&gt; sm2;</span><br></pre></td></tr></table></figure><br>这会具现两份代码，可以将参数5和10抽象出来：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class SquareMatrixBase &#123;</span><br><span class="line">protected:</span><br><span class="line">	void invert(std::size_t n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;tempname T, std::size_t n&gt;</span><br><span class="line">class SquareMatrix: private SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">private:</span><br><span class="line">	using SquareMatrixBase&lt;T&gt;::invert;</span><br><span class="line">public:</span><br><span class="line">	void invert() &#123; this-&gt;invert(n); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>SquareMatrixBase只对矩阵元素对象的类型进行具象化，不对矩阵的尺寸参数化。derived class的invert调用base class版本时用的inline调用，这些函数使用<code>this-&gt;</code>，因为如果若不这样做，模板化基类内的函数名会被derived class掩盖。</p>
<p>如何知道怎么得到数据？令SquareMatrixBase贮存一个指针，指向矩阵数值所在的内存：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class SquareMatrixBase &#123;</span><br><span class="line">protected:</span><br><span class="line">	SquareMatrixBase(std::size_t n, T* pMem) : size(n), pData(pMem) &#123; &#125;</span><br><span class="line">	void setDataPtr(T* ptr) &#123; pData = ptr; &#125;</span><br><span class="line">private:</span><br><span class="line">	std::size_t size;</span><br><span class="line">	T* pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在可以用inline的方式调用base class的函数，后者由持有同型元素的所有矩阵共享。不同大小的矩阵只拥有单一版本的invert，可减少执行文件大小，也就因此降低程序的working set，并强化指令高速缓存区的引用集中化。</p>
<p>在大多数平台上，所有指针类型都有相同的二进制表述，因此凡templates持有指针者（例如<code>list&lt;int*&gt;</code>，<code>list&lt;const int*&gt;</code>, <code>list&lt;SquareMatrix&lt;long, 3&gt;*&gt;</code>等等）往往应该对每一个成员函数使用唯一一份底层实现。这很具代表性地意味，如果你实现某些成员函数而它们操作强型指针（ strongly yped pointers，即<code>T*</code>），你应该令它们调用另一个操作无类型指针（<code>void*</code>）的函数，由后者完成实际工作。<br>某些C+标准程序库实现版本的确为 vector、deque和1ist等 templates做了这件事。如果你关心你的 templates可能出现代码膨胀，也许你会想让你的 templates也做相同的事情。</p>
<p>非类型模板参数造成的代码膨胀：以函数参数或者成员变量替换<br>类型模板参数造成的代码膨胀：特化它们，让含义相近的类型模板参数使用同一份底层代码。例如int，long, const int</p>
<h2 id="运用成员函数模版接收所有兼容类型"><a href="#运用成员函数模版接收所有兼容类型" class="headerlink" title="运用成员函数模版接收所有兼容类型"></a>运用成员函数模版接收所有兼容类型</h2><p>真实指针做得好的一件事是支持隐式转换：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Top &#123; ... &#125;;</span><br><span class="line">class Middle: public Top &#123;... &#125;;</span><br><span class="line">class Bottom: public Middle &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">Top* ptl = new Middle</span><br><span class="line">//将 Middle*转换为Top*</span><br><span class="line">Top* pt2 = new Bottom;</span><br><span class="line">//将 Bottom*转换为Top</span><br><span class="line">const Top* pct2= ptl</span><br><span class="line">//将Top*转换为 const Top*</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>但如果想在用户自定的智能指针中模拟上述转换，稍稍有点麻烦。我们希望以下代码通过编译：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class SmartPtr</span><br><span class="line">public:</span><br><span class="line">	explicit SmartPtr(T* reality); //智能指针通常以内置（原始）指针完成初始化</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Smartptr&lt;Top&gt; ptl = SmartPtr&lt;Middle&gt;(new Middle);</span><br><span class="line">//将 SmartPtr&lt;Middle&gt;转换为SmartPtr&lt;Top&gt;</span><br><span class="line">SmartPtr&lt;Top&gt; pt2 = SmartPtr&lt;Bottom&gt;(new Bottom);</span><br><span class="line">//将 SmartPtr&lt;Bottom&gt;转换为SmartPtr&lt;Top&gt;</span><br><span class="line">SmartPtr&lt;const Top&gt; pct= ptl</span><br><span class="line">//将 Smartptr&lt;Top&gt;转换为Smartptr&lt;const Top&gt;</span><br></pre></td></tr></table></figure><br>但是，同一个 template 的不同具现体之间并不存在什么与生俱来的固有关系。</p>
<h3 id="Template和泛型编程"><a href="#Template和泛型编程" class="headerlink" title="Template和泛型编程"></a>Template和泛型编程</h3><p>我们来考虑一下智能指针的拷贝构造函数和赋值操作符怎么实现。它需要子类的智能指针能够隐式转型为父类智能指针.<br>写一个构造模板，叫做member function template，其作用是为class生成函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class shared_ptr&#123;</span><br><span class="line">public:</span><br><span class="line">    //拷贝构造函数，接受所有能够从U*隐式转换到T*的参数</span><br><span class="line">    template&lt;typename U&gt;</span><br><span class="line">    shared_ptr(shared_ptr&lt;U&gt; const &amp;rh):p(rh.get())&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    //赋值操作符，接受所有能够从U*隐式转换到T*的参数</span><br><span class="line">    template&lt;typename U&gt;</span><br><span class="line">    shared_ptr&amp; operator= (shared_ptr&lt;U&gt; const &amp;rh):p(rh.get())&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //声明正常的拷贝构造函数</span><br><span class="line">    shared_ptr(shared_ptr const &amp;rh)；</span><br><span class="line">    shared_ptr&amp; operator= (shared_ptr const &amp;rh);</span><br><span class="line">private:</span><br><span class="line">    T *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上对任何类型T和U，这里可以根据类型U生成一个类型T的shared_ptr，因为<code>shared_ptr&lt;T&gt;</code>有一个构造函数可以接受一个<code>shared_ptr&lt;U&gt;</code>的参数，根据对象u创建对象t，有时称为泛化copy构造函数。</p>
<p>member function template也常用于赋值操作，例如TR1的shared_ptr支持所有来自兼容之内置指针、tr1::shared_ptr、auto_ptr和tr1::weak_ptr的构造行为，以及所有来自上述各对象的赋值操作。</p>
<p>使用成员函数模版生成“可接受所有兼容类型”的函数<br>即使有了“泛化拷贝构造函数”和“泛化的赋值操作符”，仍然需要声明正常的拷贝构造函数和赋值操作符<br>在一个类模版内，template名称可被用来作为作为“template和其参数”的简略表达式</p>
<h2 id="所有参数需要类型转换的时候请为模版定义非成员函数"><a href="#所有参数需要类型转换的时候请为模版定义非成员函数" class="headerlink" title="所有参数需要类型转换的时候请为模版定义非成员函数"></a>所有参数需要类型转换的时候请为模版定义非成员函数</h2><p>当我们编写一个模版类，某个相关函数都需要类型转换，需要把这个函数定义为非成员函数<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">class Rational</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">	Rational(const T&amp; numerator = 0,</span><br><span class="line">		const T&amp; denominator = 1);</span><br><span class="line">	const T numerator() const;</span><br><span class="line">	const T denominator() const;</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">const Rational&lt;T&gt; operator* (const Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">							 const Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">Rational&lt;int&gt; oneHalf(1,2);</span><br><span class="line">Rational&lt;int&gt; result = oneHalf * 2;</span><br></pre></td></tr></table></figure><br>但是模版的类型推导遇见了问题，以oneHalf进行推导，并不困难，<code>operator*</code>的第一参数被声明为<code>Rational&lt;T&gt;</code>，而传递给<code>operator*</code>的第一实参的类型是<code>Rational&lt;int&gt;</code>，所以T一定是int，<code>operator*</code>的第二参数被声明为<code>Rational&lt;T&gt;</code>，而传递给<code>operator*</code>的第二实参的类型是<code>int</code>，无法通过隐式类型转换将2转换成<code>Rational&lt;int&gt;</code>，需要把这个函数声明为友元函数帮助推导。</p>
<p>class Rational<T>声明<code>operator*</code>为friend，模版函数只有声明，编译器不会帮忙具现化，所以我们需要实现的是友元模版函数。friend函数作为一个函数而非函数模板，编译器可以在调用它的时候使用隐式类型转换。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">class Rational</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    friend Rational operator* (const Rational&amp; a, const Rational&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        return Rational (a.GetNumerator() * b.GetNumerator(),</span><br><span class="line">            a.GetDenominator() * b.GetDenominator());</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这项技术的一个趣味点是，我们虽然使用friend，却与friend的传统用途“访问class的non-public成分”亳不相干。为了让类型转换可能发生于所有实参身上，我们需要一个 non-member函数；为了令这个函数被自动具现化，我们需要将它声明在class内部；而在class内部声明 non-member函数的唯一办法就是令它成为一个 friend。因此我们就这样做了。</p>
<p>当我们编写一个class template，而它所提供的与此template相关的函数支持<strong>所有参数之隐式类型转换</strong>时，将那些函数定义为class template内部的friend函数。</p>
<h2 id="请使用traits-classes表现类型信息"><a href="#请使用traits-classes表现类型信息" class="headerlink" title="请使用traits classes表现类型信息"></a>请使用traits classes表现类型信息</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename DistT&gt;</span><br><span class="line">void advance(IterT&amp; iter, DistT d);</span><br></pre></td></tr></table></figure>
<p>advance只做<code>iter+=d</code>的操作，但是只有随机访问的迭代器才支持+=操作。面对其他威力不那么强大的迭代器种类， advance必须反复施行++或—，共d次。</p>
<p>STL共有5种选代器分类，对应于它们支持的操作。</p>
<ul>
<li>Input送代器只能向前移动，一次一步，客户只可读取（不能涂写）它们所指的东西，而且只能读取一次。它们模仿指向输入文件的阅读指针（ read pointer）；C++程序库中的istream Iterators是这一分类的代表。</li>
<li>Output迭代器情况类似，但一切只为输出，它们只向前移动，一次一步，客户只可涂写它们所指的东西，而且只能涂写一次。<br>它们模仿指向输出文件的涂写指针（ write pointer）； ostream iterators是这一分类的代表。这是威力最小的两个迭代器分类。由于这两类都只能向前移动，而且只能读或写其所指物最多一次，所以它们只适合“一次性操作算法”（one-passalgorithms）。</li>
<li>另一个威力比较强大的分类是forward迭代器。这种迭代器可以做前述两种分类所能做的每一件事，而且可以读或写其所指物一次以上。这使得它们可施行于多次性操作算法（muli-pass algorithms）。</li>
<li>Bidirectional迭代器比上一个分类威力更大：它除了可以向前移动，还可以向后移动。STL的list迭代器就属于这一分类，set， multiset，map和 multimap的迭代器也都是这一分类；</li>
<li>最有威力的迭代器当属 random access迭代器。它可以执行“迭代器算术”，也就是它可以在常量时间内向前或向后跳跃任意距离。这样的算术很类似指针算术，那并不令人惊讶，因为 random access迭代器正是以内置（原始）指针为榜样，而内置指针也可被当做 random access迭代器使用。 vector，deque和string提供的选代器都是这一分类<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct input_iterator_tag &#123;&#125;</span><br><span class="line">struct output_iterator_tag &#123;&#125;</span><br><span class="line">struct forward_iterator_tag: public input_iterator_tag &#123;&#125;</span><br><span class="line">struct bidirectional_iterator_tag: public forward_iterator_tag &#123;&#125;</span><br><span class="line">struct random_access_iterator_tag: public bidirectional_iterator_tag &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我们希望以这种方式实现advance函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename DistT&gt;</span><br><span class="line">void advance(IterT&amp; iter, DistT d) &#123;</span><br><span class="line">	if (iter is a random access iterator) &#123;</span><br><span class="line">		iter += d;</span><br><span class="line">	&#125; </span><br><span class="line">	else &#123;</span><br><span class="line">		if (d &gt;=0) &#123; while (d--) ++iter;&#125;</span><br><span class="line">		else &#123; while (d++) --iter;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种方法必须事先知道iter是否为random access迭代器，这就是traits让你得以进行的事，允许你在编译期间读取某些类型信息。<br>标准技术是把traits信息放入一个template及其一个或多个特化版本中，这样的templates有多个，其中针对迭代器的被命名为iterator_traits：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename IterT&gt;</span><br><span class="line">struct iterator_traits;</span><br></pre></td></tr></table></figure><br>iterator_traits的运作方式是，针对每一个类型IterT，在<code>struct iterator_traits&lt;IterT&gt;</code>内一定声明某个typedef名为iterator_category，用来确认IterT的迭代器分类。用户自定义的迭代器类型都要嵌套一个typedef，名为iterator_category。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt; ... &gt;</span><br><span class="line">class deque &#123;</span><br><span class="line">	public:</span><br><span class="line">	class iterator &#123;</span><br><span class="line">		public:</span><br><span class="line">		typedef random_access_iterator_tag iterator_category;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>为了支持指针迭代器，iterator_traits特别针对指针类型提供了一个偏特化版本：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename IterT&gt;</span><br><span class="line">struct iterator_traits&lt;IterT*&gt; &#123;</span><br><span class="line">	typedef random_access_iterator_tag iterator_category;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>有了iterator_traits，可以对advance实现之前的伪代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename DistT&gt;</span><br><span class="line">void advance(IterT&amp; iter, DistT d) &#123;</span><br><span class="line">	if (typeid(typename std::iterator_traits&lt;IterT&gt;::iterator_category) == typeid(std::random_access_iterator_tag)) &#123;</span><br><span class="line">		iter += d;</span><br><span class="line">	&#125; </span><br><span class="line">	else &#123;</span><br><span class="line">		if (d &gt;=0) &#123; while (d--) ++iter;&#125;</span><br><span class="line">		else &#123; while (d++) --iter;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>利用重载实现编译器核定成功类型：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename DistT&gt;</span><br><span class="line">void doadvance(IterT&amp; iter, DistT d, std::random_access_iterator_tag) &#123;</span><br><span class="line">	iter += d;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T, typename DistT&gt;</span><br><span class="line">void doadvance(IterT&amp; iter, DistT d, std::biredirectional_iterator_tag) &#123;</span><br><span class="line">	if (d &gt;=0) &#123; while (d--) ++iter;&#125;</span><br><span class="line">	else &#123; while (d++) --iter;&#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T, typename DistT&gt;</span><br><span class="line">void advance(IterT&amp; iter, DistT d) &#123;</span><br><span class="line">	doadvance(iter, d, typename std::iterator_traits&lt;IterT&gt;::iterator_category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>建立一组重载函数（身份像劳工）或函数模板（例如 doAdvance），彼此间的差异只在于各自的traits参数。令每个函数实现码与其接受之 traits信息相应和。<br>建立一个控制函数（身份像工头）或函数模板（例如 advance），它调用上述那些“劳工函数”并传递 traits class所提供的信息。</p>
<h2 id="模版元编程"><a href="#模版元编程" class="headerlink" title="模版元编程"></a>模版元编程</h2><p>本质上就是函数式编程<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//上楼梯，每次上一步或者两步，有多少种</span><br><span class="line">int climb(int n)&#123;</span><br><span class="line">    if(n == 1)</span><br><span class="line">        return 1;</span><br><span class="line">    if(n == 2)</span><br><span class="line">        return 2;</span><br><span class="line">    return climb(n - 1) + climb(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//元编程，采用类模版</span><br><span class="line">template&lt;int N&gt;</span><br><span class="line">class Climb&#123;</span><br><span class="line">public:</span><br><span class="line">  const static int n = Climb&lt;N-1&gt;::n + Climb&lt;N-2&gt;::n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">class Climb&lt;2&gt;&#123;</span><br><span class="line">public:</span><br><span class="line">  const static int n = 2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">class Climb&lt;1&gt;&#123;</span><br><span class="line">public:</span><br><span class="line">  const static int n = 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>C++元编程可以将计算转移到编译期，执行速度迅速(缺陷？)</p>
<h1 id="定制new和delete"><a href="#定制new和delete" class="headerlink" title="定制new和delete"></a>定制new和delete</h1><h2 id="了解new-handler的行为"><a href="#了解new-handler的行为" class="headerlink" title="了解new-handler的行为"></a>了解new-handler的行为</h2><p>STL容器使用的heap内存是由容器所拥有的分配器对象管理，不是被new和delete管理。<br>new和malloc对比：</p>
<ul>
<li>new构造对象，malloc不会</li>
<li>new分配不出内存会抛异常，malloc返回NULL</li>
<li>new分配不出内存可以调用用户设置的new-handler，malloc没有。可以为每个类设置专属new handler</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">namespace std&#123;</span><br><span class="line">    typedef void (*new_handler)();</span><br><span class="line">    //返回旧的handler</span><br><span class="line">    new_handler set_new_handler(new_handler p) throw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new_handler是个typedef，定义出一个指针指向函数，该函数没有参数也不返回任何东西；set_new_handler则是获得一个new_handler并返回一个new_handler的函数。set_new_handler的参数是个指针，指向operator new无法分配足够内存时该被调用的函数，其返回值也是个指针，指向set_new_handler被调用前正在执行的那个new_handler函数。</p>
<p>当operator new无法满足内存申请时，就会不断调用new_handler函数直到找到足够的内存。<br>C++不支持class专属new-handler，只需令每个class提供自己的set_new_handler和operator new即可。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">	static std::new_handler set_new_handler(std::new_handler p) throw();</span><br><span class="line">	stativ void* operator new(std::size_t size) throw(std::bad_alloc);</span><br><span class="line">private:</span><br><span class="line">	static std::new_handler currentHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Widget内的set_new_handler将它获得的指针存储起来，然后返回之前存储的指针：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::new_handler Widget::set_new_handler(std::new_handler p) throw() &#123;</span><br><span class="line">	std::new_handler oldHandler = currentHandler;</span><br><span class="line">	currentHandler = p;</span><br><span class="line">	return oldHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>operator new做以下事情：</p>
<ol>
<li>调用标准set_new_handler告知类的错误处理函数；</li>
<li>调用global operator new执行实际的内存分配，如果分配失败则调用类的new handler，如果global new handler最终无法分配足够内存，会抛出一个bad_alloc异常；</li>
<li>如果global operator new能够分配足够一个类对象所用的内存，类的operator new则会返回一个指针，指向分配所得。</li>
</ol>
<h2 id="了解new和delete合理的替换时机"><a href="#了解new和delete合理的替换时机" class="headerlink" title="了解new和delete合理的替换时机"></a>了解new和delete合理的替换时机</h2><p>为何要替换编译器提供的operator new和operator delete：</p>
<ul>
<li>用来检测运用上的错误。如果将new的对象delete掉却不幸失败，会导致内存泄漏，以及其他的写入错误等；</li>
<li>强化效能。对特定应用的内存分配进行优化</li>
<li>收集使用上的统计数据。</li>
<li>增加分配和归还的速度。泛用性分配器比定制性分配器慢。</li>
<li>为了降低缺省内存管理器带来的空间额外开销。泛用性分配器在每一个分配区块上招引某些开销。</li>
<li>为了弥补缺省分配器中的非最佳齐位，编译器自带的operator new并不保证对动态分配而得的double采取8-bytes对齐。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static const int signature = OxDEADBEEF;</span><br><span class="line">typedef unsigned char Byte;</span><br><span class="line">// 这段代码还有若干小错误，详下。</span><br><span class="line">void* operator new(std::size_t size) throw(std::bad_alloc) &#123;</span><br><span class="line">	using namespace std;</span><br><span class="line">	size_t realSize = size + 2 * sizeof(int);</span><br><span class="line">	//增加大小，使能够塞入两个size</span><br><span class="line">	</span><br><span class="line">	void* pMem = malloc(realSize);</span><br><span class="line">	//调用 malloc取得内存</span><br><span class="line">	if (!pMem) throw bad_alloc();</span><br><span class="line"></span><br><span class="line">	//将signature写入内存的最前段落和最后段落</span><br><span class="line">	*(static_cast&lt;int*&gt;(pMem)) = signature;</span><br><span class="line">	*(reinterpret_cast&lt;int*&gt;(static_cast&lt;Byte*&gt;(pMem)+ realSize-sizeof(int)))= signature;</span><br><span class="line">	//返回指针，指向恰位于第一个 signature之后的内存位置</span><br><span class="line">	return static_cast&lt;Byte*&gt;(pMem) + sizeof(int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个operator new的缺点主要在于它疏忽了身为这个特殊函数所应该具备的“坚持c++规矩”的态度。<br>举个例子，条款51说所有operator news都应该内含一个循环，反复调用某个new-handling函数，这里却没有。专注于一个比较微妙的主题：齐位。</p>
<p>许多计算机体系结构要求特定的类型必须放在特定的内存地址上。例如它可能会要求指针的地址必须是4倍数或doubles的地址必须是8倍数。如果没有奉行这个约束条件可能导致运行期硬件异常。<br>例如 Intel x86体系结构上的doubles可被对齐于任何byte边界，但如果它是8bye齐位，其访问速度会快许多。<br>C++要求所有operator news返回的指针都有适当的对齐（取决于数据类型）。malloc就是在这样的要求下工作，所以令 operator返回一个得自malloc的指针是安全的。</p>
<p>operator new, operator delete：分配和释放内存<br>调用构造函数，调用析构函数<br>替换new和delete的理由，就是需要收集分配内存的资源信息</p>
<p>编写符合常规的new和delete<br>operator new应该内含一个无穷循环尝试分配内存，如果无法满足，就调用new-handler。class版本要处理“比正确大小更大的(错误)申请”<br>operator deleter应该处理Null。classz专属版本还要处理“比正确大小更小的(错误)申请”<br>写了operator new也要写相应的operator delete<br>我们知道，new一个对象要经历两步。如果在调用构造函数失败，编译器会寻找一个“带相同额外参数”的operator delete，否则就不调用，造成资源泄漏</p>
<h2 id="编写new和delete时需要固守常规"><a href="#编写new和delete时需要固守常规" class="headerlink" title="编写new和delete时需要固守常规"></a>编写new和delete时需要固守常规</h2><p>operator new的返回值十分单纯。如果它有能力供应客户申请的内存，就返回一个指针指向那块内存。如果没有那个能力，就遵循条款49描述的规则，并抛出个bad_alloc异常。<br>然而其实也不是非常单纯，因为operator new实际上不只一次尝试分配内存，并在每次失败后调用new-handling函数。这里假设new- handling函数也许能够做某些动作将某些内存释放出来。只有当指向 new-handling函数的指针是 null， operatornew才会抛出异常。</p>
<p>即使客户要求分配0byte的内存，operator也要返回一个合法指针。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void* operator new(std::size_t size) throw (std::bad_alloc) &#123;</span><br><span class="line">	//你的 operator new可能接受额外参数</span><br><span class="line">	using namespace std;</span><br><span class="line">	if (size == 0) &#123;</span><br><span class="line">	//处理0-byte申请</span><br><span class="line">		size = 1;</span><br><span class="line">	//将它视为1-byte申请</span><br><span class="line">	&#125;</span><br><span class="line">	while (true)</span><br><span class="line">		// 尝试分配</span><br><span class="line">		if (分配成功) </span><br><span class="line">			return;</span><br><span class="line">	// 分配失败，找出目前的new_handling函数</span><br><span class="line">	new_handler globalHandler = set_new_handler(0);</span><br><span class="line">	set_new_handler(globanHandler);</span><br><span class="line"></span><br><span class="line">	if (globalHandler) (*globalHandler)();</span><br><span class="line">	else throw std::bad_alloc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>operator new内含一个无穷循环，而上述伪码明白表明出这个循环；”while(true)”就是那个无穷循环。退出此循环的唯一办法是内存成功分配或new- handling函数做了一件描述于条款49的事情：让更多内存可用、安装另一个 new-handler、卸除new-handler、抛出bad_a1oc异常（或其派生物），或是承认失败而直接 return。</p>
<p>operator new成员函数会被derived classes继承,这会导致某些有趣的复杂度。上述operator伪码中，函数尝试分配size bytes（除是0）。那非常合理，因为size是函数接受的实参。然而就像条款50所言，写出定制型内存管理器的一个最常见理由是为针对某特定class对象分配提供最优化，却不是为了其derived class，base class的operator new用于derived class时会有问题。</p>
<p>如果你决定写个operator new[]，唯一要做的一件事就是分配一块未加工内存，因为你无法对array之内迄今尚未存在的元素对象做任何事情。实际上你甚至无法计算这个array将含多少个元素对象。首先你不知道每个对象多大，毕竟base class的operator new有可能经由继承被调用，将内存分配给“元素为 derived class对象”的array使用。</p>
<p>operator delete的情况更简单，C++保证删除null指针永远安全，所以我们必须兑现这个要求。</p>
<h2 id="写了placement-new也要写placement-delete"><a href="#写了placement-new也要写placement-delete" class="headerlink" title="写了placement new也要写placement delete"></a>写了placement new也要写placement delete</h2><p>举个例子，假设你写了一个class专属的operator new，要求接受一个ostream，用来志记（logged）相关分配信息，同时又写了一个正常形式的class专属operator delete：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">	static void* operator new (std::size_t size, std::ostream&amp; logstream) throw(std::bad_alloc);</span><br><span class="line">	//非正常形式的new</span><br><span class="line">	static void operator delete(void* pMemory, std::size_t size) throw();</span><br><span class="line">	//正常的 class专属 delete</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这个设计有问题，但在探讨原因之前，我们需要先绕道，扼要讨论若干术语。<br>如果operator new接受的参数除了一定会有的那个size_t之外还有其他，这便是个所谓的<strong>placement new</strong>。因此，上述的operator new是个 placement版本。<br>众多placement new版本中特别有用的一个是“接受一个指针指向对象该被构造之处”，那样的operator new如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void* operator new(std::size_t, void* pMemory) throw();</span><br><span class="line">//placement new</span><br></pre></td></tr></table></figure><br>这个版本的new已被纳入C++标准程序库，你只要<code>#include&lt;new&gt;</code>就可以取用它。这个new的用途之一是负责在vector的末使用空间上创建对象。<br>实际上它正是这个函数的命名根据：一个特定位置上的new。<br>大多数时候他们谈的是此一特定版本，也就是“唯一额外实参是个<code>void*</code>”，少数时候才是指接受任意额外实参之operator new。</p>
<p>类似于new的placement版本，operator delete如果接受额外参数，便称为placement delete。</p>
<p>规则很简单：如果一个带额外参数的operator new没有“带相同额外参数”的对应版operator delete，那么当new的内存分配动作需要取消并恢复旧观时就没有任何operator delete会被调用。因此，为了消弭稍早代码中的内存泄漏，Widget有必要声明一个placement delete，对应于那个有志记功能的placement new：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Widget&#123;</span><br><span class="line">public:</span><br><span class="line">	static void* operator new(std::size_t size, std::ostream&amp; logstream) throw(std::bad_alloc);</span><br><span class="line">	static void operator delete(void* pMemory) throw();</span><br><span class="line">	static void operator delete(void* pMemory, std::ostream&amp; logStream) throw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果以下语句引发异常，则placement delete自动调用，保证不泄露内存：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget* pw = new (std::cerr) Widget;</span><br></pre></td></tr></table></figure><br>placement delete只有在伴随placement new调用而触发的构造函数出现异常时才会调用。</p>
<p>如果要对所有与placement new相关的内存泄漏宣战，必须同时提供一个正常的operator delete和一个placement delete分别用于构造时有/无异常抛出的情况。</p>
<h2 id="STL使用小细节"><a href="#STL使用小细节" class="headerlink" title="STL使用小细节"></a>STL使用小细节</h2><p>为不同的容器选择不同删除方式：<br>删除连续容器(vector,deque,string)的元素<br>当c是vector、string，删除value<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.erase(remove(c.begin(), c.end(), value), c.end());</span><br></pre></td></tr></table></figure><br>判断value是否满足某个条件，删除<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool assertFun(valuetype);</span><br><span class="line">c.erase(remove_if(c.begin(), c.end(), assertFun), c.end());</span><br></pre></td></tr></table></figure><br>有时候我们不得不遍历去完成，并删除<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(auto it = c.begin(); it != c.end(); )&#123;</span><br><span class="line">    if(assertFun(*it))&#123;</span><br><span class="line">        ···</span><br><span class="line">        it = c.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        ++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>删除list中某个元素<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.remove(value);</span><br></pre></td></tr></table></figure><br>判断value是否满足某个条件，删除<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.remove(assertFun);</span><br></pre></td></tr></table></figure><br>删除关联容器(set,map)中某个元素<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c.erase(value)</span><br><span class="line">    </span><br><span class="line">for(auto it = c.begin(); it != c.end(); )&#123;</span><br><span class="line">    if(assertFun(*it))&#123;</span><br><span class="line">        ···</span><br><span class="line">        c.erase(it++);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        ++it;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%87%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%96%87%E7%AB%A0/" itemprop="url">动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-06T15:40:00+08:00">
                2020-01-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>用一句话解释动态规划就是 “记住你之前做过的事”，如果更准确些，其实是 “记住你之前得到的答案”。</p>
<p>我举个大家工作中经常遇到的例子。</p>
<p>在软件开发中，大家经常会遇到一些系统配置的问题，配置不对，系统就会报错，这个时候一般都会去 Google 或者是查阅相关的文档，花了一定的时间将配置修改好。</p>
<p>过了一段时间，去到另一个系统，遇到类似的问题，这个时候已经记不清之前修改过的配置文件长什么样，这个时候有两种方案，一种方案还是去 Google 或者查阅文档，另一种方案是借鉴之前修改过的配置，第一种做法其实是万金油，因为你遇到的任何问题其实都可以去 Google，去查阅相关文件找答案，但是这会花费一定的时间，相比之下，第二种方案肯定会更加地节约时间，但是这个方案是有条件的，条件如下：</p>
<p>之前的问题和当前的问题有着关联性，换句话说，之前问题得到的答案可以帮助解决当前问题</p>
<p>需要记录之前问题的答案</p>
<p>当然在这个例子中，可以看到的是，上面这两个条件均满足，大可去到之前配置过的文件中，将配置拷贝过来，然后做些细微的调整即可解决当前问题，节约了大量的时间。</p>
<p>不知道你是否从这些描述中发现，对于一个动态规划问题，我们只需要从两个方面考虑，那就是 找出问题之间的联系，以及 记录答案，这里的难点其实是找出问题之间的联系，记录答案只是顺带的事情，利用一些简单的数据结构就可以做到。</p>
<h1 id="思考动态规划问题的四个步骤"><a href="#思考动态规划问题的四个步骤" class="headerlink" title="思考动态规划问题的四个步骤"></a>思考动态规划问题的四个步骤</h1><p>一般解决动态规划问题，分为四个步骤，分别是</p>
<ul>
<li>问题拆解，找到问题之间的具体联系</li>
<li>状态定义</li>
<li>递推方程推导</li>
<li>实现</li>
</ul>
<p>这里面的重点其实是前两个，如果前两个步骤顺利完成，后面的递推方程推导和代码实现会变得非常简单。</p>
<p>这里还是拿 Quora 上面的例子来讲解，“1+1+1+1+1+1+1+1” 得出答案是 8，那么如何快速计算 “1+ 1+1+1+1+1+1+1+1”，我们首先可以对这个大的问题进行拆解，这里我说的大问题是 9 个 1 相加，这个问题可以拆解成 1 + “8 个 1 相加的答案”，8 个 1 相加继续拆，可以拆解成 1 + “7 个 1 相加的答案”，… 1 + “0 个 1 相加的答案”，到这里，第一个步骤 已经完成。</p>
<p>状态定义 其实是需要思考在解决一个问题的时候我们做了什么事情，然后得出了什么样的答案，对于这个问题，当前问题的答案就是当前的状态，基于上面的问题拆解，你可以发现两个相邻的问题的联系其实是 后一个问题的答案 = 前一个问题的答案 + 1，这里，状态的每次变化就是 +1。</p>
<p>定义好了状态，递推方程就变得非常简单，就是 dp[i] = dp[i - 1] + 1，这里的 dp[i] 记录的是当前问题的答案，也就是当前的状态，dp[i - 1] 记录的是之前相邻的问题的答案，也就是之前的状态，它们之间通过 +1 来实现状态的变更。</p>
<p>最后一步就是实现了，有了状态表示和递推方程，实现这一步上需要重点考虑的其实是初始化，就是用什么样的数据结构，根据问题的要求需要做那些初始值的设定。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int dpExample(int n) &#123;</span><br><span class="line">    int[] dp = new int[n + 1];  // 多开一位用来存放 0 个 1 相加的结果</span><br><span class="line">    dp[0] = 0;      // 0 个 1 相加等于 0</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i] = dp[i - 1] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>你可以看到，动态规划这四个步骤其实是相互递进的，状态的定义离不开问题的拆解，递推方程的推导离不开状态的定义，最后的实现代码的核心其实就是递推方程，这中间如果有一个步骤卡壳了则会导致问题无法解决，当问题的复杂程度增加的时候，这里面的思维复杂程度会上升。</p>
<p>接下来我们再来看看 LeetCode 上面的几道题目，通过题目再来走一下这些个分析步骤。</p>
<h1 id="题目实战"><a href="#题目实战" class="headerlink" title="题目实战"></a>题目实战</h1><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p>但凡涉及到动态规划的题目都离不开一道例题：爬楼梯（LeetCode 第 70 号问题）。</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"></span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure></p>
<h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>爬楼梯，可以爬一步也可以爬两步，问有多少种不同的方式到达终点，我们按照上面提到的四个步骤进行分析：</p>
<p>问题拆解：<br>我们到达第 n 个楼梯可以从第 n - 1 个楼梯和第 n - 2 个楼梯到达，因此第 n 个问题可以拆解成第 n - 1 个问题和第 n - 2 个问题，第 n - 1 个问题和第 n - 2 个问题又可以继续往下拆，直到第 0 个问题，也就是第 0 个楼梯 (起点)</p>
<p>状态定义：<br>“问题拆解” 中已经提到了，第 n 个楼梯会和第 n - 1 和第 n - 2 个楼梯有关联，那么具体的联系是什么呢？你可以这样思考，第 n - 1 个问题里面的答案其实是从起点到达第 n - 1 个楼梯的路径总数，n - 2 同理，从第 n - 1 个楼梯可以到达第 n 个楼梯，从第 n - 2 也可以，并且路径没有重复，因此我们可以把第 i 个状态定义为 “从起点到达第 i 个楼梯的路径总数”，状态之间的联系其实是相加的关系。</p>
<p>递推方程：<br>“状态定义” 中我们已经定义好了状态，也知道第 i 个状态可以由第 i - 1 个状态和第 i - 2 个状态通过相加得到，因此递推方程就出来了 dp[i] = dp[i - 1] + dp[i - 2]</p>
<p>实现：<br>你其实可以从递推方程看到，我们需要有一个初始值来方便我们计算，起始位置不需要移动 dp[0] = 0，第 1 层楼梯只能从起始位置到达，因此 dp[1] = 1，第 2 层楼梯可以从起始位置和第 1 层楼梯到达，因此 dp[2] = 2，有了这些初始值，后面就可以通过这几个初始值进行递推得到。</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int climbStairs(int n) &#123;</span><br><span class="line">    if (n == 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[] dp = new int[n + 1];  // 多开一位，考虑起始位置</span><br><span class="line"></span><br><span class="line">    dp[0] = 0; dp[1] = 1; dp[2] = 2;</span><br><span class="line">    for (int i = 3; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i] = dp[i - 1] + dp[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h2><p>LeetCode 第 120 号问题：三角形最小路径和。</p>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<p>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<p>说明：</p>
<p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>给定一个三角形数组，需要求出从上到下的最小路径和，也和之前一样，按照四个步骤来分析：</p>
<p>问题拆解：<br>这里的总问题是求出最小的路径和，路径是这里的分析重点，路径是由一个个元素组成的，和之前爬楼梯那道题目类似，[i][j] 位置的元素，经过这个元素的路径肯定也会经过 [i - 1][j] 或者 [i - 1][j - 1]，因此经过一个元素的路径和可以通过这个元素上面的一个或者两个元素的路径和得到。</p>
<p>状态定义：<br>状态的定义一般会和问题需要求解的答案联系在一起，这里其实有两种方式，一种是考虑路径从上到下，另外一种是考虑路径从下到上，因为元素的值是不变的，所以路径的方向不同也不会影响最后求得的路径和，如果是从上到下，你会发现，在考虑下面元素的时候，起始元素的路径只会从[i - 1][j] 获得，每行当中的最后一个元素的路径只会从 [i - 1][j - 1] 获得，中间二者都可，这样不太好实现，因此这里考虑从下到上的方式，状态的定义就变成了 “最后一行元素到当前元素的最小路径和”，对于 [0][0] 这个元素来说，最后状态表示的就是我们的最终答案。</p>
<p>递推方程：<br>“状态定义” 中我们已经定义好了状态，递推方程就出来了<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j]</span><br></pre></td></tr></table></figure></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>这里初始化时，我们需要将最后一行的元素填入状态数组中，然后就是按照前面分析的策略，从下到上计算即可</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</span><br><span class="line">    int n = triangle.size();</span><br><span class="line"></span><br><span class="line">    int[][] dp = new int[n][n];</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; lastRow = triangle.get(n - 1);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[n - 1][i] = lastRow.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = n - 2; i &gt;= 0; --i) &#123;</span><br><span class="line">        List&lt;Integer&gt; row = triangle.get(i);</span><br><span class="line">        for (int j = 0; j &lt; i + 1; ++j) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + row.get(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[0][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h2><p>LeetCode 第 53 号问题：最大子序和。</p>
<h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。<br>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>求最大子数组和，非常经典的一道题目，这道题目有很多种不同的做法，而且很多算法思想都可以在这道题目上面体现出来，比如动态规划、贪心、分治，还有一些技巧性的东西，比如前缀和数组，这里还是使用动态规划的思想来解题，套路还是之前的四步骤：</p>
<p>问题拆解：<br>问题的核心是子数组，子数组可以看作是一段区间，因此可以由起始点和终止点确定一个子数组，两个点中，我们先确定一个点，然后去找另一个点，比如说，如果我们确定一个子数组的截止元素在 i 这个位置，这个时候我们需要思考的问题是 “以 i 结尾的所有子数组中，和最大的是多少？”，然后我们去试着拆解，这里其实只有两种情况：</p>
<ul>
<li>这个位置的元素自成一个子数组;</li>
<li>i 位置的元素的值 + 以 i - 1 结尾的所有子数组中的子数组和最大的值</li>
</ul>
<p>你可以看到，我们把第 i 个问题拆成了第 i - 1 个问题，之间的联系也变得清晰</p>
<h3 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h3><p>通过上面的分析，其实状态已经有了，dp[i] 就是 “以 i 结尾的所有子数组的最大值”</p>
<h3 id="递推方程"><a href="#递推方程" class="headerlink" title="递推方程"></a>递推方程</h3><p>拆解问题的时候也提到了，有两种情况，即当前元素自成一个子数组，另外可以考虑前一个状态的答案，于是就有了<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.max(dp[i - 1] + array[i], array[i])</span><br></pre></td></tr></table></figure><br>化简一下就成了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.max(dp[i - 1], 0) + array[i]</span><br></pre></td></tr></table></figure></p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>题目要求子数组不能为空，因此一开始需要初始化，也就是 dp[0] = array[0]，保证最后答案的可靠性，另外我们需要用一个变量记录最后的答案，因为子数组有可能以数组中任意一个元素结尾</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">    if (nums == null || nums.length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int n = nums.length;</span><br><span class="line"></span><br><span class="line">    int[] dp = new int[n];</span><br><span class="line"></span><br><span class="line">    dp[0] = nums[0];</span><br><span class="line"></span><br><span class="line">    int result = dp[0];</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - 1], 0) + nums[i];</span><br><span class="line">        result = Math.max(result, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上文解释了动态规划的一些基本特性和解题思路，也说了动态规划其实就是记住之前问题的答案，然后利用之前问题的答案来分析并解决当前问题，这里面有两个非常重要的步骤，就是<strong>拆解问题</strong> 和<strong>定义状态</strong>。</p>
<h1 id="矩阵类动态规划问题"><a href="#矩阵类动态规划问题" class="headerlink" title="矩阵类动态规划问题"></a>矩阵类动态规划问题</h1><p>这次来针对具体的一类动态规划问题，矩阵类动态规划问题，来看看针对这一类问题的思路和注意点。</p>
<p>矩阵类动态规划，也可以叫做坐标类动态规划，一般这类问题都会给你一个矩阵，矩阵里面有着一些信息，然后你需要根据这些信息求解问题。</p>
<p>其实 矩阵可以看作是图的一种，怎么说？你可以把整个矩阵当成一个图，矩阵里面的每个位置上的元素当成是图上的节点，然后每个节点的邻居就是其相邻的上下左右的位置，我们遍历矩阵其实就是遍历图，在遍历的过程中会有一些临时的状态，也就是子问题的答案，我们记录这些答案，从而推得我们最后想要的答案。</p>
<p>一般来说，在思考这类动态规划问题的时候，我们只需要思考当前位置的状态，然后试着去看当前位置和它邻居的递进关系，从而得出我们想要的递推方程，这一类动态规划问题，相对来说比较简单，我们通过几道例题来熟悉一下。</p>
<h2 id="相关题目解析"><a href="#相关题目解析" class="headerlink" title="相关题目解析"></a>相关题目解析</h2><h3 id="LeetCode-第-62-号问题：不同路径。"><a href="#LeetCode-第-62-号问题：不同路径。" class="headerlink" title="LeetCode 第 62 号问题：不同路径。"></a>LeetCode 第 62 号问题：不同路径。</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p>例如，一个7 x 3 的网格。有多少可能的路径？</p>
<p>说明： m 和 n 的值均不超过 100。</p>
<p>示例 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 3, n = 2</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line"></span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = 7, n = 3</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure></p>
<h4 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h4><p>给定一个矩阵，问有多少种不同的方式从起点(0,0) 到终点 (m-1,n-1)，并且每次移动只能向右或者向下，我们还是按之前提到的分析动态规划那四个步骤来思考一下：</p>
<p>问题拆解:<br>题目中说了，每次移动只能是向右或者是向下，矩阵类动态规划需要关注当前位置和其相邻位置的关系，对于某一个位置来说，经过它的路径只能从它上面过来，或者从它左边过来，因此，如果需要求到达当前位置的不同路径，我们需要知道到达其上方位置的不同路径，以及到达其左方位置的不同路径</p>
<p>状态定义:<br>矩阵类动态规划的状态定义相对来说比较简单，只需要看当前位置即可，问题拆解中，我们分析了当前位置和其邻居的关系，提到每个位置其实都可以算做是终点，状态表示就是 “从起点到达该位置的不同路径数目”</p>
<p>递推方程:<br>有了状态，也知道了问题之间的联系，其实递推方程也出来了，就是<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span><br></pre></td></tr></table></figure><br>实现:<br>有了这些，这道题还没完，我们还要考虑状态数组的初始化问题，对于上边界和左边界的点，因为它们只能从一个方向过来，需要单独考虑，比如上边界的点只能从左边这一个方向过来，左边界的点只能从上边这一个方向过来，它们的不同路径个数其实就只有 1，提前处理就好。</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int uniquePaths(int m, int n) &#123;</span><br><span class="line">    int[][] dp = new int[m][n];</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        dp[i][0] = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">        dp[0][j] = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; m; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt; n; ++j) &#123;</span><br><span class="line">            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[m - 1][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LeetCode-第-63-号问题：不同路径II"><a href="#LeetCode-第-63-号问题：不同路径II" class="headerlink" title="LeetCode 第 63 号问题：不同路径II"></a>LeetCode 第 63 号问题：不同路径II</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p>说明：m 和 n 的值均不超过 100。</p>
<p>示例 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><br>解释:<br>3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</li>
</ol>
<h4 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h4><p>在上面那道题的基础上，矩阵中增加了障碍物，这里只需要针对障碍物进行判断即可，如果当前位置是障碍物的话，状态数组中当前位置记录的答案就是 0，也就是没有任何一条路径可以到达当前位置，除了这一点外，其余的分析方法和解题思路和之前 一样 。</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span><br><span class="line">    if (obstacleGrid.length == 0 || obstacleGrid[0].length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (obstacleGrid[0][0] == 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int m = obstacleGrid.length, n = obstacleGrid[0].length;</span><br><span class="line">    int[][] dp = new int[m][n];</span><br><span class="line"></span><br><span class="line">    dp[0][0] = 1;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; m; ++i) &#123;</span><br><span class="line">        dp[i][0] = obstacleGrid[i][0] == 1 ? 0 : dp[i - 1][0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[0][i] = obstacleGrid[0][i] == 1 ? 0 : dp[0][i - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; m; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt; n; ++j) &#123;</span><br><span class="line">            dp[i][j] = obstacleGrid[i][j] == 1 ? 0 : dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[m - 1][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LeetCode-第-64-号问题：最小路径和"><a href="#LeetCode-第-64-号问题：最小路径和" class="headerlink" title="LeetCode 第 64 号问题：最小路径和"></a>LeetCode 第 64 号问题：最小路径和</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>示例:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br></pre></td></tr></table></figure><br>解释: 因为路径 1→3→1→1→1 的总和最小。</p>
<h4 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h4><p>给定一个矩阵，问从起点(0,0) 到终点 (m-1,n-1) 的最小路径和是多少，并且每次移动只能向右或者向下，按之四个步骤来思考一下：</p>
<p>问题拆解:<br>拆解问题的方式方法和前两道题目非常类似，这里不同的地方只是记录的答案不同，也就是状态不同，我们还是可以仅仅考虑当前位置，然后可以看到只有上面的位置和左边的位置可以到达当前位置，因此当前问题就可以拆解成两个子问题</p>
<p>状态定义:<br>因为是要求路径和，因此状态需要记录的是 “从起始点到当前位置的最小路径和”</p>
<p>递推方程:<br>有了状态，以及问题之间的联系，我们知道了，当前的最短路径和可以由其上方和其左方的最短路径和对比得出，递推方程也可以很快写出来：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Math.min(dp[i - 1][j] + dp[i][j - 1]) + grid[i][j]</span><br></pre></td></tr></table></figure><br>实现</p>
<p>实现上面需要重点考虑的还是状态数组的初始化，这一步还是和前面两题类似，这里就不过多赘述</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int minPathSum(int[][] grid) &#123;</span><br><span class="line">    int m = grid.length, n = grid[0].length;</span><br><span class="line"></span><br><span class="line">    int[][] dp = new int[m][n];</span><br><span class="line"></span><br><span class="line">    dp[0][0] = grid[0][0];</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; m; ++i) &#123;</span><br><span class="line">        dp[i][0] = dp[i - 1][0] + grid[i][0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[0][i] = dp[0][i - 1] + grid[0][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; m; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt; n; ++j) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[m - 1][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LeetCode-第-221-号问题：最大正方形。"><a href="#LeetCode-第-221-号问题：最大正方形。" class="headerlink" title="LeetCode 第 221 号问题：最大正方形。"></a>LeetCode 第 221 号问题：最大正方形。</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p>示例:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><br>题目解析</p>
<p>题目给定一个字符矩阵，字符矩阵中只有两种字符，分别是 ‘0’ 和 ‘1’，题目要在矩阵中找全为 ‘1’ 的，面积最大的正方形。</p>
<p>刚拿道这道题，如果不说任何解法的话，其实并不是特别好想，我们先来看看切题的思路是怎么样的。</p>
<p>首先一个正方形是由四个顶点构成的，如果说我们在矩阵中随机找四个点，然后判断该四个点组成的是不是正方形，如果是正方形，然后看组成正方形的每个位置的元素是不是都是 ‘1’，这种方式也是可行的，但是比较暴力，这么弄下来，时间复杂度是 <code>O((m*n)^4)</code>。</p>
<p>那我们就会思考，组成一个正方形是不是必须要四个点都找到？如果我们找出其中的三个点，甚至说两个点，能不能确定这个正方形呢？</p>
<p>你会发现，这里我们只需要考虑 正方形对角线的两个点 即可，这两个点确定了，另外的两个点也就确定了，因此我们可以把时间复杂度降为<code>O((m*n)^2)</code>。</p>
<p>但是这里还是会有一些重复计算在里面，我们和之前一样，本质还是在做暴力枚举，只是说枚举的个数变少了，我们能不能记录我们之前得到过的答案，通过牺牲空间换取时间呢，这里正是动态规划所要做的事情！</p>
<p>问题拆解:<br>我们可以思考，如果我们从左到右，然后从上到下遍历矩阵，假设我们遍历到的当前位置是正方形的右下方的点，那其实我们可以看之前我们遍历过的点有没有可能和当前点组成符合条件的正方形，除了这个点以外，无非是要找另外三个点，这三个点分别在当前点的上方，左方，以及左上方，也就是从这个点往这三个方向去做延伸，具体延伸的距离是和其相邻的三个点中的状态有关</p>
<p>状态定义:<br>因为我们考虑的是正方形的右下方的顶点，因此状态可以定义成 “当前点为正方形的右下方的顶点时，正方形的最大面积”</p>
<p>递推方程:<br>有了状态，我们再来看看递推方程如何写，前面说到我们可以从当前点向三个方向延伸，我们看相邻的位置的状态，这里我们需要取三个方向的状态的最小值才能确保我们延伸的是全为 ‘1’ 的正方形，也就是<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1</span><br></pre></td></tr></table></figure><br>实现</p>
<p>在实现上，我们需要单独考虑两种情况，就是当前位置是 ‘1’，还有就是当前位置是 ‘0’，如果是 ‘0’ 的话，状态就是 0，表示不能组成正方形，如果是 ‘1’ 的话，我们也需要考虑位置，如果是第一行的元素，以及第一列的元素，表明该位置无法同时向三个方向延伸，状态直接给为 1 即可，其他情况就按我们上面得出的递推方程来计算当前状态。</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public int maximalSquare(char[][] matrix) &#123;</span><br><span class="line">    if (matrix.length == 0 || matrix[0].length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int m = matrix.length, n = matrix[0].length;</span><br><span class="line"></span><br><span class="line">    int[][] dp = new int[m][n];</span><br><span class="line"></span><br><span class="line">    int maxLength = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            if (matrix[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                if (i == 0 || j == 0) &#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j] == &#x27;1&#x27; ? 1 : 0;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - 1][j], </span><br><span class="line">                                        Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                maxLength = Math.max(dp[i][j], maxLength);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return maxLength * maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="序列类动态规划问题"><a href="#序列类动态规划问题" class="headerlink" title="序列类动态规划问题"></a>序列类动态规划问题</h1><p>这次再来看一类动态规划问题，序列类动态规划问题，这类动态规划问题较为普遍，分析难度相比之前也略有提升，通常问题的输入参数会涉及数组或是字符串。</p>
<p>在开始之前，先解释一下子数组（子串）和子序列的区别，你可以看看下面这个例子：</p>
<p>输入数组：[1,2,3,4,5,6,7,8,9]<br>子数组：[2,3,4], [5,6,7], [6,7,8,9], …<br>子序列：[1,5,9], [2,3,6], [1,8,9], [7,8,9], …<br>可以看到的是，子数组必须是数组中的一个连续的区间，而子序列并没有这样一个要求。</p>
<p>你只需要保证子序列中的元素的顺序和原数组中元素的顺序一致即可，例如，在原数组中，元素 1 出现在元素 9 之前，那么在子序列中，如果这两个元素同时出现，那么 1 也必须在 9 之前。</p>
<p>为什么要说这个？</p>
<p>不知道你有没有发现，这里的子数组的问题和我们前面提到的矩阵类动态规划的分析思路很类似，只需要考虑当前位置，以及当前位置和相邻位置的关系。</p>
<p>通过这样的分析就可以把之前讲的内容和今天要介绍的内容关联起来了，相比矩阵类动态规划，序列类动态规划最大的不同在于，对于第 i 个位置的状态分析，它不仅仅需要考虑当前位置的状态，还需要考虑前面 i - 1 个位置的状态，这样的分析思路其实可以从子序列的性质中得出。</p>
<p>对于这类问题的问题拆解，有时并不是那么好发现问题与子问题之间的联系，但是通常来说思考的方向其实在于 寻找当前状态和之前所有状态的关系，我们通过几个非常经典的动态规划问题来一起看看。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><p>LeetCode 第 300 号问题：最长上升子序列。</p>
<p>题目描述</p>
<p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p>
<p>示例:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure><br>说明:</p>
<p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p>
<p>题目解析:<br>给定一个数组，求最长递增子序列。因为是子序列，这样对于每个位置的元素其实都存在两种可能，就是选和不选，如果我们用暴力的解法，枚举出所有的子序列，然后判断他们是不是递增的，选取最大的递增序列，这样做的话，时间复杂度是 O(2^n)，显然不高效。</p>
<p>那这里我们就需要思考用动态规划进行优化，我们按之前的四个步骤来具体分析一下：</p>
<p>问题拆解:<br>我们要求解的问题是 “数组中最长递增子序列”，一个子序列虽然不是连续的区间，但是它依然有起点和终点，比如：</p>
<p>[10,9,2,5,3,7,101,18]</p>
<p>子序列 [2,3,7,18] 的起始位置是 2，终止位置是 18<br>子序列 [5,7,101] 的起始位置是 5，终止位置是 101<br>如果我们确定终点位置，然后去 看前面 i - 1 个位置中，哪一个位置可以和当前位置拼接在一起，这样就可以把第 i 个问题拆解成思考之前 i - 1 个问题，注意这里我们并不是不考虑起始位置，在遍历的过程中我们其实已经考虑过了。</p>
<p>状态定义:<br>问题拆解中我们提到 “第 i 个问题和前 i - 1 个问题有关”，也就是说 “如果我们要求解第 i 个问题的解，那么我们必须考虑前 i - 1 个问题的解”，我们定义 dp[i] 表示以位置 i 结尾的子序列的最大长度，也就是说 dp[i] 里面记录的答案保证了该答案表示的子序列以位置 i 结尾。</p>
<p>递推方程:<br>对于 i 这个位置，我们需要考虑前 i - 1 个位置，看看哪些位置可以拼在 i 位置之前，如果有多个位置可以拼在 i 之前，那么必须选最长的那个，这样一分析，递推方程就有了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = Math.max(dp[j],...,dp[k]) + 1, </span><br></pre></td></tr></table></figure><br>其中 inputArray[j] &lt; inputArray[i], inputArray[k] &lt; inputArray[i]</p>
<p>实现:<br>在实现这里，我们需要考虑状态数组的初始化，因为对于每个位置，它本身其实就是一个序列，因此所有位置的状态都可以初始化为 1。</p>
<p>最后提一下，对于这道题来说，这种方法其实不是最优的，但是在这里的话就不展开讲了，理解序列类动态规划的解题思路是关键。</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">    if (nums == null || nums.length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // dp[i] -&gt; the longest length sequence from 0 - i, and must include nums[i]</span><br><span class="line">    int[] dp = new int[nums.length];</span><br><span class="line"></span><br><span class="line">    Arrays.fill(dp, 1);</span><br><span class="line"></span><br><span class="line">    int max = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">            if (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[j] + 1, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="粉刷房子"><a href="#粉刷房子" class="headerlink" title="粉刷房子"></a>粉刷房子</h3><p>LeetCode 第 256 号问题：粉刷房子。</p>
<p>注意：本题为 LeetCode 的付费题目，需要开通会员才能解锁查看与提交代码。</p>
<p>题目描述:</p>
<p>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。<br>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。<br>例如，costs[0][0]表示第 0 号房子粉刷成红色的成本花费；costs[1][2]表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。</p>
<p>注意：</p>
<p>所有花费均为正整数。</p>
<p>示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [[17,2,17],[16,16,5],[14,3,19]]</span><br><span class="line">输出: 10</span><br><span class="line">解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。</span><br><span class="line">     最少花费: 2 + 5 + 3 = 10。</span><br></pre></td></tr></table></figure><br>题目解析</p>
<p>给 n 个房子刷油漆，有三种颜色的油漆可以刷，必须保证相邻房子的颜色不能相同，输入是一个 n x 3 的数组，表示每个房子使用每种油漆所需要花费的价钱，求刷完所有房子的最小价值。</p>
<p>还是按原来的思考方式走一遍：</p>
<p>问题拆解:<br>对于每个房子来说，都可以使用三种油漆当中的一种，如果说不需要保证相邻的房子的颜色必须不同，那么整个题目会变得非常简单，每个房子直接用最便宜的油漆刷就好了，但是加上这个限制条件，你会发现刷第 i 个房子的花费其实是和前面 i - 1 个房子的花费以及选择相关，如果说我们需要知道第 i 个房子使用第 k 种油漆的最小花费，那么你其实可以思考第 i - 1 个房子如果不用该油漆的最小花费，这个最小花费是考虑从 0 到当前位置所有的房子的。</p>
<p>状态定义:<br>通过之前的问题拆解步骤，状态可以定义成 dp[i][k]，表示如果第 i 个房子选择第 k 个颜色，那么从 0 到 i 个房子的最小花费</p>
<p>递推方程:<br>基于之前的状态定义，以及相邻的房子不能使用相同的油漆，那么递推方程可以表示成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k] = Math.min(dp[i - 1][l], ..., dp[i - 1][r]) + costs[i][k]， l != k, r != k</span><br></pre></td></tr></table></figure><br>实现:<br>因为我们要考虑 i - 1 的情况，但是第 0 个房子并不存在 i - 1 的情况，因此我们可以把第 0 个房子的最小花费存在状态数组中，当然你也可以多开一格 dp 状态，其实都是一样的。</p>
<p>对于这道题目，你可能会问这不是和矩阵类动态规划类似吗？</p>
<p>如果单从房子来考虑的确是，但是对于颜色的话，我们必须考虑考虑相邻房子的所有颜色，这就有点序列的意思在里面了。</p>
<p>另外对于题目的分类其实没有严格的限定，主要是为了把相类似的问题放在一起，这样有便于分析问题思路。</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int minCost(int[][] costs) &#123;</span><br><span class="line">    if (costs == null || costs.length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int n = costs.length;</span><br><span class="line"></span><br><span class="line">    int[][] dp = new int[n][3];</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; costs[0].length; ++i) &#123;</span><br><span class="line">        dp[0][i] = costs[0][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        dp[i][0] = Math.min(dp[i - 1][1], dp[i - 1][2]) + costs[i][0];</span><br><span class="line">        dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][2]) + costs[i][1];</span><br><span class="line">        dp[i][2] = Math.min(dp[i - 1][0], dp[i - 1][1]) + costs[i][2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Math.min(dp[n - 1][0], Math.min(dp[n - 1][1], dp[n - 1][2]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="粉刷房子II"><a href="#粉刷房子II" class="headerlink" title="粉刷房子II"></a>粉刷房子II</h3><p>LeetCode 第 265 号问题：粉刷房子II。</p>
<p>注意：本题为 LeetCode 的付费题目，需要开通会员才能解锁查看与提交代码。</p>
<p>题目描述</p>
<p>假如有一排房子，共 n 个，每个房子可以被粉刷成 k 种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p>
<p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x k 的矩阵来表示的。</p>
<p>例如，costs[0][0] 表示第 0 号房子粉刷成 0 号颜色的成本花费；costs[1][2] 表示第 1 号房子粉刷成 2 号颜色的成本花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。</p>
<p>注意：</p>
<p>所有花费均为正整数。</p>
<p>示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,5,3],[2,9,4]]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 将 0 号房子粉刷成 0 号颜色，1 号房子粉刷成 2 号颜色。最少花费: 1 + 4 = 5; </span><br><span class="line">     或者将 0 号房子粉刷成 2 号颜色，1 号房子粉刷成 0 号颜色。最少花费: 3 + 2 = 5. </span><br></pre></td></tr></table></figure><br>进阶：<br>您能否在 O(nk) 的时间复杂度下解决此问题？</p>
<p>题目解析</p>
<p>上面那道题目的 follow up，现在不是三种油漆，而是 k 种油漆。</p>
<p>其实解题思路还是不变。</p>
<p>对于第 i 个房子的每种颜色，我们对比看第 i - 1 个房子的 k 种油漆，找到不相重的最小值就好，但是这里的时间复杂度是 <code>O(n*k^2)</code>。</p>
<p>其实这是可以优化的，我们只需要在第 i - 1 个位置的状态中找到最大值和次大值，在选择第 i 个房子的颜色的时候，我们看当前颜色是不是和最大值的颜色相重，不是的话直接加上最大值，如果相重的话，我们就加上次大值，这样一来，我们把两个嵌套的循环，拆开成两个平行的循环，时间复杂度降至 <code>O(n*k)</code>。</p>
<p>参考代码(优化前)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public int minCostII(int[][] costs) &#123;</span><br><span class="line">    if (costs.length == 0 || costs[0].length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int n = costs.length, k = costs[0].length;</span><br><span class="line">    int[][] dp = new int[n][k];</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">        dp[0][i] = costs[0][i];</span><br><span class="line">    &#125;        </span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; k; ++j) &#123;</span><br><span class="line">            for (int m = 0; m &lt; k; ++m) &#123;</span><br><span class="line">                if (m != j) &#123;</span><br><span class="line">                    dp[i][m] = Math.min(dp[i][m], dp[i - 1][j] + costs[i][m]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = Integer.MAX_VALUE;</span><br><span class="line">    for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">        result = Math.min(result, dp[n - 1][i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>参考代码(优化后)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public int minCostII(int[][] costs) &#123;</span><br><span class="line">    if (costs.length == 0 || costs[0].length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int n = costs.length, k = costs[0].length;</span><br><span class="line">    int[][] dp = new int[n][k];</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">        dp[0][i] = costs[0][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        // min1 表示的是最大值，min2 表示的是次大值</span><br><span class="line">        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;</span><br><span class="line">        int minIndex = -1;</span><br><span class="line">        for (int l = 0; l &lt; k; ++l) &#123;</span><br><span class="line">            if (min1 &gt; dp[i - 1][l]) &#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                min1 = dp[i - 1][l];</span><br><span class="line">                minIndex = l;</span><br><span class="line">            &#125; else if (min2 &gt; dp[i - 1][l]) &#123;</span><br><span class="line">                min2 = dp[i - 1][l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j = 0; j &lt; k; ++j) &#123;</span><br><span class="line">            if (minIndex != j) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], min1 + costs[i][j]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], min2 + costs[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = Integer.MAX_VALUE;</span><br><span class="line">    for (int i = 0; i &lt; k; ++i) &#123;</span><br><span class="line">        result = Math.min(result, dp[n - 1][i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><p>LeetCode 第 198 号问题：打家劫舍。</p>
<p>题目描述</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p>示例 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure></p>
<p>题目解析</p>
<p>前面那道题目的 follow up，问的是如果这些房子的排列方式是一个圆圈，其余要求不变，问该如何处理。</p>
<p>房子排列方式是一个圆圈意味着之前的最后一个房子和第一个房子之间产生了联系，这里有一个小技巧就是我们线性考虑 [0, n - 2] 和 [1, n - 1]，然后求二者的最大值。</p>
<p>其实这么做的目的很明显，把第一个房子和最后一个房子分开来考虑。实现上面我们可以直接使用之前的实现代码。</p>
<p>这里有一个边界条件就是，当只有一个房子的时候，我们直接输出结果即可。</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public int rob(int[] nums) &#123;</span><br><span class="line">    if (nums == null || nums.length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nums.length == 1) &#123;</span><br><span class="line">        return nums[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int n = nums.length;</span><br><span class="line"></span><br><span class="line">    return Math.max(</span><br><span class="line">                    robI(Arrays.copyOfRange(nums, 0, n - 1)),</span><br><span class="line">                    robI(Arrays.copyOfRange(nums, 1, n))</span><br><span class="line">                   );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int robI(int[] nums) &#123;</span><br><span class="line">    if (nums == null || nums.length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int n = nums.length;</span><br><span class="line"></span><br><span class="line">    int[] dp = new int[n + 1];</span><br><span class="line"></span><br><span class="line">    dp[1] = nums[0];</span><br><span class="line"></span><br><span class="line">    for (int i = 2; i &lt;= n; ++i) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="相关的「股票」算法题"><a href="#相关的「股票」算法题" class="headerlink" title="相关的「股票」算法题"></a>相关的「股票」算法题</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。在学习动态规划之前需要明确掌握几个重要概念。</p>
<ul>
<li>阶段：对于一个完整的问题过程，适当的切分为若干个相互联系的子问题，每次在求解一个子问题，则对应一个阶段，整个问题的求解转化为按照阶段次序去求解。</li>
<li>状态：状态表示每个阶段开始时所处的客观条件，即在求解子问题时的已知条件。状态描述了研究的问题过程中的状况。</li>
<li>决策：决策表示当求解过程处于某一阶段的某一状态时，可以根据当前条件作出不同的选择，从而确定下一个阶段的状态，这种选择称为决策。</li>
<li>策略：由所有阶段的决策组成的决策序列称为全过程策略，简称策略。</li>
<li>最优策略：在所有的策略中，找到代价最小，性能最优的策略，此策略称为最优策略。</li>
<li>状态转移方程：状态转移方程是确定两个相邻阶段状态的演变过程，描述了状态之间是如何演变的。</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>能采用动态规划求解的问题的一般要具有 3 个性质：</p>
<ul>
<li>最优化：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。子问题的局部最优将导致整个问题的全局最优。换句话说，就是问题的一个最优解中一定包含子问题的一个最优解。</li>
<li>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关，与其他阶段的状态无关，特别是与未发生的阶段的状态无关。</li>
<li>重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</li>
</ul>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ul>
<li>划分阶段：按照问题的时间或者空间特征将问题划分为若干个阶段。</li>
<li>确定状态以及状态变量：将问题的不同阶段时期的不同状态描述出来。</li>
<li>确定决策并写出状态转移方程：根据相邻两个阶段的各个状态之间的关系确定决策。</li>
<li>寻找边界条件：一般而言，状态转移方程是递推式，必须有一个递推的边界条件。</li>
<li>设计程序，解决问题</li>
</ul>
<h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><p>下面的三道算法题都是来源于 LeetCode 上与股票买卖相关的问题 ，我们按照 动态规划 的算法流程来处理该类问题。</p>
<p>股票买卖这一类的问题，都是给一个输入数组，里面的每个元素表示的是每天的股价，并且你只能持有一支股票（也就是你必须在再次购买前出售掉之前的股票），一般来说有下面几种问法：</p>
<ul>
<li>只能买卖一次</li>
<li>可以买卖无数次</li>
<li>可以买卖 k 次</li>
</ul>
<p>需要你设计一个算法去获取最大的利润。</p>
<h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p>题目来源于 LeetCode 上第 121 号问题：买卖股票的最佳时机。题目难度为 Easy，目前通过率为 49.4% 。</p>
<p>题目描述</p>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p>
<p>示例 2:</p>
<p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>题目解析</p>
<p>我们按照动态规划的思想来思考这道问题。</p>
<p>状态:<br>有 买入（buy） 和 卖出（sell） 这两种状态。</p>
<p>转移方程:<br>对于买来说，买之后可以卖出（进入卖状态），也可以不再进行股票交易（保持买状态）。</p>
<p>对于卖来说，卖出股票后不在进行股票交易（还在卖状态）。</p>
<p>只有在手上的钱才算钱，手上的钱购买当天的股票后相当于亏损。也就是说当天买的话意味着损失-prices[i]，当天卖的话意味着增加prices[i]，当天卖出总的收益就是 buy+prices[i] 。</p>
<p>所以我们只要考虑当天买和之前买哪个收益更高，当天卖和之前卖哪个收益更高。</p>
<p>buy = max(buy, -price[i])  （注意：根据定义 buy 是负数）<br>sell = max(sell,  prices[i] + buy)</p>
<p>边界:<br>第一天 buy = -prices[0], sell = 0，最后返回 sell 即可。</p>
<p>代码实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        if(prices.length &lt;= 1)</span><br><span class="line">            return 0;</span><br><span class="line">        int buy = -prices[0], sell = 0;</span><br><span class="line">        for(int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            buy = Math.max(buy, -prices[i]);</span><br><span class="line">            sell = Math.max(sell, prices[i] + buy);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h3><p>题目来源于 LeetCode 上第 122 号问题：买卖股票的最佳时机 II。题目难度为 Easy，目前通过率为 53.0% 。</p>
<p>题目描述</p>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><br>示例 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><br>题目解析</p>
<p>状态:<br>有 买入（buy） 和 卖出（sell） 这两种状态。</p>
<p>转移方程:<br>对比上题，这里可以有无限次的买入和卖出，也就是说 买入 状态之前可拥有 卖出 状态，所以买入的转移方程需要变化。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buy = max(buy, sell - price[i])</span><br><span class="line">sell = max(sell,   buy + prices[i] )</span><br></pre></td></tr></table></figure><br>边界:<br>第一天 buy = -prices[0], sell = 0，最后返回 sell 即可。</p>
<p>代码实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        if(prices.length &lt;= 1)</span><br><span class="line">            return 0;</span><br><span class="line">        int buy = -prices[0], sell = 0;</span><br><span class="line">        for(int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            sell = Math.max(sell, prices[i] + buy);</span><br><span class="line">            buy = Math.max( buy,sell - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="买卖股票的最佳时机-III"><a href="#买卖股票的最佳时机-III" class="headerlink" title="买卖股票的最佳时机 III"></a>买卖股票的最佳时机 III</h3><p>题目来源于 LeetCode 上第 123 号问题：买卖股票的最佳时机 III。题目难度为 Hard，目前通过率为 36.1% 。</p>
<p>题目描述</p>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,3,5,0,0,3,1,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><br>示例 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1] </span><br><span class="line">输出: 0 </span><br><span class="line">解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><br>题目解析</p>
<p>这里限制了最多两笔交易。</p>
<p>状态:<br>有 第一次买入（fstBuy） 、 第一次卖出（fstSell）、第二次买入（secBuy） 和 第二次卖出（secSell） 这四种状态。</p>
<p>转移方程:<br>这里可以有两次的买入和卖出，也就是说 买入 状态之前可拥有 卖出 状态，所以买入和卖出的转移方程需要变化。</p>
<p>fstBuy = max(fstBuy ，  -price[i])<br>fstSell = max(fstSell，fstBuy + prices[i] )<br>secBuy = max(secBuy ，fstSell -price[i]) (受第一次卖出状态的影响)<br>secSell = max(secSell ，secBuy + prices[i] )</p>
<p>边界:<br>一开始 fstBuy = -prices[0]</p>
<p>买入后直接卖出，fstSell = 0</p>
<p>买入后再卖出再买入，secBuy - prices[0]</p>
<p>买入后再卖出再买入再卖出，secSell = 0</p>
<p>最后返回 secSell 。</p>
<p>代码实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int fstBuy = Integer.MIN_VALUE, fstSell = 0;</span><br><span class="line">        int secBuy = Integer.MIN_VALUE, secSell = 0;</span><br><span class="line">        for(int i = 0; i &lt; prices.length; i++) &#123;</span><br><span class="line">            fstBuy = Math.max(fstBuy, -prices[i]);</span><br><span class="line">            fstSell = Math.max(fstSell, fstBuy + prices[i]);</span><br><span class="line">            secBuy = Math.max(secBuy, fstSell -  prices[i]);</span><br><span class="line">            secSell = Math.max(secSell, secBuy +  prices[i]); </span><br><span class="line">        &#125;</span><br><span class="line">        return secSell;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="字符匹配类动态规划"><a href="#字符匹配类动态规划" class="headerlink" title="字符匹配类动态规划"></a>字符匹配类动态规划</h1><p>字符匹配类动态规划，你一听名字就知道和字符串匹配相关，这类题型它其实是 序列类动态规划 的一个递进，它有时也被称为 双序列类动态规划。</p>
<p>在 序列类动态规划 中，题目的输入是一个数组或是字符串，然后让你基于这个输入数组或是字符串进行一系列的判断，往往我们拆解问题、分析状态的时候只需要考虑一个维度的状态，比如刷房子和抢房子相关的问题，我们只需要考虑此时的房子和之前考虑过的房子之间的联系，思维始终是在一条线上。</p>
<p>回到字符匹配类动态规划，题目要你分析的是两个序列彼此之间的联系，这里其实有一个动态规划状态维度的提升，在考虑当前子问题的时候，我们要同时考虑两个序列的状态，当然，一般说来，动态规划状态维度的提升，也意味着难度的提升，可能刚从一维变成二维，你会不太习惯，没关系，多思考就好了，对于字符匹配类动态规划，它的题目特征其实特别明显，比如：</p>
<p>输入是两个字符串，问是否通过一定的规则相匹配<br>输入是两个字符串，问两个字符串是否存在包含被包含的关系<br>输入是两个字符串，问一个字符串怎样通过一定规则转换成另一个字符串<br>输入是两个字符串，问它们的共有部分<br>。。。<br>另外说一下，这类问题的难点在于问题的拆解上面，也就是如何找到当前问题和子问题的联系。</p>
<p>往往这类问题的状态比较好找，你可以先假设状态 dp[i][j] 就是子问题 str1(0…i) str2(0…j)  的状态。拆解问题主要思考 dp[i][j] 和子问题的状态 dp[i - 1][j]，dp[i - 1][j] 以及 dp[i - 1][j - 1] 的联系，因为字符串会存在空串的情况，所以动态规划状态数组往往会多开一格。</p>
<p>当然，对于这类问题，如果你还是没有什么思路或者想法，我给你的建议是 画表格，我们结合实际题目一起来看看。</p>
<h2 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h2><p>LeetCode 第 1143 号问题：最长公共子序列。</p>
<p>题目描述</p>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>
<p>若这两个字符串没有公共子序列，则返回 0。</p>
<p>示例 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure><br>示例 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0。</span><br></pre></td></tr></table></figure><br>题目分析</p>
<p>这里还是按之前的四个步骤来思考，当然这只是一个框架用来辅助你思考，不用特别拘泥于这四个步骤：</p>
<p>问题拆解:</p>
<p>我们要求解 str1(0,…m) 和 str2(0,…n) 的最长公共子序列，如果这是最终要求解的问题，那么它的子问题是什么呢？其实是 str1(0,…m-1) 和 str2(0,…n-1)，以及 str1(0,…m-1) 和 str2(0,…n)，还有 str1(0,…m) 和 str2(0,…n-1)，如果要找它们之间的关系，那我们需要思考一个问题就是，这些子问题怎么变成最终要求解的问题，当前的问题考虑当前字符是否相等，很直接的一个发现就是，如果 str1(m)==str2(n)，那么我们就可以将子问题中的 str1(0,…m-1) 和 str2(0,…n-1) 后面添加两个相同字符递进成当前问题；如果不相等，我们就需要考虑在三个子问题中选择一个较大值了。</p>
<p>说到这里，如果你还是不太清楚问题之间的联系，那我们一起来画画表格，熟悉一下这个过程：</p>
<p>题目求解 text1 = “abcde”, text2 = “ace” 的最长公共子序列<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &quot;&quot;  a  c  e</span><br><span class="line">&quot;&quot;  0  0  0  0</span><br><span class="line">a   0             如果其中一个字符串是空串</span><br><span class="line">b   0             那么两个字符不存在公共子序列</span><br><span class="line">c   0             对应的子问题状态初始化为 0</span><br><span class="line">d   0</span><br><span class="line">e   0</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &quot;&quot;  a  c  e</span><br><span class="line">&quot;&quot;  0  0  0  0</span><br><span class="line">a   0  1  1  1    text1 = &quot;a&quot;  text2 = &quot;a&quot; || text2 = &quot;ac&quot; || text2 = &quot;ace&quot;</span><br><span class="line">b   0             考虑当前状态 dp[i][j] 的时候        </span><br><span class="line">c   0             我们可以考虑子状态 dp[i - 1][j - 1]</span><br><span class="line">d   0                             dp[i][j - 1]</span><br><span class="line">e   0                             dp[i - 1][j]</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &quot;&quot;  a  c  e</span><br><span class="line">&quot;&quot;  0  0  0  0</span><br><span class="line">a   0  1  1  1    </span><br><span class="line">b   0  1  1  1    text1 = &quot;ab&quot;  text2 = &quot;a&quot; || text2 = &quot;ac&quot; || text2 = &quot;ace&quot;</span><br><span class="line">c   0</span><br><span class="line">d   0</span><br><span class="line">e   0</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &quot;&quot;  a  c  e</span><br><span class="line">&quot;&quot;  0  0  0  0</span><br><span class="line">a   0  1  1  1    </span><br><span class="line">b   0  1  1  1</span><br><span class="line">c   0  1  2  2    text1 = &quot;abc&quot;  text2 = &quot;a&quot; || text2 = &quot;ac&quot; || text2 = &quot;ace&quot;</span><br><span class="line">d   0             画到这里，不知道你有没有发现当当前的字符不相同时</span><br><span class="line">e   0                 dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &quot;&quot;  a  c  e</span><br><span class="line">&quot;&quot;  0  0  0  0</span><br><span class="line">a   0  1  1  1    </span><br><span class="line">b   0  1  1  1</span><br><span class="line">c   0  1  2  2</span><br><span class="line">d   0  1  2  2    text1 = &quot;abcd&quot;  text2 = &quot;a&quot; || text2 = &quot;ac&quot; || text2 = &quot;ace&quot;</span><br><span class="line">e   0</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &quot;&quot;  a  c  e</span><br><span class="line">&quot;&quot;  0  0  0  0</span><br><span class="line">a   0  1  1  1    </span><br><span class="line">b   0  1  1  1</span><br><span class="line">c   0  1  2  2</span><br><span class="line">d   0  1  2  2    </span><br><span class="line">e   0  1  2  3    text1 = &quot;abcde&quot;  text2 = &quot;a&quot; || text2 = &quot;ac&quot; || text2 = &quot;ace&quot;</span><br></pre></td></tr></table></figure><br>3 就是我们要返回的答案<br>状态定义:<br>dp[i][j] 表示的就是 str1(0,…i) 和 str2(0,…j) 的答案，基本上字符串匹配类动态规划都可以先尝试这样去定义状态</p>
<p>递推方程:<br>在拆解问题中也说了，有两种情况，就是:</p>
<p>如果 str1(i) != str2(j):<br><code>dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])</code></p>
<p>如果 str1(i) == str2(j):<br><code>dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + 1)</code></p>
<p>因为 <code>dp[i - 1][j - 1] + 1 &gt;= dp[i - 1][j] &amp;&amp; dp[i - 1][j - 1] + 1 &gt;= dp[i][j - 1]</code><br>所以第二项可以化简：</p>
<p>如果 str1(i) == str2(j):<br><code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p>
<p>实现<br>通常来说字符相关的问题可以把状态数组多开一格用来存放空串匹配的情况，这道题空串的情况答案都是 0，使用 Java 语言也不需要考虑初始化</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class="line">    int length1 = text1.length();</span><br><span class="line">    int length2 = text2.length();</span><br><span class="line"></span><br><span class="line">    int[][] dp = new int[length1 + 1][length2 + 1];</span><br><span class="line"></span><br><span class="line">    char[] textArr1 = text1.toCharArray();</span><br><span class="line">    char[] textArr2 = text2.toCharArray();</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= length1; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= length2; ++j) &#123;</span><br><span class="line">            if (textArr1[i - 1] == textArr2[j - 1]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LeetCode-第-72-号问题：编辑距离。"><a href="#LeetCode-第-72-号问题：编辑距离。" class="headerlink" title="LeetCode 第 72 号问题：编辑距离。"></a>LeetCode 第 72 号问题：编辑距离。</h3><p>题目描述</p>
<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符<br>示例 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (删除 &#x27;e&#x27;)</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line">intention -&gt; inention (删除 &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (插入 &#x27;u&#x27;)</span><br></pre></td></tr></table></figure><br>题目分析</p>
<p>求解编辑距离，也是经典老题，编辑距离其实在实际工作中也会用到，主要用于分析两个单词的相似程度，两个单词的编辑距离越小证明两个单词的相似度越高。</p>
<p>题目说可以通过增加字符，删除字符，以及 替换字符 这三个操作来改变一个字符串，并且每个操作的 cost 都是 1，问一个单词转换成另一个单词的最小 cost，老样子，四个步骤分析一遍：</p>
<p>问题拆解:<br>我们考虑求解 str1(0…m) 通过多少 cost 变成 str2(0…n)，还是来看看它的子问题，其实还是三个</p>
<p>str1(0…m-1) 通过多少 cost 变成 str2(0…n)<br>str1(0…m) 通过多少 cost 变成 str2(0…n-1)<br>str1(0…m-1) 通过多少 cost 变成 str2(0…n-1)</p>
<p>一般字符匹配类问题的核心永远是两个字符串中的字符的比较，而且字符比较也只会有两种结果，那就是 相等 和 不相等，在字符比较的结果之上我们才会进行动态规划的统计和推导。</p>
<p>回到这道题，当我们在比较 str1(m) 和 str2(n) 的时候也会有两种结果，即 相等 或 不相等，如果说是 相等，那其实我们就不需要考虑这两个字符，问题就直接变成了子问题 str1(0…m-1) 通过多少 cost 变成 str2(0…n-1)，如果说 不相等，那我们就可以执行题目给定的三种变换策略:</p>
<p>将问题中的 str1 末尾字符 str1(m) 删除，因此只需要考虑子问题 str1(0…m-1)，str2(0…n)</p>
<p>将问题中的 str1 末尾字符 str1(m) 替换 成 str2(n)，这里我们就只需要考虑子问题 str1(0…m-1)，str2(0…n-1)</p>
<p>将问题中的 str1 末尾 添加 一个字符 str2(n)，添加后 str1(m+1) 必定等于 str2(n)，所以，我们就只需要考虑子问题 str1(0…m)，str2(0…n-1)</p>
<p>如果你还不是特别清楚问题之间的关系，那就画图表吧，这里我就略过。</p>
<p>状态定义</p>
<p>dp[i][j] 表示的是子问题 str1(0…i)，str2(0…j) 的答案，和常规的字符匹配类动态规划题目一样，没什么特别</p>
<p>递推方程:<br>问题拆解那里其实说的比较清楚了，这里需要把之前的描述写成表达式的形式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1(i) == str2(j):</span><br><span class="line">dp[i][j] = dp[i - 1][j - 1]</span><br><span class="line">tip: 这里不需要考虑 dp[i - 1][j] 以及 dp[i][j - 1]，因为</span><br><span class="line">   dp[i - 1][j - 1] &lt;= dp[i - 1][j] +1 &amp;&amp; dp[i - 1][j - 1] &lt;= dp[i][j - 1] + 1</span><br><span class="line"></span><br><span class="line">str1(i) != str2(j):</span><br><span class="line">dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][i - 1]) + 1</span><br></pre></td></tr></table></figure><br>你可以看到字符之间比较的结果永远是递推的前提</p>
<p>实现:<br>这里有一个初始化，就是当一个字符串是空串的时候，转化只能通过添加元素或是删除元素来达成，那这里状态数组中存的值其实是和非空字符串的字符数量保持一致。</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int minDistance(String word1, String word2) &#123;</span><br><span class="line">    char[] arr1 = word1.toCharArray();</span><br><span class="line">    char[] arr2 = word2.toCharArray();</span><br><span class="line"></span><br><span class="line">    int[][] dp = new int[arr1.length + 1][arr2.length + 1];</span><br><span class="line">    dp[0][0] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= arr1.length; ++i) &#123;</span><br><span class="line">        dp[i][0] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= arr2.length; ++i) &#123;</span><br><span class="line">        dp[0][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= arr1.length; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= arr2.length; ++j) &#123;</span><br><span class="line">            if (arr1[i - 1] == arr2[j - 1]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - 1][j], </span><br><span class="line">                                    Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[arr1.length][arr2.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LeetCode-第-44-号问题：通配符匹配。"><a href="#LeetCode-第-44-号问题：通配符匹配。" class="headerlink" title="LeetCode 第 44 号问题：通配符匹配。"></a>LeetCode 第 44 号问题：通配符匹配。</h3><p>题目描述</p>
<p>给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 <code>?</code> 和 <code>*</code> 的通配符匹配。</p>
<p><code>?</code> 可以匹配任何单个字符。<br><code>*</code> 可以匹配任意字符串（包括空字符串）。<br>两个字符串完全匹配才算匹配成功。</p>
<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。<br>示例 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &#x27;*&#x27; 可以匹配任意字符串。</span><br></pre></td></tr></table></figure><br>示例 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;cb&quot;</span><br><span class="line">p = &quot;?a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &#x27;?&#x27; 可以匹配 &#x27;c&#x27;, 但第二个 &#x27;a&#x27; 无法匹配 &#x27;b&#x27;。</span><br></pre></td></tr></table></figure><br>示例 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;adceb&quot;</span><br><span class="line">p = &quot;*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 第一个 &#x27;*&#x27; 可以匹配空字符串, 第二个 &#x27;*&#x27; 可以匹配字符串 &quot;dce&quot;.</span><br></pre></td></tr></table></figure><br>示例 5:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;acdcb&quot;</span><br><span class="line">p = &quot;a*c?b&quot;</span><br><span class="line">输入: false</span><br></pre></td></tr></table></figure><br>题目分析:<br>题目给定两个字符串，一个字符串是匹配串，除了小写字母外，匹配串里面还包含 * 和 ? 这两个特殊字符，另一个是普通字符串，里面只包含小写字母。</p>
<p>题目问这个普通字符串是否和匹配字符串相匹配，匹配规则是 ? 可以匹配单个字符，* 可以匹配一个区间，也就是多个字符，当然也可以匹配 0 个字符，也就是空串。</p>
<p>依然是四个步骤走一遍：</p>
<p>问题拆解:<br>做多了，你发现这种问题其实都是一个套路，老样子，我们还是根据我们要求解的问题去看和其直接相关的子问题，我们需要求解的问题是 pattern(0…m) 和 str(0…n) 是否匹配，这里的核心依然是字符之间的比较，但是和之前不同的是，这个比较不仅仅是看两个字符相不相等，它还有了一定的匹配规则在里面，那我们就依次枚举讨论下：</p>
<p>pattern(m) == str(n):<br>问题拆解成看子问题 pattern(0…m-1) 和 str(0…n-1) 是否匹配<br>pattern(m) == ?:<br>问题拆解成看子问题 pattern(0…m-1) 和 str(0…n-1) 是否匹配</p>
<p>你发现弄来弄去，子问题依然是那三个：<br>pattern(0…m-1) 和 str(0…n-1) 是否匹配<br>pattern(0…m-1) 和 str(0…n) 是否匹配<br>pattern(0…m) 和 str(0…n-1) 是否匹配</p>
<p>不知道你是否发现了字符匹配类动态规划问题的共性，如果是画表格，你只需要关注当前格子的 左边、上边、左上 这三个位置的相邻元素，因为表格有实际数据做辅助，所以画表格有时可以帮助你找到问题与子问题之间的联系。</p>
<p>状态定义:<br>还是老样子，dp[i][j] 表示的就是问题 pattern(0…i) 和 str(0…j) 的答案，直接说就是 pattern(0…i) 和 str(0…j) 是否匹配</p>
<p>递推方程:<br>把之前 “问题拆解” 中的文字描述转换成状态的表达式就是递推方程：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pattern(i) == str(j) || pattern(i) == &#x27;?&#x27;:</span><br><span class="line">dp[i][j] = dp[i - 1][j - 1]</span><br><span class="line"></span><br><span class="line">pattern(i) == &#x27;*&#x27;:</span><br><span class="line">dp[i][j] = dp[i - 1][j] || dp[i][j - 1]</span><br></pre></td></tr></table></figure></p>
<p>实现<br>这类问题的状态数组往往需要多开一格，主要是为了考虑空串的情况，这里我就不赘述了。</p>
<p>我想说的是，关于初始化的部分，如果 str 是空的，pattern 最前面有 <code>*</code>，因为 <code>*</code> 是可以匹配空串的，因此这个也需要记录一下，反过来，如果 pattern 是空的，str 只要不是空的就无法匹配，这里就不需要特别记录。</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean isMatch(String s, String p) &#123;</span><br><span class="line">    char[] sArr = s.toCharArray();</span><br><span class="line">    char[] pArr = p.toCharArray();</span><br><span class="line"></span><br><span class="line">    boolean[][] dp = new boolean[pArr.length + 1][sArr.length + 1];</span><br><span class="line"></span><br><span class="line">    dp[0][0] = true;</span><br><span class="line">    for (int i = 1; i &lt;= pArr.length; ++i) &#123;</span><br><span class="line">        if (pArr[i - 1] != &#x27;*&#x27;) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dp[i][0] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= pArr.length; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= sArr.length; ++j) &#123;</span><br><span class="line">            if (sArr[j - 1] == pArr[i - 1] || pArr[i - 1] == &#x27;?&#x27;) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">            &#125; else if (pArr[i - 1] == &#x27;*&#x27;) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[pArr.length][sArr.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LeetCode-第-97-号问题"><a href="#LeetCode-第-97-号问题" class="headerlink" title="LeetCode 第 97 号问题"></a>LeetCode 第 97 号问题</h3><p>题目描述</p>
<p>给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。</p>
<p>示例 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><br>题目分析</p>
<p>题目的输入是三个字符串，问其中两个字符串是否能够交错合并组成第三个字符串，一个字符相对于其他字符的顺序在合并之后不能改变，这也是这道题的难点，不然的话你用一个哈希表就可以做了，三个字符串是否意味着要开三维的状态数组？还是四个步骤来看看：</p>
<p>问题拆解:<br>在拆解问题之前，我们必须保证前两个字符串的字符的总数量必须正好等于第三个字符串的字符总数量，不然的话，再怎么合并也无法完全等同。这里有一个点，当我们考虑 str1(0…i) 和 str2(0…j) 的时候，其实第三个字串需要考虑的范围也就确定了，就是 str3(0…i+j)。如果我们要求解问题 str1(0…m) 和 str2(0…n) 是否能够交错组成 str3(0…m+n)，还是之前那句话，字符串匹配问题的核心永远是字符之间的比较：</p>
<p>如果 str1(m) == str3(m+n)，问题拆解成考虑子问题 str1(0…m-1) 和 str2(0…n) 是否能够交错组成 str3(0…m+n-1)<br>如果 str2(n) == str3(m+n)，问题拆解成考虑子问题 str1(0…m) 和 str2(0…n-1) 是否能够交错组成 str3(0…m+n-1)</p>
<p>你可能会问需不需要考虑子问题 str1(0…m-1) 和 str2(0…n-1)？</p>
<p>在这道题目当中，不需要！</p>
<p>千万不要题目做多了就固定思维了，之前说到这类问题可以试着考虑三个相邻子问题是为了让你有个思路，能更好地切题，并不是说所有的字符串匹配问题都需要考虑这三个子问题，我们需要遇到具体问题具体分析。</p>
<p>状态定义:<br>dp[i][j] 表示的是 str1(0…i) 和 str2(0…j) 是否可以交错组成 str3(0…i+j)，这里再补充说明下为什么我们不需要开多一维状态来表示 str3，其实很简单，str3 的状态是由 str1 str2 决定的，str1 str2 定了，str3 就定了</p>
<p>递推方程:<br>把之前问题拆解中的文字描述转换成状态的表达式就是递推方程：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1(i) == str3(i+j)</span><br><span class="line">dp[i][j] |= dp[i - 1][j]</span><br><span class="line"></span><br><span class="line">str2(j) == str3(i+j)</span><br><span class="line">dp[i][j] |= dp[i - 1][j]</span><br></pre></td></tr></table></figure><br>实现</p>
<p>初始化的时候需要考虑单个字符串能否组成 str3 对应的区间，这个比较简单，直接判断前缀是否相等即可。</p>
<p>参考代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public boolean isInterleave(String s1, String s2, String s3) &#123;</span><br><span class="line">    int length1 = s1.length();</span><br><span class="line">    int length2 = s2.length();</span><br><span class="line">    int length3 = s3.length();</span><br><span class="line"></span><br><span class="line">    if (length1 + length2 != length3) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean[][] dp = new boolean[length1 + 1][length2 + 1];</span><br><span class="line"></span><br><span class="line">    dp[0][0] = true;</span><br><span class="line"></span><br><span class="line">    char[] sArr1 = s1.toCharArray();</span><br><span class="line">    char[] sArr2 = s2.toCharArray();</span><br><span class="line">    char[] sArr3 = s3.toCharArray();</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= length1; ++i) &#123;</span><br><span class="line">        dp[i][0] = dp[i - 1][0] &amp;&amp; sArr1[i - 1] == sArr3[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= length2; ++i) &#123;</span><br><span class="line">        dp[0][i] = dp[0][i - 1] &amp;&amp; sArr2[i - 1] == sArr3[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= length1; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= length2; ++j) &#123;</span><br><span class="line">            if (sArr3[i + j - 1] == sArr1[i - 1]) &#123;</span><br><span class="line">                dp[i][j] |= dp[i - 1][j];</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            if (sArr3[i + j - 1] == sArr2[j - 1]) &#123;</span><br><span class="line">                dp[i][j] |= dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>背包问题是一类比较 特殊的动态规划 问题，这篇文章的侧重点会在答案的推导过程上，我们还是会使用之前提到的解动态规划问题的四个步骤来思考这类问题。</p>
<p>在讲述背包问题之前，首先提及一下，背包类动态规划问题和其他的动态规划问题的不同之处在于，背包类动态规划问题会选用值来作为动态规划的状态，你可以回顾下之前我们讨论过的动态规划问题，基本上都是利用数组或者是字符串的下标来表示动态规划的状态。</p>
<p>针对背包类问题，我们依然可以 画表格 来辅助我们思考问题，但是背包类问题有基本的雏形，题目特征特别明显，当你理解了这类问题的解法后，遇到类似问题基本上不需要额外的辅助就可以给出大致的解法，这也就是说，学习背包类问题是一个性价比很高的事情，理解了一个特定问题的解法，基本上一类问题都可以直接套这个解法。</p>
<h2 id="问题雏形"><a href="#问题雏形" class="headerlink" title="问题雏形"></a>问题雏形</h2><p>首先我们来看看这样一个问题：</p>
<p>有 N 件物品和一个容量为 V 的背包。第 i 件物品的体积是 C[i]，价值是 W[i]。求解将哪些物品装入背包可使价值总和最大。求出最大总价值</p>
<p>话不多说，我们还是按之前的分析四步骤来看看这个问题：</p>
<p>问题拆解:<br>我们要求解的问题是 “背包能装入物品的最大价值”，这个问题的结果受到两个因素的影响，就是背包的大小，以及物品的属性（包括大小和价值）。对于物品来说，只有两种结果，放入背包以及不放入背包，这里我们用一个例子来画画表格：</p>
<p>假设背包的大小是 10，有 4 个物品，体积分别是 [2,3,5,7]，价值分别是 [2,5,2,5]。</p>
<p>1、如果我们仅考虑将前一个物品放入背包，只要背包体积大于 2，此时都可以获得价值为 2 的最大价值：</p>
<p><img src="/img/20200106220746.jpg" alt=""><br>图一</p>
<p>2、如果我们仅考虑将前两个物品放入背包，如果背包体积大于或等于 5，表示两个物体都可放入，此时都可以获得价值为 2+5=7 的最大价值，如果不能全都放入，那就要选择体积不超，价值最大的那个：</p>
<p><img src="/img/20200106220819.jpg" alt=""><br>图二</p>
<p>3、如果我们仅考虑将前三个物品放入背包，如果背包体积大于或等于 10，表示三个物体都可放入，此时都可以获得价值为 2+5+2=9 的最大价值，如果不能全都放入，那就要选择体积不超，价值最大的那个方案：</p>
<p><img src="/img/20200106220922.jpg" alt=""><br>图三<br>4、如果我们考虑将所有物品放入背包，我们可以依据前三个物品放入的结果来制定方案：</p>
<p><img src="/img/20200106220935.jpg" alt=""><br>图四<br>这样，我们就根据物品和体积将问题拆分成子问题，也就是 “前 n 个物品在体积 V 处的最大价值” 可以由 “前 n - 1 个物品的情况” 推导得到。</p>
<p>状态定义:<br>在问题拆解中，我们得知问题其实和背包的体积还有当前考虑的物品有关，因此我们可以定义 dp[i][j] 表示 “考虑将前 i 个物品放入体积为 j 的背包里所获得的最大价值”</p>
<p>递推方程:<br>当我们考虑是否将第 i 个物品放入背包的时候，这里有两种情况</p>
<p>不放入，也就是不考虑第 i 个物品，那么问题就直接变成了上一个子问题，也就是考虑将 i - 1 个物品放入背包中，这样当前问题的解就是之前问题的解：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j]</span><br></pre></td></tr></table></figure><br>如果背包体积大于第 i 个物品的体积，我们可以考虑将第 i 个物品放入，这个时候我们要和之前的状态做一个比较，选取最大的方案：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - C[i]] + W[i])</span><br></pre></td></tr></table></figure><br>实现<br>实现这一环节还是主要考虑状态数组如何初始化，你可以看到，我们每次都要考虑 i - 1，另外还要考虑背包体积为 0 的情况，因此初始化数组时多开一格可以省去不必要的麻烦<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public int zeroOnePack(int V, int[] C, int[] W) &#123; </span><br><span class="line">    // 防止无效输入</span><br><span class="line">    if ((V &lt;= 0) || (C.length != W.length)) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int n = C.length;</span><br><span class="line"></span><br><span class="line">    // dp[i][j]: 对于下标为 0～i 的物品，背包容量为 j 时的最大价值</span><br><span class="line">    int[][] dp = new int[n + 1][V + 1];</span><br><span class="line"></span><br><span class="line">    // 背包空的情况下，价值为 0</span><br><span class="line">    dp[0][0] = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= V; ++j) &#123;</span><br><span class="line">            // 不选物品 i 的话，当前价值就是取到前一个物品的最大价值，也就是 dp[i - 1][j]</span><br><span class="line">            dp[i][j] = dp[i - 1][j];</span><br><span class="line"></span><br><span class="line">            // 如果选择物品 i 使得当前价值相对不选更大，那就选取 i，更新当前最大价值</span><br><span class="line">            if ((j &gt;= C[i - 1]) &amp;&amp; (dp[i][j] &lt; dp[i - 1][j - C[i - 1]] + W[i - 1])) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j - C[i - 1]] + W[i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回，对于所有物品（0～N），背包容量为 V 时的最大价值</span><br><span class="line">    return dp[n][V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里还有一个空间上面的优化，如果你回到我们之前画的表格，考虑前 i 个问题的状态只会依赖于前 i - 1 个问题的状态，也就是 dp[i][…] 只会依赖于 dp[i - 1][…]，另外一点就是当前考虑的背包体积只会用到比其小的体积。</p>
<p>基于这些信息，我们状态数组的维度可以少开一维，但是遍历的方向上需要从后往前遍历，从而保证子问题需要用到的数据不被覆盖，优化版本如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int zeroOnePackOpt(int V, int[] C, int[] W) &#123; </span><br><span class="line">    // 防止无效输入</span><br><span class="line">    if ((V &lt;= 0) || (C.length != W.length)) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int n = C.length;</span><br><span class="line"></span><br><span class="line">    int[] dp = new int[V + 1];</span><br><span class="line"></span><br><span class="line">    // 背包空的情况下，价值为 0</span><br><span class="line">    dp[0] = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = V; j &gt;= C[i]; --j) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - C[i]] + W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里，因为物品只能被选中 1 次，或者被选中 0 次，因此我们称这种背包问题为 01 背包问题。</p>
<p>还有一类背包问题，物品可以被选多次或者 0 次，这类问题我们称为 完全背包问题，这类背包问题和 01 背包问题很类似，略微的不同在于，在完全背包问题中，状态 dp[i][j] 依赖的是 dp[i - 1][j] 以及 dp[i][k] k &lt; j，你可以看看下面的实现代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public int completePack(int V, int[] C, int[] W) &#123;</span><br><span class="line">    // 防止无效输入</span><br><span class="line">    if (V == 0 || C.length != W.length) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int n = C.length;</span><br><span class="line"></span><br><span class="line">    // dp[i][j]: 对于下标为 0～i 的物品，背包容量为 j 时的最大价值</span><br><span class="line">    int[][] dp = new int[n + 1][V + 1];</span><br><span class="line"></span><br><span class="line">    // 背包空的情况下，价值为 0</span><br><span class="line">    dp[0][0] = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= V; ++j) &#123;</span><br><span class="line">            // 不取该物品</span><br><span class="line">            dp[i][j] = dp[i - 1][j];</span><br><span class="line"></span><br><span class="line">            // 取该物品，但是是在考虑过或者取过该物品的基础之上(dp[i][...])取</span><br><span class="line">            // 0-1背包则是在还没有考虑过该物品的基础之上(dp[i - 1][...])取</span><br><span class="line">            if ((j &gt;= C[i - 1]) &amp;&amp; (dp[i][j - C[i - 1]] + W[i - 1] &gt; dp[i][j])) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - C[i - 1]] + W[i - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回，对于所有物品（0～N），背包容量为 V 时的最大价值</span><br><span class="line">    return dp[n][V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>类似的，我们还是可以对状态数组进行空间优化，依据我们之前讨论的状态之间的依赖关系，完全背包的空间优化我们直接把状态数组少开一维即可，遍历方式都不需要改变：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int completePackOpt(int V, int[] C, int[] W) &#123;</span><br><span class="line">    if (V == 0 || C.length != W.length) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int n = C.length;</span><br><span class="line">    int[] dp = new int[V + 1];</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = C[i]; j &lt;= V; ++j) &#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - C[i]] + W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[V];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面，我们就根据这两类背包问题，看看遇到类似的问题我们是否可以套用上面我们介绍的解法。</p>
<h2 id="相关题目实战"><a href="#相关题目实战" class="headerlink" title="相关题目实战"></a>相关题目实战</h2><h3 id="LeetCode-第-416-号问题：分割等和子集。"><a href="#LeetCode-第-416-号问题：分割等和子集。" class="headerlink" title="LeetCode 第 416 号问题：分割等和子集。"></a>LeetCode 第 416 号问题：分割等和子集。</h3><p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p>
<p>题目描述</p>
<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>注意:</p>
<p>每个数组中的元素不会超过 100<br>数组的大小不会超过 200<br>示例 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line">输出: true</span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line">输出: false</span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure><br>题目分析</p>
<p>题目给定一个数组，问是否可以将数组拆分成两份，并且两份的值相等，这里并不是说分成两个子数组，而是分成两个子集。</p>
<p>直观的想法是直接遍历一遍数组，这样我们可以得到数组中所有元素的和，这个和必须是偶数，不然没法分，其实很自然地就可以想到，我们要从数组中挑出一些元素，使这些元素的和等于原数组中元素总和的一半，“从数组中找出一些元素让它们的和等于一个固定的值”，这么一个信息能否让你想到背包类动态规划呢？</p>
<p>如果你能想到这个地方，再配上我们之前讲的 01 背包问题 的解法，那么这道题目就可以直接套解法了，这里我就不具体分析了。</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public boolean canPartition(int[] nums) &#123;</span><br><span class="line">    if (nums == null || nums.length == 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int sum = 0;</span><br><span class="line"></span><br><span class="line">    int n = nums.length;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (sum % 2 != 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int target = sum / 2;</span><br><span class="line"></span><br><span class="line">    boolean[] dp = new boolean[target + 1];</span><br><span class="line"></span><br><span class="line">    dp[0] = true;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        for (int j = target; j &gt;= nums[i]; --j) &#123;</span><br><span class="line">            dp[j] |= dp[j - nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LeetCode-第-322-号问题：零钱兑换。"><a href="#LeetCode-第-322-号问题：零钱兑换。" class="headerlink" title="LeetCode 第 322 号问题：零钱兑换。"></a>LeetCode 第 322 号问题：零钱兑换。</h3><p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change">https://leetcode-cn.com/problems/coin-change</a></p>
<p>题目描述</p>
<p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>
<p>示例 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [2], amount = 3</span><br><span class="line">输出: -1</span><br><span class="line">说明:</span><br><span class="line">你可以认为每种硬币的数量是无限的。</span><br></pre></td></tr></table></figure><br>题目分析</p>
<p>题目给定一个数组和一个整数，数组里面的值表示的是每个硬币的价值，整数表示的是一个价值，问最少选择多少个硬币能够组成这个价值，硬币可以重复选择。</p>
<p>虽然这里只有一个输入数组，但是我们还是可以看到背包的影子，这里的整数就可以看作是背包的体积，然后数组里面的值可以看作是物品的体积，那物品的价值呢？</p>
<p>在这里，你可以形象地认为每个物品的价值是 1，最后我们要求的是填满背包的最小价值，因为这里物品是可以重复选择多次的，因此可以归类于 完全背包问题，套用之前的解法就可以解题，唯一要注意的一点是，这里我们不在求最大价值，而求的是最小价值，因此我们需要先将状态数组初始化成无穷大。</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int coinChange(int[] coins, int amount) &#123;</span><br><span class="line">    int[] dp = new int[amount + 1];</span><br><span class="line"></span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    dp[0] = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; coins.length; ++i) &#123;</span><br><span class="line">        for (int j = coins[i]; j &lt;= amount; ++j) &#123;</span><br><span class="line">            if (dp[j - coins[i]] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LeetCode-第-518-号问题：零钱兑换II。"><a href="#LeetCode-第-518-号问题：零钱兑换II。" class="headerlink" title="LeetCode 第 518 号问题：零钱兑换II。"></a>LeetCode 第 518 号问题：零钱兑换II。</h3><p>题目来源：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change-2/">https://leetcode-cn.com/problems/coin-change-2/</a></p>
<p>题目描述</p>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p>
<p>示例 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: amount = 5, coins = [1, 2, 5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有四种方式可以凑成总金额:</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: amount = 3, coins = [2]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 只用面额2的硬币不能凑成总金额3。</span><br></pre></td></tr></table></figure><br>示例 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: amount = 10, coins = [10] </span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><br>注意:</p>
<p>你可以假设：</p>
<p>0 &lt;= amount (总金额) &lt;= 5000<br>1 &lt;= coin (硬币面额) &lt;= 5000<br>硬币种类不超过 500 种<br>结果符合 32 位符号整数</p>
<p>题目分析</p>
<p>这道题目是上一道题目的变形，题目的输入参数还是不变，变的是最后的问题，这里需要求的是 “有多少种组合方式能够填满背包”，我们还是可以套用 完全背包 的解法，只是最后求解的东西变了，那我们动态规划状态数组中记录的东西相应的改变即可，在这道题中，状态数组中记录组合成该价值的方案的个数即可。</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int change(int amount, int[] coins) &#123;</span><br><span class="line">    int[] dp = new int[amount + 1];</span><br><span class="line"></span><br><span class="line">    dp[0] = 1;</span><br><span class="line">    for (int i = 0; i &lt; coins.length; ++i) &#123;</span><br><span class="line">        for (int j = coins[i]; j &lt;= amount; ++j) &#123;</span><br><span class="line">            dp[j] += dp[j - coins[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="K-Sum。"><a href="#K-Sum。" class="headerlink" title="K Sum。"></a>K Sum。</h3><p>题目描述</p>
<p>给定一个输入数组 array，还有两个整数 k 和 target，在数组 array 中找出 k 个元素，使得这 k 个元素相加等于 target，问有多少种组合方式，输出组合方式的个数。</p>
<p>注：在一种组合方式中，一个元素不能够被重复选择</p>
<p>题目分析</p>
<p>我们之前讲过 Two Sum，也提到过 3 Sum，还有 4 Sum，那这道题是否可以套用之前的解法呢？</p>
<p>这里有一个细节不知道你是否发现，就是 这道题目仅仅是让你输出所有组合方式的个数，并没有让你输出所有的组合方式，这是决定是否使用动态规划很重要的一点。</p>
<p>如果没有这个 k，我相信你会很直接地想到使用 01 背包问题 的解法，那我们可以思考一下，基于原来的解法，如果增加了 k 这个限制，我们需要额外做些什么事情呢？</p>
<p>因为 k 会决定问题的状态，因此我们的状态数组中也要考虑 k，在考虑将第 k 个元素放入背包中，我们需要看的是背包中存放 k - 1 个元素的情况，这么看来，其实相比普通的 01 背包问题，这道题目仅仅是增加了一维状态，没有其他的变化。</p>
<p>参考代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int kSum(int[] array, int k, int target) &#123;</span><br><span class="line">    int[][] dp = new int[target + 1][k + 1];</span><br><span class="line"></span><br><span class="line">    dp[0][0] = 1;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">        for (int j = target; j &gt;= array[i]; --j) &#123;</span><br><span class="line">            // 和普通 01背包问题 相比，仅仅是多了一层状态需要考虑</span><br><span class="line">            // 这层状态记录的是背包里面元素的个数</span><br><span class="line">            // 我们放入第 r 个元素的时候，必须确保背包里面已经有 r - 1 个元素</span><br><span class="line">            for (int r = 1; r &lt;= k; ++r) &#123;</span><br><span class="line">                dp[j][r] += dp[j - array[i]][r - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[target][k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="动态规划之背包问题系列"><a href="#动态规划之背包问题系列" class="headerlink" title="动态规划之背包问题系列"></a>动态规划之背包问题系列</h1><p>背包问题是一类经典的动态规划问题，它非常灵活，需要仔细琢磨体会，本文先对背包问题的几种常见类型作一个总结，再给出代码模板，然后再看看LeetCode上几个相关题目。</p>
<p>根据维基百科，背包问题（Knapsack problem）是一种组合优化的NP完全（NP-Complete，NPC）问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。NPC问题是没有多项式时间复杂度的解法的，但是利用动态规划，我们可以以伪多项式时间复杂度求解背包问题。一般来讲，背包问题有以下几种分类：</p>
<ul>
<li>01背包问题</li>
<li>完全背包问题</li>
<li>多重背包问题</li>
</ul>
<p>此外，还存在一些其他考法，例如恰好装满、求方案总数、求所有的方案等。本文接下来就分别讨论一下这些问题。</p>
<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>最基本的背包问题就是01背包问题（01 knapsack problem）：一共有N件物品，第i（i从1开始）件物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果采用暴力穷举的方式，每件物品都存在装入和不装入两种情况，所以总的时间复杂度是O(2^N)，这是不可接受的。而使用动态规划可以将复杂度降至O(NW)。我们的目标是书包内物品的总价值，而变量是物品和书包的限重，所以我们可定义状态dp:</p>
<p><code>dp[i][j]</code>表示将前i件物品装进限重为j的背包可以获得的最大价值, 0&lt;=i&lt;=N, 0&lt;=j&lt;=W<br>那么我们可以将<code>dp[0][0…W]</code>初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。那么当 i &gt; 0 时dp[i][j]有两种情况：</p>
<ul>
<li>不装入第i件物品，即<code>dp[i−1][j]</code>；</li>
<li>装入第i件物品（前提是能装下），即<code>dp[i−1][j−w[i]] + v[i]</code>。</li>
</ul>
<p>即状态转移方程为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i−1][j], dp[i−1][j−w[i]]+v[i]) // j &gt;= w[i]</span><br></pre></td></tr></table></figure></p>
<p>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。</p>
<ul>
<li>首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。</li>
<li>状态转移方程<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code>可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</li>
</ul>
<p><code>dp[0][j]</code>即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。当<code>j &gt;= weight[0]</code>时，<code>dp[0][j]</code>应该是value[0]，因为背包容量放足够放编号0物品。代码初始化如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span> ; j &lt; weight[<span class="number">0</span>]; j++) &#123;  <span class="comment">// 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。</span></span><br><span class="line">    dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正序遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么问题来了，先遍历 物品还是先遍历背包重量呢？其实都可以！！但是先遍历物品更好理解。那么我先给出先遍历物品，然后遍历背包重量的代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）例如这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么也是可以的呢？要理解递归的本质和递推的方向。</p>
<p><code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code>递归公式中可以看出<code>dp[i][j]</code>是靠<code>dp[i-1][j]</code>和<code>dp[i - 1][j - weight[i]]</code>推导出来的。</p>
<p>由上述状态转移方程可知，dp[i][j]的值只与<code>dp[i-1][0,...,j-1]</code>有关，所以我们可以采用动态规划常用的方法（滚动数组）对空间进行优化（即去掉dp的第一维）。需要注意的是，为了防止上一层循环的<code>dp[0,...,j-1]</code>被覆盖，循环的时候 j 只能逆向枚举（空间优化前没有这个限制），伪代码为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 01背包问题伪代码(空间优化版)</span><br><span class="line">dp[0,...,W] = 0</span><br><span class="line">for i = 1,...,N</span><br><span class="line">    for j = W,...,w[i] // 必须逆向枚举!!!</span><br><span class="line">        dp[j] = max(dp[j], dp[j−w[i]]+v[i])</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为O(NW), 空间复杂度为O(W)。由于W的值是W的位数的幂，所以这个时间复杂度是伪多项式时间。</p>
<p>动态规划的核心思想避免重复计算在01背包问题中体现得淋漓尽致。第i件物品装入或者不装入而获得的最大价值完全可以由前面i-1件物品的最大价值决定，暴力枚举忽略了这个事实。</p>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>完全背包（unbounded knapsack problem）与01背包不同就是每种物品可以有无限多个：一共有N种物品，每种物品有无限多个，第i（i从1开始）种物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？</p>
<h3 id="分析一"><a href="#分析一" class="headerlink" title="分析一"></a>分析一</h3><p>我们的目标和变量和01背包没有区别，所以我们可定义与01背包问题几乎完全相同的状态dp:</p>
<p><code>dp[i][j]</code>表示将前i种物品装进限重为j的背包可以获得的最大价值, 0&lt;=i&lt;=N, 0&lt;=j&lt;=W<br>初始状态也是一样的，我们将<code>dp[0][0…W]</code>初始化为0，表示将前0种物品（即没有物品）装入书包的最大价值为0。那么当 i &gt; 0 时dp[i][j]也有两种情况：</p>
<p>不装入第i种物品，即<code>dp[i−1][j]</code>，同01背包；<br>装入第i种物品，此时和01背包不太一样，因为每种物品有无限个（但注意书包限重是有限的），所以此时不应该转移到<code>dp[i−1][j−w[i]]</code>而应该转移到<code>dp[i][j−w[i]]</code>，即装入第i种商品后还可以再继续装入第种商品。<br>所以状态转移方程为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) // j &gt;= w[i]</span><br></pre></td></tr></table></figure></p>
<p>这个状态转移方程与01背包问题唯一不同就是max第二项不是<code>dp[i-1]</code>而是<code>dp[i]</code>。</p>
<p>和01背包问题类似，也可进行空间优化，优化后不同点在于这里的 j 只能正向枚举而01背包只能逆向枚举，因为这里的max第二项是dp[i]而01背包是dp[i-1]，即这里就是需要覆盖而01背包需要避免覆盖。所以伪代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 完全背包问题思路一伪代码(空间优化版)</span><br><span class="line">dp[0,...,W] = 0</span><br><span class="line">for i = 1,...,N</span><br><span class="line">    for j = w[i],...,W // 必须正向枚举!!!</span><br><span class="line">        dp[j] = max(dp[j], dp[j−w[i]]+v[i])</span><br></pre></td></tr></table></figure></p>
<p>由上述伪代码看出，01背包和完全背包问题此解法的空间优化版解法唯一不同就是前者的 j 只能逆向枚举而后者的 j 只能正向枚举，这是由二者的状态转移方程决定的。此解法时间复杂度为O(NW), 空间复杂度为O(W)。</p>
<h3 id="分析二"><a href="#分析二" class="headerlink" title="分析二"></a>分析二</h3><p>除了分析一的思路外，完全背包还有一种常见的思路，但是复杂度高一些。我们从装入第 i 种物品多少件出发，01背包只有两种情况即取0件和取1件，而这里是取0件、1件、2件…直到超过限重（k &gt; j/w[i]），所以状态转移方程为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// k为装入第i种物品的件数, k &lt;= j/w[i]</span><br><span class="line">dp[i][j] = max&#123;(dp[i-1][j − k*w[i]] + k*v[i]) for every k&#125;</span><br></pre></td></tr></table></figure></p>
<p>同理也可以进行空间优化，需要注意的是，这里max里面是dp[i-1]，和01背包一样，所以 j 必须逆向枚举，优化后伪代码为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 完全背包问题思路二伪代码(空间优化版)</span><br><span class="line">dp[0,...,W] = 0</span><br><span class="line">for i = 1,...,N</span><br><span class="line">    for j = W,...,w[i] // 必须逆向枚举!!!</span><br><span class="line">        for k = [0, 1,..., j/w[i]]</span><br><span class="line">            dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i])</span><br></pre></td></tr></table></figure></p>
<p>相比于分析一，此种方法不是在O(1)时间求得dp[i][j]，所以总的时间复杂度就比分析一大些了，为 O(NWWw¯)级别。</p>
<h3 id="分析三、转换成01背包"><a href="#分析三、转换成01背包" class="headerlink" title="分析三、转换成01背包"></a>分析三、转换成01背包</h3><p>01背包问题是最基本的背包问题，我们可以考虑把完全背包问题转化为01背包问题来解：将一种物品转换成若干件只能装入0件或者1件的01背包中的物品。</p>
<p>最简单的想法是，考虑到第 i 种物品最多装入 W/w[i] 件，于是可以把第 i 种物品转化为 W/w[i] 件费用及价值均不变的物品，然后求解这个01背包问题。</p>
<p>更高效的转化方法是采用二进制的思想：把第 i 种物品拆成重量为 wi2k、价值为 vi2k 的若干件物品，其中 k 取遍满足 wi2k≤W 的非负整数。这是因为不管最优策略选几件第 i 种物品，总可以表示成若干个刚才这些物品的和（例：13 = 1 + 4 + 8）。这样就将转换后的物品数目降成了对数级别。具体代码见3.4节模板。</p>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>多重背包（bounded knapsack problem）与前面不同就是每种物品是有限个：一共有N种物品，第i（i从1开始）种物品的数量为n[i]，重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？</p>
<h3 id="分析一-1"><a href="#分析一-1" class="headerlink" title="分析一"></a>分析一</h3><p>此时的分析和完全背包的分析二差不多，也是从装入第 i 种物品多少件出发：装入第i种物品0件、1件、…n[i]件（还要满足不超过限重）。所以状态方程为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// k为装入第i种物品的件数, k &lt;= min(n[i], j/w[i])</span><br><span class="line">dp[i][j] = max&#123;(dp[i-1][j − k*w[i]] + k*v[i]) for every k&#125;</span><br></pre></td></tr></table></figure></p>
<p>同理也可以进行空间优化，而且 j 也必须逆向枚举，优化后伪代码为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 完全背包问题思路二伪代码(空间优化版)</span><br><span class="line">dp[0,...,W] = 0</span><br><span class="line">for i = 1,...,N</span><br><span class="line">    for j = W,...,w[i] // 必须逆向枚举!!!</span><br><span class="line">        for k = [0, 1,..., min(n[i], j/w[i])]</span><br><span class="line">            dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i])</span><br></pre></td></tr></table></figure></p>
<h3 id="分析二、转换成01背包"><a href="#分析二、转换成01背包" class="headerlink" title="分析二、转换成01背包"></a>分析二、转换成01背包</h3><p>采用2.4节类似的思路可以将多重背包转换成01背包问题，采用二进制思路将第 i 种物品分成了 O(logni) 件物品，将原问题转化为了复杂度为 O(W∑ilogni) 的 01 背包问题，相对于分析一是很大的改进，具体代码见3.4节。</p>
<h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><p>此节根据上面的讲解给出这三种背包问题的解题模板，方便解题使用。尤其注意其中二进制优化是如何实现的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//tangshusen.me/2019/11/24/knapsack-problem/</span></span><br><span class="line"><span class="number">01</span>背包, 完全背包, 多重背包模板(二进制优化). </span><br><span class="line"><span class="number">2020.01</span><span class="number">.04</span> by tangshusen.</span><br><span class="line"></span><br><span class="line">用法:</span><br><span class="line">    对每个物品调用对应的函数即可, 例如多重背包:</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) </span><br><span class="line">        <span class="built_in">multiple_pack_step</span>(dp, w[i], v[i], num[i], W);</span><br><span class="line"></span><br><span class="line">参数:</span><br><span class="line">    dp   : 空间优化后的一维dp数组, 即dp[i]表示最大承重为i的书包的结果</span><br><span class="line">    w    : 这个物品的重量</span><br><span class="line">    v    : 这个物品的价值</span><br><span class="line">    n    : 这个物品的个数</span><br><span class="line">    max_w: 书包的最大承重</span><br><span class="line">*/</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">zero_one_pack_step</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;dp, <span class="type">int</span> w, <span class="type">int</span> v, <span class="type">int</span> max_w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = max_w; j &gt;= w; j--) <span class="comment">// 反向枚举!!!</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w] + v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">complete_pack_step</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;dp, <span class="type">int</span> w, <span class="type">int</span> v, <span class="type">int</span> max_w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = w; j &lt;= max_w; j++) <span class="comment">// 正向枚举!!!</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w] + v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 法二: 转换成01背包, 二进制优化</span></span><br><span class="line">    <span class="comment">// int n = max_w / w, k = 1;</span></span><br><span class="line">    <span class="comment">// while(n &gt; 0)&#123;</span></span><br><span class="line">    <span class="comment">//     zero_one_pack_step(dp, w*k, v*k, max_w);</span></span><br><span class="line">    <span class="comment">//     n -= k;</span></span><br><span class="line">    <span class="comment">//     k = k*2 &gt; n ? n : k*2;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">multiple_pack_step</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;dp, <span class="type">int</span> w, <span class="type">int</span> v, <span class="type">int</span> n, <span class="type">int</span> max_w)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n &gt;= max_w / w) <span class="built_in">complete_pack_step</span>(dp, w, v, max_w);</span><br><span class="line">   <span class="keyword">else</span>&#123; <span class="comment">// 转换成01背包, 二进制优化</span></span><br><span class="line">       <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="built_in">zero_one_pack_step</span>(dp, w*k, v*k, max_w);</span><br><span class="line">           n -= k;</span><br><span class="line">           k = k*<span class="number">2</span> &gt; n ? n : k*<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="其他情形"><a href="#其他情形" class="headerlink" title="其他情形"></a>其他情形</h2><h3 id="恰好装满"><a href="#恰好装满" class="headerlink" title="恰好装满"></a>恰好装满</h3><p>背包问题有时候还有一个限制就是必须恰好装满背包，此时基本思路没有区别，只是在初始化的时候有所不同。</p>
<p>如果没有恰好装满背包的限制，我们将dp全部初始化成0就可以了。因为任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。如果有恰好装满的限制，那只应该将dp[0,…,N][0]初始为0，其它dp值均初始化为-inf，因为此时只有容量为0的背包可以在什么也不装情况下被“恰好装满”，其它容量的背包初始均没有合法的解，应该被初始化为-inf。</p>
<h3 id="求方案总数"><a href="#求方案总数" class="headerlink" title="求方案总数"></a>求方案总数</h3><p>除了在给定每个物品的价值后求可得到的最大价值外，还有一类问题是问装满背包或将背包装至某一指定容量的方案总数。对于这类问题，需要将状态转移方程中的 max 改成 sum ，大体思路是不变的。例如若每件物品均是完全背包中的物品，转移方程即为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = sum(dp[i−1][j], dp[i][j−w[i]]) // j &gt;= w[i]</span><br></pre></td></tr></table></figure></p>
<h3 id="二维背包"><a href="#二维背包" class="headerlink" title="二维背包"></a>二维背包</h3><p>前面讨论的背包容量都是一个量：重量。二维背包问题是指每个背包有两个限制条件（比如重量和体积限制），选择物品必须要满足这两个条件。此类问题的解法和一维背包问题不同就是dp数组要多开一维，其他和一维背包完全一样，例如5.4节。</p>
<h3 id="求最优方案"><a href="#求最优方案" class="headerlink" title="求最优方案"></a>求最优方案</h3><p>一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由哪一个策略推出来的，这样便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。</p>
<p>以01背包为例，我们可以再用一个数组G[i][j]来记录方案，设 G[i][j] = 0表示计算 dp[i][j] 的值时是采用了max中的前一项(也即dp[i−1][j])，G[i][j] = 1 表示采用了方程的后一项。即分别表示了两种策略: 未装入第 i 个物品及装了第 i 个物品。其实我们也可以直接从求好的dp[i][j]反推方案：若 dp[i][j] = dp[i−1][j] 说明未选第i个物品，反之说明选了。</p>
<h2 id="LeetCode相关题目"><a href="#LeetCode相关题目" class="headerlink" title="LeetCode相关题目"></a>LeetCode相关题目</h2><p>本节对LeetCode上面的背包问题进行讨论。</p>
<h3 id="Partition-Equal-Subset-Sum（分割等和子集）"><a href="#Partition-Equal-Subset-Sum（分割等和子集）" class="headerlink" title="Partition Equal Subset Sum（分割等和子集）"></a>Partition Equal Subset Sum（分割等和子集）</h3><ol>
<li>Partition Equal Subset Sum（分割等和子集）</li>
</ol>
<p>题目给定一个只包含正整数的非空数组。问是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>由于所有元素的和sum已知，所以两个子集的和都应该是sum/2（所以前提是sum不能是奇数），即题目转换成从这个数组里面选取一些元素使这些元素和为sum/2。如果我们将所有元素的值看做是物品的重量，每件物品价值都为1，所以这就是一个恰好装满的01背包问题。</p>
<p>我们定义空间优化后的状态数组dp，由于是恰好装满，所以应该将dp[0]初始化为0而将其他全部初始化为INT_MIN，然后按照类似1.2节的伪代码更新dp：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> capacity = sum / <span class="number">2</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(capacity + <span class="number">1</span>, INT_MIN);</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = capacity; j &gt;= nums[i<span class="number">-1</span>]; j--)</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], <span class="number">1</span> + dp[j - nums[i<span class="number">-1</span>]]);</span><br></pre></td></tr></table></figure></p>
<p>更新完毕后，如果dp[sum/2]大于0说明满足题意。</p>
<p>由于此题最后求的是能不能进行划分，所以dp的每个元素定义成bool型就可以了，然后将dp[0]初始为true其他初始化为false，而转移方程就应该是用或操作而不是max操作。完整代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;num: nums) sum += num;</span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> capacity = sum / <span class="number">2</span>;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt;<span class="built_in">dp</span>(capacity + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = capacity; j &gt;= nums[i<span class="number">-1</span>]; j--)</span><br><span class="line">            dp[j] = dp[j] || dp[j - nums[i<span class="number">-1</span>]];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> dp[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外此题还有一个更巧妙更快的解法，基本思路是用一个bisets来记录所有可能子集的和，详见我的Github。</p>
<h3 id="Coin-Change（零钱兑换）"><a href="#Coin-Change（零钱兑换）" class="headerlink" title="Coin Change（零钱兑换）"></a>Coin Change（零钱兑换）</h3><ol>
<li>Coin Change</li>
</ol>
<p>题目给定一个价值amount和一些面值，假设每个面值的硬币数都是无限的，问我们最少能用几个硬币组成给定的价值。</p>
<p>如果我们将面值看作是物品，面值金额看成是物品的重量，每件物品的价值均为1，这样此题就是是一个恰好装满的完全背包问题了。不过这里不是求最多装入多少物品而是求最少，我们只需要将2.2节的转态转移方程中的max改成min即可，又由于是恰好装满，所以除了dp[0]，其他都应初始化为INT_MAX。完整代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(amount + <span class="number">1</span>, INT_MAX);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= coins.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = coins[i<span class="number">-1</span>]; j &lt;= amount; j++)&#123;</span><br><span class="line">            <span class="comment">// 下行代码会在 1+INT_MAX 时溢出</span></span><br><span class="line">            <span class="comment">// dp[j] = min(dp[j], 1 + dp[j - coins[i-1]]); </span></span><br><span class="line">            <span class="keyword">if</span>(dp[j] - <span class="number">1</span> &gt; dp[j - coins[i<span class="number">-1</span>]])</span><br><span class="line">                dp[j] = <span class="number">1</span> + dp[j - coins[i<span class="number">-1</span>]];   </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == INT_MAX ? <span class="number">-1</span> : dp[amount];   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意上面<code>1 + dp[j - coins[i-1]]</code>会存在溢出的风险，所以我们换了个写法。</p>
<p>另外此题还可以进行搜索所有可能然后保持一个全局的结果res，但是直接搜索会超时，所以需要进行精心剪枝，剪枝后可击败99%。详见我的Github。</p>
<h3 id="Target-Sum（目标和）"><a href="#Target-Sum（目标和）" class="headerlink" title="Target Sum（目标和）"></a>Target Sum（目标和）</h3><ol>
<li>Target Sum</li>
</ol>
<p>这道题给了我们一个数组（元素非负），和一个目标值，要求给数组中每个数字前添加正号或负号所组成的表达式结果与目标值S相等，求有多少种情况。</p>
<p>假设所有元素和为sum，所有添加正号的元素的和为A，所有添加负号的元素和为B，则有sum = A + B 且 S = A - B，解方程得A = (sum + S)/2。即题目转换成：从数组中选取一些元素使和恰好为(sum + S) / 2。可见这是一个恰好装满的01背包问题，要求所有方案数，将1.2节状态转移方程中的max改成求和即可。需要注意的是，虽然这里是恰好装满，但是dp初始值不应该是inf，因为这里求的不是总价值而是方案数，应该全部初始为0（除了dp[0]初始化为1）。所以代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// for(int &amp;num: nums) sum += num;</span></span><br><span class="line">    sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(S &gt; sum || sum &lt; -S) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 肯定不行</span></span><br><span class="line">    <span class="keyword">if</span>((S + sum) &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 奇数</span></span><br><span class="line">    <span class="type">int</span> target = (S + sum) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(target + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = target; j &gt;= nums[i<span class="number">-1</span>]; j--)</span><br><span class="line">            dp[j] = dp[j] + dp[j - nums[i<span class="number">-1</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Ones-and-Zeros（一和零）"><a href="#Ones-and-Zeros（一和零）" class="headerlink" title="Ones and Zeros（一和零）"></a>Ones and Zeros（一和零）</h3><ol>
<li>Ones and Zeroes</li>
</ol>
<p>题目给定一个仅包含 0 和 1 字符串的数组。任务是从数组中选取尽可能多的字符串，使这些字符串包含的0和1的数目分别不超过m和n。</p>
<p>我们把每个字符串看做是一件物品，把字符串中0的数目和1的数目看做是两种“重量”，所以就变成了一个二维01背包问题，书包的两个限重分别是 m 和 n，要求书包能装下的物品的最大数目（也相当于价值最大，设每个物品价值为1）。</p>
<p>我们可以提前把每个字符串的两个“重量” w0和w1算出来用数组存放，但是注意到只需要用一次这两个值，所以我们只需在用到的时候计算w0和w1就行了，这样就不用额外的数组存放。完整代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = strs.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> w0, w1;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++)&#123;</span><br><span class="line">        w0 = <span class="number">0</span>; w1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算第i-1个字符串的两个重量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> &amp;c: strs[i - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span>) w0 += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> w1 += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 01背包, 逆向迭代更新dp</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= w0; j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = n; k &gt;= w1; k--)</span><br><span class="line">                dp[j][k] = <span class="built_in">max</span>(dp[j][k], <span class="number">1</span>+dp[j-w0][k-w1]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文讨论了几类背包问题及LeetCode相关题目，其中01背包问题和完全背包问题是最常考的，另外还需要注意一些其他变种例如恰好装满、二维背包、求方案总数等等。除了本文讨论的这些背包问题之外，还存在一些其他的变种，但只要深刻领会本文所列的背包问题的思路和状态转移方程，遇到其它的变形问题，应该也不难想出算法。如果想更加详细地理解背包问题，推荐阅读经典的背包问题九讲。</p>
<h1 id="空间优化-滚动数组"><a href="#空间优化-滚动数组" class="headerlink" title="空间优化 - 滚动数组"></a>空间优化 - 滚动数组</h1><p>有一个比较通用的空间优化技巧没有在之前的文章中提到，很多的动态规划题目都可以套用这个技巧，我们就拿之前的 最长公共子序列 这道题目来举例说明，当时我们最终实现的代码是这样的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class="line">    int length1 = text1.length();</span><br><span class="line">    int length2 = text2.length();</span><br><span class="line"></span><br><span class="line">    int[][] dp = new int[length1 + 1][length2 + 1];</span><br><span class="line"></span><br><span class="line">    char[] textArr1 = text1.toCharArray();</span><br><span class="line">    char[] textArr2 = text2.toCharArray();</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= length1; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= length2; ++j) &#123;</span><br><span class="line">            if (textArr1[i - 1] == textArr2[j - 1]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[length1][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>你仔细观察代码，会发现当前考虑的状态 dp[i][j] 仅仅依赖于 dp[i - 1][j] 和 dp[i][j - 1]，如果画出表格，也就是当前行的格子只会和当前行以及前一行的格子有关，因此，保留两行数据就能够满足状态迭代更新的要求，我们可以得到下面的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class="line">    int length1 = text1.length();</span><br><span class="line">    int length2 = text2.length();</span><br><span class="line"></span><br><span class="line">    int[][] dp = new int[2][length2 + 1];</span><br><span class="line"></span><br><span class="line">    char[] textArr1 = text1.toCharArray();</span><br><span class="line">    char[] textArr2 = text2.toCharArray();</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= length1; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= length2; ++j) &#123;</span><br><span class="line">            if (textArr1[i - 1] == textArr2[j - 1]) &#123;</span><br><span class="line">                dp[i%2][j] = dp[(i - 1)%2][j - 1] + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i%2][j] = Math.max(dp[(i - 1)%2][j], dp[i%2][j - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[length1%2][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里我们成功将空间的维度降低了一维，当然如果你觉得取模的操作让代码变得不整洁，你也可以参考下面的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class="line">    int length1 = text1.length();</span><br><span class="line">    int length2 = text2.length();</span><br><span class="line"></span><br><span class="line">    int[][] dp = new int[2][length2 + 1];</span><br><span class="line"></span><br><span class="line">    char[] textArr1 = text1.toCharArray();</span><br><span class="line">    char[] textArr2 = text2.toCharArray();</span><br><span class="line"></span><br><span class="line">    int cur = 0, prev = 1;</span><br><span class="line">    for (int i = 1; i &lt;= length1; ++i) &#123;</span><br><span class="line">        prev = cur; cur = 1 - cur;</span><br><span class="line">        for (int j = 1; j &lt;= length2; ++j) &#123;</span><br><span class="line">            if (textArr1[i - 1] == textArr2[j - 1]) &#123;</span><br><span class="line">                dp[cur][j] = dp[prev][j - 1] + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[cur][j] = Math.max(dp[prev][j], dp[cur][j - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[cur][length2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其实滚动数组的思想不难理解，就是只保存需要用到的子问题的答案（状态），覆盖那些不需要用到的子问题的答案，状态在同一块空间中不断翻滚迭代向前。</p>
<p>当然，有些动态规划的实现方式就不太容易使用这类优化，比如 记忆化搜索，还有些动态规划题型，比如 区间类动态规划，状态的更新不是逐行逐列的，使用滚动数组来优化也不是特别容易，因此使用滚动数组优化的时候还是需要结合实际情况考虑。</p>
<p>滚动数组一般来说都可以将状态数组的空间降低一维，比如三维变二维、二维变一维、一维变常数，当然有些具体题型的空间优化也可以做到这个，比如背包类型的动态规划问题中，我们通过改变遍历的顺序，直接就可以做到空间降维，但其实这是这类动态规划问题特有的优化，不属于滚动数组的范畴。</p>
<h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>动态规划系列内容算是结束了，虽然有关动态规划的知识点还有很多，但是我相信如果深刻掌握并理解了之前我们讲的内容，基本上 leetcode 上面 90% 以上的动态规划相关问题都可以很好解决。</p>
<p>当然了，要想达到熟能生巧的程度，还是需要多加练习，多思考，多对比，多总结，不然的话，学到的东西很快就会忘记。</p>
<p>最后的最后，希望动态规划不再是你面试中的拦路虎，看到它，也希望你能多一份亲切和自信。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/%E5%81%9A%E5%BC%95%E6%93%8E%E5%BC%80%E5%8F%91%EF%BC%8C%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B7%B1%E5%85%A5%20C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/04/%E5%81%9A%E5%BC%95%E6%93%8E%E5%BC%80%E5%8F%91%EF%BC%8C%E6%9B%B4%E9%9C%80%E8%A6%81%E6%B7%B1%E5%85%A5%20C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="url">做引擎开发，更需要深入 C++ 内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-04T16:08:00+08:00">
                2020-01-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>说到 C++ 的内存管理，我们可能会想到栈空间的本地变量、堆上通过 new 动态分配的变量以及全局命名空间的变量等，这些变量的分配位置都是由系统来控制管理的，而调用者只需要考虑变量的生命周期相关内容即可，而无需关心变量的具体布局。这对于普通软件的开发已经足够，但对于引擎开发而言，我们必须对内存有着更为精细的管理。</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>在文章的开篇，先对一些基础概念进行简单的介绍，以便能够更好地理解后续的内容。</p>
<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p><img src="/img/20210104160900.png" alt=""></p>
<p>内存分布（可执行映像）</p>
<p>如图，描述了C++程序的内存分布。</p>
<ul>
<li>Code Segment（代码区）也称Text Segment，存放可执行程序的机器码。</li>
<li>Data Segment (数据区）存放已初始化的全局和静态变量， 常量数据（如字符串常量）。</li>
<li>BSS（Block started by symbol）存放未初始化的全局和静态变量。（默认设为0）</li>
<li>Heap（堆）从低地址向高地址增长。容量大于栈，程序中动态分配的内存在此区域。</li>
<li>Stack（栈）从高地址向低地址增长。由编译器自动管理分配。程序中的局部变量、函数参数值、返回变量等存在此区域。</li>
</ul>
<h2 id="函数栈"><a href="#函数栈" class="headerlink" title="函数栈"></a>函数栈</h2><p>如上图所示，可执行程序的文件包含BSS，Data Segment和Code Segment，当可执行程序载入内存后，系统会保留一些空间，即堆区和栈区。堆区主要是动态分配的内存（默认情况下），而栈区主要是函数以及局部变量等（包括main函数）。一般而言，栈的空间小于堆的空间。</p>
<p>当调用函数时，一块连续内存(堆栈帧）压入栈；函数返回时，堆栈帧弹出。</p>
<p>堆栈帧包含如下数据:</p>
<ul>
<li>函数返回地址</li>
<li>局部变量/CPU寄存器数据备份</li>
</ul>
<p><img src="/img/20210104160901.png" alt=""></p>
<p>函数压栈</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>当全局/静态变量（如下代码中的x和y变量）未初始化的时候，它们记录在BSS段。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> z = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="type">static</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>处于BSS段的变量的值默认为0，考虑到这一点，BSS段内部无需存储大量的零值，而只需记录字节个数即可。</p>
<p>系统载入可执行程序后，将BSS段的数据载入数据段(Data Segment） ，并将内存初始化为0，再调用程序入口（main函数）。</p>
<p>而对于已经初始化了的全局/静态变量而言，如以上代码中的z变量，则一直存储于数据段(Data Segment)。</p>
<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>对于基础类型，如float, double, int, char等，它们的大小和内存占用是一致的。而对于结构体而言，如果我们取得其sizeof的结果，会发现这个值有可能会大于结构体内所有成员大小的总和，这是由于结构体内部成员进行了内存对齐。</p>
<h3 id="为什么要进行内存对齐"><a href="#为什么要进行内存对齐" class="headerlink" title="为什么要进行内存对齐"></a>为什么要进行内存对齐</h3><p>① 内存对齐使数据读取更高效</p>
<p>在硬件设计上，数据读取的处理器只能从地址为k的倍数的内存处开始读取数据。这种读取方式相当于将内存分为了多个”块“，假设内存可以从任意位置开始存放的话，数据很可能会被分散到多个“块”中，处理分散在多个块中的数据需要移除首尾不需要的字节，再进行合并，非常耗时。</p>
<p>为了提高数据读取的效率，程序分配的内存并不是连续存储的，而是按首地址为k的倍数的方式存储；这样就可以一次性读取数据，而不需要额外的操作。<br><img src="/img/20210104160902.png" alt=""></p>
<p>读取非对齐内存的过程示例</p>
<p>② 在某些平台下，不进行内存对齐会崩溃</p>
<h3 id="内存对齐的规则"><a href="#内存对齐的规则" class="headerlink" title="内存对齐的规则"></a>内存对齐的规则</h3><p>定义有效对齐值（alignment）为结构体中 最宽成员 和 编译器/用户指定对齐值 中较小的那个。</p>
<ol>
<li>结构体起始地址为有效对齐值的整数倍</li>
<li>结构体总大小为有效对齐值的整数倍</li>
<li>结构体第一个成员偏移值为0，之后成员的偏移值为 min(有效对齐值, 自身大小) 的整数倍</li>
</ol>
<p>相当于每个成员要进行对齐，并且整个结构体也需要进行对齐。</p>
<p>示例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c1;</span><br><span class="line">    <span class="type">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl; <span class="comment">// 有效对齐值为4, output : 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20210104160903.png" alt=""><br>内存排布示例</p>
<h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><p>程序的内存往往不是紧凑连续排布的，而是存在着许多碎片。我们根据碎片产生的原因把碎片分为内部碎片和外部碎片两种类型：</p>
<ol>
<li>内部碎片：系统分配的内存大于实际所需的内存（由于对齐机制）；</li>
<li>外部碎片：不断分配回收不同大小的内存，由于内存分布散乱，较大内存无法分配；</li>
</ol>
<p><img src="/img/20210104160904.png" alt=""><br>内部碎片和外部碎片</p>
<p>为了提高内存的利用率，我们有必要减少内存碎片，具体的方案将在后文重点介绍。</p>
<h2 id="继承类布局"><a href="#继承类布局" class="headerlink" title="继承类布局"></a>继承类布局</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>如果一个类继承自另一个类，那么它自身的数据位于父类之后。</p>
<h3 id="含虚函数的类"><a href="#含虚函数的类" class="headerlink" title="含虚函数的类"></a>含虚函数的类</h3><p>如果当前类包含虚函数，则会在类的最前端占用4个字节，用于存储虚表指针（vpointer)，它指向一个虚函数表（vtable)。</p>
<p>vtable中包含当前类的所有虚函数指针。</p>
<h2 id="字节序（endianness"><a href="#字节序（endianness" class="headerlink" title="字节序（endianness)"></a>字节序（endianness)</h2><p>大于一个字节的值被称为多字节量，多字节量存在高位有效字节和低位有效字节 (关于高位和低位，我们以十进制的数字来举例，对于数字482来说，4是高位，2是低位），微处理器有两种不同的顺序处理高位和低位字节的顺序：</p>
<ul>
<li>小端（little_endian)：低位有效字节存储于较低的内存位置</li>
<li>大端（big_endian)：高位有效字节存储于较低的内存位置</li>
</ul>
<p>我们使用的PC开发机默认是小端存储。</p>
<p>一般情况下，多字节量的排列顺序对编码没有影响。但如果要考虑跨平台的一些操作，就有必要考虑到大小端的问题。如下图，ue4引擎使用了PLATFORM_LITTLE_ENDIAN这一宏，在不同平台下对数据做特殊处理（内存排布交换，确保存储时的结果一致）。ue4针对大小端对数据做特殊处理（ByteSwap.h)<br><img src="/img/20210104160905.png" alt=""></p>
<h2 id="用union判断大小端"><a href="#用union判断大小端" class="headerlink" title="用union判断大小端"></a>用union判断大小端</h2><ul>
<li>大端存储：字数据的高字节存储在低地址中</li>
<li>小端存储：字数据的低字节存储在低地址中</li>
</ul>
<p>了解了大小端存储的方式，如何在代码中进行判断呢？下面介绍两种判断方式：</p>
<p>方式一：使用强制类型转换<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="comment">//由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分</span></span><br><span class="line">    <span class="type">char</span> c = (<span class="type">char</span>)(a);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0x12</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;big endian&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="number">0x34</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;little endian&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">方式二：巧用<span class="keyword">union</span>联合体</span><br><span class="line">```C++</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//union联合体的重叠式存储，endian联合体占用内存的空间为每个成员字节长度的最大值</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">endian</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    endian value;</span><br><span class="line">    value.a = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="comment">//a和ch共用4字节的内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (value.ch == <span class="number">0x12</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;big endian&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value.ch == <span class="number">0x34</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;little endian&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>对一些基础概念有所了解后，我们可以来关注操作系统底层的一些设计。在掌握了这些特性后，我们才能更好地针对性地编写高性能代码。</p>
<h2 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h2><p>SIMD，即Single Instruction Multiple Data，用一个指令并行地对多个数据进行运算，是CPU基本指令集的扩展。</p>
<p>例一：处理器的寄存器通常是32位或者64位的，而图像的一个像素点可能只有8bit，如果一次只能处理一个数据比较浪费空间；此时可以将64位寄存器拆成8个8位寄存器，就可以并行完成8个操作，提升效率。</p>
<p>例二：SSE指令采用128位寄存器，我们通常将4个32位浮点值打包到128位寄存器中，单个指令可完成4对浮点数的计算，这对于矩阵/向量操作非常友好（除此之外，还有Neon/FPU等寄存器）</p>
<p><img src="/img/20210104160906.png" alt=""></p>
<h2 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h2><p>一般来说CPU以超高速运行，而内存速度慢于CPU，硬盘速度慢于内存。</p>
<p>当我们把数据加载内存后，要对数据进行一定操作时，会将数据从内存载入CPU寄存器。考虑到CPU读/写主内存速度较慢，处理器使用了高速的缓存（Cache)，作为内存到CPU中间的媒介。</p>
<p>引入L1和L2缓存后，CPU和内存之间的将无法进行直接的数据交互，而是需要经过两级缓存（目前也已出现L3缓存）。</p>
<p>① CPU请求数据：如果数据已经在缓存中，则直接从缓存载入寄存器；如果数据不在缓存中（缓存命中失败），则需要从内存读取，并将内存载入缓存中。</p>
<p>② CPU写入数据：有两种方案，(1) 写入到缓存时同步写入内存（write through cache) (2) 仅写入到缓存中，有必要时再写入内存(write-back)</p>
<p>为了提高程序性能，则需要尽可能避免缓存命中失败。一般而言，遵循尽可能地集中连续访问内存，减少”跳变“访问的原则（locality of reference)。这里其实隐含了两个意思，一个是内存空间上要尽可能连续，另外一个是访问时序上要尽可能连续。像节点式的数据结构的遍历就会差于内存连续性的容器。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存，也就是把不连续的物理内存块映射到虚拟地址空间（virtual address space)。使内存页对于应用程序来说看起来是连续的。一般而言，出于程序安全性和物理内存可能不足的考虑，我们的程序都会运行在虚拟内存上。</p>
<p>这意味着，每个程序都有自己的地址空间，我们使用的内存存在一个虚拟地址和一个物理地址，两者之间需要进行地址翻译。</p>
<h3 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h3><p>在虚拟内存中，每个程序的地址空间被划分为多个块，每个内存块被称作页，每个页的包含了连续的地址，并且被映射到物理内存。并非所有页都在物理内存中，当我们访问了不在物理内存中的页时，这一现象称为缺页，操作系统会从磁盘将对应内容装载到物理内存；当内存不足，部分页也会写回磁盘。</p>
<p>在这里，我们将CPU，高速缓存和主存视为一个整体，统称为DRAM。由于DRAM与磁盘之间的读写也比较耗时，为了提高程序性能，我们依然需要确保自己的程序具有良好的“局部性”——在任意时刻都在一个较小的活动页面上工作。</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>当使用虚拟内存时，会通过MMU将虚拟地址映射到物理内存，虚拟内存的内存块称为页，而物理内存中的内存块称为页框，两者大小一致，DRAM和磁盘之间以页为单位进行交换。</p>
<p>简单来说，如果想要从虚拟内存翻译到物理地址，首先会从一个TLB（Translation Lookaside Buffer)的设备中查找，如果找不到，在虚拟地址中也记录了虚拟页号和偏移量，可以先通过虚拟页号找到页框号，再通过偏移量在对应页框进行偏移，得到物理地址。为了加速这个翻译过程，有时候还会使用多级页表，倒排页表等结构。</p>
<h2 id="置换算法"><a href="#置换算法" class="headerlink" title="置换算法"></a>置换算法</h2><p>到目前为止，我们已经接触了不少和“置换”有关的内容：例如寄存器和高速缓存之间，DRAM和磁盘之间，以及TLB的缓存等。这个问题的本质是，我们在有限的空间内存储了一些快速查询的结构，但是我们无法存储所有的数据，所以当查询未命中时，就需要花更大的代价，而所谓置换，也就是我们的快速查询结构是在不断更新的，会随着我们的操作，使得一部分数据被装在到快速查询结构中，又有另一部分数据被卸载，相当于完成了数据的置换。</p>
<p>常见的置换有如下几种：</p>
<ul>
<li>最近未使用置换（NRU）：出现未命中现象时，置换最近一个周期未使用的数据。</li>
<li>先入先出置换（FIFO)：出现未命中现象时，置换最早进入的数据。</li>
<li>最近最少使用置换（LRU)：出现未命中现象时，置换未使用时间最长的数据。</li>
</ul>
<h1 id="C-语法"><a href="#C-语法" class="headerlink" title="C++语法"></a>C++语法</h1><h2 id="位域（Bit-Fields）"><a href="#位域（Bit-Fields）" class="headerlink" title="位域（Bit Fields）"></a>位域（Bit Fields）</h2><p>表示结构体位域的定义，指定变量所占位数。它通常位于成员变量后，用 声明符：常量表达式 表示。（参考资料）</p>
<p>声明符是可选的，匿名字段可用于填充。</p>
<p>以下是ue4中Float16的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PLATFORM_LITTLE_ENDIAN</span></span><br><span class="line">    uint16 Mantissa : <span class="number">10</span>;</span><br><span class="line">    uint16 Exponent : <span class="number">5</span>;</span><br><span class="line">    uint16 Sign : <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    uint16 Sign : <span class="number">1</span>;</span><br><span class="line">    uint16 Exponent : <span class="number">5</span>;</span><br><span class="line">    uint16 Mantissa : <span class="number">10</span>;   </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; Components;</span><br></pre></td></tr></table></figure></p>
<h2 id="new和placement-new"><a href="#new和placement-new" class="headerlink" title="new和placement new"></a>new和placement new</h2><p>new是C++中用于动态内存分配的运算符，它主要完成了以下两个操作：</p>
<ol>
<li>调用operator new()函数，动态分配内存。</li>
<li>在分配的动态内存块上调用构造函数，以初始化相应类型的对象，并返回首地址。</li>
</ol>
<p>当我们调用new时，会在堆中查找一个足够大的剩余空间，分配并返回；当我们调用delete时，则会将该内存标记为不再使用，而指针仍然执行原来的内存。</p>
<h3 id="new的语法"><a href="#new的语法" class="headerlink" title="new的语法"></a>new的语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::(optional) <span class="keyword">new</span> (placement_params)(optional) ( type ) <span class="built_in">initializer</span>(optional) </span><br></pre></td></tr></table></figure>
<p>● 一般表达式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p_var = <span class="keyword">new</span> <span class="built_in">type</span>(initializer); <span class="comment">// p_var = new type&#123;initializer&#125;;</span></span><br></pre></td></tr></table></figure></p>
<p>● 对象数组表达式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p_var = <span class="keyword">new</span> type[size]; <span class="comment">// 分配</span></span><br><span class="line"><span class="keyword">delete</span>[] p_var; <span class="comment">// 释放</span></span><br></pre></td></tr></table></figure></p>
<p>● 二维数组表达式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="type">double</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="type">double</span>[<span class="number">2</span>][<span class="number">2</span>]&#123; &#123;<span class="number">1.0</span>,<span class="number">2.0</span>&#125;,&#123;<span class="number">3.0</span>,<span class="number">4.0</span>&#125; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>● 不抛出异常的表达式<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (nothrow) <span class="built_in">Type</span> (optional-initializer-expression-list)</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，如果内存分配失败，new运算符会选择抛出<code>std::bad_alloc</code>异常，如果加入nothrow，则不抛出异常，而是返回nullptr。</p>
<p>● 占位符类型：我们可以使用placeholder type（如auto/decltype）指定类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">auto</span>(<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<p>● 带位置的表达式（placement new）：可以指定在哪块内存上构造类型。</p>
<p>它的意义在于我们可以利用placement new将内存分配和构造这两个模块分离（后续的allocator更好地践行了这一概念），这对于编写内存管理的代码非常重要，比如当我们想要编写内存池的代码时，可以预申请一块内存，然后通过placement new申请对象，一方面可以避免频繁调用系统new/delete带来的开销，另一方面可以自己控制内存的分配和释放。</p>
<p>预先分配的缓冲区可以是堆或者栈上的，一般按字节(char)类型来分配，这主要考虑了以下两个原因：</p>
<ul>
<li>方便控制分配的内存大小（通过sizeof计算即可）</li>
<li>如果使用自定义类型，则会调用对应的构造函数。但是既然要做分配和构造的分离，我们实际上是不期望它做任何构造操作的，而且对于没有默认构造函数的自定义类型，我们是无法预分配缓冲区的。</li>
</ul>
<p>以下是一个使用的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">A</span>(<span class="type">int</span> indata) </span><br><span class="line">  : <span class="built_in">data</span>(indata) &#123; &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line"> <span class="type">char</span> buf[<span class="function">size * <span class="title">sizeof</span><span class="params">(A)</span>]</span>; <span class="comment">// 内存分配</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="keyword">new</span> (buf + i * <span class="built_in">sizeof</span>(A)) <span class="built_in">A</span>(i); <span class="comment">// 对象构造</span></span><br><span class="line"> &#125;</span><br><span class="line"> A* arr = (A*)buf;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  arr[i].<span class="built_in">print</span>();</span><br><span class="line">  arr[i].~<span class="built_in">A</span>(); <span class="comment">// 对象析构</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 栈上预分配的内存自动释放</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>和数组越界访问不一定崩溃类似，这里如果在未分配的内存上执行placement new，可能也不会崩溃。</p>
<p>● 自定义参数的表达式</p>
<p>当我们调用new时，实际上执行了operator new运算符表达式，和其它函数一样，operator new有多种重载，如上文中的placement new，就是operator new以下形式的一个重载：<br><img src="/img/20210104160907.png" alt=""></p>
<p>● placement new的定义：新语法（C++17）还支持带对齐的operator new：<br><img src="/img/20210104160908.png" alt=""></p>
<p>● aligned new的声明：调用示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">new</span>(std::<span class="type">align_val_t</span>&#123; <span class="number">32</span> &#125;) A;</span><br></pre></td></tr></table></figure></p>
<h3 id="new的重载"><a href="#new的重载" class="headerlink" title="new的重载"></a>new的重载</h3><p>在C++中，我们一般说new和delete动态分配和释放的对象位于自由存储区(free store)，这是一个抽象概念。默认情况下，C++编译器会使用堆实现自由存储。</p>
<p>前文已经提及了new的几种重载，包括数组，placement，align等。</p>
<p>如果我们想要实现自己的内存分配自定义操作，我们可以有如下两个方式：</p>
<ul>
<li>编写重载的operator new，这意味着我们的参数需要和全局operator new有差异。</li>
<li>重定义operator new，根据名字查找规则，会优先在申请内存的数据内部/数据定义处查找new运算符，未找到才会调用全局::operator new()。</li>
</ul>
<p>需要注意的是，如果该全局operator new已经实现为inline函数，则我们不能重定义相关函数，否则无法通过编译，如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default placement versions of operator new.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span>* __p)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> __p; &#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span>, <span class="type">void</span>* __p) <span class="built_in">throw</span>() &#123; <span class="keyword">return</span> __p; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default placement versions of operator delete.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>  <span class="keyword">operator</span> <span class="title">delete</span>  <span class="params">(<span class="type">void</span>*, <span class="type">void</span>*)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span>  <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>*, <span class="type">void</span>*) <span class="keyword">throw</span>() &#123; &#125;</span><br></pre></td></tr></table></figure><br>但是，我们可以重写如下nothrow的operator new：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span>, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;) <span class="built_in">throw</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>*, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;) <span class="keyword">throw</span>();</span><br></pre></td></tr></table></figure></p>
<h3 id="为什么说new是低效的"><a href="#为什么说new是低效的" class="headerlink" title="为什么说new是低效的"></a>为什么说new是低效的</h3><p>① 一般来说，操作越简单，意味着封装了更多的实现细节。new作为一个通用接口，需要处理任意时间、任意位置申请任意大小内存的请求，它在设计上就无法兼顾一些特殊场景的优化，在管理上也会带来一定开销。</p>
<p>② 系统调用带来的开销。多数操作系统上，申请内存会从用户模式切换到内核模式，当前线程会block住，上下文切换将会消耗一定时间。</p>
<p>③ 分配可能是带锁的。这意味着分配难以并行化。</p>
<h2 id="alignas和alignof"><a href="#alignas和alignof" class="headerlink" title="alignas和alignof"></a>alignas和alignof</h2><p>不同的编译器一般都会有默认的对齐量，一般都为2的幂次。</p>
<p>在C中，我们可以通过预编译命令修改对齐量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(n)</span></span><br></pre></td></tr></table></figure></p>
<p>在内存对齐篇已经提及，我们最终的有效对齐量会取结构体最宽成员 和 编译器默认对齐量（或我们自己定义的对齐量）中较小的那个。</p>
<p>C++中也提供了类似的操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alignas</span></span><br></pre></td></tr></table></figure><br>用于指定对齐量。</p>
<p>可以应用于类/结构体/union/枚举的声明/定义；非位域的成员变量的定义；变量的定义（除了函数参数或异常捕获的参数）；</p>
<p>alignas会对对齐量做检查，对齐量不能小于默认对齐，如下面的代码，struct U的对齐设置是错误的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">8</span>) S </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">1</span>) U </span><br><span class="line">&#123;</span><br><span class="line">    S s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以下对齐设置也是错误的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">2</span>) S &#123;</span><br><span class="line"> <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>此外，一些错误的格式也无法通过编译，如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">3</span>) S &#123; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// every object of type sse_t will be aligned to 16-byte boundary</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">16</span>) <span class="type">sse_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> sse_data[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the array &quot;cacheline&quot; will be aligned to 128-byte boundary</span></span><br><span class="line"><span class="built_in">alignas</span>(<span class="number">128</span>)</span><br><span class="line"><span class="type">char</span> cacheline[<span class="number">128</span>];</span><br></pre></td></tr></table></figure></p>
<h3 id="alignof-operator"><a href="#alignof-operator" class="headerlink" title="alignof operator"></a>alignof operator</h3><p>返回类型的<code>std::size_t</code>。如果是引用，则返回引用类型的对齐方式，如果是数组，则返回元素类型的对齐方式。</p>
<p>例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Empty</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">64</span>) Empty64 &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Alignment of&quot;</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;- char          :&quot;</span>    &lt;&lt; <span class="built_in">alignof</span>(<span class="type">char</span>)    &lt;&lt; <span class="string">&quot;\n&quot;</span>   <span class="comment">// 1</span></span><br><span class="line">                 <span class="string">&quot;- pointer       :&quot;</span>    &lt;&lt; <span class="built_in">alignof</span>(<span class="type">int</span>*)    &lt;&lt; <span class="string">&quot;\n&quot;</span>   <span class="comment">// 8</span></span><br><span class="line">                 <span class="string">&quot;- class Foo     :&quot;</span>    &lt;&lt; <span class="built_in">alignof</span>(Foo)     &lt;&lt; <span class="string">&quot;\n&quot;</span>   <span class="comment">// 4</span></span><br><span class="line">                 <span class="string">&quot;- empty class   :&quot;</span>    &lt;&lt; <span class="built_in">alignof</span>(Empty)   &lt;&lt; <span class="string">&quot;\n&quot;</span>   <span class="comment">// 1</span></span><br><span class="line">                 <span class="string">&quot;- alignas(64) Empty:&quot;</span> &lt;&lt; <span class="built_in">alignof</span>(Empty64) &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// 64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="std-max-align-t"><a href="#std-max-align-t" class="headerlink" title="std::max_align_t"></a>std::max_align_t</h3><p>一般为16bytes，malloc返回的内存地址，对齐大小不能小于max_align_t。</p>
<h2 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h2><p>当我们使用C++的容器时，我们往往需要提供两个参数，一个是容器的类型，另一个是容器的分配器。其中第二个参数有默认参数，即C++自带的分配器（allocator)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = allocator&lt;T&gt; &gt; <span class="keyword">class</span> vector; <span class="comment">// generic template</span></span><br></pre></td></tr></table></figure><br>我们可以实现自己的allocator，只需实现分配、构造等相关的操作。在此之前，我们需要先对allocator的使用做一定的了解。</p>
<p>new操作将内存分配和对象构造组合在一起，而allocator的意义在于将内存分配和构造分离。这样就可以分配大块内存，而只在真正需要时才执行对象创建操作。</p>
<p>假设我们先申请n个对象，再根据情况逐一给对象赋值，如果内存分配和对象构造不分离可能带来的弊端如下：</p>
<ul>
<li>我们可能会创建一些用不到的对象；</li>
<li>对象被赋值两次，一次是默认初始化时，一次是赋值时；</li>
<li>没有默认构造函数的类甚至不能动态分配数组；</li>
</ul>
<p>使用allocator之后，我们便可以解决上述问题。</p>
<h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>为n个string分配内存：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;string&gt; alloc; <span class="comment">// 构造allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> p = alloc.<span class="built_in">allocate</span>(n); <span class="comment">// 分配n个未初始化的string</span></span><br></pre></td></tr></table></figure></p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>在刚才分配的内存上构造两个string:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> q = p;</span><br><span class="line">alloc.<span class="built_in">construct</span>(q++, <span class="string">&quot;hello&quot;</span>); <span class="comment">// 在分配的内存处创建对象</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++, <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>将已构造的string销毁：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(q != p)</span><br><span class="line">    alloc.<span class="built_in">destroy</span>(--q);</span><br></pre></td></tr></table></figure></p>
<h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>将分配的n个string内存空间释放：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc.<span class="built_in">deallocate</span>(p, n);</span><br></pre></td></tr></table></figure></p>
<p>注意：传递给deallocate的指针不能为空，且必须指向由allocate分配的内存，并保证大小参数一致。</p>
<h3 id="拷贝和填充"><a href="#拷贝和填充" class="headerlink" title="拷贝和填充"></a>拷贝和填充</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uninitialized_copy</span>(b, e, b2)</span><br><span class="line"><span class="comment">// 从迭代器b, e 中的元素拷贝到b2指定的未构造的原始内存中；</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">uninitialized_copy</span>(b, n, b2)</span><br><span class="line"><span class="comment">// 从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中；</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">uninitialized_fill</span>(b, e, t)</span><br><span class="line"><span class="comment">// 从迭代器b和e指定的原始内存范围中创建对象，对象的值均为t的拷贝；</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">uninitialized_fill_n</span>(b, n, t)</span><br><span class="line"><span class="comment">// 从迭代器b指向的内存地址开始创建n个对象；</span></span><br></pre></td></tr></table></figure>
<h3 id="为什么stl的allocator并不好用"><a href="#为什么stl的allocator并不好用" class="headerlink" title="为什么stl的allocator并不好用"></a>为什么stl的allocator并不好用</h3><p>如果仔细观察，我们会发现很多商业引擎都没有使用stl中的容器和分配器，而是自己实现了相应的功能。这意味着allocator无法满足某些引擎开发一些定制化的需求：</p>
<ul>
<li>allocator内存对齐无法控制</li>
<li>allocator难以应用内存池之类的优化机制</li>
<li>绑定模板签名</li>
</ul>
<h2 id="shared-ptr-unique-ptr和weak-ptr"><a href="#shared-ptr-unique-ptr和weak-ptr" class="headerlink" title="shared_ptr, unique_ptr和weak_ptr"></a>shared_ptr, unique_ptr和weak_ptr</h2><p>智能指针是针对裸指针可能出现的问题封装的指针类，它能够更安全、更方便地使用动态内存。</p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>shared_ptr的主要应用场景是当我们需要在多个类中共享指针时。</p>
<p>多个类共享指针存在这么一个问题：每个类都存储了指针地址的一个拷贝，如果其中一个类删除了这个指针，其它类并不知道这个指针已经失效，此时就会出现野指针的现象。为了解决这一问题，我们可以使用引用指针来计数，仅当检测到引用计数为0时，才主动删除这个数据，以上就是shared_ptr的工作原理。</p>
<p>shared_ptr的基本语法如下：</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<h3 id="拷贝和赋值"><a href="#拷贝和赋值" class="headerlink" title="拷贝和赋值"></a>拷贝和赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">auto</span> r = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">r = q; <span class="comment">// 递增q指向的对象，递减r指向的对象</span></span><br></pre></td></tr></table></figure>
<h3 id="只支持直接初始化"><a href="#只支持直接初始化" class="headerlink" title="只支持直接初始化"></a>只支持直接初始化</h3><p>由于接受指针参数的构造函数是explicit的，因此不能将指针隐式转换为shared_ptr:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>); <span class="comment">// err</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></p>
<h3 id="不与普通指针混用"><a href="#不与普通指针混用" class="headerlink" title="不与普通指针混用"></a>不与普通指针混用</h3><ol>
<li>通过get()函数，我们可以获取原始指针，但我们不应该delete这一指针，也不应该用它赋值/初始化另一个智能指针；</li>
<li>当我们将原生指针传给shared_ptr后，就应该让shared_ptr接管这一指针，而不再直接操作原生指针。</li>
</ol>
<h3 id="重新赋值"><a href="#重新赋值" class="headerlink" title="重新赋值"></a>重新赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>));</span><br></pre></td></tr></table></figure>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>有时候我们会在函数域内临时申请指针，或者在类中声明非共享的指针，但我们很有可能忘记删除这个指针，造成内存泄漏。此时我们可以考虑使用unique_ptr，由名字可见，某一时刻只有一个unique_ptr指向给定的对象，且它会在析构的时候自动释放对应指针的内存。</p>
<p><code>unique_ptr</code>的基本语法如下：</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; p = <span class="built_in">make_unique</span>&lt;string&gt;(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="不支持直接拷贝-赋值"><a href="#不支持直接拷贝-赋值" class="headerlink" title="不支持直接拷贝/赋值"></a>不支持直接拷贝/赋值</h3><p>为了确保某一时刻只有一个unique_ptr指向给定对象，unique_ptr不支持普通的拷贝或赋值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;test&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// err</span></span><br><span class="line">unique_ptr&lt;string&gt; p3;</span><br><span class="line">p3 = p2; <span class="comment">// err</span></span><br></pre></td></tr></table></figure></p>
<h3 id="所有权转移"><a href="#所有权转移" class="headerlink" title="所有权转移"></a>所有权转移</h3><p>可以通过调用release或reset将指针的所有权在unique_ptr之间转移：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;test&quot;</span>))</span></span>;</span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>());</span><br></pre></td></tr></table></figure></p>
<h3 id="不能忽视release返回的结果"><a href="#不能忽视release返回的结果" class="headerlink" title="不能忽视release返回的结果"></a>不能忽视release返回的结果</h3><p>release返回的指针通常用来初始化/赋值另一个智能指针，如果我们只调用release，而没有删除其返回值，会造成内存泄漏：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p2.<span class="built_in">release</span>(); <span class="comment">// err</span></span><br><span class="line"><span class="keyword">auto</span> p = p2.<span class="built_in">release</span>(); <span class="comment">// ok, but remember to delete(p)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="支持移动"><a href="#支持移动" class="headerlink" title="支持移动"></a>支持移动</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr不控制所指向对象的生存期，即不会影响引用计数。它指向一个shared_ptr管理的对象。通常而言，它的存在有如下两个作用：</p>
<ol>
<li>解决循环引用的问题</li>
<li>作为一个“观察者”：</li>
</ol>
<p>详细来说，和之前提到的多个类共享内存的例子一样，使用普通指针可能会导致一个类删除了数据后其它类无法同步这一信息，导致野指针；之前我们提出了shared_ptr，也就是每个类记录一个引用，释放时引用数减一，直到减为0才释放。</p>
<p>但在有些情况下，我们并不希望当前类影响到引用计数，而是希望实现这样的逻辑：假设有两个类引用一个数据，其中有一个类将主动控制类的释放，而无需等待另外一个类也释放才真正销毁指针所指对象。对于另一个类而言，它只需要知道这个指针已经失效即可，此时我们就可以使用weak_ptr。</p>
<p>我们可以像如下这样检测weak_ptr所有对象是否有效，并在有效的情况下做相关操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(shared_ptr&lt;<span class="type">int</span>&gt; np = wp.<span class="built_in">lock</span>())</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="分配与管理机制"><a href="#分配与管理机制" class="headerlink" title="分配与管理机制"></a>分配与管理机制</h1><p>到目前为止，我们对内存的概念有了初步的了解，也掌握了一些基本的语法。接下来我们要讨论如何进行有效的内存管理。设计高效的内存分配器通常会考虑到以下几点：</p>
<ul>
<li>尽可能减少内存碎片，提高内存利用率</li>
<li>尽可能提高内存的访问局部性</li>
<li>设计在不同场合上适用的内存分配器</li>
<li>考虑到内存对齐</li>
</ul>
<h2 id="含freelist的分配器"><a href="#含freelist的分配器" class="headerlink" title="含freelist的分配器"></a>含freelist的分配器</h2><p>我们首先来考虑一种能够处理任何请求的通用分配器。</p>
<p>一个非常朴素的想法是，对于释放的内存，通过链表将空闲内存链接起来，称为freelist。</p>
<p>分配内存时，先从freelist中查找是否存在满足要求的内存块，如果不存在，再从未分配内存中获取；当我们找到合适的内存块后，分配合适的内存，并将多余的部分放回freelist。</p>
<p>释放内存时，将内存插入到空闲链表，可能的话，合并前后内存块。</p>
<p>其中，有一些细节问题值得考虑：</p>
<p>① 空闲空间应该如何进行管理？</p>
<p>我们知道freelist是用于管理空闲内存的，但是freelist本身的存储也需要占用内存。我们可以按如下两种方式存储freelist:</p>
<ul>
<li>隐式空闲链表：将空闲链表信息与内存块存储在一起。主要记录大小，已分配位等信息。</li>
<li>显式空闲链表：单独维护一块空间来记录所有空闲块信息。</li>
<li>分离适配（segregated-freelist）：将不同大小的内存块放在一起容易造成外部碎片，可以设置多个freelist，并让每个freelist存储不同大小的内存块，申请内存时选择满足条件的最小内存块。</li>
<li>位图：除了freelist之外，还可以考虑用0，1表示对应内存区域是否已分配，称为位图。</li>
</ul>
<p>② 分配内存优先分配哪块内存？</p>
<p>一般而言，从策略不同来分，有以下几种常见的分配方式：</p>
<ul>
<li>首次适应(first-fit）:找到的第一个满足大小要求的空闲区</li>
<li>最佳适应(best-fit) : 满足大小要求的最小空闲区</li>
<li>循环首次适应(next-fit) :在先前停止搜索的地方开始搜索找到的第一个满足大小要求的空闲区</li>
</ul>
<p>③ 释放内存后如何放置到空闲链表中？</p>
<ul>
<li>直接放回链表头部/尾部</li>
<li>按照地址顺序放回</li>
</ul>
<p>这几种策略本质上都是取舍问题：分配/放回时间复杂度如果低，内存碎片就有可能更多，反之亦然。</p>
<h2 id="buddy分配器"><a href="#buddy分配器" class="headerlink" title="buddy分配器"></a>buddy分配器</h2><p>按照一分为二，二分为四的原则，直到分裂出一个满足大小的内存块；合并的时候看buddy是否空闲，如果是就合并。</p>
<p>可以通过位运算直接算出buddy，buddy的buddy，速度较快。但内存碎片较多。</p>
<h2 id="含对齐的分配器"><a href="#含对齐的分配器" class="headerlink" title="含对齐的分配器"></a>含对齐的分配器</h2><p>一般而言，对于通用分配器来说，都应当传回对齐的内存块，即根据对齐量，分配比请求多的对齐的内存。</p>
<p>如下，是ue4中计算对齐的方式，它返回和对齐量向上对齐后的值，其中Alignment应为2的幂次。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">FORCEINLINE <span class="keyword">constexpr</span> T <span class="title">Align</span><span class="params">(T Val, uint64 Alignment)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">static_assert</span>(TIsIntegral&lt;T&gt;::Value || TIsPointer&lt;T&gt;::Value, <span class="string">&quot;Align expects an integer or pointer type&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> (T)(((uint64)Val + Alignment - <span class="number">1</span>) &amp; ~(Alignment - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中<code>~(Alignment - 1)</code>代表的是高位掩码，类似于11110000的格式，它将剔除低位。在对Val进行掩码计算时，加上Alignment - 1的做法类似于<code>(x + a) % a</code>，避免Val值过小得到0的结果。</p>
<h2 id="单帧分配器模型"><a href="#单帧分配器模型" class="headerlink" title="单帧分配器模型"></a>单帧分配器模型</h2><p>用于分配一些临时的每帧生成的数据。分配的内存仅在当前帧适用，每帧开始时会将上一帧的缓冲数据清除，无需手动释放。<br><img src="/img/20210104160910.png" alt=""></p>
<h2 id="双帧分配器模型"><a href="#双帧分配器模型" class="headerlink" title="双帧分配器模型"></a>双帧分配器模型</h2><p>它的基本特点和单帧分配器相近，区别在于第i+1帧适用第i帧分配的内存。它适用于处理非同步的一些数据，避免当前缓冲区被重写（同时读写）<br><img src="/img/20210104160911.png" alt=""></p>
<h2 id="堆栈分配器模型"><a href="#堆栈分配器模型" class="headerlink" title="堆栈分配器模型"></a>堆栈分配器模型</h2><p>堆栈分配器，它的优点是实现简单，并且完全避免了内存碎片，如前文所述，函数栈的设计也使用了堆栈分配器的模型。<br><img src="/img/20210104160912.png" alt=""></p>
<h2 id="双端堆栈分配器模型"><a href="#双端堆栈分配器模型" class="headerlink" title="双端堆栈分配器模型"></a>双端堆栈分配器模型</h2><p>可以从两端开始分配内存，分别用于处理不同的事务，能够更充分地利用内存。</p>
<h2 id="池分配器模型"><a href="#池分配器模型" class="headerlink" title="池分配器模型"></a>池分配器模型</h2><p>池分配器可以分配大量同尺寸的小块内存。它的空闲块也是由freelist管理的，但由于每个块的尺寸一致，它的操作复杂度更低，且也不存在内存碎片的问题。</p>
<h2 id="tcmalloc的内存分配"><a href="#tcmalloc的内存分配" class="headerlink" title="tcmalloc的内存分配"></a>tcmalloc的内存分配</h2><p>tcmalloc是一个应用比较广泛的内存分配第三方库。对于大于页结构和小于页结构的内存块申请，tcmalloc分别做不同的处理。</p>
<h3 id="小于页的内存块分配"><a href="#小于页的内存块分配" class="headerlink" title="小于页的内存块分配"></a>小于页的内存块分配</h3><p>使用多个内存块定长的freelist进行内存分配，如：8，16，32……，对实际申请的内存向上“取整”。</p>
<p>freelist采用隐式存储的方式。<br><img src="/img/20210104160913.png" alt=""></p>
<h3 id="大于页的内存块分配"><a href="#大于页的内存块分配" class="headerlink" title="大于页的内存块分配"></a>大于页的内存块分配</h3><p>可以一次申请多个page，多个page构成一个span。同样的，我们使用多个定长的span链表来管理不同大小的span。<br><img src="/img/20210104160914.png" alt=""></p>
<p>对于不同大小的对象，都有一个对应的内存分配器，称为CentralCache。具体的数据都存储在span内，每个CentralCache维护了对应的spanlist。如果一个span可以存储多个对象，spanlist内部还会维护对应的freelist。</p>
<h2 id="容器的访问局部性"><a href="#容器的访问局部性" class="headerlink" title="容器的访问局部性"></a>容器的访问局部性</h2><p>由于操作系统内部存在缓存命中的问题，所以我们需要考虑程序的访问局部性，这个访问局部性实际上有两层意思：</p>
<ol>
<li>时间局部性：如果当前数据被访问，那么它将在不久后很可能在此被访问；</li>
<li>空间局部性：如果当前数据被访问，那么它相邻位置的数据很可能也被访问；</li>
</ol>
<p>我们来认识一下常用的几种容器的内存布局：</p>
<ul>
<li>数组/顺序容器：内存连续，访问局部性良好；</li>
<li>map：内部是树状结构，为节点存储，无法保证内存连续性，访问局部性较差（flat_map支持顺序存储）；</li>
<li>链表：初始状态下，如果我们连续顺序插入节点，此时我们认为内存连续，访问较快；但通过多次插入、删除、交换等操作，链表结构变得散乱，访问局部性较差；</li>
</ul>
<h2 id="碎片整理机制"><a href="#碎片整理机制" class="headerlink" title="碎片整理机制"></a>碎片整理机制</h2><p>内存碎片几乎是不可完全避免的，当一个程序运行一定时间后，将会出现越来越多的内存碎片。一个优化的思路就是在引擎底层支持定期地整理内存碎片。简单来说，碎片整理通过不断的移动操作，使所有的内存块“贴合”在一起。为了处理指针可能失效的问题，可以考虑使用智能指针。由于内存碎片整理会造成卡顿，我们可以考虑将整理操作分摊到多帧完成。</p>
<h1 id="ue4内存管理"><a href="#ue4内存管理" class="headerlink" title="ue4内存管理"></a>ue4内存管理</h1><h2 id="自定义内存管理"><a href="#自定义内存管理" class="headerlink" title="自定义内存管理"></a>自定义内存管理</h2><p><img src="/img/20210104160915.png" alt=""></p>
<p>ue4的内存管理主要是通过FMalloc类型的GMalloc这一结构来完成特定的需求，这是一个虚基类，它定义了malloc，realloc，free等一系列常用的内存管理操作。其中，Malloc的两个参数分别是分配内存的大小和对应的对齐量，默认对齐量为0。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The global memory allocator&#x27;s interface. */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CORE_API</span> FMalloc  : </span><br><span class="line"> <span class="keyword">public</span> FUseSystemMallocForNew,</span><br><span class="line"> <span class="keyword">public</span> FExec</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">Malloc</span><span class="params">( SIZE_T Count, uint32 Alignment=DEFAULT_ALIGNMENT )</span> </span>= <span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">TryMalloc</span><span class="params">( SIZE_T Count, uint32 Alignment=DEFAULT_ALIGNMENT )</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">Realloc</span><span class="params">( <span class="type">void</span>* Original, SIZE_T Count, uint32 Alignment=DEFAULT_ALIGNMENT )</span> </span>= <span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">TryRealloc</span><span class="params">(<span class="type">void</span>* Original, SIZE_T Count, uint32 Alignment=DEFAULT_ALIGNMENT)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Free</span><span class="params">( <span class="type">void</span>* Original )</span> </span>= <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>FMalloc有许多不同的实现，如FMallocBinned，FMallocBinned2等，可以在HAL文件夹下找到相关的头文件和定义，如下：<br><img src="/img/20210104160916.png" alt=""></p>
<p>内部通过枚举量来确定对应使用的Allocator：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Which allocator is being used */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EMemoryAllocatorToUse</span></span><br><span class="line">&#123;</span><br><span class="line"> Ansi, <span class="comment">// Default C allocator</span></span><br><span class="line"> Stomp, <span class="comment">// Allocator to check for memory stomping</span></span><br><span class="line"> TBB, <span class="comment">// Thread Building Blocks malloc</span></span><br><span class="line"> Jemalloc, <span class="comment">// Linux/FreeBSD malloc</span></span><br><span class="line"> Binned, <span class="comment">// Older binned malloc</span></span><br><span class="line"> Binned2, <span class="comment">// Newer binned malloc</span></span><br><span class="line"> Binned3, <span class="comment">// Newer VM-based binned malloc, 64 bit only</span></span><br><span class="line"> Platform, <span class="comment">// Custom platform specific allocator</span></span><br><span class="line"> Mimalloc, <span class="comment">// mimalloc</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>对于不同平台而言，都有自己对应的平台内存管理类，它们继承自FGenericPlatformMemory，封装了平台相关的内存操作。具体而言，包含FAndroidPlatformMemory，FApplePlatformMemory，FIOSPlatformMemory，FWindowsPlatformMemory等。</p>
<p>通过调用PlatformMemory的BaseAllocator函数，我们取得平台对应的FMalloc类型，基类默认返回默认的C allocator，而不同平台会有自己特殊的实现。</p>
<p>在PlatformMemory的基础上，为了方便调用，ue4又封装了FMemory类，定义通用内存操作，如在申请内存时，会调用FMemory::Malloc，FMemory内部又会继续调用GMalloc-&gt;Malloc。如下为节选代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CORE_API</span> FMemory</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/** @name Memory functions (wrapper for FPlatformMemory) */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">static</span> FORCEINLINE <span class="type">void</span>* <span class="title">Memmove</span><span class="params">( <span class="type">void</span>* Dest, <span class="type">const</span> <span class="type">void</span>* Src, SIZE_T Count )</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FPlatformMemory::<span class="built_in">Memmove</span>( Dest, Src, Count );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">static</span> FORCEINLINE int32 <span class="title">Memcmp</span><span class="params">( <span class="type">const</span> <span class="type">void</span>* Buf1, <span class="type">const</span> <span class="type">void</span>* Buf2, SIZE_T Count )</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> FPlatformMemory::<span class="built_in">Memcmp</span>( Buf1, Buf2, Count );</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">Malloc</span><span class="params">(SIZE_T Count, uint32 Alignment = DEFAULT_ALIGNMENT)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">Realloc</span><span class="params">(<span class="type">void</span>* Original, SIZE_T Count, uint32 Alignment = DEFAULT_ALIGNMENT)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Free</span><span class="params">(<span class="type">void</span>* Original)</span></span>;</span><br><span class="line"> <span class="function"><span class="type">static</span> SIZE_T <span class="title">GetAllocSize</span><span class="params">(<span class="type">void</span>* Original)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>为了在调用new/delete能够调用ue4的自定义函数，ue4内部替换了operator new。这一替换是通过IMPLEMENT_MODULE宏引入的：<br><img src="/img/20210104160917.png" alt=""></p>
<p>IMPLEMENT_MODULE通过定义REPLACEMENT_OPERATOR_NEW_AND_DELETE宏实现替换，如下图所示，operator new/delete内实际调用被替换为FMemory的相关函数。<br><img src="/img/20210104160918.png" alt=""></p>
<h2 id="FMallocBinned"><a href="#FMallocBinned" class="headerlink" title="FMallocBinned"></a>FMallocBinned</h2><p>我们以FMallocBinned为例介绍ue4中通用内存的分配。</p>
<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>（1） 空闲内存如何管理？</p>
<p>FMallocBinned使用freelist机制管理空闲内存。每个空闲块的信息记录在FFreeMem结构中，显式存储。</p>
<p>（2）不同大小内存如何分配？</p>
<p>FMallocBinned使用内存池机制，内部包含POOL_COUNT(42)个内存池和2个扩展的页内存池；其中每个内存池的信息由FPoolInfo结构体维护，记录了当前FreeMem内存块指针等，而特定大小的所有内存池由FPoolTable维护；内存池内包含了内存块的双向链表。</p>
<p>（3）如何快速根据分配元素大小找到对应的内存池？</p>
<p>为了快速查询当前分配内存大小应该对应使用哪个内存池，有两种办法，一种是二分搜索O(logN)，另一种是打表(O1)，考虑到可分配内存数量并不大，MallocBinned选择了打表的方式，将信息记录在MemSizeToPoolTable。</p>
<p>（4）如何快速删除已分配内存？</p>
<p>为了能够在释放的时候以O(1)时间找到对应内存池，FMallocBinned维护了PoolHashBucket结构用于跟踪内存分配的记录。它组织为双向链表形式，存储了对应内存块和键值。</p>
<h3 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h3><p>● 多个小对象内存池（内存池大小均为PageSize，但存储的数据量不一样）。数据块大小设定如下：<br><img src="/img/20210104160919.png" alt=""></p>
<p>● 两个额外的页内存池，管理大于一个页的内存池，大小为3<em>PageSize和6</em>PageSize</p>
<p>● 操作系统的内存池</p>
<h3 id="分配策略"><a href="#分配策略" class="headerlink" title="分配策略"></a>分配策略</h3><p>分配内存的函数为<code>void* FMallocBinned::Malloc(SIZE_T Size, uint32 Alignment)</code>。其中第一个参数为需要分配的内存的大小，第二个参数为对齐的内存数。</p>
<p>如果用户未指定对齐的内存大小，MallocBinned内部会默认对齐于16字节，如果指定了大于16字节的对齐内存大小，则对齐于用户指定的对齐大小。根据对齐量，计算出最终实际分配的内存大小。</p>
<p>MallocBinned内部对于不同的内存大小有三种不同的处理：</p>
<p>(1) 分配小块内存（0，PAGE_SIZE_LIMIT/2）</p>
<p>根据分配大小从MemSizeToPoolTable中获取对应内存池，并从内存池的当前空闲位置读取一块内存，并移动当前内存指针。如果移动后的内存指针指向的内存块已经使用，则将指针移动到FreeMem链表的下一个元素；如果当前内存池已满，将该内存池移除，并链接到耗尽的内存池。</p>
<p>如果当前内存池已经用尽，下次内存分配时，检测到内存池用尽，会从系统重新申请一块对应大小的内存池。</p>
<p>(2) 分配大块内存 [PAGE_SIZE_LIMIT/2, PAGE_SIZE_LIMIT*3/4]∪(PageSize，PageSize + PAGE_SIZE_LIMIT/2)</p>
<p>需要从额外的页内存池分配，分配方式和（1）一样。</p>
<p>(3) 分配超大内存</p>
<p>从系统内存池中分配。</p>
<h2 id="Allocator"><a href="#Allocator" class="headerlink" title="Allocator"></a>Allocator</h2><p>对于ue4中的容器而言，它的模板有两个参数，第一个是元素类型，第二个就是对应的分配器（Allocator）:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InElementType, <span class="keyword">typename</span> InAllocator&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TArray</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>如下图，容器一般都指定了自己默认的分配器：<br><img src="/img/20210104160920.png" alt=""></p>
<h3 id="默认的堆分配器"><a href="#默认的堆分配器" class="headerlink" title="默认的堆分配器"></a>默认的堆分配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> IndexSize&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TSizedHeapAllocator</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default Allocator</span></span><br><span class="line"><span class="keyword">using</span> FHeapAllocator = TSizedHeapAllocator&lt;<span class="number">32</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>默认情况下，如果我们不指定特定的Allocator，容器会使用大小类型为int32堆分配器，默认由FMemory控制分配（和new一致）</p>
<h3 id="含对齐的分配器-1"><a href="#含对齐的分配器-1" class="headerlink" title="含对齐的分配器"></a>含对齐的分配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;uint32 Alignment = DEFAULT_ALIGNMENT&gt;</span><br><span class="line"><span class="keyword">class</span> TAlignedHeapAllocator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由FMemory控制分配，含对齐。</p>
<h3 id="可扩展大小的分配器"><a href="#可扩展大小的分配器" class="headerlink" title="可扩展大小的分配器"></a>可扩展大小的分配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;uint32 NumInlineElements, <span class="keyword">typename</span> SecondaryAllocator = FDefaultAllocator&gt;</span><br><span class="line"><span class="keyword">class</span> TInlineAllocator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可扩展大小的分配器存储大小为NumInlineElements的定长数组，当实际存储的元素数量高于NumInlineElements时，会从SecondaryAllocator申请分配内存，默认情况下为堆分配器。</p>
<p>对齐量总为<code>DEFAULT_ALIGNMENT</code>。</p>
<h3 id="不可重定位的可扩展大小的分配器"><a href="#不可重定位的可扩展大小的分配器" class="headerlink" title="不可重定位的可扩展大小的分配器"></a>不可重定位的可扩展大小的分配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;uint32 NumInlineElements&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TNonRelocatableInlineAllocator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在支持第二分配器的基础上，允许第二分配器存储指向内联元素的指针。这意味着Allocator不应做指针重定向的操作。但ue4的Allocator通常依赖于指针重定向，因此该分配器不应用于其它Allocator容器。</p>
<h3 id="固定大小的分配器"><a href="#固定大小的分配器" class="headerlink" title="固定大小的分配器"></a>固定大小的分配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;uint32 NumInlineElements&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TFixedAllocator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类似于InlineAllocator，会分配固定大小内存，区别在于当内联存储耗尽后，不会提供额外的分配器。</p>
<h3 id="稀疏数组分配器"><a href="#稀疏数组分配器" class="headerlink" title="稀疏数组分配器"></a>稀疏数组分配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InElementAllocator = FDefaultAllocator,<span class="keyword">typename</span> InBitArrayAllocator = FDefaultBitArrayAllocator&gt;</span><br><span class="line"><span class="keyword">class</span> TSparseArrayAllocator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> InElementAllocator ElementAllocator;</span><br><span class="line"> <span class="keyword">typedef</span> InBitArrayAllocator BitArrayAllocator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>稀疏数组本身的定义比较简单，它主要用于稀疏数组（Sparse Array），相关的操作也在对应数组类中完成。稀疏数组支持不连续的下标索引，通过BitArrayAllocator来控制分配哪个位是可用的，能够以O(1)的时间删除元素。</p>
<p>默认使用堆分配。</p>
<h3 id="哈希分配器"><a href="#哈希分配器" class="headerlink" title="哈希分配器"></a>哈希分配器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line"> <span class="keyword">typename</span> InSparseArrayAllocator               = TSparseArrayAllocator&lt;&gt;,</span><br><span class="line"> <span class="keyword">typename</span> InHashAllocator                      = TInlineAllocator&lt;<span class="number">1</span>,FDefaultAllocator&gt;,</span><br><span class="line"> uint32   AverageNumberOfElementsPerHashBucket = DEFAULT_NUMBER_OF_ELEMENTS_PER_HASH_BUCKET,</span><br><span class="line"> uint32   BaseNumberOfHashBuckets              = DEFAULT_BASE_NUMBER_OF_HASH_BUCKETS,</span><br><span class="line"> uint32   MinNumberOfHashedElements            = DEFAULT_MIN_NUMBER_OF_HASHED_ELEMENTS</span><br><span class="line"> &gt;</span><br><span class="line"><span class="keyword">class</span> TSetAllocator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="type">static</span> FORCEINLINE uint32 <span class="built_in">GetNumberOfHashBuckets</span>(uint32 NumHashedElements) &#123; <span class="comment">//... &#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> InSparseArrayAllocator SparseArrayAllocator;</span><br><span class="line"> <span class="keyword">typedef</span> InHashAllocator        HashAllocator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用于TSet/TMap等结构的哈希分配器，同样的实现比较简单，具体的分配策略在TSet等结构中实现。其中SparseArrayAllocator用于管理Value，HashAllocator用于管理Key。Hash空间不足时，按照2的幂次进行扩展。</p>
<p>默认使用堆分配。</p>
<p>除了使用默认的堆分配器，稀疏数组分配器和哈希分配器都有对应的可扩展大小（InlineAllocator)/固定大小(FixedAllocator)分配版本。</p>
<h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><h3 id="TSharedPtr"><a href="#TSharedPtr" class="headerlink" title="TSharedPtr"></a>TSharedPtr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span>, ESPMode Mode &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TSharedPtr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> ObjectType* Object;</span><br><span class="line"> SharedPointerInternals::FSharedReferencer&lt; Mode &gt; SharedReferenceCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TSharedPtr是ue4提供的类似stl sharedptr的解决方案，但相比起stl，它可由第二个模板参数控制是否线程安全。</p>
<p>如上所示，它基于类内的引用计数实现(SharedReferenceCount)，为了确保多个TSharedPtr能够同步当前引用计数的信息，引用计数被设计为指针类型。在拷贝/构造/赋值等操作时，会增加或减少引用计数的值，当引用计数为0时将销毁指针所指对象。</p>
<h3 id="TSharedRef"><a href="#TSharedRef" class="headerlink" title="TSharedRef"></a>TSharedRef</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span>, ESPMode Mode &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TSharedRef</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> ObjectType* Object;</span><br><span class="line"> SharedPointerInternals::FSharedReferencer&lt; Mode &gt; SharedReferenceCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和TSharedPtr类似，但存储的指针不可为空，创建时需同时初始化指针。类似于C++中的引用。</p>
<h3 id="TRefCountPtr"><a href="#TRefCountPtr" class="headerlink" title="TRefCountPtr"></a>TRefCountPtr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ReferencedType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TRefCountPtr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> ReferencedType* Reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>TRefCountPtr是基于引用计数的共享指针的另一种实现。和TSharedPtr的差异在于它的引用计数并非智能指针类内维护的，而是基于对象的，相当于TRefCountPtr内部只存储了对应的指针信息（ReferencedType* Reference)。<br>基于对象的引用计数，即引用计数存储在对象内部，这是通过从FRefCountBase继承引入的。这也就意味着TRefCountPtr引用的对象必须从FRefCountBase继承，它的使用是有局限性的。</p>
<p>但是在如统计资源引用而判断资源是否需要卸载的应用场景中，TRefCountPtr可手动添加/释放引用，使用上更友好。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FRefCountBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">mutable</span> int32 NumRefs = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">TWeakPtr</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">ObjectType</span>, ESPMode Mode &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TWeakPtr</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>类似的，TWeakObjectPtr是ue4提供的类似stl weakptr的解决方案，它将不影响引用计数。</p>
<h3 id="TWeakObjectPtr"><a href="#TWeakObjectPtr" class="headerlink" title="TWeakObjectPtr"></a>TWeakObjectPtr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">TWeakObjectPtrBase</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TWeakObjectPtr</span> : <span class="keyword">private</span> TWeakObjectPtrBase</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FWeakObjectPtr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> int32  ObjectIndex;</span><br><span class="line"> int32  ObjectSerialNumber;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>特别的，由于UObject有对应的gc机制，TWeakObjectPtr为指向UObject的弱指针，用于查询对象是否有效（是否被回收）</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>C++语言本身并没有垃圾回收机制，ue4基于内部的UObject，单独实现了一套GC机制，此处仅做简单介绍。</p>
<p>首先，对于UObject相关对象，为了维持引用（防止被回收），通常使用UProperty()宏，使用容器（如TArray存储），或调用AddToRoot的方法。</p>
<p>ue4的垃圾回收代码实现位于GarbageCollection.cpp中的CollectGarbage函数中。这一函数会在游戏线程中被反复调用，要么在一些情况下手动调用，要么在游戏循环Tick()中满足条件时自动调用。</p>
<p>GC过程中，首先会收集所有不可到达的对象（无引用）。<br><img src="/img/20210104160921.png" alt=""></p>
<p>之后，根据当前情况，会在单帧（无时间限制）或多帧（有时间限制）的时间内，清理相关对象（IncrementalPurgeGarbage）</p>
<h2 id="SIMD-1"><a href="#SIMD-1" class="headerlink" title="SIMD"></a>SIMD</h2><p>合理的内存布局/对齐有利于SIMD的广泛应用，在编写定义基础类型/底层数学算法库时，我们通常有必要考虑到这一点。</p>
<p>我们可以参考ue4中封装的sse初始化、加法、减法、乘法等操作，其中，__m128类型的变量需程序确保为16字节对齐，它适用于浮点数存储，大部分情况下存储于内存中，计算时会在SSE寄存器中运用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __m128 VectorRegister;</span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE VectorRegister <span class="title">VectorLoad</span><span class="params">( <span class="type">const</span> <span class="type">void</span>* Ptr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> _mm_loadu_ps((<span class="type">float</span>*)(Ptr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE VectorRegister <span class="title">VectorAdd</span><span class="params">( <span class="type">const</span> VectorRegister&amp; Vec1, <span class="type">const</span> VectorRegister&amp; Vec2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> _mm_add_ps(Vec1, Vec2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE VectorRegister <span class="title">VectorSubtract</span><span class="params">( <span class="type">const</span> VectorRegister&amp; Vec1, <span class="type">const</span> VectorRegister&amp; Vec2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> _mm_sub_ps(Vec1, Vec2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FORCEINLINE VectorRegister <span class="title">VectorMultiply</span><span class="params">( <span class="type">const</span> VectorRegister&amp; Vec1, <span class="type">const</span> VectorRegister&amp; Vec2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> _mm_mul_ps(Vec1, Vec2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>除了SSE外，ue4还针对Neon/FPU等寄存器封装了统一的接口，这意味调用者可以无需考虑过多硬件的细节。</p>
<p>我们可以在多个数学运算库中看到相关的调用，如球谐向量的相加：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Addition operator. */</span></span><br><span class="line"><span class="keyword">friend</span> FORCEINLINE TSHVector <span class="keyword">operator</span>+(<span class="type">const</span> TSHVector&amp; A,<span class="type">const</span> TSHVector&amp; B)</span><br><span class="line">&#123;</span><br><span class="line"> TSHVector Result;</span><br><span class="line"> <span class="keyword">for</span>(int32 BasisIndex = <span class="number">0</span>;BasisIndex &lt; NumSIMDVectors;BasisIndex++)</span><br><span class="line"> &#123;</span><br><span class="line">  VectorRegister AddResult = <span class="built_in">VectorAdd</span>(</span><br><span class="line">   <span class="built_in">VectorLoadAligned</span>(&amp;A.V[BasisIndex * NumComponentsPerSIMDVector]),</span><br><span class="line">   <span class="built_in">VectorLoadAligned</span>(&amp;B.V[BasisIndex * NumComponentsPerSIMDVector])</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">VectorStoreAligned</span>(AddResult, &amp;Result.V[BasisIndex * NumComponentsPerSIMDVector]);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/04/Makefile%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/04/Makefile%E6%95%99%E7%A8%8B/" itemprop="url">Makefile教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-04T15:49:00+08:00">
                2020-01-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="makefile很重要"><a href="#makefile很重要" class="headerlink" title="makefile很重要"></a>makefile很重要</h1><p>什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——<code>自动化编译</code>，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，VisualC++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。</p>
<p>现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在<code>文件依赖性</code>上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHatLinux8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE1003.2-1992标准的（POSIX.2）。</p>
<p>在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。</p>
<h2 id="关于程序的编译和链接"><a href="#关于程序的编译和链接" class="headerlink" title="关于程序的编译和链接"></a>关于程序的编译和链接</h2><p>在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是.obj文件，UNIX下是.o文件，即ObjectFile，这个动作叫做编译（compile）。然后再把大量的ObjectFile合成执行文件，这个动作叫作链接（link）。</p>
<p>编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。</p>
<p>链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（ObjectFile），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫<code>库文件</code>（LibraryFile)，也就是.lib文件，在UNIX下，是ArchiveFile，也就是.a文件。</p>
<p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成ObjectFile。而在链接程序时，链接器会在所有的ObjectFile中找寻函数的实现，如果找不到，那到就会报链接错误码（LinkerError），在VC下，这种错误一般是：Link2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的ObjectFile.</p>
<p>好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。</p>
<h1 id="Makefile介绍"><a href="#Makefile介绍" class="headerlink" title="Makefile介绍"></a>Makefile介绍</h1><p>make命令执行时，需要一个Makefile文件，以告诉make命令需要怎么样的去编译和链接程序。</p>
<p>首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感性认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：</p>
<p>1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。</p>
<p>2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。</p>
<p>3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</p>
<p>只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p>
<h2 id="Makefile的规则"><a href="#Makefile的规则" class="headerlink" title="Makefile的规则"></a>Makefile的规则</h2><p>在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target...: prerequisites...</span><br><span class="line"></span><br><span class="line">command</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>target也就是一个目标文件，可以是ObjectFile，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的<code>伪目标</code>章节中会有叙述。</p>
<p>prerequisites就是，要生成那个target所需要的文件或是目标。</p>
<p>command也就是make需要执行的命令。（任意的Shell命令）</p>
<p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</p>
<p>说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）</p>
<h2 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h2><p>正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">edit: main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">main.o: main.c defs.h</span><br><span class="line"></span><br><span class="line">cc –c main.c</span><br><span class="line"></span><br><span class="line">kbd.o: kbd.c defs.h command.h</span><br><span class="line"></span><br><span class="line">cc –c kbd.c</span><br><span class="line"></span><br><span class="line">command.o: command.c defs.h command.h</span><br><span class="line"></span><br><span class="line">cc –c command.c</span><br><span class="line"></span><br><span class="line">display.o: display.c defs.h buffer.h</span><br><span class="line"></span><br><span class="line">cc –c display.c</span><br><span class="line"></span><br><span class="line">insert.o: insert.c defs.h buffer.h</span><br><span class="line"></span><br><span class="line">cc -c insert.c</span><br><span class="line"></span><br><span class="line">search.o: search.c defs.h buffer.h</span><br><span class="line"></span><br><span class="line">cc -c search.c</span><br><span class="line"></span><br><span class="line">files.o: files.c defs.h buffer.h command.h</span><br><span class="line"></span><br><span class="line">cc -c files.c</span><br><span class="line"></span><br><span class="line">utils.o: utils.c defs.h</span><br><span class="line"></span><br><span class="line">cc –c utils.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line"></span><br><span class="line">rm edit main.o kbd.o command.odisplay.o insert.o search.o files.outils.o</span><br></pre></td></tr></table></figure><br>反斜杠（\）是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为<code>Makefile</code>或<code>makefile</code>的文件中，然后在该目录下直接输入命令<code>make</code>就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下<code>make clean</code>就可以了。</p>
<p>在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些.c文件和.h文件。每一个.o文件都有一组依赖文件，而这些.o文件又是执行文件edit的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p>
<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p>
<p>这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p>
<h2 id="make是如何工作的"><a href="#make是如何工作的" class="headerlink" title="make是如何工作的"></a>make是如何工作的</h2><p>在默认的方式下，也就是我们只输入make命令。那么，</p>
<p>make会在当前目录下找名字叫<code>Makefile</code>或<code>makefile</code>的文件。</p>
<p>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到<code>edit</code>这个文件，并把这个文件作为最终的目标文件。</p>
<p>如果edit文件不存在，或是edit所依赖的后面的.o文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。</p>
<p>如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）</p>
<p>当然，你的C文件和H文件是存在的啦，于是make会生成.o文件，然后再用.o文件声明make的终极任务，也就是执行文件edit了。</p>
<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>
<p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——<code>make clean</code>，以此来清除所有的目标文件，以便重编译。</p>
<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。</p>
<p>而如果我们改变了<code>command.h</code>，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。</p>
<h2 id="makefile中使用变量"><a href="#makefile中使用变量" class="headerlink" title="makefile中使用变量"></a>makefile中使用变量</h2><p>在上面的例子中，先让我们看看edit的规则：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edit:main.o kbd.o command.odisplay.o insert.o search.o files.outils.o</span><br><span class="line"></span><br><span class="line">cc –o edit main.o kbd.ocommand.o display.o insert.o search.o files.outils.o</span><br></pre></td></tr></table></figure><br>我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。</p>
<p>比如，我们声明一个变量，叫objects,OBJECTS,objs,OBJS,obj,或是OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objects=main.o kbd.o command.odisplay.o\</span><br><span class="line"></span><br><span class="line">insert.o search.o files.outils.o</span><br></pre></td></tr></table></figure><br>于是，我们就可以很方便地在我们的makefile中以<code>$(objects)</code>的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o insert.osearch.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit: $(objects)</span><br><span class="line">	cc–o edit$(objects)</span><br><span class="line"></span><br><span class="line">main.o: main.cdefs.h</span><br><span class="line">	cc –c main.c</span><br><span class="line"></span><br><span class="line">kbd.o: kbd.c defs.h command.h</span><br><span class="line">	cc –c kbd.c</span><br><span class="line"></span><br><span class="line">command.o: command.c defs.h command.h</span><br><span class="line">	cc –c command.c</span><br><span class="line"></span><br><span class="line">display.o: display.c defs.h buffer.h</span><br><span class="line">	cc -c display.c</span><br><span class="line"></span><br><span class="line">insert.o: insert.c defs.h buffer.h</span><br><span class="line">	cc–c insert.c</span><br><span class="line"></span><br><span class="line">search.o: search.c defs.h buffer.h</span><br><span class="line">	cc–c search.c</span><br><span class="line"></span><br><span class="line">files.o: files.c defs.h buffer.h command.h</span><br><span class="line">	cc–c files.c</span><br><span class="line"></span><br><span class="line">utils.o: utils.c defs.h</span><br><span class="line">	cc– c utils.c</span><br><span class="line"></span><br><span class="line">clean: </span><br><span class="line">	rm edit$(objects)</span><br></pre></td></tr></table></figure><br>于是如果有新的.o文件加入，我们只需简单地修改一下objects变量就可以了。</p>
<p>关于变量更多的话题，我会在后续给你一一道来。</p>
<h2 id="让make自动推导"><a href="#让make自动推导" class="headerlink" title="让make自动推导"></a>让make自动推导</h2><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且<code>cc -c whatever.c</code>也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : $(objects)</span><br><span class="line"></span><br><span class="line">cc-o edit $(objects)</span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line"></span><br><span class="line">kbd.o : defs.hcommand.h</span><br><span class="line"></span><br><span class="line">command.o : defs.hcommand.h</span><br><span class="line"></span><br><span class="line">display.o : defs.hbuffer.h</span><br><span class="line"></span><br><span class="line">insert.o : defs.hbuffer.h</span><br><span class="line"></span><br><span class="line">search.o : defs.hbuffer.h</span><br><span class="line"></span><br><span class="line">files.o : defs.hbuffer.h command.h</span><br><span class="line"></span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">	rm edit $(objects)</span><br></pre></td></tr></table></figure><br>这种方法，也就是make的<code>隐晦规则</code>。上面文件内容中，<code>.PHONY</code>表示，clean是个伪目标文件。</p>
<p>关于更为详细的<code>隐晦规则</code>和<code>伪目标文件</code>，我会在后续给你一一道来。</p>
<h2 id="另类风格的makefile"><a href="#另类风格的makefile" class="headerlink" title="另类风格的makefile"></a>另类风格的makefile</h2><p>即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o insert.osearch.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : $(objects)</span><br><span class="line"></span><br><span class="line">cc -o edit $(objects)</span><br><span class="line"></span><br><span class="line">$(objects) : defs.h</span><br><span class="line"></span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line"></span><br><span class="line">display.o insert.osearch.o files.o : buffer.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">	rm edit $(objects)</span><br></pre></td></tr></table></figure><br>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。</p>
<h2 id="清空目标文件的规则"><a href="#清空目标文件的规则" class="headerlink" title="清空目标文件的规则"></a>清空目标文件的规则</h2><p>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个<code>修养</code>（呵呵，还记得我的《编程修养》吗）。一般的风格都是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line"></span><br><span class="line">rm edit $(objects)</span><br></pre></td></tr></table></figure><br>更为稳健的做法是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line"></span><br><span class="line">-rm edit $(objects)</span><br></pre></td></tr></table></figure><br>前面说过，.PHONY意思表示clean是一个<code>伪目标</code>，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——<code>clean从来都是放在文件的最后</code>。</p>
<p>上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。</p>
<h1 id="Makefile总述"><a href="#Makefile总述" class="headerlink" title="Makefile总述"></a>Makefile总述</h1><h2 id="Makefile里有什么？"><a href="#Makefile里有什么？" class="headerlink" title="Makefile里有什么？"></a>Makefile里有什么？</h2><p>Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</p>
<ul>
<li>显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</li>
<li>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。</li>
<li>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</li>
<li>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</li>
<li>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用<code>#</code>字符，这个就像C/C++中的<code>//</code>一样。如果你要在你的Makefile中使用<code>#</code>字符，可以用反斜框进行转义，如：<code>\#</code>。</li>
<li>最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。</li>
</ul>
<h2 id="Makefile的文件名"><a href="#Makefile的文件名" class="headerlink" title="Makefile的文件名"></a>Makefile的文件名</h2><p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为<code>GNUmakefile</code>、<code>makefile</code>、<code>Makefile</code>的文件，找到了解释这个文件。在这三个文件名中，最好使用<code>Makefile</code>这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用<code>GNUmakefile</code>，这个文件是GNU的make识别的。有另外一些make只对全小写的<code>makefile</code>文件名敏感，但是基本上来说，大多数的make都支持<code>makefile</code>和<code>Makefile</code>这两种默认文件名。</p>
<p>当然，你可以使用别的文件名来书写Makefile，比如：<code>Make.Linux</code>，<code>Make.Solaris</code>，<code>Make.AIX</code>等，如果要指定特定的Makefile，你可以使用make的<code>-f</code>和<code>--file</code>参数，如：make –f Make.Linux或make –file Make.AIX。</p>
<h2 id="引用其它的Makefile"><a href="#引用其它的Makefile" class="headerlink" title="引用其它的Makefile"></a>引用其它的Makefile</h2><p>在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：</p>
<p>include <filename> filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）</p>
<p>在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include foo.make *.mk$(bar)</span><br></pre></td></tr></table></figure><br>等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include foo.make a.mkb.mk c.mk e.mk f.mk</span><br></pre></td></tr></table></figure><br>make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p>
<ol>
<li>如果make执行时，有<code>-I</code>或<code>--include-dir</code>参数，那么make就会在这个参数所指定的目录下去寻找。</li>
<li>如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</li>
</ol>
<p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号<code>-</code>。如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-include&lt;filename&gt;</span><br></pre></td></tr></table></figure><br>其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</p>
<h2 id="环境变量MAKEFILES"><a href="#环境变量MAKEFILES" class="headerlink" title="环境变量MAKEFILES"></a>环境变量MAKEFILES</h2><p>如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的<code>目标</code>不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p>
<p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p>
<h2 id="make的工作方式"><a href="#make的工作方式" class="headerlink" title="make的工作方式"></a>make的工作方式</h2><p>GNU的make工作时的执行步骤入下：（想来其它的make也是类似）</p>
<ol>
<li>读入所有的Makefile。</li>
<li>读入被include的其它Makefile。</li>
<li>初始化文件中的变量。</li>
<li>推导隐晦规则，并分析所有规则。</li>
<li>为所有的目标文件创建依赖关系链。</li>
<li>根据依赖关系，决定哪些目标要重新生成。</li>
<li>执行生成命令。</li>
</ol>
<p>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。</p>
<p>当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。</p>
<h1 id="Makefile书写规则"><a href="#Makefile书写规则" class="headerlink" title="Makefile书写规则"></a>Makefile书写规则</h1><p>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。</p>
<p>在Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。</p>
<p>好了，还是让我们来看一看如何书写规则。</p>
<h2 id="规则举例"><a href="#规则举例" class="headerlink" title="规则举例"></a>规则举例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.o: foo.c defs.h #foo模块</span><br><span class="line">	cc –c –g foo.c</span><br></pre></td></tr></table></figure>
<p>看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令<code>cc –c –g foo.c</code>（以Tab键开头）。这个规则告诉我们两件事：</p>
<ol>
<li>文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。</li>
<li>如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）</li>
</ol>
<h2 id="规则的语法"><a href="#规则的语法" class="headerlink" title="规则的语法"></a>规则的语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">targets:prerequisites</span><br><span class="line">command</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>或是这样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">targets:prerequisites;command</span><br><span class="line">command</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。</p>
<p>command是命令行，如果其不与<code>target:prerequisites</code>在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）</p>
<p>prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是<code>过时的</code>，被认为是需要重生成的。这个在前面已经讲过了。</p>
<p>如果命令太长，你可以使用反斜框（‘\’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何生成目标文件。</p>
<p>一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。</p>
<h2 id="在规则中使用通配符"><a href="#在规则中使用通配符" class="headerlink" title="在规则中使用通配符"></a>在规则中使用通配符</h2><p>如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：<code>*</code>，<code>?</code>和<code>[...]</code>。这是和Unix的B-Shell是相同的。</p>
<p><code>~</code>: 波浪号（<code>~</code>）字符在文件名中也有比较特殊的用途。如果是<code>~/test</code>，这就表示当前用户的<code>$HOME</code>目录下的test目录。而<code>~hchen/test</code>则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量<code>HOME</code>而定。</p>
<p><code>*</code>通配符代替了你一系列的文件，如<code>*.c</code>表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：<code>*</code>，那么可以用转义字符<code>\</code>，如<code>\*</code>来表示真实的<code>*</code>字符，而不是任意长度的字符串。</p>
<p>好吧，还是先来看几个例子吧：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">	rm –f *.o</span><br></pre></td></tr></table></figure><br>上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print: *.c</span><br><span class="line"></span><br><span class="line">lpr –p $?</span><br><span class="line"></span><br><span class="line">touch print</span><br></pre></td></tr></table></figure><br>上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的<code>$?</code>是一个自动化变量，我会在后面给你讲述。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objects=*.o</span><br></pre></td></tr></table></figure><br>上面这个例子，表示了，通符同样可以用在变量中。并不是说<code>[*.o]</code>会展开，不！objects的值就是<code>*.o</code>。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objects:=$(wildcard*.o)</span><br></pre></td></tr></table></figure><br>这种用法由关键字<code>wildcard</code>指出，关于Makefile的关键字，我们将在后面讨论。</p>
<h2 id="文件搜寻"><a href="#文件搜寻" class="headerlink" title="文件搜寻"></a>文件搜寻</h2><p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。</p>
<p>Makefile文件中的特殊变量<code>VPATH</code>就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPATH=src:../headers</span><br></pre></td></tr></table></figure><br>上面的的定义指定两个目录，<code>src</code>和<code>../headers</code>，make会按照这个顺序进行搜索。目录由<code>冒号</code>分隔。（当然，当前目录永远是最高优先搜索的地方）</p>
<p>另一个设置文件搜索路径的方法是使用make的<code>vpath</code>关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</p>
<ol>
<li><code>vpath&lt;pattern&gt;&lt;directories&gt;</code>为符合模式<code>&lt;pattern&gt;</code>的文件指定搜索目录<code>&lt;directories&gt;</code>。</li>
<li><code>vpath&lt;pattern&gt;</code>清除符合模式<code>&lt;pattern&gt;</code>的文件的搜索目录。</li>
<li><code>vpath</code>清除所有已被设置好了的文件搜索目录。</li>
</ol>
<p><code>vapth</code>使用方法中的<code>&lt;pattern&gt;</code>需要包含<code>%</code>字符。<code>%</code>的意思是匹配零或若干字符，例如，<code>%.h</code>表示所有以<code>.h</code>结尾的文件。<code>&lt;pattern&gt;</code>指定了要搜索的文件集，而<code>&lt;directories&gt;</code>则指定了的文件集的搜索的目录。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vpath %.h ../headers</span><br></pre></td></tr></table></figure><br>该语句表示，要求make在<code>../headers</code>目录下搜索所有以<code>.h</code>结尾的文件。（如果某文件在当前目录没有找到的话）</p>
<p>我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的<code>&lt;pattern&gt;</code>，或是被重复了的<code>&lt;pattern&gt;</code>，那么，make会按照vpath语句的先后顺序来执行搜索。如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vpath %.c foo</span><br><span class="line">vpath % blish</span><br><span class="line">vpath %.c bar</span><br></pre></td></tr></table></figure><br>其表示<code>.c</code>结尾的文件，先在<code>foo</code>目录，然后是<code>blish</code>，最后是<code>bar</code>目录。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vpath %.c foo:bar</span><br><span class="line">vpath % blish</span><br></pre></td></tr></table></figure><br>而上面的语句则表示<code>.c</code>结尾的文件，先在<code>foo</code>目录，然后是<code>bar</code>目录，最后才是<code>blish</code>目录。</p>
<h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><p>最早先的一个例子中，我们提到过一个<code>clean</code>的目标，这是一个<code>伪目标</code>，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">	rm *.o temp</span><br></pre></td></tr></table></figure><br>正像我们前面例子中的<code>clean</code>一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的<code>目标</code>以备完整地重编译而用。（以<code>make clean</code>来使用该目标）</p>
<p>因为，我们并不生成<code>clean</code>这个文件。<code>伪目标</code>并不是一个文件，只是一个标签，由于<code>伪目标</code>不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个<code>目标</code>才能让其生效。当然，<code>伪目标</code>的取名不能和文件名重名，不然其就失去了<code>伪目标</code>的意义了。</p>
<p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记<code>.PHONY</code>来显示地指明一个目标是<code>伪目标</code>，向make说明，不管是否有这个文件，这个目标就是<code>伪目标</code>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:clean</span><br></pre></td></tr></table></figure><br>只要有这个声明，不管是否有<code>clean</code>文件，要运行<code>clean</code>这个目标，只有<code>make clean</code>这样。于是整个过程可以这样写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line"></span><br><span class="line">rm *.o temp</span><br></pre></td></tr></table></figure><br>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为<code>默认目标</code>，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用<code>伪目标</code>这个特性：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">all:prog1 prog2 prog3</span><br><span class="line"></span><br><span class="line">.PHONY:all</span><br><span class="line"></span><br><span class="line">prog1:prog1.o utils.o</span><br><span class="line">	cc –o prog1 prog1.o utils.o</span><br><span class="line"></span><br><span class="line">prog2:prog2.o</span><br><span class="line">	cc –o prog2 prog2.o</span><br><span class="line"></span><br><span class="line">prog3:prog3.o sort.o utils.o</span><br><span class="line">	cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure><br>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个<code>all</code>的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如<code>all</code>这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。<code>.PHONY:all</code>声明了<code>all</code>这个目标为<code>伪目标</code>。</p>
<p>随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall:cleanobj cleandiff</span><br><span class="line">	rm program</span><br><span class="line"></span><br><span class="line">cleanobj:</span><br><span class="line">	rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff:</span><br><span class="line">	rm *.diff</span><br></pre></td></tr></table></figure><br><code>make clean</code>将清除所有要被清除的文件。<code>cleanobj</code>和<code>cleandiff</code>这两个伪目标有点像<code>子程序</code>的意思。我们可以输入<code>make cleanall</code>和<code>make cleanobj</code>和<code>make cleandiff</code>命令来达到清除不同种类文件的目的</p>
<h2 id="多目标"><a href="#多目标" class="headerlink" title="多目标"></a>多目标</h2><p>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量<code>$@</code>（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bigoutput littleoutput:text.g</span><br><span class="line"></span><br><span class="line">generate text.g -$(substoutput,,$@)&gt;$@</span><br></pre></td></tr></table></figure><br>上述规则等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bigoutput:text.g</span><br><span class="line"></span><br><span class="line">generate text.g -big &gt;bigoutput</span><br><span class="line"></span><br><span class="line">littleoutput:text.g</span><br><span class="line"></span><br><span class="line">generate text.g -little&gt; littleoutput</span><br></pre></td></tr></table></figure><br>其中，<code>-$(subst output,,$@)</code>中的<code>$</code>表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，<code>$@</code>表示目标的集合，就像一个数组，<code>$@</code>依次取出目标，并执于命令。</p>
<h2 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h2><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;targets...&gt;:&lt;target-pattern&gt;:&lt;prereq-patterns...&gt;</span><br><span class="line"></span><br><span class="line">&lt;commands&gt;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p>
<p>target-parrtern是指明了targets的模式，也就是的目标集模式。</p>
<p>prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。</p>
<p>这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的<code>&lt;target-parrtern&gt;</code>定义成<code>%.o</code>，意思是我们的集合中都是以<code>.o</code>结尾的，而如果我们的<code>&lt;prereq-parrterns&gt;</code>定义成<code>%.c</code>，意思是对<code>&lt;target-parrtern&gt;</code>所形成的目标集进行二次定义，其计算方法是，取<code>&lt;target-parrtern&gt;</code>模式中的<code>%</code>（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。</p>
<p>所以，我们的<code>目标模式</code>或是<code>依赖模式</code>中都应该有<code>%</code>这个字符，如果你的文件名中有<code>%</code>那么你可以使用反斜杠<code>\</code>进行转义，来标明真实的<code>%</code>字符。</p>
<p>看一个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">objects=foo.o bar.o</span><br><span class="line"></span><br><span class="line">all:$(objects)</span><br><span class="line"></span><br><span class="line">$(objects):%.o:%.c</span><br><span class="line"></span><br><span class="line">$(CC)–c $(CFLAGS) $&lt; -o $@</span><br></pre></td></tr></table></figure><br>上面的例子中，指明了我们的目标从<code>$object</code>中获取，<code>%.o</code>表明要所有以<code>.o</code>结尾的目标，也就是<code>foo.o bar.o</code>，也就是变量<code>$object</code>集合的模式，而依赖模式<code>%.c</code>则取模式<code>%.o</code>的<code>%</code>，也就是<code>foobar</code>，并为其加下<code>.c</code>的后缀，于是，我们的依赖目标就是<code>foo.c bar.c</code>。而命令中的<code>$&lt;</code>和<code>$@</code>则是自动化变量，<code>$&lt;</code>表示所有的依赖目标集（也就是<code>foo.c bar.c</code>），<code>$@</code>表示目标集（也就是<code>foo.o bar.o</code>）。于是，上面的规则展开后等价于下面的规则：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo.o:foo.c</span><br><span class="line"></span><br><span class="line">$(CC)–c $(CFLAGS) foo.c –o foo.o</span><br><span class="line"></span><br><span class="line">bar.o:bar.c</span><br><span class="line"></span><br><span class="line">$(CC)–c $(CFLAGS) bar.c –o bar.o</span><br></pre></td></tr></table></figure><br>试想，如果我们的<code>%.o</code>有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">files=foo.elc bar.o lose.o</span><br><span class="line"></span><br><span class="line">$(filter %.o,$(files)):%.o:%.c</span><br><span class="line"></span><br><span class="line">$(CC)-c $(CFLAGS) $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(filter %.elc,$(files)):%.elc:%.el</span><br><span class="line"></span><br><span class="line">emacs-f batch-byte-compile $&lt;</span><br></pre></td></tr></table></figure><br><code>$(filter %.o,$(files))</code>表示调用Makefile的filter函数，过滤<code>$filter</code>集，只要其中模式为<code>%.o</code>的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。</p>
<h2 id="自动生成依赖性"><a href="#自动生成依赖性" class="headerlink" title="自动生成依赖性"></a>自动生成依赖性</h2><p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句<code>#include&quot;defs.h&quot;</code>，那么我们的依赖关系应该是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o:main.c defs.h</span><br></pre></td></tr></table></figure><br>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个<code>-M</code>的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -M main.c</span><br></pre></td></tr></table></figure><br>其输出是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o:main.c defs.h</span><br></pre></td></tr></table></figure><br>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用<code>-MM</code>参数，不然，<code>-M</code>参数会把一些标准库的头文件也包含进来。</p>
<p>gcc -M main.c的输出是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">main.o:main.cdefs.h/usr/include/stdio.h/usr/include/features.h\</span><br><span class="line"></span><br><span class="line">/usr/include/sys/cdefs.h/usr/include/gnu/stubs.h\</span><br><span class="line"></span><br><span class="line">/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h\</span><br><span class="line"></span><br><span class="line">/usr/include/bits/types.h/usr/include/bits/pthreadtypes.h\</span><br><span class="line"></span><br><span class="line">/usr/include/bits/sched.h/usr/include/libio.h\</span><br><span class="line"></span><br><span class="line">/usr/include/_G_config.h/usr/include/wchar.h\</span><br><span class="line"></span><br><span class="line">/usr/include/bits/wchar.h/usr/include/gconv.h\</span><br><span class="line"></span><br><span class="line">/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h\</span><br><span class="line"></span><br><span class="line">/usr/include/bits/stdio_lim.h</span><br></pre></td></tr></table></figure><br>gcc -MM main.c的输出则是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o:main.c defs.h</span><br></pre></td></tr></table></figure><br>那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个<code>name.c</code>的文件都生成一个<code>name.d</code>的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。</p>
<p>于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。</p>
<p>这里，我们给出了一个模式规则来产生[.d]文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%.d: %.c</span><br><span class="line"></span><br><span class="line">@set -e;rm -f $@;\</span><br><span class="line"></span><br><span class="line">$(CC) -M $(CPPFLAGS) $&lt;&gt; $@.;\</span><br><span class="line"></span><br><span class="line">sed &#x27;s,$*\.o[:]*,\1.o $@:,g&#x27;&lt; $@. &gt; $@;\</span><br><span class="line"></span><br><span class="line">rm -f $@.</span><br></pre></td></tr></table></figure><br>这个规则的意思是，所有的[.d]文件依赖于[.c]文件，<code>rm -f $@</code>的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件<code>$&lt;</code>，也就是[.c]文件生成依赖文件，<code>$@</code>表示模式<code>%.d</code>文件，如果有一个C文件是name.c，那么<code>%</code>就是<code>name</code>，<code>.</code>意为一个随机编号，第二行生成的文件有可能是<code>name.d.12345</code>，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p>
<p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o:main.c defs.h</span><br></pre></td></tr></table></figure><br>转成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o main.d:main.c defs.h</span><br></pre></td></tr></table></figure><br>于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的<code>include</code>命令，来引入别的Makefile文件（前面讲过），例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"></span><br><span class="line">include $(sources:.c=.d)</span><br></pre></td></tr></table></figure><br>上述语句中的<code>$(sources:.c=.d)</code>中的<code>.c=.d</code>的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]，关于这个<code>替换</code>的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标</p>
<h1 id="Makefile书写命令"><a href="#Makefile书写命令" class="headerlink" title="Makefile书写命令"></a>Makefile书写命令</h1><p>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。</p>
<p>我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被<code>/bin/sh</code>——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，<code>#</code>是注释符，很像C/C++中的<code>//</code>，其后的本行字符都被注释。</p>
<h2 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h2><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用<code>@</code>字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：</p>
<p>@echo正在编译XXX模块……</p>
<p>当make执行时，会输出<code>正在编译XXX模块......</code>字串，但不会输出命令，如果没有<code>@</code>，那么，make将输出：</p>
<p>echo正在编译XXX模块……</p>
<p>正在编译XXX模块……</p>
<p>如果make执行时，带入make参数<code>-n</code>或<code>--just-print</code>，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p>
<p>而make参数<code>-s</code>或<code>--slient</code>则是全面禁止命令的显示。</p>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：</p>
<p>示例一：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exec:</span><br><span class="line"></span><br><span class="line">cd/home/hchen</span><br><span class="line"></span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><br>示例二：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exec:</span><br><span class="line"></span><br><span class="line">cd/home/hchen;pwd</span><br></pre></td></tr></table></figure><br>当我们执行<code>make exec</code>时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出<code>/home/hchen</code>。</p>
<p>make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如<code>.exe</code>、<code>.com</code>、<code>.bat</code>、<code>.sh</code>等后缀。</p>
<h2 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h2><p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p>
<p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。</p>
<p>为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号<code>-</code>（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line"></span><br><span class="line">-rm -f *.o</span><br></pre></td></tr></table></figure><br>还有一个全局的办法是，给make加上<code>-i</code>或是<code>--ignore-errors</code>参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以<code>.IGNORE</code>作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p>
<p>还有一个要提一下的make的参数的是<code>-k</code>或是<code>--keep-going</code>，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。</p>
<h2 id="嵌套执行make"><a href="#嵌套执行make" class="headerlink" title="嵌套执行make"></a>嵌套执行make</h2><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p>
<p>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subsystem:</span><br><span class="line"></span><br><span class="line">cd subdir &amp;&amp;$(MAKE)</span><br></pre></td></tr></table></figure><br>其等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subsystem:</span><br><span class="line"></span><br><span class="line">$(MAKE) -C subdir</span><br></pre></td></tr></table></figure><br>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入<code>subdir</code>目录，然后执行make命令。</p>
<p>我们把这个Makefile叫做<code>总控Makefile</code>，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了<code>-e</code>参数。</p>
<p>如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export &lt;variable...&gt;</span><br></pre></td></tr></table></figure><br>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unexport &lt;variable...&gt;</span><br></pre></td></tr></table></figure><br>如：</p>
<p>示例一：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export variable=value</span><br></pre></td></tr></table></figure><br>其等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable=value</span><br><span class="line"></span><br><span class="line">export variable</span><br></pre></td></tr></table></figure><br>其等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export variable :=value</span><br></pre></td></tr></table></figure><br>其等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable :=value</span><br><span class="line"></span><br><span class="line">export variable</span><br></pre></td></tr></table></figure><br>示例二：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export variable +=value</span><br></pre></td></tr></table></figure><br>其等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable +=value</span><br><span class="line"></span><br><span class="line">export variable</span><br></pre></td></tr></table></figure><br>如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。</p>
<p>需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行<code>总控Makefile</code>时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p>
<p>但是make命令中的有几个参数并不往下传递，它们是<code>-C</code>,<code>-f</code>,<code>-h``-o</code>和<code>-W</code>（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subsystem:</span><br><span class="line"></span><br><span class="line">cd subdir &amp;&amp; $(MAKE)MAKEFLAGS=</span><br></pre></td></tr></table></figure><br>如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有<code>-t</code>,<code>-n</code>,和<code>-q</code>参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。</p>
<p>还有一个在<code>嵌套执行</code>中比较有用的参数，<code>-w</code>或是<code>--print-directory</code>会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是<code>/home/hchen/gnu/make</code>，如果我们使用<code>make -w</code>来执行，那么当进入该目录时，我们会看到：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make: Entering directory`/home/hchen/gnu/make&#x27;.</span><br></pre></td></tr></table></figure><br>而在完成下层make后离开目录时，我们会看到：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make: Leaving directory`/home/hchen/gnu/make&#x27;</span><br></pre></td></tr></table></figure><br>当你使用<code>-C</code>参数来指定make下层Makefile时，<code>-w</code>会被自动打开的。如果参数中有<code>-s</code>（<code>--slient</code>）或是<code>--no-print-directory</code>，那么，<code>-w</code>总是失效的。</p>
<h2 id="定义命令包"><a href="#定义命令包" class="headerlink" title="定义命令包"></a>定义命令包</h2><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以<code>define</code>开始，以<code>endef</code>结束，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define run-yacc</span><br><span class="line"></span><br><span class="line">yacc $(firstword$^)</span><br><span class="line"></span><br><span class="line">mv y.tab.c $@</span><br><span class="line"></span><br><span class="line">endef</span><br></pre></td></tr></table></figure><br>这里，<code>run-yacc</code>是这个命令包的名字，其不要和Makefile中的变量重名。在<code>define</code>和<code>endef</code>中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成<code>y.tab.c</code>的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo.c: foo.y</span><br><span class="line"></span><br><span class="line">$(run-yacc)</span><br></pre></td></tr></table></figure><br>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包<code>run-yacc</code>中的<script type="math/tex">^`就是`foo.y`，`$@`就是`foo.c`（有关这种以`</script>开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。</p>
<h1 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h1><p>在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在<code>目标</code>，<code>依赖目标</code>，<code>命令</code>或是Makefile的其它部分中。变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有<code>:</code>、<code>#</code>、<code>=</code>或是空字符（空格、回车等）。变量是大小写敏感的，<code>foo</code>、<code>Foo</code>和<code>FOO</code>是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。有一些变量是很奇怪字串，如<code>$&lt;</code>、<code>$@</code>等，这些是自动化变量，我会在后面介绍。</p>
<h2 id="变量的基础"><a href="#变量的基础" class="headerlink" title="变量的基础"></a>变量的基础</h2><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上<script type="math/tex">`符号，但最好用小括号`（）`或是大括号`{}`把变量给包括起来。如果你要使用真实的`</script>字符，那么你需要用$$$$来表示。变量可以使用在许多地方，如规则中的<code>目标</code>、<code>依赖</code>、<code>命令</code>以及新的变量中。</p>
<p>先看一个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">objects=program.o foo.o utils.o</span><br><span class="line"></span><br><span class="line">program:$(objects)</span><br><span class="line"></span><br><span class="line">cc -o program $(objects)</span><br><span class="line"></span><br><span class="line">$(objects):defs.h</span><br></pre></td></tr></table></figure><br>变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo=c</span><br><span class="line"></span><br><span class="line">prog.o:prog.$(foo)</span><br><span class="line"></span><br><span class="line">$(foo)$(foo) -$(foo) prog.$(foo)</span><br></pre></td></tr></table></figure><br>展开后得到：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prog.o:prog.c</span><br><span class="line"></span><br><span class="line">cc -c prog.c</span><br></pre></td></tr></table></figure><br>当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个<code>替代</code>的原理。另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。</p>
<h2 id="变量中的变量"><a href="#变量中的变量" class="headerlink" title="变量中的变量"></a>变量中的变量</h2><p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p>
<p>先看第一种方式，也就是简单的使用<code>=</code>号，在<code>=</code>左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好</p>
<p>的值，其也可以使用后面定义的值。如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo=$(bar)</span><br><span class="line"></span><br><span class="line">bar=$(ugh)</span><br><span class="line"></span><br><span class="line">ugh=Huh?</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line"></span><br><span class="line">echo $(foo)</span><br></pre></td></tr></table></figure><br>我们执行<code>make all</code>将会打出变量$(foo)的值是<code>Huh?</code>（$(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是<code>Huh?</code>）可见，变量是可以使用后面的变量来定义的。</p>
<p>这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=$(include_dirs) -O</span><br><span class="line"></span><br><span class="line">include_dirs=-Ifoo -Ibar</span><br></pre></td></tr></table></figure><br>当<code>CFLAGS</code>在命令中被展开时，会是<code>-Ifoo -Ibar -O</code>。但这种形式也有不好的地方，那就是递归定义，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=$(CFLAGS) -O</span><br></pre></td></tr></table></figure><br>或：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A=$(B)</span><br><span class="line"></span><br><span class="line">B=$(A)</span><br></pre></td></tr></table></figure><br>这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数<code>wildcard</code>和<code>shell</code>发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p>
<p>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是<code>:=</code>操作符，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x:=foo</span><br><span class="line"></span><br><span class="line">y:=$(x)bar</span><br><span class="line"></span><br><span class="line">x:=later</span><br></pre></td></tr></table></figure><br>其等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y:=foobar</span><br><span class="line"></span><br><span class="line">x:=later</span><br></pre></td></tr></table></figure><br>值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y:=$(x)bar</span><br><span class="line"></span><br><span class="line">x:=foo</span><br></pre></td></tr></table></figure><br>那么，y的值是<code>bar</code>，而不是<code>foobar</code>。</p>
<p>上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量<code>MAKELEVEL</code>的使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ifeq(0,$&#123;MAKELEVEL&#125;)</span><br><span class="line"></span><br><span class="line">cur-dir:=$(shell pwd)</span><br><span class="line"></span><br><span class="line">whoami:=$(shell whoami)</span><br><span class="line"></span><br><span class="line">host-type:=$(shell arch)</span><br><span class="line"></span><br><span class="line">MAKE:= $&#123;MAKE&#125; host-type=$&#123;host-type&#125;whoami=$&#123;whoami&#125;</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><br>关于条件表达式和函数，我们在后面再说，对于系统变量<code>MAKELEVEL</code>，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的<code>嵌套使用make</code>），那么，这个变量会记录了我们的当前Makefile的调用层数。</p>
<p>下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nullstring:=</span><br><span class="line"></span><br><span class="line">space:=$(nullstring) #endof the line</span><br></pre></td></tr></table></figure><br>nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用<code>#</code>注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于<code>#</code>的使用，注释符<code>#</code>的这种特性值得我们注意，如果我们这样定义一个变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir:=/foo/bar #directoryto put the frobs in</span><br></pre></td></tr></table></figure><br>dir这个变量的值是<code>/foo/bar</code>，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——<code>$(dir)/file</code>那么就完蛋了。</p>
<p>还有一个比较有用的操作符是<code>?=</code>，先看示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOO ?=bar</span><br></pre></td></tr></table></figure><br>其含义是，如果FOO没有被定义过，那么变量FOO的值就是<code>bar</code>，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(originFOO),undefined)</span><br><span class="line"></span><br><span class="line">FOO = bar</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure></p>
<h2 id="变量高级用法"><a href="#变量高级用法" class="headerlink" title="变量高级用法"></a>变量高级用法</h2><p>这里介绍两种变量的高级使用方法，第一种是变量值的替换。</p>
<p>我们可以替换变量中的共有的部分，其格式是<code>$(var:a=b)</code>或是<code>$&#123;var:a=b&#125;</code>，其意思是，把变量<code>var</code>中所有以<code>a</code>字串<code>结尾</code>的<code>a</code>替换成<code>b</code>字串。这里的<code>结尾</code>意思是<code>空格</code>或是<code>结束符</code>。</p>
<p>还是看一个示例吧：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo:=a.o b.o c.o</span><br><span class="line"></span><br><span class="line">bar:=$(foo:.o=.c)</span><br></pre></td></tr></table></figure><br>这个示例中，我们先定义了一个<code>$(foo)</code>变量，而第二行的意思是把<code>$(foo)</code>中所有以<code>.o</code>字串<code>结尾</code>全部替换成<code>.c</code>，所以我们的<code>$(bar)</code>的值就是<code>a.cb.cc.c</code>。</p>
<p>另外一种变量替换的技术是以<code>静态模式</code>（参见前面章节）定义的，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo:=a.o b.o c.o</span><br><span class="line"></span><br><span class="line">bar:=$(foo:%.o=%.c)</span><br></pre></td></tr></table></figure><br>这依赖于被替换字串中的有相同的模式，模式中必须包含一个<code>%</code>字符，这个例子同样让$(bar)变量的值为<code>a.c b.c c.c</code>。</p>
<p>第二种高级用法是——<code>把变量的值再当成变量</code>。先看一个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=y</span><br><span class="line">y=z</span><br><span class="line">a:=$($(x))</span><br></pre></td></tr></table></figure><br>在这个例子中，$(x)的值是<code>y</code>，所以$($(x))就是$(y)，于是$(a)的值就是<code>z</code>。（注意，是<code>x=y</code>，而不是<code>x=$(y)</code>）</p>
<p>我们还可以使用更多的层次：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=y</span><br><span class="line">y=z</span><br><span class="line">z=u</span><br><span class="line">a:=$($($(x)))</span><br></pre></td></tr></table></figure><br>这里的$(a)的值是<code>u</code>，相关的推导留给读者自己去做吧。</p>
<p>让我们再复杂一点，使用上<code>在变量定义中使用变量</code>的第一个方式，来看一个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x=$(y)</span><br><span class="line"></span><br><span class="line">y=z</span><br><span class="line"></span><br><span class="line">z=Hello</span><br><span class="line"></span><br><span class="line">a:=$($(x))</span><br></pre></td></tr></table></figure><br>这里的$($(x))被替换成了$($(y))，因为$(y)值是<code>z</code>，所以，最终结果是：a:=$(z)，也就是<code>Hello</code>。</p>
<p>再复杂一点，我们再加上函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x=variable1</span><br><span class="line"></span><br><span class="line">variable2:=Hello</span><br><span class="line"></span><br><span class="line">y=$(subst 1,2,$(x))</span><br><span class="line"></span><br><span class="line">z=y</span><br><span class="line"></span><br><span class="line">a:= $($($(z)))</span><br></pre></td></tr></table></figure><br>这个例子中，<code>$($($(z)))</code>扩展为<code>$($(y))</code>，而其再次被扩展为<code>$($(subst 1,2,$(x)))</code>。$(x)的值是<code>variable1</code>，subst函数把<code>variable1</code>中的所有<code>1</code>字串替换成<code>2</code>字串，于是，<code>variable1</code>变成<code>variable2</code>，再取其值，所以，最终，$(a)的值就是$(variable2)的值——<code>Hello</code>。（喔，好不容易）</p>
<p>在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">first_second=Hello</span><br><span class="line"></span><br><span class="line">a=first</span><br><span class="line"></span><br><span class="line">b=second</span><br><span class="line"></span><br><span class="line">all=$($a_$b)</span><br></pre></td></tr></table></figure><br>这里的<code>$a_$b</code>组成了<code>first_second</code>，于是，$(all)的值就是<code>Hello</code>。</p>
<p>再来看看结合第一种技术的例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a_objects:=a.o b.o c.o</span><br><span class="line"></span><br><span class="line">1_objects:=1.o 2.o 3.o</span><br><span class="line"></span><br><span class="line">sources:=$($(a1)_objects:.o=.c)</span><br></pre></td></tr></table></figure><br>这个例子中，如果$(a1)的值是<code>a</code>的话，那么，$(sources)的值就是<code>a.c b.c c.c</code>；如果$(a1)的值是<code>1</code>，那么$(sources)的值是<code>1.c 2.c 3.c</code>。</p>
<p>再来看一个这种技术和<code>函数</code>与<code>条件语句</code>一同使用的例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ifdef do_sort</span><br><span class="line"></span><br><span class="line">func :=sort</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">func :=strip</span><br><span class="line"></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">bar :=a d b g q c</span><br><span class="line"></span><br><span class="line">foo :=$($(func)$(bar))</span><br></pre></td></tr></table></figure><br>这个示例中，如果定义了<code>do_sort</code>，那么：foo:=$(sort a d b g q c)，于是$(foo)的值就是<code>a b c d g q</code>，而如果没有定义<code>do_sort</code>，那么：foo:=$(sort a d b g q c)，调用的就是strip函数。</p>
<p>当然，<code>把变量的值再当成变量</code>这种技术，同样可以用在操作符的左边：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dir =foo</span><br><span class="line"></span><br><span class="line">$(dir)_sources:=$(wildcard$(dir)/*.c)</span><br><span class="line"></span><br><span class="line">define $(dir)_print</span><br><span class="line"></span><br><span class="line">lpr $($(dir)_sources)</span><br><span class="line"></span><br><span class="line">endef</span><br></pre></td></tr></table></figure><br>这个例子中定义了三个变量：<code>dir</code>，<code>foo_sources</code>和<code>foo_print</code>。</p>
<h2 id="追加变量值"><a href="#追加变量值" class="headerlink" title="追加变量值"></a>追加变量值</h2><p>我们可以使用<code>+=</code>操作符给变量追加值，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objects=main.o foo.o bar.outils.o</span><br><span class="line"></span><br><span class="line">objects+=another.o</span><br></pre></td></tr></table></figure><br>于是，我们的$(objects)值变成：<code>main.o foo.o bar.o utils.o another.o</code>（another.o被追加进去了）</p>
<p>使用<code>+=</code>操作符，可以模拟为下面的这种例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objects=main.o foo.o bar.outils.o</span><br><span class="line"></span><br><span class="line">objects:=$(objects) another.o</span><br></pre></td></tr></table></figure><br>所不同的是，用<code>+=</code>更为简洁。</p>
<p>如果变量之前没有定义过，那么，<code>+=</code>会自动变成<code>=</code>，如果前面有变量定义，那么<code>+=</code>会继承于前次操作的赋值符。如果前一次的是<code>:=</code>，那么<code>+=</code>会以<code>:=</code>作为其赋值符，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable :=value</span><br><span class="line"></span><br><span class="line">variable +=more</span><br></pre></td></tr></table></figure><br>等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable:=value</span><br><span class="line"></span><br><span class="line">variable:=$(variable)more</span><br></pre></td></tr></table></figure><br>但如果是这种情况：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable =value</span><br><span class="line"></span><br><span class="line">variable +=more</span><br></pre></td></tr></table></figure><br>由于前次的赋值符是<code>=</code>，所以<code>+=</code>也会以<code>=</code>来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</p>
<h2 id="override指示符"><a href="#override指示符" class="headerlink" title="override指示符"></a>override指示符</h2><p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用<code>override</code>指示符。其语法是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override &lt;variable&gt;=&lt;value&gt;</span><br><span class="line"></span><br><span class="line">override &lt;variable&gt;:=&lt;value&gt;</span><br></pre></td></tr></table></figure><br>当然，你还可以追加：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override &lt;variable&gt;+= &lt;moretext&gt;</span><br></pre></td></tr></table></figure><br>对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override define foo</span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line"></span><br><span class="line">endef</span><br></pre></td></tr></table></figure></p>
<h2 id="多行变量"><a href="#多行变量" class="headerlink" title="多行变量"></a>多行变量</h2><p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过<code>命令包</code>的技术就是利用这个关键字）。</p>
<p>define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和<code>=</code>操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。</p>
<p>下面的这个示例展示了define的用法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define two-lines</span><br><span class="line"></span><br><span class="line">echo foo</span><br><span class="line"></span><br><span class="line">echo $(bar)</span><br><span class="line"></span><br><span class="line">endef</span><br></pre></td></tr></table></figure></p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了<code>-e</code>参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>
<p>因此，如果我们在环境变量中设置了<code>CFLAGS</code>环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像<code>全局变量</code>和<code>局部变量</code>的特性。当make嵌套调用时（参见前面的<code>嵌套调用</code>章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）</p>
<p>当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。</p>
<h2 id="目标变量"><a href="#目标变量" class="headerlink" title="目标变量"></a>目标变量</h2><p>前面我们所讲的在Makefile中定义的变量都是<code>全局变量</code>，在整个文件，我们都可以访问这些变量。当然，<code>自动化变量</code>除外，如<code>$&lt;</code>等这种类量的自动化变量就属于<code>规则型变量</code>，这种变量的值依赖于规则的目标和依赖目标的定义。</p>
<p>当然，我们同样可以为某个目标设置局部变量，这种变量被称为<code>Target-specific Variable</code>，它可以和<code>全局变量</code>同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<p>其语法是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;target...&gt; :&lt;variable-assignment&gt;</span><br><span class="line"></span><br><span class="line">&lt;target...&gt; :override&lt;variable-assignment&gt;</span><br></pre></td></tr></table></figure></p>
<p><variable-assignment>可以是前面讲过的各种赋值表达式，如<code>=</code>、<code>:=</code>、<code>+=</code>或是<code>？=</code>。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p>
<p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">prog:CFLAGS = -g</span><br><span class="line"></span><br><span class="line">prog:prog.o foo.o bar.o</span><br><span class="line"></span><br><span class="line">$(CC) $(CFLAGS) prog.ofoo.o bar.o</span><br><span class="line"></span><br><span class="line">prog.o:prog.c</span><br><span class="line"></span><br><span class="line">$(CC )$(CFLAGS) prog.c</span><br><span class="line"></span><br><span class="line">foo.o:foo.c</span><br><span class="line"></span><br><span class="line">$(CC) $(CFLAGS) foo.c</span><br><span class="line"></span><br><span class="line">bar.o:bar.c</span><br><span class="line"></span><br><span class="line">$(CC) $(CFLAGS) bar.c</span><br></pre></td></tr></table></figure><br>在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是<code>-g</code></p>
<h2 id="模式变量"><a href="#模式变量" class="headerlink" title="模式变量"></a>模式变量</h2><p>在GNU的make中，还支持模式变量（Pattern-specificVariable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种<code>模式</code>，可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道，make的<code>模式</code>一般是至少含有一个<code>%</code>的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%.o:CFLAGS =-O</span><br></pre></td></tr></table></figure><br>同样，模式变量的语法和<code>目标变量</code>一样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;pattern...&gt;:&lt;variable-assignment&gt;</span><br><span class="line"></span><br><span class="line">&lt;pattern...&gt;:override&lt;variable-assignment&gt;</span><br></pre></td></tr></table></figure><br>override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p>
<h1 id="使用条件判断"><a href="#使用条件判断" class="headerlink" title="使用条件判断"></a>使用条件判断</h1><p>使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面的例子，判断$(CC)变量是否<code>gcc</code>，如果是的话，则使用GNU函数编译目标。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">libs_for_gcc=-lgnu</span><br><span class="line"></span><br><span class="line">normal_libs=</span><br><span class="line"></span><br><span class="line">foo:$(objects)</span><br><span class="line"></span><br><span class="line">ifeq($(CC),gcc)</span><br><span class="line"></span><br><span class="line">$(CC) -o foo $(objects)$(libs_for_gcc)</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">$(CC) -o foo $(objects)$(normal_libs)</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><br>可见，在上面示例的这个规则中，目标<code>foo</code>可以根据变量<code>$(CC)</code>值来选取不同的函数库来编译程序。</p>
<p>我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。</p>
<p>当我们的变量$(CC)值是<code>gcc</code>时，目标foo的规则是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo:$(objects)</span><br><span class="line"></span><br><span class="line">$(CC) -o foo $(objects)$(libs_for_gcc)</span><br></pre></td></tr></table></figure><br>而当我们的变量$(CC)值不是<code>gcc</code>时（比如<code>cc</code>），目标foo的规则是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo:$(objects)</span><br><span class="line"></span><br><span class="line">$(CC) -o foo $(objects)$(normal_libs)</span><br></pre></td></tr></table></figure><br>当然，我们还可以把上面的那个例子写得更简洁一些：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">libs_for_gcc=-lgnu</span><br><span class="line"></span><br><span class="line">normal_libs=</span><br><span class="line"></span><br><span class="line">ifeq($(CC),gcc)</span><br><span class="line"></span><br><span class="line">libs=$(libs_for_gcc)</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">libs=$(normal_libs)</span><br><span class="line"></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">foo:$(objects)</span><br><span class="line"></span><br><span class="line">$(CC) -o foo $(objects)$(libs)</span><br></pre></td></tr></table></figure></p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>条件表达式的语法为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line"></span><br><span class="line">&lt;text-if-true&gt;</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><br>以及：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line"></span><br><span class="line">&lt;text-if-true&gt;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">&lt;text-if-false&gt;</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><br>其中<conditional-directive>表示条件关键字，如<code>ifeq</code>。这个关键字有四个。</p>
<p>第一个是我们前面所见过的<code>ifeq</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ifeq(&lt;arg1&gt;,&lt;arg2&gt;)</span><br><span class="line"></span><br><span class="line">ifeq&#x27;&lt;arg1&gt;&#x27;&#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"></span><br><span class="line">ifeq&quot;&lt;arg1&gt;&quot;&quot;&lt;arg2&gt;&quot;</span><br><span class="line"></span><br><span class="line">ifeq&quot;&lt;arg1&gt;&quot;&#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"></span><br><span class="line">ifeq&#x27;&lt;arg1&gt;&#x27;&quot;&lt;arg2&gt;&quot;</span><br></pre></td></tr></table></figure><br>比较参数<code>arg1</code>和<code>arg2</code>的值是否相同。当然，参数中我们还可以使用make的函数。如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifeq($(strip $(foo)),)</span><br><span class="line"></span><br><span class="line">&lt;text-if-empty&gt;</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><br>这个示例中使用了<code>strip</code>函数，如果这个函数的返回值是空（Empty），那么<text-if-empty>就生效。</p>
<p>第二个条件关键字是<code>ifneq</code>。语法是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ifneq(&lt;arg1&gt;,&lt;arg2&gt;)</span><br><span class="line"></span><br><span class="line">ifneq&#x27;&lt;arg1&gt;&#x27;&#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"></span><br><span class="line">ifneq&quot;&lt;arg1&gt;&quot;&quot;&lt;arg2&gt;&quot;</span><br><span class="line"></span><br><span class="line">ifneq&quot;&lt;arg1&gt;&quot;&#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"></span><br><span class="line">ifneq&#x27;&lt;arg1&gt;&#x27;&quot;&lt;arg2&gt;&quot;</span><br></pre></td></tr></table></figure><br>其比较参数<code>arg1</code>和<code>arg2</code>的值是否相同，如果不同，则为真。和<code>ifeq</code>类似。</p>
<p>第三个条件关键字是<code>ifdef</code>。语法是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifdef&lt;variable-name&gt;</span><br></pre></td></tr></table></figure><br>如果变量<variable-name>的值非空，那到表达式为真。否则，表达式为假。当然，<variable-name>同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：</p>
<p>示例一：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bar=</span><br><span class="line"></span><br><span class="line">foo=$(bar)</span><br><span class="line"></span><br><span class="line">ifdef foo</span><br><span class="line"></span><br><span class="line">frobozz=yes</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">frobozz=no</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><br>示例二：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo=</span><br><span class="line"></span><br><span class="line">ifdef foo</span><br><span class="line"></span><br><span class="line">frobozz=yes</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">frobozz=no</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><br>第一个例子中，<code>$(frobozz)</code>值是<code>yes</code>，第二个则是<code>no</code>。</p>
<p>第四个条件关键字是<code>ifndef</code>。其语法是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifndef&lt;variable-name&gt;</span><br></pre></td></tr></table></figure><br>这个我就不多说了，和<code>ifdef</code>是相反的意思。</p>
<p>在<code>&lt;conditional-directive&gt;</code>这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符<code>#</code>同样也是安全的。<code>else</code>和<code>endif</code>也一样，只要不是以[Tab]键开始就行了。</p>
<p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如<code>$@</code>等）放入条件表达式中，因为自动化变量是在运行时才有的。</p>
<p>而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p>
<h1 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h1><p>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</p>
<h2 id="函数的调用语法"><a href="#函数的调用语法" class="headerlink" title="函数的调用语法"></a>函数的调用语法</h2><p>函数调用，很像变量的使用，也是以<code>$</code>来标识的，其语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&lt;function&gt;&lt;arguments&gt;)</span><br></pre></td></tr></table></figure><br>或是<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;&lt;function&gt;&lt;arguments&gt;&#125;</span><br></pre></td></tr></table></figure><br>这里，<function>就是函数名，make支持的函数不多。<arguments>是函数的参数，参数间以逗号<code>,</code>分隔，而函数名和参数之间以<code>空格</code>分隔。函数调用以<code>$</code>开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用<code>$(substa,b,$(x))</code>这样的形式，而不是<code>$(substa,b,$&#123;x&#125;)</code>的形式。因为统一会更清楚，也会减少一些不必要的麻烦。</p>
<p>还是来看一个示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">comma:=,</span><br><span class="line"></span><br><span class="line">empty:=</span><br><span class="line"></span><br><span class="line">space:=$(empty)$(empty)</span><br><span class="line"></span><br><span class="line">foo:=a b c</span><br><span class="line"></span><br><span class="line">bar:=$(subst $(space),$(comma),$(foo))</span><br></pre></td></tr></table></figure><br>在这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是<code>abc</code>，$(bar)的定义用，调用了函数<code>subst</code>，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是<code>a,b,c</code>。</p>
<h2 id="字符串处理函数"><a href="#字符串处理函数" class="headerlink" title="字符串处理函数"></a>字符串处理函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</span><br></pre></td></tr></table></figure>
<p>名称：字符串替换函数——subst。</p>
<p>功能：把字串<text>中的<from>字符串替换成<to>。</p>
<p>返回：函数返回被替换过后的字符串。</p>
<p>示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(subst ee,EE,feetonthestreet)，</span><br></pre></td></tr></table></figure><br>把<code>feetonthestreet</code>中的<code>ee</code>替换成<code>EE</code>，返回结果是<code>fEEtonthestrEEt</code>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</span><br></pre></td></tr></table></figure><br>名称：模式字符串替换函数——patsubst。</p>
<p>功能：查找<code>&lt;text&gt;</code>中的单词（单词以<code>空格</code>、<code>Tab</code>或<code>回车``换行</code>分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。这里，<pattern>可以包括通配符<code>%</code>，表示任意长度的字串。如果<replacement>中也包含<code>%</code>，那么，<replacement>中的这个<code>%</code>将是<pattern>中的那个<code>%</code>所代表的字串。（可以用<code>\</code>来转义，以<code>\%</code>来表示真实含义的<code>%</code>字符）返回：函数返回被替换过后的字符串。</p>
<p>示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(patsubst %.c,%.o,x.c.cbar.c)</span><br></pre></td></tr></table></figure><br>把字串<code>x.c.c bar.c</code>符合模式[%.c]的单词替换成[%.o]，返回结果是<code>x.c.o bar.o</code></p>
<p>备注：</p>
<p>这和我们前面<code>变量章节</code>说过的相关知识有点相似。如：<br><code>$(var:&lt;pattern&gt;=&lt;replacement&gt;)</code></p>
<p>相当于<br><code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var))</code>，</p>
<p>而<br><code>$(var:&lt;suffix&gt;=&lt;replacement&gt;)</code></p>
<p>则相当于<br><code>$(patsubst %&lt;suffix&gt;,%&lt;replacement&gt;,$(var))</code>。</p>
<p>例如有：objects=foo.o bar.o baz.o，</p>
<p>那么，<code>$(objects:.o=.c)</code>和<code>$(patsubst %.o,%.c,$(objects))</code>是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(strip &lt;string&gt;)</span><br></pre></td></tr></table></figure>
<p>名称：去空格函数——strip。</p>
<p>功能：去掉<string>字串中开头和结尾的空字符。</p>
<p>返回：返回被去掉空格的字符串值。</p>
<p>示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(strip abc)</span><br></pre></td></tr></table></figure><br>把字串<code>abc</code>去到开头和结尾的空格，结果是<code>abc</code>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(findstring&lt;find&gt;,&lt;in&gt;)</span><br></pre></td></tr></table></figure><br>名称：查找字符串函数——findstring。</p>
<p>功能：在字串<in>中查找<find>字串。</p>
<p>返回：如果找到，那么返回<find>，否则返回空字符串。</p>
<p>示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(findstring a,a b c)</span><br><span class="line"></span><br><span class="line">$(findstring a,b c)</span><br></pre></td></tr></table></figure><br>第一个函数返回<code>a</code>字符串，第二个返回<code> </code>字符串（空字符串）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(filter &lt;pattern...&gt;,&lt;text&gt;)</span><br></pre></td></tr></table></figure>
<p>名称：过滤函数——filter。</p>
<p>功能：以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可以有多个模式。</p>
<p>返回：返回符合模式<pattern>的字串。</p>
<p>示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sources:=foo.c bar.c baz.sugh.h</span><br><span class="line"></span><br><span class="line">foo:$(sources)</span><br><span class="line"></span><br><span class="line">cc $(filter %.c %.s,$(sources))-o foo</span><br><span class="line"></span><br><span class="line">$(filter%.c%.s,$(sources))返回的值是`foo.c bar.c baz.s`。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(filter-out &lt;pattern...&gt;,&lt;text&gt;)</span><br></pre></td></tr></table></figure>
<p>名称：反过滤函数——filter-out。</p>
<p>功能：以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可以有多个模式。</p>
<p>返回：返回不符合模式<pattern>的字串。</p>
<p>示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objects=main1.o foo.omain2.o bar.o</span><br><span class="line"></span><br><span class="line">mains=main1.o main2.o</span><br><span class="line"></span><br><span class="line">$(filter-out $(mains),$(objects))返回值是`foo.o bar.o`。</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(sort &lt;list&gt;)</span><br></pre></td></tr></table></figure>
<p>名称：排序函数——sort。</p>
<p>功能：给字符串<list>中的单词排序（升序）。</p>
<p>返回：返回排序后的字符串。</p>
<p>示例：$(sort foobarlose)返回<code>barfoolose</code>。</p>
<p>备注：sort函数会去掉<list>中相同的单词。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(word &lt;n&gt;,&lt;text&gt;)</span><br></pre></td></tr></table></figure>
<p>名称：取单词函数——word。</p>
<p>功能：取字符串<text>中第<n>个单词。（从一开始）</p>
<p>返回：返回字符串<text>中第<n>个单词。如果<n>比<text>中的单词数要大，那么返回空字符串。</p>
<p>示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(word 2,foo bar baz)返回值是`bar`。</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(wordlist &lt;s&gt;,&lt;e&gt;,&lt;text&gt;)</span><br></pre></td></tr></table></figure><br>名称：取单词串函数——wordlist。</p>
<p>功能：从字符串<text>中取从<s>开始到<e>的单词串。<s>和<e>是一个数字。</p>
<p>返回：返回字符串<text>中从<s>到<e>的单词字串。如果<s>比<text>中的单词数要大，那</p>
<p>么返回空字符串。如果<e>大于<text>的单词数，那么返回从<s>开始，到<text>结束的单</p>
<p>词串。</p>
<p>示例：$(wordlist 2,3,foo bar baz)返回值是<code>bar baz</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(words &lt;text&gt;)</span><br></pre></td></tr></table></figure>
<p>名称：单词个数统计函数——words。</p>
<p>功能：统计<text>中字符串中的单词个数。</p>
<p>返回：返回<text>中的单词数。</p>
<p>示例：$(words,foo bar baz)返回值是<code>3</code>。</p>
<p>备注：如果我们要取<text>中最后的一个单词，我们可以这样：$(word $(words<text></p>
<p>),<text>)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(firstword &lt;text&gt;)</span><br></pre></td></tr></table></figure>
<p>名称：首单词函数——firstword。</p>
<p>功能：取字符串<text>中的第一个单词。</p>
<p>返回：返回字符串<text>的第一个单词。</p>
<p>示例：$(firstword foo bar)返回值是<code>foo</code>。</p>
<p>备注：这个函数可以用word函数来实现：$(word 1,<text>)。</p>
<p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用<code>VPATH</code>变量来指定<code>依赖文件</code>的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，如：</p>
<p>override CFLAGS +=$(patsubst%,-I%,$(subst:,,$(VPATH)))</p>
<p>如果我们的<code>$(VPATH)</code>值是<code>src:../headers</code>，那么<code>$(patsubst %,-I%,$(subst:,,$(VPATH)))</code>将返回<code>-Isrc-I../headers</code>，这正是cc或gcc搜索头文件路径的参数。</p>
<h2 id="文件名操作函数"><a href="#文件名操作函数" class="headerlink" title="文件名操作函数"></a>文件名操作函数</h2><p>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是</p>
<p>一系列的文件名来对待。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(dir &lt;names...&gt;)</span><br></pre></td></tr></table></figure><br>名称：取目录函数——dir。</p>
<p>功能：从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（<code>/</code>）之</p>
<p>前的部分。如果没有反斜杠，那么返回<code>./</code>。</p>
<p>返回：返回文件名序列<names>的目录部分。</p>
<p>示例：$(dir src/foo.chacks)返回值是<code>src/./</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(notdir &lt;names...&gt;)</span><br></pre></td></tr></table></figure>
<p>名称：取文件函数——notdir。</p>
<p>功能：从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠（<code>/</code>）之后的部分。</p>
<p>返回：返回文件名序列<names>的非目录部分。</p>
<p>示例：$(notdir src/foo.chacks)返回值是<code>foo.chacks</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(suffix&lt;names...&gt;)</span><br></pre></td></tr></table></figure>
<p>名称：取后缀函数——suffix。</p>
<p>功能：从文件名序列<names>中取出各个文件名的后缀。</p>
<p>返回：返回文件名序列<names>的后缀序列，如果文件没有后缀，则返回空字串。</p>
<p>示例：$(suffix src/foo.c src-1.0/bar.chacks)返回值是<code>.c.c</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(basename &lt;names...&gt;)</span><br></pre></td></tr></table></figure>
<p>名称：取前缀函数——basename。</p>
<p>功能：从文件名序列<names>中取出各个文件名的前缀部分。</p>
<p>返回：返回文件名序列<names>的前缀序列，如果文件没有前缀，则返回空字串。</p>
<p>示例：$(basename src/foo.c src-1.0/bar.chacks)返回值是<code>src/foo src-1.0/bar hacks</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(addsuffix &lt;suffix&gt;,&lt;names...&gt;)</span><br></pre></td></tr></table></figure>
<p>名称：加后缀函数——addsuffix。</p>
<p>功能：把后缀<suffix>加到<names>中的每个单词后面。</p>
<p>返回：返回加过后缀的文件名序列。</p>
<p>示例：$(addsuffix.c,foobar)返回值是<code>foo.c bar.c</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(addprefix &lt;prefix&gt;,&lt;names...&gt;)</span><br></pre></td></tr></table></figure>
<p>名称：加前缀函数——addprefix。</p>
<p>功能：把前缀<prefix>加到<names>中的每个单词后面。</p>
<p>返回：返回加过前缀的文件名序列。</p>
<p>示例：$(addprefix src/,foo bar)返回值是<code>src/foosrc/bar</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(join&lt;list1&gt;,&lt;list2&gt;)</span><br></pre></td></tr></table></figure>
<p>名称：连接函数——join。</p>
<p>功能：把<list2>中的单词对应地加到<list1>的单词后面。如果<list1>的单词个数要比<list2>的多，那么，<list1>中的多出来的单词将保持原样。如果<list2>的单词个数要比<list1>多，那么，<list2>多出来的单词将被复制到<list2>中。</p>
<p>返回：返回连接过后的字符串。</p>
<p>示例：$(join aaa bbb,111 222 333)返回值是<code>aaa111 bbb222 333</code>。</p>
<h2 id="foreach函数"><a href="#foreach函数" class="headerlink" title="foreach函数"></a>foreach函数</h2><p>foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(foreach&lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span><br></pre></td></tr></table></figure><br>这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p>
<p>所以，<var>最好是一个变量名，<list>可以是一个表达式，而<text>中一般会使用<var></p>
<p>这个参数来依次枚举<list>中的单词。举个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names:=a b c d</span><br><span class="line"></span><br><span class="line">files:=$(foreach n,$(names),$(n).o)</span><br></pre></td></tr></table></figure><br>上面的例子中，$(name)中的单词会被挨个取出，并存到变量<code>n</code>中，<code>$(n).o</code>每次根据<code>$(n)</code>计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(files)的值是<code>a.o b.o c.o d.o</code>。</p>
<p>注意，foreach中的<var>参数是一个临时的局部变量，foreach函数执行完后，参数<var>的变量将不在作用，其作用域只在foreach函数当中。</p>
<h2 id="if函数"><a href="#if函数" class="headerlink" title="if函数"></a>if函数</h2><p>if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(if&lt;condition&gt;,&lt;then-part&gt;)</span><br></pre></td></tr></table></figure><br>或是<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(if&lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</span><br></pre></td></tr></table></figure><br>可见，if函数可以包含<code>else</code>部分，或是不含。即if函数的参数可以是两个，也可以是三个。<condition>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part>会被计算。</p>
<p>而if函数的返回值是，如果<condition>为真（非空字符串），那个<then-part>会是整个函数的返回值，如果<condition>为假（空字符串），那么<else-part>会是整个函数的返回值，此时如果<else-part>没有被定义，那么，整个函数返回空字串。</p>
<p>所以，<then-part>和<else-part>只会有一个被计算。</p>
<h2 id="call函数"><a href="#call函数" class="headerlink" title="call函数"></a>call函数</h2><p>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</span><br></pre></td></tr></table></figure><br>当make执行这个函数时，<expression>参数中的变量，如$(1)，$(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而<expression>的返回值就是call函数的返回值。例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reverse=$(1) $(2)</span><br><span class="line"></span><br><span class="line">foo=$(call reverse,a,b)</span><br></pre></td></tr></table></figure><br>那么，foo的值就是<code>a b</code>。当然，参数的次序是可以自定义的，不一定是顺序的，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reverse=$(2) $(1)</span><br><span class="line"></span><br><span class="line">foo=$(call reverse,a,b)</span><br></pre></td></tr></table></figure><br>此时的foo的值就是<code>b a</code>。</p>
<h2 id="origin函数"><a href="#origin函数" class="headerlink" title="origin函数"></a>origin函数</h2><p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(origin &lt;variable&gt;)</span><br></pre></td></tr></table></figure><br>注意，<variable>是变量的名字，不应该是引用。所以你最好不要在<variable>中使用<code>$</code>字符。Origin函数会以其返回值来告诉你这个变量的<code>出生情况</code>，下面，是origin函</p>
<p>数的返回值:</p>
<p><code>undefined</code></p>
<p>如果<variable>从来没有定义过，origin函数返回这个值<code>undefined</code>。</p>
<p><code>default</code></p>
<p>如果<variable>是一个默认的定义，比如<code>CC</code>这个变量，这种变量我们将在后面讲述。</p>
<p><code>environment</code></p>
<p>如果<variable>是一个环境变量，并且当Makefile被执行时，<code>-e</code>参数没有被打开。</p>
<p><code>file</code></p>
<p>如果<variable>这个变量被定义在Makefile中。</p>
<p><code>command line</code></p>
<p>如果<variable>这个变量是被命令行定义的。</p>
<p><code>override</code></p>
<p>如果<variable>是被override指示符重新定义的。</p>
<p><code>automatic</code></p>
<p>如果<variable>是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</p>
<p>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量<code>bletch</code>，而我们的环境中也有一个环境变量<code>bletch</code>，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的Makefile中，我们可以这样写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ifdef bletch</span><br><span class="line"></span><br><span class="line">ifeq&quot;$(origin bletch)&quot;&quot;environment&quot;</span><br><span class="line"></span><br><span class="line">bletch=barf,gag,etc.</span><br><span class="line"></span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><br>当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p>
<h2 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h2><p>shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contents:=$(shell catfoo)</span><br><span class="line"></span><br><span class="line">files:=$(shell echo *.c)</span><br></pre></td></tr></table></figure><br>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
<h2 id="控制make的函数"><a href="#控制make的函数" class="headerlink" title="控制make的函数"></a>控制make的函数</h2><p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(error &lt;text...&gt;)</span><br></pre></td></tr></table></figure><br>产生一个致命的错误，<text...>是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：</p>
<p>示例一：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifdef ERROR_001</span><br><span class="line"></span><br><span class="line">$(error error is $(ERROR_001))</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><br>示例二：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ERR=$(error found an error!)</span><br><span class="line"></span><br><span class="line">.PHONY:err</span><br><span class="line"></span><br><span class="line">err:;$(ERR)</span><br></pre></td></tr></table></figure><br>示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(warning &lt;text...&gt;)</span><br></pre></td></tr></table></figure>
<p>这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</p>
<h1 id="make的运行"><a href="#make的运行" class="headerlink" title="make的运行"></a>make的运行</h1><p>一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。</p>
<h2 id="make的退出码"><a href="#make的退出码" class="headerlink" title="make的退出码"></a>make的退出码</h2><p>make命令执行后有三个退出码：</p>
<p>0——表示成功执行。</p>
<p>1——如果make运行时出现任何错误，其返回1。</p>
<p>2——如果你使用了make的<code>-q</code>选项，并且make使得一些目标不需要更新，那么返回2。</p>
<p>Make的相关参数我们会在后续章节中讲述。</p>
<h2 id="指定Makefile"><a href="#指定Makefile" class="headerlink" title="指定Makefile"></a>指定Makefile</h2><p>前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——<code>GNUmakefile</code>、<code>makefile</code>和<code>Makefile</code>。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。</p>
<p>当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的<code>-f</code>或是<code>--file</code>参数（<code>--makefile</code>参数也行）。例如，我们有个makefile的名字是<code>hchen.mk</code>，那么，我们可以这样来让make来执行这个文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make –f hchen.mk</span><br></pre></td></tr></table></figure><br>如果在make的命令行是，你不只一次地使用了<code>-f</code>参数，那么，所有指定的makefile将会被连在一起传递给make执行。</p>
<h2 id="指定目标"><a href="#指定目标" class="headerlink" title="指定目标"></a>指定目标</h2><p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的<code>make clean</code>形式）任何在makefile中的目标都可以被指定成终极目标，但是除了以<code>-</code>打头，或是包含了<code>=</code>的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。</p>
<p>有一个make的环境变量叫<code>MAKECMDGOALS</code>，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sources=foo.c bar.c</span><br><span class="line"></span><br><span class="line">ifneq ($(MAKECMDGOALS),clean)</span><br><span class="line"></span><br><span class="line">include $(sources:.c=.d)</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure><br>基于上面的这个例子，只要我们输入的命令不是<code>makeclean</code>，那么makefile会自动包含<code>foo.d</code>和<code>bar.d</code>这两个makefile。</p>
<p>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY:all</span><br><span class="line"></span><br><span class="line">all:prog1 prog2 prog3prog4</span><br></pre></td></tr></table></figure><br>从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——<code>prog1</code>，<code>prog2</code>，<code>prog3</code>和<code>prog4</code>，我们可以使用<code>make all</code>命令来编译所有的目标</p>
<p>（如果把all置成第一个目标，那么只需执行<code>make</code>），我们也可以使用<code>make prog2</code>来单独编译目标<code>prog2</code>。</p>
<p>即然make可以指定所有makefile中的目标，那么也包括<code>伪目标</code>，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p>
<p><code>all</code>这个伪目标是所有目标的目标，其功能一般是编译所有的目标。</p>
<p><code>clean</code>这个伪目标功能是删除所有被make创建的文件。</p>
<p><code>install</code>这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。</p>
<p><code>print</code>这个伪目标的功能是例出改变过的源文件。</p>
<p><code>tar</code>这个伪目标功能是把源程序打包备份。也就是一个tar文件。</p>
<p><code>dist</code>这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。</p>
<p><code>TAGS</code>这个伪目标功能是更新所有的目标，以备完整地重编译使用。</p>
<p><code>check</code>和<code>test</code>这两个伪目标一般用来测试makefile的流程。</p>
<p>当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。</p>
<h2 id="检查规则"><a href="#检查规则" class="headerlink" title="检查规则"></a>检查规则</h2><p>有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：</p>
<p><code>-n</code></p>
<p><code>--just-print</code></p>
<p><code>--dry-run</code></p>
<p><code>--recon</code></p>
<p>不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。</p>
<p><code>-t</code></p>
<p><code>--touch</code></p>
<p>这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</p>
<p><code>-q</code></p>
<p><code>--question</code></p>
<p>这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</p>
<p><code>-W &lt;file&gt;</code></p>
<p><code>--what-if=&lt;file&gt;</code></p>
<p><code>--assume-new=&lt;file&gt;</code></p>
<p><code>--new-file=&lt;file&gt;</code></p>
<p>这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和<code>-n</code>参数一同使用，来查看这个依赖文件所发生的规则命令。</p>
<p>另外一个很有意思的用法是结合<code>-p</code>和<code>-v</code>来输出makefile被执行时的信息（这个将在后面讲述）。</p>
<h2 id="make的参数"><a href="#make的参数" class="headerlink" title="make的参数"></a>make的参数</h2><p>下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。</p>
<p><code>-b</code></p>
<p><code>-m</code></p>
<p>这两个参数的作用是忽略和其它版本make的兼容性。</p>
<p><code>-B</code></p>
<p><code>--always-make</code></p>
<p>认为所有的目标都需要更新（重编译）。</p>
<p><code>-C &lt;dir&gt;</code></p>
<p><code>--directory=&lt;dir&gt;</code></p>
<p>指定读取makefile的目录。如果有多个<code>-C</code>参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：<code>make –C ~hchen/test–C prog</code>等价于<code>make –C ~hchen/test/prog</code>。</p>
<p><code>—debug[=&lt;options&gt;]</code></p>
<p>输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是<options>的取值：</p>
<p><code>a</code>——也就是all，输出所有的调试信息。（会非常的多）</p>
<p><code>b</code>——也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。</p>
<p><code>v</code>——也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。</p>
<p><code>i</code>——也就是implicit，输出所以的隐含规则。</p>
<p><code>j</code>——也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。</p>
<p><code>m</code>——也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。</p>
<p><code>-d</code>相当于<code>--debug=a</code>。</p>
<p><code>-e</code> <code>--environment-overrides</code> 指明环境变量的值覆盖makefile中定义的变量的值。</p>
<p><code>-f=&lt;file&gt;</code>、<code>--file=&lt;file&gt;</code>、<code>--makefile=&lt;file&gt;</code>指定需要执行的makefile。</p>
<p><code>-h</code>、<code>--help</code> 显示帮助信息。</p>
<p><code>-i</code>、<code>--ignore-errors</code> 在执行时忽略所有的错误。</p>
<p><code>-I&lt;dir&gt;</code>、<code>--include-dir=&lt;dir&gt;</code>指定一个被包含makefile的搜索目标。可以使用多个<code>-I</code>参数来指定多个目录。</p>
<p><code>-j[&lt;jobsnum&gt;]</code>、<code>--jobs[=&lt;jobsnum&gt;]</code>指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的<code>-j</code>参数，那么仅最后一个<code>-j</code>才是有效的。（注意这个参数在MS-DOS中是无用的）</p>
<p><code>-k</code>、<code>--keep-going</code>出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</p>
<p><code>-l&lt;load&gt;</code>、<code>--load-average[=&lt;load]</code>、<code>—max-load[=&lt;load&gt;]</code> 指定make运行命令的负载。</p>
<p><code>-n</code>、<code>--just-print</code>、<code>--dry-run</code>、<code>--recon</code> 仅输出执行过程中的命令序列，但并不执行。</p>
<p><code>-o&lt;file&gt;</code>、<code>--old-file=&lt;file&gt;</code>、<code>--assume-old=&lt;file&gt;</code>不重新生成的指定的<file>，即使这个目标的依赖文件新于它。</p>
<p><code>-p</code>、<code>--print-data-base</code>、输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用<code>make -q p</code>命令。如果你想查看执行makefile前的预设变量和规则，你可以使用<code>make–p–f/dev/null</code>。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。</p>
<p><code>-q</code>、<code>--question</code>不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。</p>
<p><code>-r</code>、<code>--no-builtin-rules</code>禁止make使用任何隐含规则。</p>
<p><code>-R</code>、<code>--no-builtin-variabes</code>禁止make使用任何作用于变量上的隐含规则。</p>
<p><code>-s</code>、<code>--silent</code>、<code>--quiet</code>在命令运行时不输出命令的输出。</p>
<p><code>-S</code>、<code>--no-keep-going</code>、<code>--stop</code>取消<code>-k</code>选项的作用。因为有些时候，make的选项是从环境变量<code>MAKEFLAGS</code>中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的<code>-k</code>选项失效。</p>
<p><code>-t</code>、<code>--touch</code>相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</p>
<p><code>-v</code>、<code>--version</code>输出make程序的版本、版权等关于make的信息。</p>
<p><code>-w</code>、<code>--print-directory</code>输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</p>
<p><code>--no-print-directory</code>禁止<code>-w</code>选项。</p>
<p><code>-W &lt;file&gt;</code>、<code>--what-if=&lt;file&gt;</code>、<code>--new-file=&lt;file&gt;</code>、<code>--assume-file=&lt;file&gt;</code>假定目标<file>需要更新，如果和<code>-n</code>选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有<code>-n</code>那么就像运行UNIX的<code>touch</code>命令一样，使得<file>的修改时间为当前时间。</p>
<p><code>--warn-undefined-variables</code>只要make发现有未定义的变量，那么就输出警告信息。</p>
<h1 id="隐含规则"><a href="#隐含规则" class="headerlink" title="隐含规则"></a>隐含规则</h1><p>在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o]文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的<code>隐含的</code>，早先约定了的，不需要我们再写出来的规则。</p>
<p><code>隐含规则</code>也就是一种惯例，make会按照这种<code>惯例</code>心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。</p>
<p><code>隐含规则</code>会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量<code>CFLAGS</code>可以控制编译时的编译器参数。</p>
<p>我们还可以通过<code>模式规则</code>的方式写下自己的隐含规则。用<code>后缀规则</code>来定义隐含规则会有许多的限制。使用<code>模式规则</code>会更回得智能和清楚，但<code>后缀规则</code>可以用来保证我们Makefile的兼容性。</p>
<p>我们了解了<code>隐含规则</code>，可以让其为我们更好的服务，也会让我们知道一些<code>约定俗成</code>了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候<code>隐含规则</code>也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。</p>
<h2 id="使用隐含规则"><a href="#使用隐含规则" class="headerlink" title="使用隐含规则"></a>使用隐含规则</h2><p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo:foo.o bar.o</span><br><span class="line"></span><br><span class="line">cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)</span><br></pre></td></tr></table></figure><br>我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的<code>隐含规则</code>功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。</p>
<p>make会在自己的<code>隐含规则</code>库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把[.o]的目标的依赖文件置成[.c]，并使用C的编译命令<code>cc –c $(CFLAGS)[.c]</code>来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo.o:foo.c</span><br><span class="line"></span><br><span class="line">cc –c foo.c$(CFLAGS)</span><br><span class="line"></span><br><span class="line">bar.o:bar.c</span><br><span class="line"></span><br><span class="line">cc –c bar.c $(CFLAGS)</span><br></pre></td></tr></table></figure><br>因为，这已经是<code>约定</code>好了的事了，make和我们约定好了用C编译器<code>cc</code>生成[.o]文件的规则，这就是隐含规则。</p>
<p>当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。</p>
<p>还有，在make的<code>隐含规则库</code>中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.o:foo.p</span><br></pre></td></tr></table></figure><br>依赖文件<code>foo.p</code>（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了<code>foo.c</code>文件，那么我们的隐含规则一样会生效，并会通过<code>foo.c</code>调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出<code>依赖规则</code>，而不写命令。</p>
<h2 id="隐含规则一览"><a href="#隐含规则一览" class="headerlink" title="隐含规则一览"></a>隐含规则一览</h2><p>这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数<code>-r</code>或<code>--no-builtin-rules</code>选项来取消所有的预设置的隐含规则。</p>
<p>当然，即使是我们指定了<code>-r</code>参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了<code>后缀规则</code>来定义的，所以，只要隐含规则中有<code>后缀列表</code>（也就一系统定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out,.a,.ln,.o,.c,.cc,.C,.p,.f,.F,.r,.y,.l,.s,.S,.mod,.sym,.def,.h,.info,.dvi,.tex,.texinfo,.texi,.txinfo,.w,.ch.web,.sh,.elc,.el。具体的细节，我们会在后面讲述。</p>
<p>还是先来看一看常用的隐含规则吧。</p>
<p>1、编译C程序的隐含规则。</p>
<p><code>&lt;n&gt;.o</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.c</code>，并且其生成命令是<code>$(CC)–c $(CPPFLAGS) $(CFLAGS)</code></p>
<p>2、编译C++程序的隐含规则。</p>
<p><code>&lt;n&gt;.o</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.cc</code>或是<code>&lt;n&gt;.C</code>，并且其生成命令是<code>$(CXX)–c $(CPPFLAGS) $(CFLAGS)</code>。（建议使用<code>.cc</code>作为C++源文件的后缀，而不是<code>.C</code>）</p>
<p>3、编译Pascal程序的隐含规则。</p>
<p><code>&lt;n&gt;.o</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.p</code>，并且其生成命令是<code>$(PC)–c $(PFLAGS)</code>。</p>
<p>4、编译Fortran/Ratfor程序的隐含规则。</p>
<p><code>&lt;n&gt;.o</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.r</code>或<code>&lt;n&gt;.F</code>或<code>&lt;n&gt;.f</code>，并且其生成命令是:</p>
<p><code>.f``$(FC)–c$(FFLAGS)</code></p>
<p><code>.F``$(FC)–c$(FFLAGS)$(CPPFLAGS)</code></p>
<p><code>.f``$(FC)–c$(FFLAGS)$(RFLAGS)</code></p>
<p>5、预处理Fortran/Ratfor程序的隐含规则。</p>
<p><code>&lt;n&gt;.f</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.r</code>或<code>&lt;n&gt;.F</code>。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：</p>
<p><code>.F``$(FC)–F $(CPPFLAGS) $(FFLAGS)</code></p>
<p><code>.r``$(FC)–F $(FFLAGS) $(RFLAGS)</code></p>
<p>6、编译Modula-2程序的隐含规则。</p>
<p><code>&lt;n&gt;.sym</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.def</code>，并且其生成命令是：<code>$(M2C) $(M2FLAGS)$(DEFFLAGS)</code>。<code>&lt;n.o&gt;</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.mod</code>，并且其生成命令是：<code>$(M2C) $(M2FLAGS) $(MODFLAGS)</code>。</p>
<p>7、汇编和汇编预处理的隐含规则。</p>
<p><code>&lt;n&gt;.o</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.s</code>，默认使用编译品<code>as</code>，并且其生成命令是：<code>$(AS) $(ASFLAGS)</code>。<code>&lt;n&gt;.s</code>的目标的依赖目标会自动推导为<code>&lt;n&gt;.S</code>，默认使用C预编译器<code>cpp</code>，并且其生成命令是：<code>$(AS)$(ASFLAGS)</code>。</p>
<p>8、链接Object文件的隐含规则。</p>
<p><code>&lt;n&gt;</code>目标依赖于<code>&lt;n&gt;.o</code>，通过运行C的编译器来运行链接程序生成（一般是<code>ld</code>），其生成命令是：<code>$(CC) $(LDFLAGS)&lt;n&gt;.o$(LOADLIBES) $(LDLIBS)</code>。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：</p>
<p>x:y.o z.o</p>
<p>并且<code>x.c</code>、<code>y.c</code>和<code>z.c</code>都存在时，隐含规则将执行如下命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cc -c x.c -o x.o</span><br><span class="line"></span><br><span class="line">cc -c y.c -o y.o</span><br><span class="line"></span><br><span class="line">cc -c z.c -o z.o</span><br><span class="line"></span><br><span class="line">cc x.o y.o z.o -o x</span><br><span class="line"></span><br><span class="line">rm -f x.o</span><br><span class="line"></span><br><span class="line">rm -f y.o</span><br><span class="line"></span><br><span class="line">rm -f z.o</span><br></pre></td></tr></table></figure><br>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
<p>9、Yacc C程序时的隐含规则。</p>
<p><code>&lt;n&gt;.c</code>的依赖文件被自动推导为<code>n.y</code>（Yacc生成的文件），其生成命令是：<code>$(YACC) $(YFALGS)</code>。（<code>Yacc</code>是一个语法分析器，关于其细节请查看相关资料）</p>
<p>10、LexC程序时的隐含规则。</p>
<p><code>&lt;n&gt;.c</code>的依赖文件被自动推导为<code>n.l</code>（Lex生成的文件），其生成命令是：<code>$(LEX)$(LFALGS)</code>。（关于<code>Lex</code>的细节请查看相关资料）</p>
<p>11、LexRatfor程序时的隐含规则。</p>
<p><code>&lt;n&gt;.r</code>的依赖文件被自动推导为<code>n.l</code>（Lex生成的文件），其生成命令是：<code>$(LEX)$(LFALGS)</code>。</p>
<p>12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。</p>
<p><code>&lt;n&gt;.ln</code>（lint生成的文件）的依赖文件被自动推导为<code>n.c</code>，其生成命令是：<code>$(LINT)$(LINTFALGS)$(CPPFLAGS)-i</code>。对于<code>&lt;n&gt;.y</code>和<code>&lt;n&gt;.l</code>也是同样的规则。</p>
<h2 id="隐含规则使用的变量"><a href="#隐含规则使用的变量" class="headerlink" title="隐含规则使用的变量"></a>隐含规则使用的变量</h2><p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的<code>-R</code>或<code>--no–builtin-variables</code>参数来取消你所定义的变量对隐含规则的作用。</p>
<p>例如，第一条隐含规则——编译C程序的隐含规则的命令是<code>$(CC)–c $(CFLAGS) $(CPPFLAGS)</code>。Make默认的编译命令是<code>cc</code>，如果你把变量<code>$(CC)</code>重定义成<code>gcc</code>，把变量<code>$(CFLAGS)</code>重定义成<code>-g</code>，那么，隐含规则中的命令全部会以<code>gcc–c-g $(CPPFLAGS)</code>的样子来执行了。</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如<code>CC</code>；一种是参数相的关，如<code>CFLAGS</code>。下面是所有隐含规则中会用到的变量：</p>
<p>1、关于命令的变量。<br>AR：函数库打包程序。默认命令是<code>ar</code>。</p>
<p>AS：汇编语言编译程序。默认命令是<code>as</code>。</p>
<p>CC：C语言编译程序。默认命令是<code>cc</code>。</p>
<p>CXX：C++语言编译程序。默认命令是<code>g++</code>。</p>
<p>CO：从RCS文件中扩展文件程序。默认命令是<code>co</code>。</p>
<p>CPP：C程序的预处理器（输出是标准输出设备）。默认命令是<code>$(CC)–E</code>。</p>
<p>FC：Fortran和Ratfor的编译器和预处理程序。默认命令是<code>f77</code>。</p>
<p>GET：从SCCS文件中扩展文件的程序。默认命令是<code>get</code>。</p>
<p>LEX：Lex方法分析器程序（针对于C或Ratfor）。默认命令是<code>lex</code>。</p>
<p>PC：Pascal语言编译程序。默认命令是<code>pc</code>。</p>
<p>YACC：Yacc文法分析器（针对于C程序）。默认命令是<code>yacc</code>。</p>
<p>YACCR：Yacc文法分析器（针对于Ratfor程序）。默认命令是<code>yacc–r</code>。</p>
<p>MAKEINFO：转换Texinfo源文件（.texi）到Info文件程序。默认命令是<code>makeinfo</code>。</p>
<p>TEX：从TeX源文件创建TeXDVI文件的程序。默认命令是<code>tex</code>。</p>
<p>TEXI2DVI：从Texinfo源文件创建军TeXDVI文件的程序。默认命令是<code>texi2dvi</code>。</p>
<p>WEAVE：转换Web到TeX的程序。默认命令是<code>weave</code>。</p>
<p>CWEAVE：转换CWeb到TeX的程序。默认命令是<code>cweave</code>。</p>
<p>TANGLE：转换Web到Pascal语言的程序。默认命令是<code>tangle</code>。</p>
<p>CTANGLE：转换CWeb到C。默认命令是<code>ctangle</code>。</p>
<p>RM：删除文件命令。默认命令是<code>rm –f</code>。</p>
<p>2、关于命令参数的变量<br>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p>
<p>ARFLAGS：函数库打包程序AR命令的参数。默认值是<code>rv</code>。</p>
<p>ASFLAGS：汇编语言编译器参数。（当明显地调用<code>.s</code>或<code>.S</code>文件时）。</p>
<p>CFLAGS：C语言编译器参数。</p>
<p>CXXFLAGS：C++语言编译器参数。</p>
<p>COFLAGS：RCS命令参数。</p>
<p>CPPFLAGS：C预处理器参数。（C和Fortran编译器也会用到）。</p>
<p>FFLAGS：Fortran语言编译器参数。</p>
<p>GFLAGS：SCCS<code>get</code>程序参数。</p>
<p>LDFLAGS：链接器参数。（如：<code>ld</code>）</p>
<p>LFLAGS：Lex文法分析器参数。</p>
<p>PFLAGS：Pascal语言编译器参数。</p>
<p>RFLAGS：Ratfor程序的Fortran编译器参数。</p>
<p>YFLAGS：Yacc文法分析器参数。</p>
<h2 id="隐含规则链"><a href="#隐含规则链" class="headerlink" title="隐含规则链"></a>隐含规则链</h2><p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做<code>隐含规则链</code>。</p>
<p>在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。</p>
<p>我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？</p>
<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以<code>rm-f</code>删除。</p>
<p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标<code>.INTERMEDIATE</code>来强制声明。（如：.INTERMEDIATE：mid）</p>
<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标<code>.SECONDARY</code>来强制声明（如：.SECONDARY:sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标<code>.PRECIOUS</code>的依赖目标，以保存被隐含规则所生成的中间文件。</p>
<p>在<code>隐含规则链</code>中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>
<p>Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件<code>foo.c</code>生成目标程序<code>foo</code>，按道理，make会编译生成中间文件<code>foo.o</code>，然后链接成<code>foo</code>，但在实际情况下，这一动作可以被一条<code>cc</code>的命令完成（cc–o foo foo.c），于是优化过的规则就不会生成中间文件。</p>
<h2 id="定义模式规则"><a href="#定义模式规则" class="headerlink" title="定义模式规则"></a>定义模式规则</h2><p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有”%”字符。”%”的意思是表示一个或多个任意字符。在依赖目标中同样可以使用”%”，只是依赖目标中的”%”的取值，取决于其目标。</p>
<p>有一点需要注意的是，”%”的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的”%”则发生在运行时。</p>
<p>1、模式规则介绍<br>模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。例如：”%.c”表示以”.c”结尾的文件名（文件名的长度至少为3），而”s.%.c”则表示以”s.”开头，”.c”结尾的文件名（文件名的长度至少为5）。</p>
<p>如果”%”定义在目标中，那么，目标中的”%”的值决定了依赖目标中的”%”的值，也就是说，目标中的模式的”%”决定了依赖目标中”%”的样子。例如有一个模式规则如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%.o:%.c;&lt;command......&gt;</span><br></pre></td></tr></table></figure><br>其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是”a.o b.o”，那么”%c”就是”a.c b.c”。</p>
<p>一旦依赖目标中的”%”模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。</p>
<p>2、模式规则示例<br>下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%.o:%.c</span><br><span class="line"></span><br><span class="line">$(CC)-c $(CFLAGS) $(CPPFLAGS)$&lt; -o $@</span><br></pre></td></tr></table></figure><br>其中，”$@”表示所有的目标的挨个值，”$&lt;”表示了所有依赖目标的挨个值。这些奇怪的变量我们叫”自动化变量”，后面会详细讲述。</p>
<p>下面的这个例子中有两个目标是模式的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%.tab.c %.tab.h:%.y</span><br><span class="line"></span><br><span class="line">bison -d $&lt;</span><br></pre></td></tr></table></figure><br>这条规则告诉make把所有的[.y]文件都以”bison -d <n>.y”执行，然后生成”<n>.tab.c”和”<n>.tab.h”文件。（其中，”<n>“表示一个任意字符串）。如果我们的执行程序”foo”依赖于文件”parse.tab.o”和”scan.o”，并且文件”scan.o”依赖于文件”parse.tab.h”，如果”parse.y”文件被更新了，那么根据上述的规则，”bison -d parse.y”就会被执行一次，于是，”parse.tab.o”和”scan.o”的依赖文件就齐了。（假设，”parse.tab.o”由”parse.tab.c”生成，和”scan.o”由”scan.c”生成，而”foo”由”parse.tab.o”和”scan.o”链接生成，而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）</p>
<p>3、自动化变量<br>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>
<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>
<p>下面是所有的自动化变量及其说明：</p>
<p><code>$@</code>表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，”$@”就是匹配于目标中模式定义的集合。</p>
<p><code>$%</code>仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是”foo.a(bar.o)”，那么，”$%”就是”bar.o”，”$@”就是”foo.a”。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。</p>
<p><code>$&lt;</code>依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么”$&lt;”将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p>
<p><code>$?</code>所有比目标新的依赖目标的集合。以空格分隔。</p>
<p><code>$^</code>所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</p>
<p><code>$+</code>这个变量很像”$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p>
<p><code>$*</code>这个变量表示目标模式中”%”及其之前的部分。如果目标是”dir/a.foo.b”，并且目标的模式是”a.%.b”，那么，<code>$*</code>的值就是”dir/a.foo”。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么<code>$*</code>也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么<code>$*</code>就是除了后缀的那一部分。例如：如果目标是”foo.c”，因为”.c”是make所能识别的后缀名，所以，<code>$*</code>的值就是”foo”。这个特性是GNUmake的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用<code>$*</code>，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么<code>$*</code>就是空值。</p>
<p>当你希望只对更新过的依赖文件进行操作时，<code>$?</code>在显式规则中很有用，例如，假设有一个函数库文件叫”lib”，其由其它几个object文件更新。那么把object文件打包的比较有效率的Makefile规则是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lib:foo.o bar.o lose.owin.o</span><br><span class="line"></span><br><span class="line">ar r lib $?</span><br></pre></td></tr></table></figure><br>在上述所列出来的自动量变量中。四个变量（<code>$@</code>、<code>$&lt;</code>、<code>$%</code>、<code>$*</code>）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上”D”或”F”字样。这是GNUmake中老版本的特性，在新版本中，我们使用函数”dir”或”notdir”就可以做到了。”D”的含义就是Directory，就是目录，”F”的含义就是File，就是文件。</p>
<p>下面是对于上面的七个变量分别加上”D”或是”F”的含义：</p>
<p><code>$(@D)</code>表示<code>$@</code>的目录部分（不以斜杠作为结尾），如果<code>$@</code>值是”dir/foo.o”，那么<code>$(@D)</code>就是”dir”，而如果<code>$@</code>中没有包含斜杠的话，其值就是”.”（当前目录）。</p>
<p><code>$(@F)</code>表示<code>$@</code>的文件部分，如果<code>$@</code>值是”dir/foo.o”，那么<code>$(@F)</code>就是”foo.o”，<code>$(@F)</code>相当于函数<code>$(notdir$@)</code>。</p>
<p><code>$(*D)</code>、<code>$(*F)</code>和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，<code>$(*D)</code>返回”dir”，而<code>$(*F)</code>返回”foo”</p>
<p><code>$(%D)</code>、<code>$(%F)</code>分别表示了函数包文件成员的目录部分和文件部分。这对于形同”archive(member)”形式的目标中的”member”中包含了不同的目录很有用。</p>
<p><code>$(&lt;D)</code>、<code>$(&lt;F)</code>分别表示依赖文件的目录部分和文件部分。</p>
<p><code>$(^D)</code>、<code>$(^F)</code>分别表示所有依赖文件的目录部分和文件部分。（无相同的）</p>
<p><code>$(+D)</code>、<code>$(+F)</code>分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</p>
<p><code>$(?D)</code>、<code>$(?F)</code>分别表示被更新的依赖文件的目录部分和文件部分。</p>
<p>最后想提醒一下的是，对于<code>$&lt;</code>，为了避免产生不必要的麻烦，我们最好给$后面的那个特定字符都加上圆括号，比如，<code>$(&lt;)</code>就要比<code>$&lt;</code>要好一些。</p>
<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是”显式规则”和”静态模式规则”（参见前面”书写规则”一章）。其在隐含规则中并没有意义。</p>
<p>4、模式的匹配<br>一般来说，一个目标的模式有一个有前缀或是后缀的”%”，或是没有前后缀，直接就是一个”%”。因为”%”代表一个或多个字符，所以在定义好了的模式中，我们把”%”所匹配的内容叫做”茎”，例如”%.c”所匹配的文件”test.c”中”test”就是”茎”。因为在目标和依赖目标中同时有”%”时，依赖目标的”茎”会传给目标，当做目标中的”茎”。</p>
<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行”茎”的传递时，我们需要知道这个步骤。例如有一个模式”e%t”，文件”src/eat”匹配于该模式，于是”src/a”就是其”茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式”c%r”，那么，目标就是”src/car”。（”茎”被传递）</p>
<p>5、重载内建隐含规则<br>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%.o:%.c</span><br><span class="line"></span><br><span class="line">$(CC) -c $(CPPFLAGS) $(CFLAGS)-D $(date)</span><br></pre></td></tr></table></figure><br>你可以取消内建的隐含规则，只要不在后面写命令就行。如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%.o:%.s</span><br></pre></td></tr></table></figure><br>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>
<p>6、老式风格的”后缀规则”<br>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNUmake同样兼容于这些东西。后缀规则有两种方式：”双后缀”和”单后缀”。</p>
<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如”.c.o”相当于”%o:%c”。单后缀规则只定义一个后缀，也就是源文件的后缀。如”.c”相当于”%:%.c”。</p>
<p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：”.c”和”.o”都是make所知道。因而，如果你定义了一个规则是”.c.o”那么其就是双后缀规则，意义就是”.c”是源文件的后缀，”.o”是目标文件的后缀。如下示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.c.o:</span><br><span class="line"></span><br><span class="line">$(CC) -c $(CFLAGS) $(CPPFLAGS)-o $@ $&lt;</span><br></pre></td></tr></table></figure><br>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.c.o:foo.h</span><br><span class="line"></span><br><span class="line">$(CC) -c $(CFLAGS) $(CPPFLAGS)-o $@ $&lt;</span><br></pre></td></tr></table></figure><br>这个例子，就是说，文件”.c.o”依赖于文件”foo.h”，而不是我们想要的这样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%.o:%.c foo.h</span><br><span class="line"></span><br><span class="line">$(CC) -c $(CFLAGS) $(CPPFLAGS)-o $@ $&lt;</span><br></pre></td></tr></table></figure><br>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</p>
<p>而要让make知道一些特定的后缀，我们可以使用伪目标”.SUFFIXES”来定义或是删除，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.SUFFIXES:.hack.win</span><br></pre></td></tr></table></figure><br>把后缀.hack和.win加入后缀列表中的末尾。</p>
<p>.SUFFIXES:#删除默认的后缀</p>
<p>.SUFFIXES:.c .o .h#定义自己的后缀</p>
<p>先清楚默认后缀，后定义自己的后缀列表。</p>
<p>make的参数”-r”或”-no-builtin-rules”也会使用得默认的后缀列表为空。而变量”SUFFIXE”被用来定义默认的后缀列表，你可以用”.SUFFIXES”来改变后缀列表，但请不要改变变量”SUFFIXE”的值。</p>
<p>7、隐含规则搜索算法<br>比如我们有一个目标叫T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是”archive(member)”的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把”member”当作T来搜索。</p>
<p>1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是”src/foo.o”，那么，D就是”src/“，N就是”foo.o”）</p>
<p>2、创建所有匹配于T或是N的模式规则列表。</p>
<p>3、如果在模式规则列表中有匹配所有文件的模式，如”%”，那么从列表中移除其它的模式。</p>
<p>4、移除列表中没有命令的规则。</p>
<p>5、对于第一个在列表中的模式规则：</p>
<p>1）推导其”茎”S，S应该是T或是N匹配于模式中”%”非空的部分。</p>
<p>2）计算依赖文件。把依赖文件中的”%”都替换成”茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。</p>
<p>3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫”理当存在”）</p>
<p>4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。</p>
<p>6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：</p>
<p>1）如果规则是终止规则，那就忽略它，继续下一条模式规则。</p>
<p>2）计算依赖文件。（同第5步）</p>
<p>3）测试所有的依赖文件是否存在或是理当存在。</p>
<p>4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。</p>
<p>5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。</p>
<p>7、如果没有隐含规则可以使用，查看”.DEFAULT”规则，如果有，采用，把”.DEFAULT”的命令给T使用。</p>
<p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p>
<h1 id="使用make更新函数库文件"><a href="#使用make更新函数库文件" class="headerlink" title="使用make更新函数库文件"></a>使用make更新函数库文件</h1><p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令”ar”来完成打包工作。</p>
<h2 id="函数库文件的成员"><a href="#函数库文件的成员" class="headerlink" title="函数库文件的成员"></a>函数库文件的成员</h2><p>一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archive(member)</span><br></pre></td></tr></table></figure><br>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了”ar”命令来服务的。如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foolib(hack.o):hack.o</span><br><span class="line"></span><br><span class="line">ar cr foolib hack.o</span><br></pre></td></tr></table></figure><br>如果要指定多个member，那就以空格分开，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foolib(hack.o kludge.o)</span><br></pre></td></tr></table></figure><br>其等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foolib(hack.o) foolib(kludge.o)</span><br></pre></td></tr></table></figure><br>你还可以使用Shell的文件通配符来定义，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foolib(*.o)</span><br></pre></td></tr></table></figure></p>
<h2 id="函数库成员的隐含规则"><a href="#函数库成员的隐含规则" class="headerlink" title="函数库成员的隐含规则"></a>函数库成员的隐含规则</h2><p>当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是”a(m)”形式的，其会把目标变成”(m)”。于是，如果我们的成员是”%.o”的模式定义，并且如果我们使用”make foo.a(bar.o)”的形式调用Makefile时，隐含规则会去找”bar.o”的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc-c bar.c -o bar.o</span><br><span class="line"></span><br><span class="line">ar r foo.abar.o</span><br><span class="line"></span><br><span class="line">rm -f bar.o</span><br></pre></td></tr></table></figure><br>还有一个变量要注意的是”$%”，这是专属函数库文件的自动化变量，有关其说明请参见”自动化变量”一节。</p>
<h2 id="函数库文件的后缀规则"><a href="#函数库文件的后缀规则" class="headerlink" title="函数库文件的后缀规则"></a>函数库文件的后缀规则</h2><p>你可以使用”后缀规则”和”隐含规则”来生成函数库打包文件，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.c.a:</span><br><span class="line"></span><br><span class="line">$(CC) $(CFLAGS) $(CPPFLAGS)-c $&lt; -o $*.o</span><br><span class="line"></span><br><span class="line">$(AR) r $@ $*.o</span><br><span class="line"></span><br><span class="line">$(RM) $*.o</span><br></pre></td></tr></table></figure><br>其等效于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(%.o):%.c</span><br><span class="line"></span><br><span class="line">$(CC) $(CFLAGS) $(CPPFLAGS)-c $&lt; -o $*.o</span><br><span class="line"></span><br><span class="line">$(AR) r $@ $*.o</span><br><span class="line"></span><br><span class="line">$(RM) $*.o</span><br></pre></td></tr></table></figure></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在进行函数库打包文件生成时，请小心使用make的并行机制（”-j”参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。但就目前而言，你还是应该不要尽量不要使用”-j”参数。</p>
<h1 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h1><p>终于到写结束语的时候了，以上基本上就是GNUmake的Makefile的所有细节了。其它的产商的make基本上也就是这样的，无论什么样的make，都是以文件的依赖性为基础的，其基本是都是遵循一个标准的。这篇文档中80%的技术细节都适用于任何的make，我猜测”函数”那一章的内容可能不是其它make所支持的，而隐含规则方面，我想不同的make会有不同的实现，我没有精力来查看GNU的make和VC的nmake、BCB的make，或是别的UNIX下的make有些什么样的差别，一是时间精力不够，二是因为我基本上都是在Unix下使用make，以前在SCOUnix和IBM的AIX，现在在Linux、Solaris、HP-UX、AIX和Alpha下使用，Linux和Solaris下更多一点。不过，我可以肯定的是，在Unix下的make，无论是哪种平台，几乎都使用了Richard Stallman开发的make和cc/gcc的编译器，而且，基本上都是GNU的make（公司里所有的UNIX机器上都被装上了GNU的东西，所以，使用GNU的程序也就多了一些）。GNU的东西还是很不错的，特别是使用得深了以后，越来越觉得GNU的软件的强大，也越来越觉得GNU的在操作系统中（主要是Unix，甚至Windows）”杀伤力”。</p>
<p>对于上述所有的make的细节，我们不但可以利用make这个工具来编译我们的程序，还可以利用make来完成其它的工作，因为规则中的命令可以是任何Shell之下的命令，所以，在Unix下，你不一定只是使用程序语言的编译器，你还可以在Makefile中书写其它的命令，如：tar、awk、mail、sed、cvs、compress、ls、rm、yacc、rpm、ftp……等等，等等，来完成诸如”程序打包”、”程序备份”、”制作程序安装包”、”提交代码”、”使用程序模板”、”合并文件”等等五花八门的功能，文件操作，文件管理，编程开发设计，或是其它一些异想天开的东西。比如，以前在书写银行交易程序时，由于银行的交易程序基本一样，就见到有人书写了一些交易的通用程序模板，在该模板中把一些网络通讯、数据库操作的、业务操作共性的东西写在一个文件中，在这些文件中用些诸如”@@@N、###N”奇怪字串标注一些位置，然后书写交易时，只需按照一种特定的规则书写特定的处理，最后在make时，使用awk和sed，把模板中的”@@@N、###N”等字串替代成特定的程序，形成C文件，然后再编译。这个动作很像数据库的”扩展C”语言（即在C语言中用”EXEC　SQL”的样子执行SQL语句，在用cc/gcc编译之前，需要使用”扩展C”的翻译程序，如cpre，把其翻译成标准C）。如果</p>
<p>你在使用make时有一些更为绝妙的方法，请记得告诉我啊。</p>
<p>回头看看整篇文档，不觉记起几年前刚刚开始在Unix下做开发的时候，有人问我会不会写Makefile时，我两眼发直，根本不知道在说什么。一开始看到别人在vi中写完程序后输入”!make”时，还以为是vi的功能，后来才知道有一个Makefile在作怪，于是上网查啊查，那时又不愿意看英文，发现就根本没有中文的文档介绍Makefile，只得看别人写的Makefile，自己瞎碰瞎搞才积累了一点知识，但在很多地方完全是知其然不知所以然。后来开始从事UNIX下产品软件的开发，看到一个400人年，近200万行代码的大工程，发现要编译这样一个庞然大物，如果没有Makefile，那会是多么恐怖的一样事啊。于是横下心来，狠命地读了一堆英文文档，才觉得对其掌握了。但发现目前网上对Makefile介绍的文章还是少得那么的可怜，所以想写这样一篇文章，共享给大家，希望能对各位有所帮助。</p>
<p>现在我终于写完了，看了看文件的创建时间，这篇技术文档也写了两个多月了。发现，自己知道是一回事，要写下来，跟别人讲述又是另外一回事，而且，现在越来越没有时间专研技术细节，所以在写作时，发现在阐述一些细节问题时很难做到严谨和精练，而且对先讲什么后讲什么不是很清楚，所以，还是参考了一些国外站点上的资料和题纲，以及一些技术书籍的语言风格，才得以完成。整篇文档的提纲是基于GNU的Makefile技术手册的提纲来书写的，并结合了自己的工作经验，以及自己的学习历程。因为从来没有写过这么长，这么细的文档，所以一定会有很多地方存在表达问题，语言歧义或是错误。因些，我迫切地得等待各位给我指证和建议，以及任何的反馈。</p>
<p>我欢迎任何形式的交流，无论是讨论技术还是管理，或是其它海阔天空的东西。除了政治和娱乐新闻我不关心，其它只要积极向上的东西我都欢迎！</p>
<p>最最后，我还想介绍一下make程序的设计开发者。</p>
<p>首当其冲的是：Richard Stallman</p>
<p>开源软件的领袖和先驱，从来没有领过一天工资，从来没有使用过Windows操作系统。对于他的事迹和他的软件以及他的思想，我无需说过多的话，相信大家对这个人并不比我陌生，这是他的主页：<a target="_blank" rel="noopener" href="http://www.stallman.org/。">http://www.stallman.org/。</a></p>
<p>第二位是：Roland McGrath</p>
<p>个人主页是：<a target="_blank" rel="noopener" href="http://www.frob.com/~roland/">http://www.frob.com/~roland/</a><br>下面是他的一些事迹：</p>
<p>1）合作编写了并维护GNUmake。</p>
<p>2）和ThomasBushnell一同编写了GNUHurd。</p>
<p>3）编写并维护着GNUClibrary。</p>
<p>4）合作编写并维护着部分的GNUEmacs。</p>
<p>在此，向这两位开源项目的斗士致以最真切的敬意</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/31/Leetcode201_300/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/31/Leetcode201_300/" itemprop="url">Leetcode201 - 300</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-31T15:21:00+08:00">
                2019-08-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Leetcode201-Bitwise-AND-of-Numbers-Range"><a href="#Leetcode201-Bitwise-AND-of-Numbers-Range" class="headerlink" title="Leetcode201. Bitwise AND of Numbers Range"></a>Leetcode201. Bitwise AND of Numbers Range</h1><p>Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: left = 5, right = 7</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: left = 0, right = 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: left = 1, right = 2147483647</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>我们先从题目中给的例子来分析，[5, 7]里共有三个数字，分别写出它们的二进制为：</p>
<p>101　　110　　111</p>
<p>相与后的结果为100，仔细观察我们可以得出，最后的数是该数字范围内所有的数的左边共同的部分，如果上面那个例子不太明显，我们再来看一个范围[26, 30]，它们的二进制如下：</p>
<p>11010　　11011　　11100　　11101　　11110</p>
<p>发现了规律后，我们只要写代码找到左边公共的部分即可，我们可以从建立一个32位都是1的mask，然后每次向左移一位，比较m和n是否相同，不同再继续左移一位，直至相同，然后把m和mask相与就是最终结果，代码如下：<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &gt; <span class="number">0</span> &amp;&amp; right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left == right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            left &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            right &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode202-Happy-Number"><a href="#Leetcode202-Happy-Number" class="headerlink" title="Leetcode202. Happy Number"></a>Leetcode202. Happy Number</h1><p>Write an algorithm to determine if a number n is “happy”.</p>
<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>
<p>Return True if n is a happy number, and False if not.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: 19</span><br><span class="line">Output: true</span><br><span class="line">Explanation: </span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></figure><br>简单直白的做法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cycle = <span class="number">100</span>, sum;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">while</span>(cycle--) &#123;</span><br><span class="line">            <span class="type">int</span> temp = n;</span><br><span class="line">            nums.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span>(temp) &#123;</span><br><span class="line">                nums.<span class="built_in">push_back</span>(temp%<span class="number">10</span>);</span><br><span class="line">                temp /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i : nums)</span><br><span class="line">                sum += i*i;</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>对于一个数n，如果n不是Happy Number，那么在求n各数位平方和以及求在n之后的每个数的各数位平方和的过程中，一定会产生循环，利用这个性质：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; thash;</span><br><span class="line">        <span class="keyword">while</span>(n &amp;&amp; !thash[n])&#123;</span><br><span class="line">            thash[n] = n;</span><br><span class="line">            <span class="type">int</span> temp = <span class="number">0</span>, low;</span><br><span class="line">            <span class="keyword">while</span>(n) &#123;</span><br><span class="line">                low = n % <span class="number">10</span>;</span><br><span class="line">                temp += low * low;</span><br><span class="line">                n /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode203-Remove-Linked-List-Elements"><a href="#Leetcode203-Remove-Linked-List-Elements" class="headerlink" title="Leetcode203. Remove Linked List Elements"></a>Leetcode203. Remove Linked List Elements</h1><p>Remove all elements from a linked list of integers that have value val.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><br>删除列表中对应val的节点<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *ptr = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *prev, *cur;</span><br><span class="line">        ptr-&gt;next = head;</span><br><span class="line">        cur = head;</span><br><span class="line">        prev = ptr;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val == val)</span><br><span class="line">                prev-&gt;next = cur-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        ListNode* a = head;</span><br><span class="line">        <span class="keyword">while</span>(a != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(a-&gt;val);</span><br><span class="line">            a = a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; y;</span><br><span class="line">        <span class="type">int</span> s = v.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i] != val) &#123;</span><br><span class="line">                y.<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(y.<span class="built_in">begin</span>(),y.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = y.<span class="built_in">size</span>();</span><br><span class="line">        ListNode* z = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* p = z;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(y.<span class="built_in">back</span>());</span><br><span class="line">            y.<span class="built_in">pop_back</span>();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode204-Count-Primes"><a href="#Leetcode204-Count-Primes" class="headerlink" title="Leetcode204. Count Primes"></a>Leetcode204. Count Primes</h1><p>Count the number of prime numbers less than a non-negative number, n.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.</span><br></pre></td></tr></table></figure><br>判断一定范围内有几个合数，下边这个简单的做法会超时<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isprimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n/<span class="number">2</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isprimes</span>(i))</span><br><span class="line">                sum ++;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>所以要用其他的方法，比如素数筛<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> nn = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        <span class="type">bool</span> prime[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            prime[i] = <span class="literal">true</span>;</span><br><span class="line">        prime[<span class="number">0</span>] = prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= nn; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i*<span class="number">2</span>; j &lt; n; j += i) &#123;</span><br><span class="line">                prime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prime[i])</span><br><span class="line">                sum ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode205-Isomorphic-Strings"><a href="#Leetcode205-Isomorphic-Strings" class="headerlink" title="Leetcode205. Isomorphic Strings"></a>Leetcode205. Isomorphic Strings</h1><p>Given two strings s and t, determine if they are isomorphic.</p>
<p>Two strings are isomorphic if the characters in s can be replaced to get t.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;egg&quot;, t = &quot;add&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;foo&quot;, t = &quot;bar&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;paper&quot;, t = &quot;title&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>这道题让我们求同构字符串，就是说原字符串中的每个字符可由另外一个字符替代，可以被其本身替代，相同的字符一定要被同一个字符替代，且一个字符不能被多个字符替代，即不能出现一对多的映射。根据一对一映射的特点，需要用两个 HashMap 分别来记录原字符串和目标字符串中字符出现情况，由于 ASCII 码只有 256 个字符，所以可以用一个 256 大小的数组来代替 HashMap，并初始化为0，遍历原字符串，分别从源字符串和目标字符串取出一个字符，然后分别在两个数组中查找其值，若不相等，则返回 false，若相等，将其值更新为 i + 1，因为默认的值是0，所以更新值为 i + 1，这样当 i=0 时，则映射为1，如果不加1的话，那么就无法区分是否更新了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m1[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, m2[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m1[s[i]] != m2[t[i]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            m1[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">            m2[t[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>另一种使用两个unorder_map<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIsomorphic</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ssize = s.<span class="built_in">size</span>(), tsize = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(ssize != tsize)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; mp, mp2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ssize; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(s[i]) == mp.<span class="built_in">end</span>())</span><br><span class="line">                mp[s[i]] = t[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mp[s[i]] != t[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp2.<span class="built_in">find</span>(t[i]) == mp2.<span class="built_in">end</span>())</span><br><span class="line">                mp2[t[i]] = s[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mp2[t[i]] != s[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode206-Reverse-Linked-List"><a href="#Leetcode206-Reverse-Linked-List" class="headerlink" title="Leetcode206. Reverse Linked List"></a>Leetcode206. Reverse Linked List</h1><p>Reverse a singly linked list.</p>
<p>Example:</p>
<p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p>假设存在链表 1 -&gt; 2 -&gt; 3 -&gt; NULL，我们想要把它改成 NULL &lt;- 1 &lt;- 2 &lt;- 3。</p>
<p>在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev,*next,*curr;</span><br><span class="line">        curr=head;</span><br><span class="line">        prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode207-Course-Schedule"><a href="#Leetcode207-Course-Schedule" class="headerlink" title="Leetcode207. Course Schedule"></a>Leetcode207. Course Schedule</h1><p>There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0. So it is possible.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of 2 courses to take. </span><br><span class="line">             To take course 1 you should have finished course 0, and to take course 0 you should</span><br><span class="line">             also have finished course 1. So it is impossible.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.</li>
<li>You may assume that there are no duplicate edges in the input prerequisites.</li>
<li>1 &lt;= numCourses &lt;= 10^5</li>
</ul>
<p>定义二维数组 graph 来表示这个有向图，一维数组 in 来表示每个顶点的入度。开始先根据输入来建立这个有向图，并将入度数组也初始化好。然后定义一个 queue 变量，将所有入度为0的点放入队列中，然后开始遍历队列，从 graph 里遍历其连接的点，每到达一个新节点，将其入度减一，如果此时该点入度为0，则放入队列末尾。直到遍历完队列中所有的值，若此时还有节点的入度不为0，则说明环存在，返回 false，反之则返回 true。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(numCourses, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> in[numCourses];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i ++)</span><br><span class="line">            in[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : prerequisites) &#123;</span><br><span class="line">            graph[i[<span class="number">1</span>]][i[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">            in[i[<span class="number">0</span>]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i ++)</span><br><span class="line">            <span class="keyword">if</span>(in[i] == <span class="number">0</span>)</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[temp][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                    in[i]--;</span><br><span class="line">                    <span class="keyword">if</span>(in[i] == <span class="number">0</span>)</span><br><span class="line">                        q.<span class="built_in">push</span>(i);   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i ++)</span><br><span class="line">            <span class="keyword">if</span>(in[i] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode208-Implement-Trie-Prefix-Tree"><a href="#Leetcode208-Implement-Trie-Prefix-Tree" class="headerlink" title="Leetcode208. Implement Trie (Prefix Tree)"></a>Leetcode208. Implement Trie (Prefix Tree)</h1><p>Implement a trie with insert, search, and startsWith methods.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // returns true</span><br><span class="line">trie.search(&quot;app&quot;);     // returns false</span><br><span class="line">trie.startsWith(&quot;app&quot;); // returns true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     // returns true</span><br></pre></td></tr></table></figure><br>Note:</p>
<p>You may assume that all inputs are consist of lowercase letters a-z.<br>All inputs are guaranteed to be non-empty strings.</p>
<p>实现一个字典树即可<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        Node *next[<span class="number">26</span>];</span><br><span class="line">        <span class="type">bool</span> isleaf;</span><br><span class="line">        <span class="built_in">Node</span>()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">                next[i]=<span class="literal">NULL</span>;</span><br><span class="line">            isleaf=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node* head;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* current = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> index = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;next[index]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                current-&gt;next[index] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            current = current-&gt;next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;isleaf = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* current = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> index = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;next[index]==<span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                current = current-&gt;next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> current-&gt;isleaf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Node* current = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prefix.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> index = prefix[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(current-&gt;next[index]==<span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                current = current-&gt;next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这个实现的内存占用有些高了，抄一下其他人的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// R links to node children</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode[] links;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> R = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> boolean isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        links = <span class="keyword">new</span> TrieNode[R];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">containsKey</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> links[ch -<span class="string">&#x27;a&#x27;</span>] != null;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">get</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> links[ch -<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">char</span> ch, TrieNode node)</span> </span>&#123;</span><br><span class="line">        links[ch -<span class="string">&#x27;a&#x27;</span>] = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Insertion of a key to a trie<br>We insert a key by searching into the trie. We start from the root and search a link, which corresponds to the first key character. There are two cases :</p>
<p>A link exists. Then we move down the tree following the link to the next child level. The algorithm continues with searching for the next key character.<br>A link does not exist. Then we create a new node and link it with the parent’s link matching the current key character. We repeat this step until we encounter the last character of the key, then we mark the current node as an end node and the algorithm finishes.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> currentChar = word.<span class="built_in">charAt</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.<span class="built_in">containsKey</span>(currentChar)) &#123;</span><br><span class="line">                node.<span class="built_in">put</span>(currentChar, <span class="keyword">new</span> <span class="built_in">TrieNode</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.<span class="built_in">get</span>(currentChar);</span><br><span class="line">        &#125;</span><br><span class="line">        node.<span class="built_in">setEnd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Search for a key in a trie<br>Each key is represented in the trie as a path from the root to the internal node or leaf. We start from the root with the first key character. We examine the current node for a link corresponding to the key character. There are two cases :</p>
<p>A link exist. We move to the next node in the path following this link, and proceed searching for the next key character.</p>
<p>A link does not exist. If there are no available key characters and current node is marked as isEnd we return true. Otherwise there are possible two cases in each of them we return false :</p>
<p>There are key characters left, but it is impossible to follow the key path in the trie, and the key is missing.<br>No key characters left, but current node is not marked as isEnd. Therefore the search key is only a prefix of another key in the trie.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// search a prefix or whole key in trie and</span></span><br><span class="line">    <span class="comment">// returns the node where search ends</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TrieNode <span class="title">searchPrefix</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">           <span class="type">char</span> curLetter = word.<span class="built_in">charAt</span>(i);</span><br><span class="line">           <span class="keyword">if</span> (node.<span class="built_in">containsKey</span>(curLetter)) &#123;</span><br><span class="line">               node = node.<span class="built_in">get</span>(curLetter);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> null;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">       TrieNode node = <span class="built_in">searchPrefix</span>(word);</span><br><span class="line">       <span class="keyword">return</span> node != null &amp;&amp; node.<span class="built_in">isEnd</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Search for a key prefix in a trie<br>The approach is very similar to the one we used for searching a key in a trie. We traverse the trie from the root, till there are no characters left in key prefix or it is impossible to continue the path in the trie with the current key character. The only difference with the mentioned above search for a key algorithm is that when we come to an end of the key prefix, we always return true. We don’t need to consider the isEnd mark of the current trie node, because we are searching for a prefix of a key, not for a whole key.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment">// that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = <span class="built_in">searchPrefix</span>(prefix);</span><br><span class="line">        <span class="keyword">return</span> node != null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode209-Minimum-Size-Subarray-Sum"><a href="#Leetcode209-Minimum-Size-Subarray-Sum" class="headerlink" title="Leetcode209. Minimum Size Subarray Sum"></a>Leetcode209. Minimum Size Subarray Sum</h1><p>Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray [numsl, numsl+1, …, numsr-1, numsr] of which the sum is greater than or equal to target. If there is no such subarray, return 0 instead.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The subarray [4,3] has the minimal length under the problem constraint.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 4, nums = [1,4,4]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>需要定义两个指针 left 和 right，分别记录子数组的左右的边界位置，然后让 right 向右移，直到子数组和大于等于给定值或者 right 达到数组末尾，此时更新最短距离，并且将 left 像右移一位，然后再 sum 中减去移去的值，然后重复上面的步骤，直到 right 到达末尾，且 left 到达临界位置，即要么到达边界，要么再往右移动，和就会小于给定值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, res = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">while</span>(right &lt; len &amp;&amp; sum &lt; target) &#123;</span><br><span class="line">                sum += nums[right++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, right-left);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode210-Course-Schedule-II"><a href="#Leetcode210-Course-Schedule-II" class="headerlink" title="Leetcode210. Course Schedule II"></a>Leetcode210. Course Schedule II</h1><p>There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.</p>
<p>For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.<br>Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">Output: [0,2,1,3]</span><br><span class="line">Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.</span><br><span class="line">So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: numCourses = 1, prerequisites = []</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure></p>
<p>这道题我们得找出要上的课程的顺序，即有向图的拓扑排序 Topological Sort，从 queue 中每取出一个数组就将其存在结果中，最终若有向图中有环，则结果中元素的个数不等于总课程数，那我们将结果清空即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">graph</span>(numCourses, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>));</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : prerequisites) &#123;</span><br><span class="line">            graph[a.second].<span class="built_in">push_back</span>(a.first);</span><br><span class="line">            ++in[a.first];</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(t);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : graph[t]) &#123;</span><br><span class="line">                --in[a];</span><br><span class="line">                <span class="keyword">if</span> (in[a] == <span class="number">0</span>) q.<span class="built_in">push</span>(a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() != numCourses) res.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode212-Word-Search-II"><a href="#Leetcode212-Word-Search-II" class="headerlink" title="Leetcode212.Word Search II"></a>Leetcode212.Word Search II</h1><p>Given an m x n board of characters and a list of strings words, return  all words on the board.</p>
<p>Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [[&quot;o&quot;,&quot;a&quot;,&quot;a&quot;,&quot;n&quot;],[&quot;e&quot;,&quot;t&quot;,&quot;a&quot;,&quot;e&quot;],[&quot;i&quot;,&quot;h&quot;,&quot;k&quot;,&quot;r&quot;],[&quot;i&quot;,&quot;f&quot;,&quot;l&quot;,&quot;v&quot;]], words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class="line">Output: [&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], words = [&quot;abcb&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>m == board.length</li>
<li>n == board[i].length</li>
<li>1 &lt;= m, n &lt;= 12</li>
<li>board[i][j] is a lowercase English letter.</li>
<li>1 &lt;= words.length &lt;= 3 * 104</li>
<li>1 &lt;= words[i].length &lt;= 10</li>
<li>words[i] consists of lowercase English letters.</li>
<li>All the strings of words are unique.</li>
</ul>
<p>这道题是在之前那道 Word Search 的基础上做了些拓展，之前是给一个单词让判断是否存在，现在是给了一堆单词，让返回所有存在的单词，在这道题最开始更新的几个小时内，用 brute force 是可以通过 OJ 的，就是在之前那题的基础上多加一个 for 循环而已，但是后来出题者其实是想考察字典树的应用，所以加了一个超大的 test case，以至于 brute force 无法通过，强制我们必须要用字典树来求解。LeetCode 中有关字典树的题还有 Implement Trie (Prefix Tree) 和 Add and Search Word - Data structure design，那么我们在这题中只要实现字典树中的 insert 功能就行了，查找单词和前缀就没有必要了，然后 DFS 的思路跟之前那道 Word Search 基本相同，请参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        TrieNode *child[<span class="number">26</span>];</span><br><span class="line">        string str;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        TrieNode *root;</span><br><span class="line">        <span class="built_in">Trie</span>() : <span class="built_in">root</span>(<span class="keyword">new</span> <span class="built_in">TrieNode</span>()) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">            TrieNode *p = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : s) &#123;</span><br><span class="line">                <span class="type">int</span> i = a - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (!p-&gt;child[i]) p-&gt;child[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">                p = p-&gt;child[i];</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;str = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findWords</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (words.<span class="built_in">empty</span>() || board.<span class="built_in">empty</span>() || board[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> res;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visit</span>(board.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(board[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        Trie T;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : words) T.<span class="built_in">insert</span>(a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; board[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (T.root-&gt;child[board[i][j] - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                    <span class="built_in">search</span>(board, T.root-&gt;child[board[i][j] - <span class="string">&#x27;a&#x27;</span>], i, j, visit, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, TrieNode* p, <span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visit, vector&lt;string&gt;&amp; res)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;str.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(p-&gt;str);</span><br><span class="line">            p-&gt;str.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> d[][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        visit[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : d) &#123;</span><br><span class="line">            <span class="type">int</span> nx = a[<span class="number">0</span>] + i, ny = a[<span class="number">1</span>] + j;</span><br><span class="line">            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; board.<span class="built_in">size</span>() &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; !visit[nx][ny] &amp;&amp; p-&gt;child[board[nx][ny] - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                <span class="built_in">search</span>(board, p-&gt;child[board[nx][ny] - <span class="string">&#x27;a&#x27;</span>], nx, ny, visit, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[i][j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode213-House-Robber-II"><a href="#Leetcode213-House-Robber-II" class="headerlink" title="Leetcode213. House Robber II"></a>Leetcode213. House Robber II</h1><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class="line">Total amount you can rob = 1 + 3 = 4.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [0]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>现在房子排成了一个圆圈，则如果抢了第一家，就不能抢最后一家，因为首尾相连了，所以第一家和最后一家只能抢其中的一家，或者都不抢，那这里变通一下，如果把第一家和最后一家分别去掉，各算一遍能抢的最大值，然后比较两个值取其中较大的一个即为所求。那只需参考之前的 House Robber 中的解题方法，然后调用两边取较大值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">robb</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>), <span class="built_in">robb</span>(nums, <span class="number">1</span>, nums.<span class="built_in">size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robb</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r-l &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[l];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(r, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        dp[l] = nums[l];</span><br><span class="line">        dp[l+<span class="number">1</span>] = <span class="built_in">max</span>(nums[l], nums[l+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l+<span class="number">2</span>; i &lt; r; i ++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[r<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当然，我们也可以使用两个变量来代替整个 DP 数组，讲解与之前的帖子 House Robber 相同，分别维护两个变量 robEven 和 robOdd，顾名思义，robEven 就是要抢偶数位置的房子，robOdd 就是要抢奇数位置的房子。所以在遍历房子数组时，如果是偶数位置，那么 robEven 就要加上当前数字，然后和 robOdd 比较，取较大的来更新 robEven。这里就看出来了，robEven 组成的值并不是只由偶数位置的数字，只是当前要抢偶数位置而已。同理，当奇数位置时，robOdd 加上当前数字和 robEven 比较，取较大值来更新 robOdd，这种按奇偶分别来更新的方法，可以保证组成最大和的数字不相邻，最后别忘了在 robEven 和 robOdd 种取较大值返回，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">empty</span>() ? <span class="number">0</span> : nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">rob</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>), <span class="built_in">rob</span>(nums, <span class="number">1</span>, nums.<span class="built_in">size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> robEven = <span class="number">0</span>, robOdd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt; right; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                robEven = <span class="built_in">max</span>(robEven + nums[i], robOdd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                robOdd = <span class="built_in">max</span>(robEven, robOdd + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(robEven, robOdd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode215-Kth-Largest-Element-in-an-Array"><a href="#Leetcode215-Kth-Largest-Element-in-an-Array" class="headerlink" title="Leetcode215. Kth Largest Element in an Array"></a>Leetcode215. Kth Largest Element in an Array</h1><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k = 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,3,1,2,4,5,5,6] and k = 4</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Note: You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<p>这道题让我们求数组中第k大的数字，怎么求呢，当然首先想到的是给数组排序，然后求可以得到第k大的数字。先看一种利用 C++ 的 STL 中的集成的排序方法，不用我们自己实现，这样的话这道题只要两行就完事了，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面这种解法是利用了 priority_queue 的自动排序的特性，跟上面的解法思路上没有什么区别，当然我们也可以换成 multiset 来做，一个道理，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这道题最好的解法应该是下面这种做法，用到了快速排序 Quick Sort 的思想，这里排序的方向是从大往小排。对快排不熟悉的童鞋们随意上网搜些帖子看下吧，多如牛毛啊，总有一款适合你。核心思想是每次都要先找一个中枢点 Pivot，然后遍历其他所有的数字，像这道题从大往小排的话，就把大于中枢点的数字放到左半边，把小于中枢点的放在右半边，这样中枢点是整个数组中第几大的数字就确定了，虽然左右两部分各自不一定是完全有序的，但是并不影响本题要求的结果，因为左半部分的所有值都大于右半部分的任意值，所以我们求出中枢点的位置，如果正好是 k-1，那么直接返回该位置上的数字；如果大于 k-1，说明要求的数字在左半部分，更新右边界，再求新的中枢点位置；反之则更新右半部分，求中枢点的位置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (pos == k - <span class="number">1</span>) <span class="keyword">return</span> nums[pos];</span><br><span class="line">            <span class="keyword">if</span> (pos &gt; k - <span class="number">1</span>) right = pos - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = pos + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pivot = nums[left], l = left + <span class="number">1</span>, r = right;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt; pivot &amp;&amp; nums[r] &gt; pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[l++], nums[r--]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &gt;= pivot) ++l;</span><br><span class="line">            <span class="keyword">if</span> (nums[r] &lt;= pivot) --r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[left], nums[r]);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode216-Combination-Sum-III"><a href="#Leetcode216-Combination-Sum-III" class="headerlink" title="Leetcode216. Combination Sum III"></a>Leetcode216. Combination Sum III</h1><p>Find all valid combinations of k numbers that sum up to n such that the following conditions are true:</p>
<ul>
<li>Only numbers 1 through 9 are used.</li>
<li>Each number is used at most once.</li>
</ul>
<p>Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: k = 3, n = 7</span><br><span class="line">Output: [[1,2,4]]</span><br><span class="line">Explanation:</span><br><span class="line">1 + 2 + 4 = 7</span><br><span class="line">There are no other valid combinations.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: k = 3, n = 9</span><br><span class="line">Output: [[1,2,6],[1,3,5],[2,3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">1 + 2 + 6 = 9</span><br><span class="line">1 + 3 + 5 = 9</span><br><span class="line">2 + 3 + 4 = 9</span><br><span class="line">There are no other valid combinations.</span><br></pre></td></tr></table></figure></p>
<p>n是k个数字之和，如果n小于0，则直接返回，如果n正好等于0，而且此时out中数字的个数正好为k，说明此时是一个正确解，将其存入结果res中，具体实现参见代码入下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; out;</span><br><span class="line">        <span class="built_in">combinationSum3DFS</span>(k, n, <span class="number">1</span>, out, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">combinationSum3DFS</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> level, vector&lt;<span class="type">int</span>&gt; &amp;out, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; out.<span class="built_in">size</span>() == k) res.<span class="built_in">push_back</span>(out);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = level; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            out.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">combinationSum3DFS</span>(k, n - i, i + <span class="number">1</span>, out, res);</span><br><span class="line">            out.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode217-Contains-Duplicate"><a href="#Leetcode217-Contains-Duplicate" class="headerlink" title="Leetcode217. Contains Duplicate"></a>Leetcode217. Contains Duplicate</h1><p>Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>构造一个set，不重复就加进去，重复返回true<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        s.<span class="built_in">insert</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">count</span>(nums[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                s.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>还有一个是排序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode218-The-Skyline-Problem"><a href="#Leetcode218-The-Skyline-Problem" class="headerlink" title="Leetcode218. The Skyline Problem"></a>Leetcode218. The Skyline Problem</h1><p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).</p>
<p>The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX, and Ri - Li &gt; 0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p>
<p>For instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ].</p>
<p>The output is a list of “key points” (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], … ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</p>
<p>For instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].</p>
<p>Notes:</p>
<ul>
<li>The number of buildings in any input list is guaranteed to be in the range [0, 10000].</li>
<li>The input list is already sorted in ascending order by the left x position Li.</li>
<li>The output list must be sorted by the x position.</li>
<li>There must be no consecutive horizontal lines of equal height in the output skyline. For instance, […[2 3], [4 5], [7 5], [11 5], [12 7]…] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: […[2 3], [4 5], [12 7], …]</li>
</ul>
<p>这里用到了 multiset 数据结构，其好处在于其中的元素是按堆排好序的，插入新元素进去还是有序的，而且执行删除元素也可方便的将元素删掉。这里为了区分左右边界，将左边界的高度存为负数，建立左边界和负高度的 pair，再建立右边界和高度的 pair，存入数组中，都存进去了以后，给数组按照左边界排序，这样就可以按顺序来处理那些关键的节点了。在 multiset 中放入一个0，这样在某个没有和其他建筑重叠的右边界上，就可以将封闭点存入结果 res 中。下面按顺序遍历这些关键节点，如果遇到高度为负值的 pair，说明是左边界，那么将正高度加入 multiset 中，然后取出此时集合中最高的高度，即最后一个数字，然后看是否跟 pre 相同，这里的 pre 是上一个状态的高度，初始化为0，所以第一个左边界的高度绝对不为0，所以肯定会存入结果 res 中。接下来如果碰到了一个更高的楼的左边界的话，新高度存入 multiset 的话会排在最后面，那么此时 cur 取来也跟 pre 不同，可以将新的左边界点加入结果 res。第三个点遇到绿色建筑的左边界点时，由于其高度低于红色的楼，所以 cur 取出来还是红色楼的高度，跟 pre 相同，直接跳过。下面遇到红色楼的右边界，此时首先将红色楼的高度从 multiset 中删除，那么此时 cur 取出的绿色楼的高度就是最高啦，跟 pre 不同，则可以将红楼的右边界横坐标和绿楼的高度组成 pair 加到结果 res 中，这样就成功的找到我们需要的拐点啦，后面都是这样类似的情况。当某个右边界点没有跟任何楼重叠的话，删掉当前的高度，那么 multiset 中就只剩0了，所以跟当前的右边界横坐标组成pair就是封闭点啦，具体实现参看代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">getSkyline</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; buildings) &#123;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; h, res;</span><br><span class="line">        multiset&lt;<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : buildings) &#123;</span><br><span class="line">            h.<span class="built_in">push_back</span>(&#123;a[<span class="number">0</span>], -a[<span class="number">2</span>]&#125;);</span><br><span class="line">           h.<span class="built_in">push_back</span>(&#123;a[<span class="number">1</span>], a[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(h.<span class="built_in">begin</span>(), h.<span class="built_in">end</span>());</span><br><span class="line">        m.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : h) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.second &lt; <span class="number">0</span>) m.<span class="built_in">insert</span>(-a.second);</span><br><span class="line">            <span class="keyword">else</span> m.<span class="built_in">erase</span>(m.<span class="built_in">find</span>(a.second));</span><br><span class="line">            cur = *m.<span class="built_in">rbegin</span>();</span><br><span class="line">            <span class="keyword">if</span> (cur != pre) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;a.first, cur&#125;);</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode219-Contains-Duplicate-II"><a href="#Leetcode219-Contains-Duplicate-II" class="headerlink" title="Leetcode219. Contains Duplicate II"></a>Leetcode219. Contains Duplicate II</h1><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1], k = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,0,1,1], k = 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,1,2,3], k = 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(nums[i]) == mp.<span class="built_in">end</span>()) </span><br><span class="line">                mp[nums[i]] = i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i - mp[nums[i]] &lt;= k)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                mp[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode221-Maximal-Square"><a href="#Leetcode221-Maximal-Square" class="headerlink" title="Leetcode221. Maximal Square"></a>Leetcode221. Maximal Square</h1><p>Given an m x n binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[&quot;0&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[&quot;0&quot;]]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>类似85题，注意是正方形。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> width = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (width == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> height = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(width, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(height, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; width; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; height; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = j == <span class="number">0</span> ? <span class="number">1</span> : dp[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> length = dp[i][j];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = i; k &gt;= <span class="number">0</span>; k --) &#123;</span><br><span class="line">                        length = <span class="built_in">min</span>(length, dp[k][j]);</span><br><span class="line">                        <span class="keyword">if</span> ((i-k+<span class="number">1</span>) == length)</span><br><span class="line">                            res = <span class="built_in">max</span>(res, (i-k+<span class="number">1</span>)*length);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>来个效率高的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> width = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (width == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> height = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(width, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(height, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; width; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; height; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode222-Count-Complete-Tree-Nodes"><a href="#Leetcode222-Count-Complete-Tree-Nodes" class="headerlink" title="Leetcode222. Count Complete Tree Nodes"></a>Leetcode222. Count Complete Tree Nodes</h1><p>Given the root of a complete binary tree, return the number of the nodes in the tree.</p>
<p>According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<p>Design an algorithm that runs in less than O(n) time complexity.</p>
<p>这道题给定了一棵完全二叉树，让我们求其节点的个数。最暴力的解法就是直接用递归来统计结点的个数，根本不需要考虑什么完全二叉树还是完美二叉树，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root ? (<span class="number">1</span> + <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right)) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>完美二叉树一定是完全二叉树，而完全二叉树不一定是完美二叉树。那么这道题给的完全二叉树就有可能是完美二叉树，若是完美二叉树，节点个数很好求，为2的h次方减1，h为该完美二叉树的高度。若不是的话，只能老老实实的一个一个数结点了。思路是由 root 根结点往下，分别找最靠左边和最靠右边的路径长度，如果长度相等，则证明二叉树最后一层节点是满的，是满二叉树，直接返回节点个数，如果不相等，则节点个数为左子树的节点个数加上右子树的节点个数再加1(根节点)，其中左右子树节点个数的计算可以使用递归来计算。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hLeft = <span class="number">0</span>, hRight = <span class="number">0</span>;</span><br><span class="line">        TreeNode *pLeft = root, *pRight = root;</span><br><span class="line">        <span class="keyword">while</span> (pLeft) &#123;</span><br><span class="line">            ++hLeft;</span><br><span class="line">            pLeft = pLeft-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pRight) &#123;</span><br><span class="line">            ++hRight;</span><br><span class="line">            pRight = pRight-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hLeft == hRight) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, hLeft) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode223-Rectangle-Area"><a href="#Leetcode223-Rectangle-Area" class="headerlink" title="Leetcode223. Rectangle Area"></a>Leetcode223. Rectangle Area</h1><p>Find the total area covered by two rectilinearrectangles in a 2D plane.</p>
<p>Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2</span><br><span class="line">Output: 45</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<p>Assume that the total area is never beyond the maximum possible value of int.</p>
<p>尝试先找出所有的不相交的情况，只有四种，一个矩形在另一个的上下左右四个位置不重叠，这四种情况下返回两个矩形面积之和。其他所有情况下两个矩形是有交集的，这时候只要算出长和宽，即可求出交集区域的大小，然后从两个矩型面积之和中减去交集面积就是最终答案。求交集区域的长和宽也不难，由于交集都是在中间，所以横边的左端点是两个矩形左顶点横坐标的较大值，右端点是两个矩形右顶点的较小值，同理，竖边的下端点是两个矩形下顶点纵坐标的较大值，上端点是两个矩形上顶点纵坐标的较小值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">computeArea</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B, <span class="type">int</span> C, <span class="type">int</span> D, <span class="type">int</span> E, <span class="type">int</span> F, <span class="type">int</span> G, <span class="type">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum1 = (C - A) * (D - B), sum2 = (H - F) * (G - E);</span><br><span class="line">        <span class="keyword">if</span> (E &gt;= C || F &gt;= D || B &gt;= H || A &gt;= G) <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">        <span class="keyword">return</span> sum1 - ((<span class="built_in">min</span>(G, C) - <span class="built_in">max</span>(A, E)) * (<span class="built_in">min</span>(D, H) - <span class="built_in">max</span>(B, F))) + sum2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我自己的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">computeArea</span><span class="params">(<span class="type">int</span> ax1, <span class="type">int</span> ay1, <span class="type">int</span> ax2, <span class="type">int</span> ay2, <span class="type">int</span> bx1, <span class="type">int</span> by1, <span class="type">int</span> bx2, <span class="type">int</span> by2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> inter_x1 = <span class="built_in">max</span>(ax1, bx1);</span><br><span class="line">        <span class="type">int</span> inter_x2 = <span class="built_in">min</span>(ax2, bx2);</span><br><span class="line">        <span class="type">int</span> inter_y1 = <span class="built_in">max</span>(ay1, by1);</span><br><span class="line">        <span class="type">int</span> inter_y2 = <span class="built_in">min</span>(ay2, by2);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> total_area = (ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1);</span><br><span class="line">        <span class="keyword">if</span> (bx1 &gt; ax2 || by2 &lt; ay1 || bx2 &lt; ax1 || by1 &gt; ay2)</span><br><span class="line">            <span class="keyword">return</span> total_area;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> total_area - (inter_x2-inter_x1)*(inter_y2-inter_y1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode224-Basic-Calculator"><a href="#Leetcode224-Basic-Calculator" class="headerlink" title="Leetcode224. Basic Calculator"></a>Leetcode224. Basic Calculator</h1><p>Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.</p>
<p>Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;1 + 1&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot; 2-1 + 2 &quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= s.length &lt;= 3 * 105</li>
<li>s consists of digits, ‘+’, ‘-‘, ‘(‘, ‘)’, and ‘ ‘.</li>
<li>s represents a valid expression.</li>
<li>‘+’ is not used as a unary operation (i.e., “+1” and “+(2 + 3)” is invalid).</li>
<li>‘-‘ could be used as a unary operation (i.e., “-1” and “-(2 + 3)” is valid).</li>
<li>There will be no two consecutive operators in the input.</li>
<li>Every number and running calculation will fit in a signed 32-bit integer.</li>
</ul>
<p>这道题让我们实现一个基本的计算器来计算简单的算数表达式，而且题目限制了表达式中只有加减号，数字，括号和空格，没有乘除，那么就没啥计算的优先级之分了。于是这道题就变的没有那么复杂了。我们需要一个栈来辅助计算，用个变量sign来表示当前的符号，我们遍历给定的字符串s，如果遇到了数字，由于可能是个多位数，所以我们要用while循环把之后的数字都读进来，然后用sign*num来更新结果res；如果遇到了加号，则sign赋为1，如果遇到了符号，则赋为-1；如果遇到了左括号，则把当前结果res和符号sign压入栈，res重置为0，sign重置为1；如果遇到了右括号，结果res乘以栈顶的符号，栈顶元素出栈，结果res加上栈顶的数字，栈顶元素出栈。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, len = s.<span class="built_in">length</span>();</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(op);</span><br><span class="line">                i ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                i ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                op = <span class="number">1</span> * st.<span class="built_in">top</span>();</span><br><span class="line">                i ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                op = <span class="number">-1</span> * st.<span class="built_in">top</span>();</span><br><span class="line">                i ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; len &amp;&amp; <span class="string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    val = val * <span class="number">10</span> + s[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                res += (op * val);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Leetcode225-Implement-Stack-using-Queues"><a href="#Leetcode225-Implement-Stack-using-Queues" class="headerlink" title="Leetcode225. Implement Stack using Queues"></a>Leetcode225. Implement Stack using Queues</h1><p>Implement the following operations of a stack using queues.</p>
<ul>
<li>push(x) — Push element x onto stack.</li>
<li>pop() — Removes the element on top of the stack.</li>
<li>top() — Get the top element.</li>
<li>empty() — Return whether the stack is empty.</li>
</ul>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyStack stack = new MyStack();</span><br><span class="line"></span><br><span class="line">stack.push(1);</span><br><span class="line">stack.push(2);  </span><br><span class="line">stack.top();   // returns 2</span><br><span class="line">stack.pop();   // returns 2</span><br><span class="line">stack.empty(); // returns false</span><br></pre></td></tr></table></figure><br>Notes:</p>
<ul>
<li>You must use only standard operations of a queue — which means only push to back, peek/pop from front, size, and is empty operations are valid.</li>
<li>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.</li>
<li>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="type">int</span> temp = que.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(temp &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> xx = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            que.<span class="built_in">push</span>(xx);</span><br><span class="line">            temp --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tt = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> tt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode226-Invert-Binary-Tree"><a href="#Leetcode226-Invert-Binary-Tree" class="headerlink" title="Leetcode226. Invert Binary Tree"></a>Leetcode226. Invert Binary Tree</h1><p>Invert a binary tree.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode227-Basic-Calculator-II"><a href="#Leetcode227-Basic-Calculator-II" class="headerlink" title="Leetcode227. Basic Calculator II"></a>Leetcode227. Basic Calculator II</h1><p>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string contains only non-negativeintegers, +, -, *, / operators and empty spaces ``. The integer division should truncate toward zero.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;3+2*2&quot;</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot; 3/2 &quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot; 3+5 / 2 &quot;</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>You may assume that the given expression is always valid.</li>
<li>Do not use the eval built-in library function.</li>
</ul>
<p>这道题是之前那道 Basic Calculator 的拓展，不同之处在于那道题的计算符号只有加和减，而这题加上了乘除，那么就牵扯到了运算优先级的问题，好在这道题去掉了括号，还适当的降低了难度，估计再出一道的话就该加上括号了。不管那么多，这道题先按木有有括号来处理，由于存在运算优先级，我们采取的措施是使用一个栈保存数字，如果该数字之前的符号是加或减，那么把当前数字压入栈中，注意如果是减号，则加入当前数字的相反数，因为减法相当于加上一个相反数。如果之前的符号是乘或除，那么从栈顶取出一个数字和当前数字进行乘或除的运算，再把结果压入栈中，那么完成一遍遍历后，所有的乘或除都运算完了，再把栈中所有的数字都加起来就是最终结果了，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> res = <span class="number">0</span>, num = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">char</span> op = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s[i] &lt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) st.<span class="built_in">push</span>(num);</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="string">&#x27;-&#x27;</span>) st.<span class="built_in">push</span>(-num);</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span> || op == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> tmp = (op == <span class="string">&#x27;*&#x27;</span>) ? st.<span class="built_in">top</span>() * num : st.<span class="built_in">top</span>() / num;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    st.<span class="built_in">push</span>(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                op = s[i];</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res += st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> res = <span class="number">0</span>, curRes = <span class="number">0</span>, num = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">char</span> op = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;*&#x27;</span> || c == <span class="string">&#x27;/&#x27;</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: curRes += num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: curRes -= num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: curRes *= num; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: curRes /= num; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    res += curRes;</span><br><span class="line">                    curRes = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                op = c;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>, last_val;</span><br><span class="line">        <span class="type">char</span> op = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; len &amp;&amp; <span class="string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">                    val = val* <span class="number">10</span> + s[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                    res += val;</span><br><span class="line">                    last_val = val;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    res -= val;</span><br><span class="line">                    last_val = -val;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    res = res - last_val + last_val * val;</span><br><span class="line">                    last_val = last_val * val;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    res = res - last_val + last_val / val;</span><br><span class="line">                    last_val = last_val / val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                op = s[i];</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode228-Summary-Ranges"><a href="#Leetcode228-Summary-Ranges" class="headerlink" title="Leetcode228. Summary Ranges"></a>Leetcode228. Summary Ranges</h1><p>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:  [0,1,2,4,5,7]</span><br><span class="line">Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:  [0,2,3,4,6,8,9]</span><br><span class="line">Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.</span><br></pre></td></tr></table></figure></p>
<p>这道题给定我们一个有序数组，让我们总结区间，具体来说就是让我们找出连续的序列，然后首尾两个数字之间用个“-&gt;”来连接，那么我只需遍历一遍数组即可，每次检查下一个数是不是递增的，如果是，则继续往下遍历，如果不是了，我们还要判断此时是一个数还是一个序列，一个数直接存入结果，序列的话要存入首尾数字和箭头“-&gt;”。我们需要两个变量i和j，其中i是连续序列起始数字的位置，j是连续数列的长度，当j为1时，说明只有一个数字，若大于1，则是一个连续序列。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i + j &lt; n &amp;&amp; (<span class="type">long</span>)nums[i + j] - nums[i] == j) ++j;</span><br><span class="line">            res.<span class="built_in">push_back</span>(j &lt;= <span class="number">1</span> ? <span class="built_in">to_string</span>(nums[i]) : <span class="built_in">to_string</span>(nums[i]) + <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(nums[i + j - <span class="number">1</span>]));</span><br><span class="line">            i += j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode229-Majority-Element-II"><a href="#Leetcode229-Majority-Element-II" class="headerlink" title="Leetcode229. Majority Element II"></a>Leetcode229. Majority Element II</h1><p>Given an integer array of size  n , find all elements that appear more than ⌊ n/3 ⌋ times.</p>
<p>Note: The algorithm should run in linear time and in O(1) space.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,3]</span><br><span class="line">Output: [3]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1,3,3,2,2,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们求出现次数大于 n/3 的数字，而且限定了时间和空间复杂度，那么就不能排序，也不能使用 HashMap，这么苛刻的限制条件只有一种方法能解了，那就是摩尔投票法 Moore Voting，这种方法在之前那道题 Majority Element 中也使用了。题目中给了一条很重要的提示，让先考虑可能会有多少个这样的数字，经过举了很多例子分析得出，任意一个数组出现次数大于 n/3 的数最多有两个，具体的证明博主就不会了，博主也不是数学专业的（热心网友用手走路提供了证明：如果有超过两个，也就是至少三个数字满足“出现的次数大于 n/3”，那么就意味着数组里总共有超过 3*(n/3) = n 个数字，这与已知的数组大小矛盾，所以，只可能有两个或者更少）。那么有了这个信息，使用投票法的核心是找出两个候选数进行投票，需要两遍遍历，第一遍历找出两个候选数，第二遍遍历重新投票验证这两个候选数是否为符合题意的数即可，选候选数方法和前面那篇 Majority Element 一样，由于之前那题题目中限定了一定会有大多数存在，故而省略了验证候选众数的步骤，这道题却没有这种限定，即满足要求的大多数可能不存在，所以要有验证，参加代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, cnt1 = <span class="number">0</span>, cnt2 = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == a) ++cnt1;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num == b) ++cnt2;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt1 == <span class="number">0</span>) &#123; a = num; cnt1 = <span class="number">1</span>; &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cnt2 == <span class="number">0</span>) &#123; b = num; cnt2 = <span class="number">1</span>; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; --cnt1; --cnt2; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == a) ++cnt1;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num == b) ++cnt2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt1 &gt; n / <span class="number">3</span>) res.<span class="built_in">push_back</span>(a);</span><br><span class="line">        <span class="keyword">if</span> (cnt2 &gt; n / <span class="number">3</span>) res.<span class="built_in">push_back</span>(b);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode230-Kth-Smallest-Element-in-a-BST"><a href="#Leetcode230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="Leetcode230. Kth Smallest Element in a BST"></a>Leetcode230. Kth Smallest Element in a BST</h1><p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Follow up:<br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
<p>如果用中序遍历所有的节点就会得到一个有序数组。先来看一种非递归的方法，中序遍历最先遍历到的是最小的结点，只要用一个计数器，每遍历一个结点，计数器自增1，当计数器到达k时，返回当前结点值即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span> (p || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            p = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">if</span> (cnt == k) <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当然，此题我们也可以用递归来解，还是利用中序遍历来解，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kthSmallestDFS</span>(root, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallestDFS</span><span class="params">(TreeNode* root, <span class="type">int</span> &amp;k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> val = <span class="built_in">kthSmallestDFS</span>(root-&gt;left, k);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kthSmallestDFS</span>(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再来看一种分治法的思路，由于 BST 的性质，可以快速定位出第k小的元素是在左子树还是右子树，首先计算出左子树的结点个数总和 cnt，如果k小于等于左子树结点总和 cnt，说明第k小的元素在左子树中，直接对左子结点调用递归即可。如果k大于 cnt+1，说明目标值在右子树中，对右子结点调用递归函数，注意此时的k应为 k-cnt-1，应为已经减少了 cnt+1 个结点。如果k正好等于 cnt+1，说明当前结点即为所求，返回当前结点值即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="built_in">count</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= cnt) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">kthSmallest</span>(root-&gt;left, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; cnt + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">kthSmallest</span>(root-&gt;right, k - cnt - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">count</span>(node-&gt;left) + <span class="built_in">count</span>(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这道题的 Follow up 中说假设该 BST 被修改的很频繁，而且查找第k小元素的操作也很频繁，问我们如何优化。其实最好的方法还是像上面的解法那样利用分治法来快速定位目标所在的位置，但是每个递归都遍历左子树所有结点来计算个数的操作并不高效，所以应该修改原树结点的结构，使其保存包括当前结点和其左右子树所有结点的个数，这样就可以快速得到任何左子树结点总数来快速定位目标值了。定义了新结点结构体，然后就要生成新树，还是用递归的方法生成新树，注意生成的结点的 count 值要累加其左右子结点的 count 值。然后在求第k小元素的函数中，先生成新的树，然后调用递归函数。在递归函数中，不能直接访问左子结点的 count 值，因为左子节结点不一定存在，所以要先判断，如果左子结点存在的话，那么跟上面解法的操作相同。如果不存在的话，当此时k为1的时候，直接返回当前结点值，否则就对右子结点调用递归函数，k自减1，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Follow up</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MyTreeNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        MyTreeNode *left;</span><br><span class="line">        MyTreeNode *right;</span><br><span class="line">        <span class="built_in">MyTreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">count</span>(<span class="number">1</span>), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyTreeNode* <span class="title">build</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        MyTreeNode *node = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>(root-&gt;val);</span><br><span class="line">        node-&gt;left = <span class="built_in">build</span>(root-&gt;left);</span><br><span class="line">        node-&gt;right = <span class="built_in">build</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) node-&gt;count += node-&gt;left-&gt;count;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) node-&gt;count += node-&gt;right-&gt;count;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyTreeNode *node = <span class="built_in">build</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(node, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(MyTreeNode* node, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            <span class="type">int</span> cnt = node-&gt;left-&gt;count;</span><br><span class="line">            <span class="keyword">if</span> (k &lt;= cnt) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">helper</span>(node-&gt;left, k);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; cnt + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">helper</span>(node-&gt;right, k - <span class="number">1</span> - cnt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">helper</span>(node-&gt;right, k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode231-Power-of-Two"><a href="#Leetcode231-Power-of-Two" class="headerlink" title="Leetcode231. Power of Two"></a>Leetcode231. Power of Two</h1><p>Given an integer, write a function to determine if it is a power of two.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1 Output: true </span><br><span class="line">Explanation: 2^0 = 1</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 16 Output: true</span><br><span class="line">Explanation: 2^4 = 16</span><br></pre></td></tr></table></figure><br>判断一个数是不是2的幂<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> temp = n &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode232-Implement-Queue-using-Stacks"><a href="#Leetcode232-Implement-Queue-using-Stacks" class="headerlink" title="Leetcode232. Implement Queue using Stacks"></a>Leetcode232. Implement Queue using Stacks</h1><p>Implement the following operations of a queue using stacks.</p>
<ul>
<li>push(x) — Push element x to the back of queue.</li>
<li>pop() — Removes the element from in front of queue.</li>
<li>peek() — Get the front element.</li>
<li>empty() — Return whether the queue is empty.</li>
</ul>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  // returns 1</span><br><span class="line">queue.pop();   // returns 1</span><br><span class="line">queue.empty(); // returns false</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            front = x;</span><br><span class="line">        &#125;</span><br><span class="line">        s1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">            s1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = s2.<span class="built_in">top</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span>(!s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(s2.<span class="built_in">top</span>());</span><br><span class="line">            s2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">            s1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = s2.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">while</span>(!s2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(s2.<span class="built_in">top</span>());</span><br><span class="line">            s2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode233-Number-of-Digit-One"><a href="#Leetcode233-Number-of-Digit-One" class="headerlink" title="Leetcode233. Number of Digit One"></a>Leetcode233. Number of Digit One</h1><p>Given an integer n, count  the total number of digit1 appearing in all non-negative integers less than or equal to  n.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 13</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>0 &lt;= n &lt;= 2 * 109</li>
</ul>
<p>这道题让我们比给定数小的所有数中1出现的个数，之前有道类似的题 Number of 1 Bits，那道题是求转为二进数后1的个数，博主开始以为这道题也是要用那题的方法，其实不是的，这题实际上相当于一道找规律的题。那么为了找出规律，就先来列举下所有含1的数字，并每 10 个统计下个数，如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1的个数  含1的数字                                          数字范围</span><br><span class="line">1           1                                               [1, 9]</span><br><span class="line">11          10  11  12  13  14  15  16  17  18  19          [10, 19]</span><br><span class="line">1           21                                              [20, 29]</span><br><span class="line">1           31                                              [30, 39]</span><br><span class="line">1           41                                              [40, 49]</span><br><span class="line">1           51                                              [50, 59]</span><br><span class="line">1           61                                              [60, 69]</span><br><span class="line">1           71                                              [70, 79]</span><br><span class="line">1           81                                              [80, 89]</span><br><span class="line">1           91                                              [90, 99]</span><br><span class="line">11         100  101  102  103  104  105  106  107  108  109 [100, 109]</span><br><span class="line">21         110  111  112  113  114  115  116  117  118  119 [110, 119]</span><br><span class="line">11         120  121  122  123  124  125  126  127  128  129 [120, 129]</span><br></pre></td></tr></table></figure></p>
<p>通过上面的列举可以发现，100 以内的数字，除了10-19之间有 11 个 ‘1’ 之外，其余都只有1个。如果不考虑 [10, 19] 区间上那多出来的 10 个 ‘1’ 的话，那么在对任意一个两位数，十位数上的数字(加1)就代表1出现的个数，这时候再把多出的 10 个加上即可。比如 56 就有 (5+1)+10=16 个。如何知道是否要加上多出的 10 个呢，就要看十位上的数字是否大于等于2，是的话就要加上多余的 10 个 ‘1’。那么就可以用 (x+8)/10 来判断一个数是否大于等于2。对于三位数区间 [100, 199] 内的数也是一样，除了 [110, 119] 之间多出的10个数之外，共 21 个 ‘1’，其余的每 10 个数的区间都只有 11 个 ‘1’，所以 [100, 199] 内共有 21 + 11 <em> 9 = 120 个 ‘1’。那么现在想想 [0, 999] 区间内 ‘1’ 的个数怎么求？根据前面的结果，[0, 99] 内共有 20 个，[100, 199] 内共有 120 个，而其他每 100 个数内 ‘1’ 的个数也应该符合之前的规律，即也是 20 个，那么总共就有 120 + 20 </em> 9 = 300 个 ‘1’。那么还是可以用相同的方法来判断并累加1的个数，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res += (n + <span class="number">8</span>) / <span class="number">10</span> * a + (n % <span class="number">10</span> == <span class="number">1</span>) * b;</span><br><span class="line">            b += n % <span class="number">10</span> * a;</span><br><span class="line">            a *= <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode234-Palindrome-Linked-List"><a href="#Leetcode234-Palindrome-Linked-List" class="headerlink" title="Leetcode234. Palindrome Linked List"></a>Leetcode234. Palindrome Linked List</h1><p>Given a singly linked list, determine if it is a palindrome.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>使用反转链表。不同的是不反转整个链表，只反转回文的后半段链表。然后就是判断出哪里是回文的中间位置。</p>
<p>首先说反转链表函数。设置一个节点pre为空，是反转链表后的起始节点。设置节点next为空，是要反转链表当前节点的next节点。遍历，只要head不为空，则先将head-&gt;next保存在next节点中。然后head-&gt;next指向pre，然后head节点保存在pre中。最后head保存next节点。遍历结束，返回pre节点，即完成反转。</p>
<p>然后说判断回文中间位置。设置一个慢指针slow，一个快指针fast。遍历，只要fast-&gt;next和fast-&gt;next-&gt;next不为空，则slow往前走一步，fast往前走两步，slow = slow-&gt;next，fast = fast-&gt;next-&gt;next，这样当不满足遍历条件、结束遍历时，slow刚好指在中间位置，如果长度是计数，则刚好中间，长度是偶数，则中间前一个。</p>
<p>然后说反转后半部分链表。将slow-&gt;next开始反转，slow-&gt;next = reverselist(slow-&gt;next)，然后将slow = slow-&gt;next。</p>
<p>最后是判断是否是回文。这时，可同时遍历head和slow，判断二者值是否相等即可，不相等直接返回false。遍历结束后，返回true。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">NULL</span>, *next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            next = head-&gt;next;</span><br><span class="line">            head-&gt;next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = <span class="built_in">reverseList</span>(slow-&gt;next);</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(slow) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slow-&gt;val != head-&gt;val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#Leetcode235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="Leetcode235. Lowest Common Ancestor of a Binary Search Tree"></a>Leetcode235. Lowest Common Ancestor of a Binary Search Tree</h1><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p>
<p>Given binary search tree:  root = <code>[6,2,8,0,4,7,9,null,null,3,5]</code></p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The LCA of nodes 2 and 8 is 6.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure><br>这道题我们可以用递归来求解，我们首先来看题目中给的例子，由于二叉搜索树的特点是左&lt;根&lt;右，所以根节点的值一直都是中间值，大于左子树的所有节点值，小于右子树的所有节点值，那么我们可以做如下的判断，如果根节点的值大于p和q之间的较大值，说明p和q都在左子树中，那么此时我们就进入根节点的左子节点继续递归，如果根节点小于p和q之间的较小值，说明p和q都在右子树中，那么此时我们就进入根节点的右子节点继续递归，如果都不是，则说明当前根节点就是最小共同父节点，直接返回即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; <span class="built_in">max</span>(p-&gt;val, q-&gt;val)) </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; <span class="built_in">min</span>(p-&gt;val, q-&gt;val)) </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当然，此题也有非递归的写法，用个 while 循环来代替递归调用即可，然后不停的更新当前的根节点，也能实现同样的效果，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; <span class="built_in">max</span>(p-&gt;val, q-&gt;val)) root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; <span class="built_in">min</span>(p-&gt;val, q-&gt;val)) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#Leetcode236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="Leetcode236. Lowest Common Ancestor of a Binary Tree"></a>Leetcode236. Lowest Common Ancestor of a Binary Tree</h1><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p>
<p>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of nodes 5 and 1 is 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>All of the nodes’ values will be unique.</li>
<li>p and q are different and both values will exist in the binary tree.</li>
</ul>
<p>在二叉树中来搜索p和q，然后从路径中找到最后一个相同的节点即为父节点，可以用递归来实现，在递归函数中，首先看当前结点是否为空，若为空则直接返回空，若为p或q中的任意一个，也直接返回当前结点。否则的话就对其左右子结点分别调用递归函数，由于这道题限制了p和q一定都在二叉树中存在，那么如果当前结点不等于p或q，p和q要么分别位于左右子树中，要么同时位于左子树，或者同时位于右子树，那么我们分别来讨论：</p>
<ul>
<li>若p和q分别位于左右子树中，那么对左右子结点调用递归函数，会分别返回p和q结点的位置，而当前结点正好就是p和q的最小共同父结点，直接返回当前结点即可，这就是题目中的例子1的情况。</li>
<li>若p和q同时位于左子树，这里有两种情况，一种情况是 left 会返回p和q中较高的那个位置，而 right 会返回空，所以最终返回非空的 left 即可，这就是题目中的例子2的情况。还有一种情况是会返回p和q的最小父结点，就是说当前结点的左子树中的某个结点才是p和q的最小父结点，会被返回。</li>
<li>若p和q同时位于右子树，同样这里有两种情况，一种情况是 right 会返回p和q中较高的那个位置，而 left 会返回空，所以最终返回非空的 right 即可，还有一种情况是会返回p和q的最小父结点，就是说当前结点的右子树中的某个结点才是p和q的最小父结点，会被返回，写法很简洁，代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!root || p == root || q == root) <span class="keyword">return</span> root;</span><br><span class="line">       TreeNode *left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">       TreeNode *right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p , q);</span><br><span class="line">       <span class="keyword">if</span> (left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">       <span class="keyword">return</span> left ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码可以进行优化一下，如果当前结点不为空，且既不是p也不是q，那么根据上面的分析，p和q的位置就有三种情况，p和q要么分别位于左右子树中，要么同时位于左子树，或者同时位于右子树。我们需要优化的情况就是当p和q同时为于左子树或右子树中，而且返回的结点并不是p或q，那么就是p和q的最小父结点了，已经求出来了，就不用再对右结点调用递归函数了，这是为啥呢？因为根本不会存在 left 既不是p也不是q，同时还有p或者q在 right 中。首先递归的第一句就限定了只要遇到了p或者q，就直接返回，之后又限定了只有当 left 和 right 同时存在的时候，才会返回当前结点，当前结点若不是p或q，则一定是最小父节点，否则 left 一定是p或者q。这里的逻辑比较绕，不太好想，多想想应该可以理清头绪吧，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!root || p == root || q == root) <span class="keyword">return</span> root;</span><br><span class="line">       TreeNode *left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">       <span class="keyword">if</span> (left &amp;&amp; left != p &amp;&amp; left != q) <span class="keyword">return</span> left;</span><br><span class="line">       TreeNode *right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p , q);</span><br><span class="line">　　　　<span class="keyword">if</span> (left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line">       <span class="keyword">return</span> left ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode237-Delete-Node-in-a-Linked-List"><a href="#Leetcode237-Delete-Node-in-a-Linked-List" class="headerlink" title="Leetcode237. Delete Node in a Linked List"></a>Leetcode237. Delete Node in a Linked List</h1><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Given linked list — head = [4,5,1,9], which looks like following:</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [4,5,1,9], node = 5</span><br><span class="line">Output: [4,1,9]</span><br><span class="line">Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [4,5,1,9], node = 1</span><br><span class="line">Output: [4,5,9]</span><br><span class="line">Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure><br>这道题让我们删除链表的一个节点，更通常不同的是，没有给我们链表的起点，只给我们了一个要删的节点，跟我们以前遇到的情况不太一样，我们之前要删除一个节点的方法是要有其前一个节点的位置，然后将其前一个节点的next连向要删节点的下一个，然后delete掉要删的节点即可。这道题的处理方法是先把当前节点的值用下一个节点的值覆盖了，然后我们删除下一个节点即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode238-Product-of-Array-Except-Self"><a href="#Leetcode238-Product-of-Array-Except-Self" class="headerlink" title="Leetcode238. Product of Array Except Self"></a>Leetcode238. Product of Array Except Self</h1><p>Given an array nums of n integers where n &gt; 1,  return an array output such that output[i] is equal to the product of all the elements of numsexcept nums[i].</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  [1,2,3,4]</span><br><span class="line">Output: [24,12,8,6]</span><br></pre></td></tr></table></figure></p>
<p>Note: Please solve it without division and in O(n).</p>
<p>这道题给定我们一个数组，让我们返回一个新数组，对于每一个位置上的数是其他位置上数的乘积，并且限定了时间复杂度 O(n)，并且不让我们用除法。如果让用除法的话，那这道题就应该属于 Easy，因为可以先遍历一遍数组求出所有数字之积，然后除以对应位置的上的数字。但是这道题禁止我们使用除法，那么我们只能另辟蹊径。我们想，对于某一个数字，如果我们知道其前面所有数字的乘积，同时也知道后面所有的数乘积，那么二者相乘就是我们要的结果，所以我们只要分别创建出这两个数组即可，分别从数组的两个方向遍历就可以分别创建出乘积累积数组。参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fwd</span><span class="params">(n, <span class="number">1</span>)</span>, <span class="title">bwd</span><span class="params">(n, <span class="number">1</span>)</span>, <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            fwd[i + <span class="number">1</span>] = fwd[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            bwd[i - <span class="number">1</span>] = bwd[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res[i] = fwd[i] * bwd[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以对上面的方法进行空间上的优化，由于最终的结果都是要乘到结果 res 中，所以可以不用单独的数组来保存乘积，而是直接累积到结果 res 中，我们先从前面遍历一遍，将乘积的累积存入结果 res 中，然后从后面开始遍历，用到一个临时变量 right，初始化为1，然后每次不断累积，最终得到正确结果，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            res[i] *= right;</span><br><span class="line">            right *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode239-Sliding-Window-Maximum"><a href="#Leetcode239-Sliding-Window-Maximum" class="headerlink" title="Leetcode239. Sliding Window Maximum"></a>Leetcode239. Sliding Window Maximum</h1><p>You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.</p>
<p>Return the max sliding window.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">Output: [3,3,5,5,6,7]</span><br><span class="line">Explanation: </span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1], k = 1</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure></p>
<p>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<h2 id="双端单调队列"><a href="#双端单调队列" class="headerlink" title="双端单调队列"></a>双端单调队列</h2><p>本题要找长度为 k 的区间的最大值。模拟这个区间的移动过程，可以发现，右边增加一个数，左边必然会去掉一个数。</p>
<p>那么最大的数有什么性质呢？可以发现，如果扫描区间末尾，在已经遍历过的数之中，一个数 a 在 b 前面，并且 a 还比 b 小，那么 a 在之后的区间里永远无法成为最大值。</p>
<p>所以我们遍历到一个数时，它之前的所有比它小的数都可以去掉了，只保留比它大的数就行了。这就让人想到了之前介绍过的单调栈，但是本题中是先进先出，所以要改用单调队列。此外队列末尾不仅要增加元素，还得维护单调递减，适当去除一些元素，所以队列两端都得有插入和删除的功能。所以本题要使用双端队列，而队列中的元素又是单调递减的，所以又是双端单调队列。</p>
<p>这样思路就很明确了：</p>
<ul>
<li>遍历元素 nums[i] ，然后跟队列尾部元素比较，如果比尾部元素大，就出队，然后继续比较，直到 nums[i] 小于尾部元素，然后将它入队。</li>
<li>然后用一下队列首部元素的下标，计算出队列中区间的长度，如果大于 k 了，那么队首元素就要出队。</li>
<li>最后队首元素就是当前区间的最大值。</li>
</ul>
<h2 id="分块法"><a href="#分块法" class="headerlink" title="分块法"></a>分块法</h2><p>试想如果我们将数组划分为相同大小的若干块，每一块中最大值都是知道的话，那么要求区间最大值，只需要看它在哪几块里就行了。</p>
<p>那么块的大小应该设成多少呢？</p>
<p>如果块大小为 k ，就可以发现长度为 k 的区间 [i, j] 要么正好就是一个完整的块，要么跨越了两个相邻块。那么我们只需要知道 i 到它那块末尾元素中最大值，以及 j 到它那块开头最大值就行了，两个部分合并求最大值就是区间的最大值了。而每个元素到它自己那块的开头和末尾的最大值都可以预处理出来，方法和求前缀和类似。</p>
<p>那为什么块大小不能是其他值呢？如果块大小大于 k ，那么会出现区间完全包含于一块之中的情况，那就和不分块一样了。如果块大小小于 k ，那么就会出现区间横跨了好几块，那么还得遍历中间块的最大值。极端情况下如果块大小为 1 ，那么就等于暴力求解。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>双端单调队列（c++）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt;= nums[Q.<span class="built_in">back</span>()]) Q.<span class="built_in">pop_back</span>();</span><br><span class="line">            Q.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i - Q.<span class="built_in">front</span>() + <span class="number">1</span> &gt; k) Q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k<span class="number">-1</span>) res.<span class="built_in">push_back</span>(nums[Q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>双端单调队列+数组实现（c++）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Q</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (r-l &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[Q[r<span class="number">-1</span>]]) r--;</span><br><span class="line">            Q[r++] = i;</span><br><span class="line">            <span class="keyword">if</span> (i - Q[l] + <span class="number">1</span> &gt; k) l++;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k<span class="number">-1</span>) res.<span class="built_in">push_back</span>(nums[Q[l]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>分块法（c++）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lmax</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">rmax</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%k == <span class="number">0</span>) lmax[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> lmax[i] = <span class="built_in">max</span>(lmax[i<span class="number">-1</span>], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i+<span class="number">1</span>)%k == <span class="number">0</span> || i == n<span class="number">-1</span>) rmax[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> rmax[i] = <span class="built_in">max</span>(rmax[i+<span class="number">1</span>], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k<span class="number">-1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">max</span>(lmax[i], rmax[i-k+<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>双端单调队列（python）<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        Q = collections.deque()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(Q) &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt;= nums[Q[-<span class="number">1</span>]]:</span><br><span class="line">                Q.pop()</span><br><span class="line">            Q.append(i)</span><br><span class="line">            <span class="keyword">if</span> i - Q[<span class="number">0</span>] + <span class="number">1</span> &gt; k:</span><br><span class="line">                Q.popleft()</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k-<span class="number">1</span>:</span><br><span class="line">                res.append(nums[Q[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>双端单调队列+数组实现（python）<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        Q = [<span class="number">0</span>] * n</span><br><span class="line">        res = []</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">while</span> r-l &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt;= nums[Q[r-<span class="number">1</span>]]:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            Q[r] = i</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i - Q[l] + <span class="number">1</span> &gt; k:</span><br><span class="line">                l += <span class="number">1</span> </span><br><span class="line">            <span class="keyword">if</span> i &gt;= k-<span class="number">1</span>:</span><br><span class="line">                res.append(nums[Q[l]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>分块法（python）<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        lmax, rmax = [<span class="number">0</span>] * n, [<span class="number">0</span>] * n</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i%k == <span class="number">0</span>:</span><br><span class="line">                lmax[i] = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lmax[i] = <span class="built_in">max</span>(lmax[i-<span class="number">1</span>], nums[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>)%k == <span class="number">0</span> <span class="keyword">or</span> i == n-<span class="number">1</span>:</span><br><span class="line">                rmax[i] = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rmax[i] = <span class="built_in">max</span>(rmax[i+<span class="number">1</span>], nums[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>, n):</span><br><span class="line">            res.append(<span class="built_in">max</span>(lmax[i], rmax[i-k+<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode240-Search-a-2D-Matrix-II"><a href="#Leetcode240-Search-a-2D-Matrix-II" class="headerlink" title="Leetcode240. Search a 2D Matrix II"></a>Leetcode240. Search a 2D Matrix II</h1><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<p>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.<br>Example:</p>
<p>Consider the following matrix:</p>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>Given target = 5, return true.</p>
<p>Given target = 20, return false.</p>
<p>从右上角开始, 比较target 和 <code>matrix[i][j]</code>的值. 如果小于target, 则该行不可能有此数,  所以i++; 如果大于target, 则该列不可能有此数, 所以j—. 遇到边界则表明该矩阵不含target.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>()==<span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;matrix.<span class="built_in">size</span>() &amp;&amp; j&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] &lt; target)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，做一些简单的优化，就能从打败50%升到打败60%。比如尽量少的使用<code>matrix[i][j]</code>，而是用变量把它存下来。</p>
<h1 id="Leetcode241-Different-Ways-to-Add-Parentheses-添加括号的不同方式"><a href="#Leetcode241-Different-Ways-to-Add-Parentheses-添加括号的不同方式" class="headerlink" title="Leetcode241. Different Ways to Add Parentheses 添加括号的不同方式"></a>Leetcode241. Different Ways to Add Parentheses 添加括号的不同方式</h1><p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;2-1-1&quot;</span><br><span class="line">Output: [0, 2]</span><br><span class="line">Explanation: </span><br><span class="line">((2-1)-1) = 0 </span><br><span class="line">(2-(1-1)) = 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;2*3-4*5&quot;</span><br><span class="line">Output: [-34, -14, -10, -10, 10]</span><br><span class="line">Explanation: </span><br><span class="line">(2*(3-(4*5))) = -34 </span><br><span class="line">((2*3)-(4*5)) = -14 </span><br><span class="line">((2*(3-4))*5) = -10 </span><br><span class="line">(2*((3-4)*5)) = -10 </span><br><span class="line">(((2*3)-4)*5) = 10</span><br></pre></td></tr></table></figure></p>
<p>这道题让给了一个可能含有加减乘的表达式，让我们在任意位置添加括号，求出所有可能表达式的不同值。</p>
<p>先从最简单的输入开始，若 input 是空串，那就返回一个空数组。若 input 是一个数字的话，那么括号加与不加其实都没啥区别，因为不存在计算，但是需要将字符串转为整型数，因为返回的是一个整型数组。当然，input 是一个单独的运算符这种情况是不存在的，因为前面说了这道题默认输入的合法的。下面来看若 input 是数字和运算符的时候，比如 “1+1” 这种情况，那么加不加括号也没有任何影响，因为只有一个计算，结果一定是2。再复杂一点的话，比如题目中的例子1，input 是 “2-1-1” 时，就有两种情况了，(2-1)-1 和 2-(1-1)，由于括号的不同，得到的结果也不同，但如果我们把括号里的东西当作一个黑箱的话，那么其就变为 ()-1  和 2-()，其最终的结果跟括号内可能得到的值是息息相关的，那么再 general 一点，实际上就可以变成 () ? () 这种形式，两个括号内分别是各自的表达式，最终会分别计算得到两个整型数组，中间的问号表示运算符，可以是加，减，或乘。那么问题就变成了从两个数组中任意选两个数字进行运算，瞬间变成我们会做的题目了有木有？而这种左右两个括号代表的黑盒子就交给递归去计算，像这种分成左右两坨的 pattern 就是大名鼎鼎的分治法 Divide and Conquer 了，是必须要掌握的一个神器。类似的题目还有之前的那道 Unique Binary Search Trees II 用的方法一样，用递归来解，划分左右子树，递归构造。</p>
<p>好，继续来说这道题，我们不用新建递归函数，就用其本身来递归就行，先建立一个结果 res 数组，然后遍历 input 中的字符，根据上面的分析，我们希望在每个运算符的地方，将 input 分成左右两部分，从而扔到递归中去计算，从而可以得到两个整型数组 left 和 right，分别表示作用两部分各自添加不同的括号所能得到的所有不同的值，此时我们只要分别从两个数组中取数字进行当前的运算符计算，然后把结果存到 res 中即可。当然，若最终结果 res 中还是空的，那么只有一种情况，input 本身就是一个数字，直接转为整型存入结果 res 中即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input[i] == <span class="string">&#x27;+&#x27;</span> || input[i] == <span class="string">&#x27;-&#x27;</span> || input[i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(<span class="number">0</span>, i));</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">diffWaysToCompute</span>(input.<span class="built_in">substr</span>(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; left.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; right.<span class="built_in">size</span>(); ++k) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (input[i] == <span class="string">&#x27;+&#x27;</span>) res.<span class="built_in">push_back</span>(left[j] + right[k]);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (input[i] == <span class="string">&#x27;-&#x27;</span>) res.<span class="built_in">push_back</span>(left[j] - right[k]);</span><br><span class="line">                        <span class="keyword">else</span> res.<span class="built_in">push_back</span>(left[j] * right[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">empty</span>()) res.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode242-Valid-Anagram"><a href="#Leetcode242-Valid-Anagram" class="headerlink" title="Leetcode242. Valid Anagram"></a>Leetcode242. Valid Anagram</h1><p>Given two strings s and t , write a function to determine if t is an anagram of s.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>判断异位词，即包含相同的字符的字符串。使用map记录每个字符串中的字符，判断map是否相同。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; ss, tt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ss.<span class="built_in">find</span>(s[i]) == ss.<span class="built_in">end</span>())</span><br><span class="line">                ss[s[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> ss[s[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tt.<span class="built_in">find</span>(t[i]) == tt.<span class="built_in">end</span>())</span><br><span class="line">                tt[t[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> tt[t[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ss == tt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode243-Shortest-Word-Distance"><a href="#Leetcode243-Shortest-Word-Distance" class="headerlink" title="Leetcode243. Shortest Word Distance"></a>Leetcode243. Shortest Word Distance</h1><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Assume that words = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;].</span><br><span class="line"></span><br><span class="line">Input: word1 = “coding”, word2 = “practice”</span><br><span class="line">Output: 3</span><br><span class="line">Input: word1 = &quot;makes&quot;, word2 = &quot;coding&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><br>Note:<br>You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestDistance</span><span class="params">(vector&lt;string&gt;&amp; words, string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">-1</span>, res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (words[i] == word1 || words[i] == word2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (idx != <span class="number">-1</span> &amp;&amp; words[idx] != words[i]) &#123;</span><br><span class="line">                    res = <span class="built_in">min</span>(res, i - idx);</span><br><span class="line">                &#125;</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode246-Strobogrammatic-Number"><a href="#Leetcode246-Strobogrammatic-Number" class="headerlink" title="Leetcode246. Strobogrammatic Number"></a>Leetcode246. Strobogrammatic Number</h1><p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to determine if a number is strobogrammatic. The number is represented as a string.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  &quot;69&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  &quot;88&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  &quot;962&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>这道题定义了一种对称数，就是说一个数字旋转 180 度和原来一样，也就是倒过来看一样，比如 609，倒过来还是 609 等等，满足这种条件的数字其实没有几个，只有 0,1,8,6,9。这道题其实可以看做求回文数的一种特殊情况，还是用双指针来检测，首尾两个数字如果相等的话，只有它们是 0,1,8 中间的一个才行，如果它们不相等的话，必须一个是6一个是9，或者一个是9一个是6，其他所有情况均返回 false。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isStrobogrammatic</span><span class="params">(string num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = num.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[l] == num[r]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[l] != <span class="string">&#x27;1&#x27;</span> &amp;&amp; num[l] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; num[l] != <span class="string">&#x27;8&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((num[l] != <span class="string">&#x27;6&#x27;</span> || num[r] != <span class="string">&#x27;9&#x27;</span>) &amp;&amp; (num[l] != <span class="string">&#x27;9&#x27;</span> || num[r] != <span class="string">&#x27;6&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++l; --r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode247-Strobogrammatic-Number-II"><a href="#Leetcode247-Strobogrammatic-Number-II" class="headerlink" title="Leetcode247. Strobogrammatic Number II"></a>Leetcode247. Strobogrammatic Number II</h1><p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Find all strobogrammatic numbers that are of length = n.</p>
<p>For example, Given n = 2, return [“11”,”69”,”88”,”96”].</p>
<p>可以像是一层层的给字符串从里向外穿衣服一样DFS生成所有的解.</p>
<p>其中翻转之后和自身相等有0, 1, 8, 在n为奇数的情况下最里面的一个数可以为这三个数的任意一个. 再外边就一次给两端添加一个对称的字符. 如果是最外层的话需要注意不能是为0.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> n, string str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> result.<span class="built_in">push_back</span>(str);</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">for</span>(<span class="keyword">auto</span> val: same) <span class="built_in">DFS</span>(n<span class="number">-1</span>, val);</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = (n==<span class="number">2</span>)?<span class="number">1</span>:<span class="number">0</span>; i &lt; two.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="built_in">DFS</span>(n<span class="number">-2</span>, two[i].first + str + two[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findStrobogrammatic</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">DFS</span>(n, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    vector&lt;string&gt; same&#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;8&quot;</span>&#125;;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">char</span>,<span class="type">char</span>&gt;&gt; two&#123;&#123;<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;,&#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;,&#123;<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;9&#x27;</span>&#125;,&#123;<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;8&#x27;</span>&#125;,&#123;<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;6&#x27;</span>&#125;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode252-Meeting-Rooms"><a href="#Leetcode252-Meeting-Rooms" class="headerlink" title="Leetcode252. Meeting Rooms"></a>Leetcode252. Meeting Rooms</h1><p>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), determine if a person could attend all meetings.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,30],[5,10],[15,20]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[7,10],[2,4]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.</p>
<p>这道题给了我们一堆会议的时间，问能不能同时参见所有的会议，这实际上就是求区间是否有交集的问题，那么最简单暴力的方法就是每两个区间比较一下，看是否有 overlap，有的话直接返回 false 就行了。比较两个区间a和b是否有 overlap，可以检测两种情况，如果a的起始位置大于等于b的起始位置，且此时a的起始位置小于b的结束位置，则一定有 overlap，另一种情况是a和b互换个位置，如果b的起始位置大于等于a的起始位置，且此时b的起始位置小于a的结束位置，那么一定有 overlap，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canAttendMeetings</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; intervals.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((intervals[i][<span class="number">0</span>] &gt;= intervals[j][<span class="number">0</span>] &amp;&amp; intervals[i][<span class="number">0</span>] &lt; intervals[j][<span class="number">1</span>]) || (intervals[j][<span class="number">0</span>] &gt;= intervals[i][<span class="number">0</span>] &amp;&amp; intervals[j][<span class="number">0</span>] &lt; intervals[i][<span class="number">1</span>])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们可以先给所有区间排个序，用起始时间的先后来排，然后从第二个区间开始，如果开始时间早于前一个区间的结束时间，则说明会议时间有冲突，返回 false，遍历完成后没有冲突，则返回 true，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canAttendMeetings</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;<span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; intervals[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode253-Meeting-Rooms-II"><a href="#Leetcode253-Meeting-Rooms-II" class="headerlink" title="Leetcode253. Meeting Rooms II"></a>Leetcode253. Meeting Rooms II</h1><p>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), find the minimum number of conference rooms required.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0, 30],[5, 10],[15, 20]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[7,10],[2,4]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.</p>
<p>这道题是之前那道 Meeting Rooms 的拓展，那道题只问我们是否能参加所有的会，也就是看会议之间有没有时间冲突，而这道题让求最少需要安排几个会议室，有时间冲突的肯定需要安排在不同的会议室。这道题有好几种解法，先来看使用 TreeMap 来做的，遍历时间区间，对于起始时间，映射值自增1，对于结束时间，映射值自减1，然后定义结果变量 res，和房间数 rooms，遍历 TreeMap，时间从小到大，房间数每次加上映射值，然后更新结果 res，遇到起始时间，映射是正数，则房间数会增加，如果一个时间是一个会议的结束时间，也是另一个会议的开始时间，则映射值先减后加仍为0，并不用分配新的房间，而结束时间的映射值为负数更不会增加房间数，利用这种思路可以写出代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMeetingRooms</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : intervals) &#123;</span><br><span class="line">            ++m[a[<span class="number">0</span>]];</span><br><span class="line">            --m[a[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rooms = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : m) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, rooms += it.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>第二种方法是用两个一维数组来做，分别保存起始时间和结束时间，然后各自排个序，定义结果变量 res 和结束时间指针 endpos，然后开始遍历，如果当前起始时间小于结束时间指针的时间，则结果自增1，反之结束时间指针自增1，这样可以找出重叠的时间段，从而安排新的会议室，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMeetingRooms</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; starts, ends;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, endpos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : intervals) &#123;</span><br><span class="line">            starts.<span class="built_in">push_back</span>(a[<span class="number">0</span>]);</span><br><span class="line">            ends.<span class="built_in">push_back</span>(a[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(starts.<span class="built_in">begin</span>(), starts.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(ends.<span class="built_in">begin</span>(), ends.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (starts[i] &lt; ends[endpos]) ++res;</span><br><span class="line">            <span class="keyword">else</span> ++endpos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode256-Paint-House"><a href="#Leetcode256-Paint-House" class="headerlink" title="Leetcode256. Paint House"></a>Leetcode256. Paint House</h1><p>There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.<br>The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses.</p>
<p>Note:<br>All costs are positive integers.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[17,2,17],[16,16,5],[14,3,19]]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue. </span><br><span class="line">             Minimum cost: 2 + 5 + 3 = 10.</span><br></pre></td></tr></table></figure><br>解题思路：一道很明显的动态规划的题目. 每个房子有三种染色方案, 那么如果当前房子染红色的话, 最小代价将是上一个房子的绿色和蓝色的最小代价+当前房子染红色的代价. 对另外两种颜色也是如此. 因此动态转移方程为:</p>
<ul>
<li>Sub-problem: find the minimum cost to paint the houses up to current house in red, blue or green.</li>
<li>Function:<ul>
<li>Red: min(f[i - 11][1], f[i - 1][2]) + costs[i][0].</li>
<li>Blue: min(f[i - 1][0], f[i - 1][2]) + costs[i][1].</li>
<li>Green: min(f[i - 1][0], f[i - 1][1]) + costs[i][2].</li>
<li>Initialization: f[0][i] = 0.</li>
<li>Answer: min(f[costs.length][i]).</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = costs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 直接initialize成0更好</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, INT_MAX));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + costs[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + costs[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) + costs[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[n][<span class="number">0</span>], <span class="built_in">min</span>(dp[n][<span class="number">1</span>], dp[n][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode257-Binary-Tree-Paths"><a href="#Leetcode257-Binary-Tree-Paths" class="headerlink" title="Leetcode257. Binary Tree Paths"></a>Leetcode257. Binary Tree Paths</h1><p>Given a binary tree, return all root-to-leaf paths.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br><span class="line">Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</span><br></pre></td></tr></table></figure><br>中序遍历<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, string cur)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left, cur+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">to_string</span>(root-&gt;left-&gt;val));</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right, cur+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">to_string</span>(root-&gt;right-&gt;val));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="built_in">to_string</span>(root-&gt;val));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode258-Add-Digits"><a href="#Leetcode258-Add-Digits" class="headerlink" title="Leetcode258. Add Digits"></a>Leetcode258. Add Digits</h1><p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 38</span><br><span class="line">Output: 2 </span><br><span class="line">Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. </span><br><span class="line">             Since 2 has only one digit, return it.</span><br></pre></td></tr></table></figure><br>逐位相加直到小于10<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">addDigits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = num;</span><br><span class="line">        <span class="keyword">while</span>(res / <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="type">int</span> temp = res, sum = <span class="number">0</span>;;</span><br><span class="line">            <span class="keyword">while</span>(temp) &#123;</span><br><span class="line">                sum += temp%<span class="number">10</span>;</span><br><span class="line">                temp /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode259-3Sum-Smaller"><a href="#Leetcode259-3Sum-Smaller" class="headerlink" title="Leetcode259. 3Sum Smaller"></a>Leetcode259. 3Sum Smaller</h1><p>Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 &lt;= i &lt; j &lt; k &lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &lt; target.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-2,0,1,3], and target = 2</span><br><span class="line">Output: 2 </span><br><span class="line">Explanation: Because there are two triplets which sums are less than 2:</span><br><span class="line">	[-2,0,1]</span><br><span class="line">	[-2,0,3]</span><br></pre></td></tr></table></figure></p>
<p>这道题是 3Sum 问题的一个变形，让我们求三数之和小于一个目标值，那么最简单的方法就是穷举法，将所有的可能的三个数字的组合都遍历一遍，比较三数之和跟目标值之间的大小，小于的话则结果自增1，参见代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(nums.<span class="built_in">size</span>() - <span class="number">2</span>); ++i) &#123;</span><br><span class="line">	        <span class="type">int</span> left = i + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>, sum = target - nums[i];</span><br><span class="line">	        <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt;= right; ++j) &#123;</span><br><span class="line">	            <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt;= right; ++k) &#123;</span><br><span class="line">	                <span class="keyword">if</span> (nums[j] + nums[k] &lt; sum) ++res;</span><br><span class="line">		        &#125;</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>题目中的 Follow up 让我们在 O(n^2) 的时间复杂度内实现，那么借鉴之前那两道题 3Sum Closest 和 3Sum 中的方法，采用双指针来做，这里面有个 trick 就是当判断三个数之和小于目标值时，此时结果应该加上 right-left，因为数组排序了以后，如果加上 num[right] 小于目标值的话，那么加上一个更小的数必定也会小于目标值，然后将左指针右移一位，否则将右指针左移一位，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    <span class="type">int</span> res = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">	    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">	        <span class="type">int</span> left = i + <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line">	        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">	    	    <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">	    	        res += right - left;</span><br><span class="line">	    	        ++left;</span><br><span class="line">	    	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    	        --right;</span><br><span class="line">	    	    &#125;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode260-Single-Number-III"><a href="#Leetcode260-Single-Number-III" class="headerlink" title="Leetcode260. Single Number III"></a>Leetcode260. Single Number III</h1><p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  [1,2,1,3,2,5]</span><br><span class="line">Output: [3,5]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The order of the result is not important. So in the above example, [5, 3] is also correct.</li>
<li>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</li>
</ul>
<p>这道题其实是很巧妙的利用了 Single Number 的解法，因为那道解法是可以准确的找出只出现了一次的数字，但前提是其他数字必须出现两次才行。而这题有两个数字都只出现了一次，那么我们如果能想办法把原数组分为两个小数组，不相同的两个数字分别在两个小数组中，这样分别调用 Single Number 的解法就可以得到答案。那么如何实现呢，首先我们先把原数组全部异或起来，那么我们会得到一个数字，这个数字是两个不相同的数字异或的结果，我们取出其中任意一位为 ‘1’ 的位，为了方便起见，我们用 a &amp;= -a 来取出最右端为 ‘1’ 的位，具体来说下这个是如何操作的吧。就拿题目中的例子来说，如果我们将其全部 ‘异或’ 起来，我们知道相同的两个数 ‘异或’ 的话为0，那么两个1，两个2，都抵消了，就剩3和5 ‘异或’ 起来，那么就是二进制的 11 和 101 ‘异或’ ，得到110。然后我们进行 a &amp;= -a 操作。首先变负数吧，在二进制中负数采用补码的形式，而补码就是反码 +1，那么 110 的反码是 11…1001，那么加1后是 11…1010，然后和 110 相与，得到了 10，就是代码中的 diff 变量。得到了这个 diff，就可以将原数组分为两个数组了。为啥呢，我们想阿，如果两个相同的数字 ‘异或’ ，每位都会是0，而不同的数字 ‘异或’ ，一定会有对应位不同，一个0一个1，这样 ‘异或’ 是1。比如3和5的二进制 11 和 101，如果从低往高看，最开始产生不同的就是第二位，那么我们用第二位来和数组中每个数字相与，根据结果的不同，一定可以把3和5区分开来，而其他的数字由于是成对出现，所以区分开来也是成对的，最终都会 ‘异或’ 成0，不会3和5产生影响。分别将两个小组中的数字都异或起来，就可以得到最终结果了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> diff = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>, <span class="built_in">bit_xor</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        diff &amp;= -diff;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &amp; diff) res[<span class="number">0</span>] ^= a;</span><br><span class="line">            <span class="keyword">else</span> res[<span class="number">1</span>] ^= a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode261-Graph-Valid-Tree"><a href="#Leetcode261-Graph-Valid-Tree" class="headerlink" title="Leetcode261. Graph Valid Tree"></a>Leetcode261. Graph Valid Tree</h1><p>Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">n = 5, and edges = [[0,1], [0,2], [0,3], [1,4]]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">n = 5, and edges = [[0,1], [1,2], [2,3], [1,3], [1,4]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0,1] is the same as [1,0] and thus will not appear together in edges.</p>
<p>这道题给了一个无向图，让我们来判断其是否为一棵树，如果是树的话，所有的节点必须是连接的，也就是说必须是连通图，而且不能有环，所以焦点就变成了验证是否是连通图和是否含有环。首先用 DFS 来做，根据 pair 来建立一个图的结构，用邻接链表来表示，还需要一个一位数组v来记录某个结点是否被访问过，然后用 DFS 来搜索结点0，遍历的思想是，当 DFS 到某个结点，先看当前结点是否被访问过，如果已经被访问过，说明环存在，直接返回 false，如果未被访问过，现在将其状态标记为已访问过，然后到邻接链表里去找跟其相邻的结点继续递归遍历，注意还需要一个变量 pre 来记录上一个结点，以免回到上一个结点，这样遍历结束后，就把和结点0相邻的节点都标记为 true，然后再看v里面是否还有没被访问过的结点，如果有，则说明图不是完全连通的，返回 false，反之返回 true，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validTree</span><span class="params">(<span class="type">int</span> n, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">v</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : edges) &#123;</span><br><span class="line">            g[a.first].<span class="built_in">push_back</span>(a.second);</span><br><span class="line">            g[a.second].<span class="built_in">push_back</span>(a.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">dfs</span>(g, v, <span class="number">0</span>, <span class="number">-1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;g, vector&lt;<span class="type">bool</span>&gt; &amp;v, <span class="type">int</span> cur, <span class="type">int</span> pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v[cur]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        v[cur] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : g[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a != pre) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">dfs</span>(g, v, a, cur)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面来看 BFS 的解法，思路很相近，需要用 queue 来辅助遍历，这里没有用一维向量来标记节点是否访问过，而是用了一个 HashSet，如果遍历到一个节点，在 HashSet 中没有，则加入 HashSet，如果已经存在，则返回false，还有就是在遍历邻接链表的时候，遍历完成后需要将结点删掉，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validTree</span><span class="params">(<span class="type">int</span> n, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n, <span class="built_in">unordered_set</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; s&#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q&#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : edges) &#123;</span><br><span class="line">            g[a.first].<span class="built_in">insert</span>(a.second);</span><br><span class="line">            g[a.second].<span class="built_in">insert</span>(a.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> a : g[t]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.<span class="built_in">count</span>(a)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                s.<span class="built_in">insert</span>(a);</span><br><span class="line">                q.<span class="built_in">push</span>(a);</span><br><span class="line">                g[a].<span class="built_in">erase</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>() == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们再来看 Union Find 的方法，这种方法对于解决连通图的问题很有效，思想是遍历节点，如果两个节点相连，将其 roots 值连上，这样可以找到环，初始化 roots 数组为 -1，然后对于一个 pair 的两个节点分别调用 find 函数，得到的值如果相同的话，则说明环存在，返回 false，不同的话，将其 roots 值 union 上，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validTree</span><span class="params">(<span class="type">int</span> n, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">roots</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : edges) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">find</span>(roots, a.first), y = <span class="built_in">find</span>(roots, a.second);</span><br><span class="line">            <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            roots[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges.<span class="built_in">size</span>() == n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;roots, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (roots[i] != <span class="number">-1</span>) i = roots[i];</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode263-Ugly-Number"><a href="#Leetcode263-Ugly-Number" class="headerlink" title="Leetcode263. Ugly Number"></a>Leetcode263. Ugly Number</h1><p>Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 6 = 2 × 3</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 8 = 2 × 2 × 2</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 14</span><br><span class="line">Output: false </span><br><span class="line">Explanation: 14 is not ugly since it includes another prime factor 7.</span><br></pre></td></tr></table></figure><br>检测一个数是否为丑陋数，所谓丑陋数就是其质数因子只能是 2，3，5。那么最直接的办法就是不停的除以这些质数，如果剩余的数字是1的话就是丑陋数了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isUgly</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">0</span>) num /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">3</span> == <span class="number">0</span>) num /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">5</span> == <span class="number">0</span>) num /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode264-Ugly-Number-II"><a href="#Leetcode264-Ugly-Number-II" class="headerlink" title="Leetcode264. Ugly Number II"></a>Leetcode264. Ugly Number II</h1><p>An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.</p>
<p>Given an integer n, return the nth ugly number.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 10</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.</span><br></pre></td></tr></table></figure></p>
<p>这道题是之前那道 Ugly Number 的拓展，这里让找到第n个丑陋数，还好题目中给了很多提示，基本上相当于告诉我们解法了，根据提示中的信息，丑陋数序列可以拆分为下面3个子列表：</p>
<p>(1) 1x2 ,  2x2, 2x2 , 3x2, 3x2 , 4x2 , 5x2…</p>
<p>(2) 1x3,   1x3 , 2x3, 2x3, 2x3 , 3x3, 3x3…</p>
<p>(3) 1x5,  1x5, 1x5, 1x5 , 2x5, 2x5, 2x5…</p>
<p>仔细观察上述三个列表，可以发现每个子列表都是一个丑陋数分别乘以 2，3，5，而要求的丑陋数就是从已经生成的序列中取出来的，每次都从三个列表中取出当前最小的那个加入序列，请参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (res.<span class="built_in">size</span>() &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> m2 = res[i2] * <span class="number">2</span>, m3 = res[i3] * <span class="number">3</span>, m5 = res[i5] * <span class="number">5</span>;</span><br><span class="line">            <span class="type">int</span> mn = <span class="built_in">min</span>(m2, <span class="built_in">min</span>(m3, m5));</span><br><span class="line">            <span class="keyword">if</span> (mn == m2) ++i2;</span><br><span class="line">            <span class="keyword">if</span> (mn == m3) ++i3;</span><br><span class="line">            <span class="keyword">if</span> (mn == m5) ++i5;</span><br><span class="line">            res.<span class="built_in">push_back</span>(mn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode266-Palindrome-Permutation"><a href="#Leetcode266-Palindrome-Permutation" class="headerlink" title="Leetcode266. Palindrome Permutation"></a>Leetcode266. Palindrome Permutation</h1><p>Given a string, determine if a permutation of the string could form a palindrome.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;code&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;aab&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;carerac&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Hint: </p>
<ul>
<li>Consider the palindromes of odd vs even length. What difference do you notice?</li>
<li>Count the frequency of each character.</li>
</ul>
<p>这道题让我们判断一个字符串的全排列有没有是回文字符串的，那么根据题目中的提示，我们分字符串的个数是奇偶的情况来讨论，如果是偶数的话，由于回文字符串的特性，每个字母出现的次数一定是偶数次，当字符串是奇数长度时，只有一个字母出现的次数是奇数，其余均为偶数，那么利用这个特性我们就可以解题，我们建立每个字母和其出现次数的映射，然后我们遍历 HashMap，统计出现次数为奇数的字母的个数，那么只有两种情况是回文数，第一种是没有出现次数为奇数的字母，再一个就是字符串长度为奇数，且只有一个出现次数为奇数的字母，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPermutePalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : s) ++m[a];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.second % <span class="number">2</span> == <span class="number">1</span>) ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span> || (s.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; cnt == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode268-Missing-Number"><a href="#Leetcode268-Missing-Number" class="headerlink" title="Leetcode268. Missing Number"></a>Leetcode268. Missing Number</h1><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,0,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure><br>随机从0到size()选取了n个数，其中只有一个丢失了（显然的）。<br>别人的算法：数学推出，0到size()的总和减去当前数组和sum.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n*(n+<span class="number">1</span>)/<span class="number">2</span> - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>这道问题被标注为位运算问题：参考讨论区的位运算解法：</p>
<p>异或运算xor，<br>0 ^ a = a ^ 0 =a<br>a ^ b = b ^ a<br>a ^ a = 0<br>0到size()间的所有数一起与数组中的数进行异或运算，<br>因为同则0，0异或某个未出现的数将存活下来<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums.<span class="built_in">size</span>(); i++) </span><br><span class="line">            res =res ^ i ^ nums[i<span class="number">-1</span>]; </span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode270-Closest-Binary-Search-Tree-Value"><a href="#Leetcode270-Closest-Binary-Search-Tree-Value" class="headerlink" title="Leetcode270. Closest Binary Search Tree Value"></a>Leetcode270. Closest Binary Search Tree Value</h1><p>Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.</p>
<p>Note: Given target value is a floating point. You are guaranteed to have only one unique value in the BST that is closest to the target.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,5,1,3], target = 3.714286</span><br><span class="line"></span><br><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br><span class="line"></span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><br>这道题让我们找一个二分搜索数的跟给定值最接近的一个节点值，由于是二分搜索树，所以博主最先想到用中序遍历来做，一个一个的比较，维护一个最小值，不停的更新，实际上这种方法并没有提高效率，用其他的遍历方法也可以，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="type">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> d = numeric_limits&lt;<span class="type">double</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span> (p || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            p = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (d &gt;= <span class="built_in">abs</span>(target - p-&gt;val)) &#123;</span><br><span class="line">                d = <span class="built_in">abs</span>(target - p-&gt;val);</span><br><span class="line">                res = p-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>实际我们可以利用二分搜索树的特点 (左&lt;根&lt;右) 来快速定位，由于根节点是中间值，在往下遍历时，根据目标值和根节点的值大小关系来比较，如果目标值小于节点值，则应该找更小的值，于是到左子树去找，反之去右子树找，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">closestValue</span><span class="params">(TreeNode* root, <span class="type">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = root-&gt;val;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(res - target) &gt;= <span class="built_in">abs</span>(root-&gt;val - target)) &#123;</span><br><span class="line">                res = root-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            root = target &lt; root-&gt;val ? root-&gt;left : root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode273-Integer-to-English-Words"><a href="#Leetcode273-Integer-to-English-Words" class="headerlink" title="Leetcode273. Integer to English Words"></a>Leetcode273. Integer to English Words</h1><p>Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.</p>
<p>For example,<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">123 -&gt; &quot;One Hundred Twenty Three&quot;</span><br><span class="line">12345 -&gt; &quot;Twelve Thousand Three Hundred Forty Five&quot;</span><br><span class="line">1234567 -&gt; &quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&quot;</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们把一个整型数转为用英文单词描述，就像在check上写钱数的方法，我最开始的方法特别复杂，因为我用了几个switch语句来列出所有的单词，但是我看网上大神们的解法都是用数组来枚举的，特别的巧妙而且省地方，膜拜学习中。题目中给足了提示，首先告诉我们要3个一组的进行处理，而且题目中限定了输入数字范围为0到231 - 1之间，最高只能到billion位，3个一组也只需处理四组即可，那么我们需要些一个处理三个一组数字的函数，我们需要把1到19的英文单词都列出来，放到一个数组里，还要把20,30，… 到90的英文单词列出来放到另一个数组里，然后我们需要用写技巧，比如一个三位数n，百位数表示为n/100，后两位数一起表示为n%100，十位数表示为n%100/10，个位数表示为n%10，然后我们看后两位数是否小于20，小于的话直接从数组中取出单词，如果大于等于20的话，则分别将十位和个位数字的单词从两个数组中取出来。然后再来处理百位上的数字，还要记得加上Hundred。主函数中调用四次这个帮助函数，然后中间要插入”Thousand”, “Million”, “Billion”到对应的位置，最后check一下末尾是否有空格，把空格都删掉，返回的时候检查下输入是否为0，是的话要返回’Zero’。参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">numberToWords</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string res = <span class="built_in">convertHundred</span>(num % <span class="number">1000</span>);</span><br><span class="line">        vector&lt;string&gt; v = &#123;<span class="string">&quot;Thousand&quot;</span>, <span class="string">&quot;Million&quot;</span>, <span class="string">&quot;Billion&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            num /= <span class="number">1000</span>;</span><br><span class="line">            res = num % <span class="number">1000</span> ? <span class="built_in">convertHundred</span>(num % <span class="number">1000</span>) + <span class="string">&quot; &quot;</span> + v[i] + <span class="string">&quot; &quot;</span> + res : res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (res.<span class="built_in">back</span>() == <span class="string">&#x27; &#x27;</span>) res.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">empty</span>() ? <span class="string">&quot;Zero&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">convertHundred</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; v1 = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&quot;Five&quot;</span>, <span class="string">&quot;Six&quot;</span>, <span class="string">&quot;Seven&quot;</span>, <span class="string">&quot;Eight&quot;</span>, <span class="string">&quot;Nine&quot;</span>, <span class="string">&quot;Ten&quot;</span>, <span class="string">&quot;Eleven&quot;</span>, <span class="string">&quot;Twelve&quot;</span>, <span class="string">&quot;Thirteen&quot;</span>, <span class="string">&quot;Fourteen&quot;</span>, <span class="string">&quot;Fifteen&quot;</span>, <span class="string">&quot;Sixteen&quot;</span>, <span class="string">&quot;Seventeen&quot;</span>, <span class="string">&quot;Eighteen&quot;</span>, <span class="string">&quot;Nineteen&quot;</span>&#125;;</span><br><span class="line">        vector&lt;string&gt; v2 = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Twenty&quot;</span>, <span class="string">&quot;Thirty&quot;</span>, <span class="string">&quot;Forty&quot;</span>, <span class="string">&quot;Fifty&quot;</span>, <span class="string">&quot;Sixty&quot;</span>, <span class="string">&quot;Seventy&quot;</span>, <span class="string">&quot;Eighty&quot;</span>, <span class="string">&quot;Ninety&quot;</span>&#125;;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> a = num / <span class="number">100</span>, b = num % <span class="number">100</span>, c = num % <span class="number">10</span>;</span><br><span class="line">        res = b &lt; <span class="number">20</span> ? v1[b] : v2[b / <span class="number">10</span>] + (c ? <span class="string">&quot; &quot;</span> + v1[c] : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) res = v1[a] + <span class="string">&quot; Hundred&quot;</span> + (b ? <span class="string">&quot; &quot;</span> + res : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode274-H-Index"><a href="#Leetcode274-H-Index" class="headerlink" title="Leetcode274. H-Index"></a>Leetcode274. H-Index</h1><p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>
<p>According to the definition of h-index on Wikipedia: “A scientist has index  h  if  h  of his/her  N  papers have at least h  citations each, and the other  N − h  papers have no more than  h  citations each.”</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: citations = [3,0,6,1,5]</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had </span><br><span class="line">             received 3, 0, 6, 1, 5 citations respectively. </span><br><span class="line">             Since the researcher has 3 papers with at least 3 citations each and the remaining </span><br><span class="line">             two with no more than 3 citations each, her h-index is 3.</span><br></pre></td></tr></table></figure><br>Note: If there are several possible values for  h , the maximum one is taken as the h-index.</p>
<p>这道题让我们求H指数，这个质数是用来衡量研究人员的学术水平的质数，定义为一个人的学术文章有n篇分别被引用了n次，那么H指数就是n。而且wiki上直接给出了算法，可以按照如下方法确定某人的H指数：1、将其发表的所有SCI论文按被引次数从高到低排序；2、从前往后查找排序后的列表，直到某篇论文的序号大于该论文被引次数。所得序号减一即为H指数。我也就没多想，直接按照上面的方法写出了代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(citations.<span class="built_in">begin</span>(), citations.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, size = citations.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (citations[i] &gt;= size-i) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, size-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode275-H-Index-II"><a href="#Leetcode275-H-Index-II" class="headerlink" title="Leetcode275. H-Index II"></a>Leetcode275. H-Index II</h1><p>Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>
<p>According to the definition of h-index on Wikipedia: “A scientist has index  h  if  h  of his/her  N  papers have at least  h  citations each, and the other  N − h  papers have no more than  h citations each.”</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: citations = [0,1,3,5,6]</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had </span><br><span class="line">             received 0, 1, 3, 5, 6 citations respectively. </span><br><span class="line">             Since the researcher has 3 papers with at least 3 citations each and the remaining </span><br><span class="line">             two with no more than 3 citations each, her h-index is 3.</span><br></pre></td></tr></table></figure></p>
<p>Note: If there are several possible values for  h , the maximum one is taken as the h-index.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = citations.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = size<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (citations[mid] == size-mid)</span><br><span class="line">                <span class="keyword">return</span> size-mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (citations[mid] &gt; size-mid)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size - left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode278-First-Bad-Version"><a href="#Leetcode278-First-Bad-Version" class="headerlink" title="Leetcode278. First Bad Version"></a>Leetcode278. First Bad Version</h1><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>
<p>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
<p>Example:</p>
<p>Given n = 5, and version = 4 is the first bad version.</p>
<p>call isBadVersion(3) -&gt; false<br>call isBadVersion(5) -&gt; true<br>call isBadVersion(4) -&gt; true</p>
<p>Then 4 is the first bad version. </p>
<ol>
<li>找出一个序列中第一个出错的位置，可以理解位这个序列是有序的，利用二分查找找到第一个位置</li>
<li>二分查找在处理的时候，如果不是，start = mid + 1;  是的话应该直接赋值start， 因为这时候这个值有可能就是第一个值</li>
<li>为什么要用 start + （end - start)/2 这种写法，而不是直接用（start + end）/2？这是为了防止大数溢出，假设这时候start已经是一个很大的数了，就会产生溢出<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">VersionControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>, end = n;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end - start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(!isBadVersion(mid))  start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Leetcode279-Perfect-Squares"><a href="#Leetcode279-Perfect-Squares" class="headerlink" title="Leetcode279. Perfect Squares"></a>Leetcode279. Perfect Squares</h1><p>Given a positive integer  n , find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to  n.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 12</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: 12 = 4 + 4 + 4.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 = 4 + 9.</span><br></pre></td></tr></table></figure></p>
<p>这道题说是给我们一个正整数，求它最少能由几个完全平方数组成。这道题是考察四平方和定理。先来看第一种很高效的方法，根据四平方和定理，任意一个正整数均可表示为4个整数的平方和，其实是可以表示为4个以内的平方数之和，那么就是说返回结果只有 1,2,3 或4其中的一个，首先我们将数字化简一下，由于一个数如果含有因子4，那么我们可以把4都去掉，并不影响结果，比如2和8,3和12等等，返回的结果都相同，读者可自行举更多的栗子。还有一个可以化简的地方就是，如果一个数除以8余7的话，那么肯定是由4个完全平方数组成，这里就不证明了，因为我也不会证明，读者可自行举例验证。那么做完两步后，一个很大的数有可能就会变得很小了，大大减少了运算时间，下面我们就来尝试的将其拆为两个平方数之和，如果拆成功了那么就会返回1或2，因为其中一个平方数可能为0。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">4</span> == <span class="number">0</span>) n /= <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">8</span> == <span class="number">7</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a * a &lt;= n; ++a) &#123;</span><br><span class="line">            <span class="type">int</span> b = <span class="built_in">sqrt</span>(n - a * a);</span><br><span class="line">            <span class="keyword">if</span> (a * a + b * b == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> !!a + !!b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这道题远不止这一种解法，我们还可以用动态规划 Dynamic Programming 来做，我们建立一个长度为 n+1 的一维dp数组，将第一个值初始化为0，其余值都初始化为<code>INT_MAX</code>，i从0循环到n，j从1循环到<code>i+j&lt;=n</code>的位置，然后每次更新<code>dp[i+j]</code>的值，动态更新 dp 数组，其中<code>dp[i]</code>表示正整数i至少由多个完全平方数组成，那么我们求n，就是返回<code>dp[n]</code>即可，也就是 dp 数组的最后一个数字。需要注意的是这里的写法，i必须从0开始，j必须从1开始，因为我们的初衷是想用<code>dp[i]</code>来更新<code>dp[i + j * j]</code>，如果<code>i=0</code>，<code>j=1</code>了，那么<code>dp[i]</code>和<code>dp[i + j * j]</code>就相等了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; i + j * j &lt;= n; ++j) &#123;</span><br><span class="line">                dp[i + j * j] = <span class="built_in">min</span>(dp[i + j * j], dp[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode282-Expression-Add-Operators"><a href="#Leetcode282-Expression-Add-Operators" class="headerlink" title="Leetcode282. Expression Add Operators"></a>Leetcode282. Expression Add Operators</h1><p>Given a string that contains only digits 0-9 and a target value, return all possibilities to add binaryoperators (not unary) +, -, or * between the digits so they evaluate to the target value.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: _num_ = &quot;123&quot;, _target_ = 6</span><br><span class="line">Output: [&quot;1+2+3&quot;, &quot;1*2*3&quot;] </span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: _num_ = &quot;232&quot;, _target_ = 8</span><br><span class="line">Output: [&quot;2*3+2&quot;, &quot;2+3*2&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: _num_ = &quot;105&quot;, _target_ = 5</span><br><span class="line">Output: [&quot;1*0+5&quot;,&quot;10-5&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: _num_ = &quot;00&quot;, _target_ = 0</span><br><span class="line">Output: [&quot;0+0&quot;, &quot;0-0&quot;, &quot;0*0&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: _num_ = &quot;3456237490&quot;, _target_ = 9191</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个只由数字组成的字符串，让我们再其中添加+,-或号来形成一个表达式，该表达式的计算和为给定了target值，让我们找出所有符合要求的表达式来。看了题目中的例子1和2，很容易让人误以为是必须拆成个位数字，其实不是的，比如例子3中的 “105”, 5能返回”10-5”，说明连着的数字也可以。如果非要在过往的题中找一道相似的题，我觉得跟 Combination Sum II 很类似。不过这道题要更复杂麻烦一些。还是用递归来解题，我们需要两个变量diff和curNum，一个用来记录将要变化的值，另一个是当前运算后的值，而且它们都需要用 long 型的，因为字符串转为int型很容易溢出，所以我们用长整型。对于加和减，diff就是即将要加上的数和即将要减去的数的负值，而对于乘来说稍有些复杂，此时的diff应该是上一次的变化的diff乘以即将要乘上的数，有点不好理解，那我们来举个例子，比如 2+32，即将要运算到乘以2的时候，上次循环的 curNum = 5, diff = 3, 而如果我们要算这个乘2的时候，新的变化值diff应为 32=6，而我们要把之前+3操作的结果去掉，再加上新的diff，即 (5-3)+6=8，即为新表达式 2+32 的值，有点难理解，大家自己一步一步推算吧。</p>
<p>还有一点需要注意的是，如果输入为”000”,0的话，容易出现以下的错误：</p>
<p>Wrong：[“0+0+0”,”0+0-0”,”0+00”,”0-0+0”,”0-0-0”,”0-00”,”00+0”,”00-0”,”000”,”0+00”,”0-00”,”000”,”00+0”,”00-0”,”000”,”000”]</p>
<p>Correct：[“000”,”00+0”,”00-0”,”0+00”,”0+0+0”,”0+0-0”,”0-00”,”0-0+0”,”0-0-0”]</p>
<p>我们可以看到错误的结果中有0开头的字符串出现，明显这不是数字，所以我们要去掉这些情况，过滤方法也很简单，我们只要判断长度大于1且首字符是‘0’的字符串，将其滤去即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">addOperators</span><span class="params">(string num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="built_in">helper</span>(num, target, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(string num, <span class="type">int</span> target, <span class="type">long</span> diff, <span class="type">long</span> curNum, string out, vector&lt;string&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; curNum == target) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(out); <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            string cur = num.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (cur.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; cur[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">            string next = num.<span class="built_in">substr</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (out.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">helper</span>(next, target, <span class="built_in">stoll</span>(cur), curNum + <span class="built_in">stoll</span>(cur), out + <span class="string">&quot;+&quot;</span> + cur, res);</span><br><span class="line">                <span class="built_in">helper</span>(next, target, -<span class="built_in">stoll</span>(cur), curNum - <span class="built_in">stoll</span>(cur), out + <span class="string">&quot;-&quot;</span> + cur, res);</span><br><span class="line">                <span class="built_in">helper</span>(next, target, diff * <span class="built_in">stoll</span>(cur), (curNum - diff) + diff * <span class="built_in">stoll</span>(cur), out + <span class="string">&quot;*&quot;</span> + cur, res);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">helper</span>(next, target, <span class="built_in">stoll</span>(cur), <span class="built_in">stoll</span>(cur), cur, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> target;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; exp, <span class="type">int</span> pos, <span class="type">long</span> <span class="type">long</span> sum, <span class="type">long</span> <span class="type">long</span> lastval)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == target) </span><br><span class="line">                res.<span class="built_in">push_back</span>(exp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">const</span> string ops = pos == <span class="number">0</span> ? <span class="string">&quot;+&quot;</span> : <span class="string">&quot;+-*&quot;</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt; s.<span class="built_in">length</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; pos &amp;&amp; s[pos] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            val = val * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 整个s的第一个符号只能是+</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> op : ops) &#123;            </span><br><span class="line">                string newexpr;</span><br><span class="line">                <span class="keyword">if</span> (!pos) </span><br><span class="line">                    newexpr = s.<span class="built_in">substr</span>(pos, i-pos+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    newexpr = exp + <span class="built_in">string</span>(<span class="number">1</span>, op) + s.<span class="built_in">substr</span>(pos, i-pos+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(newexpr, i+<span class="number">1</span>, sum+val, val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(newexpr, i+<span class="number">1</span>, sum - val, -val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(newexpr, i+<span class="number">1</span>, sum - lastval + lastval * val, lastval * val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">addOperators</span><span class="params">(string num, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = num;</span><br><span class="line">        <span class="keyword">this</span>-&gt;target = target;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode283-Move-Zeroes"><a href="#Leetcode283-Move-Zeroes" class="headerlink" title="Leetcode283. Move Zeroes"></a>Leetcode283. Move Zeroes</h1><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,3,12]</span><br><span class="line">Output: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><br>Note:</p>
<ul>
<li>You must do this in-place without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ul>
<p>把0移动到数组末尾：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt; nums.<span class="built_in">size</span>() &amp;&amp; end &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            end = begin;</span><br><span class="line">            <span class="keyword">if</span>(nums[begin] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(end &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[end] == <span class="number">0</span>)</span><br><span class="line">                    end ++;</span><br><span class="line">                <span class="keyword">if</span>(end == nums.<span class="built_in">size</span>())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="type">int</span> temp = nums[begin];</span><br><span class="line">                nums[begin] = nums[end];</span><br><span class="line">                nums[end] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            begin ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>优化方法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> lastNonZeroFoundAt = <span class="number">0</span>, cur = <span class="number">0</span>; cur &lt; nums.<span class="built_in">size</span>(); cur++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[cur] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[lastNonZeroFoundAt++], nums[cur]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode287-Find-the-Duplicate-Number"><a href="#Leetcode287-Find-the-Duplicate-Number" class="headerlink" title="Leetcode287. Find the Duplicate Number"></a>Leetcode287. Find the Duplicate Number</h1><p>Given an array  nums  containing  n  + 1 integers where each integer is between 1 and  n  (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>You must not modify the array (assume the array is read only).</li>
<li>You must use only constant,  O (1) extra space.</li>
<li>Your runtime complexity should be less than  O ( n 2).</li>
<li>There is only one duplicate number in the array, but it could be repeated more than once.</li>
</ul>
<p>这道题给了我们 n+1 个数，所有的数都在 [1, n] 区域内，首先让证明必定会有一个重复数，这不禁让博主想起了小学华罗庚奥数中的抽屉原理(又叫鸽巢原理)，即如果有十个苹果放到九个抽屉里，如果苹果全在抽屉里，则至少有一个抽屉里有两个苹果，这里就不证明了，直接来做题吧。题目要求不能改变原数组，即不能给原数组排序，又不能用多余空间，那么哈希表神马的也就不用考虑了，又说时间小于 O(n2)，也就不能用 brute force 的方法，那也就只能考虑用二分搜索法了，在区间 [1, n] 中搜索，首先求出中点 mid，然后遍历整个数组，统计所有小于等于 mid 的数的个数，如果个数小于等于 mid，则说明重复值在 [mid+1, n] 之间，反之，重复值应在 [1, mid-1] 之间，然后依次类推，直到搜索完成，此时的 low 就是我们要求的重复值，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>, cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= mid) ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= mid) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一种方法的基本思想是将数组抽象为一条线和一个圆环，因为1～n之间有n＋1个数，所以一定有重复数字出现，所以重复的数字即是圆环与线的交汇点。然后设置两个指针，一个快指针一次走两步，一个慢指针一次走一步。当两个指针第一次相遇时，令快指针回到原点（0）且也变成一次走一步，慢指针则继续前进，再次回合时即是线与圆环的交汇点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fast = nums[nums[<span class="number">0</span>]], slow = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(fast != slow) &#123;</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">        &#125;</span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != slow) &#123;</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode289-Game-of-Life"><a href="#Leetcode289-Game-of-Life" class="headerlink" title="Leetcode289. Game of Life"></a>Leetcode289. Game of Life</h1><p>According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p>
<p>Given a  board  with  m  by  n  cells, each cell has an initial state  live  (1) or  dead  (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>
<ul>
<li>Any live cell with fewer than two live neighbors dies, as if caused by under-population.</li>
<li>Any live cell with two or three live neighbors lives on to the next generation.</li>
<li>Any live cell with more than three live neighbors dies, as if by over-population..</li>
<li>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</li>
</ul>
<p>Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,1],</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: </span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,1,1],</span><br><span class="line">  [0,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>Follow up:</p>
<ul>
<li>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.</li>
<li>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</li>
</ul>
<p>这道题是有名的 康威生命游戏，这是一种细胞自动机，每一个位置有两种状态，1为活细胞，0为死细胞，对于每个位置都满足如下的条件：</p>
<ol>
<li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡</li>
<li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活</li>
<li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡</li>
<li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活</li>
</ol>
<p>由于题目中要求用置换方法 in-place 来解题，所以就不能新建一个相同大小的数组，那么只能更新原有数组，题目中要求所有的位置必须被同时更新，但在循环程序中还是一个位置一个位置更新的，当一个位置更新了，这个位置成为其他位置的 neighbor 时，怎么知道其未更新的状态呢？可以使用状态机转换：</p>
<ul>
<li>状态0： 死细胞转为死细胞</li>
<li>状态1： 活细胞转为活细胞</li>
<li>状态2： 活细胞转为死细胞</li>
<li>状态3： 死细胞转为活细胞</li>
</ul>
<p>最后对所有状态对2取余，则状态0和2就变成死细胞，状态1和3就是活细胞，达成目的。先对原数组进行逐个扫描，对于每一个位置，扫描其周围八个位置，如果遇到状态1或2，就计数器累加1，扫完8个邻居，如果少于两个活细胞或者大于三个活细胞，而且当前位置是活细胞的话，标记状态2，如果正好有三个活细胞且当前是死细胞的话，标记状态3。完成一遍扫描后再对数据扫描一遍，对2取余变成我们想要的结果。参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gameOfLife</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = m ? board[<span class="number">0</span>].<span class="built_in">size</span>() : <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dx&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dy&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k) &#123;</span><br><span class="line">                    <span class="type">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; (board[x][y] == <span class="number">1</span> || board[x][y] == <span class="number">2</span>)) &#123;</span><br><span class="line">                        ++cnt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] &amp;&amp; (cnt &lt; <span class="number">2</span> || cnt &gt; <span class="number">3</span>)) board[i][j] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!board[i][j] &amp;&amp; cnt == <span class="number">3</span>) board[i][j] = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                board[i][j] %= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode290-Word-Pattern"><a href="#Leetcode290-Word-Pattern" class="headerlink" title="Leetcode290. Word Pattern"></a>Leetcode290. Word Pattern</h1><p>Given a pattern and a string str, find if str follows the same pattern.</p>
<p>Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Notes:<br>You may assume pattern contains only lowercase letters, and str contains lowercase letters that may be separated by a single space.</p>
<p>给定一种规律 pattern 和一个字符串 str ，判断 str 中的单词和pattern的字母是否遵循相同的映射， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。</p>
<p>自己的代码，在测评的帮助下加了很多的boundary case，超过了双百：</p>
<ul>
<li>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Word Pattern.</li>
<li>Memory Usage: 6.7 MB, less than 100.00% of C++ online submissions for Word Pattern.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordPattern</span><span class="params">(string pattern, string str)</span> </span>&#123;</span><br><span class="line">        map&lt;string, <span class="type">char</span>&gt; mapp;</span><br><span class="line">        string word;</span><br><span class="line">        str.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>, count=<span class="number">0</span>;;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            word=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(str[i]!=<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                word += str[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            count ++; <span class="comment">// str一共有多少个单词</span></span><br><span class="line">            <span class="keyword">if</span> (mapp.<span class="built_in">find</span>(word)==mapp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(temp&lt;j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pattern[temp]==pattern[j])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    temp ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp == j)</span><br><span class="line">                    mapp[word] = pattern[j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> (mapp[word] != pattern[j])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count != pattern.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看看人家的思路：这道题目主要考察哈希表和字符串的内容。可以将题目拆解为下面三步：</p>
<ul>
<li>设置pattern字符到单词（字符串 str）的映射（哈希），使用HashMap()存储；使用HashSet() 记录被使用过的单词  。</li>
<li>若单词个数和pattern字符个数不匹配，返回false；</li>
<li>遍历pattern，同时对应的向前移动 str 中单词的指针，每次拆分出pattern中的一个字符， 判断：<ul>
<li>如果该字符从未出现在哈希表中：</li>
<li>如果该字符对应的单词已被使用过 ，即<code>HashSet()</code>中包含该字符对应的单词，则返回false；</li>
<li>将该字符与其对应的单词做映射，加入哈希表中；标记该字符指向的单词为已使用，并加入<code>HashSet()</code>；</li>
<li>如果该字符在哈希表的映射单词与当前指向的单词不同，则返回false；</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">wordPattern</span><span class="params">(String pattern, String str)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        String[] array = str.<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pattern.<span class="built_in">length</span>() != array.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pattern.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> key = pattern.<span class="built_in">charAt</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (!map.<span class="built_in">containsKey</span>(key)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (set.<span class="built_in">contains</span>(array[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                map.<span class="built_in">put</span>(key, array[i]);</span><br><span class="line">                set.<span class="built_in">add</span>(array[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!map.<span class="built_in">get</span>(key).<span class="built_in">equals</span>(array[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode292-Nim-Game"><a href="#Leetcode292-Nim-Game" class="headerlink" title="Leetcode292. Nim Game"></a>Leetcode292. Nim Game</h1><p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>
<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: false </span><br><span class="line">Explanation: If there are 4 stones in the heap, then you will never win the game;</span><br><span class="line">             No matter 1, 2, or 3 stones you remove, the last stone will always be </span><br><span class="line">             removed by your friend.</span><br></pre></td></tr></table></figure><br>规律就是当有4,8,12,16….4n…时，我一定输；其他情况我一定赢。</p>
<p>因为当为4n时，我拿后剩下4n-1,4n-2,4n-3块，对方可以拿到4n-4=4(n-1)块。然后我再拿，对方再拿到4(n-2)块。。无论我怎么拿，对方总能拿到最后剩下4块。。。这样我就输了。同理，不为4n时，我总能拿到4n，这样对方就输了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:      </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode293-Flip-Game"><a href="#Leetcode293-Flip-Game" class="headerlink" title="Leetcode293. Flip Game"></a>Leetcode293. Flip Game</h1><p>You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip twoconsecutive “++” into “—“. The game ends when a person can no longer make a move and therefore the other person will be the winner.</p>
<p>Write a function to compute all possible states of the string after one valid move.</p>
<p>For example, given s = “++++”, after one move, it may become one of the following states:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;--++&quot;,</span><br><span class="line">  &quot;+--+&quot;,</span><br><span class="line">  &quot;++--&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>If there is no valid move, return an empty list [].</p>
<p>这道题让我们把相邻的两个 ++ 变成 —，真不是一道难题，就从第二个字母开始遍历，每次判断当前字母是否为+，和之前那个字母是否为+，如果都为加，则将翻转后的字符串存入结果中即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generatePossibleNextMoves</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, i - <span class="number">1</span>) + <span class="string">&quot;--&quot;</span> + s.<span class="built_in">substr</span>(i + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode295-Find-Median-from-Data-Stream"><a href="#Leetcode295-Find-Median-from-Data-Stream" class="headerlink" title="Leetcode295. Find Median from Data Stream"></a>Leetcode295. Find Median from Data Stream</h1><p>The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.</p>
<p>For example, for arr = [2,3,4], the median is 3.<br>For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.<br>Implement the MedianFinder class:</p>
<p>MedianFinder() initializes the MedianFinder object.<br>void addNum(int num) adds the integer num from the data stream to the data structure.<br>double findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span><br><span class="line">[[], [1], [2], [], [3], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 1.5, null, 2.0]</span><br></pre></td></tr></table></figure></p>
<p>Explanation<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MedianFinder medianFinder = new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    // arr = [1]</span><br><span class="line">medianFinder.addNum(2);    // arr = [1, 2]</span><br><span class="line">medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)</span><br><span class="line">medianFinder.addNum(3);    // arr[1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); // return 2.0</span><br></pre></td></tr></table></figure></p>
<p>这道题给我们一个数据流，让我们找出中位数，由于数据流中的数据并不是有序的，所以我们首先应该想个方法让其有序。如果我们用vector来保存数据流的话，每进来一个新数据都要给数组排序，很不高效。所以之后想到用multiset这个数据结构，是有序保存数据的，但是它不能用下标直接访问元素，找中位数也不高效。这里用到的解法十分巧妙，我们使用大小堆来解决问题，其中大堆保存右半段较大的数字，小堆保存左半段较小的数组。这样整个数组就被中间分为两段了，由于堆的保存方式是由大到小，我们希望大堆里面的数据是从小到大，这样取第一个来计算中位数方便。我们用到一个小技巧，就是存到大堆里的数先取反再存，这样由大到小存下来的顺序就是实际上我们想要的从小到大的顺序。当大堆和小堆中的数字一样多时，我们取出大堆小堆的首元素求平均值，当小堆元素多时，取小堆首元素为中位数，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adds a number into the data structure.</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        small.<span class="built_in">push</span>(num);</span><br><span class="line">        large.<span class="built_in">push</span>(-small.<span class="built_in">top</span>());</span><br><span class="line">        small.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (small.<span class="built_in">size</span>() &lt; large.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            small.<span class="built_in">push</span>(-large.<span class="built_in">top</span>());</span><br><span class="line">            large.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the median of current data stream</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> small.<span class="built_in">size</span>() &gt; large.<span class="built_in">size</span>() ? small.<span class="built_in">top</span>() : <span class="number">0.5</span> *(small.<span class="built_in">top</span>() - large.<span class="built_in">top</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">long</span>&gt; small, large;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="LeetCode296-Best-Meeting-Point"><a href="#LeetCode296-Best-Meeting-Point" class="headerlink" title="LeetCode296. Best Meeting Point"></a>LeetCode296. Best Meeting Point</h1><p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where <code>distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|</code>.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">1 - 0 - 0 - 0 - 1</span><br><span class="line">|   |   |   |   |</span><br><span class="line">0 - 0 - 0 - 0 - 0</span><br><span class="line">|   |   |   |   |</span><br><span class="line">0 - 0 - 1 - 0 - 0</span><br><span class="line"></span><br><span class="line">Output: 6 </span><br></pre></td></tr></table></figure></p>
<p>Explanation: Given three people living at (0,0), (0,4), and (2,2), The point (0,2) is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.</p>
<p>这道题让我们求最佳的开会地点，该地点需要到每个为1的点的曼哈顿距离之和最小，题目中给了提示，让从一维的情况来分析，先看一维时有两个点A和B的情况,<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">______A_____P_______B_______</span><br></pre></td></tr></table></figure></p>
<p>可以发现，只要开会为位置P在 [A, B] 区间内，不管在哪，距离之和都是A和B之间的距离，如果P不在 [A, B] 之间，那么距离之和就会大于A和B之间的距离，现在再加两个点C和D：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">______C_____A_____P_______B______D______</span><br></pre></td></tr></table></figure></p>
<p>通过分析可以得出，P点的最佳位置就是在 [A, B] 区间内，这样和四个点的距离之和为AB距离加上 CD 距离，在其他任意一点的距离都会大于这个距离，那么分析出来了上述规律，这题就变得很容易了，只要给位置排好序，然后用最后一个坐标减去第一个坐标，即 CD 距离，倒数第二个坐标减去第二个坐标，即 AB 距离，以此类推，直到最中间停止，那么一维的情况分析出来了，二维的情况就是两个一维相加即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minTotalDistance</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rows, cols;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    rows.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    cols.<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">minTotalDistance</span>(rows) + <span class="built_in">minTotalDistance</span>(cols);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minTotalDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) res += v[j--] - v[i++];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以不用多写一个函数，直接对 rows 和 cols 同时处理，稍稍能简化些代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minTotalDistance</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rows, cols;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    rows.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    cols.<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(cols.<span class="built_in">begin</span>(), cols.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = rows.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) res += rows[j] - rows[i] + cols[j--] - cols[i++];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode297-Serialize-and-Deserialize-Binary-Tree"><a href="#Leetcode297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="Leetcode297. Serialize and Deserialize Binary Tree"></a>Leetcode297. Serialize and Deserialize Binary Tree</h1><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,null,null,4,5]</span><br><span class="line">Output: [1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure></p>
<p>二叉树的序列化与反序列化<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">  * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">  *     int val;</span></span><br><span class="line"><span class="comment">  *     TreeNode *left;</span></span><br><span class="line"><span class="comment">  *     TreeNode *right;</span></span><br><span class="line"><span class="comment">  *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment">  * &#125;;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200000</span>;</span><br><span class="line"><span class="type">char</span> buf[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length)</span><br><span class="line">            buf[length++] = <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            buf[length++] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	        </span><br><span class="line">        string val = <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : val)</span><br><span class="line">            buf[length++] = c;</span><br><span class="line">	        </span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        buf[length] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">gen</span><span class="params">(string data, <span class="type">int</span>&amp; cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur &gt;= data.<span class="built_in">length</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (data[cur] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            cur += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>, val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (data[cur] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            cur ++;</span><br><span class="line">            flag = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	        </span><br><span class="line">        <span class="keyword">while</span>(cur &lt; data.<span class="built_in">length</span>() &amp;&amp; data[cur] != <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">            val = val * <span class="number">10</span> + data[cur] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            cur ++;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(flag * val);</span><br><span class="line">        cur ++;</span><br><span class="line">        root-&gt;left = <span class="built_in">gen</span>(data, cur);</span><br><span class="line">        root-&gt;right = <span class="built_in">gen</span>(data, cur);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gen</span>(data, cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser, deser;</span></span><br><span class="line"><span class="comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode299-Bulls-and-Cows"><a href="#Leetcode299-Bulls-and-Cows" class="headerlink" title="Leetcode299. Bulls and Cows"></a>Leetcode299. Bulls and Cows</h1><p>You are playing the following Bulls and Cows game with your friend: You write a 4-digit secret number and ask your friend to guess it, each time your friend guesses a number, you give a hint, the hint tells your friend how many digits are in the correct positions (called “bulls”) and how many digits are in the wrong positions (called “cows”), your friend will use those hints to find out the secret number.</p>
<p>For example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Secret number:  1807</span><br><span class="line">Friend&#x27;s guess: 7810</span><br></pre></td></tr></table></figure></p>
<p>According to Wikipedia: “Bulls and Cows (also known as Cows and Bulls or Pigs and Bulls or Bulls and Cleots) is an old code-breaking mind or paper and pencil game for two or more players, predating the similar commercially marketed board game Mastermind. The numerical version of the game is usually played with 4 digits, but can also be played with 3 or any other number of digits.”</p>
<p>Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows, in the above example, your function should return 1A3B.</p>
<p>You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.</p>
<p>这道题提出了一个叫公牛母牛的游戏，有一个四位数字，你猜一个结果，然后根据你猜的结果和真实结果做对比，提示有多少个数字和位置都正确的叫做bulls，还提示有多少数字正确但位置不对的叫做cows，根据这些信息来引导我们继续猜测正确的数字。这道题并没有让我们实现整个游戏，而只用实现一次比较即可。给出两个字符串，让我们找出分别几个bulls和cows。这题需要用哈希表，来建立数字和其出现次数的映射。我最开始想的方法是用两次遍历，第一次遍历找出所有位置相同且值相同的数字，即bulls，并且记录secret中不是bulls的数字出现的次数。然后第二次遍历我们针对guess中不是bulls的位置，如果在哈希表中存在，cows自增1，然后映射值减1，参见如下代码：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getHint</span><span class="params">(string secret, string guess)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, bulls = <span class="number">0</span>, cows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; secret.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (secret[i] == guess[i]) ++bulls;</span><br><span class="line">            <span class="keyword">else</span> ++m[secret[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; secret.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (secret[i] != guess[i] &amp;&amp; m[guess[i]]) &#123;</span><br><span class="line">                ++cows;</span><br><span class="line">                --m[guess[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(bulls) + <span class="string">&quot;A&quot;</span> + <span class="built_in">to_string</span>(cows) + <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们其实可以用一次循环就搞定的，在处理不是bulls的位置时，我们看如果secret当前位置数字的映射值小于0，则表示其在guess中出现过，cows自增1，然后映射值加1，如果guess当前位置的数字的映射值大于0，则表示其在secret中出现过，cows自增1，然后映射值减1，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getHint</span><span class="params">(string secret, string guess)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, bulls = <span class="number">0</span>, cows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; secret.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (secret[i] == guess[i]) ++bulls;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (m[secret[i]]++ &lt; <span class="number">0</span>) ++cows;</span><br><span class="line">                <span class="keyword">if</span> (m[guess[i]]-- &gt; <span class="number">0</span>) ++ cows;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(bulls) + <span class="string">&quot;A&quot;</span> + <span class="built_in">to_string</span>(cows) + <span class="string">&quot;B&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode300-Longest-Increasing-Subsequence"><a href="#Leetcode300-Longest-Increasing-Subsequence" class="headerlink" title="Leetcode300. Longest Increasing Subsequence"></a>Leetcode300. Longest Increasing Subsequence</h1><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,9,2,5,3,7,101,18]</span><br><span class="line">Output: 4 </span><br><span class="line">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. </span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>There may be more than one LIS combination, it is only necessary for you to return the length.</li>
<li>Your algorithm should run in O( n2 ) complexity.</li>
</ul>
<p>这道题让我们求最长递增子串 Longest Increasing Subsequence 的长度，简称 LIS 的长度。首先来看一种动态规划 Dynamic Programming 的解法，这种解法的时间复杂度为 O(n2)，类似 brute force 的解法，维护一个一维 dp 数组，其中 dp[i] 表示以 nums[i] 为结尾的最长递增子串的长度，对于每一个 nums[i]，从第一个数再搜索到i，如果发现某个数小于 nums[i]，更新 dp[i]，更新方法为 dp[i] = max(dp[i], dp[j] + 1)，即比较当前 dp[i] 的值和那个小于 num[i] 的数的 dp 值加1的大小，就这样不断的更新 dp 数组，到最后 dp 数组中最大的值就是要返回的 LIS 的长度，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面来看一种优化时间复杂度到 O(nlgn) 的解法，这里用到了二分查找法，所以才能加快运行时间哇。思路是，先建立一个数组 ends，把首元素放进去，然后比较之后的元素，如果遍历到的新元素比 ends 数组中的首元素小的话，替换首元素为此新元素，如果遍历到的新元素比 ends 数组中的末尾元素还大的话，将此新元素添加到 ends 数组末尾(注意不覆盖原末尾元素)。如果遍历到的新元素比 ends 数组首元素大，比尾元素小时，此时用二分查找法找到第一个不小于此新元素的位置，覆盖掉位置的原来的数字，以此类推直至遍历完整个 nums 数组，此时 ends 数组的长度就是要求的LIS的长度，特别注意的是 ends 数组的值可能不是一个真实的 LIS，比如若输入数组 nums 为 {4, 2， 4， 5， 3， 7}，那么算完后的 ends 数组为 {2， 3， 5， 7}，可以发现它不是一个原数组的 LIS，只是长度相等而已，千万要注意这点。参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ends&#123;nums[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &lt; ends[<span class="number">0</span>]) ends[<span class="number">0</span>] = a;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; ends.<span class="built_in">back</span>()) ends.<span class="built_in">push_back</span>(a);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> left = <span class="number">0</span>, right = ends.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (ends[mid] &lt; a) left = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                ends[right] = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ends.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/12/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">130</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
