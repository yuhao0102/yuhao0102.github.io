<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="TAUTAU是一个面向MPI与OpenMP并行程序的profiler，在目前看到的OpenMPI的Profiler中算是比较健全的一个（x）。官网：https:&#x2F;&#x2F;www.cs.uoregon.edu&#x2F;research&#x2F;tau&#x2F;home.php 。 其实Intel的vtune也不是不能用，但是面向OpenMPI的时候会有些限制。TAU可以根据不同的MPI发行版重新编译，感觉会好一些。 安装官方的I">
<meta property="og:type" content="article">
<meta property="og:title" content="gdb、git、qsub、tmux、memcached开发工具相关">
<meta property="og:url" content="http://yoursite.com/2022/12/26/GDB_GIT_qsub_tmux%E7%AD%89%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="TAUTAU是一个面向MPI与OpenMP并行程序的profiler，在目前看到的OpenMPI的Profiler中算是比较健全的一个（x）。官网：https:&#x2F;&#x2F;www.cs.uoregon.edu&#x2F;research&#x2F;tau&#x2F;home.php 。 其实Intel的vtune也不是不能用，但是面向OpenMPI的时候会有些限制。TAU可以根据不同的MPI发行版重新编译，感觉会好一些。 安装官方的I">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/3149063-20230326103354863-88530209.png">
<meta property="og:image" content="http://yoursite.com/img/3149063-20230326103354863-88530210.png">
<meta property="og:image" content="http://blog.chinaunix.net/attachment/201209/16/24774106_1347798530g9dm.png">
<meta property="og:image" content="http://blog.chinaunix.net/attachment/201209/16/24774106_1347800246pw43.png">
<meta property="og:image" content="http://yoursite.com/img/16060378746.jpg">
<meta property="og:image" content="http://yoursite.com/img/16060378749.jpg">
<meta property="og:image" content="http://yoursite.com/img/16060378750.jpg">
<meta property="og:image" content="http://yoursite.com/img/16060378751.jpg">
<meta property="og:image" content="http://yoursite.com/img/16060378752.jpg">
<meta property="og:image" content="https://github.com/digoal/blog/raw/master/201611/20161127_01_pic_003.png">
<meta property="og:image" content="http://yoursite.com/img/588461c83dfa4e419f68a4e1d3d0e18b.png">
<meta property="og:image" content="http://yoursite.com/img/1bf4c7db76f94c9dbad142c13dba220f.png">
<meta property="og:image" content="http://yoursite.com/img/2df8aecfda6d4fc5a0cca1471f36322b.png">
<meta property="og:image" content="http://yoursite.com/img/70194a30f6684349a5be1c585598045b.png">
<meta property="og:image" content="http://yoursite.com/img/aa9b553b39f74c68bb9b3e44527ab2f6.png">
<meta property="og:image" content="http://yoursite.com/img/a9c0895165e34c089a20f39a707ea26a.png">
<meta property="og:image" content="http://yoursite.com/img/c0f34b91bdd844f6ba16714a2c8d8ce0.png">
<meta property="og:image" content="http://yoursite.com/img/4c3ba21b8747479998fd31addc4e0485.png">
<meta property="og:image" content="http://yoursite.com/img/bb011d16353846ffa403d72df425e4bb.png">
<meta property="og:image" content="http://yoursite.com/img/20190421001.png">
<meta property="og:image" content="http://yoursite.com/img/20191008001.png">
<meta property="og:image" content="http://yoursite.com/img/20191008002.png">
<meta property="og:image" content="http://yoursite.com/img/20191008003.png">
<meta property="og:image" content="http://yoursite.com/img/20191008004.png">
<meta property="og:image" content="http://yoursite.com/img/20191008005.png">
<meta property="og:image" content="http://yoursite.com/img/20191008006.png">
<meta property="og:image" content="http://yoursite.com/img/20191008007.png">
<meta property="og:image" content="http://yoursite.com/img/20191008008.png">
<meta property="og:image" content="http://yoursite.com/img/20191008009.png">
<meta property="og:image" content="http://yoursite.com/img/20191008010.png">
<meta property="og:image" content="http://yoursite.com/img/20191008011.png">
<meta property="article:published_time" content="2022-12-26T12:15:00.000Z">
<meta property="article:modified_time" content="2023-09-08T01:53:21.850Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="积累">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/3149063-20230326103354863-88530209.png">

<link rel="canonical" href="http://yoursite.com/2022/12/26/GDB_GIT_qsub_tmux%E7%AD%89%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>gdb、git、qsub、tmux、memcached开发工具相关 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/12/26/GDB_GIT_qsub_tmux%E7%AD%89%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          gdb、git、qsub、tmux、memcached开发工具相关
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-26 20:15:00" itemprop="dateCreated datePublished" datetime="2022-12-26T20:15:00+08:00">2022-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-08 09:53:21" itemprop="dateModified" datetime="2023-09-08T09:53:21+08:00">2023-09-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="TAU"><a href="#TAU" class="headerlink" title="TAU"></a>TAU</h1><p>TAU是一个面向MPI与OpenMP并行程序的profiler，在目前看到的OpenMPI的Profiler中算是比较健全的一个（x）。官网：<a href="https://www.cs.uoregon.edu/research/tau/home.php">https://www.cs.uoregon.edu/research/tau/home.php</a> 。</p>
<p>其实Intel的vtune也不是不能用，但是面向OpenMPI的时候会有些限制。TAU可以根据不同的MPI发行版重新编译，感觉会好一些。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方的INSTALL中给出的configure建议参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copy% ./configure -c++=mpicxx -cc=mpicc -fortran=mpif90 -mpi -ompt -iowrapper -bfd=download -dwarf=download -otf=download -unwind=download -pdt=&lt;path_to_pdt_dir&gt;</span><br></pre></td></tr></table></figure>
<p>pdt不使用，因为是一个挺大的东西，目前还没用过。而且一般profile到第二层就足够了（见使用部分）。ompt也有比较大的概率不支持，可以直接关掉。ompt是貌似是OpenMP提供给外部工具的一个接口，如果没有OpenMP成分的话关掉没什么影响。（<a href="https://www.openmp.org/spec-html/5.0/openmpsu15.html）">https://www.openmp.org/spec-html/5.0/openmpsu15.html）</a></p>
<p>之后发现BFD也是直接下载不了，关了。没发现有什么用。</p>
<p>最后改成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copy./configure -c++=mpicxx -cc=mpicc -fortran=mpif90 -mpi -iowrapper -dwarf=download -otf=download -unwind=download -prefix=&lt;prefix&gt;</span><br></pre></td></tr></table></figure>
<p>configure结束之后有提示。根据提示添加一下PATH，然后直接make install即可。TAU的编译过程是内含在install过程中的。</p>
<p>在make install的过程中，大概率是要报错的。这也是TAU比较令我无语的一个地方……它的动态库编译flag基本上都是错的。需要进行一个手动修改。</p>
<p>在主目录的Makefile下，在Line 195左右的位置，把编译命令换成：</p>
<p>（-diag-disable是针对intel编译器的，如果不是intel编译器记得去掉。其实都可以去掉，但是现在用icc不加这个选项就会报出一堆的warning，看着心烦）</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copy@echo <span class="string">&quot;*********** RECURSIVELY MAKING SUBDIRECTORIES ***********&quot;</span></span><br><span class="line">        @for i in $&#123;SUBDIR&#125;; do (echo <span class="string">&quot;*** COMPILING $$i DIRECTORY&quot;</span>; cd $$i;\</span><br><span class="line">             <span class="variable">$(MAKE)</span> <span class="string">&quot;MAKE=<span class="variable">$(MAKE)</span>&quot;</span> <span class="string">&quot;CC=<span class="variable">$(CC)</span> -diag-disable=10441 -fPIC&quot;</span> <span class="string">&quot;TAU_F90=<span class="variable">$(TAU_F90)</span> -fPIC&quot;</span> <span class="string">&quot;TAU_CC=<span class="variable">$(TAU_CC)</span> -fPIC&quot;</span> <span class="string">&quot;CXX=<span class="variable">$(CXX)</span> -diag-disable=10441 -fPIC&quot;</span> <span class="string">&quot;AR_SHFLAGS=-shared&quot;</span> <span class="string">&quot;TAU_SHFLAGS=-shared -o&quot;</span> install ) || exit $<span class="variable">$?</span>; done</span><br></pre></td></tr></table></figure>
<p>这里其实就是改了一堆flag。这样编译就可以正常通过了。至此完成安装。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>TAU提供了三种详细程度不同的profile：</p>
<p><img src="/img/3149063-20230326103354863-88530209.png" alt="截屏2023-03-24 上午10.09.29"></p>
<p>简单来说，三种profile方式详细程度逐渐提高，但最粗略的不需要重新编译，第二种需要重新编译，最详细的一种要求使用PDT。</p>
<h3 id="interposition"><a href="#interposition" class="headerlink" title="interposition"></a>interposition</h3><p>这个最简单。从</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copympirun <span class="tag">&lt;<span class="name">mpi-args</span>&gt;</span> <span class="tag">&lt;<span class="name">program</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>换成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copympirun &lt;mpi-args&gt; tau_exec &lt;program&gt; </span><br></pre></td></tr></table></figure>
<p>即可。熟悉vtune的话会觉得差不多。</p>
<p>这样的方式可以得到各个MPI函数的占用的时间，但是没法得到callpath等更细致的信息。</p>
<h3 id="recompile"><a href="#recompile" class="headerlink" title="recompile"></a>recompile</h3><p>需要重新编译。</p>
<p>TAU的configure方式比较特殊。如果在配置完一个TAU之后，再在相同的目录下configure一个配置不同的TAU，其内容不会被覆盖，而是两个版本并存。TAU通过一个Makefile来决定使用哪种配置，Makefile在<code>&lt;prefix&gt;/x86_64/lib</code>下。</p>
<p>相应控制TAU的配置的环境变量是<code>TAU_MAKEFILE</code>.</p>
<p>TAU提供的编译器是<code>tau_cc.sh</code>,<code>tau_f90.sh</code>等，其实就是一层wrapper，根据MAKEFILE的内容来指定底层实际的编译器。用这几个命令来编译的时候也可以看到，就是多连接了一些库。</p>
<p>recompile之后不需要额外的运行参数，只需要正常运行就能生成profile文件。不过说实话，如果不开启一些环境变量，感觉和interposition相比也没有丰富多少。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyPROFILEDIR=<span class="variable">$PWD</span>/tau-pro mpirun --host f0104:72,f0105:72 -n 144 &lt;program&gt;</span><br></pre></td></tr></table></figure>
<p>有用的环境变量包括：</p>
<p><code>TAU_TRACE</code>：开启tracing。生成文件的格式会改变，并且会变得很大。此时文件夹由<code>TRACEDIR</code>决定。</p>
<p><code>TAU_COMM_MATRIX</code>：为1时启动通讯记录。这样profile中会记录下哪个进程与哪个进程进行了多少通讯，比较直观。</p>
<p><code>TAU_CALLPATH</code>：为1时追踪函数的调用记录。没有开的时候，只会记录下这个函数总的调用花了多少时间；开了之后会记录从哪个函数中调用这个函数花了多少时间。不过，在recompile等级下好像也没法追踪到自定义的函数体（可能是因为我profile的是fortran的代码？不清楚），并且展开之后会比较乱，也不一定好用。</p>
<p>最后得到的文件使用paraprof工具可以进行可视化。能实现的比较有用的功能：</p>
<ul>
<li>单个进程的各个MPI函数调用时间排序；</li>
<li>单个MPI函数在各个进程上调用时间分布直方图；</li>
<li>Communication Matrix。</li>
</ul>
<h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><h3 id="动态插桩（Dynamic-instrumentation）"><a href="#动态插桩（Dynamic-instrumentation）" class="headerlink" title="动态插桩（Dynamic instrumentation）"></a>动态插桩（Dynamic instrumentation）</h3><p>在mpirun的命令中插入一个tau_exec，实现动态插桩。普通的MPI运行命令。后面是一系列程序运行的参数：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpirun -np 8 ./swap -k 19 -c 5 -i ./data/S.aureus.fasta -o Saur_k19_c5</span><br></pre></td></tr></table></figure></p>
<p>加了tau_exec之后的运行命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpirun -np 8 tau_exec ./swap -k 19 -c 5 -i ./data/S.aureus.fasta -o Saur_k19_c5</span><br></pre></td></tr></table></figure></p>
<p>接着目录下会多了几个类似于profile.0.0.0的文件。直接在当前目录下执行pprof命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pprof</span><br></pre></td></tr></table></figure><br>显示结果如下图所示：</p>
<p><img src="/img/3149063-20230326103354863-88530210.png" alt="在这里插入图片描述"></p>
<p>这种方法只能够查看到MPI的函数调用情况，并不能看到用户的自定义函数的调用情况。因此不太推荐这种插桩方法。</p>
<h3 id="源码插桩（Source-instrumentation）"><a href="#源码插桩（Source-instrumentation）" class="headerlink" title="源码插桩（Source instrumentation）"></a>源码插桩（Source instrumentation）</h3><p>直接在源码中进行插桩。</p>
<p>首先，要选择我们想要借助TAU获得的信息（e.g. MPI support, tracing, CUDA hardware counters, etc）。我们要将TAU_MAKEFILE变量设置为相应的pdt。因为我们现在使用TAU来测MPI程序的信息，因此将TAU_MAKEFILE变量设为tau-mpi-pdt：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TAU_MAKEFILE=<span class="variable">$TAU_HOME</span>/lib/Makefile.tau-mpi-pdt</span><br></pre></td></tr></table></figure></p>
<p>接着，使用tau_cc.sh或者tau_cxx.sh而不是使用mpicc或者mpicxx来编译cpp文件。以下代码是从别处抄来的，因为我测的这个程序使用MakeFile文件来进行编译的，我就直接在MakeFile文件中进行修改，将mpicxx替换成tau_cxx.sh。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tau_cxx.sh wave2d.cpp -o wave2d</span><br></pre></td></tr></table></figure><br>编译完成后，还是使用mpirun运行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpirun -np 4 tau_exec ./swap -k 19 -c 5 -i ./data/S.aureus.fasta -o Saur_k19_c5</span><br></pre></td></tr></table></figure></p>
<p>接着就是使用各种可视化工具来对性能测试的数据进行可视化。pprof是一个基于文本的可视化工具。先使用pprof试试：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pprof</span><br></pre></td></tr></table></figure></p>
<p>可以看出确实多了很多用户自定义函数的执行情况，而不是只限于MPI函数。但是可能是因为没有解析出来的缘故，很多函数都只是给出了地址，而没有给出函数名字。</p>
<h3 id="基于编译器的插桩（Compiler-based-instrumentation）和可选择代码区域的插桩（Selective-instrumentation"><a href="#基于编译器的插桩（Compiler-based-instrumentation）和可选择代码区域的插桩（Selective-instrumentation" class="headerlink" title="基于编译器的插桩（Compiler-based instrumentation）和可选择代码区域的插桩（Selective instrumentation"></a>基于编译器的插桩（Compiler-based instrumentation）和可选择代码区域的插桩（Selective instrumentation</h3><p>基于编译器的插桩介于Source和Dynamic之间。而选择代码区域的插桩大致就是在代码中指定一块区域。两个我都没怎么使用过，就不介绍了。文档中还是推荐使用源码（Source）插桩。</p>
<h1 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h1><p>贴原文链接：<a href="https://blog.csdn.net/zb872676223/article/details/37906049">https://blog.csdn.net/zb872676223/article/details/37906049</a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在前面几节，我们讲了gdb的命令，以及这些命令在调试时候的作用，并以例子进行了演示。作为C/C++ coder，要知其然，更要知其所以然。所以，借助本节，我们大概讲下GDB调试的原理。</p>
<p>gdb 通过系统调用 ptrace 来接管一个进程的执行。ptrace 系统调用提供了一种方法使得父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器。它主要用来实现断点调试和系统调用跟踪。</p>
<p>ptrace系统调用定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid, <span class="type">void</span> *addr, <span class="type">void</span> *data)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>pid_t pid</code>：指示 ptrace 要跟踪的进程</li>
<li><code>void *addr</code>：指示要监控的内存地址</li>
<li><code>enum __ptrace_request request</code>：决定了系统调用的功能，几个主要的选项：<ul>
<li><code>PTRACE_TRACEME</code>：表示此进程将被父进程跟踪，任何信号（除了 SIGKILL）都会暂停子进程，接着阻塞于 wait() 等待的父进程被唤醒。子进程内部对 exec() 的调用将发出 SIGTRAP 信号，这可以让父进程在子进程新程序开始运行之前就完全控制它</li>
<li><code>PTRACE_ATTACH</code>：attach 到一个指定的进程，使其成为当前进程跟踪的子进程，而子进程的行为等同于它进行了一次 PTRACE_TRACEME 操作。但需要注意的是，虽然当前进程成为被跟踪进程的父进程，但是子进程使用 getppid() 的到的仍将是其原始父进程的pid</li>
<li><code>PTRACE_CONT</code>：继续运行之前停止的子进程。可同时向子进程交付指定的信号</li>
</ul>
</li>
</ul>
<h3 id="调试原理"><a href="#调试原理" class="headerlink" title="调试原理"></a>调试原理</h3><p>运行并调试新进程，步骤如下：</p>
<ul>
<li>运行gdb exe</li>
<li>输入run命令，gdb执行以下操作：</li>
<li>通过fork()系统调用创建一个新进程</li>
<li>在新创建的子进程中执行ptrace(PTRACE_TRACEME, 0, 0, 0)操作</li>
<li>在子进程中通过execv()系统调用加载指定的可执行文件</li>
</ul>
<h3 id="attach运行的进程"><a href="#attach运行的进程" class="headerlink" title="attach运行的进程"></a>attach运行的进程</h3><p>可以通过gdb attach pid来调试一个运行的进程，gdb将对指定进程执行<code>ptrace(PTRACE_ATTACH, pid, 0, 0)</code>操作。需要注意的是，当我们attach一个进程id时候，可能会报如下错误：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process 28849</span><br><span class="line">ptrace: Operation not permitted.</span><br></pre></td></tr></table></figure></p>
<p>这是因为没有权限进行操作，可以根据启动该进程用户下或者root下进行操作。</p>
<h3 id="断点原理"><a href="#断点原理" class="headerlink" title="断点原理"></a>断点原理</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>当我们通过b或者break设置断点时候，就是在指定位置插入断点指令，当被调试的程序运行到断点的时候，产生SIGTRAP信号。该信号被gdb捕获并 进行断点命中判断。</p>
<h4 id="设置原理"><a href="#设置原理" class="headerlink" title="设置原理"></a>设置原理</h4><p>在程序中设置断点，就是先在该位置保存原指令，然后在该位置写入int 3。当执行到int 3时，发生软中断，内核会向子进程发送SIGTRAP信号。当然，这个信号会转发给父进程。然后用保存的指令替换int 3并等待操作恢复。</p>
<h4 id="命中判断"><a href="#命中判断" class="headerlink" title="命中判断"></a>命中判断</h4><p>gdb将所有断点位置存储在一个链表中。命中判定将被调试程序的当前停止位置与链表中的断点位置进行比较，以查看断点产生的信号。</p>
<h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><p>在断点处恢复指令后，增加了一个条件判断。如果表达式为真，则触发断点。由于需要判断一次，添加条件断点后，是否触发条件断点，都会影响性能。在 x86 平台上，部分硬件支持硬件断点。不是在条件断点处插入 int 3，而是插入另一条指令。当程序到达这个地址时，不是发出int 3信号，而是进行比较。特定寄存器的内容和某个地址，然后决定是否发送int 3。因此，当你的断点位置被程序频繁“通过”时，尽量使用硬件断点，这将有助于提高性能。</p>
<h4 id="单步原理"><a href="#单步原理" class="headerlink" title="单步原理"></a>单步原理</h4><p>这个ptrace函数本身就支持，可以通过ptrace(PTRACE_SINGLESTEP, pid,…)调用来实现单步。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;attaching to PID %d\n&quot;</span>, pid);</span><br><span class="line"><span class="keyword">if</span> (ptrace(PTRACE_ATTACH, pid, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;attach failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> waitStat = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> waitRes = waitpid(pid, &amp;waitStat, WUNTRACED);</span><br><span class="line"><span class="keyword">if</span> (waitRes != pid || !WIFSTOPPED(waitStat))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;unexpected waitpid result!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="type">int64_t</span> numSteps = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> res = ptrace(PTRACE_SINGLESTEP, pid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码，首先接收一个pid，然后对其进行attach，最后调用ptrace进行单步调试。</p>
<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>我们先看看我们的测试程序:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in eg1.c */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">wib</span><span class="params">(<span class="type">int</span> no1, <span class="type">int</span> no2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result, diff;</span><br><span class="line">    diff = no1 - no2;</span><br><span class="line">    result = no1 / diff;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork err\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* in child process */</span></span><br><span class="line">        sleep(<span class="number">60</span>); ------------------ (!)</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> div = <span class="number">6</span>;</span><br><span class="line">        <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i     = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                result = wib(value, div);</span><br><span class="line">                total += result;</span><br><span class="line">                div++;</span><br><span class="line">                value--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d wibed by %d equals %d\n&quot;</span>, value, div, total);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">/* in parent process */</span></span><br><span class="line">         sleep(<span class="number">4</span>);</span><br><span class="line">         wait(<span class="number">-1</span>);</span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>该测试程序中子进程运行过程中会在wib函数中出现一个’除0’异常。现在我们就要调试该子进程。</p>
<h4 id="调试原理-1"><a href="#调试原理-1" class="headerlink" title="调试原理"></a>调试原理</h4><p>不知道大家发现没有，在(!)处在我们的测试程序在父进程fork后，子进程调用sleep睡了60秒。这就是关键，这个sleep本来是不该存在于子进程代码中的，而是而了使用GDB调试后加入的，它是我们调试的一个关键点。为什么要让子进程刚刚运行就开始sleep呢？因为我们要在子进程睡眠期间，利用 shell命令获取其process id，然后再利用gdb调试外部进程的方法attach到该process id上，调试该进程。<br>我们现在调试的是mpi程序，intel的mpiexec可以直接-gdb进行调试，但是用gnu的话就不行了，只能gdb attach来调试，下述。</p>
<h4 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h4><p>GDB 调试程序的前提条件就是你编译程序时必须加入调试符号信息，即使用’-g’编译选项。首先编译我们的源程序<code>gcc -g -o eg1 eg1.c</code>。编译好之后，我们就有了我们的调试目标eg1。由于我们在调试过程中需要多个工具配合，所以你最好多打开几个终端窗口，另外一点需要注意的是最好在eg1的working directory下执行gdb程序，否则gdb回提示’No symbol table is loaded’。你还得手工load symbol table。好了，下面我们就’按部就班’的开始调试我们的eg1。</p>
<p>执行eg1:<code>eg1 &amp;   --- 让eg1后台运行</code></p>
<p>查找进程id:<code>ps -fu YOUR_USER_NAME</code></p>
<p>或在linux下使用<code>getpid()</code>函数</p>
<p>运行gdb:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">gdb</span><br><span class="line">(gdb) attach xxxxx --- xxxxx为利用ps命令获得的子进程process <span class="built_in">id</span></span><br><span class="line">(gdb) stop --- 这点很重要，你需要先暂停那个子进程，然后设置一些断点和一些Watch</span><br><span class="line">(gdb) <span class="built_in">break</span> 37 -- 在result = wib(value, div);这行设置一个断点,可以使用list命令察看源代码</span><br><span class="line">Breakpoint 1 at 0x10808: file eg1.c, line 37.</span><br><span class="line">(gdb) <span class="built_in">continue</span></span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at eg1.c:37</span><br><span class="line">37                              result = wib(value, div);</span><br><span class="line">(gdb) step</span><br><span class="line">wib (no1=10, no2=6) at eg1.c:13</span><br><span class="line">13              diff = no1 - no2;</span><br><span class="line">(gdb) <span class="built_in">continue</span></span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at eg1.c:37</span><br><span class="line">37                              result = wib(value, div);</span><br><span class="line">(gdb) step</span><br><span class="line">wib (no1=9, no2=7) at eg1.c:13</span><br><span class="line">13              diff = no1 - no2;</span><br><span class="line">(gdb) <span class="built_in">continue</span></span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at eg1.c:37</span><br><span class="line">37                              result = wib(value, div);</span><br><span class="line">(gdb) step</span><br><span class="line">wib (no1=8, no2=8) at eg1.c:13</span><br><span class="line">13              diff = no1 - no2;</span><br><span class="line">(gdb) next</span><br><span class="line">14              result = no1 / diff;</span><br><span class="line">(gdb) <span class="built_in">print</span> diff</span><br><span class="line"><span class="variable">$6</span> = 0        ------- 除数为0，我们找到罪魁祸首了。</span><br><span class="line">(gdb) next</span><br><span class="line">Program received signal SIGFPE, Arithmetic exception.</span><br><span class="line">0xff29d830 <span class="keyword">in</span> .div () from /usr/lib/libc.so.1</span><br></pre></td></tr></table></figure><br>至此，我们调试完毕。</p>
<h2 id="GDB调试精粹"><a href="#GDB调试精粹" class="headerlink" title="GDB调试精粹"></a>GDB调试精粹</h2><h3 id="一、列文件清单"><a href="#一、列文件清单" class="headerlink" title="一、列文件清单"></a>一、列文件清单</h3><p><code>list / l</code><br>列出产生执行文件的源代码的一部分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//列出 line1 到 line2 行之间的源代码  </span><br><span class="line">(gdb) list line1, line2  </span><br><span class="line">  </span><br><span class="line">//输出从上次调用list命令开始往后的10行程序代码  </span><br><span class="line">(gdb) list  </span><br><span class="line">  </span><br><span class="line">//输出第 n 行附近的10行程序代码  </span><br><span class="line">(gdb) list n  </span><br><span class="line">  </span><br><span class="line">//输出函数function前后的10行程序代码  </span><br><span class="line">(gdb) list function  </span><br></pre></td></tr></table></figure>
<h3 id="二、执行程序"><a href="#二、执行程序" class="headerlink" title="二、执行程序"></a>二、执行程序</h3><p><code>run / r</code><br>运行准备调试的程序，在它后面可以跟随发给该程序的任何参数，包括标准输入和标准输出说明符(&lt;和&gt;)和shell通配符（*、？、[、]）在内。<br>如果你使用不带参数的run命令，gdb就再次使用你给予前一条run命令的参数，这是很有用的。</p>
<p><code>set args</code><br>命令就可以修改发送给程序的参数，而使用</p>
<p><code>show args</code><br>命令就可以查看其缺省参数的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args –b –x  </span><br><span class="line">(gdb) show args  </span><br></pre></td></tr></table></figure>
<h3 id="三、显示数据"><a href="#三、显示数据" class="headerlink" title="三、显示数据"></a>三、显示数据</h3><p><code>print / p</code><br>查看变量的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//利用print 命令可以检查各个变量的值。  </span><br><span class="line">(gdb) print p (p为变量名)  </span><br><span class="line">print 是 gdb 的一个功能很强的命令，利用它可以显示被调试的语言中任何有效的表达式。表达式除了包含你程序中的变量外，还可以包含以下内容：</span><br><span class="line"></span><br><span class="line">//对程序中函数的调用  </span><br><span class="line">(gdb) print find_entry(1, 0)  </span><br><span class="line">  </span><br><span class="line">//数据结构和其他复杂对象  </span><br><span class="line">(gdb) print *table_start  </span><br><span class="line">$8=&#123;e=reference=’\000’,location=0x0,next=0x0&#125;  </span><br><span class="line">  </span><br><span class="line">//值的历史成分  </span><br><span class="line">(gdb)print $1 ($1为历史记录变量,在以后可以直接引用 $1 的值)  </span><br><span class="line">whatis </span><br><span class="line"></span><br><span class="line">查看变量的类型</span><br><span class="line"></span><br><span class="line">//whatis 命令可以显示某个变量的类型  </span><br><span class="line">(gdb) whatis p  </span><br><span class="line">type = int *  </span><br></pre></td></tr></table></figure>
<h3 id="四、设置与清除断点"><a href="#四、设置与清除断点" class="headerlink" title="四、设置与清除断点"></a>四、设置与清除断点</h3><p><code>break / b</code><br>可以用来在调试的程序中设置断点，该命令有如下四种形式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//使程序恰好在执行给定行之前停止  </span><br><span class="line">break line-number  </span><br><span class="line">  </span><br><span class="line">//使程序恰好在进入指定的函数之前停止  </span><br><span class="line">  </span><br><span class="line">break function-name  </span><br><span class="line">  </span><br><span class="line">//如果condition（条件）是真，程序到达指定行或函数时停止  </span><br><span class="line">break line-or-function if condition  </span><br><span class="line">   </span><br><span class="line">//在指定例程的入口处设置断点  </span><br><span class="line">break routine-name  </span><br></pre></td></tr></table></figure></p>
<p>如果该程序是由很多原文件构成的，你可以在各个原文件中设置断点，而不是在当前的原文件中设置断点，其方法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break filename:line-number  </span><br><span class="line">  </span><br><span class="line">(gdb) break filename:function-name  </span><br><span class="line">break  if</span><br></pre></td></tr></table></figure><br>要想设置一个条件断点，可以利用break if命令，如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break line-or-function if expr  </span><br><span class="line">  </span><br><span class="line">(gdb) break 46 if testsize==100  </span><br><span class="line">clean number</span><br></pre></td></tr></table></figure><br>清除原文件中某一代码行上的所有断点</p>
<p>注：number 为原文件的某个代码行的行号</p>
<h3 id="五、断点的管理"><a href="#五、断点的管理" class="headerlink" title="五、断点的管理"></a>五、断点的管理</h3><p>断点是我们在调试中经常用的一个功能，我们在指定位置设置断点之后，程序运行到该位置将会暂停，这个时候我们就可以对程序进行更多的操作，比如查看变量内容，堆栈情况等等，以帮助我们调试程序。</p>
<p>以设置断点的命令分为以下几类：</p>
<ul>
<li>breakpoint</li>
<li>watchpoint</li>
<li>catchpoint</li>
</ul>
<ol>
<li><p>显示当前gdb的断点信息<br><code>info break</code></p>
</li>
<li><p>delete 删除指定的某个断点<br><code>delete breakpoint</code></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//该命令将会删除编号为1的断点  </span><br><span class="line">(gdb) delete breakpoint 1  </span><br><span class="line">  </span><br><span class="line">//如果不带编号参数，将删除所有的断点  </span><br><span class="line">(gdb) delete breakpoint  </span><br></pre></td></tr></table></figure>
<ol>
<li>禁止、允许使用某个断点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disable breakpoint 1</span><br><span class="line">enable breakpoint 1</span><br></pre></td></tr></table></figure>
该命令将禁止、允许断点 1，同时断点信息的 (Enb)域将变为 n、y</li>
</ol>
<p>breakpoint可以根据行号、函数、条件生成断点，下面是相关命令以及对应的作用说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>break [file]:function</td>
<td>在文件file的function函数入口设置断点</td>
</tr>
<tr>
<td>break [file]:line</td>
<td>在文件file的第line行设置断点</td>
</tr>
<tr>
<td>info breakpoints</td>
<td>查看断点列表</td>
</tr>
<tr>
<td>break [+-]offset</td>
<td>在当前位置偏移量为[+-]offset处设置断点</td>
</tr>
<tr>
<td><code>break *addr</code></td>
<td>在地址addr处设置断点</td>
</tr>
<tr>
<td>break … if expr</td>
<td>设置条件断点，仅仅在条件满足时</td>
</tr>
<tr>
<td>ignore n count</td>
<td>接下来对于编号为n的断点忽略count次</td>
</tr>
<tr>
<td>clear</td>
<td>删除所有断点</td>
</tr>
<tr>
<td>clear function</td>
<td>删除所有位于function内的断点</td>
</tr>
<tr>
<td>delete n</td>
<td>删除指定编号的断点</td>
</tr>
<tr>
<td>enable n</td>
<td>启用指定编号的断点</td>
</tr>
<tr>
<td>disable n</td>
<td>禁用指定编号的断点</td>
</tr>
<tr>
<td>save breakpoints file</td>
<td>保存断点信息到指定文件</td>
</tr>
<tr>
<td>source file</td>
<td>导入文件中保存的断点信息</td>
</tr>
<tr>
<td>break</td>
<td>在下一个指令处设置断点</td>
</tr>
<tr>
<td>clear [file:]line</td>
<td>删除第line行的断点</td>
</tr>
</tbody>
</table>
</div>
<p>watchpoint是一种特殊类型的断点，类似于正常断点，是要求GDB暂停程序执行的命令。区别在于watchpoint没有驻留某一行源代码中，而是指示GDB每当某个表达式改变了值就暂停执行的命令。</p>
<p>watchpoint分为硬件实现和软件实现两种。前者需要硬件系统的支持；后者的原理就是每步执行后都检查变量的值是否改变。GDB在新建数据断点时会优先尝试硬件方式，如果失败再尝试软件实现。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>watch variable</td>
<td>设置变量数据断点</td>
</tr>
<tr>
<td>watch var1 + var2</td>
<td>设置表达式数据断点</td>
</tr>
<tr>
<td>rwatch variable</td>
<td>设置读断点，仅支持硬件实现</td>
</tr>
<tr>
<td>awatch variable</td>
<td>设置读写断点，仅支持硬件实现</td>
</tr>
<tr>
<td>info watchpoints</td>
<td>查看数据断点列表</td>
</tr>
<tr>
<td>set can-use-hw-watchpoints 0</td>
<td>强制基于软件方式实现</td>
</tr>
</tbody>
</table>
</div>
<p>使用数据断点时，需要注意：</p>
<ul>
<li>当监控变量为局部变量时，一旦局部变量失效，数据断点也会失效</li>
<li>如果监控的是指针变量p，则watch *p监控的是p所指内存数据的变化情况，而watch p监控的是p指针本身有没有改变指向</li>
</ul>
<p>最常见的数据断点应用场景：「定位堆上的结构体内部成员何时被修改」。由于指针一般为局部变量，为了解决断点失效，一般有两种方法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>print &amp;variable</td>
<td>查看变量的内存地址</td>
</tr>
<tr>
<td>watch <em>(type </em>)address</td>
<td>通过内存地址间接设置断点</td>
</tr>
<tr>
<td>watch -l variable</td>
<td>指定location参数</td>
</tr>
<tr>
<td>watch variable thread 1</td>
<td>仅编号为1的线程修改变量var值时会中断</td>
</tr>
</tbody>
</table>
</div>
<p>catchpoint从字面意思理解，是捕获断点，其主要监测信号的产生。例如c++的throw，或者加载库的时候，产生断点行为。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>catch fork</td>
<td>程序调用fork时中断</td>
</tr>
<tr>
<td>tcatch fork</td>
<td>设置的断点只触发一次，之后被自动删除</td>
</tr>
<tr>
<td>catch syscall ptrace</td>
<td>为ptrace系统调用设置断点</td>
</tr>
</tbody>
</table>
</div>
<h3 id="六、单步执行"><a href="#六、单步执行" class="headerlink" title="六、单步执行"></a>六、单步执行</h3><p><code>next / n</code><br>不进入的单步执行</p>
<p><code>step</code><br>进入的单步执行</p>
<p><code>finish</code><br>如果已经进入了某函数，而想退出该函数返回到它的调用函数中，可使用命令finish</p>
<p><code>until</code><br>结束当前循环</p>
<h3 id="七、函数的调用"><a href="#七、函数的调用" class="headerlink" title="七、函数的调用"></a>七、函数的调用</h3><p><code>call name</code><br>调用和执行一个函数<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) call gen_and_sork( 1234,1,0 )  </span><br><span class="line">(gdb) call printf(“abcd”)  </span><br><span class="line">$1=4  </span><br></pre></td></tr></table></figure></p>
<h3 id="八、-原文件的搜索"><a href="#八、-原文件的搜索" class="headerlink" title="八、 原文件的搜索"></a>八、 原文件的搜索</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search text</span><br></pre></td></tr></table></figure>
<p>该命令可显示在当前文件中包含text串的下一行。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse-search text</span><br></pre></td></tr></table></figure><br>该命令可以显示包含text 的前一行。</p>
<p>小结：常用的 gdb 命令</p>
<p>backtrace / bt 显示程序中的当前位置和表示如何到达当前位置的栈跟踪（同义词：where）</p>
<p>breakpoint / b 在程序中设置一个断点</p>
<p>cd 改变当前工作目录</p>
<p>clear 删除刚才停止处的断点</p>
<p>commands 命中断点时，列出将要执行的命令</p>
<p>continue 从断点开始继续执行</p>
<p>delete 删除一个断点或监测点；也可与其他命令一起使用</p>
<p>display 程序停止时显示变量和表达时</p>
<p>down 下移栈帧，使得另一个函数成为当前函数</p>
<p>frame 选择下一条continue命令的帧</p>
<p>info 显示与该程序有关的各种信息</p>
<p>jump 在源程序中的另一点开始运行</p>
<p>kill 异常终止在gdb 控制下运行的程序</p>
<p>list 列出相应于正在执行的程序的原文件内容</p>
<p>next 执行下一个源程序行，从而执行其整体中的一个函数</p>
<p>print 显示变量或表达式的值</p>
<p>pwd 显示当前工作目录</p>
<p>ptype 显示一个数据结构（如一个结构或C++类）的内容</p>
<p>quit 退出gdb</p>
<p>reverse-search 在源文件中反向搜索正规表达式</p>
<p>run 执行该程序</p>
<p>search 在源文件中搜索正规表达式</p>
<p>set variable 给变量赋值</p>
<p>signal 将一个信号发送到正在运行的进程</p>
<p>step 执行下一个源程序行，必要时进入下一个函数</p>
<p>undisplay display 命令的反命令，不要显示表达式</p>
<p>until 结束当前循环</p>
<p>up 上移栈帧，使另一函数成为当前函数</p>
<p>watch 在程序中设置一个监测点（即数据断点）</p>
<p>whatis 显示变量或函数类型</p>
<h3 id="九、查看运行时数据"><a href="#九、查看运行时数据" class="headerlink" title="九、查看运行时数据"></a>九、查看运行时数据</h3><p>在你调试程序时，当程序被停住时，你可以使用print命令（简写命令为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式是：<br><code>print</code></p>
<p><code>print /</code>是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是/x。 </p>
<ol>
<li>表达式<br>print和许多GDB的命令一样，可以接受一个表达式，GDB会根据当前的程序运行的数据来计算这个表达式，既然是表达式，那么就可以是当前程序运行中的const常量、变量、函数等内容。可惜的是GDB不能使用你在程序中所定义的宏。表达式的语法应该是当前所调试的语言的语法，由于C/C++是一种大众型的语言，所以，本文中的例子都是关于C/C++的。（而关于用GDB调试其它语言的章节，我将在后面介绍）。在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中。 </li>
</ol>
<p>@是一个和数组有关的操作符，在后面会有更详细的说明。 <code>::</code>指定一个在文件或是一个函数中的变量。 <code>&#123;&#125;</code>表示一个指向内存地址的类型为type的一个对象。 </p>
<ol>
<li>程序变量<br>在GDB中，你可以随时查看以下三种变量的值： </li>
<li>全局变量（所有文件可见的） </li>
<li>静态全局变量（当前文件可见的） </li>
<li>局部变量（当前Scope可见的） </li>
</ol>
<p>如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函数中，用print显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用“::”操作符：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file::variable </span><br><span class="line">function::variable </span><br></pre></td></tr></table></figure><br>可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看文件f2.c中的全局变量x的值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p &#x27;f2.c&#x27;::x </span><br></pre></td></tr></table></figure><br>当然，“::”操作符会和C++中的发生冲突，GDB能自动识别“::” 是否C++的操作符，所以你不必担心在调试C++程序时会出现异常。 另外，需要注意的是，如果你的程序编译时开启了优化选项，那么在用GDB调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的变量等，所以在GDB调试这种程序时，运行时的指令和你所编写指令就有不一样，也就会出现你所想象不到的结果。对付这种情况时，需要在编译程序时关闭编译优化。一般来说，几乎所有的编译器都支持编译优化的开关，例如，GNU的C/C++编译器GCC，你可以使用“-gstabs”选项来解决这个问题。关于编译器的参数，还请查看编译器的使用说明文档。 </p>
<ol>
<li><p>数组<br>有时候，你需要查看一段连续的内存空间的值。比如数组的一段，或是动态分配的数据的大小。你可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右边则你你想查看内存的长度。例如，你的程序中有这样的语句：<br><code>int *array = (int *) malloc (len * sizeof (int));</code><br>于是，在GDB调试过程中，你可以以如下命令显示出这个动态数组的取值： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p *array@len </span><br></pre></td></tr></table></figure>
<p>@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其保存在变量len中，其输出结果，大约是下面这个样子的： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p *array@len </span><br><span class="line">$1 = &#123;2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40&#125; </span><br></pre></td></tr></table></figure>
<p>如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。 </p>
</li>
<li><p>输出格式<br>一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要做到这样，你可以使用GDB的数据显示格式： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">x 按十六进制格式显示变量。 </span><br><span class="line">d 按十进制格式显示变量。 </span><br><span class="line">u 按十六进制格式显示无符号整型。 </span><br><span class="line">o 按八进制格式显示变量。 </span><br><span class="line">t 按二进制格式显示变量。 </span><br><span class="line">a 按十六进制格式显示变量。 </span><br><span class="line">c 按字符格式显示变量。 </span><br><span class="line">f 按浮点数格式显示变量。 </span><br><span class="line">(gdb) p i </span><br><span class="line">$21 = 101 </span><br><span class="line">(gdb) p/a i </span><br><span class="line">$22 = 0x65 </span><br><span class="line">(gdb) p/c i </span><br><span class="line">$23 = 101 &#x27;e&#x27; </span><br><span class="line">(gdb) p/f i </span><br><span class="line">$24 = 1.41531145e-43 </span><br><span class="line">(gdb) p/x i </span><br><span class="line">$25 = 0x65 </span><br><span class="line">(gdb) p/t i </span><br><span class="line">$26 = 1100101 </span><br></pre></td></tr></table></figure></li>
<li>查看内存<br>你可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/ </span><br></pre></td></tr></table></figure>
n、f、u是可选的参数。<br>n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。 f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地址是指令地址，那么格式可以是i。u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</li>
</ol>
<p>n/f/u三个参数可以一起使用。例如： </p>
<ul>
<li>命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。 </li>
</ul>
<ol>
<li><p>自动显示<br>你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display。<br>display<br>格式i和s同样被display支持，一个非常有用的命令是：<br><code>display/i $pc</code><br>$pc是GDB的环境变量，表示着指令的地址，/i则表示输出格式为机器指令码，也就是汇编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形，这是一个很有意思的功能。<br>info display<br>查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。 </p>
</li>
<li><p>设置显示选项<br>GDB中关于显示的选项比较多，这里我只例举大多数常用的选项。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set print address </span><br><span class="line">set print address on </span><br></pre></td></tr></table></figure>
<p>打开地址输出，当程序显示函数信息时，GDB会显出函数的参数地址。系统默认为打开的，<br>如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) f </span><br><span class="line">#0 set_quotes (lq=0x34c78 &quot;&lt;&lt;&quot;, rq=0x34c88 &quot;&gt;&gt;&quot;) </span><br><span class="line">at input.c:530 </span><br><span class="line">530 if (lquote != def_lquote) </span><br><span class="line">set print address off </span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>关闭函数的参数地址显示，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set print addr off </span><br><span class="line">(gdb) f </span><br><span class="line">#0 set_quotes (lq=&quot;&lt;&lt;&quot;, rq=&quot;&gt;&gt;&quot;) at input.c:530 </span><br><span class="line">530 if (lquote != def_lquote) </span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show print address </span><br></pre></td></tr></table></figure>
<p>查看当前地址显示选项是否打开。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set print array </span><br><span class="line">set print array on </span><br></pre></td></tr></table></figure>
<p>打开数组显示，打开后当数组显示时，每个元素占一行，如果不打开的话，每个元素则以逗号分隔。这个选项默认是关闭的。与之相关的两个命令如下，我就不再多说了。<br>set print array off<br>show print array </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set print elements </span><br></pre></td></tr></table></figure>
<p>这个选项主要是设置数组的，如果你的数组太大了，那么就可以指定一个来指定数据显示的最大长度，当到达这个长度时，GDB就不再往下显示了。如果设置为0，则表示不限制。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show print elements</span><br></pre></td></tr></table></figure>
<p>查看print elements的选项信息。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set print null-stop </span><br></pre></td></tr></table></figure>
<p>如果打开了这个选项，那么当显示字符串时，遇到结束符则停止显示。这个选项默认为off。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set print pretty on </span><br></pre></td></tr></table></figure>
<p>如果打开printf pretty这个选项，那么当GDB显示结构体时会比较漂亮。如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$1 = &#123; </span><br><span class="line">next = 0x0, </span><br><span class="line">flags = &#123; </span><br><span class="line">sweet = 1, </span><br><span class="line">sour = 1 </span><br><span class="line">&#125;, </span><br><span class="line">meat = 0x54 &quot;Pork&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set print pretty off </span><br></pre></td></tr></table></figure>
<p>关闭printf pretty这个选项，GDB显示结构体时会如下显示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$1 = &#123;next = 0x0, flags = &#123;sweet = 1, sour = 1&#125;, meat = 0x54 &quot;Pork&quot;&#125; </span><br></pre></td></tr></table></figure></p>
<p><code>show print pretty</code>查看GDB是如何显示结构体的。 </p>
<p><code>set print sevenbit-strings</code><br>设置字符显示，是否按“/nnn”的格式显示，如果打开，则字符串或字符数据按/nnn显示，<br>如“/065”。 </p>
<p><code>show print sevenbit-strings</code><br>查看字符显示开关是否打开。 </p>
<p><code>set print union</code><br>设置显示结构体时，是否显式其内的联合体数据。例如有以下数据结构：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;Tree, Bug&#125; Species; </span><br><span class="line">typedef enum &#123;Big_tree, Acorn, Seedling&#125; Tree_forms; </span><br><span class="line">typedef enum &#123;Caterpillar, Cocoon, Butterfly&#125; </span><br><span class="line">Bug_forms; </span><br><span class="line">struct thing &#123; </span><br><span class="line">Species it; </span><br><span class="line">union &#123;</span><br><span class="line"></span><br><span class="line">Tree_forms tree; </span><br><span class="line">Bug_forms bug; </span><br><span class="line">&#125; form; </span><br><span class="line">&#125;; </span><br><span class="line">struct thing foo = &#123;Tree, &#123;Acorn&#125;&#125;; </span><br></pre></td></tr></table></figure></p>
<p>当打开这个开关时，执行 p foo 命令后，会如下显示：<br><code>$1 = &#123;it = Tree, form = &#123;tree = Acorn, bug = Cocoon&#125;&#125;</code><br>当关闭这个开关时，执行 p foo 命令后，会如下显示：<br><code>$1 = &#123;it = Tree, form = &#123;...&#125;&#125;</code></p>
<p><code>show print union</code><br>查看联合体数据的显示方式<br><code>set print object</code><br>在C++中，如果一个对象指针指向其派生类，如果打开这个选项，GDB会自动按照虚方法调用的规则显示输出，如果关闭这个选项的话，GDB就不管虚函数表了。这个选项默认是off。 </p>
<p><code>show print object</code><br>查看对象选项的设置。</p>
<p><code>set print static-members</code><br>这个选项表示，当显示一个C++对象中的内容是，是否显示其中的静态数据成员。默认是on。 </p>
<p><code>show print static-members</code><br>查看静态数据成员选项设置。 </p>
<p><code>set print vtbl</code><br>当此选项打开时，GDB将用比较规整的格式来显示虚函数表时。其默认是关闭的。 </p>
<p><code>show print vtbl</code><br>查看虚函数显示格式的选项。</p>
<ol>
<li><p>历史记录<br>当你用GDB的print查看程序运行时的数据时，你每一个print都会被GDB记录下来。GDB会以$1, $2, $3 …..这样的方式为你每一个print命令编上号。于是，你可以使用这个编号访问以前的表达式，如$1。这个功能所带来的好处是，如果你先前输入了一个比较长的表达式，如果你还想查看这个表达式的值，你可以使用历史记录来访问，省去了重复输入。</p>
</li>
<li><p>GDB环境变量<br>你可以在GDB的调试环境中定义自己的变量，用来保存一些调试程序中的运行数据。要定义一个GDB的变量很简单只需。使用GDB的set命令。GDB的环境变量和UNIX一样，也是以$起头。如：<code>set $foo = *object_ptr</code></p>
</li>
</ol>
<p>使用环境变量时，GDB会在你第一次使用时创建这个变量，而在以后的使用中，则直接对其賦值。环境变量没有类型，你可以给环境变量定义任一的类型。包括结构体和数组。 </p>
<p><code>show convenience</code><br>该命令查看当前所设置的所有的环境变量。<br>这是一个比较强大的功能，环境变量和程序变量的交互使用，将使得程序调试更为灵活便捷。<br>例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set $i = 0 </span><br><span class="line">print bar[$i++]-&gt;contents </span><br></pre></td></tr></table></figure><br>于是，当你就不必，print bar[0]-&gt;contents, print bar[1]-&gt;contents地输入命令了。输入这样的命令后，只用敲回车，重复执行上一条语句，环境变量会自动累加，从而完成逐个输出的功能。</p>
<ol>
<li>查看寄存器<br>要查看寄存器的值，很简单，可以使用如下命令： </li>
</ol>
<p><code>info registers</code><br>查看寄存器的情况。（除了浮点寄存器） </p>
<p><code>info all-registers</code><br>查看所有寄存器的情况。（包括浮点寄存器） </p>
<p><code>info registers</code><br>查看所指定的寄存器的情况。<br>寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈地址（sp）等等。你同样可以使用print命令来访问寄存器的情况，只需要在寄存器名字前加一个$符号就可以了。如：p $eip。</p>
<ol>
<li>改变程序的执行 </li>
</ol>
<p>一旦使用GDB挂上被调试程序，当程序运行起来后，你可以根据自己的调试思路来动态地在GDB中更改当前被调试程序的运行线路或是其变量的值，这个强大的功能能够让你更好的调试你的程序，比如，你可以在程序的一次运行中走遍程序的所有分支。 </p>
<p>修改变量值<br>修改被调试程序运行时的变量值，在GDB中很容易实现，使用GDB的print命令即可完成。<br>如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print x=4 </span><br></pre></td></tr></table></figure><br>x=4这个表达式是C/C++的语法，意为把变量x的值修改为4，如果你当前调试的语言是Pascal，那么你可以使用Pascal的语法：x:=4。<br>在某些时候，很有可能你的变量和GDB中的参数冲突，如： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) whatis width </span><br><span class="line">type = double </span><br><span class="line">(gdb) p width </span><br><span class="line">$4 = 13 </span><br><span class="line">(gdb) set width=47 </span><br><span class="line">Invalid syntax in expression. </span><br></pre></td></tr></table></figure>
<p>因为，set width是GDB的命令，所以，出现了“Invalid syntax in expression”的设置错误，此时，你可以使用set var命令来告诉GDB，width不是你GDB的参数，而是程序的变量名，如：<br><code>(gdb) set var width=47</code></p>
<p>另外，还可能有些情况，GDB并不报告这种错误，所以保险起见，在你改变程序变量取值时，最好都使用set var格式的GDB命令。 </p>
<p>跳转执行<br>一般来说，被调试程序会按照程序代码的运行顺序依次执行。GDB提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，可以让程序执行随意跳跃。这个功能可以由GDB的jump命令来完：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jump</span><br></pre></td></tr></table></figure><br>指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。<br>注意，jump命令不会改变当前的程序栈中的内容，所以，当你从一个函数跳到另一个函数时，当函数运行完返回时进行弹栈操作时必然会发生错误，可能结果还是非常奇怪的，甚至于产生程序Core Dump。所以最好是同一个函数中进行跳转。 熟悉汇编的人都知道，程序运行时，有一个寄存器用于保存当前代码所在的内存地址。所以，jump命令也就是改变了这个寄存器中的值。于是，你可以使用“set $pc”来更改跳转执行的地址。如：<br><code>set $pc = 0x485</code></p>
<p>产生信号量<br>使用singal命令，可以产生一个信号量给被调试的程序。如：中断信号Ctrl+C。这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，这种精确地在某处产生信号非常有利程序的调试。 语法是：signal ，UNIX的系统信号量通常从1到15。所以取值也在这个范围。<br>single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。 </p>
<p>强制函数返回<br>如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用return命令强制函数忽略还没有执行的语句并返回。<br><code>return</code><br>使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认作函数的返回值。 </p>
<p>强制调用函数</p>
<p><code>call</code>表达式中可以一是函数，以此达到强制调用函数的目的。并显示函数的返回值，如果函数返回值是void，那么就不显示。 另一个相似的命令也可以完成这一功能——print，print后面可以跟表达式，所以也可以用他来调用函数，print和call的不同是，如果函数返回void，call则不显示，print则显示函数返回值，并把该值存入历史数据中。 </p>
<p>GDB支持下列语言：C, C++, Fortran, PASCAL, Java, Chill, assembly, 和 Modula-2。一般说来，GDB会根据你所调试的程序来确定当然的调试语言，比如：发现文件名后缀为“.c”的，GDB会认为是C程序。文件名后缀为“.C, .cc, .cp, .cpp, .cxx, .c++”的，GDB会认为是C++程序。而后缀是“.f, .F”的，GDB会认为是Fortran程序，还有，后缀为如果是“.s, .S”的会认为是汇编语言。 也就是说，GDB会根据你所调试的程序的语言，来设置自己的语言环境，并让GDB的命令跟着语言环境的改变而改变。比如一些GDB命令需要用到表达式或变量时，这些表达式或变量的语法，完全是根据当前的语言环境而改变的。例如C/C++中对指针的语法是*p，而在Modula-2中则是p^。并且，如果你当前的程序是由几种不同语言一同编译成的，那到在调试过程中，GDB也能根据不同的语言自动地切换语言环境。这种跟着语言环境而改变的功能，真是体贴开发人员的一种设计。 </p>
<p>下面是几个相关于GDB语言环境的命令：<br><code>show language</code><br>查看当前的语言环境。如果GDB不能识为你所调试的编程语言，那么，C语言被认为是默<br>认的环境。 </p>
<p><code>info frame</code><br>查看当前函数的程序语言。 </p>
<p><code>info source</code><br>查看当前文件的程序语言。<br>如果GDB没有检测出当前的程序语言，那么你也可以手动设置当前的程序语言。使用set language命令即可做到。<br>当set language命令后什么也不跟的话，你可以查看GDB所支持的语言种类：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set language </span><br><span class="line">The currently understood settings are: </span><br><span class="line">local or auto Automatic setting based on source file </span><br><span class="line">c Use the C language </span><br><span class="line">c++ Use the C++ language </span><br><span class="line">asm Use the Asm language </span><br><span class="line">chill Use the Chill language </span><br><span class="line">fortran Use the Fortran language </span><br><span class="line">java Use the Java language </span><br><span class="line">modula-2 Use the Modula-2 language </span><br><span class="line">pascal Use the Pascal language </span><br><span class="line">scheme Use the Scheme language </span><br></pre></td></tr></table></figure><br>于是你可以在set language后跟上被列出来的程序语言名，来设置当前的语言环境。 </p>
<h2 id="多进程、多线程"><a href="#多进程、多线程" class="headerlink" title="多进程、多线程"></a>多进程、多线程</h2><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>GDB在调试多进程程序（程序含fork调用）时，默认只追踪父进程。可以通过命令设置，实现只追踪父进程或子进程，或者同时调试父进程和子进程。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>info inferiors</td>
<td>查看进程列表</td>
</tr>
<tr>
<td>attach pid</td>
<td>绑定进程id</td>
</tr>
<tr>
<td>inferior num</td>
<td>切换到指定进程上进行调试</td>
</tr>
<tr>
<td><code>print $_exitcode</code></td>
<td>显示程序退出时的返回值</td>
</tr>
<tr>
<td>set follow-fork-mode child</td>
<td>追踪子进程</td>
</tr>
<tr>
<td>set follow-fork-mode parent</td>
<td>追踪父进程</td>
</tr>
<tr>
<td>set detach-on-fork on</td>
<td>fork调用时只追踪其中一个进程</td>
</tr>
<tr>
<td>set detach-on-fork off</td>
<td>fork调用时会同时追踪父子进程</td>
</tr>
</tbody>
</table>
</div>
<p>在调试多进程程序时候，默认情况下，除了当前调试的进程，其他进程都处于挂起状态，所以，如果需要在调试当前进程的时候，其他进程也能正常执行，那么通过设置set schedule-multiple on即可。</p>
<p>同上面一样，我们仍然以一个例子进行模拟多进程调试，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="built_in">perror</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is child,pid = %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is parent,pid = %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">      <span class="built_in">wait</span>(<span class="literal">NULL</span>); <span class="comment">// 等待子进程退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面代码中，包含两个进程，一个是父进程(也就是main进程)，另外一个是由fork()函数创建的子进程。</p>
<p>在默认情况下，在多进程程序中，GDB只调试main进程，也就是说无论程序调用了多少次fork()函数创建了多少个子进程，GDB在默认情况下，只调试父进程。为了支持多进程调试，从GDB版本7.0开始支持单独调试(调试父进程或者子进程)和同时调试多个进程。</p>
<p>那么，我们该如何调试子进程呢？我们可以使用如下几种方式进行子进程调试。</p>
<h4 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h4><p>首先，无论是父进程还是子进程，都可以通过attach命令启动gdb进行调试。我们都知道，对于每个正在运行的程序，操作系统都会为其分配一个唯一ID号，也就是进程ID。如果我们知道了进程ID，就可以使用attach命令对其进行调试了。</p>
<p>在上面代码中，fork()函数创建的子进程内部，首先会进入while循环sleep，然后在while循环之后调用printf函数。这样做的目的有如下：</p>
<p>帮助attach捕获要调试的进程id<br>在使用gdb进行调试的时候，真正的代码(即print函数)没有被执行，这样就可以从头开始对子进程进行调试</p>
<p>使用如下命令编译生成可执行文件test_process<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g test_process.cc -o test_process</span><br></pre></td></tr></table></figure></p>
<p>现在，我们开始尝试启动调试。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb -q ./test_process</span><br><span class="line">Reading symbols from /root/test_process...done.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>这里需要说明下，之所以加-q选项，是想去掉其他不必要的输出，q为quite的缩写。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /root/./test_process</span><br><span class="line">Detaching after fork from child process 37482.</span><br><span class="line">this is parent,pid = 37478</span><br><span class="line">[Inferior 1 (process 37478) exited normally]</span><br><span class="line">Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 libgcc-4.8.5-36.el7.x86_64 libstdc++-4.8.5-36.el7.x86_64</span><br><span class="line">(gdb) attach 37482</span><br><span class="line">//符号类输出，此处略去</span><br><span class="line">(gdb) n</span><br><span class="line">Single stepping until exit from function __nanosleep_nocancel,</span><br><span class="line">which has no line number information.</span><br><span class="line">0x00007ffff72b3cc4 in sleep () from /lib64/libc.so.6</span><br><span class="line">(gdb)</span><br><span class="line">Single stepping until exit from function sleep,</span><br><span class="line">which has no line number information.</span><br><span class="line">main () at test_process.cc:8</span><br><span class="line">8       while(num==10)&#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>在上述命令中，我们执行了n(next的缩写)，使其重新对while循环的判断体进行判断。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set num = 1</span><br><span class="line">(gdb) n</span><br><span class="line">12       printf(&quot;this is child,pid = %d\n&quot;,getpid());</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">this is child,pid = 37482</span><br><span class="line">[Inferior 1 (process 37482) exited normally]</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p>
<p>为了退出while循环，我们使用set命令设置了num的值为1，这样条件就会失效退出while循环，进而执行下面的printf()函数；在最后我们执行了c(continue的缩写)命令，支持程序退出。</p>
<h4 id="指定进程"><a href="#指定进程" class="headerlink" title="指定进程"></a>指定进程</h4><p>默认情况下，GDB调试多进程程序时候，只调试父进程。GDB提供了两个命令，可以通过follow-fork-mode和detach-on-fork来指定调试父进程还是子进程。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">follow-fork-mode</span><br></pre></td></tr></table></figure></p>
<p>该命令的使用方式为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set follow-fork-mode mode</span><br></pre></td></tr></table></figure></p>
<p>其中，mode有以下两个选项：</p>
<ul>
<li>parent:父进程，mode的默认选项</li>
<li>child:子进程，其目的是告诉 gdb 在目标应用调用fork之后接着调试子进程而不是父进程，因为在Linux系统中fork()系统调用成功会返回两次，一次在父进程，一次在子进程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show follow-fork-mode</span><br><span class="line">Debugger response to a program call of fork or vfork is &quot;parent&quot;.</span><br><span class="line">(gdb) set follow-fork-mode child</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /root/./test_process</span><br><span class="line">[New process 37830]</span><br><span class="line">this is parent,pid = 37826</span><br><span class="line"></span><br><span class="line">^C</span><br><span class="line">Program received signal SIGINT, Interrupt.</span><br><span class="line">[Switching to process 37830]</span><br><span class="line">0x00007ffff72b3e10 in __nanosleep_nocancel () from /lib64/libc.so.6</span><br><span class="line">Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 libgcc-4.8.5-36.el7.x86_64 libstdc++-4.8.5-36.el7.x86_64</span><br><span class="line">(gdb) n</span><br><span class="line">Single stepping until exit from function __nanosleep_nocancel,</span><br><span class="line">which has no line number information.</span><br><span class="line">0x00007ffff72b3cc4 in sleep () from /lib64/libc.so.6</span><br><span class="line">(gdb) n</span><br><span class="line">Single stepping until exit from function sleep,</span><br><span class="line">which has no line number information.</span><br><span class="line">main () at test_process.cc:8</span><br><span class="line">8       while(num==10)&#123;</span><br><span class="line">(gdb) show follow-fork-mode</span><br><span class="line">Debugger response to a program call of fork or vfork is &quot;child&quot;.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<p>在上述命令中，我们做了如下操作：</p>
<ul>
<li>show follow-fork-mode:通过该命令来查看当前处于什么模式下，通过输出可以看出，处于parent即父进程模式</li>
<li>set follow-fork-mode child:指定调试子进程模式</li>
<li>r:运行程序，直接运行程序，此时会进入子进程，然后执行while循环</li>
<li>ctrl + c:通过该命令，可以使得GDB收到SIGINT命令，从而暂停执行while循环</li>
<li>n(next):继续执行，进而进入到while循环的条件判断处</li>
<li>show follow-fork-mode:再次执行该命令，通过输出可以看出，当前处于child模式下</li>
</ul>
<p>如果一开始指定要调试子进程还是父进程，那么使用follow-fork-mode命令完全可以满足需求;但是如果想在调试过程中，想根据实际情况在父进程和子进程之间来回切换调试呢？</p>
<p>GDB提供了另外一个命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set detach-on-fork mode</span><br></pre></td></tr></table></figure><br>其中mode有如下两个值：</p>
<ul>
<li>on:默认值，即表明只调试一个进程，可以是子进程，也可以是父进程</li>
<li>off:程序中的每个进程都会被记录，进而我们可以对所有的进程进行调试</li>
</ul>
<p>如果选择关闭detach-on-fork模式(mode为off)，那么GDB将保留对所有被fork出来的进程控制，即可用调试所有被fork出来的进程。可用 使用info forks命令列出所有的可被GDB调试的fork进程，并可用使用fork命令从一个fork进程切换到另一个fork进程。</p>
<ul>
<li>info forks: 打印DGB控制下的所有被fork出来的进程列表。该列表包括fork id、进程id和当前进程的位置</li>
<li>fork fork-id: 参数fork-id是GDB分配的内部fork编号，该编号可用通过上面的命令info forks获取</li>
</ul>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多线程开发在日常开发工作中很常见，所以多线程的调试技巧非常有必要掌握。</p>
<p>默认调试多线程时，一旦程序中断，所有线程都将暂停。如果此时再继续执行当前线程，其他线程也会同时执行。</p>
<p>|命令|作用|<br>|info threads|查看线程列表|<br>|<code>print $_thread</code>|显示当前正在调试的线程编号|<br>|set scheduler-locking on|调试一个线程时，其他线程暂停执行|<br>|set scheduler-locking off|调试一个线程时，其他线程同步执行|<br>|set scheduler-locking step|仅用step调试线程时其他线程不执行，用其他命令如next调试时仍执行|</p>
<p>如果只关心当前线程，建议临时设置 scheduler-locking 为 on，避免其他线程同时运行，导致命中其他断点分散注意力。</p>
<p>为了方便进行演示，我们创建一个简单的例子，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun_int</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;in fun_int n = &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun_string</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">  std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">10</span>));</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;in fun_string s = &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line">  v.<span class="built_in">emplace_back</span>(<span class="number">2</span>);</span><br><span class="line">  v.<span class="built_in">emplace_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(fun_int, <span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(fun_string, <span class="string">&quot;test&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;after thread create&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">  t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码比较简单：</p>
<ul>
<li>函数fun_int的功能是休眠10s，然后打印其参数</li>
<li>函数fun_string功能是休眠10s，然后打印其参数</li>
<li>main函数中，创建两个线程，分别执行上述两个函数</li>
</ul>
<p>下面是一个完整的调试过程：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 27</span><br><span class="line">Breakpoint 1 at 0x4013d5: file test.cc, line 27.</span><br><span class="line">(gdb) b test.cc:32</span><br><span class="line">Breakpoint 2 at 0x40142d: file test.cc, line 32.</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x00000000004013d5 in main() at test.cc:27</span><br><span class="line">2       breakpoint     keep y   0x000000000040142d in main() at test.cc:32</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /root/test</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib64/libthread_db.so.1&quot;.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.cc:27</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">3</span><br><span class="line">[New Thread 0x7ffff6fd2700 (LWP 44996)]</span><br><span class="line">in fun_int n = 1</span><br><span class="line">[New Thread 0x7ffff67d1700 (LWP 44997)]</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at test.cc:32</span><br><span class="line">32   std::cout &lt;&lt; &quot;after thread create&quot; &lt;&lt; std::endl;</span><br><span class="line">(gdb) info threads</span><br><span class="line">  Id   Target Id         Frame</span><br><span class="line">  3    Thread 0x7ffff67d1700 (LWP 44997) &quot;test&quot; 0x00007ffff7051fc3 in new_heap () from /lib64/libc.so.6</span><br><span class="line">  2    Thread 0x7ffff6fd2700 (LWP 44996) &quot;test&quot; 0x00007ffff7097e2d in nanosleep () from /lib64/libc.so.6</span><br><span class="line">* 1    Thread 0x7ffff7fe7740 (LWP 44987) &quot;test&quot; main () at test.cc:32</span><br><span class="line">(gdb) thread 2</span><br><span class="line">[Switching to thread 2 (Thread 0x7ffff6fd2700 (LWP 44996))]</span><br><span class="line">#0  0x00007ffff7097e2d in nanosleep () from /lib64/libc.so.6</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007ffff7097e2d in nanosleep () from /lib64/libc.so.6</span><br><span class="line">#1  0x00007ffff7097cc4 in sleep () from /lib64/libc.so.6</span><br><span class="line">#2  0x00007ffff796ceb9 in std::this_thread::__sleep_for(std::chrono::duration&lt;long, std::ratio&lt;1l, 1l&gt; &gt;, std::chrono::duration&lt;long, std::ratio&lt;1l, 1000000000l&gt; &gt;) () from /lib64/libstdc++.so.6</span><br><span class="line">#3  0x00000000004018cc in std::this_thread::sleep_for&lt;long, std::ratio&lt;1l, 1l&gt; &gt; (__rtime=...) at /usr/include/c++/4.8.2/thread:281</span><br><span class="line">#4  0x0000000000401307 in fun_int (n=1) at test.cc:9</span><br><span class="line">#5  0x0000000000404696 in std::_Bind_simple&lt;int (*(int))(int)&gt;::_M_invoke&lt;0ul&gt;(std::_Index_tuple&lt;0ul&gt;) (this=0x609080)</span><br><span class="line">    at /usr/include/c++/4.8.2/functional:1732</span><br><span class="line">#6  0x000000000040443d in std::_Bind_simple&lt;int (*(int))(int)&gt;::operator()() (this=0x609080) at /usr/include/c++/4.8.2/functional:1720</span><br><span class="line">#7  0x000000000040436e in std::thread::_Impl&lt;std::_Bind_simple&lt;int (*(int))(int)&gt; &gt;::_M_run() (this=0x609068) at /usr/include/c++/4.8.2/thread:115</span><br><span class="line">#8  0x00007ffff796d070 in ?? () from /lib64/libstdc++.so.6</span><br><span class="line">#9  0x00007ffff7bc6dd5 in start_thread () from /lib64/libpthread.so.0</span><br><span class="line">#10 0x00007ffff70d0ead in clone () from /lib64/libc.so.6</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">after thread create</span><br><span class="line">in fun_int n = 1</span><br><span class="line">[Thread 0x7ffff6fd2700 (LWP 45234) exited]</span><br><span class="line">in fun_string s = test</span><br><span class="line">[Thread 0x7ffff67d1700 (LWP 45235) exited]</span><br><span class="line">[Inferior 1 (process 45230) exited normally]</span><br><span class="line">(gdb) q</span><br></pre></td></tr></table></figure></p>
<p>在上述调试过程中：</p>
<ul>
<li>b 27 在第27行加上断点</li>
<li>b test.cc:32 在第32行加上断点(效果与b 32一致)</li>
<li>info b 输出所有的断点信息</li>
<li>r 程序开始运行，并在第一个断点处暂停</li>
<li>c 执行c命令，在第二个断点处暂停，在第一个断点和第二个断点之间，创建了两个线程t1和t2</li>
<li>info threads 输出所有的线程信息，从输出上可以看出，总共有3个线程，分别为main线程、t1和t2</li>
<li>thread 2 切换至线程2</li>
<li>bt 输出线程2的堆栈信息</li>
<li>c 直至程序结束</li>
<li>q 退出gdb</li>
</ul>
<h2 id="动态链接库中函数的地址确定"><a href="#动态链接库中函数的地址确定" class="headerlink" title="动态链接库中函数的地址确定"></a>动态链接库中函数的地址确定</h2><p>有一个问题是我们调用了动态链接库里面的函数，我们怎么知道动态链接库里面的函数的地址呢？事实上，直到我们第一次调用这个函数，我们并不知道这个函数的地址，这个功能要做延迟绑定 lazy bind。 因为程序的分支很多，并不是所有的分支都能跑到，想想我们的异常处理，异常处理分支的动态链接库里面的函数也许永远跑不到，所以，一上来就解析所有出现过的动态库里面的函数是个浪费的办法，降低性能并且没有必要。</p>
<p>下面我们看下延迟绑定的效果。我写了个程序，先睡15s，然后pthread_create 一个线程。我们用LD_DEBUG观察符号的解析。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">myfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">15</span>);</span><br><span class="line">    <span class="type">pthread_t</span> tid = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid,<span class="literal">NULL</span>,myfunc,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;pthread create failed %m \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">pthread_join</span>(tid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;pthread join failed %m\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@libin:~/program/C/plt_got# LD_DEBUG=symbols ./test</span><br><span class="line">2849: symbol=_res;  lookup in file=./test [0]</span><br><span class="line">2849: symbol=_res;  lookup in file=/lib/tls/i686/cmov/libpthread.so.0 [0]</span><br><span class="line">2849: symbol=_res;  lookup in file=/lib/tls/i686/cmov/libc.so.6 [0]</span><br><span class="line">2849: symbol=_IO_file_close;  lookup in file=./test [0]</span><br><span class="line">2849: symbol=_IO_file_close;  lookup in file=/lib/tls/i686/cmov/libpthread.so.0 [0]</span><br><span class="line">2849: symbol=_IO_file_close;  lookup in file=/lib/tls/i686/cmov/libc.so.6 [0]</span><br><span class="line">2849: symbol=rpc_createerr;  lookup in file=./test [0]</span><br><span class="line">2849: symbol=rpc_createerr;  lookup in file=/lib/tls/i686/cmov/libpthread.so.0 [0]</span><br><span class="line">2849: symbol=rpc_createerr;  lookup in file=/lib/tls/i686/cmov/libc.so.6 [0]</span><br><span class="line"></span><br><span class="line">2849:    transferring control: ./test</span><br><span class="line">2849:</span><br><span class="line">2849:    symbol=sleep;  lookup in file=./test [0]</span><br><span class="line">2849:    symbol=sleep;  lookup in file=/lib/tls/i686/cmov/libpthread.so.0 [0]</span><br><span class="line">2849:    symbol=sleep;  lookup in file=/lib/tls/i686/cmov/libc.so.6 [0]</span><br><span class="line">===================================================================================</span><br></pre></td></tr></table></figure>
<p>然后停了15s，才解析出pthread_create的地址，由此可见，得确是运行时重定位，知道用到这个函数pthread_create才真正去找这个函数的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2849:    </span><br><span class="line">2849:    symbol=sleep; lookup in file=./test [0]</span><br><span class="line">2849:    symbol=sleep; lookup in file=/lib/tls/i686/cmov/libpthread.so.0 [0]</span><br><span class="line">2849:    symbol=sleep; lookup in file=/lib/tls/i686/cmov/libc.so.6 [0]</span><br><span class="line">===================================================================================</span><br><span class="line">2849:    symbol=pthread_create; lookup in file=./test [0]</span><br><span class="line">2849:    symbol=pthread_create; lookup in file=/lib/tls/i686/cmov/libpthread.so.0 [0]</span><br><span class="line">2849:    symbol=__getpagesize; lookup in file=./test [0]</span><br><span class="line">2849:    symbol=__getpagesize; lookup in file=/lib/tls/i686/cmov/libpthread.so.0 [0]</span><br><span class="line">2849:    symbol=__getpagesize; lookup in file=/lib/tls/i686/cmov/libc.so.6 [0]</span><br><span class="line">2849:    symbol=mmap; lookup in file=./test [0]</span><br><span class="line">2849:    symbol=mmap; lookup in file=/lib/tls/i686/cmov/libpthread.so.0 [0]</span><br><span class="line">2849:    symbol=mmap; lookup in file=/lib/tls/i686/cmov/libc.so.6 [0]</span><br></pre></td></tr></table></figure>
<p>真正动态库中函数地址的解析是第一次调用的时候做的，然后如果再次用到动态库的解析过的函数，就直接用第一次解析的结果。很自然的想法就是，一定有地方存储函数的地址，否则第一次解析出来的结果，第二次调用也没法利用。 这个存储动态库函数的地方就要GOT，Global Offset Table。 OK，我们可以想象，如果我的程序里面用到了6个动态库里面的函数，那个这个GOT里面就应该存有6个条目，每个条目里面存储着对应函数的地址。事实的确是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@libin:~/program/C/plt_got# readelf -r test</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rel.dyn&#x27; at offset 0x394 contains 2 entries:</span><br><span class="line">Offset Info Type Sym.Value Sym. Name</span><br><span class="line">08049ff0 00000206 R_386_GLOB_DAT 00000000 __gmon_start__</span><br><span class="line">0804a020 00000905 R_386_COPY 0804a020 stderr</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rel.plt&#x27; at offset 0x3a4 contains 6 entries:</span><br><span class="line">Offset Info Type Sym.Value Sym. Name</span><br><span class="line">0804a000 00000107 R_386_JUMP_SLOT 00000000 pthread_join</span><br><span class="line">0804a004 00000207 R_386_JUMP_SLOT 00000000 __gmon_start__</span><br><span class="line">0804a008 00000407 R_386_JUMP_SLOT 00000000 __libc_start_main</span><br><span class="line">0804a00c 00000507 R_386_JUMP_SLOT 00000000 fprintf</span><br><span class="line">0804a010 00000607 R_386_JUMP_SLOT 00000000 pthread_create</span><br><span class="line">0804a014 00000707 R_386_JUMP_SLOT 00000000 sleep</span><br></pre></td></tr></table></figure>
<p>我们看到了有全局变量stderr和<strong>gmon_start</strong>需要重定位，这些本文并不关心。下面是需要重定位的函数，可以看出，我们调用动态库里面的函数都在这了，fprintf是Glibc库的，pthread_create是pthread库的等等。</p>
<p>.got.plt这个段的起始地址是0x8049ff4。 .got.plt这个section大小为0x24 = 36,可是我们只有6个需要解析地址的function，4*6=24个字节，只需要24个字节就能存放这6个函数指针。多出来的12个字节是dynamic段地址，ModuleID 和 _dl_runtime_resolve的地址，如下图所示<br><img src="http://blog.chinaunix.net/attachment/201209/16/24774106_1347798530g9dm.png" alt=""></p>
<p>OK 。我们看一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x8048551: file test.c, line 19.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/libin/program/C/plt_got/test</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.c:19</span><br><span class="line">19 sleep(15);</span><br><span class="line">(gdb) x/24x 0x8049ff4</span><br><span class="line">0x8049ff4 &lt;_GLOBAL_OFFSET_TABLE_&gt;: 0x08049f18 0x0012c8f8 0x00123270 0x0804841a</span><br><span class="line">0x804a004 &lt;_GLOBAL_OFFSET_TABLE_+16&gt;: 0x0804842a 0x0015daf0 0x0804844a 0x0804845a</span><br><span class="line">0x804a014 &lt;_GLOBAL_OFFSET_TABLE_+32&gt;: 0x0804846a 0x00000000 0x00000000 0x0029c580</span><br><span class="line">0x804a024 : 0x00000000 0x00000000 0x00000000 0x00000000</span><br><span class="line">0x804a034: 0x00000000 0x00000000 0x00000000 0x00000000</span><br><span class="line">0x804a044: 0x00000000 0x00000000 0x00000000 0x00000000</span><br></pre></td></tr></table></figure>
<p>蓝色的0x0849f18是dynamic段的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[21] .dynamic DYNAMIC 08049f18 000f18 0000d8 08 WA 7 0 4</span><br></pre></td></tr></table></figure>
<p>接下来，我们要分析PLT 和GOT的关系了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas main</span><br><span class="line"></span><br><span class="line">0x0804857e &lt;+54&gt;: lea 0x1c(%esp),%eax</span><br><span class="line">0x08048582 &lt;+58&gt;: mov %eax,(%esp)</span><br><span class="line">0x08048585 &lt;+61&gt;: call 0x8048454 &lt;pthread_create@plt&gt;</span><br><span class="line">0x0804858a &lt;+66&gt;: mov %eax,0x18(%esp)</span><br><span class="line">0x0804858e &lt;+70&gt;: cmpl $0x0,0x18(%esp)</span><br></pre></td></tr></table></figure>
<p>要执行pthread_create 函数，跳到PLT部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">libin@libin:~/program/C/plt_got$ objdump -dj .plt test</span><br><span class="line"></span><br><span class="line">test: file format elf32-i386</span><br><span class="line"></span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">08048404 :</span><br><span class="line">8048404: ff 35 f8 9f 04 08 pushl 0x8049ff8</span><br><span class="line">804840a: ff 25 fc 9f 04 08 jmp *0x8049ffc</span><br><span class="line">8048410: 00 00 add %al,(%eax)</span><br><span class="line"></span><br><span class="line">08048414 :</span><br><span class="line">8048414: ff 25 00 a0 04 08 jmp *0x804a000</span><br><span class="line">804841a: 68 00 00 00 00 push $0x0</span><br><span class="line">804841f: e9 e0 ff ff ff jmp 8048404 &lt;_init+0x30&gt;</span><br><span class="line"></span><br><span class="line">08048424 &lt;__gmon_start__@plt&gt;:</span><br><span class="line">8048424: ff 25 04 a0 04 08 jmp *0x804a004</span><br><span class="line">804842a: 68 08 00 00 00 push $0x8</span><br><span class="line">804842f: e9 d0 ff ff ff jmp 8048404 &lt;_init+0x30&gt;</span><br><span class="line"></span><br><span class="line">08048434 &lt;__libc_start_main@plt&gt;:</span><br><span class="line">8048434: ff 25 08 a0 04 08 jmp *0x804a008</span><br><span class="line">804843a: 68 10 00 00 00 push $0x10</span><br><span class="line">804843f: e9 c0 ff ff ff jmp 8048404 &lt;_init+0x30&gt;</span><br><span class="line"></span><br><span class="line">08048444 :</span><br><span class="line">8048444: ff 25 0c a0 04 08 jmp *0x804a00c</span><br><span class="line">804844a: 68 18 00 00 00 push $0x18</span><br><span class="line">804844f: e9 b0 ff ff ff jmp 8048404 &lt;_init+0x30&gt;</span><br><span class="line"></span><br><span class="line">08048454 :</span><br><span class="line">8048454: ff 25 10 a0 04 08 jmp *0x804a010</span><br><span class="line">804845a: 68 20 00 00 00 push $0x20</span><br><span class="line">804845f: e9 a0 ff ff ff jmp 8048404 &lt;_init+0x30&gt;</span><br><span class="line"></span><br><span class="line">08048464 :</span><br><span class="line">8048464: ff 25 14 a0 04 08 jmp *0x804a014</span><br><span class="line">804846a: 68 28 00 00 00 push $0x28</span><br><span class="line">804846f: e9 90 ff ff ff jmp 8048404 &lt;_init+0x30&gt;</span><br></pre></td></tr></table></figure>
<p>PLT部分认为pthread_create函数存放在GOT，0x804a010是GOT里面的一个条目，这个条目存储着pthread_create函数的地址。当第二次以至于第N次调用pthead_create的时候，的的确确存放着pthread_create的地址，但是第一次不行，第一次这个条目里面还没记录这个地址。那么这个条目记录的是什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/10i 0x8048454</span><br><span class="line">0x8048454 : jmp *0x804a010</span><br><span class="line">0x804845a : push $0x20</span><br><span class="line">0x804845f : jmp 0x8048404</span><br><span class="line">0x8048464 : jmp *0x804a014</span><br><span class="line">0x804846a : push $0x28</span><br><span class="line">0x804846f : jmp 0x8048404</span><br><span class="line">0x8048474: add %al,(%eax)</span><br><span class="line">0x8048476: add %al,(%eax)</span><br><span class="line">0x8048478: add %al,(%eax)</span><br><span class="line">0x804847a: add %al,(%eax)</span><br><span class="line">(gdb) x/10x 0x804a010</span><br><span class="line">0x804a010 &lt;_GLOBAL_OFFSET_TABLE_+28&gt;: 0x0804845a 0x0804846a 0x00000000 0x00000000</span><br><span class="line">0x804a020 : 0x0029c580 0x00000000 0x00000000 0x00000000</span><br><span class="line">0x804a030: 0x00000000 0x00000000</span><br></pre></td></tr></table></figure>
<p>0x804a010这个地址最终应该记录的是pthread_create的地址，但是目前还不是，记录的是0x084845a</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">08048454 :</span><br><span class="line">8048454: ff 25 10 a0 04 08     jmp    *0x804a010</span><br><span class="line">804845a: 68 20 00 00 00        push   $0x20</span><br><span class="line">804845f: e9 a0 ff ff ff        jmp    8048404 &lt;_init+0x30&gt;</span><br></pre></td></tr></table></figure>
<p>从PLT跳到GOT 找地址，但是第一次找的时候，并不是pthread_create的地址，而是又跳回来PLT，我们看到push了0x20之后，跳到了0x8048404。 每一个PLT的代码段，都是push了一个值之后，跳到了0x8048404。大家可以去上面的图验证。<br><img src="http://blog.chinaunix.net/attachment/201209/16/24774106_1347800246pw43.png" alt=""></p>
<p>接下来，我们看0x8048404存放的是啥指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/10i 0x8048404</span><br><span class="line">   0x8048404:    pushl 0x8049ff8</span><br><span class="line">   0x804840a:    jmp *0x8049ffc</span><br><span class="line">   0x8048410:    add %al,(%eax)</span><br><span class="line">   0x8048412:    add %al,(%eax)</span><br><span class="line">   0x8048414 &lt;&lt;/span&gt;pthread_join@plt&gt;:    jmp *0x804a000</span><br><span class="line">   0x804841a &lt;&lt;/span&gt;pthread_join@plt+6&gt;:    push $0x0</span><br><span class="line">   0x804841f &lt;&lt;/span&gt;pthread_join@plt+11&gt;:    jmp 0x8048404</span><br><span class="line">   0x8048424 &lt;&lt;/span&gt;__gmon_start__@plt&gt;:    jmp *0x804a004</span><br><span class="line">   0x804842a &lt;&lt;/span&gt;__gmon_start__@plt+6&gt;:    push $0x8</span><br><span class="line">   0x804842f &lt;&lt;/span&gt;__gmon_start__@plt+11&gt;:    jmp 0x8048404</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/10x 0x8049ffc</span><br><span class="line">0x8049ffc &lt;&lt;/span&gt;_GLOBAL_OFFSET_TABLE_+8&gt;:    0x00123270    0x0804841a    0x0804842a    0x0015daf0</span><br><span class="line">0x804a00c &lt;&lt;/span&gt;_GLOBAL_OFFSET_TABLE_+24&gt;:    0x0804844a    0x0804845a    0x0804846a    0x00000000</span><br><span class="line">0x804a01c &lt;&lt;/span&gt;__dso_handle&gt;:    0x00000000    0x0029c580</span><br><span class="line">(gdb) x/10i 0x00123270</span><br><span class="line">   0x123270 &lt;&lt;/span&gt;_dl_runtime_resolve&gt;:    push %eax</span><br><span class="line">   0x123271 &lt;&lt;/span&gt;_dl_runtime_resolve+1&gt;:    push %ecx</span><br><span class="line">   0x123272 &lt;&lt;/span&gt;_dl_runtime_resolve+2&gt;:    push %edx</span><br><span class="line">   0x123273 &lt;&lt;/span&gt;_dl_runtime_resolve+3&gt;:    mov 0x10(%esp),%edx</span><br><span class="line">   0x123277 &lt;&lt;/span&gt;_dl_runtime_resolve+7&gt;:    mov 0xc(%esp),%eax</span><br><span class="line">   0x12327b &lt;&lt;/span&gt;_dl_runtime_resolve+11&gt;:    call 0x11d5a0 &lt;&lt;/span&gt;_dl_fixup&gt;</span><br><span class="line">   0x123280 &lt;&lt;/span&gt;_dl_runtime_resolve+16&gt;:    pop %edx</span><br><span class="line">   0x123281 &lt;&lt;/span&gt;_dl_runtime_resolve+17&gt;:    mov (%esp),%ecx</span><br><span class="line">   0x123284 &lt;&lt;/span&gt;_dl_runtime_resolve+20&gt;:    mov %eax,(%esp)</span><br><span class="line">   0x123287 &lt;&lt;/span&gt;_dl_runtime_resolve+23&gt;:    mov 0x4(%esp),%eax</span><br><span class="line">`````  </span><br><span class="line"></span><br><span class="line">我们看到0x8049ffc就是GOT的第三项，前文提到的dl_runtime_resolve的地址。这个函数将帮助我们将pthread_create函数地址定位，并且填入GOT表的相应位置 0x804a010。</span><br><span class="line"></span><br><span class="line">    我们watch下GOT pthread_create对应条目，看下这个条目啥时候变化：</span><br><span class="line"></span><br><span class="line">`````		</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x8048551: file test.c, line 19.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/libin/program/C/plt_got/test </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.c:19</span><br><span class="line">19     sleep(15);</span><br><span class="line">(gdb) watch *0x804a010</span><br><span class="line">Hardware watchpoint 2: *0x804a010</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Hardware watchpoint 2: *0x804a010</span><br><span class="line"></span><br><span class="line">Old value = 134513754</span><br><span class="line">New value = 1260912</span><br><span class="line">_dl_fixup (l=&lt;&lt;/span&gt;value optimized out&gt;, reloc_arg=&lt;&lt;/span&gt;value optimized out&gt;) at dl-runtime.c:155</span><br><span class="line">155    dl-runtime.c: 没有那个文件或目录.</span><br><span class="line">    in dl-runtime.c</span><br><span class="line">(gdb) bt</span><br><span class="line">#0 _dl_fixup (l=&lt;&lt;/span&gt;value optimized out&gt;, reloc_arg=&lt;&lt;/span&gt;value optimized out&gt;) at dl-runtime.c:155</span><br><span class="line">#1 0x00123280 in _dl_runtime_resolve () at ../sysdeps/i386/dl-trampoline.S:37</span><br><span class="line">#2 0x0804858a in main () at test.c:21</span><br><span class="line">(gdb)</span><br><span class="line">`````</span><br><span class="line"></span><br><span class="line">看到了，是_dl_runtime_resolve调用了_dl_fixup修改了GOT的对应条目。</span><br><span class="line"></span><br><span class="line">`````</span><br><span class="line">(gdb) x/10i 1260912</span><br><span class="line">   0x133d70 &lt;&lt;/span&gt;__pthread_create_2_1&gt;:    push %ebp</span><br><span class="line">   0x133d71 &lt;&lt;/span&gt;__pthread_create_2_1+1&gt;:    mov %esp,%ebp</span><br><span class="line">   0x133d73 &lt;&lt;/span&gt;__pthread_create_2_1+3&gt;:    push %edi</span><br><span class="line">   0x133d74 &lt;&lt;/span&gt;__pthread_create_2_1+4&gt;:    push %esi</span><br><span class="line">   0x133d75 &lt;&lt;/span&gt;__pthread_create_2_1+5&gt;:    push %ebx</span><br><span class="line">   0x133d76 &lt;&lt;/span&gt;__pthread_create_2_1+6&gt;:    call 0x132340 &lt;&lt;/span&gt;__i686.get_pc_thunk.bx&gt;</span><br><span class="line">   0x133d7b &lt;&lt;/span&gt;__pthread_create_2_1+11&gt;:    add $0x10279,%ebx</span><br><span class="line">   0x133d81 &lt;&lt;/span&gt;__pthread_create_2_1+17&gt;:    sub $0x4c,%esp</span><br><span class="line">   0x133d84 &lt;&lt;/span&gt;__pthread_create_2_1+20&gt;:    mov 0xc(%ebp),%edx</span><br><span class="line">   0x133d87 &lt;&lt;/span&gt;__pthread_create_2_1+23&gt;:    test %edx,%edx</span><br><span class="line">`````</span><br><span class="line"></span><br><span class="line">这是第一次。第二次就比较简单了，因为GOT里面有一个条目已经有了pthread_create函数的地址。</span><br><span class="line">![](http://blog.chinaunix.net/attachment/201209/16/24774106_13478011589N9A.png)</span><br><span class="line"></span><br><span class="line"># Perf</span><br><span class="line">## Perf 简介</span><br><span class="line">Perf 是用来进行软件性能分析的工具。</span><br><span class="line"></span><br><span class="line">通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。它不但可以分析指定应用程序的性能问题 (per thread)，也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。</span><br><span class="line"></span><br><span class="line">最初的时候，它叫做 Performance counter，在 2.6.31 中第一次亮相。此后他成为内核开发最为活跃的一个领域。在 2.6.32 中它正式改名为 Performance Event，因为 perf 已不再仅仅作为 PMU 的抽象，而是能够处理所有的性能相关的事件。</span><br><span class="line"></span><br><span class="line">使用 perf，您可以分析程序运行期间发生的硬件事件，比如 instructions retired ，processor clock cycles 等；您也可以分析软件事件，比如 Page Fault 和进程切换。</span><br><span class="line"></span><br><span class="line">这使得 Perf 拥有了众多的性能分析能力，举例来说，使用 Perf 可以计算每个时钟周期内的指令数，称为 IPC，IPC 偏低表明代码没有很好地利用 CPU。Perf 还可以对程序进行函数级别的采样，从而了解程序的性能瓶颈究竟在哪里等等。Perf 还可以替代 strace，可以添加动态内核 probe 点，还可以做 benchmark 衡量调度器的好坏。。。</span><br><span class="line"></span><br><span class="line">Perf通过系统调用`sys_perf_event_open` 陷入到内核中，内核根据perf 提供的信息在PMU（Performance Monitoring Unit）上初始化一个硬件性能计数器（PMC: Performance Monitoring Counter）。PMC随着指定硬件事件的发生而自动累加。在PMC 溢出时，PMU 触发一个PMI（Performance Monitoring Interrupt）中断。内核在PMI 中断的处理函数中保存PMC 的计数值，触发中断时的指令地址，当前时间戳以及当前进程的PID，TID，comm 等信息。我们把这些信息统称为一个采样（sample）。内核会将收集到的sample 放入用于跟用户空间通信的Ring Buffer。用户空间里的perf 分析程序采用mmap 机制从ring buffer 中读入采样，并对其解析。</span><br><span class="line"></span><br><span class="line">## 背景知识</span><br><span class="line">有些背景知识是分析性能问题时需要了解的。比如硬件 cache；再比如操作系统内核。应用程序的行为细节往往是和这些东西互相牵扯的，这些底层的东西会以意想不到的方式影响应用程序的性能，比如某些程序无法充分利用 cache，从而导致性能下降。比如不必要地调用过多的系统调用，造成频繁的内核 / 用户切换。等等。方方面面，这里只是为本文的后续内容做一些铺垫，关于调优还有很多东西，我所不知道的比知道的要多的多。</span><br><span class="line"></span><br><span class="line">当算法已经优化，代码不断精简，人们调到最后，便需要斤斤计较了。cache 啊，流水线啊一类平时不大注意的东西也必须精打细算了。</span><br><span class="line"></span><br><span class="line">### 硬件特性之 cache</span><br><span class="line">内存读写是很快的，但还是无法和处理器的指令执行速度相比。为了从内存中读取指令和数据，处理器需要等待，用处理器的时间来衡量，这种等待非常漫长。Cache 是一种 SRAM，它的读写速率非常快，能和处理器处理速度相匹配。因此将常用的数据保存在 cache 中，处理器便无须等待，从而提高性能。Cache 的尺寸一般都很小，充分利用 cache 是软件调优非常重要的部分。</span><br><span class="line"></span><br><span class="line">### 硬件特性之流水线，超标量体系结构，乱序执行</span><br><span class="line">提高性能最有效的方式之一就是并行。处理器在硬件设计时也尽可能地并行，比如流水线，超标量体系结构以及乱序执行。</span><br><span class="line"></span><br><span class="line">处理器处理一条指令需要分多个步骤完成，比如先取指令，然后完成运算，最后将计算结果输出到总线上。在处理器内部，这可以看作一个三级流水线，如下图所示：</span><br><span class="line"></span><br><span class="line">![](/img/20201126102100.gif)</span><br><span class="line">图 1. 处理器流水线</span><br><span class="line"></span><br><span class="line">指令从左边进入处理器，上图中的流水线有三级，一个时钟周期内可以同时处理三条指令，分别被流水线的不同部分处理。</span><br><span class="line"></span><br><span class="line">超标量（superscalar）指一个时钟周期发射多条指令的流水线机器架构，比如 Intel 的 Pentium 处理器，内部有两个执行单元，在一个时钟周期内允许执行两条指令。</span><br><span class="line"></span><br><span class="line">此外，在处理器内部，不同指令所需要的处理步骤和时钟周期是不同的，如果严格按照程序的执行顺序执行，那么就无法充分利用处理器的流水线。因此指令有可能被乱序执行。</span><br><span class="line"></span><br><span class="line">上述三种并行技术对所执行的指令有一个基本要求，即相邻的指令相互没有依赖关系。假如某条指令需要依赖前面一条指令的执行结果数据，那么 pipeline 便失去作用，因为第二条指令必须等待第一条指令完成。因此好的软件必须尽量避免这种代码的生成。</span><br><span class="line"></span><br><span class="line">### 硬件特性之分支预测</span><br><span class="line">分支指令对软件性能有比较大的影响。尤其是当处理器采用流水线设计之后，假设流水线有三级，当前进入流水的第一条指令为分支指令。假设处理器顺序读取指令，那么如果分支的结果是跳转到其他指令，那么被处理器流水线预取的后续两条指令都将被放弃，从而影响性能。为此，很多处理器都提供了分支预测功能，根据同一条指令的历史执行记录进行预测，读取最可能的下一条指令，而并非顺序读取指令。</span><br><span class="line"></span><br><span class="line">分支预测对软件结构有一些要求，对于重复性的分支指令序列，分支预测硬件能得到较好的预测结果，而对于类似 switch case 一类的程序结构，则往往无法得到理想的预测结果。</span><br><span class="line"></span><br><span class="line">上面介绍的几种处理器特性对软件的性能有很大的影响，然而依赖时钟进行定期采样的 profiler 模式无法揭示程序对这些处理器硬件特性的使用情况。处理器厂商针对这种情况，在硬件中加入了 PMU 单元，即 performance monitor unit。</span><br><span class="line"></span><br><span class="line">PMU 允许软件针对某种硬件事件设置 counter，此后处理器便开始统计该事件的发生次数，当发生的次数超过 counter 内设置的值后，便产生中断。比如 cache miss 达到某个值后，PMU 便能产生相应的中断。</span><br><span class="line"></span><br><span class="line">捕获这些中断，便可以考察程序对这些硬件特性的利用效率了。</span><br><span class="line"></span><br><span class="line">### Tracepoints</span><br><span class="line">Tracepoint 是散落在内核源代码中的一些 hook，一旦使能，它们便可以在特定的代码被运行到时被触发，这一特性可以被各种 trace/debug 工具所使用。Perf 就是该特性的用户之一。</span><br><span class="line"></span><br><span class="line">假如您想知道在应用程序运行期间，内核内存管理模块的行为，便可以利用潜伏在 slab 分配器中的 tracepoint。当内核运行到这些 tracepoint 时，便会通知 perf。</span><br><span class="line"></span><br><span class="line">Perf 将 tracepoint 产生的事件记录下来，生成报告，通过分析这些报告，调优人员便可以了解程序运行时期内核的种种细节，对性能症状作出更准确的诊断。</span><br><span class="line"></span><br><span class="line">## 性能事件</span><br><span class="line"></span><br><span class="line">在程序运行中发生的，可能影响到程序性能的软硬件件事件，使用perf list命令可以显示当前软硬件环境下支持的所有事件，大致可以分为三种：</span><br><span class="line"></span><br><span class="line">- Hardware Event由PMU部件产生，在特定的条件下探测性能事件是否发生以及发生的次数。比如CPU周期、分支指令、TLB重填例外、Cache缺失等。</span><br><span class="line">- Software Event是内核产生的事件，分布在各个功能模块中，统计和操作系统相关性能事件。比如系统调用次数、上下文切换次数、任务迁移次数、缺页例外次数等。</span><br><span class="line">- Tracepoint Event是内核中静态tracepoint所触发的事件，这些tracepoint用来判断程序运行期间内核的行为细节，比如slab分配器的分配次数等。基于ftrace框架实现，内核中的所有tracepoint都可以作为perf的性能事件</span><br><span class="line"></span><br><span class="line">`cat /sys/kernel/debug/tracing/available_events`，可查看当前系统的所有tracepoint分成了几大类：</span><br><span class="line">- ext4 文件系统的tracepoint events，如果是其它文件系统，比如XFS，也有对应的tracepoint event;</span><br><span class="line">- jbd2 文件日志的tracepoint events;</span><br><span class="line">- skb 内存的tracepoint events;</span><br><span class="line">- net,napi,sock,udp:网络的tracepoint events;</span><br><span class="line">- scsi, block, writeback 磁盘IO</span><br><span class="line">- kmem 内存</span><br><span class="line">- sched 调度</span><br><span class="line">- syscalls 系统调用</span><br><span class="line"></span><br><span class="line">## perf 的基本使用</span><br><span class="line">说明一个工具的最佳途径是列举一个例子。</span><br><span class="line"></span><br><span class="line">考查下面这个例子程序。其中函数`longa()`是个很长的循环，比较浪费时间。函数`foo1`和`foo2`将分别调用该函数 10 次，以及 100 次。</span><br><span class="line"></span><br><span class="line">清单 1. 测试程序 t1</span><br><span class="line">```C</span><br><span class="line">//test.c </span><br><span class="line">void longa() </span><br><span class="line">&#123; </span><br><span class="line">  int i,j; </span><br><span class="line">  for(i = 0; i &lt; 1000000; i++) </span><br><span class="line">  j=i; //am I silly or crazy? I feel boring and desperate. </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">void foo2() </span><br><span class="line">&#123; </span><br><span class="line">  int i; </span><br><span class="line">  for(i=0 ; i &lt; 10; i++) </span><br><span class="line">       longa(); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">void foo1() </span><br><span class="line">&#123; </span><br><span class="line">  int i; </span><br><span class="line">  for(i = 0; i&lt; 100; i++) </span><br><span class="line">     longa(); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">int main(void) </span><br><span class="line">&#123; </span><br><span class="line">  foo1(); </span><br><span class="line">  foo2(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找到这个程序的性能瓶颈无需任何工具，肉眼的阅读便可以完成。<code>Longa()</code>是这个程序的关键，只要提高它的速度，就可以极大地提高整个程序的运行效率。</p>
<p>但，因为其简单，却正好可以用来演示 perf 的基本使用。假如 perf 告诉您这个程序的瓶颈在别处，您就不必再浪费宝贵时间阅读本文了。</p>
<h3 id="准备使用-perf"><a href="#准备使用-perf" class="headerlink" title="准备使用 perf"></a>准备使用 perf</h3><p>安装 perf 非常简单，只要您有 2.6.31 以上的内核源代码，那么进入 tools/perf 目录然后敲入下面两个命令即可：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><br>性能调优工具如 perf，Oprofile 等的基本原理都是对被监测对象进行采样，最简单的情形是根据 tick 中断进行采样，即在 tick 中断内触发采样点，在采样点里判断程序当时的上下文。假如一个程序 90% 的时间都花费在函数 foo() 上，那么 90% 的采样点都应该落在函数 foo() 的上下文中。运气不可捉摸，但我想只要采样频率足够高，采样时间足够长，那么以上推论就比较可靠。因此，通过 tick 触发采样，我们便可以了解程序中哪些地方最耗时间，从而重点分析。</p>
<p>稍微扩展一下思路，就可以发现改变采样的触发条件使得我们可以获得不同的统计数据：</p>
<p>以时间点 ( 如 tick) 作为事件触发采样便可以获知程序运行时间的分布。</p>
<p>以 cache miss 事件触发采样便可以知道 cache miss 的分布，即 cache 失效经常发生在哪些程序代码中。如此等等。</p>
<p>因此让我们先来了解一下 perf 中能够触发采样的事件有哪些。</p>
<h3 id="perf-—help"><a href="#perf-—help" class="headerlink" title="perf —help"></a>perf —help</h3><p>先了解一下概貌</p>
<p>perf 命令用法还是挺简单的，根据功能区分了COMMAND，每个COMMAND有各自的用法。</p>
<p>用得比较多的有list, record, report, script, stat, top。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">usage: perf [--version] [--help] [OPTIONS] COMMAND [ARGS]</span><br><span class="line"></span><br><span class="line">The most commonly used perf commands are:</span><br><span class="line">  annotate        Read perf.data (created by perf record) and display annotated code</span><br><span class="line">  archive         Create archive with object files with build-ids found in perf.data file</span><br><span class="line">  bench           General framework for benchmark suites</span><br><span class="line">  buildid-cache   Manage build-id cache.</span><br><span class="line">  buildid-list    List the buildids in a perf.data file</span><br><span class="line">  data            Data file related processing</span><br><span class="line">  diff            Read perf.data files and display the differential profile</span><br><span class="line">  evlist          List the event names in a perf.data file</span><br><span class="line">  inject          Filter to augment the events stream with additional information</span><br><span class="line">  kmem            Tool to trace/measure kernel memory properties</span><br><span class="line">  kvm             Tool to trace/measure kvm guest os</span><br><span class="line">  list            List all symbolic event types</span><br><span class="line">  lock            Analyze lock events</span><br><span class="line">  mem             Profile memory accesses</span><br><span class="line">  record          Run a command and record its profile into perf.data</span><br><span class="line">  report          Read perf.data (created by perf record) and display the profile</span><br><span class="line">  sched           Tool to trace/measure scheduler properties (latencies)</span><br><span class="line">  script          Read perf.data (created by perf record) and display trace output</span><br><span class="line">  stat            Run a command and gather performance counter statistics</span><br><span class="line">  test            Runs sanity tests.</span><br><span class="line">  timechart       Tool to visualize total system behavior during a workload</span><br><span class="line">  top             System profiling tool.</span><br><span class="line">  probe           Define new dynamic tracepoints</span><br><span class="line">  trace           strace inspired tool</span><br><span class="line"></span><br><span class="line">See &#x27;perf help COMMAND&#x27; for more information on a specific command.</span><br></pre></td></tr></table></figure>
<h3 id="Perf-list，perf-事件"><a href="#Perf-list，perf-事件" class="headerlink" title="Perf list，perf 事件"></a>Perf list，perf 事件</h3><p>使用<code>perf list</code>命令可以列出所有能够触发 perf 采样点的事件。比如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ perf <span class="built_in">list</span> </span><br><span class="line"> List of pre-defined <span class="title function_">events</span> <span class="params">(to be used in -e)</span>: </span><br><span class="line"> cpu-cycles OR cycles [Hardware event] </span><br><span class="line"> instructions [Hardware event] </span><br><span class="line">…</span><br><span class="line"> cpu-clock [Software event] </span><br><span class="line"> task-clock [Software event] </span><br><span class="line"> context-switches OR cs [Software event] </span><br><span class="line">…</span><br><span class="line"> ext4:ext4_allocate_inode [Tracepoint event] </span><br><span class="line"> kmem:kmalloc [Tracepoint event] </span><br><span class="line"> module:module_load [Tracepoint event] </span><br><span class="line"> workqueue:workqueue_execution [Tracepoint event] </span><br><span class="line"> sched:sched_&#123;wakeup,<span class="keyword">switch</span>&#125; [Tracepoint event] </span><br><span class="line"> syscalls:sys_&#123;enter,<span class="built_in">exit</span>&#125;_epoll_wait [Tracepoint event] </span><br><span class="line">…</span><br></pre></td></tr></table></figure><br>不同的系统会列出不同的结果，在 2.6.35 版本的内核中，该列表已经相当的长，但无论有多少，我们可以将它们划分为三类：</p>
<ul>
<li>Hardware Event 是由 PMU 硬件产生的事件，比如 cache 命中，当您需要了解程序对硬件特性的使用情况时，便需要对这些事件进行采样；</li>
<li>Software Event 是内核软件产生的事件，比如进程切换，tick 数等 ;</li>
<li>Tracepoint event 是内核中的静态 tracepoint 所触发的事件，这些 tracepoint 用来判断程序运行期间内核的行为细节，比如 slab 分配器的分配次数等。</li>
</ul>
<p>上述每一个事件都可以用于采样，并生成一项统计数据，时至今日，尚没有文档对每一个 event 的含义进行详细解释。我希望能和大家一起努力，以弄明白更多的 event 为目标。。。</p>
<h3 id="Perf-stat"><a href="#Perf-stat" class="headerlink" title="Perf stat"></a>Perf stat</h3><p>做任何事都最好有条有理。老手往往能够做到不慌不忙，循序渐进，而新手则往往东一下，西一下，不知所措。</p>
<p>面对一个问题程序，最好采用自顶向下的策略。先整体看看该程序运行时各种统计事件的大概，再针对某些方向深入细节。而不要一下子扎进琐碎细节，会一叶障目的。</p>
<p>有些程序慢是因为计算量太大，其多数时间都应该在使用 CPU 进行计算，这叫做 CPU bound 型；有些程序慢是因为过多的 IO，这种时候其 CPU 利用率应该不高，这叫做 IO bound 型；对于 CPU bound 程序的调优和 IO bound 的调优是不同的。</p>
<p>如果您认同这些说法的话，Perf stat 应该是您最先使用的一个工具。它通过概括精简的方式提供被调试程序运行的整体情况和汇总数据。</p>
<p>还记得我们前面准备的那个例子程序么？现在将它编译为可执行文件 t1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc –o t1 – g test.c</span><br></pre></td></tr></table></figure><br>下面演示了 perf stat 针对程序 t1 的输出：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$perf stat ./t1 </span><br><span class="line"> Performance counter stats <span class="keyword">for</span> <span class="string">&#x27;./t1&#x27;</span>: </span><br><span class="line"> </span><br><span class="line"> <span class="number">262.738415</span> task-clock-msecs ## <span class="number">0.991</span> CPUs </span><br><span class="line"> <span class="number">2</span> context-switches ## <span class="number">0.000</span> M/sec </span><br><span class="line"> <span class="number">1</span> CPU-migrations ## <span class="number">0.000</span> M/sec </span><br><span class="line"> <span class="number">81</span> page-faults ## <span class="number">0.000</span> M/sec </span><br><span class="line"> <span class="number">9478851</span> cycles ## <span class="number">36.077</span> M/sec (scaled from <span class="number">98.24</span>%) </span><br><span class="line"> <span class="number">6771</span> instructions ## <span class="number">0.001</span> IPC (scaled from <span class="number">98.99</span>%) </span><br><span class="line"> <span class="number">111114049</span> branches ## <span class="number">422.908</span> M/sec (scaled from <span class="number">99.37</span>%) </span><br><span class="line"> <span class="number">8495</span> branch-misses ## <span class="number">0.008</span> % (scaled from <span class="number">95.91</span>%) </span><br><span class="line"> <span class="number">12152161</span> cache-references ## <span class="number">46.252</span> M/sec (scaled from <span class="number">96.16</span>%) </span><br><span class="line"> <span class="number">7245338</span> cache-misses ## <span class="number">27.576</span> M/sec (scaled from <span class="number">95.49</span>%) </span><br><span class="line"> </span><br><span class="line">  <span class="number">0.265238069</span> seconds time elapsed </span><br></pre></td></tr></table></figure><br>上面告诉我们，程序 t1 是一个 CPU bound 型，因为 task-clock-msecs 接近 1。<br>对 t1 进行调优应该要找到热点 ( 即最耗时的代码片段 )，再看看是否能够提高热点代码的效率。</p>
<p>缺省情况下，除了 task-clock-msecs 之外，perf stat 还给出了其他几个最常用的统计信息：</p>
<ul>
<li>Task-clock-msecs：CPU 利用率，该值高，说明程序的多数时间花费在 CPU 计算上而非 IO。</li>
<li>Context-switches：进程切换次数，记录了程序运行过程中发生了多少次进程切换，频繁的进程切换是应该避免的。</li>
<li>Cache-misses：程序运行过程中总体的 cache 利用情况，如果该值过高，说明程序的 cache 利用不好</li>
<li>CPU-migrations：表示进程 t1 运行过程中发生了多少次 CPU 迁移，即被调度器从一个 CPU 转移到另外一个 CPU 上运行。</li>
<li>Cycles：处理器时钟，一条机器指令可能需要多个 cycles，</li>
<li>Instructions: 机器指令数目。</li>
<li>IPC：是 Instructions/Cycles 的比值，该值越大越好，说明程序充分利用了处理器的特性。</li>
<li>Cache-references: cache 命中的次数</li>
<li>Cache-misses: cache 失效的次数。</li>
</ul>
<p>通过指定 -e 选项，您可以改变 perf stat 的缺省事件 ( 关于事件，在上一小节已经说明，可以通过 perf list 来查看 )。假如您已经有很多的调优经验，可能会使用 -e 选项来查看您所感兴趣的特殊的事件。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-e &lt;event&gt;：指定性能事件（可以是多个，用,分隔列表）</span><br><span class="line">-p &lt;pid&gt;：指定待分析进程的 pid（可以是多个，用,分隔列表）</span><br><span class="line">-t &lt;tid&gt;;：指定待分析线程的 tid（可以是多个，用,分隔列表）</span><br><span class="line">-a：从所有 CPU 收集系统数据</span><br><span class="line">-d：打印更详细的信息，可重复 3 次</span><br><span class="line">    -d：L1 和 LLC data cache</span><br><span class="line">    -d -d：dTLB 和 iTLB events</span><br><span class="line">    -d -d -d：增加 prefetch events</span><br><span class="line">-r &lt;n&gt;;：重复运行命令 n 次，打印平均值。n 设为 0 时无限循环打印</span><br><span class="line">-c &lt;cpu-list&gt;：只统计指定 CPU 列表的数据，如：0,1,3或1-2</span><br><span class="line">-A：与-a选项联用，不要将 CPU 计数聚合</span><br><span class="line">-I &lt;N msecs&gt;：每隔 N 毫秒打印一次计数器的变化，N 最小值为 100 毫秒</span><br></pre></td></tr></table></figure>
<h3 id="perf-top"><a href="#perf-top" class="headerlink" title="perf  top"></a>perf  top</h3><p>使用 perf stat 的时候，往往您已经有一个调优的目标。比如我刚才写的那个无聊程序 t1。</p>
<p>也有些时候，您只是发现系统性能无端下降，并不清楚究竟哪个进程成为了贪吃的 hog。</p>
<p>此时需要一个类似 top 的命令，列出所有值得怀疑的进程，从中找到需要进一步审查的家伙。类似法制节目中办案民警常常做的那样，通过查看监控录像从茫茫人海中找到行为古怪的那些人，而不是到大街上抓住每一个人来审问。</p>
<p>Perf top 用于实时显示当前系统的性能统计信息。该命令主要用来观察整个系统当前的状态，比如可以通过查看该命令的输出来查看当前系统最耗时的内核函数或某个用户进程。</p>
<p>让我们再设计一个例子来演示吧。</p>
<p>不知道您怎么想，反正我觉得做一件有益的事情很难，但做点儿坏事儿却非常容易。我很快就想到了如代码清单 2 所示的一个程序：</p>
<p>清单 2. 一个死循环<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) i++;</span><br></pre></td></tr></table></figure><br>我叫他 t2。启动 t2，然后用 perf top 来观察：</p>
<p>下面是 perf top 的可能输出：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PerfTop: <span class="number">705</span> irqs/sec kernel:<span class="number">60.4</span>% [<span class="number">1000</span>Hz cycles] </span><br><span class="line">-------------------------------------------------- </span><br><span class="line">sampl pcnt function DSO </span><br><span class="line"><span class="number">1503.00</span> <span class="number">49.2</span>% t2 </span><br><span class="line"><span class="number">72.00</span> <span class="number">2.2</span>% pthread_mutex_lock /lib/libpthread<span class="number">-2.12</span>.so </span><br><span class="line"><span class="number">68.00</span> <span class="number">2.1</span>% delay_tsc [kernel.kallsyms] </span><br><span class="line"><span class="number">55.00</span> <span class="number">1.7</span>% aes_dec_blk [aes_i586] </span><br><span class="line"><span class="number">55.00</span> <span class="number">1.7</span>% drm_clflush_pages [drm] </span><br><span class="line"><span class="number">52.00</span> <span class="number">1.6</span>% system_call [kernel.kallsyms] </span><br><span class="line"><span class="number">49.00</span> <span class="number">1.5</span>% __memcpy_ssse3 /lib/libc<span class="number">-2.12</span>.so </span><br><span class="line"><span class="number">48.00</span> <span class="number">1.4</span>% __strstr_ia32 /lib/libc<span class="number">-2.12</span>.so </span><br><span class="line"><span class="number">46.00</span> <span class="number">1.4</span>% unix_poll [kernel.kallsyms] </span><br><span class="line"><span class="number">42.00</span> <span class="number">1.3</span>% __ieee754_pow /lib/libm<span class="number">-2.12</span>.so </span><br><span class="line"><span class="number">41.00</span> <span class="number">1.2</span>% do_select [kernel.kallsyms] </span><br><span class="line"><span class="number">40.00</span> <span class="number">1.2</span>% pixman_rasterize_edges libpixman<span class="number">-1.</span>so.<span class="number">0.18</span>.<span class="number">0</span> </span><br><span class="line"><span class="number">37.00</span> <span class="number">1.1</span>% _raw_spin_lock_irqsave [kernel.kallsyms] </span><br><span class="line"><span class="number">36.00</span> <span class="number">1.1</span>% _int_malloc /lib/libc<span class="number">-2.12</span>.so </span><br></pre></td></tr></table></figure><br>很容易便发现 t2 是需要关注的可疑程序。不过其作案手法太简单：肆无忌惮地浪费着 CPU。所以我们不用再做什么其他的事情便可以找到问题所在。但现实生活中，影响性能的程序一般都不会如此愚蠢，所以我们往往还需要使用其他的 perf 工具进一步分析。</p>
<p>通过添加 -e 选项，您可以列出造成其他事件的 TopN 个进程 / 函数。比如 -e cache-miss，用来看看谁造成的 cache miss 最多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-e &lt;event&gt;：指明要分析的性能事件。</span><br><span class="line">-p &lt;pid&gt;：仅分析目标进程及其创建的线程。</span><br><span class="line">-k &lt;path&gt;：带符号表的内核映像所在的路径。</span><br><span class="line">-K：不显示属于内核或模块的符号。</span><br><span class="line">-U：不显示属于用户态程序的符号。</span><br><span class="line">-d &lt;n&gt;：界面的刷新周期，默认为2s。</span><br><span class="line">-g：得到函数的调用关系图。</span><br></pre></td></tr></table></figure>
<h2 id="使用-perf-record-解读-report"><a href="#使用-perf-record-解读-report" class="headerlink" title="使用 perf record, 解读 report"></a>使用 perf record, 解读 report</h2><p>使用 top 和 stat 之后，您可能已经大致有数了。要进一步分析，便需要一些粒度更细的信息。比如说您已经断定目标程序计算量较大，也许是因为有些代码写的不够精简。那么面对长长的代码文件，究竟哪几行代码需要进一步修改呢？这便需要使用 perf record 记录单个函数级别的统计信息，并使用 perf report 来显示统计结果。</p>
<p>perf record收集一段时间内的性能事件到文件 perf.data，随后需要用perf report命令分析</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-e &lt;event&gt;：指定性能事件（可以是多个，用,分隔列表）</span><br><span class="line">-p &lt;pid&gt;：指定待分析进程的 pid（可以是多个，用,分隔列表）</span><br><span class="line">-t &lt;tid&gt;：指定待分析线程的 tid（可以是多个，用,分隔列表）</span><br><span class="line">-u &lt;uid&gt;：指定收集的用户数据，uid为名称或数字</span><br><span class="line">-a：从所有 CPU 收集系统数据</span><br><span class="line">-g：开启 call-graph (stack chain/backtrace) 记录</span><br><span class="line">-C &lt;cpu-list&gt;：只统计指定 CPU 列表的数据，如：0,1,3或1-2</span><br><span class="line">-r &lt;RT priority&gt;：perf 程序以SCHED_FIFO实时优先级RT priority运行这里填入的数值越大，进程优先级越高（即 nice 值越小）</span><br><span class="line">-c &lt;count&gt;： 事件每发生 count 次采一次样</span><br><span class="line">-F &lt;n&gt;：每秒采样 n 次</span><br><span class="line">-o &lt;output.data&gt;：指定输出文件output.data，默认输出到perf.data</span><br></pre></td></tr></table></figure>
<p>—call-graph 堆栈展开的方式，perf支持3种方式：<code>perf record -g --call-graph (fp,dwarf,lbr)</code></p>
<ul>
<li>fp: perf默认采用的方式，需要关闭对堆栈有影响的编译优化(-fno-omit-frame-pointer,-fno-optimize-sibling-calls)，否则可能获取不到正确的堆栈信息。<ul>
<li>优点：性能消耗小，生成文件小，report速度快。</li>
<li>缺点：不遵守X86Calling convention的函数无法获取堆栈信息，内联函数无法获取堆栈信息。</li>
</ul>
</li>
<li>dwarf:<ul>
<li>优点：堆栈信息最详细，内联函数也可以获取堆栈信息。</li>
<li>缺点：性能消耗大，生成文件大，report时间长。</li>
</ul>
</li>
<li>lbr:<ul>
<li>优点：性能消耗极小，堆栈信息非常准确</li>
<li>缺点：需要处理器支持（尝试了阿里云的ECS并不支持，所以实际没有使用过）。</li>
</ul>
</li>
</ul>
<p>您的调优应该将注意力集中到百分比高的热点代码片段上，假如一段代码只占用整个程序运行时间的 0.1%，即使您将其优化到仅剩一条机器指令，恐怕也只能将整体的程序性能提高 0.1%。俗话说，好钢用在刀刃上，不必我多说了。</p>
<p>仍以 t1 为例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perf record – e cpu-clock ./t1 </span><br><span class="line">perf report</span><br></pre></td></tr></table></figure><br>结果如下图所示：</p>
<p><img src="/img/16060378746.jpg" alt=""><br>图 2. perf report 示例</p>
<p>不出所料，hot spot 是<code>longa()</code>函数。</p>
<p>但，代码是非常复杂难说的，t1 程序中的 foo1() 也是一个潜在的调优对象，为什么要调用 100 次那个无聊的 longa() 函数呢？但我们在上图中无法发现 foo1 和 foo2，更无法了解他们的区别了。</p>
<p>我曾发现自己写的一个程序居然有近一半的时间花费在 string 类的几个方法上，string 是 C++ 标准，我绝不可能写出比 STL 更好的代码了。因此我只有找到自己程序中过多使用 string 的地方。因此我很需要按照调用关系进行显示的统计信息。</p>
<p>使用 perf 的 -g 选项便可以得到需要的信息：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perf record – e cpu-clock – g ./t1 </span><br><span class="line">perf report</span><br></pre></td></tr></table></figure><br>结果如下图所示：</p>
<p><img src="/img/16060378749.jpg" alt=""><br>图 3. perf – g report 示例</p>
<p>通过对 calling graph 的分析，能很方便地看到 91% 的时间都花费在 foo1() 函数中，因为它调用了 100 次 longa() 函数，因此假如 longa() 是个无法优化的函数，那么程序员就应该考虑优化 foo1，减少对 longa() 的调用次数。</p>
<p>之前的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> perf record -g -a --call-graph dwarf,65000 -p 进程号 -d 1 -b</span><br><span class="line"><span class="built_in">sudo</span> perf report -i perf.data &gt; perf.txt</span><br><span class="line"></span><br><span class="line">火焰图：</span><br><span class="line">perf report -i perf.data &gt; perf.txt</span><br><span class="line">perf script &gt; out.perf</span><br><span class="line"></span><br><span class="line">./stackcollapse-perf.pl out.perf &gt; out.folded</span><br><span class="line">./flamegraph.pl out.folded &gt; kernel.svg</span><br></pre></td></tr></table></figure>
<h2 id="Perf-Script"><a href="#Perf-Script" class="headerlink" title="Perf Script"></a>Perf Script</h2><p>读取 Perf Record 结果。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-i, --input &lt;file&gt;    input file name</span><br><span class="line">-G, --hide-call-graph</span><br><span class="line">                      When printing symbols do not display call chain</span><br><span class="line">-F, --fields &lt;str&gt;    comma separated output fields prepend with &#x27;type:&#x27;. Valid types: hw,sw,trace,raw. Fields: comm,tid,pid,time,cpu,event,trace,ip,sym,dso,addr,symoff,period</span><br><span class="line">-a, --all-cpus        system-wide collection from all CPUs</span><br><span class="line">-S, --symbols &lt;symbol[,symbol...]&gt;</span><br><span class="line">                      only consider these symbols</span><br><span class="line">-C, --cpu &lt;cpu&gt;       list of cpus to profile</span><br><span class="line">-c, --comms &lt;comm[,comm...]&gt;</span><br><span class="line">                      only display events for these comms</span><br><span class="line">    --pid &lt;pid[,pid...]&gt;</span><br><span class="line">                      only consider symbols in these pids</span><br><span class="line">    --tid &lt;tid[,tid...]&gt;</span><br><span class="line">                      only consider symbols in these tids</span><br><span class="line">    --time &lt;str&gt;      Time span of interest (start,stop)</span><br><span class="line">    --show-kernel-path</span><br><span class="line">                      Show the path of [kernel.kallsyms]</span><br><span class="line">    --show-task-events</span><br><span class="line">                      Show the fork/comm/exit events</span><br><span class="line">    --show-mmap-events</span><br><span class="line">                      Show the mmap events</span><br><span class="line">    --per-event-dump  Dump trace output to files named by the monitored events</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="使用-PMU-的例子"><a href="#使用-PMU-的例子" class="headerlink" title="使用 PMU 的例子"></a>使用 PMU 的例子</h2><p>例子 t1 和 t2 都较简单。所谓魔高一尺，道才能高一丈。要想演示 perf 更加强大的能力，我也必须想出一个高明的影响性能的例子，我自己想不出，只好借助于他人。下面这个例子 t3 参考了文章“Branch and Loop Reorganization to Prevent Mispredicts”</p>
<p>该例子考察程序对奔腾处理器分支预测的利用率，如前所述，分支预测能够显著提高处理器的性能，而分支预测失败则显著降低处理器的性能。首先给出一个存在 BTB 失效的例子：</p>
<p>清单 3. 存在 BTB 失效的例子程序<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">int</span> i,j; </span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++) </span><br><span class="line"> j+=<span class="number">2</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"> <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">100000000</span>; i++) </span><br><span class="line"> foo(); </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>用 gcc 编译生成测试程序 t3:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc – o t3 – O0 test.c</span><br></pre></td></tr></table></figure><br>用 perf stat 考察分支预测的使用情况：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[lm@ovispoly perf]$ ./perf stat ./t3 </span><br><span class="line"> </span><br><span class="line"> Performance counter stats <span class="keyword">for</span> <span class="string">&#x27;./t3&#x27;</span>: </span><br><span class="line"> </span><br><span class="line"><span class="number">6240.758394</span> task-clock-msecs ## <span class="number">0.995</span> CPUs </span><br><span class="line"><span class="number">126</span> context-switches ## <span class="number">0.000</span> M/sec </span><br><span class="line"><span class="number">12</span> CPU-migrations ## <span class="number">0.000</span> M/sec </span><br><span class="line"><span class="number">80</span> page-faults ## <span class="number">0.000</span> M/sec </span><br><span class="line"><span class="number">17683221</span> cycles ## <span class="number">2.834</span> M/sec (scaled from <span class="number">99.78</span>%) </span><br><span class="line"><span class="number">10218147</span> instructions ## <span class="number">0.578</span> IPC (scaled from <span class="number">99.83</span>%) </span><br><span class="line"><span class="number">2491317951</span> branches ## <span class="number">399.201</span> M/sec (scaled from <span class="number">99.88</span>%) </span><br><span class="line"><span class="number">636140932</span> branch-misses ## <span class="number">25.534</span> % (scaled from <span class="number">99.63</span>%) </span><br><span class="line"><span class="number">126383570</span> cache-references ## <span class="number">20.251</span> M/sec (scaled from <span class="number">99.68</span>%) </span><br><span class="line"><span class="number">942937348</span> cache-misses ## <span class="number">151.093</span> M/sec (scaled from <span class="number">99.58</span>%) </span><br><span class="line"> </span><br><span class="line"> <span class="number">6.271917679</span> seconds time elapsed</span><br></pre></td></tr></table></figure><br>可以看到 branche-misses 的情况比较严重，25% 左右。我测试使用的机器的处理器为 Pentium4，其 BTB 的大小为 16。而 test.c 中的循环迭代为 20 次，BTB 溢出，所以处理器的分支预测将不准确。</p>
<p>对于上面这句话我将简要说明一下，但关于 BTB 的细节，请阅读参考文献。</p>
<p>for 循环编译成为 IA 汇编后如下：</p>
<p>清单 4. 循环的汇编<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C code </span></span><br><span class="line"> <span class="keyword">for</span> ( i=<span class="number">0</span>; i &lt; <span class="number">20</span>; i++ ) </span><br><span class="line"> &#123; … &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//Assembly code; </span></span><br><span class="line"> mov    esi, data </span><br><span class="line"> mov    ecx, <span class="number">0</span> </span><br><span class="line"> ForLoop: </span><br><span class="line"> cmp    ecx, <span class="number">20</span> </span><br><span class="line"> jge    </span><br><span class="line"> EndForLoop </span><br><span class="line">…</span><br><span class="line"> add    ecx, <span class="number">1</span> </span><br><span class="line"> jmp    ForLoop </span><br><span class="line"> EndForLoop:</span><br></pre></td></tr></table></figure><br>可以看到，每次循环迭代中都有一个分支语句 jge，因此在运行过程中将有 20 次分支判断。每次分支判断都将写入 BTB，但 BTB 是一个 ring buffer，16 个 slot 写满后便开始覆盖。假如迭代次数正好为 16，或者小于 16，则完整的循环将全部写入 BTB，比如循环迭代次数为 4 次，则 BTB 应该如下图所示：</p>
<p><img src="/img/16060378750.jpg" alt=""><br>图 4. BTB buffer</p>
<p>这个 buffer 完全精确地描述了整个循环迭代的分支判定情况，因此下次运行同一个循环时，处理器便可以做出完全正确的预测。但假如迭代次数为 20，则该 BTB 随着时间推移而不能完全准确地描述该循环的分支预测执行情况，处理器将做出错误的判断。</p>
<p>我们将测试程序进行少许的修改，将迭代次数从 20 减少到 10，为了让逻辑不变，j++ 变成了 j+=2；</p>
<p>清单 5. 没有 BTB 失效的代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">int</span> i,j; </span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; <span class="number">10</span>; i++) </span><br><span class="line"> j+=<span class="number">2</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">int</span> i; </span><br><span class="line"> <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt; <span class="number">100000000</span>; i++) </span><br><span class="line"> foo(); </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>此时再次用 perf stat 采样得到如下结果：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[lm@ovispoly perf]$ ./perf stat ./t3 </span><br><span class="line"> </span><br><span class="line"> Performance counter stats <span class="keyword">for</span> <span class="string">&#x27;./t3: </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">2784.004851 task-clock-msecs ## 0.927 CPUs </span></span><br><span class="line"><span class="string">90 context-switches ## 0.000 M/sec </span></span><br><span class="line"><span class="string">8 CPU-migrations ## 0.000 M/sec </span></span><br><span class="line"><span class="string">81 page-faults ## 0.000 M/sec </span></span><br><span class="line"><span class="string">33632545 cycles ## 12.081 M/sec (scaled from 99.63%) </span></span><br><span class="line"><span class="string">42996 instructions ## 0.001 IPC (scaled from 99.71%) </span></span><br><span class="line"><span class="string">1474321780 branches ## 529.569 M/sec (scaled from 99.78%) </span></span><br><span class="line"><span class="string">49733 branch-misses ## 0.003 % (scaled from 99.35%) </span></span><br><span class="line"><span class="string">7073107 cache-references ## 2.541 M/sec (scaled from 99.42%) </span></span><br><span class="line"><span class="string">47958540 cache-misses ## 17.226 M/sec (scaled from 99.33%) </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"> 3.002673524 seconds time elapsed</span></span><br></pre></td></tr></table></figure><br>Branch-misses 减少了。</p>
<h2 id="特殊用法以及内核调优示例"><a href="#特殊用法以及内核调优示例" class="headerlink" title="特殊用法以及内核调优示例"></a>特殊用法以及内核调优示例</h2><p>之前介绍了 perf 最常见的一些用法，关注于 Linux 系统上应用程序的调优。现在让我们把目光转移到内核以及其他 perf 命令上面来。</p>
<p>在内核方面，人们的兴趣五花八门，有些内核开发人员热衷于寻找整个内核中的热点代码；另一些则只关注某一个主题，比如 slab 分配器，对于其余部分则不感兴趣。对这些人而言，perf 的一些奇怪用法更受欢迎。当然，诸如 perf top，perf stat, perf record 等也是内核调优的基本手段，但用法和 part1 所描述的一样，无需重述。</p>
<p>此外虽然内核事件对应用程序开发人员而言有些陌生，但一旦了解，对应用程序的调优也很有帮助。我曾经参与开发过一个数据库应用程序，其效率很低。通过常规的热点查询，IO 统计等方法，我们找到了一些可以优化的地方，以至于将程序的效率提高了几倍。可惜对于拥有海量数据的用户，其运行时间依然无法达到要求。进一步调优需要更加详细的统计信息，可惜本人经验有限，实在是无计可施。。。从客户反馈来看，该应用的使用频率很低。作为一个程序员，为此我时常心情沮丧。。。</p>
<p>假如有 perf，那么我想我可以用它来验证自己的一些猜测，比如是否太多的系统调用，或者系统中的进程切换太频繁 ? 针对这些怀疑使用 perf 都可以拿出有用的报告，或许能找到问题吧。但过去的便无可弥补，时光不会倒流，无论我如何伤感，世界绝不会以我的意志为转移。所以我们好好学习 perf，或许可以预防某些遗憾吧。</p>
<p>这里我还要提醒读者注意，讲述 perf 的命令和语法容易，但说明什么时候使用这些命令，或者说明怎样解决实际问题则很困难。就好象说明电子琴上 88 个琴键的唱名很容易，但想说明如何弹奏动听的曲子则很难。</p>
<p>在简述每个命令语法的同时，我试图通过一些示例来说明这些命令的使用场景，但这只能是一种微薄的努力。因此总体说来，本文只能充当那本随同电子琴一起发售的使用说明书。。。</p>
<h3 id="使用-tracepoint"><a href="#使用-tracepoint" class="headerlink" title="使用 tracepoint"></a>使用 tracepoint</h3><p>当 perf 根据 tick 时间点进行采样后，人们便能够得到内核代码中的 hot spot。那什么时候需要使用 tracepoint 来采样呢？</p>
<p>我想人们使用 tracepoint 的基本需求是对内核的运行时行为的关心，如前所述，有些内核开发人员需要专注于特定的子系统，比如内存管理模块。这便需要统计相关内核函数的运行情况。另外，内核行为对应用程序性能的影响也是不容忽视的：</p>
<p>以之前的遗憾为例，假如时光倒流，我想我要做的是统计该应用程序运行期间究竟发生了多少次系统调用。在哪里发生的？</p>
<p>下面我用 ls 命令来演示 sys_enter 这个 tracepoint 的使用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@ovispoly /]<span class="meta"># perf stat -e raw_syscalls:sys_enter ls </span></span><br><span class="line">bin dbg etc  lib  media opt root  selinux sys usr </span><br><span class="line">boot dev home lost+found mnt proc sbin srv  tmp var </span><br><span class="line"> </span><br><span class="line"> Performance counter stats <span class="keyword">for</span> <span class="string">&#x27;ls&#x27;</span>: </span><br><span class="line"> </span><br><span class="line"><span class="number">101</span> raw_syscalls:sys_enter </span><br><span class="line"> </span><br><span class="line"> <span class="number">0.003434730</span> seconds time elapsed </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[root@ovispoly /]<span class="meta"># perf record -e raw_syscalls:sys_enter ls </span></span><br><span class="line"> </span><br><span class="line">[root@ovispoly /]<span class="meta"># perf report </span></span><br><span class="line">Failed to open .lib/ld<span class="number">-2.12</span>.so, continuing without symbols </span><br><span class="line"># Samples: <span class="number">70</span> </span><br><span class="line"># </span><br><span class="line"># Overhead Command Shared Object Symbol </span><br><span class="line"># ........ ............... ............... ...... </span><br><span class="line"># </span><br><span class="line"><span class="number">97.14</span>% ls ld<span class="number">-2.12</span>.so [.] <span class="number">0x0000000001629d</span> </span><br><span class="line"><span class="number">2.86</span>% ls [vdso] [.] <span class="number">0x00000000421424</span> </span><br><span class="line"># </span><br><span class="line"># (For a higher level overview, try: perf report --sort comm,dso) </span><br><span class="line">#</span><br></pre></td></tr></table></figure><br>这个报告详细说明了在 ls 运行期间发生了多少次系统调用 ( 上例中有 101 次 )，多数系统调用都发生在哪些地方 (97% 都发生在 ld-2.12.so 中 )。</p>
<p>有了这个报告，或许我能够发现更多可以调优的地方。比如函数 foo() 中发生了过多的系统调用，那么我就可以思考是否有办法减少其中有些不必要的系统调用。</p>
<p>您可能会说 strace 也可以做同样事情啊，的确，统计系统调用这件事完全可以用 strace 完成，但 perf 还可以干些别的，您所需要的就是修改 -e 选项后的字符串。</p>
<p>罗列 tracepoint 实在是不太地道，本文当然不会这么做。但学习每一个 tracepoint 是有意义的，类似背单词之于学习英语一样，是一项缓慢痛苦却不得不做的事情。</p>
<h3 id="Perf-probe"><a href="#Perf-probe" class="headerlink" title="Perf probe"></a>Perf probe</h3><p>tracepoint 是静态检查点，意思是一旦它在哪里，便一直在那里了，您想让它移动一步也是不可能的。内核代码有多少行？我不知道，100 万行是至少的吧，但目前 tracepoint 有多少呢？我最大胆的想象是不超过 1000 个。所以能够动态地在想查看的地方插入动态监测点的意义是不言而喻的。</p>
<p>Perf 并不是第一个提供这个功能的软件，systemTap 早就实现了。但假若您不选择 RedHat 的发行版的话，安装 systemTap 并不是件轻松愉快的事情。perf 是内核代码包的一部分，所以使用和维护都非常方便。</p>
<p>我使用的 Linux 版本为 2.6.33。因此您自己做实验时命令参数有可能不同。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@ovispoly perftest]<span class="meta"># perf probe schedule:12 cpu </span></span><br><span class="line">Added new event: </span><br><span class="line">probe:schedule (on schedule+<span class="number">52</span> with cpu) </span><br><span class="line"> </span><br><span class="line">You can now use it on all perf tools, such as: </span><br><span class="line"> </span><br><span class="line">  perf record -e probe:schedule -a sleep <span class="number">1</span> </span><br><span class="line"> </span><br><span class="line">[root@ovispoly perftest]<span class="meta"># perf record -e probe:schedule -a sleep 1 </span></span><br><span class="line">Error, output file perf.data exists, use -A to append or -f to overwrite. </span><br><span class="line"> </span><br><span class="line">[root@ovispoly perftest]<span class="meta"># perf record -f -e probe:schedule -a sleep 1 </span></span><br><span class="line">[ perf record: Woken up <span class="number">1</span> times to write data ] </span><br><span class="line">[ perf record: Captured and wrote <span class="number">0.270</span> MB perf.data (~<span class="number">11811</span> samples) ] </span><br><span class="line">[root@ovispoly perftest]<span class="meta"># perf report </span></span><br><span class="line"># Samples: <span class="number">40</span> </span><br><span class="line"># </span><br><span class="line"># Overhead Command Shared Object Symbol </span><br><span class="line"># ........ ............... ................. ...... </span><br><span class="line"># </span><br><span class="line"><span class="number">57.50</span>% init <span class="number">0</span> [k] <span class="number">0000000000000000</span> </span><br><span class="line"><span class="number">30.00</span>% firefox [vdso] [.] <span class="number">0x0000000029c424</span> </span><br><span class="line"><span class="number">5.00</span>% sleep [vdso] [.] <span class="number">0x00000000ca7424</span> </span><br><span class="line"><span class="number">5.00</span>% perf.<span class="number">2.6</span>.<span class="number">33.3</span><span class="number">-8</span> [vdso] [.] <span class="number">0x00000000ca7424</span> </span><br><span class="line"><span class="number">2.50</span>% ksoftirqd/<span class="number">0</span> [kernel] [k] <span class="number">0000000000000000</span> </span><br><span class="line"># </span><br><span class="line"># (For a higher level overview, try: perf report --sort comm,dso) </span><br><span class="line">#</span><br></pre></td></tr></table></figure><br>上例利用 probe 命令在内核函数 schedule() 的第 12 行处加入了一个动态 probe 点，和 tracepoint 的功能一样，内核一旦运行到该 probe 点时，便会通知 perf。可以理解为动态增加了一个新的 tracepoint。</p>
<p>此后便可以用 record 命令的 -e 选项选择该 probe 点，最后用 perf report 查看报表。如何解读该报表便是见仁见智了，既然您在 shcedule() 的第 12 行加入了 probe 点，想必您知道自己为什么要统计它吧？</p>
<p>比如你想跟踪kernel的某个function, 甚至某一行代码，某些变量的值。或者你想跟踪用户软件的某个function，甚至某一行代码，某些变量的值。首先要添加需要动态跟踪的对象（function, var, …），然后record，和report分析，这和前面的用法是一样的。</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">Listing variables available for tcp_sendmsg():</span><br><span class="line"></span><br><span class="line"># perf probe -V tcp_sendmsg</span><br><span class="line">Available variables at tcp_sendmsg</span><br><span class="line">        @&lt;tcp_sendmsg+0&gt;</span><br><span class="line">                size_t  size</span><br><span class="line">                struct kiocb*   iocb</span><br><span class="line">                struct msghdr*  msg</span><br><span class="line">                struct sock*    sk</span><br><span class="line">Creating a probe for tcp_sendmsg() with the &quot;size&quot; variable:</span><br><span class="line"></span><br><span class="line"># perf probe --add &#x27;tcp_sendmsg size&#x27;</span><br><span class="line">Added new event:</span><br><span class="line">  probe:tcp_sendmsg    (on tcp_sendmsg with size)</span><br><span class="line"></span><br><span class="line">You can now use it in all perf tools, such as:</span><br><span class="line"></span><br><span class="line">    perf record -e probe:tcp_sendmsg -aR sleep 1</span><br><span class="line">Tracing this probe:</span><br><span class="line"></span><br><span class="line"># perf record -e probe:tcp_sendmsg -a</span><br><span class="line">^C[ perf record: Woken up 1 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.052 MB perf.data (~2252 samples) ]</span><br><span class="line"># perf script</span><br><span class="line"># ========</span><br><span class="line"># captured on: Fri Jan 31 23:49:55 2014</span><br><span class="line"># hostname : dev1</span><br><span class="line"># os release : 3.13.1-ubuntu-12-opt</span><br><span class="line"># perf version : 3.13.1</span><br><span class="line"># arch : x86_64</span><br><span class="line"># nrcpus online : 2</span><br><span class="line"># nrcpus avail : 2</span><br><span class="line"># cpudesc : Intel(R) Xeon(R) CPU E5645 @ 2.40GHz</span><br><span class="line"># cpuid : GenuineIntel,6,44,2</span><br><span class="line"># total memory : 1796024 kB</span><br><span class="line"># cmdline : /usr/bin/perf record -e probe:tcp_sendmsg -a </span><br><span class="line"># event : name = probe:tcp_sendmsg, type = 2, config = 0x1dd, config1 = 0x0, config2 = ...</span><br><span class="line"># HEADER_CPU_TOPOLOGY info available, use -I to display</span><br><span class="line"># HEADER_NUMA_TOPOLOGY info available, use -I to display</span><br><span class="line"># pmu mappings: software = 1, tracepoint = 2, breakpoint = 5</span><br><span class="line"># ========</span><br><span class="line">#</span><br><span class="line">            sshd  1301 [001]   502.424719: probe:tcp_sendmsg: (ffffffff81505d80) size=b0</span><br><span class="line">            sshd  1301 [001]   502.424814: probe:tcp_sendmsg: (ffffffff81505d80) size=40</span><br><span class="line">            sshd  2371 [000]   502.952590: probe:tcp_sendmsg: (ffffffff81505d80) size=27</span><br><span class="line">            sshd  2372 [000]   503.025023: probe:tcp_sendmsg: (ffffffff81505d80) size=3c0</span><br><span class="line">            sshd  2372 [001]   503.203776: probe:tcp_sendmsg: (ffffffff81505d80) size=98</span><br><span class="line">            sshd  2372 [001]   503.281312: probe:tcp_sendmsg: (ffffffff81505d80) size=2d0</span><br><span class="line">            sshd  2372 [001]   503.461358: probe:tcp_sendmsg: (ffffffff81505d80) size=30</span><br><span class="line">            sshd  2372 [001]   503.670239: probe:tcp_sendmsg: (ffffffff81505d80) size=40</span><br><span class="line">            sshd  2372 [001]   503.742565: probe:tcp_sendmsg: (ffffffff81505d80) size=140</span><br><span class="line">            sshd  2372 [001]   503.822005: probe:tcp_sendmsg: (ffffffff81505d80) size=20</span><br><span class="line">            sshd  2371 [000]   504.118728: probe:tcp_sendmsg: (ffffffff81505d80) size=30</span><br><span class="line">            sshd  2371 [000]   504.192575: probe:tcp_sendmsg: (ffffffff81505d80) size=70</span><br><span class="line">[...]</span><br><span class="line">The size is shown as hexadecimal.</span><br></pre></td></tr></table></figure>
<p>跟踪某行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"># perf probe -L tcp_sendmsg</span><br><span class="line">&lt;tcp_sendmsg@/mnt/src/linux-3.14.5/net/ipv4/tcp.c:0&gt;</span><br><span class="line">      0  int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,</span><br><span class="line">                        size_t size)</span><br><span class="line">      2  &#123;</span><br><span class="line">                struct iovec *iov;</span><br><span class="line">                struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">                struct sk_buff *skb;</span><br><span class="line">      6         int iovlen, flags, err, copied = 0;</span><br><span class="line">      7         int mss_now = 0, size_goal, copied_syn = 0, offset = 0;</span><br><span class="line">                bool sg;</span><br><span class="line">                long timeo;</span><br><span class="line">[...]</span><br><span class="line">     79                 while (seglen &gt; 0) &#123;</span><br><span class="line">                                int copy = 0;</span><br><span class="line">     81                         int max = size_goal;</span><br><span class="line"></span><br><span class="line">                                skb = tcp_write_queue_tail(sk);</span><br><span class="line">     84                         if (tcp_send_head(sk)) &#123;</span><br><span class="line">     85                                 if (skb-&gt;ip_summed == CHECKSUM_NONE)</span><br><span class="line">                                                max = mss_now;</span><br><span class="line">     87                                 copy = max - skb-&gt;len;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">     90                         if (copy &lt;= 0) &#123;</span><br><span class="line">         new_segment:</span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># perf probe -V tcp_sendmsg:81</span><br><span class="line">Available variables at tcp_sendmsg:81</span><br><span class="line">        @&lt;tcp_sendmsg+537&gt;</span><br><span class="line">                bool    sg</span><br><span class="line">                int     copied</span><br><span class="line">                int     copied_syn</span><br><span class="line">                int     flags</span><br><span class="line">                int     mss_now</span><br><span class="line">                int     offset</span><br><span class="line">                int     size_goal</span><br><span class="line">                long int        timeo</span><br><span class="line">                size_t  seglen</span><br><span class="line">                struct iovec*   iov</span><br><span class="line">                struct sock*    sk</span><br><span class="line">                unsigned char*  from</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Now lets trace line 81, with the seglen variable that is checked in the loop:</span><br><span class="line"></span><br><span class="line"># perf probe --add &#x27;tcp_sendmsg:81 seglen&#x27;</span><br><span class="line">Added new event:</span><br><span class="line">  probe:tcp_sendmsg    (on tcp_sendmsg:81 with seglen)</span><br><span class="line"></span><br><span class="line">You can now use it in all perf tools, such as:</span><br><span class="line"></span><br><span class="line">    perf record -e probe:tcp_sendmsg -aR sleep 1</span><br><span class="line"></span><br><span class="line"># perf record -e probe:tcp_sendmsg -a</span><br><span class="line">^C[ perf record: Woken up 1 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 0.188 MB perf.data (~8200 samples) ]</span><br><span class="line"># perf script</span><br><span class="line">            sshd  4652 [001] 2082360.931086: probe:tcp_sendmsg: (ffffffff81642ca9) seglen=0x80</span><br><span class="line">   app_plugin.pl  2400 [001] 2082360.970489: probe:tcp_sendmsg: (ffffffff81642ca9) seglen=0x20</span><br><span class="line">        postgres  2422 [000] 2082360.970703: probe:tcp_sendmsg: (ffffffff81642ca9) seglen=0x52</span><br><span class="line">   app_plugin.pl  2400 [000] 2082360.970890: probe:tcp_sendmsg: (ffffffff81642ca9) seglen=0x7b</span><br><span class="line">        postgres  2422 [001] 2082360.971099: probe:tcp_sendmsg: (ffffffff81642ca9) seglen=0xb</span><br><span class="line">   app_plugin.pl  2400 [000] 2082360.971140: probe:tcp_sendmsg: (ffffffff81642ca9) seglen=0x55</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>跟踪用户软件的指定function</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"># perf probe -x /lib/x86_64-linux-gnu/libc-2.15.so --add malloc</span><br><span class="line">Added new event:</span><br><span class="line">  probe_libc:malloc    (on 0x82f20)</span><br><span class="line"></span><br><span class="line">You can now use it in all perf tools, such as:</span><br><span class="line"></span><br><span class="line">    perf record -e probe_libc:malloc -aR sleep 1</span><br><span class="line"></span><br><span class="line">Tracing it system-wide:</span><br><span class="line"></span><br><span class="line"># perf record -e probe_libc:malloc -a</span><br><span class="line">^C[ perf record: Woken up 12 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 3.522 MB perf.data (~153866 samples) ]</span><br><span class="line">The report:</span><br><span class="line"></span><br><span class="line"># perf report -n</span><br><span class="line">[...]</span><br><span class="line"># Samples: 45K of event &#x27;probe_libc:malloc&#x27;</span><br><span class="line"># Event count (approx.): 45158</span><br><span class="line">#</span><br><span class="line"># Overhead       Samples          Command  Shared Object      Symbol</span><br><span class="line"># ........  ............  ...............  .............  ..........</span><br><span class="line">#</span><br><span class="line">    42.72%         19292       apt-config  libc-2.15.so   [.] malloc</span><br><span class="line">    19.71%          8902             grep  libc-2.15.so   [.] malloc</span><br><span class="line">     7.88%          3557             sshd  libc-2.15.so   [.] malloc</span><br><span class="line">     6.25%          2824              sed  libc-2.15.so   [.] malloc</span><br><span class="line">     6.06%          2738            which  libc-2.15.so   [.] malloc</span><br><span class="line">     4.12%          1862  update-motd-upd  libc-2.15.so   [.] malloc</span><br><span class="line">     3.72%          1680             stat  libc-2.15.so   [.] malloc</span><br><span class="line">     1.68%           758            login  libc-2.15.so   [.] malloc</span><br><span class="line">     1.21%           546        run-parts  libc-2.15.so   [.] malloc</span><br><span class="line">     1.21%           545               ls  libc-2.15.so   [.] malloc</span><br><span class="line">     0.80%           360        dircolors  libc-2.15.so   [.] malloc</span><br><span class="line">     0.56%           252               tr  libc-2.15.so   [.] malloc</span><br><span class="line">     0.54%           242              top  libc-2.15.so   [.] malloc</span><br><span class="line">     0.49%           222       irqbalance  libc-2.15.so   [.] malloc</span><br><span class="line">     0.44%           200             dpkg  libc-2.15.so   [.] malloc</span><br><span class="line">     0.38%           173         lesspipe  libc-2.15.so   [.] malloc</span><br><span class="line">     0.29%           130  update-motd-fsc  libc-2.15.so   [.] malloc</span><br><span class="line">     0.25%           112            uname  libc-2.15.so   [.] malloc</span><br><span class="line">     0.24%           108              cut  libc-2.15.so   [.] malloc</span><br><span class="line">     0.23%           104           groups  libc-2.15.so   [.] malloc</span><br><span class="line">     0.21%            94  release-upgrade  libc-2.15.so   [.] malloc</span><br><span class="line">     0.18%            82        00-header  libc-2.15.so   [.] malloc</span><br><span class="line">     0.14%            62             mesg  libc-2.15.so   [.] malloc</span><br><span class="line">     0.09%            42  update-motd-reb  libc-2.15.so   [.] malloc</span><br><span class="line">     0.09%            40             date  libc-2.15.so   [.] malloc</span><br><span class="line">     0.08%            35             bash  libc-2.15.so   [.] malloc</span><br><span class="line">     0.08%            35         basename  libc-2.15.so   [.] malloc</span><br><span class="line">     0.08%            34          dirname  libc-2.15.so   [.] malloc</span><br><span class="line">     0.06%            29               sh  libc-2.15.so   [.] malloc</span><br><span class="line">     0.06%            26        99-footer  libc-2.15.so   [.] malloc</span><br><span class="line">     0.05%            24              cat  libc-2.15.so   [.] malloc</span><br><span class="line">     0.04%            18             expr  libc-2.15.so   [.] malloc</span><br><span class="line">     0.04%            17         rsyslogd  libc-2.15.so   [.] malloc</span><br><span class="line">     0.03%            12             stty  libc-2.15.so   [.] malloc</span><br><span class="line">     0.00%             1             cron  libc-2.15.so   [.] malloc</span><br><span class="line">This shows the most malloc() calls were by apt-config, while I was tracing.</span><br><span class="line"></span><br><span class="line">User: malloc() with size</span><br><span class="line"></span><br><span class="line">As of the Linux 3.13.1 kernel, this is not supported yet:</span><br><span class="line"></span><br><span class="line"># perf probe -x /lib/x86_64-linux-gnu/libc-2.15.so --add &#x27;malloc size&#x27;</span><br><span class="line">Debuginfo-analysis is not yet supported with -x/--exec option.</span><br><span class="line">  Error: Failed to add events. (-38)</span><br><span class="line">As a workaround, you can access the registers (on Linux 3.7+). For example, on x86_64:</span><br><span class="line"></span><br><span class="line"># perf probe -x /lib64/libc-2.17.so &#x27;--add=malloc size=%di&#x27;</span><br><span class="line">       probe_libc:malloc    (on 0x800c0 with size=%di)</span><br></pre></td></tr></table></figure>
<h3 id="Perf-sched"><a href="#Perf-sched" class="headerlink" title="Perf sched"></a>Perf sched</h3><p>调度器的好坏直接影响一个系统的整体运行效率。在这个领域，内核黑客们常会发生争执，一个重要原因是对于不同的调度器，每个人给出的评测报告都各不相同，甚至常常有相反的结论。因此一个权威的统一的评测工具将对结束这种争论有益。Perf sched 便是这种尝试。</p>
<p>Perf sched 有五个子命令：</p>
<ul>
<li>perf sched record            # low-overhead recording of arbitrary workloads </li>
<li>perf sched latency           # output per task latency metrics </li>
<li>perf sched map               # show summary/map of context-switching </li>
<li>perf sched trace             # output finegrained trace </li>
<li>perf sched replay            # replay a captured workload using simlated threads</li>
</ul>
<p>用户一般使用’ perf sched record ’收集调度相关的数据，然后就可以用’ perf sched latency ’查看诸如调度延迟等和调度器相关的统计数据。</p>
<p>其他三个命令也同样读取 record 收集到的数据并从其他不同的角度来展示这些数据。下面一一进行演示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">perf sched record sleep <span class="number">10</span>     <span class="meta"># record full system activity for 10 seconds </span></span><br><span class="line"> perf sched latency --sort max  <span class="meta"># report latencies sorted by max </span></span><br><span class="line"> </span><br><span class="line"> -------------------------------------------------------------------------------------</span><br><span class="line">  Task               |   Runtime ms  | Switches | Average delay ms | Maximum delay ms | </span><br><span class="line"> -------------------------------------------------------------------------------------</span><br><span class="line">  :<span class="number">14086</span>:<span class="number">14086</span>        |      <span class="number">0.095</span> ms |        <span class="number">2</span> | avg:    <span class="number">3.445</span> ms | max:    <span class="number">6.891</span> ms | </span><br><span class="line">  gnome-session:<span class="number">13792</span>   |   <span class="number">31.713</span> ms |      <span class="number">102</span> | avg:    <span class="number">0.160</span> ms | max:    <span class="number">5.992</span> ms | </span><br><span class="line">  metacity:<span class="number">14038</span>      |     <span class="number">49.220</span> ms |      <span class="number">637</span> | avg:    <span class="number">0.066</span> ms | max:    <span class="number">5.942</span> ms | </span><br><span class="line">  gconfd<span class="number">-2</span>:<span class="number">13971</span>     | <span class="number">48.587</span> ms |      <span class="number">777</span> | avg:    <span class="number">0.047</span> ms | max:    <span class="number">5.793</span> ms | </span><br><span class="line">  gnome-power-man:<span class="number">14050</span> |  <span class="number">140.601</span> ms | <span class="number">434</span> | avg:  <span class="number">0.097</span> ms | max:    <span class="number">5.367</span> ms | </span><br><span class="line">  python:<span class="number">14049</span>        |  <span class="number">114.694</span> ms |      <span class="number">125</span> | avg:    <span class="number">0.120</span> ms | max:    <span class="number">5.343</span> ms | </span><br><span class="line">  kblockd/<span class="number">1</span>:<span class="number">236</span>       |   <span class="number">3.458</span> ms |      <span class="number">498</span> | avg:    <span class="number">0.179</span> ms | max:    <span class="number">5.271</span> ms | </span><br><span class="line">  Xorg:<span class="number">3122</span>         |   <span class="number">1073.107</span> ms |     <span class="number">2920</span> | avg:    <span class="number">0.030</span> ms | max:    <span class="number">5.265</span> ms | </span><br><span class="line">  dbus-daemon:<span class="number">2063</span>   |   <span class="number">64.593</span> ms |      <span class="number">665</span> | avg:    <span class="number">0.103</span> ms | max:    <span class="number">4.730</span> ms | </span><br><span class="line">  :<span class="number">14040</span>:<span class="number">14040</span>       |   <span class="number">30.786</span> ms |      <span class="number">255</span> | avg:    <span class="number">0.095</span> ms | max:    <span class="number">4.155</span> ms | </span><br><span class="line">  events/<span class="number">1</span>:<span class="number">8</span>         |    <span class="number">0.105</span> ms |       <span class="number">13</span> | avg:    <span class="number">0.598</span> ms | max:    <span class="number">3.775</span> ms | </span><br><span class="line">  console-kit-dae:<span class="number">2080</span>  | <span class="number">14.867</span> ms |   <span class="number">152</span> | avg:    <span class="number">0.142</span> ms | max:    <span class="number">3.760</span> ms | </span><br><span class="line">  gnome-settings-:<span class="number">14023</span> |  <span class="number">572.653</span> ms |  <span class="number">979</span> | avg:    <span class="number">0.056</span> ms | max:    <span class="number">3.627</span> ms | </span><br><span class="line"> ... </span><br><span class="line"> -----------------------------------------------------------------------------------</span><br><span class="line">  TOTAL:                |   <span class="number">3144.817</span> ms |    <span class="number">11654</span> | </span><br><span class="line"> --------------------------------------------------- </span><br></pre></td></tr></table></figure><br>上面的例子展示了一个 Gnome 启动时的统计信息。各个 column 的含义如下：</p>
<ul>
<li>Task: 进程的名字和 pid </li>
<li>Runtime: 实际运行时间</li>
<li>Switches: 进程切换的次数</li>
<li>Average delay: 平均的调度延迟</li>
<li>Maximum delay: 最大延迟</li>
</ul>
<p>这里最值得人们关注的是 Maximum delay，一般从这里可以看到对交互性影响最大的特性：调度延迟，如果调度延迟比较大，那么用户就会感受到视频或者音频断断续续的。</p>
<p>其他的三个子命令提供了不同的视图，一般是由调度器的开发人员或者对调度器内部实现感兴趣的人们所使用。</p>
<p>首先是 map:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ perf sched <span class="built_in">map</span> </span><br><span class="line">... </span><br><span class="line"> </span><br><span class="line"> N1  O1  .   .   .   S1  .   .   .   B0  .  *I0  C1  .   M1  .    <span class="number">23002.773423</span> secs </span><br><span class="line"> N1  O1  .  *Q0  .   S1  .   .   .   B0  .   I0  C1  .   M1  .    <span class="number">23002.773423</span> secs </span><br><span class="line"> N1  O1  .   Q0  .   S1  .   .   .   B0  .  *R1  C1  .   M1  .    <span class="number">23002.773485</span> secs </span><br><span class="line"> N1  O1  .   Q0  .   S1  .  *S0  .   B0  .   R1  C1  .   M1  .    <span class="number">23002.773478</span> secs </span><br><span class="line">*L0  O1  .   Q0  .   S1  .   S0  .   B0  .   R1  C1  .   M1  .    <span class="number">23002.773523</span> secs </span><br><span class="line"> L0  O1  .  *.   .   S1  .   S0  .   B0  .   R1  C1  .   M1  .    <span class="number">23002.773531</span> secs </span><br><span class="line"> L0  O1  .   .   .   S1  .   S0  .   B0  .   R1  C1 *T1  M1  .    <span class="number">23002.773547</span> secs </span><br><span class="line">                     T1 =&gt; irqbalance:<span class="number">2089</span> </span><br><span class="line"> L0  O1  .   .   .   S1  .   S0  .  *P0  .   R1  C1  T1  M1  .    <span class="number">23002.773549</span> secs </span><br><span class="line">*N1  O1  .   .   .   S1  .   S0  .   P0  .   R1  C1  T1  M1  .    <span class="number">23002.773566</span> secs </span><br><span class="line"> N1  O1  .   .   .  *J0  .   S0  .   P0  .   R1  C1  T1  M1  .    <span class="number">23002.773571</span> secs </span><br><span class="line"> N1  O1  .   .   .   J0  .   S0 *B0  P0  .   R1  C1  T1  M1  .    <span class="number">23002.773592</span> secs </span><br><span class="line"> N1  O1  .   .   .   J0  .  *U0  B0  P0  .   R1  C1  T1  M1  .    <span class="number">23002.773582</span> secs </span><br><span class="line"> N1  O1  .   .   .  *S1  .   U0  B0  P0  .   R1  C1  T1  M1  .    <span class="number">23002.773604</span> secs</span><br></pre></td></tr></table></figure><br>星号表示调度事件发生所在的 CPU。</p>
<p>点号表示该 CPU 正在 IDLE。</p>
<p>Map 的好处在于提供了一个的总的视图，将成百上千的调度事件进行总结，显示了系统任务在 CPU 之间的分布，假如有不好的调度迁移，比如一个任务没有被及时迁移到 idle 的 CPU 却被迁移到其他忙碌的 CPU，类似这种调度器的问题可以从 map 的报告中一眼看出来。</p>
<p>如果说 map 提供了高度概括的总体的报告，那么 trace 就提供了最详细，最底层的细节报告。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pipe-test-100k-13520 [001]  1254.354513808: sched_stat_wait: </span><br><span class="line">task: pipe-test-100k:13521 wait: 5362 [ns] </span><br><span class="line"> pipe-test-100k-13520 [001]  1254.354514876: sched_switch: </span><br><span class="line">task pipe-test-100k:13520 [120] (S) ==&gt; pipe-test-100k:13521 [120] </span><br><span class="line">         :13521-13521 [001]  1254.354517927: sched_stat_runtime: </span><br><span class="line">task: pipe-test-100k:13521 runtime: 5092 [ns], vruntime: 133967391150 [ns] </span><br><span class="line">         :13521-13521 [001]  1254.354518984: sched_stat_sleep: </span><br><span class="line">task: pipe-test-100k:13520 sleep: 5092 [ns] </span><br><span class="line">         :13521-13521 [001]  1254.354520011: sched_wakeup: </span><br><span class="line">task pipe-test-100k:13520 [120] success=1 [001]</span><br></pre></td></tr></table></figure><br>要理解以上的信息，必须对调度器的源代码有一定了解，对一般用户而言，理解他们十分不易。幸好这些信息一般也只有编写调度器的人感兴趣。。。</p>
<p>Perf replay 这个工具更是专门为调度器开发人员所设计，它试图重放 perf.data 文件中所记录的调度场景。很多情况下，一般用户假如发现调度器的奇怪行为，他们也无法准确说明发生该情形的场景，或者一些测试场景不容易再次重现，或者仅仅是出于“偷懒”的目的，使用 perf replay，perf 将模拟 perf.data 中的场景，无需开发人员花费很多的时间去重现过去，这尤其利于调试过程，因为需要一而再，再而三地重复新的修改是否能改善原始的调度场景所发现的问题。</p>
<p>下面是 replay 执行的示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ perf sched replay </span><br><span class="line">run measurement overhead: 3771 nsecs </span><br><span class="line">sleep measurement overhead: 66617 nsecs </span><br><span class="line">the run test took 999708 nsecs </span><br><span class="line">the sleep test took 1097207 nsecs </span><br><span class="line">nr_run_events:        200221 </span><br><span class="line">nr_sleep_events:      200235 </span><br><span class="line">nr_wakeup_events:     100130 </span><br><span class="line">task      0 (                perf:     13519), nr_events: 148 </span><br><span class="line">task      1 (                perf:     13520), nr_events: 200037 </span><br><span class="line">task      2 (      pipe-test-100k:     13521), nr_events: 300090 </span><br><span class="line">task      3 (         ksoftirqd/0:         4), nr_events: 8 </span><br><span class="line">task      4 (             swapper:         0), nr_events: 170 </span><br><span class="line">task      5 (     gnome-power-man:      3192), nr_events: 3 </span><br><span class="line">task      6 (     gdm-simple-gree:      3234), nr_events: 3 </span><br><span class="line">task      7 (                Xorg:      3122), nr_events: 5 </span><br><span class="line">task      8 (     hald-addon-stor:      2234), nr_events: 27 </span><br><span class="line">task      9 (               ata/0:       321), nr_events: 29 </span><br><span class="line">task     10 (           scsi_eh_4:       704), nr_events: 37 </span><br><span class="line">task     11 (            events/1:         8), nr_events: 3 </span><br><span class="line">task     12 (            events/0:         7), nr_events: 6 </span><br><span class="line">task     13 (           flush-8:0:      6980), nr_events: 20 </span><br><span class="line">------------------------------------------------------------ </span><br><span class="line">#1  : 2038.157, ravg: 2038.16, cpu: 0.09 / 0.09 </span><br><span class="line">#2  : 2042.153, ravg: 2038.56, cpu: 0.11 / 0.09 </span><br><span class="line">^C</span><br></pre></td></tr></table></figure></p>
<h3 id="perf-bench"><a href="#perf-bench" class="headerlink" title="perf bench"></a>perf bench</h3><p>除了调度器之外，很多时候人们都需要衡量自己的工作对系统性能的影响。benchmark 是衡量性能的标准方法，对于同一个目标，如果能够有一个大家都承认的 benchmark，将非常有助于”提高内核性能”这项工作。</p>
<p>目前，就我所知，perf bench 提供了 3 个 benchmark:</p>
<ol>
<li><p>Sched message</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lm@ovispoly ~]$ perf bench sched messaging</span><br><span class="line"># Running sched/messaging benchmark...# 20 sender and receiver processes per group# 10 groups == 400 processes run Total time: 1.918 [sec]</span><br></pre></td></tr></table></figure>
<p>sched message 是从经典的测试程序 hackbench 移植而来，用来衡量调度器的性能，overhead 以及可扩展性。该 benchmark 启动 N 个 reader/sender 进程或线程对，通过 IPC(socket 或者 pipe) 进行并发的读写。一般人们将 N 不断加大来衡量调度器的可扩展性。Sched message 的用法及用途和 hackbench 一样。</p>
</li>
<li><p>Sched Pipe</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lm@ovispoly ~]$ perf bench sched pipe</span><br><span class="line"># Running sched/pipe benchmark...# Extecuted 1000000 pipe operations between two tasks Total time: 20.888 [sec] 20.888017 usecs/op 47874 ops/sec</span><br></pre></td></tr></table></figure>
<p>sched pipe 从 Ingo Molnar 的 pipe-test-1m.c 移植而来。当初 Ingo 的原始程序是为了测试不同的调度器的性能和公平性的。其工作原理很简单，两个进程互相通过 pipe 拼命地发 1000000 个整数，进程 A 发给 B，同时 B 发给 A。。。因为 A 和 B 互相依赖，因此假如调度器不公平，对 A 比 B 好，那么 A 和 B 整体所需要的时间就会更长。</p>
</li>
<li><p>Mem memcpy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lm@ovispoly ~]$ perf bench mem memcpy</span><br><span class="line"># Running mem/memcpy benchmark...# Copying 1MB Bytes from 0xb75bb008 to 0xb76bc008 ... 364.697301 MB/Sec</span><br></pre></td></tr></table></figure>
<p>这个是 perf bench 的作者 Hitoshi Mitake 自己写的一个执行 memcpy 的 benchmark。该测试衡量一个拷贝 1M 数据的 memcpy() 函数所花费的时间。我尚不明白该 benchmark 的使用场景。。。或许是一个例子，告诉人们如何利用 perf bench 框架开发更多的 benchmark 吧。</p>
</li>
</ol>
<p>这三个 benchmark 给我们展示了一个可能的未来：不同语言，不同肤色，来自不同背景的人们将来会采用同样的 benchmark，只要有一份 Linux 内核代码即可。</p>
<h3 id="perf-lock"><a href="#perf-lock" class="headerlink" title="perf lock"></a>perf lock</h3><p>锁是内核同步的方法，一旦加了锁，其他准备加锁的内核执行路径就必须等待，降低了并行。因此对于锁进行专门分析应该是调优的一项重要工作。</p>
<p>我运行 perf lock 后得到如下输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Name acquired contended total wait (ns) max wait (ns) min </span><br><span class="line"> </span><br><span class="line"> &amp;md-&gt;map_lock 396 0 0 0 </span><br><span class="line"> &amp;(&amp;mm-&gt;page_tabl... 309 0 0 0 </span><br><span class="line"> &amp;(&amp;tty-&gt;buf.lock... 218 0 0 0 </span><br><span class="line"> &amp;ctx-&gt;lock 185 0 0 0 </span><br><span class="line"> key 178 0 0 0 </span><br><span class="line"> &amp;ctx-&gt;lock 132 0 0 0 </span><br><span class="line"> &amp;tty-&gt;output_loc... 126 0 0 0 </span><br><span class="line">。。。</span><br><span class="line"> &amp;(&amp;object-&gt;lock)... 1 0 0 0 </span><br><span class="line"> &amp;(&amp;object-&gt;lock)... 0 0 0 0 </span><br><span class="line"> &amp;(&amp;object-&gt;lock)... 0 0 0 0 </span><br><span class="line"> &amp;p-&gt;cred_guard_m... 0 0 0 0 </span><br><span class="line"> </span><br><span class="line"> === output for debug=== </span><br><span class="line"> </span><br><span class="line"> bad: 28, total: 664 </span><br><span class="line"> bad rate: 4.216867 % </span><br><span class="line"> histogram of events caused bad sequence </span><br><span class="line">  acquire: 8 </span><br><span class="line">  acquired: 0 </span><br><span class="line">  contended: 0 </span><br><span class="line">  release: 20</span><br></pre></td></tr></table></figure><br>对该报表的一些解释如下：</p>
<ul>
<li>“Name”: 锁的名字，比如 md-&gt;map_lock，即定义在 dm.c 结构 mapped_device 中的读写锁。</li>
<li>“acquired”: 该锁被直接获得的次数，即没有其他内核路径拥有该锁的情况下得到该锁的次数。</li>
<li>“contended”冲突的次数，即在准备获得该锁的时候已经被其他人所拥有的情况的出现次数。</li>
<li>“total wait”：为了获得该锁，总共的等待时间。</li>
<li>“max wait”：为了获得该锁，最大的等待时间。</li>
<li>“min wait”：为了获得该锁，最小的等待时间。</li>
</ul>
<p>目前 perf lock 还处于比较初级的阶段，我想在后续的内核版本中，还应该会有较大的变化，因此当您开始使用 perf lock 时，恐怕已经和本文这里描述的有所不同了。不过我又一次想说的是，命令语法和输出并不是最重要的，重要的是了解什么时候我们需要用这个工具，以及它能帮我们解决怎样的问题。</p>
<h3 id="perf-tracepoint"><a href="#perf-tracepoint" class="headerlink" title="perf tracepoint"></a>perf tracepoint</h3><p>event中的一种类型，实际上是一些比较常见的系统调用。</p>
<p>不在里面的可以使用前面介绍的动态跟踪的方式进行跟踪。</p>
<p>支持哪些tracepoint</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">perf list | awk -F: &#x27;/Tracepoint event/ &#123; lib[$1]++ &#125; END &#123;for (l in lib) &#123; printf &quot;  %-16s %d\n&quot;, l, lib[l] &#125; &#125;&#x27; | sort | column</span><br><span class="line"></span><br><span class="line">    block          18       jbd2           11       kvmmmu         9        napi           1        sched          15       skb            3        timer          12       writeback      16</span><br><span class="line">    ext4           46       kmem           42       mce            1        net            4        scsi           5        sock           2        udp            1        xfs            314</span><br><span class="line">    irq            5        kvm            21       module         5        power          3        signal         2        syscalls       548      workqueue      4</span><br><span class="line"></span><br><span class="line">perf list </span><br><span class="line">......</span><br><span class="line">  xfs:xfs_attr_list_sf                               [Tracepoint event]</span><br><span class="line">  xfs:xfs_attr_list_sf_all                           [Tracepoint event]</span><br><span class="line">  xfs:xfs_attr_list_leaf                             [Tracepoint event]</span><br><span class="line">  xfs:xfs_attr_list_leaf_end                         [Tracepoint event]</span><br><span class="line">  xfs:xfs_attr_list_full                             [Tracepoint event]</span><br><span class="line">  xfs:xfs_attr_list_add                              [Tracepoint event]</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>主要包含以下tracepoint subtype</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">block: block device I/O</span><br><span class="line">ext3, ext4: file system operations</span><br><span class="line">kmem: kernel memory allocation events</span><br><span class="line">random: kernel random number generator events</span><br><span class="line">sched: CPU scheduler events</span><br><span class="line">syscalls: system call enter and exits</span><br><span class="line">task: task events</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">I used perf_events to record the block request (disk I/O) issue and completion static tracepoints:</span><br><span class="line"></span><br><span class="line"># perf record -e block:block_rq_issue -e block:block_rq_complete -a sleep 120</span><br><span class="line">[ perf record: Woken up 36 times to write data ]</span><br><span class="line">[ perf record: Captured and wrote 8.885 MB perf.data (~388174 samples) ]</span><br><span class="line"># perf script</span><br><span class="line">[...]</span><br><span class="line">     randread.pl  2522 [000]  6011.824759: block:block_rq_issue: 254,16 R 0 () 7322849 + 16 [randread.pl]</span><br><span class="line">     randread.pl  2520 [000]  6011.824866: block:block_rq_issue: 254,16 R 0 () 26144801 + 16 [randread.pl]</span><br><span class="line">         swapper     0 [000]  6011.828913: block:block_rq_complete: 254,16 R () 31262577 + 16 [0]</span><br><span class="line">     randread.pl  2521 [000]  6011.828970: block:block_rq_issue: 254,16 R 0 () 70295937 + 16 [randread.pl]</span><br><span class="line">         swapper     0 [000]  6011.835862: block:block_rq_complete: 254,16 R () 26144801 + 16 [0]</span><br><span class="line">     randread.pl  2520 [000]  6011.835932: block:block_rq_issue: 254,16 R 0 () 5495681 + 16 [randread.pl]</span><br><span class="line">         swapper     0 [000]  6011.837988: block:block_rq_complete: 254,16 R () 7322849 + 16 [0]</span><br><span class="line">     randread.pl  2522 [000]  6011.838051: block:block_rq_issue: 254,16 R 0 () 108589633 + 16 [randread.pl]</span><br><span class="line">         swapper     0 [000]  6011.850615: block:block_rq_complete: 254,16 R () 108589633 + 16 [0]</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<h3 id="perf-Kmem"><a href="#perf-Kmem" class="headerlink" title="perf Kmem"></a>perf Kmem</h3><p>Perf Kmem 专门收集内核 slab 分配器的相关事件。比如内存分配，释放等。可以用来研究程序在哪里分配了大量内存，或者在什么地方产生碎片之类的和内存管理相关的问题。</p>
<p>Perf kmem 和 perf lock 实际上都是 perf tracepoint 的特例，您也完全可以用 Perf record – e kmem:<em> 或者 perf record – e lock:</em> 来完成同样的功能。但重要的是，这些工具在内部对原始数据进行了汇总和分析，因而能够产生信息更加明确更加有用的统计报表。</p>
<p>perf kmem 的输出结果如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@ovispoly perf]# ./perf kmem --alloc -l 10 --caller stat </span><br><span class="line">--------------------------------------------------------------------------- </span><br><span class="line">Callsite       | Total_alloc/Per | Total_req/Per | Hit | Ping-pong| Frag </span><br><span class="line">--------------------------------------------------------------------------- </span><br><span class="line">perf_mmap+1a8 | 1024/1024 | 572/572|1 | 0 | 44.141% </span><br><span class="line">seq_open+15| 12384/96 | 8772/68 |129 | 0 | 29.167% </span><br><span class="line">do_maps_open+0| 1008/16 | 756/12 |63 | 0 | 25.000% </span><br><span class="line">...| ... | ...| ... | ... | ... </span><br><span class="line">__split_vma+50| 88/88 | 88/88 | 1 | 0 | 0.000% </span><br><span class="line">--------------------------------------------------------------------------- </span><br><span class="line"> Alloc Ptr | Total_alloc/Per | Total_req/Per | Hit |Ping-pong| Frag </span><br><span class="line">--------------------------------------------------------------------------- </span><br><span class="line">0xd15d4600|64/64 | 33/33  1 |  0 | 48.438% </span><br><span class="line">0xc461e000|1024/1024 | 572/572 |1 | 0 | 44.141% </span><br><span class="line">0xd15d44c0| 64/64 | 38/38 |1 | 0 | 40.625% </span><br><span class="line">... | ... | ... | ... | ... | ... </span><br><span class="line">--------------------------------------------------------------------------- </span><br><span class="line"> </span><br><span class="line">SUMMARY </span><br><span class="line">======= </span><br><span class="line">Total bytes requested: 10487021 </span><br><span class="line">Total bytes allocated: 10730448 </span><br><span class="line">Total bytes wasted on internal fragmentation: 243427 </span><br><span class="line">Internal fragmentation: 2.268563% </span><br><span class="line">Cross CPU allocations: 0/246458</span><br></pre></td></tr></table></figure><br>该报告有三个部分：根据 Callsite 显示的部分，所谓 Callsite 即内核代码中调用 kmalloc 和 kfree 的地方。比如上图中的函数 perf_mmap，Hit 栏为 1，表示该函数在 record 期间一共调用了 kmalloc 一次，假如如第三行所示数字为 653，则表示函数 sock_alloc_send_pskb 共有 653 次调用 kmalloc 分配内存。</p>
<p>对于第一行 Total_alloc/Per 显示为 1024/1024，第一个值 1024 表示函数 perf_mmap 总共分配的内存大小，Per 表示平均值。</p>
<p>比较有趣的两个参数是 Ping-pong 和 Frag。Frag 比较容易理解，即内部碎片。虽然相对于 Buddy System，Slab 正是要解决内部碎片问题，但 slab 依然存在内部碎片，比如一个 cache 的大小为 1024，但需要分配的数据结构大小为 1022，那么有 2 个字节成为碎片。Frag 即碎片的比例。</p>
<p>Ping-pong 是一种现象，在多 CPU 系统中，多个 CPU 共享的内存会出现”乒乓现象”。一个 CPU 分配内存，其他 CPU 可能访问该内存对象，也可能最终由另外一个 CPU 释放该内存对象。而在多 CPU 系统中，L1 cache 是 per CPU 的，CPU2 修改了内存，那么其他的 CPU 的 cache 都必须更新，这对于性能是一个损失。Perf kmem 在 kfree 事件中判断 CPU 号，如果和 kmalloc 时的不同，则视为一次 ping-pong，理想的情况下 ping-pone 越小越好。Ibm developerworks 上有一篇讲述 oprofile 的文章，其中关于 cache 的调优可以作为很好的参考资料。</p>
<p>后面则有根据被调用地点的显示方式的部分。</p>
<p>最后一个部分是汇总数据，显示总的分配的内存和碎片情况，Cross CPU allocation 即 ping-pong 的汇总。</p>
<h3 id="Perf-timechart"><a href="#Perf-timechart" class="headerlink" title="Perf timechart"></a>Perf timechart</h3><p>很多 perf 命令都是为调试单个程序或者单个目的而设计。有些时候，性能问题并非由单个原因所引起，需要从各个角度一一查看。为此，人们常需要综合利用各种工具，比如 top,vmstat,oprofile 或者 perf。这非常麻烦。</p>
<p>此外，前面介绍的所有工具都是基于命令行的，报告不够直观。更令人气馁的是，一些报告中的参数令人费解。所以人们更愿意拥有一个“傻瓜式”的工具。</p>
<p>以上种种就是 perf timechart 的梦想，其灵感来源于 bootchart。采用“简单”的图形“一目了然”地揭示问题所在。</p>
<p>加注了引号的原因是，perf timechart 虽然有了美观的图形输出，但对于新手，这个图形就好象高科技节目中播放的 DNA 图像一样，不明白那些坐在屏幕前的人是如何从密密麻麻的点和线中找到有用的信息的。但正如受过训练的科学家一样，经过一定的练习，相信您也一定能从下图中找到您想要的。</p>
<p><img src="/img/16060378751.jpg" alt=""><br>图 1. perf timechart</p>
<p>人们说，只有黑白两色是一个人内心压抑的象征，Timechart 用不同的颜色代表不同的含义。上图的最上面一行是图例，告诉人们每种颜色所代表的含义。蓝色表示忙碌，红色表示 idle，灰色表示等待，等等。</p>
<p>接下来是 per-cpu 信息，上图所示的系统中有两个处理器，可以看到在采样期间，两个处理器忙碌程度的概括。蓝色多的地方表示忙碌，因此上图告诉我们，CPU1 很忙，而 CPU2 很闲。</p>
<p>再下面是 per-process 信息，每一个进程有一个 bar。上图中进程 bash 非常忙碌，而其他进程则大多数时间都在等待着什么。Perf 自己在开始的时候很忙，接下来便开始 wait 了。</p>
<p>总之这张图告诉了我们一个系统的概况，但似乎不够详细？</p>
<p>Timechart 可以显示更详细的信息，上图实际上是一个矢量图形 SVG 格式，用 SVG viewer 的放大功能，我们可以将该图的细节部分放大，timechart 的设计理念叫做”infinitely zoomable”。放大之后便可以看到一些更详细的信息，类似网上的 google 地图，找到国家之后，可以放大，看城市的分布，再放大，可以看到某个城市的街道分布，还可以放大以便得到更加详细的信息。</p>
<p>完整的 timechart 图形和颜色解读超出了本文的范围，感兴趣的读者可以到作者 Arjan 的博客上查看。这里仅举一个例子，上图中有一条 bar 对应了 Xorg 进程。多数时候该进程都处于 waiting 状态，只有需要显示什么的时候它才会开始和内核通信，以便进行绘图所需的 IO 操作。</p>
<p>将 Xorg 条目放大的例子图形如下：</p>
<p><img src="/img/16060378752.jpg" alt=""><br>图 2. perf timechart detail</p>
<p>上图中需要注意的是几条绿色的短线，表示进程通信，即准备绘图。假如通信的两个进程在图中上下相邻，那么绿线可以连接他们。但如果不相邻，则只会显示如上图所示的被截断的绿色短线。</p>
<p>蓝色部分表示进程忙碌，黄色部分表示该进程的时间片已经用完，但仍处于就绪状态，在等待调度器给予 CPU。</p>
<p>通过这张图，便可以较直观地看到进程在一段时间内的详细行为。</p>
<h3 id="绘制perf火焰图"><a href="#绘制perf火焰图" class="headerlink" title="绘制perf火焰图"></a>绘制perf火焰图</h3><p>使用perf report -tui或者-stdio输出的文本不够直观的话，使用火焰图可以很直观的表现出哪些代码是瓶颈所在。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">压测</span><br><span class="line">$pgbench -M prepared -n -r -P 1 -c 32 -j 32 -T 100</span><br><span class="line"></span><br><span class="line">收集统计信息</span><br><span class="line">#perf record -a -g -v sleep 30</span><br></pre></td></tr></table></figure>
<p>生成火焰图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># git clone https://github.com/brendangregg/FlameGraph      # or download it from github</span><br><span class="line"># mv perf.data FlameGraph/</span><br><span class="line"># cd FlameGraph</span><br><span class="line"># perf script | ./stackcollapse-perf.pl &gt; out.perf-folded</span><br><span class="line"># cat out.perf-folded | ./flamegraph.pl &gt; perf-kernel.svg</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/digoal/blog/blob/master/201611/20161127_01_pic_003.png"><img src="https://github.com/digoal/blog/raw/master/201611/20161127_01_pic_003.png" alt="pic"></a></p>
<h3 id="绘制perf热力图"><a href="#绘制perf热力图" class="headerlink" title="绘制perf热力图"></a>绘制perf热力图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">压测</span><br><span class="line">$pgbench -M prepared -n -r -P 1 -c 32 -j 32 -T 100</span><br><span class="line"></span><br><span class="line">收集统计信息</span><br><span class="line">#perf record -a -g -v sleep 30</span><br></pre></td></tr></table></figure>
<p>生成热力图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># git clone https://github.com/brendangregg/HeatMap      # or download it from github</span><br><span class="line"># mv perf.data HeatMap/</span><br><span class="line"># cd HeatMap</span><br><span class="line"># perf script | awk &#x27;&#123; gsub(/:/, &quot;&quot;) &#125; $5 ~ /issue/ &#123; ts[$6, $10] = $4 &#125;</span><br><span class="line">    $5 ~ /complete/ &#123; if (l = ts[$6, $9]) &#123; printf &quot;%.f %.f\n&quot;, $4 * 1000000,</span><br><span class="line">    ($4 - l) * 1000000; ts[$6, $10] = 0 &#125; &#125;&#x27; &gt; out.lat_us</span><br><span class="line"># ./trace2heatmap.pl --unitstime=us --unitslat=us --maxlat=50000 out.lat_us &gt; out.svg</span><br></pre></td></tr></table></figure>
<h2 id="使用-Script-增强-perf-的功能"><a href="#使用-Script-增强-perf-的功能" class="headerlink" title="使用 Script 增强 perf 的功能"></a>使用 Script 增强 perf 的功能</h2><p>通常，面对看似复杂，实则较有规律的计算机输出，程序员们总是会用脚本来进行处理：比如给定一个文本文件，想从中找出有多少个数字 0125，人们不会打开文件然后用肉眼去一个一个地数，而是用 grep 命令来进行处理。</p>
<p>perf 的输出虽然是文本格式，但还是不太容易分析和阅读。往往也需要进一步处理，perl 和 python 是目前最强大的两种脚本语言。Tom Zanussi 将 perl 和 python 解析器嵌入到 perf 程序中，从而使得 perf 能够自动执行 perl 或者 python 脚本进一步进行处理，从而为 perf 提供了强大的扩展能力。因为任何人都可以编写新的脚本，对 perf 的原始输出数据进行所需要的进一步处理。这个特性所带来的好处很类似于 plug-in 之于 eclipse。</p>
<p>下面的命令可以查看系统中已经安装的脚本：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># perf trace -l </span><br><span class="line">    List of available trace scripts: </span><br><span class="line">      syscall-counts [comm]                system-wide syscall counts </span><br><span class="line">      syscall-counts-by-pid [comm]         system-wide syscall counts, by pid </span><br><span class="line">      failed-syscalls-by-pid [comm]        system-wide failed syscalls, by pid </span><br></pre></td></tr></table></figure><br>比如 failed-syscalls 脚本，执行的效果如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># perf trace record failed-syscalls </span><br><span class="line">   ^C[ perf record: Woken up 11 times to write data ]                         </span><br><span class="line">   [ perf record: Captured and wrote 1.939 MB perf.data (~84709 samples) ]   </span><br><span class="line"> </span><br><span class="line">perf trace report failed-syscalls </span><br><span class="line">   perf trace started with Perl script \ </span><br><span class="line">    /root/libexec/perf-core/scripts/perl/failed-syscalls.pl </span><br><span class="line"> </span><br><span class="line">   failed syscalls, by comm: </span><br><span class="line"> </span><br><span class="line">   comm                    # errors </span><br><span class="line">   --------------------  ---------- </span><br><span class="line">   firefox                     1721 </span><br><span class="line">   claws-mail                   149 </span><br><span class="line">   konsole                       99 </span><br><span class="line">   X                             77 </span><br><span class="line">   emacs                         56 </span><br><span class="line">   [...] </span><br><span class="line"> </span><br><span class="line">   failed syscalls, by syscall: </span><br><span class="line"> </span><br><span class="line">   syscall                           # errors </span><br><span class="line">   ------------------------------  ---------- </span><br><span class="line">   sys_read                              2042 </span><br><span class="line">   sys_futex                              130 </span><br><span class="line">   sys_mmap_pgoff                          71 </span><br><span class="line">   sys_access                              33 </span><br><span class="line">   sys_stat64                               5 </span><br><span class="line">   sys_inotify_add_watch                    4 </span><br><span class="line">   [...]</span><br></pre></td></tr></table></figure><br>该报表分别按进程和按系统调用显示失败的次数。非常简单明了，而如果通过普通的 perf record 加 perf report 命令，则需要自己手工或者编写脚本来统计这些数字。</p>
<h2 id="遇到的其它问题"><a href="#遇到的其它问题" class="headerlink" title="遇到的其它问题"></a>遇到的其它问题</h2><p>非root用户运行perf时出现的警告<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">user# perf record  --call-graph dwarf -e task-clock,cpu-clock  -p pid</span><br><span class="line">WARNING: Kernel address maps (/proc/&#123;kallsyms,modules&#125;) are restricted,</span><br><span class="line">check /proc/sys/kernel/kptr_restrict.</span><br><span class="line"></span><br><span class="line">Samples in kernel functions may not be resolved if a suitable vmlinux</span><br><span class="line">file is not found in the buildid cache or in the vmlinux path.</span><br><span class="line"></span><br><span class="line">Samples in kernel modules won&#x27;t be resolved at all.</span><br><span class="line"></span><br><span class="line">If some relocation was applied (e.g. kexec) symbols may be misresolved</span><br><span class="line">even with a suitable vmlinux or kallsyms file.</span><br></pre></td></tr></table></figure></p>
<p>原因是perf只能采集所允许用户空间下的事件，可使用:u指定<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user# perf record  --call-graph dwarf -e task-clock:u,cpu-clock:u  -p pid</span><br></pre></td></tr></table></figure></p>
<p>非root用户运行perf时使用-a选项出现的警告</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Warning:</span><br><span class="line">PID/TID switch overriding SYSTEM</span><br></pre></td></tr></table></figure>
<p>原因是非root用户不能使用-a来对所有内核事件进行采样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mapping pages error</span><br><span class="line">user# perf record  --call-graph dwarf -e task-clock:u,cpu-clock:u  -p pid -m 256</span><br><span class="line">Permission error mapping pages.</span><br><span class="line">Consider increasing /proc/sys/kernel/perf_event_mlock_kb,</span><br><span class="line">or try again with a smaller value of -m/--mmap_pages.</span><br><span class="line">(current value: 256,0)</span><br></pre></td></tr></table></figure>
<p>原因是-m 选项指定的mmap data pages的大小超过perf系统设置中限定的最大值，该最大值可通过以下方式查看：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user# cat /proc/sys/kernel/perf_event_mlock_kb     </span><br><span class="line">516</span><br></pre></td></tr></table></figure></p>
<p>如果不填-m选项，默认使用最大值。</p>
<p>另外要注意的是<code>perf_event_mlock_kb</code>是该用户可使用的最大值，如果用户同时运行了多个perf，则多个perf使用共享该值。例如，<code>perf_event_mlock_kb</code>设置512，有2个perf正在运行，则每个perf可使用512/2即256.</p>
<p>另外，如果-m所填参数不是2的幂次方，perf会帮你向上扩充到2的幂次方，例如，你输入-m 12，perf会帮你扩展到16.</p>
<h1 id="qsub教程"><a href="#qsub教程" class="headerlink" title="qsub教程"></a>qsub教程</h1><p>PBS作业管理，即以qsub、qstat、qdel命令为核心的集群作业管理系统，且它是开源的。</p>
<p>在此环境下运行，用户不需要指定程序在哪些节点上运行，程序所需的硬件资源由PBS管理和分配。</p>
<p>qsub、qstat、qdel的功能分别为“提交作业”、“查看作业状态”、“删除作业”。</p>
<h2 id="非PBS下mpi计算"><a href="#非PBS下mpi计算" class="headerlink" title="非PBS下mpi计算"></a>非PBS下mpi计算</h2><p>通常来说，使用mpirun即可，例如<code>mpirun -np 16 ./pom.kii2b.exe &lt; /dev/null &gt; pom.log</code>，意为在一个节点上使用16核执行pom.kii2b.exe，stdin重定向至空，stdout重定向至pom.log。</p>
<p>之后可能会再执行几个mv命令之类的，例如把pom.log文件移动至别处，防止多次调用时覆盖log。</p>
<h2 id="PBS作业提交"><a href="#PBS作业提交" class="headerlink" title="PBS作业提交"></a>PBS作业提交</h2><p>直接执行qsub会提示输入PBS作业脚本，这样很不方便，因此通常来说都是把qsub脚本写到文件里，重定向输入来进行作业提交，例如<code>qsub &lt; cess.sbpom.qsub</code>（其实不加&lt;也可以），提交一个写在cess.sbpom.qsub文件里的PBS脚本。</p>
<p>PBS脚本形如下面那段代码从<code>#!/bin/sh</code>到<code>mv pom.log ../$TIME.pom.log</code>的部分。</p>
<p>由于存在需要多次提交相似作业的可能，例如我有20个文件夹的数据，每个文件夹里数据的处理方式相同，调用同一个程序，总不能写20个PBS脚本。因此更为通常的做法是，使用shell脚本进行qsub脚本输出再提交，举例如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    PNAME=fz_letkf</span><br><span class="line">    NODE=1</span><br><span class="line">    NP=16</span><br><span class="line">    QSUBTIME=&quot;24:00:00&quot;</span><br><span class="line">    NOWDIR=`pwd`</span><br><span class="line">    QSUB=cess.letkf.qsub</span><br><span class="line">    LETKF=letkf020.m01</span><br><span class="line">cat &lt;&lt;EOF &gt;$QSUB</span><br><span class="line">#!/bin/sh</span><br><span class="line">#PBS -q hpca </span><br><span class="line">#PBS -V </span><br><span class="line">#PBS -N $PNAME</span><br><span class="line">#PBS -l nodes=$NODE:ppn=$NP</span><br><span class="line">#PBS -l walltime=&quot;$QSUBTIME&quot;</span><br><span class="line">#PBS -o /home/xfh_stu/WORK3/qsublog</span><br><span class="line">#PBS -j oe </span><br><span class="line">cd $NOWDIR</span><br><span class="line">mpirun ./$LETKF &lt; /dev/null</span><br><span class="line">mv pom.log ../$TIME.pom.log</span><br><span class="line">EOF</span><br><span class="line">    qsub $QSUB &gt;cessrunid</span><br></pre></td></tr></table></figure></p>
<p>调用此脚本就会自动将PBS脚本输出至$QSUB文件中，并提交此作业。通常在这段代码外面会套上循环，每次修改相应变量，从而实现一次提交多个相似作业。</p>
<p>在这里cat命令使用了一种叫做heredoc的写法，用于输出大段文字，同时还要替换其中的变量。界定符EOF是可以自定义的，不过通常来说都使用EOF。另外，用于结束的界定符必须顶格写（想不顶格也是可以的，但是有其他限制，且不方便）。</p>
<p>命令格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qsub [-a date_time] [-c interval] [-C directive_prefix]</span><br><span class="line">[-e path] [-I] [-j join] [-k keep] [-l resource_list] [-m mail_options]</span><br><span class="line">[-M user_list][-N name] [-o path] [-p priority] [-q destination] [-r c]</span><br><span class="line">[-S path_list] [-u user_list][-v variable_list] [-V]</span><br><span class="line">[-W additional_attributes] [-z]</span><br><span class="line">[script]</span><br></pre></td></tr></table></figure><br>下面解释一下参数的意思。</p>
<ul>
<li><code>-q</code>：指定使用的队列。可使用<code>qstat -q</code>查看队列信息，包括队列名、资源限制、正在运行的任务数等。</li>
<li><code>-V</code>：将执行qsub命令时拥有的环境变量都export该作业。</li>
<li><code>-N</code>：指定作业名。</li>
<li><code>-l</code>：指定作业使用的节点数与核数、时间限制等。</li>
<li><code>-o</code>：重定向此作业的stdout至指定的文件夹中，名为作业名.o作业ID。</li>
<li><code>-j oe</code>：合并此作业的stdout与stderr。</li>
</ul>
<p>qsub成功提交作业后，会在stdout输出Job ID，形如作业ID.主机名，例如15252.manager。在上面的例子中，我将qsub的结果重定向至cessrunid文件中，用于存储作业ID，以便后续处理。</p>
<h2 id="查看作业状态"><a href="#查看作业状态" class="headerlink" title="查看作业状态"></a>查看作业状态</h2><p>执行qstat即可查看当前正在执行的作业以及刚刚完成的作业。在S那一列，C表示已完成，R表示正在执行，Q表示正在等待，还有一些其他不常见的状态，可以man qstat并以job state为关键词查询即可。</p>
<p>命令格式：<code>qatat [-f][-a][-i] [-n][-s] [-R] [-Q][-q][-B][-u]</code><br>参数说明：<br>-f jobid 列出指定作业的信息<br>-a 列出系统所有作业<br>-i 列出不在运行的作业<br>-n 列出分配给此作业的结点<br>-s 列出队列管理员与scheduler所提供的建议<br>-R 列出磁盘预留信息<br>-Q 操作符是destination id，指明请求的是队列状态<br>-q 列出队列状态，并以alternative形式显示<br>-au userid 列出指定用户的所有作业<br>-B 列出PBS Server信息<br>-r 列出所有正在运行的作业<br>-Qf queue 列出指定队列的信息<br>-u 若操作符为作业号，则列出其状态。<br>若操作符为destination id，则列出运行在其上的属于user_list中用户的作业状态。</p>
<p>现在还有个问题，即如何在脚本中判断作业完成与否呢？一个很实际的例子是，我在脚本中一次提交完多个作业后，后续的脚本必须在完成这些作业后才能继续执行，那么就需要知道这些作业有没有完成。</p>
<p>通常有两种思路：</p>
<p>一是查看程序本应输出的文件有没有正常输出，即判断输出文件是否存在。或者在程序中写一些日志输出语句，脚本就可以通过查找日志文件某关键的一句话有没有输出从而知道程序运行有没有正常完成。</p>
<p>二是查看上文中通过-o参数指定的作业stdout输出文件，文件名为作业名.o作业ID。这也就是为什么我要把qsub提交信息保存到cessrunid这个文件里。通常来说，只要作业正常完成了，就会生成此文件。</p>
<p>对于第一种思路，就要根据程序具体情况来编写了。</p>
<p>对于第二种思路，一个典型的判断脚本如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line"></span><br><span class="line">    temp=`cat cessrunid`</span><br><span class="line">    runid=$&#123;PNAME&#125;.o$&#123;temp%.manager&#125;</span><br><span class="line">    runfilename=&#x27;/home/xfh_stu/WORK3/qsublog/&#x27;$runid</span><br><span class="line">    if [ -f &quot;$runfilename&quot; ]; then</span><br><span class="line">        break</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    sleep 60</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>大意为：</p>
<p>提取出cessrunid这个文件里的qsub提交信息，并去掉后面的.manager主机名（CESS集群主机名为manager），之后改写成作业名.o作业ID的形式，并加上路径，判断该文件是否存在。</p>
<p>如果文件存在，则说明作业已完成，即可break掉这个无限循环，继续后面的操作了。</p>
<p>这里需要注意的一个地方就是，在无限循环里的每次判断中间要加上一个sleep语句，比如我设置的是每分钟跑一次循环，这样机器就不会由于每时每刻都在执行判断而耗尽资源。</p>
<h2 id="删除作业"><a href="#删除作业" class="headerlink" title="删除作业"></a>删除作业</h2><p>执行qdel -W 15 15303即可在15秒后停止并删除Job ID为15303的作业。</p>
<h2 id="管理作业"><a href="#管理作业" class="headerlink" title="管理作业"></a>管理作业</h2><p>qmgr 命令—用于队列管理<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qmgr -c “create queue batch queue_type=execution”</span><br><span class="line">qmgr -c “<span class="built_in">set</span> queue batch started=<span class="literal">true</span>”</span><br><span class="line">qmgr -c “<span class="built_in">set</span> queue batch enabled=<span class="literal">true</span>”</span><br><span class="line">qmgr -c “<span class="built_in">set</span> queue batch resources_default.nodes=1″</span><br><span class="line">qmgr -c “<span class="built_in">set</span> queue batch resources_default.walltime=3600″</span><br><span class="line">qmgr -c “<span class="built_in">set</span> server default_queue=batch”</span><br></pre></td></tr></table></figure></p>
<h2 id="脚本的正确使用方法"><a href="#脚本的正确使用方法" class="headerlink" title="脚本的正确使用方法"></a>脚本的正确使用方法</h2><p>通常来说，我们都是在shell脚本中进行qsub脚本输出再提交该qsub脚本。</p>
<p>这里存在一个问题，即shell脚本自身需要后台执行。如果执行前台执行脚本，就会导致断开SSH连接后，脚本就会停止执行。</p>
<p>因此，需要使用nohup ./your.script.name.sh &amp;命令，它可以脚本在后台执行且将stdout重定向至nohup.out文件中。要注意命令最后的&amp;是不可缺少的，如果不写，脚本虽然也会在后台执行，但是在关闭SSH后就会停止。</p>
<p>另外，在执行完这个命令之后要按一下回车，使其回到shell上来。</p>
<p>当我们解决脚本后台执行的问题后，又出现了新问题，即如何停止该脚本？</p>
<p>通过脚本提交的PBS作业可以通过qdel命令结束掉，而脚本本身停止就需要kill掉该脚本的进程了。</p>
<p>首先，我们使用ps -ef | grep your.script.name.sh查询到脚本的进程PID，之后执行kill xxxxx即可停止PID为xxxxx的进程了。</p>
<h1 id="tmux使用备忘"><a href="#tmux使用备忘" class="headerlink" title="tmux使用备忘"></a>tmux使用备忘</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>tmux is a terminal multiplexer. It lets you switch easily between several programs in one terminal, detach them (they keep running in the background) and reattach them to a different terminal.</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动</td>
<td>tmux</td>
</tr>
<tr>
<td>退出</td>
<td><code>ctrl + d</code> 或者<code>exit</code></td>
</tr>
<tr>
<td>前缀键</td>
<td><code>ctrl + b</code></td>
</tr>
<tr>
<td>查看帮助</td>
<td><code>ctrl + b ?</code></td>
</tr>
<tr>
<td>新建会话</td>
<td><code>tmux new -s blog</code></td>
</tr>
<tr>
<td>分离会话</td>
<td><code>ctrl + b d</code> <code>tmux detach</code></td>
</tr>
<tr>
<td>查看会话</td>
<td><code>tmux ls</code></td>
</tr>
<tr>
<td>接入会话</td>
<td><code>tmux attach -t 0</code> <br/><code>tmux attach -t blog</code></td>
</tr>
<tr>
<td>杀死会话</td>
<td><code>tmux kill-session -t 0</code> <br/><code>tmux kill-session -t blog</code></td>
</tr>
<tr>
<td>切换会话</td>
<td><code>tmux switch -t 0</code><br/><code>tmux switch -t blog</code></td>
</tr>
<tr>
<td>重命名窗口</td>
<td><code>tmux rename-window &lt;new-name&gt;</code><br/><code>ctrl + b ,</code></td>
</tr>
<tr>
<td>创建一个新窗口</td>
<td><code>ctrl + b c</code></td>
</tr>
<tr>
<td>切换上一个窗口</td>
<td><code>ctrl + b n</code></td>
</tr>
<tr>
<td>切换到指定编号窗口</td>
<td><code>ctrl + b number</code></td>
</tr>
<tr>
<td>从列表中选择窗口</td>
<td><code>ctrl + b w</code></td>
</tr>
<tr>
<td>列出所有快捷键</td>
<td><code>tmux list-keys</code></td>
</tr>
<tr>
<td>列出所有命令及参数</td>
<td><code>tmux list-commands</code></td>
</tr>
<tr>
<td>列出所有会话信息</td>
<td><code>tmux info</code></td>
</tr>
<tr>
<td>wwtmux配置</td>
<td><code>tmux source-file ~/.tmux.conf</code></td>
</tr>
<tr>
<td>左右分屏</td>
<td><code>ctrl + b %</code></td>
</tr>
<tr>
<td>上下分屏</td>
<td><code>ctrl + b &quot;</code></td>
</tr>
<tr>
<td>切换分屏窗口</td>
<td><code>ctrl + b 方向键</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="切换pane"><a href="#切换pane" class="headerlink" title="切换pane"></a>切换pane</h3><p>ctrl+b o 依次切换当前窗口下的各个pane。</p>
<p>ctrl+b Up|Down|Left|Right 根据按箭方向选择切换到某个pane。</p>
<p>ctrl+b Space (空格键) 对当前窗口下的所有pane重新排列布局，每按一次，换一种样式。</p>
<p>ctrl+b z 最大化当前pane。再按一次后恢复。</p>
<h3 id="关闭pane"><a href="#关闭pane" class="headerlink" title="关闭pane"></a>关闭pane</h3><p>ctrl+b x 关闭当前使用中的pane，操作之后会给出是否关闭的提示，按y确认即关闭。</p>
<h2 id="tmux-window中的历史输出查看"><a href="#tmux-window中的历史输出查看" class="headerlink" title="tmux window中的历史输出查看"></a>tmux window中的历史输出查看</h2><p>在tmux里面，因为每个窗口(tmux window)的历史内容已经被tmux接管了，当我们在每个tmux的window之间进行来回切换，来回操作，那么我们没有办法看到一个window里面屏幕上的历史输出。没办法使用鼠标滚动(例如在SecureCRT中)查看之前的内容，在SecureCRT中通过鼠标滚动看到的输出一定是各个tmux的window的输出混乱夹杂在一起的，如果要看当前窗口的历史内容，那么应该怎么办呢，通过在当前的tmux window 按 ctrl-b 进入copy mode，然后就可以用PgUp/PgDn来浏览历史输出了，按q退出。</p>
<h1 id="使用mpiP工具分析AMG程序"><a href="#使用mpiP工具分析AMG程序" class="headerlink" title="使用mpiP工具分析AMG程序"></a>使用mpiP工具分析AMG程序</h1><h2 id="下载mpiP"><a href="#下载mpiP" class="headerlink" title="下载mpiP"></a>下载mpiP</h2><p>mpiP需要依赖几个库：</p>
<ul>
<li>libunwind : 用来收集调用栈信息</li>
<li>binutils : 用来解析程序地址到源代码行的信息</li>
</ul>
<h2 id="安装libunwind"><a href="#安装libunwind" class="headerlink" title="安装libunwind"></a>安装libunwind</h2><p>安装的时候会在<code>autoreconf -i</code>这一步就报错，导致没有生成Makefile文件，应该先安装libtool这个工具</p>
<p>执行libtool中带的libtoolize，发现报错<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[yuhao@localhost libunwind]$ ../libtool/bin/libtoolize </span><br><span class="line">libtoolize: putting auxiliary files <span class="keyword">in</span> AC_CONFIG_AUX_DIR, <span class="string">&#x27;config&#x27;</span>.</span><br><span class="line">libtoolize: linking file <span class="string">&#x27;config/ltmain.sh&#x27;</span></span><br><span class="line">libtoolize: You should add the contents of the following files to <span class="string">&#x27;aclocal.m4&#x27;</span>:</span><br><span class="line">libtoolize:   <span class="string">&#x27;/home/yuhao/tool/libtool/share/aclocal/libtool.m4&#x27;</span></span><br><span class="line">libtoolize:   <span class="string">&#x27;/home/yuhao/tool/libtool/share/aclocal/ltoptions.m4&#x27;</span></span><br><span class="line">libtoolize:   <span class="string">&#x27;/home/yuhao/tool/libtool/share/aclocal/ltsugar.m4&#x27;</span></span><br><span class="line">libtoolize:   <span class="string">&#x27;/home/yuhao/tool/libtool/share/aclocal/ltversion.m4&#x27;</span></span><br><span class="line">libtoolize:   <span class="string">&#x27;/home/yuhao/tool/libtool/share/aclocal/lt~obsolete.m4&#x27;</span></span><br><span class="line">libtoolize: Consider adding <span class="string">&#x27;AC_CONFIG_MACRO_DIRS([m4])&#x27;</span> to configure.ac,</span><br><span class="line">libtoolize: and rerunning libtoolize and aclocal.</span><br><span class="line">libtoolize: Consider adding <span class="string">&#x27;-I m4&#x27;</span> to ACLOCAL_AMFLAGS <span class="keyword">in</span> Makefile.am.</span><br></pre></td></tr></table></figure></p>
<p>先尝试执行下边的命令，会报错：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[yuhao@localhost libunwind]$ aclocal -I /home/yuhao/tool/libtool/share/aclocal/</span><br><span class="line">[yuhao@localhost libunwind]$ autoreconf -i</span><br><span class="line">src/Makefile.am:10: error: Libtool library used but <span class="string">&#x27;LIBTOOL&#x27;</span> is undefined</span><br><span class="line">src/Makefile.am:10:   The usual way to define <span class="string">&#x27;LIBTOOL&#x27;</span> is to add <span class="string">&#x27;LT_INIT&#x27;</span></span><br><span class="line">src/Makefile.am:10:   to <span class="string">&#x27;configure.ac&#x27;</span> and run <span class="string">&#x27;aclocal&#x27;</span> and <span class="string">&#x27;autoconf&#x27;</span> again.</span><br><span class="line">src/Makefile.am:10:   If <span class="string">&#x27;LT_INIT&#x27;</span> is <span class="keyword">in</span> <span class="string">&#x27;configure.ac&#x27;</span>, make sure</span><br><span class="line">src/Makefile.am:10:   its definition is <span class="keyword">in</span> aclocal<span class="string">&#x27;s search path.</span></span><br><span class="line"><span class="string">autoreconf: automake failed with exit status: 1</span></span><br></pre></td></tr></table></figure></p>
<p>尝试按照上边的提示，在configure.ac中加入<code>AC_CONFIG_MACRO_DIRS([m4])</code>，其中m4替换成libtool中的aclocal路径。再执行一遍libtoolize<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[yuhao@localhost libunwind]$ ../libtool/bin/libtoolize </span><br><span class="line">libtoolize: Consider adding <span class="string">&#x27;-I /home/yuhao/tool/libtool/share/aclocal/&#x27;</span> to ACLOCAL_AMFLAGS <span class="keyword">in</span> Makefile.am.</span><br></pre></td></tr></table></figure></p>
<p>又让把一个路径加到Makefile.am中</p>
<p>再从头开始执行一遍，总算好了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[yuhao@localhost libunwind]$ ../libtool/bin/libtoolize </span><br><span class="line">[yuhao@localhost libunwind]$ aclocal</span><br><span class="line">ac[yuhao@localhost libunwind]$ autoheader</span><br><span class="line">a[yuhao@localhost libunwind]$ autoreconf</span><br><span class="line">[yuhao@localhost libunwind]$ ./configure CC=icc CFLAGS=&quot;-std=c11 -g -O3 -ip&quot; CXX=icpc CCASFLAGS=-g  --prefix=/home/yuhao/tool/libunwind</span><br></pre></td></tr></table></figure></p>
<p>编译的时候又报错了，最后使用了2019的intel编译器才能编译：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">libtool: compile:  icc -DHAVE_CONFIG_H -I. -I../include -I../include -I../include/tdep-x86_64 -I. -D_GNU_SOURCE -DNDEBUG -g -std=c++11 -O3 -ip -D__EXTENSIONS__ -MT os-linux.lo -MD -MP -MF .deps/os-linux.Tpo -c os-linux.c  -fPIC -DPIC -o .libs/os-linux.o</span><br><span class="line">icc: <span class="built_in">command</span> line warning <span class="comment">#10370: option &#x27;-std=c++11&#x27; is not valid for C compilations</span></span><br><span class="line">In file included from ../include/tdep-x86_64/libunwind_i.h(41),</span><br><span class="line">                 from ../include/tdep/libunwind_i.h(25),</span><br><span class="line">                 from ../include/libunwind_i.h(356),</span><br><span class="line">                 from os-linux.c(33):</span><br><span class="line">../include/dwarf.h(355): error: identifier <span class="string">&quot;_Atomic&quot;</span> is undefined</span><br><span class="line">      _Atomic uint32_t generation;        /* generation number */</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>安装好依赖库后，相应配置mpiP的安装选项（依赖库路径，编译器，编译选项等），再按照提示安装即可。</p>
<p>mpiP生成一个动态库libmpiP.so，使用起来比较简单，不需要用它来重编程序。但为了得到正确的源文件和行号信息，最好用-g选项重编一下。两种使用方式</p>
<ul>
<li>将mpiP库与可执行文件链接起来。如果链接命令包含MPI库，要将mpiP库排序到MPI库之前，如 -l mpiP -lmpi</li>
<li>在运行时设置LD_PRELOAD环境变量来加载mpiP库</li>
</ul>
<p>mpiP提供一系列运行时选项给用户，通过打开它们来采集对应的信息。主要用到的一些列举如下：</p>
<ul>
<li><code>-k n</code>设置调用栈回溯的深度（默认1）</li>
<li><code>-o</code> 在初始化时关掉profiling，在希望profiling的特定代码段通过MPI_Pcontrol()打开</li>
<li><code>-p</code> 报告包含点对点通信的消息大小、通信子</li>
<li><code>-y</code> 报告包含集合通信的消息大小、通信子</li>
</ul>
<p>这些选项通过环境变量MPIP的设置来生效，如：export MPIP=”-t 10.0 -k 2” (bash)。</p>
<h2 id="AMG编译和运行过程"><a href="#AMG编译和运行过程" class="headerlink" title="AMG编译和运行过程"></a>AMG编译和运行过程</h2><p>选择候选程序中的AMG（<a href="https://github.com/LLNL/AMG）进行测试。clone下来之后，按照README进行编译。注意几个编译选项，开启了`-DHYPRE_USING_PERSISTENT_COMM`来使用MPI的重复非阻塞通信来提高性能，开启了`-DHYPRE_HOPSCOTCH`来提高OpenMP的优化。它还提供`-DHYPRE_PROFILE`来做一些很简单的计时，但这里没有用。">https://github.com/LLNL/AMG）进行测试。clone下来之后，按照README进行编译。注意几个编译选项，开启了`-DHYPRE_USING_PERSISTENT_COMM`来使用MPI的重复非阻塞通信来提高性能，开启了`-DHYPRE_HOPSCOTCH`来提高OpenMP的优化。它还提供`-DHYPRE_PROFILE`来做一些很简单的计时，但这里没有用。</a></p>
<p>编译需要修改Makefile.include中的<code>INCLUDE_CFLAGS</code>，加上-g选项；同时修改<code>INCLUDE_LFLAGS</code>，加上<code>-lmpip</code>选项。</p>
<p>编译过程：依次进入子目录utilities，krylov，IJ_mv，parcsr_ls，parcsr_mv，seq_mv，编译各个源文件，并生成一个对应的静态库*.a，最后进入test目录编译和链接测试程序。</p>
<h2 id="mpiP对AMG的分析结果"><a href="#mpiP对AMG的分析结果" class="headerlink" title="mpiP对AMG的分析结果"></a>mpiP对AMG的分析结果</h2><p>设置环境变量MPIP=”-k5,-e,-y,-p”，程序结束运行时输出一个mpiP的记录文件。</p>
<p>打开可以看到几部分。首先是记录了程序运行的信息，每个MPI进程的分布：<br><img src="/img/588461c83dfa4e419f68a4e1d3d0e18b.png" alt=""></p>
<p>第二部分记录了每个进程花在MPI相关的函数上的时间，占总的时间比例：<br><img src="/img/1bf4c7db76f94c9dbad142c13dba220f.png" alt=""></p>
<p>可以看到通信负载并不是很均衡，最小通信耗时的进程只是最大的一半左右。</p>
<p>第三部分展示了各个MPI相关函数调用的信息，每一个ID对应一个位置的调用（同样的MPI函数出现在不同地方的调用，有不同的ID，如下图的Waitall），这里设置了调用栈回溯为5层，所以每个ID重复出现5次，Lev较大的是调用者，同时有每一个函数所在的源文件和行数。<br><img src="/img/2df8aecfda6d4fc5a0cca1471f36322b.png" alt=""></p>
<p>如果程序所使用的进程很多，且通信模式复杂的话，这一部分将会非常庞大。这一次的运行，该部分共有47733条记录。</p>
<p>第四部分记录了总耗时在前20个的MPI函数调用。这里的site就对应上一部分的ID，可以据此判定这一项对应哪个位置的调用。<br><img src="/img/70194a30f6684349a5be1c585598045b.png" alt=""></p>
<p>类似的记录还有发的消息总大小、次数、平均大小。按照消息总大小展示前20名。<br><img src="/img/aa9b553b39f74c68bb9b3e44527ab2f6.png" alt=""></p>
<p>由于打开了-y选项，下一部分展示了集合通信的总耗时、通信子大小、数据大小。可见程序中涉及的集合通信只有四个地方。但不知道为什么，这里没有site，不知道怎么去找对应的调用位置。<br><img src="/img/a9c0895165e34c089a20f39a707ea26a.png" alt=""></p>
<p>由于打开了-p选项，下一部分展示了点对点通信的通信子大小、消息大小等，MPI_Sent %似乎表示的是这一个调用占的发送消息的总比例，但也没有显示site。<br><img src="/img/c0f34b91bdd844f6ba16714a2c8d8ce0.png" alt=""></p>
<p>最后一部分是每个调用位置的统计信息。该部分首先是时间信息，包括了操作时间的最大最小值和平均值，以及该调用位置耗时在它进程的MPI总时间和整个程序时间中的占比（Rank列中的星号代表该调用位置的累加的信息)。这部分的排序是按字母序的，a开头的Allreduce在前。<br><img src="/img/4c3ba21b8747479998fd31addc4e0485.png" alt=""></p>
<p>该部分然后是通信的消息大小的统计。<br><img src="/img/bb011d16353846ffa403d72df425e4bb.png" alt=""></p>
<h2 id="分析结果的简单分析和理解"><a href="#分析结果的简单分析和理解" class="headerlink" title="分析结果的简单分析和理解"></a>分析结果的简单分析和理解</h2><p>mpiP只能简单测量通信特征，从以上结果，大致可以有几点判断：</p>
<ul>
<li>程序中的通信以点对点通信为主<ul>
<li>ISend在发送消息的量上占比很高，各个位置的调用次数都很多，且通信消息的大小较大；对应使用的异步接收的Waiall说明是重复的非阻塞通信，且耗时占比很高</li>
<li>集合通信的类型较少，耗时占比小，消息大小也很小</li>
</ul>
</li>
<li>最耗时的点对点通信（即程序中的update halo操作），消息大小都在5.5 KB左右</li>
<li>通信负载很不均衡，MPI时间的min/max只有50%左右</li>
<li>程序的通信热点所在的路径包含了函数hypre_ParCSRMatrixMatvecOutOfPlace，因为在调用位置的栈回溯中大量出现该函数（但仅通过通信特征来明确程序热点似乎有点不足，虽然它确实就是程序最耗时的部分）</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>综合来看，要对一个程序进行性能分析，包括全面的计算、访存和通信，得需要多种的分析工具。光靠一种有点难以全面评估。而mpiP给出的信息只能覆盖通信特征，且缺乏直观，尤其在大规模进程数时，得到的callsite statistics非常庞大，需要用户自己通过site ID去找最耗时的通信调用对应在哪个地方。虽然通过mpiP的<code>MPI_Pcontrol()</code>可以实现任意具体代码段的分析，能减小输出的文件的规模，便于针对性的分析，但这就需要用户对程序代码本身有理解了才能在代码里添加<code>MPI_Pcontrol()</code>的控制。而且配合<code>MPI_Pcontrol()</code>启用-o选项后，不知道为什么，输出的文件里就没有具体通信调用处的通信子大小、消息大小等信息了。</p>
<h1 id="Git的奇技淫巧"><a href="#Git的奇技淫巧" class="headerlink" title="Git的奇技淫巧"></a>Git的奇技淫巧</h1><p>Git是一个 “分布式版本管理工具”，简单的理解版本管理工具：大家在写东西的时候都用过 “回撤” 这个功能，但是回撤只能回撤几步，假如想要找回我三天之前的修改，光用 “回撤” 是找不回来的。而 “版本管理工具” 能记录每次的修改，只要提交到版本仓库，你就可以找到之前任何时刻的状态（文本状态）。</p>
<p>下面的内容就是列举了常用的 Git 命令和一些小技巧，可以通过 “页面内查找” 的方式进行快速查询：<code>Ctrl/Command+f</code>。</p>
<h2 id="开卷必读"><a href="#开卷必读" class="headerlink" title="开卷必读"></a>开卷必读</h2><p><em>如果之前未使用过 Git，可以学习 <a href="http://rogerdudler.github.io/git-guide/index.zh.html">Git 小白教程</a>入门</em></p>
<ol>
<li><strong>一定要先测试命令的效果后</strong>，再用于工作环境中，以防造成不能弥补的后果！<strong>到时候别拿着砍刀来找我</strong></li>
<li>所有的命令都在<code>git version 2.7.4 (Apple Git-66)</code>下测试通过</li>
<li>统一概念：<ul>
<li>工作区：改动（增删文件和内容）</li>
<li>暂存区：输入命令：<code>git add 改动的文件名</code>，此次改动就放到了 ‘暂存区’</li>
<li>本地仓库(简称：本地)：输入命令：<code>git commit 此次修改的描述</code>，此次改动就放到了 ’本地仓库’，每个 commit，我叫它为一个 ‘版本’。</li>
<li>远程仓库(简称：远程)：输入命令：<code>git push 远程仓库</code>，此次改动就放到了 ‘远程仓库’（GitHub 等)</li>
<li>commit-id：输出命令：<code>git log</code>，最上面那行 <code>commit xxxxxx</code>，后面的字符串就是 commit-id</li>
</ul>
</li>
</ol>
<h2 id="展示帮助信息"><a href="#展示帮助信息" class="headerlink" title="展示帮助信息"></a>展示帮助信息</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">help</span> -g</span><br></pre></td></tr></table></figure>
<p>The command output as below:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">The common Git guides are:</span><br><span class="line">   attributes          Defining attributes per path</span><br><span class="line">   cli                 Git command-line interface and conventions</span><br><span class="line">   core-tutorial       A Git core tutorial for developers</span><br><span class="line">   cvs-migration       Git for CVS users</span><br><span class="line">   diffcore            Tweaking diff output</span><br><span class="line">   everyday            A useful minimum set of commands for Everyday Git</span><br><span class="line">   glossary            A Git Glossary</span><br><span class="line">   hooks               Hooks used by Git</span><br><span class="line">   ignore              Specifies intentionally untracked files to ignore</span><br><span class="line">   modules             Defining submodule properties</span><br><span class="line">   namespaces          Git namespaces</span><br><span class="line">   repository-layout    Git Repository Layout</span><br><span class="line">   revisions           Specifying revisions and ranges for Git</span><br><span class="line">   tutorial            A tutorial introduction to Git</span><br><span class="line">   tutorial-2          A tutorial introduction to Git: part two</span><br><span class="line">   workflows           An overview of recommended workflows with Git</span><br><span class="line"></span><br><span class="line">&#x27;git help -a&#x27; and &#x27;git help -g&#x27; list available subcommands and some concept guides. See &#x27;git help &lt;command&gt;&#x27; or &#x27;git help &lt;concept&gt;&#x27; to read about a specific subcommand or concept.</span><br></pre></td></tr></table></figure>
<h2 id="回到远程仓库的状态"><a href="#回到远程仓库的状态" class="headerlink" title="回到远程仓库的状态"></a>回到远程仓库的状态</h2><p>抛弃本地所有的修改，回到远程仓库的状态。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all &amp;&amp; git reset --hard origin/master</span><br></pre></td></tr></table></figure></p>
<h2 id="重设第一个-commit"><a href="#重设第一个-commit" class="headerlink" title="重设第一个 commit"></a>重设第一个 commit</h2><p>也就是把所有的改动都重新放回工作区，并<strong>清空所有的 commit</strong>，这样就可以重新提交第一个 commit 了</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-ref -d HEAD</span><br></pre></td></tr></table></figure>
<h2 id="展示工作区和暂存区的不同"><a href="#展示工作区和暂存区的不同" class="headerlink" title="展示工作区和暂存区的不同"></a>展示工作区和暂存区的不同</h2><p>输出<strong>工作区</strong>和<strong>暂存区</strong>的 different (不同)。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>
<p>还可以展示本地仓库中任意两个 commit 之间的文件变动：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;commit-id&gt; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="展示暂存区和最近版本的不同"><a href="#展示暂存区和最近版本的不同" class="headerlink" title="展示暂存区和最近版本的不同"></a>展示暂存区和最近版本的不同</h2><p>输出<strong>暂存区</strong>和本地最近的版本 (commit) 的 different (不同)。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure></p>
<h2 id="展示暂存区、工作区和最近版本的不同"><a href="#展示暂存区、工作区和最近版本的不同" class="headerlink" title="展示暂存区、工作区和最近版本的不同"></a>展示暂存区、工作区和最近版本的不同</h2><p>输出<strong>工作区</strong>、<strong>暂存区</strong> 和本地最近的版本 (commit) 的 different (不同)。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure>
<h2 id="快速切换到上一个分支"><a href="#快速切换到上一个分支" class="headerlink" title="快速切换到上一个分支"></a>快速切换到上一个分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure>
<h2 id="删除已经合并到-master-的分支"><a href="#删除已经合并到-master-的分支" class="headerlink" title="删除已经合并到 master 的分支"></a>删除已经合并到 master 的分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged master | grep -v <span class="string">&#x27;^\*\|  master&#x27;</span> | xargs -n 1 git branch -d</span><br></pre></td></tr></table></figure>
<h2 id="展示本地分支关联远程仓库的情况"><a href="#展示本地分支关联远程仓库的情况" class="headerlink" title="展示本地分支关联远程仓库的情况"></a>展示本地分支关联远程仓库的情况</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure>
<h2 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h2><p>关联之后，<code>git branch -vv</code> 就可以展示关联的远程分支名了，同时推送到远程仓库直接：<code>git push</code>，不需要指定远程仓库了。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -u origin/mybranch</span><br></pre></td></tr></table></figure></p>
<p>或者在 push 时加上 <code>-u</code> 参数<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin/mybranch -u</span><br></pre></td></tr></table></figure></p>
<h2 id="列出所有远程分支"><a href="#列出所有远程分支" class="headerlink" title="列出所有远程分支"></a>列出所有远程分支</h2><p>-r 参数相当于：remote<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure></p>
<h2 id="列出本地和远程分支"><a href="#列出本地和远程分支" class="headerlink" title="列出本地和远程分支"></a>列出本地和远程分支</h2><p>-a 参数相当于：all<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure></p>
<h2 id="创建并切换到本地分支"><a href="#创建并切换到本地分支" class="headerlink" title="创建并切换到本地分支"></a>创建并切换到本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="从远程分支中创建并切换到本地分支"><a href="#从远程分支中创建并切换到本地分支" class="headerlink" title="从远程分支中创建并切换到本地分支"></a>从远程分支中创建并切换到本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;local-branchname&gt;</span><br></pre></td></tr></table></figure>
<h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :&lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure>
<h2 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;new-branch-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<p>展示当前分支的最近的 tag</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe --tags --abbrev=0</span><br></pre></td></tr></table></figure>
<h2 id="查看标签详细信息"><a href="#查看标签详细信息" class="headerlink" title="查看标签详细信息"></a>查看标签详细信息</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -<span class="built_in">ln</span></span><br></pre></td></tr></table></figure>
<h2 id="本地创建标签"><a href="#本地创建标签" class="headerlink" title="本地创建标签"></a>本地创建标签</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;version-number&gt;</span><br></pre></td></tr></table></figure>
<p>默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a &lt;version-number&gt; -m <span class="string">&quot;v1.0 发布(描述)&quot;</span> &lt;commit-id&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="推送标签到远程仓库"><a href="#推送标签到远程仓库" class="headerlink" title="推送标签到远程仓库"></a>推送标签到远程仓库</h2><p>首先要保证本地创建好了标签才可以推送标签到远程仓库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;local-version-number&gt;</span><br></pre></td></tr></table></figure>
<p>一次性推送所有标签，同步到远程仓库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>
<h2 id="删除本地标签"><a href="#删除本地标签" class="headerlink" title="删除本地标签"></a>删除本地标签</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tag-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h2><p>删除远程标签需要<strong>先删除本地标签</strong>，再执行下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/&lt;tag-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="切回到某个标签"><a href="#切回到某个标签" class="headerlink" title="切回到某个标签"></a>切回到某个标签</h2><p>一般上线之前都会打 tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b branch_name tag_name</span><br></pre></td></tr></table></figure></p>
<h2 id="放弃工作区的修改"><a href="#放弃工作区的修改" class="headerlink" title="放弃工作区的修改"></a>放弃工作区的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;file-name&gt;</span><br></pre></td></tr></table></figure>
<p>放弃所有修改：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure></p>
<h2 id="恢复删除的文件"><a href="#恢复删除的文件" class="headerlink" title="恢复删除的文件"></a>恢复删除的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rev-list -n 1 HEAD -- &lt;file_path&gt; <span class="comment">#得到 deleting_commit</span></span><br><span class="line"></span><br><span class="line">git checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt; <span class="comment">#回到删除文件 deleting_commit 之前的状态</span></span><br></pre></td></tr></table></figure>
<h2 id="以新增一个-commit-的方式还原某一个-commit-的修改"><a href="#以新增一个-commit-的方式还原某一个-commit-的修改" class="headerlink" title="以新增一个 commit 的方式还原某一个 commit 的修改"></a>以新增一个 commit 的方式还原某一个 commit 的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>
<h2 id="回到某个-commit-的状态，并删除后面的-commit"><a href="#回到某个-commit-的状态，并删除后面的-commit" class="headerlink" title="回到某个 commit 的状态，并删除后面的 commit"></a>回到某个 commit 的状态，并删除后面的 commit</h2><p>和 revert 的区别：reset 命令会抹去某个 commit id 之后的所有 commit</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit-id&gt;  <span class="comment">#默认就是-mixed参数。</span></span><br><span class="line"></span><br><span class="line">git reset –mixed HEAD^  <span class="comment">#回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。</span></span><br><span class="line"></span><br><span class="line">git reset –soft HEAD~3  <span class="comment">#回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可  </span></span><br><span class="line"></span><br><span class="line">git reset –hard &lt;commit-id&gt;  <span class="comment">#彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容</span></span><br></pre></td></tr></table></figure>
<h2 id="修改上一个-commit-的描述"><a href="#修改上一个-commit-的描述" class="headerlink" title="修改上一个 commit 的描述"></a>修改上一个 commit 的描述</h2><p>如果暂存区有改动，同时也会将暂存区的改动提交到上一个 commit</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<h2 id="查看-commit-历史"><a href="#查看-commit-历史" class="headerlink" title="查看 commit 历史"></a>查看 commit 历史</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<h2 id="查看某段代码是谁写的"><a href="#查看某段代码是谁写的" class="headerlink" title="查看某段代码是谁写的"></a>查看某段代码是谁写的</h2><p>blame 的意思为‘责怪’，你懂的。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;file-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="显示本地更新过-HEAD-的-git-命令记录"><a href="#显示本地更新过-HEAD-的-git-命令记录" class="headerlink" title="显示本地更新过 HEAD 的 git 命令记录"></a>显示本地更新过 HEAD 的 git 命令记录</h2><p>每次更新了 HEAD 的 git 命令比如 commint、amend、cherry-pick、reset、revert 等都会被记录下来（不限分支），就像 shell 的 history 一样。<br>这样你可以 reset 到任何一次更新了 HEAD 的操作之后，而不仅仅是回到当前分支下的某个 commit 之后的状态。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<h2 id="修改作者名"><a href="#修改作者名" class="headerlink" title="修改作者名"></a>修改作者名</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend --author=<span class="string">&#x27;Author Name &lt;email@address.com&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="修改远程仓库的-url"><a href="#修改远程仓库的-url" class="headerlink" title="修改远程仓库的 url"></a>修改远程仓库的 url</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin &lt;URL&gt;</span><br></pre></td></tr></table></figure>
<h2 id="增加远程仓库"><a href="#增加远程仓库" class="headerlink" title="增加远程仓库"></a>增加远程仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;remote-url&gt;</span><br></pre></td></tr></table></figure>
<h2 id="列出所有远程仓库"><a href="#列出所有远程仓库" class="headerlink" title="列出所有远程仓库"></a>列出所有远程仓库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>
<h2 id="查看两个星期内的改动"><a href="#查看两个星期内的改动" class="headerlink" title="查看两个星期内的改动"></a>查看两个星期内的改动</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git whatchanged --since=<span class="string">&#x27;2 weeks ago&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="把-A-分支的某一个-commit，放到-B-分支上"><a href="#把-A-分支的某一个-commit，放到-B-分支上" class="headerlink" title="把 A 分支的某一个 commit，放到 B 分支上"></a>把 A 分支的某一个 commit，放到 B 分支上</h2><p>这个过程需要 <code>cherry-pick</code> 命令，<a href="http://sg552.iteye.com/blog/1300713#bc2367928">参考</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>
<h2 id="给-git-命令起别名"><a href="#给-git-命令起别名" class="headerlink" title="给 git 命令起别名"></a>给 git 命令起别名</h2><p>简化命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global <span class="built_in">alias</span>.&lt;handle&gt; &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line">比如：git status 改成 git st，这样可以简化命令</span><br><span class="line"></span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure>
<h2 id="存储当前的修改，但不用提交-commit"><a href="#存储当前的修改，但不用提交-commit" class="headerlink" title="存储当前的修改，但不用提交 commit"></a>存储当前的修改，但不用提交 commit</h2><p>详解可以参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000">廖雪峰老师的 git 教程</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></p>
<h2 id="保存当前状态，包括-untracked-的文件"><a href="#保存当前状态，包括-untracked-的文件" class="headerlink" title="保存当前状态，包括 untracked 的文件"></a>保存当前状态，包括 untracked 的文件</h2><p>untracked 文件：新建的文件<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash -u</span><br></pre></td></tr></table></figure></p>
<h2 id="展示所有-stashes"><a href="#展示所有-stashes" class="headerlink" title="展示所有 stashes"></a>展示所有 stashes</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<h2 id="回到某个-stash-的状态"><a href="#回到某个-stash-的状态" class="headerlink" title="回到某个 stash 的状态"></a>回到某个 stash 的状态</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply &lt;stash@&#123;n&#125;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="回到最后一个-stash-的状态，并删除这个-stash"><a href="#回到最后一个-stash-的状态，并删除这个-stash" class="headerlink" title="回到最后一个 stash 的状态，并删除这个 stash"></a>回到最后一个 stash 的状态，并删除这个 stash</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
<h2 id="删除所有的-stash"><a href="#删除所有的-stash" class="headerlink" title="删除所有的 stash"></a>删除所有的 stash</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure>
<h2 id="从-stash-中拿出某个文件的修改"><a href="#从-stash-中拿出某个文件的修改" class="headerlink" title="从 stash 中拿出某个文件的修改"></a>从 stash 中拿出某个文件的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;stash@&#123;n&#125;&gt; -- &lt;file-path&gt;</span><br></pre></td></tr></table></figure>
<h2 id="展示所有-tracked-的文件"><a href="#展示所有-tracked-的文件" class="headerlink" title="展示所有 tracked 的文件"></a>展示所有 tracked 的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files -t</span><br></pre></td></tr></table></figure>
<h2 id="展示所有-untracked-的文件"><a href="#展示所有-untracked-的文件" class="headerlink" title="展示所有 untracked 的文件"></a>展示所有 untracked 的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --others</span><br></pre></td></tr></table></figure>
<h2 id="展示所有忽略的文件"><a href="#展示所有忽略的文件" class="headerlink" title="展示所有忽略的文件"></a>展示所有忽略的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files --others -i --exclude-standard</span><br></pre></td></tr></table></figure>
<h2 id="强制删除-untracked-的文件"><a href="#强制删除-untracked-的文件" class="headerlink" title="强制删除 untracked 的文件"></a>强制删除 untracked 的文件</h2><p>可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的 untracked 文件。<code>clean</code> 命令，<strong>注意两点</strong>：</p>
<ol>
<li>clean 后，删除的文件无法找回</li>
<li>不会影响 tracked 的文件的改动，只会删除 untracked 的文件</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean &lt;file-name&gt; -f</span><br></pre></td></tr></table></figure>
<h2 id="强制删除-untracked-的目录"><a href="#强制删除-untracked-的目录" class="headerlink" title="强制删除 untracked 的目录"></a>强制删除 untracked 的目录</h2><p>可以用来删除新建的目录，<strong>注意</strong>:这个命令也可以用来删除 untracked 的文件。详情见上一条</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean &lt;directory-name&gt; -<span class="built_in">df</span></span><br></pre></td></tr></table></figure>
<h2 id="展示简化的-commit-历史"><a href="#展示简化的-commit-历史" class="headerlink" title="展示简化的 commit 历史"></a>展示简化的 commit 历史</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline --graph --decorate --all</span><br></pre></td></tr></table></figure>
<h2 id="把某一个分支到导出成一个文件"><a href="#把某一个分支到导出成一个文件" class="headerlink" title="把某一个分支到导出成一个文件"></a>把某一个分支到导出成一个文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bundle create &lt;file&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="从包中导入分支"><a href="#从包中导入分支" class="headerlink" title="从包中导入分支"></a>从包中导入分支</h2><p>新建一个分支，分支内容就是上面 <code>git bundle create</code> 命令导出的内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="执行-rebase-之前自动-stash"><a href="#执行-rebase-之前自动-stash" class="headerlink" title="执行 rebase 之前自动 stash"></a>执行 rebase 之前自动 stash</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase --autostash</span><br></pre></td></tr></table></figure>
<h2 id="从远程仓库根据-ID，拉下某一状态，到本地分支"><a href="#从远程仓库根据-ID，拉下某一状态，到本地分支" class="headerlink" title="从远程仓库根据 ID，拉下某一状态，到本地分支"></a>从远程仓库根据 ID，拉下某一状态，到本地分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin pull/&lt;<span class="built_in">id</span>&gt;/head:&lt;branch-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="详细展示一行中的修改"><a href="#详细展示一行中的修改" class="headerlink" title="详细展示一行中的修改"></a>详细展示一行中的修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --word-diff</span><br></pre></td></tr></table></figure>
<h2 id="清除-gitignore-文件中记录的文件"><a href="#清除-gitignore-文件中记录的文件" class="headerlink" title="清除 gitignore 文件中记录的文件"></a>清除 gitignore 文件中记录的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -X -f</span><br></pre></td></tr></table></figure>
<h2 id="展示所有-alias-和-configs"><a href="#展示所有-alias-和-configs" class="headerlink" title="展示所有 alias 和 configs"></a>展示所有 alias 和 configs</h2><p><strong>注意：</strong> config 分为：当前目录（local）和全局（golbal）的 config，默认为当前目录的 config</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> --list (当前目录)</span><br><span class="line">git config --global --list (全局)</span><br></pre></td></tr></table></figure>
<h2 id="展示忽略的文件"><a href="#展示忽略的文件" class="headerlink" title="展示忽略的文件"></a>展示忽略的文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status --ignored</span><br></pre></td></tr></table></figure>
<h2 id="commit-历史中显示-Branch1-有的，但是-Branch2-没有-commit"><a href="#commit-历史中显示-Branch1-有的，但是-Branch2-没有-commit" class="headerlink" title="commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit"></a>commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> Branch1 ^Branch2</span><br></pre></td></tr></table></figure>
<h2 id="在-commit-log-中显示-GPG-签名"><a href="#在-commit-log-中显示-GPG-签名" class="headerlink" title="在 commit log 中显示 GPG 签名"></a>在 commit log 中显示 GPG 签名</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --show-signature</span><br></pre></td></tr></table></figure>
<h2 id="删除全局设置"><a href="#删除全局设置" class="headerlink" title="删除全局设置"></a>删除全局设置</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> &lt;entry-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="新建并切换到新分支上，同时这个分支没有任何-commit"><a href="#新建并切换到新分支上，同时这个分支没有任何-commit" class="headerlink" title="新建并切换到新分支上，同时这个分支没有任何 commit"></a>新建并切换到新分支上，同时这个分支没有任何 commit</h2><p>相当于保存修改，但是重写 commit 历史</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --orphan &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="展示任意分支某一文件的内容"><a href="#展示任意分支某一文件的内容" class="headerlink" title="展示任意分支某一文件的内容"></a>展示任意分支某一文件的内容</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show &lt;branch-name&gt;:&lt;file-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="clone-下来指定的单一分支"><a href="#clone-下来指定的单一分支" class="headerlink" title="clone 下来指定的单一分支"></a>clone 下来指定的单一分支</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git</span><br></pre></td></tr></table></figure>
<h2 id="忽略某个文件的改动"><a href="#忽略某个文件的改动" class="headerlink" title="忽略某个文件的改动"></a>忽略某个文件的改动</h2><p>关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index --assume-unchanged path/to/file</span><br></pre></td></tr></table></figure>
<p>恢复 track 指定文件的改动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index --no-assume-unchanged path/to/file</span><br></pre></td></tr></table></figure>
<h2 id="忽略文件的权限变化"><a href="#忽略文件的权限变化" class="headerlink" title="忽略文件的权限变化"></a>忽略文件的权限变化</h2><p>不再将文件的权限变化视作改动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.fileMode <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="以最后提交的顺序列出所有-Git-分支"><a href="#以最后提交的顺序列出所有-Git-分支" class="headerlink" title="以最后提交的顺序列出所有 Git 分支"></a>以最后提交的顺序列出所有 Git 分支</h2><p>最新的放在最上面</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git for-each-ref --<span class="built_in">sort</span>=-committerdate --format=<span class="string">&#x27;%(refname:short)&#x27;</span> refs/heads/</span><br></pre></td></tr></table></figure>
<h2 id="在-commit-log-中查找相关内容"><a href="#在-commit-log-中查找相关内容" class="headerlink" title="在 commit log 中查找相关内容"></a>在 commit log 中查找相关内容</h2><p>通过 grep 查找，given-text：所需要查找的字段</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --all --grep=<span class="string">&#x27;&lt;given-text&gt;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="把暂存区的指定-file-放到工作区中"><a href="#把暂存区的指定-file-放到工作区中" class="headerlink" title="把暂存区的指定 file 放到工作区中"></a>把暂存区的指定 file 放到工作区中</h2><p>不添加参数，默认是 <code>-mixed</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="强制推送"><a href="#强制推送" class="headerlink" title="强制推送"></a>强制推送</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="一图详解"><a href="#一图详解" class="headerlink" title="一图详解"></a>一图详解</h2><p><img src="/img/20190421001.png" alt=""></p>
<h2 id="优雅的提交Commit信息"><a href="#优雅的提交Commit信息" class="headerlink" title="优雅的提交Commit信息"></a>优雅的提交Commit信息</h2><p>使用<a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines">Angular团队提交规范</a></p>
<p>主要有以下组成</p>
<ul>
<li>标题行: 必填, 描述主要修改类型和内容</li>
<li>主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等等</li>
<li>页脚注释: 放 Breaking Changes 或 Closed Issues</li>
</ul>
<p>常用的修改项</p>
<ul>
<li>type: commit 的类型</li>
<li>feat: 新特性</li>
<li>fix: 修改问题</li>
<li>refactor: 代码重构</li>
<li>docs: 文档修改</li>
<li>style: 代码格式修改, 注意不是 css 修改</li>
<li>test: 测试用例修改</li>
<li>chore: 其他修改, 比如构建流程, 依赖管理.</li>
<li>scope: commit 影响的范围, 比如: route, component, utils, build…</li>
<li>subject: commit 的概述</li>
<li>body: commit 具体修改内容, 可以分为多行</li>
<li>footer: 一些备注, 通常是 BREAKING CHANGE 或修复的 bug 的链接.</li>
</ul>
<h1 id="memcached完全剖析"><a href="#memcached完全剖析" class="headerlink" title="memcached完全剖析"></a>memcached完全剖析</h1><h2 id="memcached是什么？"><a href="#memcached是什么？" class="headerlink" title="memcached是什么？"></a>memcached是什么？</h2><p>memcached是以LiveJournal旗下Danga Interactive 公司的Brad Fitzpatric为首开发的一款软件。现在已成为mixi、hatena、 Facebook、Vox、LiveJournal等众多服务中提高Web应用扩展性的重要因素。</p>
<p>许多Web应用都将数据保存到RDBMS中，应用服务器从中读取数据并在浏览器中显示。 但随着数据量的增大、访问的集中，就会出现RDBMS的负担加重、数据库响应恶化、 网站显示延迟等重大影响。</p>
<p>这时就该memcached大显身手了。memcached是高性能的分布式内存缓存服务器。 一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、 提高可扩展性。</p>
<p><img src="/img/20191008001.png" alt="图1 一般情况下memcached的用途"></p>
<h2 id="memcached的特征"><a href="#memcached的特征" class="headerlink" title="memcached的特征"></a>memcached的特征</h2><p>memcached作为高速运行的分布式缓存服务器，具有以下的特点。</p>
<ul>
<li>协议简单</li>
<li>基于libevent的事件处理</li>
<li>内置内存存储方式</li>
<li>memcached不互相通信的分布式</li>
</ul>
<h3 id="协议简单"><a href="#协议简单" class="headerlink" title="协议简单"></a>协议简单</h3><p>memcached的服务器客户端通信并不使用复杂的XML等格式，而使用简单的基于文本行的协议。因此，通过telnet 也能在memcached上保存数据、取得数据。下面是例子。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ telnet localhost 11211</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.localdomain (127.0.0.1).</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">set foo 0 0 3     （保存命令）</span><br><span class="line">bar               （数据）</span><br><span class="line">STORED            （结果）</span><br><span class="line">get foo           （取得命令）</span><br><span class="line">VALUE foo 0 3     （数据）</span><br><span class="line">bar               （数据）</span><br></pre></td></tr></table></figure><br>协议文档位于memcached的源代码内，也可以参考以下的URL。</p>
<p><a href="http://code.sixapart.com/svn/memcached/trunk/server/doc/protocol.txt">http://code.sixapart.com/svn/memcached/trunk/server/doc/protocol.txt</a></p>
<h3 id="基于libevent的事件处理"><a href="#基于libevent的事件处理" class="headerlink" title="基于libevent的事件处理"></a>基于libevent的事件处理</h3><p>libevent是个程序库，它将Linux的epoll、BSD类操作系统的kqueue等事件处理功能 封装成统一的接口。即使对服务器的连接数增加，也能发挥O(1)的性能。 memcached使用这个libevent库，因此能在Linux、BSD、Solaris等操作系统上发挥其高性能。 关于事件处理这里就不再详细介绍，可以参考Dan Kegel的The C10K Problem。</p>
<p>libevent: <a href="http://www.monkey.org/~provos/libevent/">http://www.monkey.org/~provos/libevent/</a><br>The C10K Problem: <a href="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</a></p>
<h3 id="内置内存存储方式"><a href="#内置内存存储方式" class="headerlink" title="内置内存存储方式"></a>内置内存存储方式</h3><p>为了提高性能，memcached中保存的数据都存储在memcached内置的内存存储空间中。 由于数据仅存在于内存中，因此重启memcached、重启操作系统会导致全部数据消失。 另外，内容容量达到指定值之后，就基于LRU(Least Recently Used)算法自动删除不使用的缓存。 memcached本身是为缓存而设计的服务器，因此并没有过多考虑数据的永久性问题。 关于内存存储的详细信息，本连载的第二讲以后前坂会进行介绍，请届时参考。</p>
<h3 id="memcached不互相通信的分布式"><a href="#memcached不互相通信的分布式" class="headerlink" title="memcached不互相通信的分布式"></a>memcached不互相通信的分布式</h3><p>memcached尽管是“分布式”缓存服务器，但服务器端并没有分布式功能。 各个memcached不会互相通信以共享信息。那么，怎样进行分布式呢？ 这完全取决于客户端的实现。本连载也将介绍memcached的分布式。</p>
<p><img src="/img/20191008002.png" alt="图2 memcached的分布式"></p>
<p>接下来简单介绍一下memcached的使用方法。</p>
<h3 id="memcached的安装"><a href="#memcached的安装" class="headerlink" title="memcached的安装"></a>memcached的安装</h3><p>运行memcached需要本文开头介绍的libevent库。Fedora 8中有现成的rpm包， 通过yum命令安装即可。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install libevent libevent-devel</span><br></pre></td></tr></table></figure><br>memcached的源代码可以从memcached网站上下载。本文执笔时的最新版本为1.2.5。 Fedora 8虽然也包含了memcached的rpm，但版本比较老。因为源代码安装并不困难， 这里就不使用rpm了。</p>
<p>下载memcached：<a href="http://www.danga.com/memcached/download.bml">http://www.danga.com/memcached/download.bml</a><br>memcached安装与一般应用程序相同，configure、make、make install就行了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://www.danga.com/memcached/dist/memcached-1.2.5.tar.gz</span><br><span class="line">$ tar zxf memcached-1.2.5.tar.gz</span><br><span class="line">$ cd memcached-1.2.5</span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><br>默认情况下memcached安装到/usr/local/bin下。</p>
<h3 id="memcached的启动"><a href="#memcached的启动" class="headerlink" title="memcached的启动"></a>memcached的启动</h3><p>从终端输入以下命令，启动memcached。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/local/bin/memcached -p 11211 -m 64m -vv</span><br><span class="line">slab class   1: chunk size     88 perslab 11915</span><br><span class="line">slab class   2: chunk size    112 perslab  9362</span><br><span class="line">slab class   3: chunk size    144 perslab  7281</span><br><span class="line">中间省略</span><br><span class="line">slab class  38: chunk size 391224 perslab     2</span><br><span class="line">slab class  39: chunk size 489032 perslab     2</span><br><span class="line">&lt;23 server listening</span><br><span class="line">&lt;24 send buffer was 110592, now 268435456</span><br><span class="line">&lt;24 server listening (udp)</span><br><span class="line">&lt;24 server listening (udp)</span><br><span class="line">&lt;24 server listening (udp)</span><br><span class="line">&lt;24 server listening (udp)</span><br></pre></td></tr></table></figure><br>这里显示了调试信息。这样就在前台启动了memcached，监听TCP端口11211 最大内存使用量为64M。调试信息的内容大部分是关于存储的信息， 下次连载时具体说明。</p>
<p>作为daemon后台启动时，只需<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/local/bin/memcached -p 11211 -m 64m -d</span><br></pre></td></tr></table></figure><br>这里使用的memcached启动选项的内容如下。</p>
<ul>
<li><code>-p</code>使用的TCP端口。默认为11211</li>
<li><code>-m</code>最大内存大小。默认为64M</li>
<li><code>-vv</code>用very vrebose模式启动，调试信息和错误输出到控制台</li>
<li><code>-d</code>作为daemon在后台启动</li>
</ul>
<p>上面四个是常用的启动选项，其他还有很多，通过<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/local/bin/memcached -h</span><br></pre></td></tr></table></figure><br>命令可以显示。许多选项可以改变memcached的各种行为， 推荐读一读。</p>
<h2 id="使用Cache-Memcached"><a href="#使用Cache-Memcached" class="headerlink" title="使用Cache::Memcached"></a>使用Cache::Memcached</h2><p>Perl的memcached客户端有</p>
<ul>
<li>Cache::Memcached</li>
<li>Cache::Memcached::Fast</li>
<li>Cache::Memcached::libmemcached</li>
</ul>
<p>等几个CPAN模块。这里介绍的Cache::Memcached是memcached的作者Brad Fitzpatric的作品， 应该算是memcached的客户端中应用最为广泛的模块了。</p>
<h3 id="使用Cache-Memcached连接memcached"><a href="#使用Cache-Memcached连接memcached" class="headerlink" title="使用Cache::Memcached连接memcached"></a>使用Cache::Memcached连接memcached</h3><p>下面的源代码为通过Cache::Memcached连接刚才启动的memcached的例子。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/perl</span><br><span class="line"></span><br><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line">use Cache::Memcached;</span><br><span class="line"></span><br><span class="line">my $key = &quot;foo&quot;;</span><br><span class="line">my $value = &quot;bar&quot;;</span><br><span class="line">my $expires = 3600; # 1 hour</span><br><span class="line">my $memcached = Cache::Memcached-&gt;new(&#123;</span><br><span class="line">    servers =&gt; [&quot;127.0.0.1:11211&quot;],</span><br><span class="line">    compress_threshold =&gt; 10_000</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$memcached-&gt;add($key, $value, $expires);</span><br><span class="line">my $ret = $memcached-&gt;get($key);</span><br><span class="line">print &quot;$ret\n&quot;;</span><br></pre></td></tr></table></figure><br>在这里，为Cache::Memcached指定了memcached服务器的IP地址和一个选项，以生成实例。 Cache::Memcached常用的选项如下所示。</p>
<ul>
<li>servers    用数组指定memcached服务器和端口</li>
<li>compress_threshold    数据压缩时使用的值</li>
<li>namespace    指定添加到键的前缀</li>
</ul>
<p>另外，Cache::Memcached通过Storable模块可以将Perl的复杂数据序列化之后再保存， 因此散列、数组、对象等都可以直接保存到memcached中。</p>
<h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>向memcached保存数据的方法有</p>
<ul>
<li>add</li>
<li>replace</li>
<li>set</li>
</ul>
<p>它们的使用方法都相同：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my $add = $memcached-&gt;add( &#x27;键&#x27;, &#x27;值&#x27;, &#x27;期限&#x27; );</span><br><span class="line">my $replace = $memcached-&gt;replace( &#x27;键&#x27;, &#x27;值&#x27;, &#x27;期限&#x27; );</span><br><span class="line">my $set = $memcached-&gt;set( &#x27;键&#x27;, &#x27;值&#x27;, &#x27;期限&#x27; );</span><br></pre></td></tr></table></figure><br>向memcached保存数据时可以指定期限(秒)。不指定期限时，memcached按照LRU算法保存数据。 这三个方法的区别如下：</p>
<ul>
<li>add    仅当存储空间中不存在键相同的数据时才保存</li>
<li>replace    仅当存储空间中存在键相同的数据时才保存</li>
<li>set    与add和replace不同，无论何时都保存</li>
</ul>
<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>获取数据可以使用get和get_multi方法。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my $val = $memcached-&gt;get(&#x27;键&#x27;);</span><br><span class="line">my $val = $memcached-&gt;get_multi(&#x27;键1&#x27;, &#x27;键2&#x27;, &#x27;键3&#x27;, &#x27;键4&#x27;, &#x27;键5&#x27;);</span><br></pre></td></tr></table></figure><br>一次取得多条数据时使用get_multi。get_multi可以非同步地同时取得多个键值， 其速度要比循环调用get快数十倍。</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除数据使用delete方法，不过它有个独特的功能。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$memcached-&gt;delete(&#x27;键&#x27;, &#x27;阻塞时间(秒)&#x27;);</span><br></pre></td></tr></table></figure><br>删除第一个参数指定的键的数据。第二个参数指定一个时间值，可以禁止使用同样的键保存新数据。 此功能可以用于防止缓存数据的不完整。但是要注意，set函数忽视该阻塞，照常保存数据</p>
<h3 id="增一和减一操作"><a href="#增一和减一操作" class="headerlink" title="增一和减一操作"></a>增一和减一操作</h3><p>可以将memcached上特定的键值作为计数器使用。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my $ret = $memcached-&gt;incr(&#x27;键&#x27;);</span><br><span class="line">$memcached-&gt;add(&#x27;键&#x27;, 0) unless defined $ret;</span><br></pre></td></tr></table></figure><br>增一和减一是原子操作，但未设置初始值时，不会自动赋成0。因此， 应当进行错误检查，必要时加入初始化操作。而且，服务器端也不会对 超过2 SUP(32)时的行为进行检查。</p>
<h3 id="Slab-Allocation机制：整理内存以便重复使用"><a href="#Slab-Allocation机制：整理内存以便重复使用" class="headerlink" title="Slab Allocation机制：整理内存以便重复使用"></a>Slab Allocation机制：整理内存以便重复使用</h3><p>最近的memcached默认情况下采用了名为Slab Allocator的机制分配、管理内存。 在该机制出现以前，内存的分配是通过对所有记录简单地进行malloc和free来进行的。 但是，这种方式会导致内存碎片，加重操作系统内存管理器的负担，最坏的情况下， 会导致操作系统比memcached进程本身还慢。Slab Allocator就是为解决该问题而诞生的。</p>
<p>下面来看看Slab Allocator的原理。下面是memcached文档中的slab allocator的目标：</p>
<p>the primary goal of the slabs subsystem in memcached was to eliminate memory fragmentation issues totally by using fixed-size memory chunks coming from a few predetermined size classes.</p>
<p>也就是说，Slab Allocator的基本原理是按照预先规定的大小，将分配的内存分割成特定长度的块， 以完全解决内存碎片问题。</p>
<p>Slab Allocation的原理相当简单。 将分配的内存分割成各种尺寸的块（chunk）， 并把尺寸相同的块分成组（chunk的集合）（图1）。<br><img src="/img/20191008003.png" alt="图1 Slab Allocation的构造图"></p>
<p>而且，slab allocator还有重复使用已分配的内存的目的。 也就是说，分配到的内存不会释放，而是重复利用。</p>
<h3 id="Slab-Allocation的主要术语"><a href="#Slab-Allocation的主要术语" class="headerlink" title="Slab Allocation的主要术语"></a>Slab Allocation的主要术语</h3><h4 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h4><p>分配给Slab的内存空间，默认是1MB。分配给Slab之后根据slab的大小切分成chunk。</p>
<h4 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h4><p>用于缓存记录的内存空间。</p>
<h4 id="Slab-Class"><a href="#Slab-Class" class="headerlink" title="Slab Class"></a>Slab Class</h4><p>特定大小的chunk的组。</p>
<h2 id="在Slab中缓存记录的原理"><a href="#在Slab中缓存记录的原理" class="headerlink" title="在Slab中缓存记录的原理"></a>在Slab中缓存记录的原理</h2><p>下面说明memcached如何针对客户端发送的数据选择slab并缓存到chunk中。</p>
<p>memcached根据收到的数据的大小，选择最适合数据大小的slab（图2）。 memcached中保存着slab内空闲chunk的列表，根据该列表选择chunk， 然后将数据缓存于其中。</p>
<p><img src="/img/20191008004.png" alt="图2 选择存储记录的组的方法"></p>
<p>实际上，Slab Allocator也是有利也有弊。下面介绍一下它的缺点。</p>
<h2 id="Slab-Allocator的缺点"><a href="#Slab-Allocator的缺点" class="headerlink" title="Slab Allocator的缺点"></a>Slab Allocator的缺点</h2><p>Slab Allocator解决了当初的内存碎片问题，但新的机制也给memcached带来了新的问题。</p>
<p>这个问题就是，由于分配的是特定长度的内存，因此无法有效利用分配的内存。 例如，将100字节的数据缓存到128字节的chunk中，剩余的28字节就浪费了（图3）。<br><img src="/img/20191008005.png" alt="图3 chunk空间的使用"></p>
<p>对于该问题目前还没有完美的解决方案，但在文档中记载了比较有效的解决方案。</p>
<p>The most efficient way to reduce the waste is to use a list of size classes that closely matches (if that’s at all possible) common sizes of objects that the clients of this particular installation of memcached are likely to store.</p>
<p>就是说，如果预先知道客户端发送的数据的公用大小，或者仅缓存大小相同的数据的情况下， 只要使用适合数据大小的组的列表，就可以减少浪费。</p>
<p>但是很遗憾，现在还不能进行任何调优，只能期待以后的版本了。 但是，我们可以调节slab class的大小的差别。 接下来说明growth factor选项。</p>
<h2 id="使用Growth-Factor进行调优"><a href="#使用Growth-Factor进行调优" class="headerlink" title="使用Growth Factor进行调优"></a>使用Growth Factor进行调优</h2><p>memcached在启动时指定 Growth Factor因子（通过-f选项）， 就可以在某种程度上控制slab之间的差异。默认值为1.25。 但是，在该选项出现之前，这个因子曾经固定为2，称为“powers of 2”策略。</p>
<p>让我们用以前的设置，以verbose模式启动memcached试试看：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ memcached -f 2 -vv</span><br></pre></td></tr></table></figure><br>下面是启动后的verbose输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">slab class   1: chunk size    128 perslab  8192</span><br><span class="line">slab class   2: chunk size    256 perslab  4096</span><br><span class="line">slab class   3: chunk size    512 perslab  2048</span><br><span class="line">slab class   4: chunk size   1024 perslab  1024</span><br><span class="line">slab class   5: chunk size   2048 perslab   512</span><br><span class="line">slab class   6: chunk size   4096 perslab   256</span><br><span class="line">slab class   7: chunk size   8192 perslab   128</span><br><span class="line">slab class   8: chunk size  16384 perslab    64</span><br><span class="line">slab class   9: chunk size  32768 perslab    32</span><br><span class="line">slab class  10: chunk size  65536 perslab    16</span><br><span class="line">slab class  11: chunk size 131072 perslab     8</span><br><span class="line">slab class  12: chunk size 262144 perslab     4</span><br><span class="line">slab class  13: chunk size 524288 perslab     2</span><br></pre></td></tr></table></figure><br>可见，从128字节的组开始，组的大小依次增大为原来的2倍。 这样设置的问题是，slab之间的差别比较大，有些情况下就相当浪费内存。 因此，为尽量减少内存浪费，两年前追加了growth factor这个选项。</p>
<p>来看看现在的默认设置（f=1.25）时的输出（篇幅所限，这里只写到第10组）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">slab class   1: chunk size     88 perslab 11915</span><br><span class="line">slab class   2: chunk size    112 perslab  9362</span><br><span class="line">slab class   3: chunk size    144 perslab  7281</span><br><span class="line">slab class   4: chunk size    184 perslab  5698</span><br><span class="line">slab class   5: chunk size    232 perslab  4519</span><br><span class="line">slab class   6: chunk size    296 perslab  3542</span><br><span class="line">slab class   7: chunk size    376 perslab  2788</span><br><span class="line">slab class   8: chunk size    472 perslab  2221</span><br><span class="line">slab class   9: chunk size    592 perslab  1771</span><br><span class="line">slab class  10: chunk size    744 perslab  1409</span><br></pre></td></tr></table></figure><br>可见，组间差距比因子为2时小得多，更适合缓存几百字节的记录。 从上面的输出结果来看，可能会觉得有些计算误差， 这些误差是为了保持字节数的对齐而故意设置的。</p>
<p>将memcached引入产品，或是直接使用默认值进行部署时， 最好是重新计算一下数据的预期平均长度，调整growth factor， 以获得最恰当的设置。内存是珍贵的资源，浪费就太可惜了。</p>
<p>接下来介绍一下如何使用memcached的stats命令查看slabs的利用率等各种各样的信息。</p>
<h2 id="查看memcached的内部状态"><a href="#查看memcached的内部状态" class="headerlink" title="查看memcached的内部状态"></a>查看memcached的内部状态</h2><p>memcached有个名为stats的命令，使用它可以获得各种各样的信息。 执行命令的方法很多，用telnet最为简单：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ telnet 主机名 端口号</span><br></pre></td></tr></table></figure><br>连接到memcached之后，输入stats再按回车，即可获得包括资源利用率在内的各种信息。 此外，输入”stats slabs”或”stats items”还可以获得关于缓存记录的信息。 结束程序请输入quit。</p>
<p>这些命令的详细信息可以参考memcached软件包内的protocol.txt文档。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ telnet localhost 11211</span><br><span class="line">Trying ::1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &#x27;^]&#x27;.</span><br><span class="line">stats</span><br><span class="line">STAT pid 481</span><br><span class="line">STAT uptime 16574</span><br><span class="line">STAT time 1213687612</span><br><span class="line">STAT version 1.2.5</span><br><span class="line">STAT pointer_size 32</span><br><span class="line">STAT rusage_user 0.102297</span><br><span class="line">STAT rusage_system 0.214317</span><br><span class="line">STAT curr_items 0</span><br><span class="line">STAT total_items 0</span><br><span class="line">STAT bytes 0</span><br><span class="line">STAT curr_connections 6</span><br><span class="line">STAT total_connections 8</span><br><span class="line">STAT connection_structures 7</span><br><span class="line">STAT cmd_get 0</span><br><span class="line">STAT cmd_set 0</span><br><span class="line">STAT get_hits 0</span><br><span class="line">STAT get_misses 0</span><br><span class="line">STAT evictions 0</span><br><span class="line">STAT bytes_read 20</span><br><span class="line">STAT bytes_written 465</span><br><span class="line">STAT limit_maxbytes 67108864</span><br><span class="line">STAT threads 4</span><br><span class="line">END</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><br>另外，如果安装了libmemcached这个面向C/C++语言的客户端库，就会安装 memstat 这个命令。 使用方法很简单，可以用更少的步骤获得与telnet相同的信息，还能一次性从多台服务器获得信息。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ memstat --servers=server1,server2,server3,...</span><br></pre></td></tr></table></figure><br>libmemcached可以从下面的地址获得：<a href="http://tangent.org/552/libmemcached.html">http://tangent.org/552/libmemcached.html</a></p>
<h2 id="查看slabs的使用状况"><a href="#查看slabs的使用状况" class="headerlink" title="查看slabs的使用状况"></a>查看slabs的使用状况</h2><p>使用memcached的创造者Brad写的名为memcached-tool的Perl脚本，可以方便地获得slab的使用情况 （它将memcached的返回值整理成容易阅读的格式）。可以从下面的地址获得脚本：</p>
<p><a href="http://code.sixapart.com/svn/memcached/trunk/server/scripts/memcached-tool">http://code.sixapart.com/svn/memcached/trunk/server/scripts/memcached-tool</a><br>使用方法也极其简单：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ memcached-tool 主机名:端口 选项</span><br></pre></td></tr></table></figure><br>查看slabs使用状况时无需指定选项，因此用下面的命令即可：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ memcached-tool 主机名:端口</span><br></pre></td></tr></table></figure><br>获得的信息如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> ##  Item_Size   Max_age  1MB_pages Count   Full?</span><br><span class="line"> 1     104 B  1394292 s    1215 12249628    yes</span><br><span class="line"> 2     136 B  1456795 s      52  400919     yes</span><br><span class="line"> 3     176 B  1339587 s      33  196567     yes</span><br><span class="line"> 4     224 B  1360926 s     109  510221     yes</span><br><span class="line"> 5     280 B  1570071 s      49  183452     yes</span><br><span class="line"> 6     352 B  1592051 s      77  229197     yes</span><br><span class="line"> 7     440 B  1517732 s      66  157183     yes</span><br><span class="line"> 8     552 B  1460821 s      62  117697     yes</span><br><span class="line"> 9     696 B  1521917 s     143  215308     yes</span><br><span class="line">10     872 B  1695035 s     205  246162     yes</span><br><span class="line">11     1.1 kB 1681650 s     233  221968     yes</span><br><span class="line">12     1.3 kB 1603363 s     241  183621     yes</span><br><span class="line">13     1.7 kB 1634218 s      94   57197     yes</span><br><span class="line">14     2.1 kB 1695038 s      75   36488     yes</span><br><span class="line">15     2.6 kB 1747075 s      65   25203     yes</span><br><span class="line">16     3.3 kB 1760661 s      78   24167     yes</span><br></pre></td></tr></table></figure><br>各列的含义为：</p>
<ul>
<li>‘#’    slab class编号</li>
<li>Item_Size    Chunk大小</li>
<li>Max_age    LRU内最旧的记录的生存时间</li>
<li>1MB_pages    分配给Slab的页数</li>
<li>Count    Slab内的记录数</li>
<li>Full?    Slab内是否含有空闲chunk</li>
</ul>
<p>从这个脚本获得的信息对于调优非常方便，强烈推荐使用。</p>
<h2 id="memcached在数据删除方面有效利用资源"><a href="#memcached在数据删除方面有效利用资源" class="headerlink" title="memcached在数据删除方面有效利用资源"></a>memcached在数据删除方面有效利用资源</h2><p>数据不会真正从memcached中消失<br>上次介绍过， memcached不会释放已分配的内存。记录超时后，客户端就无法再看见该记录（invisible，透明）， 其存储空间即可重复使用。</p>
<h3 id="Lazy-Expiration"><a href="#Lazy-Expiration" class="headerlink" title="Lazy Expiration"></a>Lazy Expiration</h3><p>memcached内部不会监视记录是否过期，而是在get时查看记录的时间戳，检查记录是否过期。 这种技术被称为lazy（惰性）expiration。因此，memcached不会在过期监视上耗费CPU时间。</p>
<h2 id="LRU：从缓存中有效删除数据的原理"><a href="#LRU：从缓存中有效删除数据的原理" class="headerlink" title="LRU：从缓存中有效删除数据的原理"></a>LRU：从缓存中有效删除数据的原理</h2><p>memcached会优先使用已超时的记录的空间，但即使如此，也会发生追加新记录时空间不足的情况， 此时就要使用名为 Least Recently Used（LRU）机制来分配空间。 顾名思义，这是删除“最近最少使用”的记录的机制。 因此，当memcached的内存空间不足时（无法从slab class 获取到新的空间时），就从最近未被使用的记录中搜索，并将其空间分配给新的记录。 从缓存的实用角度来看，该模型十分理想。</p>
<p>不过，有些情况下LRU机制反倒会造成麻烦。memcached启动时通过“-M”参数可以禁止LRU，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ memcached -M -m 1024</span><br></pre></td></tr></table></figure>
<p>启动时必须注意的是，小写的“-m”选项是用来指定最大内存大小的。不指定具体数值则使用默认值64MB。</p>
<p>指定“-M”参数启动后，内存用尽时memcached会返回错误。 话说回来，memcached毕竟不是存储器，而是缓存，所以推荐使用LRU。</p>
<h2 id="memcached的最新发展方向"><a href="#memcached的最新发展方向" class="headerlink" title="memcached的最新发展方向"></a>memcached的最新发展方向</h2><p>memcached的roadmap上有两个大的目标。一个是二进制协议的策划和实现，另一个是外部引擎的加载功能。</p>
<h3 id="关于二进制协议"><a href="#关于二进制协议" class="headerlink" title="关于二进制协议"></a>关于二进制协议</h3><p>使用二进制协议的理由是它不需要文本协议的解析处理，使得原本高速的memcached的性能更上一层楼， 还能减少文本协议的漏洞。目前已大部分实现，开发用的代码库中已包含了该功能。 memcached的下载页面上有代码库的链接。</p>
<p><a href="http://danga.com/memcached/download.bml">http://danga.com/memcached/download.bml</a></p>
<h4 id="二进制协议的格式"><a href="#二进制协议的格式" class="headerlink" title="二进制协议的格式"></a>二进制协议的格式</h4><p>协议的包为24字节的帧，其后面是键和无结构数据（Unstructured Data）。 实际的格式如下（引自协议文档）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Byte/     0       |       1       |       2       |       3       |   </span><br><span class="line">   /              |               |               |               |   </span><br><span class="line">  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|</span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br><span class="line"> 0/ HEADER                                                        /   </span><br><span class="line">  /                                                               /   </span><br><span class="line">  /                                                               /   </span><br><span class="line">  /                                                               /   </span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br><span class="line">24/ COMMAND-SPECIFIC EXTRAS (as needed)                           /   </span><br><span class="line"> +/  (note length in th extras length header field)               /   </span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br><span class="line"> m/ Key (as needed)                                               /   </span><br><span class="line"> +/  (note length in key length header field)                     /   </span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br><span class="line"> n/ Value (as needed)                                             /   </span><br><span class="line"> +/  (note length is total body length header field, minus        /   </span><br><span class="line"> +/   sum of the extras and key length body fields)               /   </span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br><span class="line"> Total 24 bytes</span><br></pre></td></tr></table></figure><br>如上所示，包格式十分简单。需要注意的是，占据了16字节的头部(HEADER)分为 请求头（Request Header）和响应头（Response Header）两种。 头部中包含了表示包的有效性的Magic字节、命令种类、键长度、值长度等信息，格式如下：</p>
<p>Request Header<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Byte/     0       |       1       |       2       |       3       |</span><br><span class="line">   /              |               |               |               |</span><br><span class="line">  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|</span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br><span class="line"> 0| Magic         | Opcode        | Key length                    |</span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br><span class="line"> 4| Extras length | Data type     | Reserved                      |</span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br><span class="line"> 8| Total body length                                             |</span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br><span class="line">12| Opaque                                                        |</span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br><span class="line">16| CAS                                                           |</span><br><span class="line">  |                                                               |</span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br></pre></td></tr></table></figure><br>Response Header<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Byte/     0       |       1       |       2       |       3       |</span><br><span class="line">   /              |               |               |               |</span><br><span class="line">  |0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|</span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br><span class="line"> 0| Magic         | Opcode        | Key Length                    |</span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br><span class="line"> 4| Extras length | Data type     | Status                        |</span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br><span class="line"> 8| Total body length                                             |</span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br><span class="line">12| Opaque                                                        |</span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br><span class="line">16| CAS                                                           |</span><br><span class="line">  |                                                               |</span><br><span class="line">  +---------------+---------------+---------------+---------------+</span><br></pre></td></tr></table></figure><br>如希望了解各个部分的详细内容，可以checkout出memcached的二进制协议的代码树， 参考其中的docs文件夹中的protocol_binary.txt文档。</p>
<h4 id="HEADER中引人注目的地方"><a href="#HEADER中引人注目的地方" class="headerlink" title="HEADER中引人注目的地方"></a>HEADER中引人注目的地方</h4><p>看到HEADER格式后我的感想是，键的上限太大了！现在的memcached规格中，键长度最大为250字节， 但二进制协议中键的大小用2字节表示。因此，理论上最大可使用65536字节（216）长的键。 尽管250字节以上的键并不会太常用，二进制协议发布之后就可以使用巨大的键了。</p>
<p>二进制协议从下一版本1.3系列开始支持。</p>
<h3 id="外部引擎支持"><a href="#外部引擎支持" class="headerlink" title="外部引擎支持"></a>外部引擎支持</h3><p>我去年曾经试验性地将memcached的存储层改造成了可扩展的（pluggable）。</p>
<p><a href="http://alpha.mixi.co.jp/blog/?p=129">http://alpha.mixi.co.jp/blog/?p=129</a><br>MySQL的Brian Aker看到这个改造之后，就将代码发到了memcached的邮件列表。 memcached的开发者也十分感兴趣，就放到了roadmap中。现在由我和 memcached的开发者Trond Norbye协同开发（规格设计、实现和测试）。 和国外协同开发时时差是个大问题，但抱着相同的愿景， 最后终于可以将可扩展架构的原型公布了。 代码库可以从memcached的下载页面 上访问。</p>
<h4 id="外部引擎支持的必要性"><a href="#外部引擎支持的必要性" class="headerlink" title="外部引擎支持的必要性"></a>外部引擎支持的必要性</h4><p>世界上有许多memcached的派生软件，其理由是希望永久保存数据、实现数据冗余等， 即使牺牲一些性能也在所不惜。我在开发memcached之前，在mixi的研发部也曾经 考虑过重新发明memcached。</p>
<p>外部引擎的加载机制能封装memcached的网络功能、事件处理等复杂的处理。 因此，现阶段通过强制手段或重新设计等方式使memcached和存储引擎合作的困难 就会烟消云散，尝试各种引擎就会变得轻而易举了。</p>
<h4 id="简单API设计的成功的关键"><a href="#简单API设计的成功的关键" class="headerlink" title="简单API设计的成功的关键"></a>简单API设计的成功的关键</h4><p>该项目中我们最重视的是API设计。函数过多，会使引擎开发者感到麻烦； 过于复杂，实现引擎的门槛就会过高。因此，最初版本的接口函数只有13个。 具体内容限于篇幅，这里就省略了，仅说明一下引擎应当完成的操作：</p>
<ul>
<li>引擎信息（版本等）</li>
<li>引擎初始化</li>
<li>引擎关闭</li>
<li>引擎的统计信息</li>
<li>在容量方面，测试给定记录能否保存</li>
<li>为item（记录）结构分配内存</li>
<li>释放item（记录）的内存</li>
<li>删除记录</li>
<li>保存记录</li>
<li>回收记录</li>
<li>更新记录的时间戳</li>
<li>数学运算处理</li>
<li>数据的flush</li>
</ul>
<p>对详细规格有兴趣的读者，可以checkout engine项目的代码，阅读器中的engine.h。</p>
<h4 id="重新审视现在的体系"><a href="#重新审视现在的体系" class="headerlink" title="重新审视现在的体系"></a>重新审视现在的体系</h4><p>memcached支持外部存储的难点是，网络和事件处理相关的代码（核心服务器）与 内存存储的代码紧密关联。这种现象也称为tightly coupled（紧密耦合）。 必须将内存存储的代码从核心服务器中独立出来，才能灵活地支持外部引擎。 因此，基于我们设计的API，memcached被重构成下面的样子：<br><img src="/img/20191008006.png" alt=""></p>
<p>重构之后，我们与1.2.5版、二进制协议支持版等进行了性能对比，证实了它不会造成性能影响。</p>
<p>在考虑如何支持外部引擎加载时，让memcached进行并行控制（concurrency control）的方案是最为容易的， 但是对于引擎而言，并行控制正是性能的真谛，因此我们采用了将多线程支持完全交给引擎的设计方案。</p>
<h2 id="memcached的分布式"><a href="#memcached的分布式" class="headerlink" title="memcached的分布式"></a>memcached的分布式</h2><p>正如第1次中介绍的那样，memcached虽然称为“分布式”缓存服务器，但服务器端并没有“分布式”功能。 服务器端仅包括第2次、第3次前坂介绍的内存存储功能，其实现非常简单。至于memcached的分布式，则是完全由客户端程序库实现的。这种分布式是memcached的最大特点。</p>
<p>memcached的分布式是什么意思？<br>这里多次使用了“分布式”这个词，但并未做详细解释。 现在开始简单地介绍一下其原理，各个客户端的实现基本相同。</p>
<p>下面假设memcached服务器有node1～node3三台， 应用程序要保存键名为“tokyo”“kanagawa”“chiba”“saitama”“gunma” 的数据。<br><img src="/img/20191008007.png" alt="图1 分布式简介：准备"></p>
<p>首先向memcached中添加“tokyo”。将“tokyo”传给客户端程序库后， 客户端实现的算法就会根据“键”来决定保存数据的memcached服务器。 服务器选定后，即命令它保存“tokyo”及其值。</p>
<p><img src="/img/20191008008.png" alt="图2 分布式简介：添加时"></p>
<p>同样，“kanagawa”“chiba”“saitama”“gunma”都是先选择服务器再保存。</p>
<p>接下来获取保存的数据。获取时也要将要获取的键“tokyo”传递给函数库。 函数库通过与数据保存时相同的算法，根据“键”选择服务器。 使用的算法相同，就能选中与保存时相同的服务器，然后发送get命令。 只要数据没有因为某些原因被删除，就能获得保存的值。<br><img src="/img/20191008009.png" alt="图3 分布式简介：获取时"></p>
<p>这样，将不同的键保存到不同的服务器上，就实现了memcached的分布式。 memcached服务器增多后，键就会分散，即使一台memcached服务器发生故障 无法连接，也不会影响其他的缓存，系统依然能继续运行。</p>
<p>接下来介绍第1次中提到的Perl客户端函数库Cache::Memcached实现的分布式方法。</p>
<h2 id="Cache-Memcached的分布式方法"><a href="#Cache-Memcached的分布式方法" class="headerlink" title="Cache::Memcached的分布式方法"></a>Cache::Memcached的分布式方法</h2><p>Perl的memcached客户端函数库Cache::Memcached是 memcached的作者Brad Fitzpatrick的作品，可以说是原装的函数库了。</p>
<p>Cache::Memcached - search.cpan.org<br>该函数库实现了分布式功能，是memcached标准的分布式方法。</p>
<h3 id="根据余数计算分散"><a href="#根据余数计算分散" class="headerlink" title="根据余数计算分散"></a>根据余数计算分散</h3><p>Cache::Memcached的分布式方法简单来说，就是“根据服务器台数的余数进行分散”。 求得键的整数哈希值，再除以服务器台数，根据其余数来选择服务器。</p>
<p>下面将Cache::Memcached简化成以下的Perl脚本来进行说明。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line">use String::CRC32;</span><br><span class="line"></span><br><span class="line">my @nodes = (&#x27;node1&#x27;,&#x27;node2&#x27;,&#x27;node3&#x27;);</span><br><span class="line">my @keys = (&#x27;tokyo&#x27;, &#x27;kanagawa&#x27;, &#x27;chiba&#x27;, &#x27;saitama&#x27;, &#x27;gunma&#x27;);</span><br><span class="line"></span><br><span class="line">foreach my $key (@keys) &#123;</span><br><span class="line">    my $crc = crc32($key);             ## CRC値</span><br><span class="line">    my $mod = $crc % ( $#nodes + 1 );</span><br><span class="line">    my $server = $nodes[ $mod ];       ## 根据余数选择服务器</span><br><span class="line">    printf &quot;%s =&gt; %s\n&quot;, $key, $server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Cache::Memcached在求哈希值时使用了CRC。</p>
<p>String::CRC32 - search.cpan.org<br>首先求得字符串的CRC值，根据该值除以服务器节点数目得到的余数决定服务器。 上面的代码执行后输入以下结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tokyo       =&gt; node2</span><br><span class="line">kanagawa =&gt; node3</span><br><span class="line">chiba       =&gt; node2</span><br><span class="line">saitama   =&gt; node1</span><br><span class="line">gunma     =&gt; node1</span><br></pre></td></tr></table></figure></p>
<p>根据该结果，“tokyo”分散到node2，“kanagawa”分散到node3等。 多说一句，当选择的服务器无法连接时，Cache::Memcached会将连接次数 添加到键之后，再次计算哈希值并尝试连接。这个动作称为rehash。 不希望rehash时可以在生成Cache::Memcached对象时指定“rehash =&gt; 0”选项。</p>
<h3 id="根据余数计算分散的缺点"><a href="#根据余数计算分散的缺点" class="headerlink" title="根据余数计算分散的缺点"></a>根据余数计算分散的缺点</h3><p>余数计算的方法简单，数据的分散性也相当优秀，但也有其缺点。 那就是当添加或移除服务器时，缓存重组的代价相当巨大。 添加服务器后，余数就会产生巨变，这样就无法获取与保存时相同的服务器， 从而影响缓存的命中率。用Perl写段代码来验证其代价。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">use strict;</span><br><span class="line">use warnings;</span><br><span class="line">use String::CRC32;</span><br><span class="line"></span><br><span class="line">my @nodes = @ARGV;</span><br><span class="line">my @keys = (&#x27;a&#x27;..&#x27;z&#x27;);</span><br><span class="line">my %nodes;</span><br><span class="line"></span><br><span class="line">foreach my $key ( @keys ) &#123;</span><br><span class="line">    my $hash = crc32($key);</span><br><span class="line">    my $mod = $hash % ( $#nodes + 1 );</span><br><span class="line">    my $server = $nodes[ $mod ];</span><br><span class="line">    push @&#123; $nodes&#123; $server &#125; &#125;, $key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach my $node ( sort keys %nodes ) &#123;</span><br><span class="line">    printf &quot;%s: %s\n&quot;, $node,  join &quot;,&quot;, @&#123; $nodes&#123;$node&#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段Perl脚本演示了将“a”到“z”的键保存到memcached并访问的情况。 将其保存为mod.pl并执行。</p>
<p>首先，当服务器只有三台时：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mod.pl node1 node2 nod3</span><br><span class="line">node1: a,c,d,e,h,j,n,u,w,x</span><br><span class="line">node2: g,i,k,l,p,r,s,y</span><br><span class="line">node3: b,f,m,o,q,t,v,z</span><br></pre></td></tr></table></figure></p>
<p>结果如上，node1保存a、c、d、e……，node2保存g、i、k……， 每台服务器都保存了8个到10个数据。</p>
<p>接下来增加一台memcached服务器。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mod.pl node1 node2 node3 node4</span><br><span class="line">node1: d,f,m,o,t,v</span><br><span class="line">node2: b,i,k,p,r,y</span><br><span class="line">node3: e,g,l,n,u,w</span><br><span class="line">node4: a,c,h,j,q,s,x,z</span><br></pre></td></tr></table></figure></p>
<p>添加了node4。可见，只有d、i、k、p、r、y命中了。像这样，添加节点后 键分散到的服务器会发生巨大变化。26个键中只有六个在访问原来的服务器， 其他的全都移到了其他服务器。命中率降低到23%。在Web应用程序中使用memcached时， 在添加memcached服务器的瞬间缓存效率会大幅度下降，负载会集中到数据库服务器上， 有可能会发生无法提供正常服务的情况。</p>
<p>mixi的Web应用程序运用中也有这个问题，导致无法添加memcached服务器。 但由于使用了新的分布式方法，现在可以轻而易举地添加memcached服务器了。 这种分布式方法称为 Consistent Hashing。</p>
<h2 id="Consistent-Hashing"><a href="#Consistent-Hashing" class="headerlink" title="Consistent Hashing"></a>Consistent Hashing</h2><h3 id="Consistent-Hashing的简单说明"><a href="#Consistent-Hashing的简单说明" class="headerlink" title="Consistent Hashing的简单说明"></a>Consistent Hashing的简单说明</h3><p>Consistent Hashing如下所示：首先求出memcached服务器（节点）的哈希值， 并将其配置到0～2SUP(32)的圆（continuum）上。 然后用同样的方法求出存储数据的键的哈希值，并映射到圆上。 然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。 如果超过2SUP(32)仍然找不到服务器，就会保存到第一台memcached服务器上。</p>
<p><img src="/img/20191008010.png" alt="图4 Consistent Hashing：基本原理"></p>
<p>从上图的状态中添加一台memcached服务器。余数分布式算法由于保存键的服务器会发生巨大变化 而影响缓存的命中率，但Consistent Hashing中，只有在continuum上增加服务器的地点逆时针方向的 第一台服务器上的键会受到影响。</p>
<p><img src="/img/20191008011.png" alt="图5 Consistent Hashing：添加服务器"></p>
<p>因此，Consistent Hashing最大限度地抑制了键的重新分布。 而且，有的Consistent Hashing的实现方法还采用了虚拟节点的思想。 使用一般的hash函数的话，服务器的映射地点的分布非常不均匀。 因此，使用虚拟节点的思想，为每个物理节点（服务器） 在continuum上分配100～200个点。这样就能抑制分布不均匀， 最大限度地减小服务器增减时的缓存重新分布。</p>
<p>通过下文中介绍的使用Consistent Hashing算法的memcached客户端函数库进行测试的结果是， 由服务器台数（n）和增加的服务器台数（m）计算增加服务器后的命中率计算公式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 - n/(n+m)) * 100</span><br></pre></td></tr></table></figure></p>
<h3 id="支持Consistent-Hashing的函数库"><a href="#支持Consistent-Hashing的函数库" class="headerlink" title="支持Consistent Hashing的函数库"></a>支持Consistent Hashing的函数库</h3><p>本连载中多次介绍的Cache::Memcached虽然不支持Consistent Hashing， 但已有几个客户端函数库支持了这种新的分布式算法。 第一个支持Consistent Hashing和虚拟节点的memcached客户端函数库是 名为libketama的PHP库，由last.fm开发。<br>至于Perl客户端，连载的第1次中介绍过的Cache::Memcached::Fast和Cache::Memcached::libmemcached支持 Consistent Hashing。</p>
<p>两者的接口都与Cache::Memcached几乎相同，如果正在使用Cache::Memcached， 那么就可以方便地替换过来。Cache::Memcached::Fast重新实现了libketama， 使用Consistent Hashing创建对象时可以指定ketama_points选项。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my $memcached = Cache::Memcached::Fast-&gt;new(&#123;</span><br><span class="line">    servers =&gt; [&quot;192.168.0.1:11211&quot;,&quot;192.168.0.2:11211&quot;],</span><br><span class="line">    ketama_points =&gt; 150</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>另外，Cache::Memcached::libmemcached 是一个使用了Brain Aker开发的C函数库libmemcached的Perl模块。 libmemcached本身支持几种分布式算法，也支持Consistent Hashing， 其Perl绑定也支持Consistent Hashing。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%A7%AF%E7%B4%AF/" rel="tag"># 积累</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/12/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/" rel="prev" title="机器学习中的高性能计算">
      <i class="fa fa-chevron-left"></i> 机器学习中的高性能计算
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/01/04/HIP%E7%BC%96%E7%A8%8B/" rel="next" title="HIP编程">
      HIP编程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#TAU"><span class="nav-number">1.</span> <span class="nav-text">TAU</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">1.1.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#interposition"><span class="nav-number">1.2.1.</span> <span class="nav-text">interposition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#recompile"><span class="nav-number">1.2.2.</span> <span class="nav-text">recompile</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">测试过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%8F%92%E6%A1%A9%EF%BC%88Dynamic-instrumentation%EF%BC%89"><span class="nav-number">1.3.1.</span> <span class="nav-text">动态插桩（Dynamic instrumentation）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E6%8F%92%E6%A1%A9%EF%BC%88Source-instrumentation%EF%BC%89"><span class="nav-number">1.3.2.</span> <span class="nav-text">源码插桩（Source instrumentation）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E6%8F%92%E6%A1%A9%EF%BC%88Compiler-based-instrumentation%EF%BC%89%E5%92%8C%E5%8F%AF%E9%80%89%E6%8B%A9%E4%BB%A3%E7%A0%81%E5%8C%BA%E5%9F%9F%E7%9A%84%E6%8F%92%E6%A1%A9%EF%BC%88Selective-instrumentation"><span class="nav-number">1.3.3.</span> <span class="nav-text">基于编译器的插桩（Compiler-based instrumentation）和可选择代码区域的插桩（Selective instrumentation</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GDB"><span class="nav-number">2.</span> <span class="nav-text">GDB</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.1.</span> <span class="nav-text">调试原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attach%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.1.2.</span> <span class="nav-text">attach运行的进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AD%E7%82%B9%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.3.</span> <span class="nav-text">断点原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">设置原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%B8%AD%E5%88%A4%E6%96%AD"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">命中判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">条件判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.3.5.</span> <span class="nav-text">单步原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.1.4.</span> <span class="nav-text">测试程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86-1"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">调试原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">调试过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GDB%E8%B0%83%E8%AF%95%E7%B2%BE%E7%B2%B9"><span class="nav-number">2.2.</span> <span class="nav-text">GDB调试精粹</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%88%97%E6%96%87%E4%BB%B6%E6%B8%85%E5%8D%95"><span class="nav-number">2.2.1.</span> <span class="nav-text">一、列文件清单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.2.2.</span> <span class="nav-text">二、执行程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE"><span class="nav-number">2.2.3.</span> <span class="nav-text">三、显示数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E8%AE%BE%E7%BD%AE%E4%B8%8E%E6%B8%85%E9%99%A4%E6%96%AD%E7%82%B9"><span class="nav-number">2.2.4.</span> <span class="nav-text">四、设置与清除断点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%96%AD%E7%82%B9%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">2.2.5.</span> <span class="nav-text">五、断点的管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%8D%95%E6%AD%A5%E6%89%A7%E8%A1%8C"><span class="nav-number">2.2.6.</span> <span class="nav-text">六、单步执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">2.2.7.</span> <span class="nav-text">七、函数的调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB%E3%80%81-%E5%8E%9F%E6%96%87%E4%BB%B6%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="nav-number">2.2.8.</span> <span class="nav-text">八、 原文件的搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E6%9F%A5%E7%9C%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE"><span class="nav-number">2.2.9.</span> <span class="nav-text">九、查看运行时数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text">多进程、多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.3.1.</span> <span class="nav-text">多进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#attach"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">attach</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">指定进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.3.2.</span> <span class="nav-text">多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A1%AE%E5%AE%9A"><span class="nav-number">2.4.</span> <span class="nav-text">动态链接库中函数的地址确定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E4%BD%BF%E7%94%A8-perf"><span class="nav-number">2.4.1.</span> <span class="nav-text">准备使用 perf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#perf-%E2%80%94help"><span class="nav-number">2.4.2.</span> <span class="nav-text">perf —help</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Perf-list%EF%BC%8Cperf-%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.4.3.</span> <span class="nav-text">Perf list，perf 事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Perf-stat"><span class="nav-number">2.4.4.</span> <span class="nav-text">Perf stat</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#perf-top"><span class="nav-number">2.4.5.</span> <span class="nav-text">perf  top</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-perf-record-%E8%A7%A3%E8%AF%BB-report"><span class="nav-number">2.5.</span> <span class="nav-text">使用 perf record, 解读 report</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Perf-Script"><span class="nav-number">2.6.</span> <span class="nav-text">Perf Script</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-PMU-%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">2.7.</span> <span class="nav-text">使用 PMU 的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%86%85%E6%A0%B8%E8%B0%83%E4%BC%98%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.8.</span> <span class="nav-text">特殊用法以及内核调优示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-tracepoint"><span class="nav-number">2.8.1.</span> <span class="nav-text">使用 tracepoint</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Perf-probe"><span class="nav-number">2.8.2.</span> <span class="nav-text">Perf probe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Perf-sched"><span class="nav-number">2.8.3.</span> <span class="nav-text">Perf sched</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#perf-bench"><span class="nav-number">2.8.4.</span> <span class="nav-text">perf bench</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#perf-lock"><span class="nav-number">2.8.5.</span> <span class="nav-text">perf lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#perf-tracepoint"><span class="nav-number">2.8.6.</span> <span class="nav-text">perf tracepoint</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#perf-Kmem"><span class="nav-number">2.8.7.</span> <span class="nav-text">perf Kmem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Perf-timechart"><span class="nav-number">2.8.8.</span> <span class="nav-text">Perf timechart</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%98%E5%88%B6perf%E7%81%AB%E7%84%B0%E5%9B%BE"><span class="nav-number">2.8.9.</span> <span class="nav-text">绘制perf火焰图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%98%E5%88%B6perf%E7%83%AD%E5%8A%9B%E5%9B%BE"><span class="nav-number">2.8.10.</span> <span class="nav-text">绘制perf热力图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Script-%E5%A2%9E%E5%BC%BA-perf-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">2.9.</span> <span class="nav-text">使用 Script 增强 perf 的功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%87%E5%88%B0%E7%9A%84%E5%85%B6%E5%AE%83%E9%97%AE%E9%A2%98"><span class="nav-number">2.10.</span> <span class="nav-text">遇到的其它问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#qsub%E6%95%99%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">qsub教程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9EPBS%E4%B8%8Bmpi%E8%AE%A1%E7%AE%97"><span class="nav-number">3.1.</span> <span class="nav-text">非PBS下mpi计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PBS%E4%BD%9C%E4%B8%9A%E6%8F%90%E4%BA%A4"><span class="nav-number">3.2.</span> <span class="nav-text">PBS作业提交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E4%BD%9C%E4%B8%9A%E7%8A%B6%E6%80%81"><span class="nav-number">3.3.</span> <span class="nav-text">查看作业状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E4%BD%9C%E4%B8%9A"><span class="nav-number">3.4.</span> <span class="nav-text">删除作业</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E4%BD%9C%E4%B8%9A"><span class="nav-number">3.5.</span> <span class="nav-text">管理作业</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.</span> <span class="nav-text">脚本的正确使用方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tmux%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98"><span class="nav-number">4.</span> <span class="nav-text">tmux使用备忘</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">4.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="nav-number">4.2.</span> <span class="nav-text">快捷键</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E6%8D%A2pane"><span class="nav-number">4.2.1.</span> <span class="nav-text">切换pane</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%ADpane"><span class="nav-number">4.2.2.</span> <span class="nav-text">关闭pane</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tmux-window%E4%B8%AD%E7%9A%84%E5%8E%86%E5%8F%B2%E8%BE%93%E5%87%BA%E6%9F%A5%E7%9C%8B"><span class="nav-number">4.3.</span> <span class="nav-text">tmux window中的历史输出查看</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8mpiP%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90AMG%E7%A8%8B%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">使用mpiP工具分析AMG程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BDmpiP"><span class="nav-number">5.1.</span> <span class="nav-text">下载mpiP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85libunwind"><span class="nav-number">5.2.</span> <span class="nav-text">安装libunwind</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AMG%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">5.3.</span> <span class="nav-text">AMG编译和运行过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mpiP%E5%AF%B9AMG%E7%9A%84%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C"><span class="nav-number">5.4.</span> <span class="nav-text">mpiP对AMG的分析结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C%E7%9A%84%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E5%92%8C%E7%90%86%E8%A7%A3"><span class="nav-number">5.5.</span> <span class="nav-text">分析结果的简单分析和理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">5.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Git%E7%9A%84%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7"><span class="nav-number">6.</span> <span class="nav-text">Git的奇技淫巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%80%E5%8D%B7%E5%BF%85%E8%AF%BB"><span class="nav-number">6.1.</span> <span class="nav-text">开卷必读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF"><span class="nav-number">6.2.</span> <span class="nav-text">展示帮助信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">6.3.</span> <span class="nav-text">回到远程仓库的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%AE%BE%E7%AC%AC%E4%B8%80%E4%B8%AA-commit"><span class="nav-number">6.4.</span> <span class="nav-text">重设第一个 commit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">6.5.</span> <span class="nav-text">展示工作区和暂存区的不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E6%9A%82%E5%AD%98%E5%8C%BA%E5%92%8C%E6%9C%80%E8%BF%91%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">6.6.</span> <span class="nav-text">展示暂存区和最近版本的不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E6%9A%82%E5%AD%98%E5%8C%BA%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9C%80%E8%BF%91%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">6.7.</span> <span class="nav-text">展示暂存区、工作区和最近版本的不同</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E5%88%B0%E4%B8%8A%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF"><span class="nav-number">6.8.</span> <span class="nav-text">快速切换到上一个分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%B7%B2%E7%BB%8F%E5%90%88%E5%B9%B6%E5%88%B0-master-%E7%9A%84%E5%88%86%E6%94%AF"><span class="nav-number">6.9.</span> <span class="nav-text">删除已经合并到 master 的分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">6.10.</span> <span class="nav-text">展示本地分支关联远程仓库的情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">6.11.</span> <span class="nav-text">关联远程分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">6.12.</span> <span class="nav-text">列出所有远程分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E5%87%BA%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">6.13.</span> <span class="nav-text">列出本地和远程分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%88%87%E6%8D%A2%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="nav-number">6.14.</span> <span class="nav-text">创建并切换到本地分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%88%87%E6%8D%A2%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="nav-number">6.15.</span> <span class="nav-text">从远程分支中创建并切换到本地分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="nav-number">6.16.</span> <span class="nav-text">删除本地分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF"><span class="nav-number">6.17.</span> <span class="nav-text">删除远程分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="nav-number">6.18.</span> <span class="nav-text">重命名本地分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%A0%87%E7%AD%BE"><span class="nav-number">6.19.</span> <span class="nav-text">查看标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%A0%87%E7%AD%BE%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF"><span class="nav-number">6.20.</span> <span class="nav-text">查看标签详细信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE"><span class="nav-number">6.21.</span> <span class="nav-text">本地创建标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A8%E9%80%81%E6%A0%87%E7%AD%BE%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">6.22.</span> <span class="nav-text">推送标签到远程仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E6%A0%87%E7%AD%BE"><span class="nav-number">6.23.</span> <span class="nav-text">删除本地标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E6%A0%87%E7%AD%BE"><span class="nav-number">6.24.</span> <span class="nav-text">删除远程标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E5%9B%9E%E5%88%B0%E6%9F%90%E4%B8%AA%E6%A0%87%E7%AD%BE"><span class="nav-number">6.25.</span> <span class="nav-text">切回到某个标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%BE%E5%BC%83%E5%B7%A5%E4%BD%9C%E5%8C%BA%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">6.26.</span> <span class="nav-text">放弃工作区的修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E5%88%A0%E9%99%A4%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">6.27.</span> <span class="nav-text">恢复删除的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A5%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AA-commit-%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%98%E5%8E%9F%E6%9F%90%E4%B8%80%E4%B8%AA-commit-%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">6.28.</span> <span class="nav-text">以新增一个 commit 的方式还原某一个 commit 的修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E5%88%B0%E6%9F%90%E4%B8%AA-commit-%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%8C%E5%B9%B6%E5%88%A0%E9%99%A4%E5%90%8E%E9%9D%A2%E7%9A%84-commit"><span class="nav-number">6.29.</span> <span class="nav-text">回到某个 commit 的状态，并删除后面的 commit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E4%B8%8A%E4%B8%80%E4%B8%AA-commit-%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-number">6.30.</span> <span class="nav-text">修改上一个 commit 的描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B-commit-%E5%8E%86%E5%8F%B2"><span class="nav-number">6.31.</span> <span class="nav-text">查看 commit 历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E6%AE%B5%E4%BB%A3%E7%A0%81%E6%98%AF%E8%B0%81%E5%86%99%E7%9A%84"><span class="nav-number">6.32.</span> <span class="nav-text">查看某段代码是谁写的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E6%9C%AC%E5%9C%B0%E6%9B%B4%E6%96%B0%E8%BF%87-HEAD-%E7%9A%84-git-%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95"><span class="nav-number">6.33.</span> <span class="nav-text">显示本地更新过 HEAD 的 git 命令记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E4%BD%9C%E8%80%85%E5%90%8D"><span class="nav-number">6.34.</span> <span class="nav-text">修改作者名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84-url"><span class="nav-number">6.35.</span> <span class="nav-text">修改远程仓库的 url</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">6.36.</span> <span class="nav-text">增加远程仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93"><span class="nav-number">6.37.</span> <span class="nav-text">列出所有远程仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E4%B8%A4%E4%B8%AA%E6%98%9F%E6%9C%9F%E5%86%85%E7%9A%84%E6%94%B9%E5%8A%A8"><span class="nav-number">6.38.</span> <span class="nav-text">查看两个星期内的改动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8A-A-%E5%88%86%E6%94%AF%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AA-commit%EF%BC%8C%E6%94%BE%E5%88%B0-B-%E5%88%86%E6%94%AF%E4%B8%8A"><span class="nav-number">6.39.</span> <span class="nav-text">把 A 分支的某一个 commit，放到 B 分支上</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%99-git-%E5%91%BD%E4%BB%A4%E8%B5%B7%E5%88%AB%E5%90%8D"><span class="nav-number">6.40.</span> <span class="nav-text">给 git 命令起别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BD%93%E5%89%8D%E7%9A%84%E4%BF%AE%E6%94%B9%EF%BC%8C%E4%BD%86%E4%B8%8D%E7%94%A8%E6%8F%90%E4%BA%A4-commit"><span class="nav-number">6.41.</span> <span class="nav-text">存储当前的修改，但不用提交 commit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E5%BD%93%E5%89%8D%E7%8A%B6%E6%80%81%EF%BC%8C%E5%8C%85%E6%8B%AC-untracked-%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">6.42.</span> <span class="nav-text">保存当前状态，包括 untracked 的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89-stashes"><span class="nav-number">6.43.</span> <span class="nav-text">展示所有 stashes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E5%88%B0%E6%9F%90%E4%B8%AA-stash-%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">6.44.</span> <span class="nav-text">回到某个 stash 的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E5%88%B0%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA-stash-%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%8C%E5%B9%B6%E5%88%A0%E9%99%A4%E8%BF%99%E4%B8%AA-stash"><span class="nav-number">6.45.</span> <span class="nav-text">回到最后一个 stash 的状态，并删除这个 stash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E7%9A%84-stash"><span class="nav-number">6.46.</span> <span class="nav-text">删除所有的 stash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E-stash-%E4%B8%AD%E6%8B%BF%E5%87%BA%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">6.47.</span> <span class="nav-text">从 stash 中拿出某个文件的修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89-tracked-%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">6.48.</span> <span class="nav-text">展示所有 tracked 的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89-untracked-%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">6.49.</span> <span class="nav-text">展示所有 untracked 的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89%E5%BF%BD%E7%95%A5%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">6.50.</span> <span class="nav-text">展示所有忽略的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4-untracked-%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">6.51.</span> <span class="nav-text">强制删除 untracked 的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4-untracked-%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="nav-number">6.52.</span> <span class="nav-text">强制删除 untracked 的目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E7%AE%80%E5%8C%96%E7%9A%84-commit-%E5%8E%86%E5%8F%B2"><span class="nav-number">6.53.</span> <span class="nav-text">展示简化的 commit 历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8A%E6%9F%90%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF%E5%88%B0%E5%AF%BC%E5%87%BA%E6%88%90%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-number">6.54.</span> <span class="nav-text">把某一个分支到导出成一个文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%8C%85%E4%B8%AD%E5%AF%BC%E5%85%A5%E5%88%86%E6%94%AF"><span class="nav-number">6.55.</span> <span class="nav-text">从包中导入分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C-rebase-%E4%B9%8B%E5%89%8D%E8%87%AA%E5%8A%A8-stash"><span class="nav-number">6.56.</span> <span class="nav-text">执行 rebase 之前自动 stash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%A0%B9%E6%8D%AE-ID%EF%BC%8C%E6%8B%89%E4%B8%8B%E6%9F%90%E4%B8%80%E7%8A%B6%E6%80%81%EF%BC%8C%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF"><span class="nav-number">6.57.</span> <span class="nav-text">从远程仓库根据 ID，拉下某一状态，到本地分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E5%B1%95%E7%A4%BA%E4%B8%80%E8%A1%8C%E4%B8%AD%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">6.58.</span> <span class="nav-text">详细展示一行中的修改</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%85%E9%99%A4-gitignore-%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AE%B0%E5%BD%95%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">6.59.</span> <span class="nav-text">清除 gitignore 文件中记录的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89-alias-%E5%92%8C-configs"><span class="nav-number">6.60.</span> <span class="nav-text">展示所有 alias 和 configs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E5%BF%BD%E7%95%A5%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">6.61.</span> <span class="nav-text">展示忽略的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#commit-%E5%8E%86%E5%8F%B2%E4%B8%AD%E6%98%BE%E7%A4%BA-Branch1-%E6%9C%89%E7%9A%84%EF%BC%8C%E4%BD%86%E6%98%AF-Branch2-%E6%B2%A1%E6%9C%89-commit"><span class="nav-number">6.62.</span> <span class="nav-text">commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-commit-log-%E4%B8%AD%E6%98%BE%E7%A4%BA-GPG-%E7%AD%BE%E5%90%8D"><span class="nav-number">6.63.</span> <span class="nav-text">在 commit log 中显示 GPG 签名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE"><span class="nav-number">6.64.</span> <span class="nav-text">删除全局设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%88%87%E6%8D%A2%E5%88%B0%E6%96%B0%E5%88%86%E6%94%AF%E4%B8%8A%EF%BC%8C%E5%90%8C%E6%97%B6%E8%BF%99%E4%B8%AA%E5%88%86%E6%94%AF%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95-commit"><span class="nav-number">6.65.</span> <span class="nav-text">新建并切换到新分支上，同时这个分支没有任何 commit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E4%BB%BB%E6%84%8F%E5%88%86%E6%94%AF%E6%9F%90%E4%B8%80%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">6.66.</span> <span class="nav-text">展示任意分支某一文件的内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clone-%E4%B8%8B%E6%9D%A5%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8D%95%E4%B8%80%E5%88%86%E6%94%AF"><span class="nav-number">6.67.</span> <span class="nav-text">clone 下来指定的单一分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%BD%E7%95%A5%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E6%94%B9%E5%8A%A8"><span class="nav-number">6.68.</span> <span class="nav-text">忽略某个文件的改动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90%E5%8F%98%E5%8C%96"><span class="nav-number">6.69.</span> <span class="nav-text">忽略文件的权限变化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A5%E6%9C%80%E5%90%8E%E6%8F%90%E4%BA%A4%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89-Git-%E5%88%86%E6%94%AF"><span class="nav-number">6.70.</span> <span class="nav-text">以最后提交的顺序列出所有 Git 分支</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-commit-log-%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9"><span class="nav-number">6.71.</span> <span class="nav-text">在 commit log 中查找相关内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8A%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E6%8C%87%E5%AE%9A-file-%E6%94%BE%E5%88%B0%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%B8%AD"><span class="nav-number">6.72.</span> <span class="nav-text">把暂存区的指定 file 放到工作区中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E6%8E%A8%E9%80%81"><span class="nav-number">6.73.</span> <span class="nav-text">强制推送</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E5%9B%BE%E8%AF%A6%E8%A7%A3"><span class="nav-number">6.74.</span> <span class="nav-text">一图详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E9%9B%85%E7%9A%84%E6%8F%90%E4%BA%A4Commit%E4%BF%A1%E6%81%AF"><span class="nav-number">6.75.</span> <span class="nav-text">优雅的提交Commit信息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#memcached%E5%AE%8C%E5%85%A8%E5%89%96%E6%9E%90"><span class="nav-number">7.</span> <span class="nav-text">memcached完全剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#memcached%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">7.1.</span> <span class="nav-text">memcached是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memcached%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">7.2.</span> <span class="nav-text">memcached的特征</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E7%AE%80%E5%8D%95"><span class="nav-number">7.2.1.</span> <span class="nav-text">协议简单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Elibevent%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">7.2.2.</span> <span class="nav-text">基于libevent的事件处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">7.2.3.</span> <span class="nav-text">内置内存存储方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memcached%E4%B8%8D%E4%BA%92%E7%9B%B8%E9%80%9A%E4%BF%A1%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F"><span class="nav-number">7.2.4.</span> <span class="nav-text">memcached不互相通信的分布式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memcached%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-number">7.2.5.</span> <span class="nav-text">memcached的安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memcached%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="nav-number">7.2.6.</span> <span class="nav-text">memcached的启动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Cache-Memcached"><span class="nav-number">7.3.</span> <span class="nav-text">使用Cache::Memcached</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Cache-Memcached%E8%BF%9E%E6%8E%A5memcached"><span class="nav-number">7.3.1.</span> <span class="nav-text">使用Cache::Memcached连接memcached</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="nav-number">7.3.2.</span> <span class="nav-text">保存数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="nav-number">7.3.3.</span> <span class="nav-text">获取数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">7.3.4.</span> <span class="nav-text">删除数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E4%B8%80%E5%92%8C%E5%87%8F%E4%B8%80%E6%93%8D%E4%BD%9C"><span class="nav-number">7.3.5.</span> <span class="nav-text">增一和减一操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Slab-Allocation%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%95%B4%E7%90%86%E5%86%85%E5%AD%98%E4%BB%A5%E4%BE%BF%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8"><span class="nav-number">7.3.6.</span> <span class="nav-text">Slab Allocation机制：整理内存以便重复使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Slab-Allocation%E7%9A%84%E4%B8%BB%E8%A6%81%E6%9C%AF%E8%AF%AD"><span class="nav-number">7.3.7.</span> <span class="nav-text">Slab Allocation的主要术语</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Page"><span class="nav-number">7.3.7.1.</span> <span class="nav-text">Page</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Chunk"><span class="nav-number">7.3.7.2.</span> <span class="nav-text">Chunk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Slab-Class"><span class="nav-number">7.3.7.3.</span> <span class="nav-text">Slab Class</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8Slab%E4%B8%AD%E7%BC%93%E5%AD%98%E8%AE%B0%E5%BD%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">7.4.</span> <span class="nav-text">在Slab中缓存记录的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slab-Allocator%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">7.5.</span> <span class="nav-text">Slab Allocator的缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Growth-Factor%E8%BF%9B%E8%A1%8C%E8%B0%83%E4%BC%98"><span class="nav-number">7.6.</span> <span class="nav-text">使用Growth Factor进行调优</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8Bmemcached%E7%9A%84%E5%86%85%E9%83%A8%E7%8A%B6%E6%80%81"><span class="nav-number">7.7.</span> <span class="nav-text">查看memcached的内部状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8Bslabs%E7%9A%84%E4%BD%BF%E7%94%A8%E7%8A%B6%E5%86%B5"><span class="nav-number">7.8.</span> <span class="nav-text">查看slabs的使用状况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memcached%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4%E6%96%B9%E9%9D%A2%E6%9C%89%E6%95%88%E5%88%A9%E7%94%A8%E8%B5%84%E6%BA%90"><span class="nav-number">7.9.</span> <span class="nav-text">memcached在数据删除方面有效利用资源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lazy-Expiration"><span class="nav-number">7.9.1.</span> <span class="nav-text">Lazy Expiration</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LRU%EF%BC%9A%E4%BB%8E%E7%BC%93%E5%AD%98%E4%B8%AD%E6%9C%89%E6%95%88%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">7.10.</span> <span class="nav-text">LRU：从缓存中有效删除数据的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memcached%E7%9A%84%E6%9C%80%E6%96%B0%E5%8F%91%E5%B1%95%E6%96%B9%E5%90%91"><span class="nav-number">7.11.</span> <span class="nav-text">memcached的最新发展方向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%8F%E8%AE%AE"><span class="nav-number">7.11.1.</span> <span class="nav-text">关于二进制协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">7.11.1.1.</span> <span class="nav-text">二进制协议的格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HEADER%E4%B8%AD%E5%BC%95%E4%BA%BA%E6%B3%A8%E7%9B%AE%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-number">7.11.1.2.</span> <span class="nav-text">HEADER中引人注目的地方</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%BC%95%E6%93%8E%E6%94%AF%E6%8C%81"><span class="nav-number">7.11.2.</span> <span class="nav-text">外部引擎支持</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%BC%95%E6%93%8E%E6%94%AF%E6%8C%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="nav-number">7.11.2.1.</span> <span class="nav-text">外部引擎支持的必要性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95API%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%88%90%E5%8A%9F%E7%9A%84%E5%85%B3%E9%94%AE"><span class="nav-number">7.11.2.2.</span> <span class="nav-text">简单API设计的成功的关键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86%E7%8E%B0%E5%9C%A8%E7%9A%84%E4%BD%93%E7%B3%BB"><span class="nav-number">7.11.2.3.</span> <span class="nav-text">重新审视现在的体系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memcached%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F"><span class="nav-number">7.12.</span> <span class="nav-text">memcached的分布式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cache-Memcached%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%B9%E6%B3%95"><span class="nav-number">7.13.</span> <span class="nav-text">Cache::Memcached的分布式方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E4%BD%99%E6%95%B0%E8%AE%A1%E7%AE%97%E5%88%86%E6%95%A3"><span class="nav-number">7.13.1.</span> <span class="nav-text">根据余数计算分散</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E4%BD%99%E6%95%B0%E8%AE%A1%E7%AE%97%E5%88%86%E6%95%A3%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">7.13.2.</span> <span class="nav-text">根据余数计算分散的缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Consistent-Hashing"><span class="nav-number">7.14.</span> <span class="nav-text">Consistent Hashing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Consistent-Hashing%E7%9A%84%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E"><span class="nav-number">7.14.1.</span> <span class="nav-text">Consistent Hashing的简单说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81Consistent-Hashing%E7%9A%84%E5%87%BD%E6%95%B0%E5%BA%93"><span class="nav-number">7.14.2.</span> <span class="nav-text">支持Consistent Hashing的函数库</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
