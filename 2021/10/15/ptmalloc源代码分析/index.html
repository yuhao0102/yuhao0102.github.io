<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="基础知识X86平台Linux进程内存布局Linux系统在装载elf格式的程序文件时，会调用loader把可执行文件中的各个段依次载入到从某一地址开始的空间中（载入地址取决link editor(ld)和机器地址位数，在32位机器上是0x8048000，即128M处）。如下图所示，以32位机器为例，首先被载入的是.text段，然后是.data段，最后是.bss段。这可以看作是程序的开始空间。程序所能">
<meta property="og:type" content="article">
<meta property="og:title" content="glibc内存管理ptmalloc源代码分析1">
<meta property="og:url" content="http://yoursite.com/2021/10/15/ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="基础知识X86平台Linux进程内存布局Linux系统在装载elf格式的程序文件时，会调用loader把可执行文件中的各个段依次载入到从某一地址开始的空间中（载入地址取决link editor(ld)和机器地址位数，在32位机器上是0x8048000，即128M处）。如下图所示，以32位机器为例，首先被载入的是.text段，然后是.data段，最后是.bss段。这可以看作是程序的开始空间。程序所能">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/1634291202.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634291292.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634291332.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634304883.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634304988.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634306475.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634402543.jpg">
<meta property="og:image" content="http://yoursite.com/img/1634435791.jpg">
<meta property="article:published_time" content="2021-10-15T09:42:00.000Z">
<meta property="article:modified_time" content="2022-12-26T12:30:46.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/1634291202.jpg">

<link rel="canonical" href="http://yoursite.com/2021/10/15/ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>glibc内存管理ptmalloc源代码分析1 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/15/ptmalloc%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          glibc内存管理ptmalloc源代码分析1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-15 17:42:00" itemprop="dateCreated datePublished" datetime="2021-10-15T17:42:00+08:00">2021-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 20:30:46" itemprop="dateModified" datetime="2022-12-26T20:30:46+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="X86平台Linux进程内存布局"><a href="#X86平台Linux进程内存布局" class="headerlink" title="X86平台Linux进程内存布局"></a>X86平台Linux进程内存布局</h2><p><code>Linux</code>系统在装载<code>elf</code>格式的程序文件时，会调用<code>loader</code>把可执行文件中的各个段依次载入到从某一地址开始的空间中（载入地址取决<code>link editor(ld)</code>和机器地址位数，在32位机器上是0x8048000，即<code>128M</code>处）。如下图所示，以32位机器为例，首先被载入的是<code>.text</code>段，然后是<code>.data</code>段，最后是<code>.bss</code>段。这可以看作是程序的开始空间。程序所能访问的最后的地址是<code>0xbfffffff</code>，也就是到<code>3G</code>地址处，<code>3G</code>以上的<code>1G</code>空间是内核使用的，应用程序不可以直接访问。应用程序的堆栈从最高地址处开始向下生长，<code>.bss</code>段与堆栈之间的空间是空闲的，空闲空间被分成两部分，一部分为<code>heap</code>，一部分为<code>mmap</code>映射区域，<code>mmap</code>映射区域一般从<code>TASK_SIZE/3</code>的地方开始。</p>
<p><code>heap</code>和<code>mmap</code>区域都可以供用户自由使用，但是它在刚开始的时候并没有映射到内存空间内，是不可访问的。在向内核请求分配该空间之前，对这个空间的访问会导致<code>segmentation fault</code>。用户程序可以直接使用系统调用来管理<code>heap</code>和<code>mmap</code>映射区域，但更多的时候程序都是使用<code>C</code>语言提供的<code>malloc()</code>和<code>free()</code>函数来动态的分配和释放内存。 Stack`区域是唯一不需要映射，用户却可以访问的内存区域，这也是利用堆栈溢出进行攻击的基础。</p>
<h3 id="32位模式下进程内存经典布局"><a href="#32位模式下进程内存经典布局" class="headerlink" title="32位模式下进程内存经典布局"></a>32位模式下进程内存经典布局</h3><p><img src="/img/1634291202.jpg" alt=""><br>这种布局是<code>Linux</code>内核2.6.7以前的默认进程内存布局形式，<code>mmap</code>区域与栈区域相对增长，这意味着堆只有<code>1GB</code>的虚拟地址空间可以使用，继续增长就会进入<code>mmap</code>映射区域，这显然不是我们想要的。这是由于32模式地址空间限制造成的，所以内核引入了另一种虚拟地址空间的布局形式。但对于64位系统，提供了巨大的虚拟地址空间，这种布局就相当好。</p>
<h3 id="32位模式下进程默认内存布局"><a href="#32位模式下进程默认内存布局" class="headerlink" title="32位模式下进程默认内存布局"></a>32位模式下进程默认内存布局</h3><p><img src="/img/1634291292.jpg" alt=""><br>从上图可以看到，栈至顶向下扩展，并且栈是有界的。堆至底向上扩展，<code>mmap</code>映射区域至顶向下扩展，<code>mmap</code>映射区域和堆相对扩展，直至耗尽虚拟地址空间中的剩余区域，这种结构便于<code>C</code>运行时库使用<code>mmap</code>映射区域和堆进行内存分配。上图的布局形式是在内核2.6.7以后才引入的，这是32位模式下进程的默认内存布局形式。</p>
<h3 id="64位模式下进程内存布局"><a href="#64位模式下进程内存布局" class="headerlink" title="64位模式下进程内存布局"></a>64位模式下进程内存布局</h3><p>在64位模式下各个区域的起始位置是什么呢？对于<code>AMD64</code>系统，内存布局采用经典内存布局，<code>text</code>的起始地址为<code>0x0000000000400000</code>，堆紧接着<code>BSS</code>段向上增长，<code>mmap</code>映射区域开始位置一般设为<code>TASK_SIZE/3</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SIZE_MAX ((1UL &lt;&lt; 47) - PAGE_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SIZE (test_thread_flag(TIF_IA32) ? \</span></span><br><span class="line"><span class="meta">IA32_PAGE_OFFSET : TASK_SIZE_MAX)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_TOP TASK_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNMAPPED_BASE (PAGE_ALIGN(TASK_SIZE / 3))</span></span><br></pre></td></tr></table></figure></p>
<p>计算一下可知，<code>mmap</code>的开始区域地址为0x00002AAAAAAAA000，栈顶地址为0x00007FFFFFFFF0006</p>
<p><img src="/img/1634291332.jpg" alt=""><br>上图是<code>X86_64</code>下<code>Linux</code>进程的默认内存布局形式，这只是一个示意图，当前内核默认配置下，进程的栈和<code>mmap</code>映射区域并不是从一个固定地址开始，并且每次启动时的值都不一样，这是程序在启动时随机改变这些值的设置，使得使用缓冲区溢出进行攻击更加困难。当然也可以让进程的栈和<code>mmap</code>映射区域从一个固定位置开始，只需要设置全局变量<code>randomize_va_space</code>值为0，这个变量默认值为1。用户可以通过设置<code>/proc/sys/kernel/randomize_va_space</code>来停用该特性，也可以用如下命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w kernel.randomize_va_space=0</span><br></pre></td></tr></table></figure></p>
<h2 id="操作系统内存分配的相关函数"><a href="#操作系统内存分配的相关函数" class="headerlink" title="操作系统内存分配的相关函数"></a>操作系统内存分配的相关函数</h2><p>上节提到<code>heap</code>和<code>mmap</code>映射区域是可以提供给用户程序使用的虚拟内存空间，如何获得该区域的内存呢？操作系统提供了相关的系统调用来完成相关工作。对<code>heap</code>的操作，操作系统提供了<code>brk()</code>函数，<code>C</code>运行时库提供了<code>sbrk()</code>函数；对<code>mmap</code>映射区域的操作，操作系统提供了<code>mmap()</code>和<code>munmap()</code>函数。<code>sbrk()</code>，<code>brk()</code>或者<code>mmap()</code>都可以用来向我们的进程添加额外的虚拟内存。<code>Glibc</code>同样是使用这些函数向操作系统申请虚拟内存。</p>
<p>这里要提到一个很重要的概念，内存的延迟分配，只有在真正访问一个地址的时候才建立这个地址的物理映射，这是<code>Linux</code>内存管理的基本思想之一。 Linux`内核在用户申请内存的时候，只是给它分配了一个线性区（也就是虚拟内存），并没有分配实际物理内存；只有当用户使用这块内存的时候，内核才会分配具体的物理页面给用户，这时候才占用宝贵的物理内存。内核释放物理页面是通过释放线性区，找到其所对应的物理页面，将其全部释放的过程。</p>
<h3 id="heap操作相关函数"><a href="#heap操作相关函数" class="headerlink" title="heap操作相关函数"></a>heap操作相关函数</h3><p><code>heap</code>操作函数主要有两个，<code>brk()</code>为系统调用，<code>sbrk()</code>为<code>C</code>库函数。系统调用通常提供一种最小功能，而库函数通常提供比较复杂的功能。<code>Glibc</code>的<code>malloc</code>函数族（<code>realloc</code>，<code>calloc</code>等）就调用<code>sbrk()</code>函数将数据段的下界移动，<code>sbrk()</code>函数在内核的管理下将虚拟地址空间映射到内存，供<code>malloc()</code>函数使用。</p>
<p>内核数据结构<code>mm_struct</code>中的成员变量<code>start_code</code>和<code>end_code</code>是进程代码段的起始和终止地址，<code>start_data</code>和<code>end_data</code>是进程数据段的起始和终止地址，<code>start_stack</code>是进程堆栈段起始地址，<code>start_brk</code>是进程动态内存分配起始地址（堆的起始地址），还有一个<code>brk</code>（堆的当前最后地址），就是动态内存分配当前的终止地址。<code>C</code>语言的动态内存分配基本函数是<code>malloc()</code>，在<code>Linux</code>上的实现是通过内核的<code>brk</code>系统调用。<code>brk()</code>是一个非常简单的系统调用，只是简单地改变<code>mm_struct</code>结构的成员变量<code>brk</code>的值。</p>
<p>这两个函数的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">brk</span><span class="params">(<span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span>;</span><br></pre></td></tr></table></figure></p>
<p>需要说明的是，<code>sbrk()</code>的参数<code>increment</code>为0时，<code>sbrk()</code>返回的是进程的当前<code>brk</code>值，<code>increment</code>为正数时扩展<code>brk</code>值，当<code>increment</code>为负值时收缩<code>brk</code>值。</p>
<h3 id="mmap映射区域操作相关函数"><a href="#mmap映射区域操作相关函数" class="headerlink" title="mmap映射区域操作相关函数"></a>mmap映射区域操作相关函数</h3><p><code>mmap()</code>函数将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。<code>munmap</code>执行相反的操作，删除特定地址区域的对象映射。函数的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure></p>
<p>参数：</p>
<ul>
<li><code>start</code>：映射区的开始地址。</li>
<li><code>length</code>：映射区的长度。</li>
<li><code>prot</code>：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过<code>or</code>运算合理地组合在一起。<code>ptmalloc</code>中主要使用了如下的几个标志：<ul>
<li><code>PROT_EXEC</code>//页内容可以被执行，<code>ptmalloc</code>中没有使用</li>
<li><code>PROT_READ</code>//页内容可以被读取，<code>ptmalloc</code>直接用<code>mmap</code>分配内存并立即返回给用户时设置该标志</li>
<li><code>PROT_WRITE</code>//页可以被写入，<code>ptmalloc</code>直接用<code>mmap</code>分配内存并立即返回给用户时设置该标志</li>
<li><code>PROT_NONE</code>//页不可访问，<code>ptmalloc</code>用<code>mmap</code>向系统“批发”一块内存进行管理时设置该标志</li>
</ul>
</li>
<li><code>flags</code>：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体<ul>
<li><code>MAP_FIXED</code> //使用指定的映射起始地址，如果由<code>start</code>和<code>len</code>参数指定的内存区重叠于现存的映射空间，重叠部分将会被丢弃。如果指定的起始地址不可用，操作将会失败。并且起始地址必须落在页的边界上。<code>ptmalloc</code>在回收从系统中“批发”的内存时设置该标志。</li>
<li><code>MAP_PRIVATE</code> //建立一个写入时拷贝的私有映射。内存区域的写入不会影响到原文件。这个标志和以上标志是互斥的，只能使用其中一个。<code>ptmalloc</code>每次调用<code>mmap</code>都设置该标志。</li>
<li><code>MAP_NORESERVE</code> //不要为这个映射保留交换空间。当交换空间被保留，对映射区修改的可能会得到保证。当交换空间不被保留，同时内存不足，对映射区的修改会引起段违例信号。 ptmalloc`向系统“批发”内存块时设置该标志。</li>
<li><code>MAP_ANONYMOUS</code> //匿名映射，映射区不与任何文件关联。<code>ptmalloc</code>每次调用<code>mmap</code>都设置该标志。</li>
</ul>
</li>
<li><code>fd</code>：有效的文件描述词。如果<code>MAP_ANONYMOUS</code>被设定，为了兼容问题，其值应为-1。</li>
<li><code>offset</code>：被映射对象内容的起点。</li>
</ul>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="内存管理一般性描述"><a href="#内存管理一般性描述" class="headerlink" title="内存管理一般性描述"></a>内存管理一般性描述</h2><p>当不知道程序的每个部分将需要多少内存时，系统内存空间有限，而内存需求又是变化的，这时就需要内存管理程序来负责分配和回收内存。程序的动态性越强，内存管理就越重要，内存分配程序的选择也就更重要。</p>
<h3 id="内存管理的方法"><a href="#内存管理的方法" class="headerlink" title="内存管理的方法"></a>内存管理的方法</h3><p>可用于内存管理的方法有许多种，它们各有好处与不足，不同的内存管理方法有最适用的情形。</p>
<h4 id="C风格的内存管理程序"><a href="#C风格的内存管理程序" class="headerlink" title="C风格的内存管理程序"></a>C风格的内存管理程序</h4><p><code>C</code>风格的内存管理程序主要实现<code>malloc()</code>和<code>free()</code>函数。内存管理程序主要通过调用<code>brk()</code>或者<code>mmap()</code>进程添加额外的虚拟内存。<code>Doug Lea Malloc</code>，<code>ptmalloc</code>，<code>BSD malloc</code>，<code>Hoard</code>，<code>TCMalloc</code>都属于这一类内存管理程序。</p>
<p>基于<code>malloc()</code>的内存管理器仍然有很多缺点，不管使用的是哪个分配程序。对于那些需要保持长期存储的程序使用<code>malloc()</code>来管理内存可能会非常令人失望。如果有大量的不固定的内存引用，经常难以知道它们何时被释放。生存期局限于当前函数的内存非常容易管理，但是对于生存期超出该范围的内存来说，管理内存则困难得多。因为管理内存的问题，很多程序倾向于使用它们自己的内存管理规则。</p>
<h4 id="池式内存管理"><a href="#池式内存管理" class="headerlink" title="池式内存管理"></a>池式内存管理</h4><p>内存池是一种半内存管理方法。内存池帮助某些程序进行自动内存管理，这些程序会经历一些特定的阶段，而且每个阶段中都有分配给进程的特定阶段的内存。在池式内存管理中，每次内存分配都会指定内存池，从中分配内存。每个内存池都有不同的生存期限。另外，有一些实现允许注册清除函数（cleanup functions），在清除内存池之前，恰好可以调用它，来完成在内存被清理前需要完成的其他所有任务（类似于面向对象中的析构函数）。</p>
<p>使用池式内存分配的优点如下所示：</p>
<ul>
<li>应用程序可以简单地管理内存。</li>
<li>内存分配和回收更快，因为每次都是在一个池中完成的。分配可以在<code>O(1)</code>时间内完成，释放内存池所需时间也差不多（实际上是<code>O(n)</code>时间，不过在大部分情况下会除以一个大的因数，使其变成<code>O(1)</code>）。</li>
<li>可以预先分配错误处理池（Error-handling pools），以便程序在常规内存被耗尽时仍可以恢复。</li>
<li>有非常易于使用的标准实现。</li>
</ul>
<p>池式内存的缺点是：</p>
<ul>
<li>内存池只适用于操作可以分阶段的程序。</li>
<li>内存池通常不能与第三方库很好地合作。</li>
<li>如果程序的结构发生变化，则不得不修改内存池，这可能会导致内存管理系统的重新设计。</li>
<li>您必须记住需要从哪个池进行分配。另外，如果在这里出错，就很难捕获该内存池。</li>
</ul>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>在引用计数中，所有共享的数据结构都有一个域来包含当前活动“引用”结构的次数。当向一个程序传递一个指向某个数据结构指针时，该程序会将引用计数增加1。实质上，是在告诉数据结构，它正在被存储在多少个位置上。然后，当进程完成对它的使用后，该程序就会将引用计数减少1。结束这个动作之后，它还会检查计数是否已经减到零。如果是，那么它将释放内存。</p>
<p>在<code>Java</code>，<code>Perl</code>等高级语言中，进行内存管理时使用引用计数非常广泛。在这些语言中，引用计数由语言自动地处理，所以您根本不必担心它，除非要编写扩展模块。由于所有内容都必须进行引用计数，所以这会对速度产生一些影响，但它极大地提高了编程的安全性和方便性。</p>
<p>以下是引用计数的好处：</p>
<ul>
<li>实现简单。</li>
<li>易于使用。</li>
<li>由于引用是数据结构的一部分，所以它有一个好的缓存位置。</li>
</ul>
<p>不过，它也有其不足之处：</p>
<ul>
<li>要求您永远不要忘记调用引用计数函数。</li>
<li>无法释放作为循环数据结构的一部分的结构。</li>
<li>减缓几乎每一个指针的分配。</li>
<li>尽管所使用的对象采用了引用计数，但是当使用异常处理（比如<code>try</code>或<code>setjmp()</code>/<code>longjmp()</code>）时，您必须采取其他方法。</li>
<li>需要额外的内存来处理引用。</li>
<li>引用计数占用了结构中的第一个位置，在大部分机器中最快可以访问到的就是这个位置。</li>
<li>在多线程环境中更慢也更难以使用。</li>
</ul>
<h4 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h4><p>垃圾收集（Garbage collection）是全自动地检测并移除不再使用的数据对象。垃圾收集器通常会在当可用内存减少到少于一个具体的阈值时运行。通常，它们以程序所知的可用的一组“基本”数据——栈数据、全局变量、寄存器——作为出发点。然后它们尝试去追踪通过这些数据连接到每一块数据。收集器找到的都是有用的数据；它没有找到的就是垃圾，可以被销毁并重新使用这些无用的数据。为了有效地管理内存，很多类型的垃圾收集器都需要知道数据结构内部指针的规划，所以，为了正确运行垃圾收集器，它们必须是语言本身的一部分。</p>
<p>垃圾收集的一些优点：<br>-永远不必担心内存的双重释放或者对象的生命周期。<br>-使用某些收集器，您可以使用与常规分配相同的`API。</p>
<p>其缺点包括：</p>
<ul>
<li>使用大部分收集器时，您都无法干涉何时释放内存。</li>
<li>在多数情况下，垃圾收集比其他形式的内存管理更慢。</li>
<li>垃圾收集错误引发的缺陷难于调试。</li>
<li>如果您忘记将不再使用的指针设置为<code>null</code>，那么仍然会有内存泄漏。</li>
</ul>
<h3 id="内存管理器的设计目标"><a href="#内存管理器的设计目标" class="headerlink" title="内存管理器的设计目标"></a>内存管理器的设计目标</h3><p>分析内存管理算法之前，我们先看看对内存管理算法的质量需求有哪些：</p>
<ol>
<li>最大化兼容性：要实现内存管理器时，先要定义出分配器的接口函数。接口函数没有必要标新立异，而是要遵循现有标准（如<code>POSIX</code>），让使用者可以平滑的过度到新的内存管理器上。</li>
<li>最大化可移植性：通常情况下，内存管理器要向<code>OS</code>申请内存，然后进行二次分配。所以，在适当的时候要扩展内存或释放多余的内存，这要调用<code>OS</code>提供的函数才行。<code>OS</code>提供的函数则是因平台而异，尽量抽象出平台相关的代码，保证内存管理器的可移植性。</li>
<li>浪费最小的空间：内存管理器要管理内存，必然要使用自己一些数据结构，这些数据结构本身也要占内存空间。在用户眼中，这些内存空间毫无疑问是浪费掉了，如果浪费在内存管理器身的内存太多，显然是不可以接受的。内存碎片也是浪费空间的罪魁祸首，若内存管理器中有大量的内存碎片，它们是一些不连续的小块内存，它们总量可能很大，但无法使用，这也是不可以接受的。</li>
<li>最快的速度：内存分配/释放是常用的操作。按着2/8原则，常用的操作就是性能热点，热点函数的性能对系统的整体性能尤为重要。</li>
<li>最大化可调性（以适应于不同的情况）：内存管理算法设计的难点就在于要适应用不同的情况。事实上，如果缺乏应用的上下文，是无法评估内存管理算法的好坏的。可以说在任何情况下，专用算法都比通用算法在时/空性能上的表现更优。设计一套通用内存管理算法，通过一些参数对它进行配置，可以让它在特定情况也有相当出色的表现，这就是可调性。</li>
<li>最大化局部性（Locality）：大家都知道，使用<code>cache</code>可以提高程度的速度，但很多人未必知道<code>cache</code>使程序速度提高的真正原因。拿<code>CPU</code>内部的<code>cache</code>和<code>RAM</code>的访问速度相比，速度可能相差一个数量级。<br>两者的速度上的差异固然重要，但这并不是提高速度的充分条件，只是必要条件。另外一个条件是程序访问内存的局部性（Locality）。大多数情况下，程序总访问一块内存附近的内存，把附近的内存先加入到<code>cache</code>中，下次访问<code>cache</code>中的数据，速度就会提高。否则，如果程序一会儿访问这里，一会儿访问另外一块相隔十万八千里的内存，这只会使数据在内存与<code>cache</code>之间来回搬运，不但于提高速度无益，反而会大大降低程序的速度。因此，内存管理算法要考虑这一因素，减少<code>cache miss</code>和<code>page fault</code>。</li>
<li>最大化调试功能：内存管理器提供的调试功能，强大易用，特别对于嵌入式环境来说，内存错误检测工具缺乏，内存管理器提供的调试功能就更是不可或缺了。</li>
<li>最大化适应性：对于不同情况都要去调设置，无疑太麻烦，是非用户友好的。要尽量让内存管理器适用于很广的情况，只有极少情况下才去调设置。</li>
</ol>
<p>为了提高分配、释放的速度，多核计算机上，主要做的工作是避免所有核同时在竞争内存，常用的做法是内存池，简单来说就是批量申请内存，然后切割成各种长度，各种长度都有一个链表，申请、释放都只要在链表上操作，可以认为是<code>O(1)</code>的。不可能所有的长度都对应一个链表。很多内存池是假设，<code>A</code>释放掉一块内存后，<code>B</code>会申请类似大小的内存，但是<code>A</code>释放的内存跟<code>B</code>需要的内存不一定完全相等，可能有一个小的误差，如果严格按大小分配，会导致复用率很低，这样各个链表上都会有很多释放了，但是没有复用的内存，导致利用率很低。这个问题也是可以解决的，可以回收这些空闲的内存，这就是传统的内存管理，不停地对内存块作切割和合并，会导致效率低下。所以通常的做法是只分配有限种类的长度。一般的内存池只提供几十种选择。</p>
<h3 id="常见C内存管理程序"><a href="#常见C内存管理程序" class="headerlink" title="常见C内存管理程序"></a>常见C内存管理程序</h3><p>比较著名的几个<code>C</code>内存管理程序包括：</p>
<ul>
<li>Doug Lea Malloc：<ul>
<li><code>Doug Lea Malloc</code>实际上是完整的一组分配程序，其中包括<code>Doug Lea</code>的原始分配程序，<code>GNU libc</code>分配程序和<code>ptmalloc</code>。</li>
<li><code>Doug Lea</code>的分配程序加入了索引，这使得搜索速度更快，并且可以将多个没有被使用的块组合为一个大的块。</li>
<li>它还支持缓存，以便更快地再次使用最近释放的内存。</li>
<li><code>ptmalloc</code>是<code>Doug Lea Malloc</code>的一个扩展版本，支持多线程。在本文后面的部分详细分析<code>ptamlloc2</code>的源代码实现。</li>
</ul>
</li>
<li>BSD Malloc：<ul>
<li><code>BSD Malloc</code>是随4.2 BSD发行的实现，包含在<code>FreeBSD</code>之中，这个分配程序可以从预先确实大小的对象构成的池中分配对象。</li>
<li>它有一些用于对象大小的<code>size</code>类，这些对象的大小为2的若干次幂减去某一常数。所以，如果您请求给定大小的一个对象，它就简单地分配一个与之匹配的<code>size</code>类。这样就提供了一个快速的实现，但是可能会浪费内存。</li>
</ul>
</li>
<li>Hoard：<ul>
<li>编写<code>Hoard</code>的目标是使内存分配在多线程环境中进行得非常快。因此，它的构造以锁的使用为中心，从而使所有进程不必等待分配内存。它可以显著地加快那些进行很多分配和回收的多线程进程的速度。</li>
</ul>
</li>
<li>TCMalloc（Thread-Caching Malloc）：<ul>
<li>是<code>google</code>开发的开源工具──“google-perftools”中的成员。与标准的<code>Glibc</code>库的<code>malloc</code>相比，<code>TCMalloc</code>在内存的分配上效率和速度要高得多。<code>TCMalloc</code>是一种通用内存管理程序，集成了内存池和垃圾回收的优点，对于小内存，按8的整数次倍分配，对于大内存，按<code>4K</code>的整数次倍分配。这样做有两个好处：<ul>
<li>一是分配的时候比较快，那种提供几十种选择的内存池，往往要遍历一遍各种长度，才能选出合适的种类，而<code>TCMalloc</code>则可以简单地做几个运算就行了。</li>
<li>二是短期的收益比较大，分配的小内存至多浪费7个字节，大内存则4K。</li>
<li>但是长远来说，TCMalloc分配的种类还是比别的内存池要多很多的，可能会导致复用率很低。</li>
</ul>
</li>
<li><code>TCMalloc</code>还有一套高效的机制回收这些空闲的内存。当一个线程的空闲内存比较多的时候，会交还给进程，进程可以把它调配给其他线程使用；如果某种长度交还给进程后，其他线程并没有需求，进程则把这些长度合并成内存页，然后切割成其他长度。如果进程占据的资源比较多，不会交回给操作系统。周期性的内存回收，避免可能出现的内存爆炸式增长的问题。</li>
<li><code>TCMalloc</code>有比较高的空间利用率，只额外花费1%的空间。尽量避免加锁（一次加锁解锁约浪费100ns），使用更高效的<code>spinlock</code>，采用更合理的粒度。</li>
<li>小块内存和打开内存分配采取不同的策略：小于<code>32K</code>的被定义为小块内存，小块内存按大小被分为<code>8Bytes</code>，<code>16Bytes</code>，。。。，<code>236Bytes</code>进行分级。不是某个级别整数倍的大小都会被分配向上取整。如<code>13Bytes</code>的会按<code>16Bytes</code>分配，分配时，首先在本线程相应大小级别的空闲链表里面找，如果找到的话可以避免加锁操作（本线程的<code>cache</code>只有本线程自己使用）。如果找不到的话，则尝试从中心内存区的相应级别的空闲链表里搬一些对象到本线程的链表。</li>
<li>如果中心内存区相应链表也为空的话，则向中心页分配器请求内存页面，然后分割成该级别的对象存储。</li>
<li>大块内存处理方式：按页分配，每页大小是4K`，然后内存按1页，2页，……，255页的大小分类，相同大小的内存块也用链表连接。</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>策略</th>
<th>分配速度</th>
<th>回收速度</th>
<th>局部缓存</th>
<th>易用性</th>
<th>通用性</th>
<th><code>SMP</code>线程友好度</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>GNU Malloc</code></td>
<td>中</td>
<td>快</td>
<td>中</td>
<td>容</td>
<td>易</td>
<td>高</td>
<td>中</td>
</tr>
<tr>
<td><code>Hoard</code></td>
<td>中</td>
<td>中</td>
<td>中</td>
<td>容</td>
<td>易</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td><code>TCMalloc</code></td>
<td>快</td>
<td>快</td>
<td>中</td>
<td>容</td>
<td>易</td>
<td>高</td>
<td>高</td>
</tr>
</tbody>
</table>
</div>
<p>从上表可以看出，<code>TCMalloc</code>的优势还是比较大的，<code>TCMalloc</code>的优势体现在：</p>
<ul>
<li>分配内存页的时候，直接跟<code>OS</code>打交道，而常用的内存池一般是基于别的内存管理器上分配，如果完全一样的内存管理策略，明显<code>TCMalloc</code>在性能及内存利用率上要省掉第三方内存管理的开销。</li>
<li>大部分的内存池只负责分配，不管回收。当然了，没有回收策略，也有别的方法解决问题。比如线程之间协调资源，模索模块一般是一写多读，也就是只有一个线程申请、释放内存，就不存在线程之间协调资源；为了避免某些块大量空闲，常用的做法是减少内存块的种类，提高复用率，这可能会造成内部碎片比较多，如果空闲的内存实在太多了，还可以直接重启。</li>
</ul>
<p>作为一个通用的内存管理库，<code>TCMalloc</code>也未必能超过专用的比较粗糙的内存池。比如应用中主要用到7种长度的块，专用的内存池，可以只分配这7种长度，使得没有内部碎片。或者利用统计信息设置内存池的长度，也可以使得内部碎片比较少。所以<code>TCMalloc</code>的意义在于，不需要增加任何开发代价，就能使得内存的开销比较少，而且可以从理论上证明，最优的分配不会比<code>TCMalloc</code>的分配好很多。</p>
<p>对比<code>Glibc</code>可以发现，两者的思想其实是差不多的，差别只是在细节上，细节上的差别，对工程项目来说也是很重要的，至少在性能与内存使用率上<code>TCMalloc</code>是领先很多的。 Glibc在内存回收方面做得不太好，常见的一个问题，申请很多内存，然后又释放，只是有一小块没释放，这时候<code>Glibc</code>就必须要等待这一小块也释放了，也把整个大块释放，极端情况下，可能会造成几个<code>G</code>的浪费。</p>
<h2 id="ptmalloc内存管理概述"><a href="#ptmalloc内存管理概述" class="headerlink" title="ptmalloc内存管理概述"></a>ptmalloc内存管理概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Linux</code>中<code>malloc</code>的早期版本是由<code>Doug Lea</code>实现的，它有一个重要问题就是在并行处理时多个线程共享进程的内存空间，各线程可能并发请求内存，在这种情况下应该如何保证分配和回收的正确和高效。<code>Wolfram Gloger</code>在<code>Doug Lea</code>的基础上改进使得<code>Glibc</code>的<code>malloc</code>可以支持多线程——<code>ptmalloc</code>，在<code>glibc-2.3.x</code>中已经集成了<code>ptmalloc2</code>，这就是我们平时使用的<code>malloc</code>，目前<code>ptmalloc</code>的最新版本<code>ptmalloc3</code>。<code>ptmalloc2</code>的性能略微比<code>ptmalloc3</code>要高一点点。</p>
<p><code>ptmalloc</code>实现了<code>malloc()</code>，<code>free()</code>以及一组其它的函数.以提供动态内存管理的支持。分配器处在用户程序和内核之间，它响应用户的分配请求，向操作系统申请内存，然后将其返回给用户程序，为了保持高效的分配，分配器一般都会预先分配一块大于用户请求的内存，并通过某种算法管理这块内存。来满足用户的内存分配要求，用户释放掉的内存也并不是立即就返回给操作系统，相反，分配器会管理这些被释放掉的空闲空间，以应对用户以后的内存分配要求。也就是说，分配器不但要管理已分配的内存块，还需要管理空闲的内存块，当响应用户分配要求时，分配器会首先在空闲空间中寻找一块合适的内存给用户，在空闲空间中找不到的情况下才分配一块新的内存。为实现一个高效的分配器，需要考虑很多的因素。比如，分配器本身管理内存块所占用的内存空间必须很小，分配算法必须要足够的快。</p>
<h3 id="内存管理的设计假设"><a href="#内存管理的设计假设" class="headerlink" title="内存管理的设计假设"></a>内存管理的设计假设</h3><p><code>ptmalloc</code>在设计时折中了高效率，高空间利用率，高可用性等设计目标。在其实现代码中，隐藏着内存管理中的一些设计假设，由于某些设计假设，导致了在某些情况下<code>ptmalloc</code>的行为很诡异。这些设计假设包括：</p>
<ol>
<li>具有长生命周期的大内存分配使用<code>mmap</code>。</li>
<li>特别大的内存分配总是使用<code>mmap</code>。</li>
<li>具有短生命周期的内存分配使用<code>brk</code>，因为用<code>mmap</code>映射匿名页，当发生缺页异常时，<code>linux</code>内核为缺页分配一个新物理页，并将该物理页清0，一个<code>mmap</code>的内存块需要映射多个物理页，导致多次清0操作，很浪费系统资源，所以引入了<code>mmap</code>分配阈值动态调整机制，保证在必要的情况下才使用<code>mmap</code>分配内存。</li>
<li>尽量只缓存临时使用的空闲小内存块，对大内存块或是长生命周期的大内存块在释放时都直接归还给操作系统。</li>
<li>对空闲的小内存块只会在<code>malloc</code>和<code>free</code>的时候进行合并，<code>free</code>时空闲内存块可能放入<code>pool</code>中，不一定归还给操作系统。</li>
<li>收缩堆的条件是当前<code>free</code>的块大小加上前后能合并<code>chunk</code>的大小大于<code>64KB</code>，并且堆顶的大小达到阈值，才有可能收缩堆，把堆最顶端的空闲内存返回给操作系统。</li>
<li>需要保持长期存储的程序不适合用<code>ptmalloc</code>来管理内存。</li>
<li>为了支持多线程，多个线程可以从同一个分配区（<code>arena</code>）中分配内存，<code>ptmalloc</code>假设线程<code>A</code>释放掉一块内存后，线程<code>B</code>会申请类似大小的内存，但是<code>A</code>释放的内存跟<code>B</code>需要的内存不一定完全相等，可能有一个小的误差，就需要不停地对内存块作切割和合并，这个过程中可能产生内存碎片。</li>
</ol>
<h3 id="内存管理数据结构概述"><a href="#内存管理数据结构概述" class="headerlink" title="内存管理数据结构概述"></a>内存管理数据结构概述</h3><h4 id="Main-arena与non-main-arena"><a href="#Main-arena与non-main-arena" class="headerlink" title="Main_arena与non_main_arena"></a>Main_arena与non_main_arena</h4><p>在<code>Doug Lea</code>实现的内存分配器中只有一个主分配区（main arena），每次分配内存都必须对主分配区加锁，分配完成后释放锁，在<code>SMP</code>多线程环境下，对主分配区的锁的争用很激烈，严重影响了<code>malloc</code>的分配效率。于是<code>Wolfram Gloger</code>在<code>Doug Lea</code>的基础上改进使得<code>Glibc</code>的<code>malloc</code>可以支持多线程，增加了非主分配区（non main arena）支持，主分配区与非主分配区用环形链表进行管理。每一个分配区利用互斥锁（mutex）使线程对于该分配区的访问互斥。</p>
<p>每个进程只有一个主分配区，但可能存在多个非主分配区，<code>ptmalloc</code>根据系统对分配区的争用情况动态增加非主分配区的数量，分配区的数量一旦增加，就不会再减少了。主分配区可以访问进程的<code>heap</code>区域和<code>mmap</code>映射区域，也就是说主分配区可以使用<code>sbrk</code>和<code>mmap</code>向操作系统申请虚拟内存。而非主分配区只能访问进程的<code>mmap</code>映射区域，非主分配区每次使用<code>mmap()</code>向操作系统“批发”<code>HEAP_MAX_SIZE</code>（32位系统上默认为<code>1MB</code>，64位系统默认为<code>64MB</code>）大小的虚拟内存，当用户向非主分配区请求分配内存时再切割成小块“零售”出去，毕竟系统调用是相对低效的，直接从用户空间分配内存快多了。所以<code>ptmalloc</code>在必要的情况下才会调用<code>mmap()</code>函数向操作系统申请虚拟内存。</p>
<p>主分配区可以访问<code>heap</code>区域，如果用户不调用<code>brk()</code>或是<code>sbrk()</code>函数，分配程序就可以保证分配到连续的虚拟地址空间，因为每个进程只有一个主分配区使用<code>sbrk()</code>分配<code>heap</code>区域的虚拟内存。内核对<code>brk</code>的实现可以看着是<code>mmap</code>的一个精简版，相对高效一些。如果主分配区的内存是通过<code>mmap()</code>向系统分配的，当<code>free</code>该内存时，主分配区会直接调用<code>munmap()</code>将该内存归还给系统。</p>
<p>当某一线程需要调用<code>malloc()</code>分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜索循环链表试图获得一个没有加锁的分配区。如果所有的分配区都已经加锁，那么<code>malloc()</code>会开辟一个新的分配区，把该分配区加入到全局分配区循环链表并加锁，然后使用该分配区进行分配内存操作。在释放操作中，线程同样试图获得待释放内存块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行释放操作。</p>
<p>申请小块内存时会产生很多内存碎片，<code>ptmalloc</code>在整理时也需要对分配区做加锁操作。每个加锁操作大概需要5～10个<code>cpu</code>指令，而且程序线程很多的情况下，锁等待的时间就会延长，导致<code>malloc</code>性能下降。一次加锁操作需要消耗<code>100ns</code>左右，正是锁的缘故，导致<code>ptmalloc</code>在多线程竞争情况下性能远远落后于<code>tcmalloc</code>。最新版的<code>ptmalloc</code>对锁进行了优化，加入了<code>PER_THREAD</code>和<code>ATOMIC_FASTBINS</code>优化，但默认编译不会启用该优化，这两个对锁的优化应该能够提升多线程内存的分配的效率。</p>
<h4 id="chunk的组织"><a href="#chunk的组织" class="headerlink" title="chunk的组织"></a>chunk的组织</h4><p>不管内存是在哪里被分配的，用什么方法分配，用户请求分配的空间在<code>ptmalloc</code>中都使用一个<code>chunk</code>来表示。用户调用<code>free()</code>函数释放掉的内存也并不是立即就归还给操作系统，相反，它们也会被表示为一个<code>chunk</code>，<code>ptmalloc</code>使用特定的数据结构来管理这些空闲的<code>chunk</code>。</p>
<h5 id="chunk格式"><a href="#chunk格式" class="headerlink" title="chunk格式"></a>chunk格式</h5><p><code>ptmalloc</code>在给用户分配的空间的前后加上了一些控制信息，用这样的方法来记录分配的信息，以便完成分配和释放工作。一个使用中的<code>chunk</code>（使用中，就是指还没有被<code>free</code>掉）在内存中的样子如图所示：<br><img src="/img/1634304883.jpg" alt=""></p>
<p>在图中，<code>chunk</code>指针指向一个<code>chunk</code>的开始，一个<code>chunk</code>中包含了用户请求的内存区域和相关的控制信息。图中的<code>mem</code>指针才是真正返回给用户的内存指针。<code>chunk</code>的第二个域的最低一位为<code>P</code>，它表示前一个块是否在使用中，<code>P</code>为0则表示前一个<code>chunk</code>为空闲，这时<code>chunk</code>的第一个域<code>prev_size</code>才有效，<code>prev_size</code>表示前一个<code>chunk</code>的<code>size</code>，程序可以使用这个值来找到前一个<code>chunk</code>的开始地址。当<code>P</code>为1时，表示前一个<code>chunk</code>正在使用中，<code>prev_size</code>无效，程序也就不可以得到前一个<code>chunk</code>的大小。不能对前一个<code>chunk</code>进行任何操作。<code>ptmalloc</code>分配的第一个块总是将<code>P</code>设为1，以防止程序引用到不存在的区域。</p>
<p><code>chunk</code>的第二个域的倒数第二个位为<code>M</code>，他表示当前<code>chunk</code>是从哪个内存区域获得的虚拟内存。<code>M</code>为1表示该<code>chunk</code>是从<code>mmap</code>映射区域分配的，否则是从<code>heap</code>区域分配的。<code>chunk</code>的第二个域倒数第三个位为<code>A</code>，表示该<code>chunk</code>属于主分配区或者非主分配区，如果属于非主分配区，将该位置为1，否则置为0。</p>
<p>空闲<code>chunk</code>在内存中的结构如图所示：<br><img src="/img/1634304988.jpg" alt=""></p>
<p>当<code>chunk</code>空闲时，其<code>M</code>状态不存在，只有<code>AP</code>状态，原本是用户数据区的地方存储了四个指针，指针<code>fd</code>指向后一个空闲的<code>chunk</code>，而<code>bk</code>指向前一个空闲的<code>chunk</code>，<code>ptmalloc</code>通过这两个指针将大小相近的<code>chunk</code>连成一个双向链表。对于<code>large bin</code>中的空闲<code>chunk</code>，还有两个指针，<code>fd_nextsize</code>和<code>bk_nextsize</code>，这两个指针用于加快在<code>large bin</code>中查找最近匹配的空闲<code>chunk</code>。不同的<code>chunk</code>链表又是通过<code>bins</code>或者<code>fastbins</code>来组织的。</p>
<h5 id="chunk中的空间复用"><a href="#chunk中的空间复用" class="headerlink" title="chunk中的空间复用"></a>chunk中的空间复用</h5><p>为了使得<code>chunk</code>所占用的空间最小，<code>ptmalloc</code>使用了空间复用，一个<code>chunk</code>或者正在被使用，或者已经被<code>free</code>掉，所以<code>chunk</code>的中的一些域可以在使用状态和空闲状态表示不同的意义，来达到空间复用的效果。以32位系统为例，空闲时，一个<code>chunk</code>中至少需要4个<code>size_t</code>（4B）大小的空间，用来存储<code>prev_size</code>，<code>size</code>，<code>fd</code>和<code>bk</code>，也就是<code>16B</code>，<code>chunk</code>的大小要对齐到8B。当一个<code>chunk</code>处于使用状态时，它的下一个<code>chunk</code>的<code>prev_size</code>域肯定是无效的。所以实际上，这个空间也可以被当前<code>chunk</code>使用。这听起来有点不可思议，但确实是合理空间复用的例子。故而实际上，一个使用中的<code>chunk</code>的大小的计算公式应该是：<code>in_use_size = (用户请求大小+ 8 - 4 ) align to 8B</code>，这里加8是因为需要存储<code>prev_size</code>和<code>size</code>，但又因为向下一个<code>chunk</code>“借”了<code>4B</code>，所以要减去4。最后，因为空闲的<code>chunk</code>和使用中的<code>chunk</code>使用的是同一块空间。所以肯定要取其中最大者作为实际的分配空间。即最终的分配空间<code>chunk_size = max(in_use_size, 16)</code>。</p>
<h4 id="空闲chunk容器"><a href="#空闲chunk容器" class="headerlink" title="空闲chunk容器"></a>空闲chunk容器</h4><h5 id="Bins"><a href="#Bins" class="headerlink" title="Bins"></a>Bins</h5><p>用户<code>free</code>掉的内存并不是都会马上归还给系统，<code>ptmalloc</code>会统一管理<code>heap</code>和<code>mmap</code>映射区域中的空闲的<code>chunk</code>，当用户进行下一次分配请求时，<code>ptmalloc</code>会首先试图在空闲的<code>chunk</code>中挑选一块给用户，这样就避免了频繁的系统调用，降低了内存分配的开销。 <code>ptmalloc</code>将相似大小的<code>chunk</code>用双向链表链接起来，这样的一个链表被称为一个<code>bin</code>。<code>ptmalloc</code>一共维护了128个<code>bin</code>，并使用一个数组来存储这些<code>bin</code>（如下图所示）。<br><img src="/img/1634306475.jpg" alt=""></p>
<p>数组中的第一个为<code>unsorted bin</code>，数组中从2开始编号的前64个<code>bin</code>称为<code>small bins</code>，同一个<code>small bin</code>中的<code>chunk</code>具有相同的大小。两个相邻的<code>small bin</code>中的<code>chunk</code>大小相差8bytes。</p>
<p><code>small bins</code>中的<code>chunk</code>按照最近使用顺序进行排列，最后释放的<code>chunk</code>被链接到链表的头部，而申请<code>chunk</code>是从链表尾部开始，这样，每一个<code>chunk</code>都有相同的机会被<code>ptmalloc</code>选中。<code>small bins</code>后面的<code>bin</code>被称作<code>large bins</code>。<code>large bins</code>中的每一个<code>bin</code>分别包含了一个给定范围内的<code>chunk</code>，其中的<code>chunk</code>按大小序排列。相同大小的<code>chunk</code>同样按照最近使用顺序排列。</p>
<p><code>ptmalloc</code>使用<code>smallest-first</code>，<code>best-fit</code>原则在空闲<code>large bins</code>中查找合适的<code>chunk</code>。当空闲的<code>chunk</code>被链接到<code>bin</code>中的时候，<code>ptmalloc</code>会把表示该<code>chunk</code>是否处于使用中的标志<code>P</code>设为0（注意，这个标志实际上处在下一个<code>chunk</code>中），同时<code>ptmalloc</code>还会检查它前后的<code>chunk</code>是否也是空闲的，如果是的话，<code>ptmalloc</code>会首先把它们合并为一个大的<code>chunk</code>，然后将合并后的<code>chunk</code>放到<code>unstored bin</code>中。要注意的是，并不是所有的<code>chunk</code>被释放后就立即被放到<code>bin</code>中。<code>ptmalloc</code>为了提高分配的速度，会把一些小的的<code>chunk</code>先放到一个叫做<code>fast bins</code>的容器内。</p>
<h5 id="Fast-Bins"><a href="#Fast-Bins" class="headerlink" title="Fast Bins"></a>Fast Bins</h5><p>一般的情况是，程序在运行时会经常需要申请和释放一些较小的内存空间。当分配器合并了相邻的几个小的<code>chunk</code>之后，也许马上就会有另一个小块内存的请求，这样分配器又需要从大的空闲内存中切分出一块，这样无疑是比较低效的，故而，<code>ptmalloc</code>中在分配过程中引入了<code>fast bins</code>，不大于<code>max_fast</code>（默认值为64B）的<code>chunk</code>被释放后，首先会被放到<code>fast bins</code>中，<code>fast bins</code>中的<code>chunk</code>并不改变它的使用标志<code>P</code>。这样也就无法将它们合并，当需要给用户分配的<code>chunk</code>小于或等于<code>max_fast</code>时，<code>ptmalloc</code>首先会在<code>fast bins</code>中查找相应的空闲块，然后才会去查找<code>bins</code>中的空闲<code>chunk</code>。在某个特定的时候，<code>ptmalloc</code>会遍历<code>fast bins</code>中的<code>chunk</code>，将相邻的空闲<code>chunk</code>进行合并，并将合并后的<code>chunk</code>加入<code>unsorted bin</code>中，然后再将<code>usorted bin</code>里的<code>chunk</code>加入<code>bins</code>中。</p>
<h5 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h5><p><code>unsorted bin</code>的队列使用<code>bins</code>数组的第一个，如果被用户释放的<code>chunk</code>大于<code>max_fast</code>，或者<code>fast bins</code>中的空闲<code>chunk</code>合并后，这些<code>chunk</code>首先会被放到<code>unsorted bin</code>队列中，在进行<code>malloc</code>操作的时候，如果在<code>fast bins</code>中没有找到合适的<code>chunk</code>，则<code>ptmalloc</code>会先在<code>unsorted bin</code>中查找合适的空闲<code>chunk</code>，然后才查找<code>bins</code>。如果<code>unsorted bin</code>不能满足分配要求。<code>malloc</code>便会将<code>unsorted bin</code>中的<code>chunk</code>加入<code>bins</code>中。然后再从<code>bins</code>中继续进行查找和分配过程。从这个过程可以看出来，<code>unsorted bin</code>可以看做是<code>bins</code>的一个缓冲区，增加它只是为了加快分配的速度。</p>
<h5 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h5><p>并不是所有的<code>chunk</code>都按照上面的方式来组织，实际上，有三种例外情况。<code>top chunk</code>，<code>mmaped chunk</code>和<code>last remainder</code>，下面会分别介绍这三类特殊的<code>chunk</code>。</p>
<p><code>top chunk</code>对于主分配区和非主分配区是不一样的。</p>
<p>对于非主分配区会预先从<code>mmap</code>区域分配一块较大的空闲内存模拟<code>sub-heap</code>，通过管理<code>sub-heap</code>来响应用户的需求，因为内存是按地址从低向高进行分配的，在空闲内存的最高处，必然存在着一块空闲<code>chunk</code>，叫做<code>top chunk</code>。当<code>bins</code>和<code>fast bins</code>都不能满足分配需要的时候，<code>ptmalloc</code>会设法在<code>top chunk</code>中分出一块内存给用户，如果<code>top chunk</code>本身不够大，分配程序会重新分配一个<code>sub-heap</code>，并将<code>top chunk</code>迁移到新的<code>sub-heap</code>上，新的<code>sub-heap</code>与已有的<code>sub-heap</code>用单向链表连接起来，然后在新的<code>top chunk</code>上分配所需的内存以满足分配的需要，实际上，<code>top chunk</code>在分配时总是在<code>fast bins</code>和<code>bins</code>之后被考虑，所以，不论<code>top chunk</code>有多大，它都不会被放到<code>fast bins</code>或者是<code>bins</code>中。<code>top chunk</code>的大小是随着分配和回收不停变换的，如果从<code>top chunk</code>分配内存会导致<code>top chunk</code>减小，如果回收的<code>chunk</code>恰好与<code>top chunk</code>相邻，那么这两个<code>chunk</code>就会合并成新的<code>top chunk</code>，从而使<code>top chunk</code>变大。如果在<code>free</code>时回收的内存大于某个阈值，并且<code>top chunk</code>的大小也超过了收缩阈值，<code>ptmalloc</code>会收缩<code>sub-heap</code>，如果<code>top-chunk</code>包含了整个<code>sub-heap</code>，<code>ptmalloc</code>会调用<code>munmap</code>把整个<code>sub-heap</code>的内存返回给操作系统。</p>
<p>由于主分配区是唯一能够映射进程<code>heap</code>区域的分配区，它可以通过<code>sbrk()</code>来增大或是收缩进程<code>heap</code>的大小，<code>ptmalloc</code>在开始时会预先分配一块较大的空闲内存（也就是所谓的<code>heap</code>），主分配区的<code>top chunk</code>在第一次调用<code>malloc</code>时会分配一块<code>(chunk_size + 128KB) align 4KB</code>大小的空间作为初始的<code>heap</code>，用户从<code>top chunk</code>分配内存时，可以直接取出一块内存给用户。在回收内存时，回收的内存恰好与<code>top chunk</code>相邻则合并成新的<code>top chunk</code>，当该次回收的空闲内存大小达到某个阈值，并且<code>top chunk</code>的大小也超过了收缩阈值，会执行内存收缩，减小<code>top chunk</code>的大小，但至少要保留一个页大小的空闲内存，从而把内存归还给操作系统。如果向主分配区的<code>top chunk</code>申请内存，而<code>top chunk</code>中没有空闲内存，<code>ptmalloc</code>会调用<code>sbrk()</code>将进程<code>heap</code>的边界<code>brk</code>上移，然后修改<code>top chunk</code>的大小。</p>
<h5 id="mmaped-chunk"><a href="#mmaped-chunk" class="headerlink" title="mmaped chunk"></a>mmaped chunk</h5><p>当需要分配的<code>chunk</code>足够大，而且<code>fast bins</code>和<code>bins</code>都不能满足要求，甚至<code>top chunk</code>本身也不能满足分配需求时，<code>ptmalloc</code>会使用<code>mmap</code>来直接使用内存映射来将页映射到进程空间。这样分配的<code>chunk</code>在被<code>free</code>时将直接解除映射，于是就将内存归还给了操作系统，再次对这样的内存区的引用将导致<code>segmentation fault</code>错误。这样的<code>chunk</code>也不会包含在任何<code>bin</code>中。</p>
<h5 id="Last-remainder"><a href="#Last-remainder" class="headerlink" title="Last remainder"></a>Last remainder</h5><p><code>last remainder</code>是另外一种特殊的<code>chunk</code>，就像<code>top chunk</code>和<code>mmaped chunk</code>一样，不会在任何<code>bins</code>中找到这种<code>chunk</code>。当需要分配一个<code>small chunk</code>，但在<code>small bins</code>中找不到合适的<code>chunk</code>，如果<code>last remainder chunk</code>的大小大于所需的<code>small chunk</code>大小，<code>last remainder chunk</code>被分裂成两个<code>chunk</code>，其中一个<code>chunk</code>返回给用户，另一个<code>chunk</code>变成新的<code>last remainder chuk</code>。</p>
<h4 id="sbrk与mmap"><a href="#sbrk与mmap" class="headerlink" title="sbrk与mmap"></a>sbrk与mmap</h4><p>从进程的内存布局可知，<code>.bss</code>段之上的这块分配给用户程序的空间被称为<code>heap</code>（堆）。<code>start_brk</code>指向<code>heap</code>的开始，而<code>brk</code>指向<code>heap</code>的顶部。可以使用系统调用<code>brk()</code>和<code>sbrk()</code>来增加标识<code>heap</code>顶部的<code>brk</code>值，从而线性的增加分配给用户的<code>heap</code>空间。在使<code>malloc</code>之前，<code>brk</code>的值等于<code>start_brk</code>，也就是说<code>heap</code>大小为0。<code>ptmalloc</code>在开始时，若请求的空间小于<code>mmap</code>分配阈值（<code>mmap threshold</code>，默认值为128KB）时，主分配区会调用<code>sbrk()</code>增加一块大小为<code>(128KB + chunk_size) align 4KB</code>的空间作为<code>heap</code>。非主分配区会调用<code>mmap</code>映射一块大小为<code>HEAP_MAX_SIZE</code>（32位系统上默认为<code>1MB</code>，64位系统上默认为<code>64MB</code>）的空间作为<code>sub-heap</code>。</p>
<p>这就是前面所说的<code>ptmalloc</code>所维护的分配空间，当用户请求内存分配时，首先会在这个区域内找一块合适的<code>chunk</code>给用户。当用户释放了<code>heap</code>中的<code>chunk</code>时，<code>ptmalloc</code>又会使用<code>fast bins</code>和<code>bins</code>来组织空闲<code>chunk</code>。以备用户的下一次分配。若需要分配的<code>chunk</code>大小小于<code>mmap</code>分配阈值，而<code>heap</code>空间又不够，则此时主分配区会通过<code>sbrk()</code>调用来增加<code>heap</code>大小，非主分配区会调用<code>mmap</code>映射一块新的<code>sub-heap</code>，也就是增加<code>top chunk</code>的大小，每次<code>heap</code>增加的值都会对齐到<code>4KB</code>。</p>
<p>当用户的请求超过<code>mmap</code>分配阈值，并且主分配区使用<code>sbrk()</code>分配失败的时候，或是非主分配区在<code>top chunk</code>中不能分配到需要的内存时，<code>ptmalloc</code>会尝试使用<code>mmap()</code>直接映射一块内存到进程内存空间。使用<code>mmap()</code>直接映射的<code>chunk</code>在释放时直接解除映射，而不再属于进程的内存空间。任何对该内存的访问都会产生段错误。而在<code>heap</code>中或是<code>sub-heap</code>中分配的空间则可能会留在进程内存空间内，还可以再次引用（当然是很危险的）。</p>
<p>当<code>ptmalloc munmap chunk</code>时，如果回收的<code>chunk</code>空间大小大于<code>mmap</code>分配阈值的当前值，并且小于<code>DEFAULT_MMAP_THRESHOLD_MAX</code>（32位系统默认为<code>512KB</code>，64位系统默认为32MB），<code>ptmalloc</code>会把<code>mmap</code>分配阈值调整为当前回收的<code>chunk</code>的大小，并将<code>mmap</code>收缩阈值（mmap trim threshold）设置为<code>mmap</code>分配阈值的2倍。这就是<code>ptmalloc</code>的对<code>mmap</code>分配阈值的动态调整机制，该机制是默认开启的，当然也可以用<code>mallopt()</code>关闭该机制。</p>
<h3 id="内存分配概述"><a href="#内存分配概述" class="headerlink" title="内存分配概述"></a>内存分配概述</h3><h4 id="分配算法概述"><a href="#分配算法概述" class="headerlink" title="分配算法概述"></a>分配算法概述</h4><p>以32系统为例，64位系统类似。</p>
<ul>
<li>小于等于64字节：用<code>pool</code>算法分配。</li>
<li>64到512字节之间：在最佳匹配算法分配和<code>pool</code>算法分配中取一种合适的。</li>
<li>大于等于512字节：用最佳匹配算法分配。</li>
<li>大于等于<code>mmap</code>分配阈值（默认值128KB）：根据设置的<code>mmap</code>的分配策略进行分配，如果没有开启<code>mmap</code>分配阈值的动态调整机制，大于等于<code>128KB</code>就直接调用<code>mmap</code>分配。否则，大于等于<code>mmap</code>分配阈值时才直接调用<code>mmap()</code>分配。</li>
</ul>
<p>ptmalloc的响应用户内存分配要求的具体步骤为:</p>
<ol>
<li>获取分配区的锁，为了防止多个线程同时访问同一个分配区，在进行分配之前需要取得分配区域的锁。线程先查看线程私有实例中是否已经存在一个分配区，如果存在尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，否则，该线程搜索分配区循环链表试图获得一个空闲（没有加锁）的分配区。如果所有的分配区都已经加锁，那么<code>ptmalloc</code>会开辟一个新的分配区，把该分配区加入到全局分配区循环链表和线程的私有实例中并加锁，然后使用该分配区进行分配操作。开辟出来的新分配区一定为非主分配区，因为主分配区是从父进程那里继承来的。开辟非主分配区时会调用<code>mmap()</code>创建一个<code>sub-heap</code>，并设置好<code>top chunk</code>。</li>
<li>将用户的请求大小转换为实际需要分配的<code>chunk</code>空间大小。</li>
<li>判断所需分配<code>chunk</code>的大小是否满足<code>chunk_size &lt;= max_fast</code> (<code>max_fast</code>默认为64B)，如果是的话，则转下一步，否则跳到第5步。</li>
<li>首先尝试在<code>fast bins</code>中取一个所需大小的<code>chunk</code>分配给用户。如果可以找到，则分配结束。否则转到下一步。</li>
<li>判断所需大小是否处在<code>small bins</code>中，即判断<code>chunk_size &lt; 512B</code>是否成立。如果<code>chunk</code>大小处在<code>small bins</code>中，则转下一步，否则转到第6步。</li>
<li>根据所需分配的<code>chunk</code>的大小，找到具体所在的某个<code>small bin</code>，从该<code>bin</code>的尾部摘取一个恰好满足大小的<code>chunk</code>。若成功，则分配结束，否则，转到下一步。</li>
<li>到了这一步，说明需要分配的是一块大的内存，或者<code>small bins</code>中找不到合适的<code>chunk</code>。于是，<code>ptmalloc</code>首先会遍历<code>fast bins</code>中的<code>chunk</code>，将相邻的<code>chunk</code>进行合并，并链接到<code>unsorted bin</code>中，然后遍历<code>unsorted bin</code>中的<code>chunk</code>，如果<code>unsorted bin</code>只有一个<code>chunk</code>，并且这个<code>chunk</code>在上次分配时被使用过，并且所需分配的<code>chunk</code>大小属于<code>small bins</code>，并且<code>chunk</code>的大小大于等于需要分配的大小，这种情况下就直接将该<code>chunk</code>进行切割，分配结束，否则将根据<code>chunk</code>的空间大小将其放入<code>small bins</code>或是<code>large bins</code>中，遍历完成后，转入下一步。</li>
<li>到了这一步，说明需要分配的是一块大的内存，或者<code>small bins</code>和<code>unsorted bin</code>中都找不到合适的<code>chunk</code>，并且<code>fast bins</code>和<code>unsorted bin</code>中所有的<code>chunk</code>都清除干净了。从<code>large bins</code>中按照<code>smallest-first</code>，<code>best-fit</code>原则，找一个合适的<code>chunk</code>，从中划分一块所需大小的<code>chunk</code>，并将剩下的部分链接回到<code>bins</code>中。若操作成功，则分配结束，否则转到下一步。</li>
<li>如果搜索<code>fast bins</code>和<code>bins</code>都没有找到合适的<code>chunk</code>，那么就需要操作<code>top chunk</code>来进行分配了。判断<code>top chunk</code>大小是否满足所需<code>chunk</code>的大小，如果是，则从<code>top chunk</code>中分出一块来。否则转到下一步。</li>
<li>到了这一步，说明<code>top chunk</code>也不能满足分配要求，所以，于是就有了两个选择:如果是主分配区，调用<code>sbrk()</code>，增加<code>top chunk</code>大小；如果是非主分配区，调用<code>mmap</code>来分配一个新的<code>sub-heap</code>，增加<code>top chunk</code>大小；或者使用<code>mmap()</code>来直接分配。在这里，需要依靠<code>chunk</code>的大小来决定到底使用哪种方法。判断所需分配的<code>chunk</code>大小是否大于等于<code>mmap</code>分配阈值，如果是的话，则转下一步，调用<code>mmap</code>分配，否则跳到第12步，增加<code>top chunk</code>的大小。</li>
<li>使用<code>mmap</code>系统调用为程序的内存空间映射一块<code>chunk_size align 4kB</code>大小的空间。然后将内存指针返回给用户。</li>
<li>判断是否为第一次调用<code>malloc</code>，若是主分配区，则需要进行一次初始化工作，分配一块大小为<code>(chunk_size + 128KB) align 4KB</code>大小的空间作为初始的<code>heap</code>。若已经初始化过了，主分配区则调用<code>sbrk()</code>增加<code>heap</code>空间，非主分配区则在<code>top chunk</code>中切割出一个<code>chunk</code>，使之满足分配需求，并将内存指针返回给用户。</li>
</ol>
<p>总结一下：根据用户请求分配的内存的大小，<code>ptmalloc</code>有可能会在两个地方为用户分配内存空间。在第一次分配内存时，一般情况下只存在一个主分配区，但也有可能从父进程那里继承来了多个非主分配区，在这里主要讨论主分配区的情况，<code>brk</code>值等于<code>start_brk</code>，所以实际上<code>heap</code>大小为0，<code>top chunk</code>大小也是0。这时，如果不增加<code>heap</code>大小，就不能满足任何分配要求。所以，若用户的请求的内存大小小于<code>mmap</code>分配阈值，则<code>ptmalloc</code>会初始<code>heap</code>。然后在<code>heap</code>中分配空间给用户，以后的分配就基于这个<code>heap</code>进行。若第一次用户的请求就大于<code>mmap</code>分配阈值，则<code>ptmalloc</code>直接使用<code>mmap()</code>分配一块内存给用户，而<code>heap</code>也就没有被初始化，直到用户第一次请求小于<code>mmap</code>分配阈值的内存分配。</p>
<p>第一次以后的分配就比较复杂了，简单说来，<code>ptmalloc</code>首先会查找<code>fast bins</code>，如果不能找到匹配的<code>chunk</code>，则查找<code>small bins</code>。若还是不行，合并<code>fast bins</code>，把<code>chunk</code>加入<code>unsorted bin</code>，在<code>unsorted bin</code>中查找，若还是不行，把<code>unsorted bin</code>中的<code>chunk</code>全加入<code>large bins</code>中，并查找<code>large bins</code>。在<code>fast bins</code>和<code>small bins</code>中的查找都需要精确匹配，而在<code>large bins</code>中查找时，则遵循<code>smallest-first</code>，<code>best-fit</code>的原则，不需要精确匹配。</p>
<p>若以上方法都失败了，则<code>ptmalloc</code>会考虑使用<code>top chunk</code>。若<code>top chunk</code>也不能满足分配要求。而且所需<code>chunk</code>大小大于<code>mmap</code>分配阈值，则使用<code>mmap</code>进行分配。否则增加<code>heap</code>，增大<code>top chunk</code>。以满足分配要求。</p>
<h3 id="内存回收概述"><a href="#内存回收概述" class="headerlink" title="内存回收概述"></a>内存回收概述</h3><p><code>free()</code>函数接受一个指向分配区域的指针作为参数，释放该指针所指向的<code>chunk</code>。而具体的释放方法则看该<code>chunk</code>所处的位置和该<code>chunk</code>的大小。<code>free()</code>函数的工作步骤如下：</p>
<ol>
<li><code>free()</code>函数同样首先需要获取分配区的锁，来保证线程安全。</li>
<li>判断传入的指针是否为0，如果为0，则什么都不做，直接<code>return</code>。否则转下一步。</li>
<li>判断所需释放的<code>chunk</code>是否为<code>mmaped chunk</code>，如果是，则调用<code>munmap()</code>释放<code>mmaped chunk</code>，解除内存空间映射，该该空间不再有效。如果开启了<code>mmap</code>分配阈值的动态调整机制，并且当前回收的<code>chunk</code>大小大于<code>mmap</code>分配阈值，将<code>mmap</code>分配阈值设置为该<code>chunk</code>的大小，将<code>mmap</code>收缩阈值设定为<code>mmap</code>分配阈值的2倍，释放完成，否则跳到下一步。</li>
<li>判断<code>chunk</code>的大小和所处的位置，若<code>chunk_size &lt;= max_fast</code>，并且<code>chunk</code>并不位于<code>heap</code>的顶部，也就是说并不与<code>top chunk</code>相邻，则转到下一步，否则跳到第6步。（因为与<code>top chunk</code>相邻的小<code>chunk</code>也和<code>top chunk</code>进行合并，所以这里不仅需要判断大小，还需要判断相邻情况）</li>
<li>将<code>chunk</code>放到<code>fast bins</code>中，<code>chunk</code>放入到<code>fast bins</code>中时，并不修改该<code>chunk</code>使用状态位<code>P</code>。也不与相邻的<code>chunk</code>进行合并。只是放进去，如此而已。这一步做完之后释放便结束了，程序从<code>free()</code>函数中返回。</li>
<li>判断前一个<code>chunk</code>是否处在使用中，如果前一个块也是空闲块，则合并。并转下一步。</li>
<li>判断当前释放<code>chunk</code>的下一个块是否为<code>top chunk</code>，如果是，则转第9步，否则转下一步。</li>
<li>判断下一个<code>chunk</code>是否处在使用中，如果下一个<code>chunk</code>也是空闲的，则合并，并将合并后的<code>chunk</code>放到<code>unsorted bin</code>中。注意，这里在合并的过程中，要更新<code>chunk</code>的大小，以反映合并后的<code>chunk</code>的大小。并转到第10步。</li>
<li>如果执行到这一步，说明释放了一个与<code>top chunk</code>相邻的<code>chunk</code>。则无论它有多大，都将它与<code>top chunk</code>合并，并更新<code>top chunk</code>的大小等信息。转下一步。</li>
<li>判断合并后的<code>chunk</code>的大小是否大于<code>FASTBIN_CONSOLIDATION_THRESHOLD</code>（默认64KB），如果是的话，则会触发进行<code>fast bins</code>的合并操作，<code>fast bins</code>中的<code>chunk</code>将被遍历，并与相邻的空闲<code>chunk</code>进行合并，合并后的<code>chunk</code>会被放到<code>unsorted bin</code>中。<code>fast bins</code>将变为空，操作完成之后转下一步。</li>
<li>判断<code>top chunk</code>的大小是否大于<code>mmap</code>收缩阈值（默认为128KB），如果是的话，对于主分配区，则会试图归还<code>top chunk</code>中的一部分给操作系统。但是最先分配的<code>128KB</code>空间是不会归还的，<code>ptmalloc</code>会一直管理这部分内存，用于响应用户的分配请求；<ol>
<li>如果为非主分配区，会进行<code>sub-heap</code>收缩，将<code>top chunk</code>的一部分返回给操作系统，</li>
<li>如果<code>top chunk</code>为整个<code>sub-heap</code>，会把整个<code>sub-heap</code>还回给操作系统。</li>
<li>做完这一步之后，释放结束，从<code>free()</code>函数退出。可以看出，收缩堆的条件是当前<code>free</code>的<code>chunk</code>大小加上前后能合并<code>chunk</code>的大小大于<code>64k</code>，并且要<code>top chunk</code>的大小要达到<code>mmap</code>收缩阈值，才有可能收缩堆。</li>
</ol>
</li>
</ol>
<h3 id="配置选项概述"><a href="#配置选项概述" class="headerlink" title="配置选项概述"></a>配置选项概述</h3><p><code>ptmalloc</code>主要提供以下几个配置选项用于调优，这些选项可以通过<code>mallopt()</code>进行设置：</p>
<p><code>M_MXFAST</code>用于设置<code>fast bins</code>中保存的<code>chunk</code>的最大大小，默认值为<code>64B</code>，<code>fast bins</code>中保存的<code>chunk</code>在一段时间内不会被合并，分配小对象时可以首先查找<code>fast bins</code>，如果<code>fast bins</code>找到了所需大小的<code>chunk</code>，就直接返回该<code>chunk</code>，大大提高小对象的分配速度，但这个值设置得过大，会导致大量内存碎片，并且会导致<code>ptmalloc</code>缓存了大量空闲内存，去不能归还给操作系统，导致内存暴增。</p>
<p><code>M_MXFAST</code>的最大值为<code>80B</code>，不能设置比80B更大的值，因为设置为更大的值并不能提高分配的速度。<code>fast bins</code>是为需要分配许多小对象的程序设计的，比如需要分配许多小<code>struct</code>，小对象，小的<code>string</code>等等。</p>
<p>如果设置该选项为0，就会不使用<code>fast bins</code>。</p>
<p><code>M_TRIM_THRESHOLD</code>用于设置<code>mmap</code>收缩阈值，默认值为<code>128KB</code>。自动收缩只会在<code>free</code>时才发生，如果当前<code>free</code>的<code>chunk</code>大小加上前后能合并<code>chunk</code>的大小大于<code>64KB</code>，并且<code>top chunk</code>的大小达到<code>mmap</code>收缩阈值，对于主分配区，调用<code>malloc_trim()</code>返回一部分内存给操作系统，对于非主分配区，调用<code>heap_trim()</code>返回一部分内存给操作系统，在发生内存收缩时，还是从新设置<code>mmap</code>分配阈值和<code>mmap</code>收缩阈值。</p>
<p>这个选项一般与<code>M_MMAP_THRESHOLD</code>选项一起使用，<code>M_MMAP_THRESHOLD</code>用于设置<code>mmap</code>分配阈值，对于长时间运行的程序，需要对这两个选项进行调优，尽量保证在<code>ptmalloc</code>中缓存的空闲<code>chunk</code>能够得到重用，尽量少用<code>mmap</code>分配临时用的内存。不停地使用系统调用<code>mmap</code>分配内存，然后很快又<code>free</code>掉该内存，这样是很浪费系统资源的，并且这样分配的内存的速度比从<code>ptmalloc</code>的空闲<code>chunk</code>中分配内存慢得多，由于需要页对齐导致空间利用率降低，并且操作系统调用<code>mmap()</code>分配内存是串行的，在发生缺页异常时加载新的物理页，需要对新的物理页做清0操作，大大影响效率。</p>
<p><code>M_TRIM_THRESHOLD</code>的值必须设置为页大小对齐，设置为-1会关闭内存收缩设置。</p>
<p>注意：试图在程序开始运行时分配一块大内存，并马上释放掉，以期望来触发内存收缩，这是不可能的，因为该内存马上就返回给操作系统了。</p>
<p><code>M_MMAP_THRESHOLD</code>用于设置<code>mmap</code>分配阈值，默认值为<code>128KB</code>，<code>ptmalloc</code>默认开启动态调整<code>mmap</code>分配阈值和<code>mmap</code>收缩阈值。当用户需要分配的内存大于<code>mmap</code>分配阈值，<code>ptmalloc</code>的<code>malloc()</code>函数其实相当于<code>mmap()</code>的简单封装，<code>free</code>函数相当于<code>munmap()</code>的简单封装。相当于直接通过系统调用分配内存，回收的内存就直接返回给操作系统了。因为这些大块内存不能被<code>ptmalloc</code>缓存管理，不能重用，所以<code>ptmalloc</code>也只有在万不得已的情况下才使用该方式分配内存。</p>
<p>但使用<code>mmap</code>分配有如下的好处：</p>
<ul>
<li><code>mmap</code>的空间可以独立从系统中分配和释放的系统，对于长时间运行的程序，申请长生命周期的大内存块就很适合有这种方式。</li>
<li><code>mmap</code>的空间不会被<code>ptmalloc</code>锁在缓存的<code>chunk</code>中，不会导致<code>ptmalloc</code>内存暴增的问题。</li>
<li>对有些系统的虚拟地址空间存在洞，只能用<code>mmap()</code>进行分配内存，<code>sbrk()</code>不能运行。</li>
</ul>
<p>使用<code>mmap</code>分配内存的缺点：</p>
<ul>
<li>该内存不能被<code>ptmalloc</code>回收再利用。</li>
<li>会导致更多的内存浪费，因为<code>mmap</code>需要按页对齐。</li>
<li>它的分配效率跟操作系统提供的<code>mmap()</code>函数的效率密切相关，<code>Linux</code>系统强制把匿名<code>mmap</code>的内存物理页清0是很低效的。</li>
</ul>
<p>所以用<code>mmap</code>来分配长生命周期的大内存块就是最好的选择，其他情况下都不太高效。</p>
<p><code>M_MMAP_MAX</code>用于设置进程中用<code>mmap</code>分配的内存块的最大限制，默认值为<code>64K</code>，因为有些系统用<code>mmap</code>分配的内存块太多会导致系统的性能下降。如果将<code>M_MMAP_MAX</code>设置为0，<code>ptmalloc</code>将不会使用<code>mmap</code>分配大块内存。<code>ptmalloc</code>为优化锁的竞争开销，做了<code>PER_THREAD</code>的优化，也提供了两个选项，<code>M_ARENA_TEST</code>和<code>M_ARENA_MAX</code>，由于<code>PER_THREAD</code>的优化默认没有开启，这里暂不对这两个选项做介绍。</p>
<p>另外，<code>ptmalloc</code>没有提供关闭<code>mmap</code>分配阈值动态调整机制的选项，<code>mmap</code>分配阈值动态调整时默认开启的，如果要关闭<code>mmap</code>分配阈值动态调整机制，可以设置<code>M_TRIM_THRESHOLD</code>，<code>M_MMAP_THRESHOLD</code>，<code>M_TOP_PAD</code>和<code>M_MMAP_MAX</code>中的任意一个。</p>
<p>但是强烈建议不要关闭该机制，该机制保证了<code>ptmalloc</code>尽量重用缓存中的空闲内存，不用每次对相对大一些的内存使用系统调用<code>mmap</code>去分配内存。</p>
<h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><p>为了避免<code>Glibc</code>内存暴增，使用时需要注意以下几点：</p>
<ol>
<li>后分配的内存先释放，因为<code>ptmalloc</code>收缩内存是从<code>top chunk</code>开始，如果与<code>top chunk</code>相邻的<code>chunk</code>不能释放，<code>top chunk</code>以下的<code>chunk</code>都无法释放。</li>
<li><code>ptmalloc</code>不适合用于管理长生命周期的内存，特别是持续不定期分配和释放长生命周期的内存，这将导致<code>ptmalloc</code>内存暴增。如果要用<code>ptmalloc</code>分配长周期内存，在32位系统上，分配的内存块最好大于<code>1MB</code>，64位系统上，分配的内存块大小大于32MB。这是由于<code>ptmalloc</code>默认开启<code>mmap</code>分配阈值动态调整功能，<code>1MB</code>是32位系统<code>mmap</code>分配阈值的最大值，32MB是64位系统<code>mmap</code>分配阈值的最大值，这样可以保证<code>ptmalloc</code>分配的内存一定是从<code>mmap</code>映射区域分配的，当<code>free</code>时，<code>ptmalloc</code>会直接把该内存返回给操作系统，避免了被<code>ptmalloc</code>缓存。</li>
<li>不要关闭<code>ptmalloc</code>的<code>mmap</code>分配阈值动态调整机制，因为这种机制保证了短生命周期的内存分配尽量从<code>ptmalloc</code>缓存的内存<code>chunk</code>中分配，更高效，浪费更少的内存。如果关闭了该机制，对大于<code>128KB</code>的内存分配就会使用系统调用<code>mmap</code>向操作系统分配内存，使用系统调用分配内存一般会比从<code>ptmalloc</code>缓存的<code>chunk</code>中分配内存慢，特别是在多线程同时分配大内存块时，操作系统会串行调用<code>mmap()</code>，并为发生缺页异常的页加载新物理页时，默认强制清0。频繁使用<code>mmap</code>向操作系统分配内存是相当低效的。使用<code>mmap</code>分配的内存只适合长生命周期的大内存块。</li>
<li>多线程分阶段执行的程序不适合用<code>ptmalloc</code>，这种程序的内存更适合用内存池管理，就像<code>Appach</code>那样，每个连接请求处理分为多个阶段，每个阶段都有自己的内存池，每个阶段完成后，将相关的内存就返回给相关的内存池。<code>ptmalloc</code>假设了线程<code>A</code>释放的内存块能在线程<code>B</code>中得到重用，但<code>B</code>不一定会分配和<code>A</code>线程同样大小的内存块，于是就需要不断地做切割和合并，可能导致内存碎片。</li>
<li>尽量减少程序的线程数量和避免频繁分配/释放内存，<code>ptmalloc</code>在多线程竞争激烈的情况下，首先查看线程私有变量是否存在分配区，如果存在则尝试加锁，如果加锁不成功会尝试其它分配区，如果所有的分配区的锁都被占用着，就会增加一个非主分配区供当前线程使用。由于在多个线程的私有变量中可能会保存同一个分配区，所以当线程较多时，加锁的代价就会上升，<code>ptmalloc</code>分配和回收内存都要对分配区加锁，从而导致了多线程<br>竞争环境下<code>ptmalloc</code>的效率降低。</li>
<li>防止内存泄露，<code>ptmalloc</code>对内存泄露是相当敏感的，根据它的内存收缩机制，如果与<code>top chunk</code>相邻的那个<code>chunk</code>没有回收，将导致<code>top chunk</code>一下很多的空闲内存都无法返回给操作系统。</li>
<li>防止程序分配过多内存，或是由于<code>Glibc</code>内存暴增，导致系统内存耗尽，程序因<code>OOM</code>被系统杀掉。预估程序可以使用的最大物理内存大小，配置系统的<code>/proc/sys/vm/overcommit_memory</code>，<code>/proc/sys/vm/overcommit_ratio</code>，以及使用<code>ulimt –v</code>限制程序能使用虚拟内存空间大小，防止程序因<code>OOM</code>被杀掉。</li>
</ol>
<h1 id="问题分析及解决"><a href="#问题分析及解决" class="headerlink" title="问题分析及解决"></a>问题分析及解决</h1><p>通过前面几节对<code>ptmalloc</code>实现的粗略分析，尝试去分析和解决我们遇到的问题，我们系统遇到的问题是<code>glibc</code>内存暴增，现象是程序已经把内存返回给了<code>Glibc</code>库，但<code>Glibc</code>库却没有把内存归还给操作系统，最终导致系统内存耗尽，程序因为<code>OOM</code>被系统杀掉。原因有如下几点：</p>
<ol>
<li>在64位系统上使用默认的系统配置，也就是说<code>ptmalloc</code>的<code>mmap</code>分配阈值动态调整机制是开启的。我们的<code>NoSql</code>系统经常分配内存为<code>2MB</code>，并且这2MB的内存很快会被释放，在<code>ptmalloc</code>回收2MB内存时，<code>ptmalloc</code>的动态调整机制会认为2MB对我们的系统来说是一个临时的内存分配，每次都用系统调用<code>mmap()</code>向操作系统分配内存，<code>ptmalloc</code>认为这太低效了，于是把<code>mmap</code>的阈值设置成了2MB+4K<code>，当下次再分配2MB的内存时，
尽量从</code>ptmalloc<code>缓存的</code>chunk<code>中分配，缓存的</code>chunk<code>不能满足要求，才考虑调用</code>mmap()`进行分配，提高分配的效率。</li>
<li>系统中分配2M内存的地方主要有两处，一处是全局的内存<code>cache</code>，另一处是网络模块，网络模块每次分配2MB内存用于处理网络的请求，处理完成后就释放该内存。这可以看成是一个短生命周期的内存。内存<code>cache</code>每次分配<code>2MB</code>，但不确定什么时候释放，也不确定下次会什么时候会再分配2MB内存，但有一点可以确定，每次分配的2MB内存，要经过比较长的一段时间才会释放，所以可以看成是长生命周期的内存块，对于这些<code>cache</code>中的多个2M内存块没有使用<code>free list</code>管理，每次都是先从<code>cache</code>中<code>free</code>调用一个2M内存块，再从<code>Glibc</code>中分配一块新的2M内存块。 <code>ptmalloc</code>不擅长管理长生命周期的内存块，<code>ptmalloc</code>设计的假设中就明确假设缓存的内存块都用于短生命周期的内存分配，因为<code>ptmalloc</code>的内存收缩是从<code>top chunk</code>开始，如果与<code>top chunk</code>相邻的那个<code>chunk</code>在我们<code>NoSql</code>的内存池中没有释放，<code>top chunk</code>以下的空闲内存都无法返回给系统，即使这些空闲内存有几十个<code>G</code>也不行。</li>
<li><code>Glibc</code>内存暴增的问题我们定位为全局内存池中的内存块长时间没有释放，其中还有一个原因就是全局内存池会不定期的分配内存，可能下次分配的内存是在<code>top chunk</code>分配的，分配以后又短时间不释放，导致<code>top chunk</code>升到了一个更高的虚拟地址空间，从而使<code>ptmalloc</code>中缓存的内存块更多，但无法返回给操作系统。</li>
<li>另一个原因就是进程的线程数越多，在高压力高并发环境下，频繁分配和释放内存，由于分配内存时锁争用更激烈，<code>ptmalloc</code>会为进程创建更多的分配区，由于我们的全局内存池的长时间不释放内存的缘故，会导致<code>ptmalloc</code>缓存的<code>chunk</code>数量增长得更快，从而更容易重现<code>Glibc</code>内存暴增的问题。</li>
<li>内存池管理内存的方式导致<code>Glibc</code>大量的内存碎片。我们的内存池对于小于等于64K的内存分配，则从内存池中分配64K的内存块，如果内存池中没有，则调用<code>malloc()</code>分配64K的内存块，释放时，该64K的内存块加入内存中，永不还回给操作系统，对于大于64K的内存分配，调用<code>malloc()</code>分配，释放时调用<code>free()</code>函数换回给Glibc。这些大量的64K的内存块长时间存在于内存池中，导致了<code>Glibc</code>中缓存了大量的内存碎片不能释放回<br>操作系统。</li>
</ol>
<p>比如：假如应用层分配内存的顺序是<code>64K</code>，<code>100K</code>，<code>64K</code>，然后释放100K的内存块，Glibc会缓存这个100K的内存块，其中的两个64K内存块都在<code>mempool</code>中，一直不释放，如果下次再分配64K的内存，就会将100K的内存块拆分成64K和36K的两个内存块，64K的内存块返回给应用层，并被<code>mempool</code>缓存，但剩下的36K被<code>Glibc</code>缓存，再也不能被应用层分配了，因为应用层分配的最小内存为64K`，这个36K的内存块就是内存碎片，这也是内存暴增的原因之一。</p>
<p>问题找到了，解决的办法可以参考如下几种:</p>
<ol>
<li>禁用<code>ptmalloc</code>的<code>mmap</code>分配阈值动态调整机制。通过<code>mallopt()</code>设置<code>M_TRIM_THRESHOLD</code>，<code>M_MMAP_THRESHOLD</code>，<code>M_TOP_PAD</code>和<code>M_MMAP_MAX</code>中任意一个，关闭<code>mmap</code>分配阈值动态调整机制，同时需要将<code>mmap</code>分配阈值设置为<code>64K</code>，大于64K的内存分配都使用<code>mmap</code>向系统分配，释放大于64K的内存将调用<code>munmap</code>释放回系统。但强烈建议不要这么做，这会大大降低<code>ptmalloc</code>的分配释放效率。因为系统调用<code>mmap</code>是串行的，操作系统需要对<code>mmap</code>分配内存加锁，而且操作系统对<code>mmap</code>的物理页强制清0很慢。</li>
<li>我们系统的关键问题出在全局内存池，它分配的内存是长生命周期的大内存块，通过前面的分析可知，对长生命周期的大内存块分配最好用<code>mmap</code>系统调用直接向操作系统分配，回收时用<code>munmap</code>返回给操作系统。比如内存池每次用<code>mmap</code>向操作系统分配8M或是更多的虚拟内存。如果非要用<code>ptmalloc</code>的<code>malloc</code>函数分配内存，就得绕过<code>ptmalloc</code>的<code>mmap</code>分配阈值动态调整机制，<code>mmap</code>分配阈值在64位系统上的最大值为<code>32M</code>，如果分配的内存大于<code>32M</code>，可以保证<code>malloc</code>分配的内存肯定是用<code>mmap</code>向操作系统分配的，回收时<code>free</code>一定会返回给操作系统，而不会被<code>ptmalloc</code>缓存用于下一次分配。但是如果这样使用<code>malloc</code>分配的话，其实<code>malloc</code>就是<code>mmap</code>的简单封装，还不如直接使用<code>mmap</code>系统调用想操作系统分配内存来得简单，并且显式调用<code>munmap</code>回收分配的内存，根本不依赖<code>ptmalloc</code>的实现。</li>
<li>改写内存<code>cache</code>，使用<code>free list</code>管理所分配的内存块。使用预分配优化已有的代码，尽量在每个请求过程中少分配内存。并使用线程私有内存块来存放线程所使用的私有实例。这种解决办法也是暂时的。</li>
<li>从长远的设计来看，我们的系统也是分阶段执行的，每次网络请求都会分配2MB为单位内存，请求完成后释放请求锁分配的内存，内存池最适合这种情景的操作。我们的线程池至少需要包含对2MB和几种系统中常用分配大小的支持，采用与<code>TCMalloc</code>类似的无锁设计，使用线程私用变量的形式尽量减少分配时线程对锁的争用。或者直接使用<code>TCMalloc</code>，免去了很多的线程池设计考虑。</li>
</ol>
<h1 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h1><p>本部分主要对源代码实现技巧的细节做分析，希望能进一步理解<code>ptmalloc</code>的实现，做到终极无惑。主要分析的文件包括<code>arena.c</code>和<code>malloc.c</code>，这两个文件包括了<code>ptmalloc</code>的核心实现，其中<code>arena.c</code>主要是对多线程支持的实现，<code>malloc.c</code>定义了公用的<code>malloc()</code>，<code>free()</code>等函数，实现了基于分配区的内存管理算法。</p>
<h2 id="边界标记法"><a href="#边界标记法" class="headerlink" title="边界标记法"></a>边界标记法</h2><p><code>ptmalloc</code>使用<code>chunk</code>实现内存管理，对<code>chunk</code>的管理基于独特的边界标记法。</p>
<p>在不同的平台下，每个<code>chunk</code>的最小大小，地址对齐方式是不同的，<code>ptmalloc</code>依赖平台定义的<code>size_t</code>长度，对于32位平台，<code>size_t</code>长度为4字节，对64位平台，<code>size_t</code>长度可能为4字节，也可能为8字节，在<code>Linux X86_64</code>上<code>size_t</code>为8字节，这里就以<code>size_t</code>为4字节和8字节的情况进行分析。先看一段源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INTERNAL_SIZE_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding word size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_SZ (sizeof(INTERNAL_SIZE_T))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MALLOC_ALIGNMENT is the minimum alignment for malloc&#x27;ed chunks.</span></span><br><span class="line"><span class="comment">It must be a power of two at least 2 * SIZE_SZ, even on machines</span></span><br><span class="line"><span class="comment">for which smaller alignments would suffice. It may be defined as</span></span><br><span class="line"><span class="comment">larger than this though. Note however that code and data structures</span></span><br><span class="line"><span class="comment">are optimized for the case of 8-byte alignment.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT (2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* The corresponding bit mask value */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span><br></pre></td></tr></table></figure>
<p><code>ptmalloc</code>使用宏来屏蔽不同平台的差异，将<code>INTERNAL_SIZE_T</code>定义为<code>size_t</code>，<code>SIZE_SZ</code>定义为<code>size_t</code>的大小，在32位平台下位4字节，在64位平台下位4字节或者8字节。另外分配<code>chunk</code>时必须以<code>2*SIZE_SZ</code>对齐，<code>MALLOC_ALIGNMENT</code>和<code>MALLOC_ALIGN_MASK</code>是用来处理<code>chunk</code>地址对齐的宏。在32平台<code>chunk</code>地址按8字节对齐，64位平台按8字节或是16字节对齐。</p>
<p><code>ptmalloc</code>采用边界标记法将内存划分成很多块，从而对内存的分配与回收进行管理。在<code>ptmalloc</code>的实现源码中定义结构体<code>malloc_chunk</code>来描述这些块，并使用宏封装了对<code>chunk</code>中每个域的读取，修改，校验，遍历等等。<code>malloc_chunk</code>定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">    INTERNAL_SIZE_T prev_size; <span class="comment">/* Size of previous chunk (if free). */</span></span><br><span class="line">    INTERNAL_SIZE_T size; <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only used for large blocks: pointer to next larger size. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>chunk</code>的定义相当简单明了，对各个域做一下简单介绍:</p>
<ul>
<li><code>prev_size</code>:如果前一个<code>chunk</code>是空闲的，该域表示前一个<code>chunk</code>的大小，如果前一个<code>chunk</code>不空闲，该域无意义。</li>
<li><code>size</code>：当前<code>chunk</code>的大小，并且记录了当前<code>chunk</code>和前一个<code>chunk</code>的一些属性，包括前一个<code>chunk</code>是否在使用中，当前<code>chunk</code>是否是通过<code>mmap</code>获得的内存，当前<code>chunk</code>是否属于非主分配区。</li>
<li><code>fd</code>和<code>bk</code>：指针<code>fd</code>和<code>bk</code>只有当该<code>chunk</code>块空闲时才存在，其作用是用于将对应的空闲<code>chunk</code>块加入到空闲<code>chunk</code>块链表中统一管理，如果该<code>chunk</code>块被分配给应用程序使用，那么这两个指针也就没有用（该<code>chunk</code>块已经从空闲链中拆出）了，所以也当作应用程序的使用空间，而不至于浪费。</li>
<li><code>fd_nextsize</code>和<code>bk_nextsize</code>:当当前的<code>chunk</code>存在于<code>large bins</code>中时，<code>large bins</code>中的空闲<code>chunk</code>是按照大小排序的，但同一个大小的<code>chunk</code>可能有多个，增加了这两个字段可以加快遍历空闲<code>chunk</code>，并查找满足需要的空闲<code>chunk</code>，<code>fd_nextsize</code>指向下一个比当前<code>chunk</code>大小大的第一个空闲<code>chunk</code>，<code>bk_nextszie</code>指向前一个比当前<code>chunk</code>大小小的第一个空闲<code>chunk</code>。如果该<code>chunk</code>块被分配给应用程序使用，那么这两个指针也就没有用（该<code>chunk</code>块已经从<code>size</code>链中拆出）了，所以也当作应用程序的使用空间，而不至于浪费。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">malloc_chunk details:</span></span><br><span class="line"><span class="comment">Chunks of memory are maintained using a `boundary tag&#x27; method as</span></span><br><span class="line"><span class="comment">described in e.g., Knuth or Standish. Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">in the front of each chunk and at the end. This makes</span></span><br><span class="line"><span class="comment">consolidating fragmented chunks into bigger chunks very fast. The</span></span><br><span class="line"><span class="comment">size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">in use.</span></span><br><span class="line"><span class="comment">An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment">chunk-&gt;     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            | Size of previous chunk, if allocated  |   |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            | Size of chunk, in bytes               |M|P|</span></span><br><span class="line"><span class="comment">            mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            | User data starts here...                  .</span></span><br><span class="line"><span class="comment">            .                                           .</span></span><br><span class="line"><span class="comment">            .       (malloc_usable_size() bytes)        .</span></span><br><span class="line"><span class="comment">            .                                           |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">        |                 Size of chunk                 |</span></span><br><span class="line"><span class="comment">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">Where &quot;chunk&quot; is the front of the chunk for the purpose of most of</span></span><br><span class="line"><span class="comment">the malloc code, but &quot;mem&quot; is the pointer that is returned to the</span></span><br><span class="line"><span class="comment">user. &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</span></span><br><span class="line"><span class="comment">Chunks always begin on even word boundries, so the mem portion</span></span><br><span class="line"><span class="comment">(which is returned to the user) is also on an even word boundary, and</span></span><br><span class="line"><span class="comment">thus at least double-word aligned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment">chunk-&gt;     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |                   Size of previous chunk                      |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">`head:&#x27;     |                   Size of chunk, in bytes                   |P|</span></span><br><span class="line"><span class="comment">mem-&gt;       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">            |               Unused space (may be 0 bytes long)              .</span></span><br><span class="line"><span class="comment">            .                                                               .</span></span><br><span class="line"><span class="comment">            .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">`foot:&#x27;     |                   Size of chunk, in bytes                     |</span></span><br><span class="line"><span class="comment">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The P (PREV_INUSE) bit, stored in the unused low-order bit of the</span></span><br><span class="line"><span class="comment">chunk size (which is always a multiple of two words), is an in-use</span></span><br><span class="line"><span class="comment">bit for the *previous* chunk. If that bit is *clear*, then the</span></span><br><span class="line"><span class="comment">word before the current chunk size contains the previous chunk</span></span><br><span class="line"><span class="comment">size, and can be used to find the front of the previous chunk.</span></span><br><span class="line"><span class="comment">The very first chunk allocated always has this bit set,</span></span><br><span class="line"><span class="comment">preventing access to non-existent (or non-owned) memory. If</span></span><br><span class="line"><span class="comment">prev_inuse is set for any given chunk, then you CANNOT determine</span></span><br><span class="line"><span class="comment">the size of the previous chunk, and might even get a memory</span></span><br><span class="line"><span class="comment">addressing fault when trying to do so.</span></span><br><span class="line"><span class="comment">Note that the `foot&#x27; of the current chunk is actually represented</span></span><br><span class="line"><span class="comment">as the prev_size of the NEXT chunk. This makes it easier to</span></span><br><span class="line"><span class="comment">deal with alignments etc but can be very confusing when trying</span></span><br><span class="line"><span class="comment">to extend or adapt this code.</span></span><br><span class="line"><span class="comment">The two exceptions to all this are</span></span><br><span class="line"><span class="comment">1. The special chunk `top&#x27; doesn&#x27;t bother using the</span></span><br><span class="line"><span class="comment">trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">that would have to index off it. After initialization, `top&#x27;30</span></span><br><span class="line"><span class="comment">is forced to always exist. If it would become less than</span></span><br><span class="line"><span class="comment">MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment">2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">bit M (IS_MMAPPED) set in their size fields. Because they are</span></span><br><span class="line"><span class="comment">allocated one-by-one, each must contain its own trailing size field.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上面这段注释详细描述了<code>chunk</code>的细节，已分配的<code>chunk</code>和空闲的<code>chunk</code>形式不一样，充分利用空间复用，设计相当的巧妙。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((void_t*)((char*)(p) + 2*SIZE_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE \</span></span><br><span class="line"><span class="meta">(unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line"><span class="meta">((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \</span></span><br><span class="line"><span class="meta">&amp; MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure>
<p>对于已经分配的<code>chunk</code>，通过<code>chunk2mem</code>宏根据<code>chunk</code>地址获得返回给用户的内存地址，反过来通过<code>mem2chunk</code>宏根据<code>mem</code>地址得到<code>chunk</code>地址，<code>chunk</code>的地址是按<code>2*SIZE_SZ</code>对齐的，而<code>chunk</code>结构体的前两个域刚好也是<code>2*SIZE_SZ</code>大小，所以，<code>mem</code>地址也是<code>2*SIZE_SZ</code>对齐的。宏<code>aligned_OK</code>和<code>misaligned_chunk(p)</code>用于校验地址是否是按<code>2*SIZE_SZ</code>对齐的。<code>MIN_CHUNK_SIZE</code>定义了最小的<code>chunk</code>的大小，32位平台上位16字节，64位平台为24字节或是32字节。<code>MINSIZE</code>定义了最小的分配的内存大小，是对<code>MIN_CHUNK_SIZE</code>进行了<br><code>2*SIZE_SZ</code>对齐，地址对齐后与<code>MIN_CHUNK_SIZE</code>的大小仍然是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req) \</span></span><br><span class="line"><span class="meta">((unsigned long)(req) &gt;= \</span></span><br><span class="line"><span class="meta">(unsigned long)(INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req) \</span></span><br><span class="line"><span class="meta">(((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) ? \</span></span><br><span class="line"><span class="meta">MINSIZE : \</span></span><br><span class="line"><span class="meta">((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"><span class="comment">/* Same, except also perform argument check */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz) \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123; \</span></span><br><span class="line"><span class="meta">MALLOC_FAILURE_ACTION; \</span></span><br><span class="line"><span class="meta">return 0; \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">(sz) = request2size(req);</span></span><br></pre></td></tr></table></figure>
<p>这几个宏用于将用户请求的分配大小转换成内部需要分配的<code>chunk</code>大小，这里需要注意的在转换时不但考虑的地址对齐，还额外加上了<code>SIZE_SZ</code>，这意味着<code>ptmalloc</code>分配内存需要一个额外的<code>overhead</code>，为<code>SIZE_SZ</code>字节，通过<code>chunk</code>的空间复用，我们很容易得出这个<code>overhead</code>为<code>SIZE_SZ</code>。</p>
<p>以<code>Linux X86_64</code>平台为例，假设<code>SIZE_SZ</code>为8字节，空闲时，一个<code>chunk</code>中至少要4个<code>size_t</code>（8B）大小的空间，用来存储<code>prev_size</code>，<code>size</code>，<code>fd</code>和<code>bk</code>，也就是<code>MINSIZE</code>（32B），<code>chunk</code>的大小要对齐到<code>2*SIZE_SZ</code>（16B）。当一个<code>chunk</code>处于使用状态时，它的下一个<code>chunk</code>的<code>prev_size</code>域肯定是无效的。所以实际上，这个空间也可以被当前<code>chunk</code>使用。这听起来有点不可思议，但确实是合理空间复用的例子。</p>
<p>故而实际上，一个使用中的<code>chunk</code>的大小的计算公式应该是：<code>in_use_size = (用户请求大小+ 16 - 8 ) align to 8B</code>，这里加16是因为需要存储<code>prev_size</code>和<code>size</code>，但又因为向下一个<code>chunk</code>“借”了<code>8B</code>，所以要减去8，每分配一个<code>chunk</code>的<code>overhead</code>为<code>8B</code>，即<code>SIZE_SZ</code>的大小。最后，因为空闲的<code>chunk</code>和使用中的<code>chunk</code>使用的是同一块空间。所以肯定要取其中最大者作为实际的分配空间。即最终的分配空间<code>chunk_size = max(in_use_size, 32)</code>。这就是当用户请求内存分配时，<code>ptmalloc</code>实际需要分配的内存大小。</p>
<p>注意：如果<code>chunk</code>是由<code>mmap()</code>直接分配的，则该<code>chunk</code>不会有前一个<code>chunk</code>和后一个<code>chunk</code>，所有本<code>chunk</code>没有下一个<code>chunk</code>的<code>prev_size</code>的空间可以“借”，所以对于直接<code>mmap()</code>分配内存的<code>overhead</code>为<code>2*SIZE_SZ</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p) ((p)-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">from a non-main arena. This is only set immediately before handing</span></span><br><span class="line"><span class="comment">the chunk to the user, if necessary. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x432</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for chunk from non-main arena */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>
<p><code>chunk</code>在分割时总是以地址对齐（默认是8字节，可以自由设置，但是8字节是最小值并且设置的值必须是2为底的幂函数值，即是<code>alignment = 2^n</code>，<code>n</code>为整数且<code>n&gt;=3</code>）的方式来进行的，所以用<code>chunk-&gt;size</code>来存储本<code>chunk</code>块大小字节数的话，其末3bit位总是0，因此这三位可以用来存储其它信息，比如：</p>
<ul>
<li>以第0位作为<code>P</code>状态位，标记前一<code>chunk</code>块是否在使用中，为1表示使用，为0表示空闲。</li>
<li>以第1位作为<code>M</code>状态位，标记本<code>chunk</code>块是否是使用<code>mmap()</code>直接从进程的<code>mmap</code>映射区域分配的，为1表示是，为0表示否。</li>
<li>以第2位作为<code>A</code>状态位，标记本<code>chunk</code>是否属于非主分配区，为1表示是，为0表示否。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment">Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS) ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)-&gt;prev_size) ))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char*)(p)) + (s)))</span></span><br></pre></td></tr></table></figure>
<p><code>prev_size</code>字段虽然在当前<code>chunk</code>块结构体内，记录的却是前一个邻接<code>chunk</code>块的信息，这样做的好处就是我们通过本块<code>chunk</code>结构体就可以直接获取到前一<code>chunk</code>块的信息，从而方便做进一步的处理操作。相对的，当前<code>chunk</code>块的<code>foot</code>信息就存在于下一个邻接<code>chunk</code>块的结构体内。字段<code>prev_size</code>记录的什么信息呢？有两种情况：</p>
<ol>
<li>如果前一个邻接<code>chunk</code>块空闲，那么当前<code>chunk</code>块结构体内的<code>prev_size</code>字段记录的是前一个邻接<code>chunk</code>块的大小。这就是由当前<code>chunk</code>指针获得前一个空闲<code>chunk</code>地址的依据。宏<code>prev_chunk(p)</code>就是依赖这个假设实现的。</li>
<li>如果前一个邻接<code>chunk</code>在使用中，则当前<code>chunk</code>的<code>prev_size</code>的空间被前一个<code>chunk</code>借用中，其中的值是前一个<code>chunk</code>的内存内容，对当前<code>chunk</code>没有任何意义。字段<code>size</code>记录了本<code>chunk</code>的大小，无论下一个<code>chunk</code>是空闲状态或是被使用状态，都可以通过本<code>chunk</code>的地址加上本<code>chunk</code>的大小，得到下一个<code>chunk</code>的地址，由于<code>size</code>的低3个<code>bit</code>记录了控制信息，需要屏蔽掉这些控制信息，取出实际的<code>size</code>在进行计算下一个<code>chunk</code>地址，这是<code>next_chunk(p)</code>的实现原理。</li>
</ol>
<p>宏<code>chunksize(p)</code>用于获得<code>chunk</code>的实际大小，需要屏蔽掉<code>size</code>中的控制信息。宏<code>chunk_at_offset(p, s)</code>将<code>p+s</code>的地址强制看作一个<code>chunk</code>。</p>
<p>注意：按照边界标记法，可以有多个连续的并且正在被使用中的<code>chunk</code>块，但是不会有多个连续的空闲<code>chunk</code>块，因为连续的多个空闲<code>chunk</code>块一定会合并成一个大的空闲<code>chunk</code>块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)\</span></span><br><span class="line"><span class="meta">((((mchunkptr)(((char*)(p))+((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse(p)\</span></span><br><span class="line"><span class="meta">((mchunkptr)(((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)\</span></span><br><span class="line"><span class="meta">((mchunkptr)(((char*)(p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size &amp;= ~(PREV_INUSE)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的这一组宏用于<code>check/set/clear</code>当前<code>chunk</code>使用标志位，有当前<code>chunk</code>的使用标志位存储在下一个<code>chunk</code>的<code>size</code>的第0 bit （<code>P</code>状态位），所以首先要获得下一个<code>chunk</code>的地址，然后<code>check/set/clear</code>下一个<code>chunk</code>的<code>size</code>域的第0 bit。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse_bit_at_offset(p, s)\</span></span><br><span class="line"><span class="meta">(((mchunkptr)(((char*)(p)) + (s)))-&gt;size &amp; PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s)\</span></span><br><span class="line"><span class="meta">(((mchunkptr)(((char*)(p)) + (s)))-&gt;size |= PREV_INUSE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse_bit_at_offset(p, s)\</span></span><br><span class="line"><span class="meta">(((mchunkptr)(((char*)(p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span></span><br></pre></td></tr></table></figure>
<p>上面的三个宏用于<code>check/set/clear</code>指定<code>chunk</code>的<code>size</code>域中的使用标志位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s) ((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s) ((p)-&gt;size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s) (((mchunkptr)((char*)(p) + (s)))-&gt;prev_size = (s))</span></span><br></pre></td></tr></table></figure>
<p>宏<code>set_head_size(p, s)</code>用于设置当前<code>chunk</code> <code>p</code>的<code>size</code>域并保留<code>size</code>域的控制信息。宏<code>set_head(p, s)</code>用于设置当前<code>chunk</code> <code>p</code>的<code>size</code>域并忽略已有的<code>size</code>域控制信息。宏<code>set_foot(p, s)</code>用于设置当前<code>chunk</code> <code>p</code>的下一个<code>chunk</code>的<code>prev_size</code>为<code>s</code>，<code>s</code>为当前<code>chunk</code>的<code>size</code>，只有当<code>chunk</code> <code>p</code>为空闲时才能使用这个宏，当前<code>chunk</code>的<code>foot</code>的内存空间存在于下一个<code>chunk</code>，即下一个<code>chunk</code>的<code>prev_size</code>。</p>
<h2 id="分箱式内存管理"><a href="#分箱式内存管理" class="headerlink" title="分箱式内存管理"></a>分箱式内存管理</h2><p>对于空闲的<code>chunk</code>，<code>ptmalloc</code>采用分箱式内存管理方式，根据空闲<code>chunk</code>的大小和处于的状态将其放在四个不同的<code>bin</code>中，这四个空闲<code>chunk</code>的容器包括<code>fast bins</code>，<code>unsorted bin</code>，<code>small bins</code>和<code>large bins</code>。<code>fast bins</code>是小内存块的高速缓存，当一些大小小于64字节的<code>chunk</code>被回收时，首先会放入<code>fast bins</code>中，在分配小内存时，首先会查看<code>fast bins</code>中是否有合适的内存块，如果存在，则直接返回<code>fast bins</code>中的内存块，以加快分配速度。</p>
<p><code>usorted bin</code>只有一个，回收的<code>chunk</code>块必须先放到<code>unsorted bin</code>中，分配内存时会查看<code>unsorted bin</code>中是否有合适的<code>chunk</code>，如果找到满足条件的<code>chunk</code>，则直接返回给用户，否则将<code>unsorted bin</code>的所有<code>chunk</code>放入<code>small bins</code>或是<code>large bins</code>中。</p>
<p><code>small bins</code>用于存放固定大小的<code>chunk</code>，共64个<code>bin</code>，最小的<code>chunk</code>大小为16字节或32字节，每个<code>bin</code>的大小相差8字节或是16字节，当<br>分配小内存块时，采用精确匹配的方式从<code>small bins</code>中查找合适的<code>chunk</code>。</p>
<p><code>large bins</code>用于存储大于等于512B或1024B的空闲<code>chunk</code>，这些<code>chunk</code>使用双向链表的形式按大小顺序排序，分配内存时按最近匹配方式从<code>large bins</code>中分配<code>chunk</code>。</p>
<h3 id="small-bins"><a href="#small-bins" class="headerlink" title="small bins"></a>small bins</h3><p><code>ptmalloc</code>使用<code>small bins</code>管理空闲小<code>chunk</code>，每个<code>small bin</code>中的<code>chunk</code>的大小与<code>bin</code>的<code>index</code>有如下关系：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk_size=2 * SIZE_SZ * index</span><br></pre></td></tr></table></figure></p>
<p>在<code>SIZE_SZ</code>为4B的平台上，<code>small bins</code>中的<code>chunk</code>大小是以<code>8B</code>为公差的等差数列，最大的<code>chunk</code>大小为<code>504B</code>，最小的<code>chunk</code>大小为<code>16B</code>，所以实际共62个bin。分别为<code>16B</code>、<code>24B</code>、<code>32B</code>，„„，<code>504B</code>。在<code>SIZE_SZ</code>为8B的平台上，<code>small bins</code>中的<code>chunk</code>大小是以<code>16B</code>为公差的等差数列，最大的<code>chunk</code>大小为<code>1008B</code>，最小的<code>chunk</code>大小为<code>32B</code>，所以实际共62个<code>bin</code>。分别为<code>32B</code>、<code>48B</code>、<code>64B</code>，„„，<code>1008B</code>。</p>
<p><code>ptmalloc</code>维护了62个双向环形链表（每个链表都具有链表头节点，加头节点的最大作用就是便于对链表内节点的统一处理，即简化编程），每一个链表内的各空闲<code>chunk</code>的大小一致，因此当应用程序需要分配某个字节大小的内存空间时直接在对应的链表内取就可以了，这样既可以很好的满足应用程序的内存空间申请请求而又不会出现太多的内存碎片。我们可以用如下图来表示在<code>SIZE_SZ</code>为4B的平台上<code>ptmalloc</code>对512B字节以下的空闲<code>chunk</code>组织方式（所谓的分箱机制）。<br><img src="/img/1634402543.jpg" alt=""></p>
<h3 id="large-bins"><a href="#large-bins" class="headerlink" title="large bins"></a>large bins</h3><p>在<code>SIZE_SZ</code>为4B的平台上，大于等于512B的空闲<code>chunk</code>，或者，在<code>SIZE_SZ</code>为8B的平台上，大小大于等于1024B的空闲<code>chunk</code>，由<code>sorted bins</code>管理。<code>large bins</code>一共包括63个<code>bin</code>，每个<code>bin</code>中的<code>chunk</code>大小不是一个固定公差的等差数列，而是分成6组<code>bin</code>，每组<code>bin</code>是一个<br>固定公差的等差数列，每组的<code>bin</code>数量依次为32、 16、 8、 4、 2、 1，公差依次为64B、 512B、4096B、 32768B、 262144B等。</p>
<p>以<code>SIZE_SZ</code>为4B的平台为例，第一个<code>large bin</code>的起始<code>chunk</code>大小为<code>512B</code>，共32个<code>bin</code>，公差为<code>64B</code>，等差数列满足如下关系：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk_size=512 + 64 * index</span><br></pre></td></tr></table></figure></p>
<p>第二个<code>large bin</code>的起始<code>chunk</code>大小为第一组<code>bin</code>的结束<code>chunk</code>大小，满足如下关系：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk_size=512 + 64 * 32 + 512 * index</span><br></pre></td></tr></table></figure></p>
<p>同理，我们可计算出每个<code>bin</code>的起始<code>chunk</code>大小和结束<code>chunk</code>大小。这些<code>bin</code>都是很有规律的，其实<code>small bins</code>也是满足类似规律，<code>small bins</code>可以看着是公差为8的等差数列，一共有64个<code>bin</code>（第0和1<code>bin</code>不存在），所以我们可以将<code>small bins</code>和<code>large bins</code>存放在同一个包含128个<code>chunk</code>的数组上，数组的前一部分位<code>small bins</code>，后一部分为<code>large bins</code>，每个<code>bin</code>的<code>index</code>为<code>chunk</code>数组的下标，于是，我们可以根据数组下标计算出该<code>bin</code>的<code>chunk</code>大小（<code>small bins</code>）或是<code>chunk</code>大小范围（<code>large bins</code>），也可以根据需要分配内存块大小计算出所需<code>chunk</code>所属<code>bin</code>的<code>index</code>，<code>ptmalloc</code>使用了一组宏巧妙的实现了这种计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE (NSMALLBINS * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz) \</span></span><br><span class="line"><span class="meta">((unsigned long)(sz) &lt; (unsigned long)MIN_LARGE_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line"><span class="meta">(SMALLBIN_WIDTH == 16 ? (((unsigned)(sz)) &gt;&gt; 4) : (((unsigned)(sz)) &gt;&gt; 3))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz) \</span></span><br><span class="line"><span class="meta">(((((unsigned long)(sz)) &gt;&gt; 6) <span class="string">&lt;= 38)? 56 + (((unsigned long)(sz)) &gt;</span>&gt; 6): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 9) <span class="string">&lt;= 20)? 91 + (((unsigned long)(sz)) &gt;</span>&gt; 9): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 12) <span class="string">&lt;= 10)? 110 + (((unsigned long)(sz)) &gt;</span>&gt; 12): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 15) <span class="string">&lt;= 4)? 119 + (((unsigned long)(sz)) &gt;</span>&gt; 15): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 18) <span class="string">&lt;= 2)? 124 + (((unsigned long)(sz)) &gt;</span>&gt; 18): \</span></span><br><span class="line"><span class="meta">126)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz) \</span></span><br><span class="line"><span class="meta">(((((unsigned long)(sz)) &gt;&gt; 6) <span class="string">&lt;= 48)? 48 + (((unsigned long)(sz)) &gt;</span>&gt; 6): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 9) <span class="string">&lt;= 20)? 91 + (((unsigned long)(sz)) &gt;</span>&gt; 9): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 12) <span class="string">&lt;= 10)? 110 + (((unsigned long)(sz)) &gt;</span>&gt; 12): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 15) <span class="string">&lt;= 4)? 119 + (((unsigned long)(sz)) &gt;</span>&gt; 15): \</span></span><br><span class="line"><span class="meta">((((unsigned long)(sz)) &gt;&gt; 18) <span class="string">&lt;= 2)? 124 + (((unsigned long)(sz)) &gt;</span>&gt; 18): \</span></span><br><span class="line"><span class="meta">126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz) \</span></span><br><span class="line"><span class="meta">(SIZE_SZ == 8 ? largebin_index_64 (sz) : largebin_index_32 (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_index(sz) \</span></span><br><span class="line"><span class="meta">((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))</span></span><br></pre></td></tr></table></figure>
<p>宏<code>bin_index(sz)</code>根据所需内存大小计算出所需<code>bin</code>的<code>index</code>，如果所需内存大小属于<code>small bins</code>的大小范围，调用<code>smallbin_index(sz)</code>，否则调用<code>largebin_index(sz))</code>。<code>smallbin_index(sz)</code>的计算相当简单，如果<code>SIZE_SZ</code>为<code>4B</code>，则将<code>sz</code>除以8，如果<code>SIZE_SZ</code>为<code>8B</code>，则将<code>sz</code>除以16，也就是除以<code>small bins</code>中等差数列的公差。<code>largebin_index(sz)</code>的计算相对复杂一些，可以用如下的表格直观的显示<code>chunk</code>的大小范围与<code>bin index</code>的关系。以<code>SIZE_SZ</code>为4B的平台为例，<code>chunk</code>大小与<code>bin index</code>的对应关系如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>开始(字节)</th>
<th>结束（字节）</th>
<th>Bin index</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>7</td>
<td>不存在</td>
</tr>
<tr>
<td>8</td>
<td>15</td>
<td>不存在</td>
</tr>
<tr>
<td>16</td>
<td>23</td>
<td>2</td>
</tr>
<tr>
<td>24</td>
<td>31</td>
<td>3</td>
</tr>
<tr>
<td>32</td>
<td>39</td>
<td>4</td>
</tr>
<tr>
<td>40</td>
<td>47</td>
<td>5</td>
</tr>
<tr>
<td>48</td>
<td>55</td>
<td>6</td>
</tr>
<tr>
<td>56</td>
<td>63</td>
<td>7</td>
</tr>
<tr>
<td>64</td>
<td>71</td>
<td>8</td>
</tr>
<tr>
<td>72</td>
<td>79</td>
<td>9</td>
</tr>
<tr>
<td>80</td>
<td>87</td>
<td>10</td>
</tr>
<tr>
<td>88</td>
<td>95</td>
<td>11</td>
</tr>
<tr>
<td>96</td>
<td>103</td>
<td>12</td>
</tr>
<tr>
<td>104</td>
<td>111</td>
<td>13</td>
</tr>
<tr>
<td>112</td>
<td>119</td>
<td>14</td>
</tr>
<tr>
<td>120</td>
<td>127</td>
<td>15</td>
</tr>
<tr>
<td>128</td>
<td>135</td>
<td>16</td>
</tr>
<tr>
<td>136</td>
<td>143</td>
<td>17</td>
</tr>
<tr>
<td>144</td>
<td>151</td>
<td>18</td>
</tr>
<tr>
<td>152</td>
<td>159</td>
<td>19</td>
</tr>
<tr>
<td>160</td>
<td>167</td>
<td>20</td>
</tr>
<tr>
<td>168</td>
<td>175</td>
<td>21</td>
</tr>
<tr>
<td>176</td>
<td>183</td>
<td>22</td>
</tr>
<tr>
<td>184</td>
<td>191</td>
<td>23</td>
</tr>
<tr>
<td>192</td>
<td>199</td>
<td>24</td>
</tr>
<tr>
<td>200</td>
<td>207</td>
<td>25</td>
</tr>
<tr>
<td>208</td>
<td>215</td>
<td>26</td>
</tr>
<tr>
<td>216</td>
<td>223</td>
<td>27</td>
</tr>
<tr>
<td>224</td>
<td>231</td>
<td>28</td>
</tr>
<tr>
<td>232</td>
<td>239</td>
<td>29</td>
</tr>
<tr>
<td>240</td>
<td>247</td>
<td>30</td>
</tr>
<tr>
<td>248</td>
<td>255</td>
<td>31</td>
</tr>
<tr>
<td>256</td>
<td>263</td>
<td>32</td>
</tr>
<tr>
<td>264</td>
<td>271</td>
<td>33</td>
</tr>
<tr>
<td>272</td>
<td>279</td>
<td>34</td>
</tr>
<tr>
<td>280</td>
<td>287</td>
<td>35</td>
</tr>
<tr>
<td>288</td>
<td>295</td>
<td>36</td>
</tr>
<tr>
<td>296</td>
<td>303</td>
<td>37</td>
</tr>
<tr>
<td>304</td>
<td>311</td>
<td>38</td>
</tr>
<tr>
<td>312</td>
<td>319</td>
<td>39</td>
</tr>
<tr>
<td>320</td>
<td>327</td>
<td>40</td>
</tr>
<tr>
<td>328</td>
<td>335</td>
<td>41</td>
</tr>
<tr>
<td>336</td>
<td>343</td>
<td>42</td>
</tr>
<tr>
<td>344</td>
<td>351</td>
<td>43</td>
</tr>
<tr>
<td>352</td>
<td>359</td>
<td>44</td>
</tr>
<tr>
<td>360</td>
<td>367</td>
<td>45</td>
</tr>
<tr>
<td>368</td>
<td>375</td>
<td>46</td>
</tr>
<tr>
<td>376</td>
<td>383</td>
<td>47</td>
</tr>
<tr>
<td>384</td>
<td>391</td>
<td>48</td>
</tr>
<tr>
<td>392</td>
<td>399</td>
<td>49</td>
</tr>
<tr>
<td>400</td>
<td>407</td>
<td>50</td>
</tr>
<tr>
<td>408</td>
<td>415</td>
<td>51</td>
</tr>
<tr>
<td>416</td>
<td>423</td>
<td>52</td>
</tr>
<tr>
<td>424</td>
<td>431</td>
<td>53</td>
</tr>
<tr>
<td>432</td>
<td>439</td>
<td>54</td>
</tr>
<tr>
<td>440</td>
<td>447</td>
<td>55</td>
</tr>
<tr>
<td>448</td>
<td>455</td>
<td>56</td>
</tr>
<tr>
<td>456</td>
<td>463</td>
<td>57</td>
</tr>
<tr>
<td>464</td>
<td>471</td>
<td>58</td>
</tr>
<tr>
<td>472</td>
<td>479</td>
<td>59</td>
</tr>
<tr>
<td>480</td>
<td>487</td>
<td>60</td>
</tr>
<tr>
<td>488</td>
<td>495</td>
<td>61</td>
</tr>
<tr>
<td>496</td>
<td>503</td>
<td>62</td>
</tr>
<tr>
<td>504</td>
<td>511</td>
<td>63</td>
</tr>
<tr>
<td>512</td>
<td>575</td>
<td>64</td>
</tr>
<tr>
<td>576</td>
<td>639</td>
<td>65</td>
</tr>
<tr>
<td>640</td>
<td>703</td>
<td>66</td>
</tr>
<tr>
<td>704</td>
<td>767</td>
<td>67</td>
</tr>
<tr>
<td>768</td>
<td>831</td>
<td>68</td>
</tr>
<tr>
<td>832</td>
<td>895</td>
<td>69</td>
</tr>
<tr>
<td>896</td>
<td>959</td>
<td>70</td>
</tr>
<tr>
<td>960</td>
<td>1023</td>
<td>71</td>
</tr>
<tr>
<td>1024</td>
<td>1087</td>
<td>72</td>
</tr>
<tr>
<td>1088</td>
<td>1151</td>
<td>73</td>
</tr>
<tr>
<td>1152</td>
<td>1215</td>
<td>74</td>
</tr>
<tr>
<td>1216</td>
<td>1279</td>
<td>75</td>
</tr>
<tr>
<td>1280</td>
<td>1343</td>
<td>76</td>
</tr>
<tr>
<td>1344</td>
<td>1407</td>
<td>77</td>
</tr>
<tr>
<td>1408</td>
<td>1471</td>
<td>78</td>
</tr>
<tr>
<td>1472</td>
<td>1535</td>
<td>79</td>
</tr>
<tr>
<td>1536</td>
<td>1599</td>
<td>80</td>
</tr>
<tr>
<td>1600</td>
<td>1663</td>
<td>81</td>
</tr>
<tr>
<td>1664</td>
<td>1727</td>
<td>82</td>
</tr>
<tr>
<td>1728</td>
<td>1791</td>
<td>83</td>
</tr>
<tr>
<td>1792</td>
<td>1855</td>
<td>84</td>
</tr>
<tr>
<td>1856</td>
<td>1919</td>
<td>85</td>
</tr>
<tr>
<td>1920</td>
<td>1983</td>
<td>86</td>
</tr>
<tr>
<td>1984</td>
<td>2047</td>
<td>87</td>
</tr>
<tr>
<td>2048</td>
<td>2111</td>
<td>88</td>
</tr>
<tr>
<td>2112</td>
<td>2175</td>
<td>89</td>
</tr>
<tr>
<td>2176</td>
<td>2239</td>
<td>90</td>
</tr>
<tr>
<td>2240</td>
<td>2303</td>
<td>91</td>
</tr>
<tr>
<td>2304</td>
<td>2367</td>
<td>92</td>
</tr>
<tr>
<td>2368</td>
<td>2431</td>
<td>93</td>
</tr>
<tr>
<td>2432</td>
<td>2495</td>
<td>94</td>
</tr>
<tr>
<td>2496</td>
<td>2559</td>
<td>95</td>
</tr>
<tr>
<td>2560</td>
<td>3071</td>
<td>96</td>
</tr>
<tr>
<td>3072</td>
<td>3583</td>
<td>97</td>
</tr>
<tr>
<td>3584</td>
<td>4095</td>
<td>98</td>
</tr>
<tr>
<td>4096</td>
<td>4607</td>
<td>99</td>
</tr>
<tr>
<td>4608</td>
<td>5119</td>
<td>100</td>
</tr>
<tr>
<td>5120</td>
<td>5631</td>
<td>101</td>
</tr>
<tr>
<td>5632</td>
<td>6143</td>
<td>102</td>
</tr>
<tr>
<td>6144</td>
<td>6655</td>
<td>103</td>
</tr>
<tr>
<td>6656</td>
<td>7167</td>
<td>104</td>
</tr>
<tr>
<td>7168</td>
<td>7679</td>
<td>105</td>
</tr>
<tr>
<td>7680</td>
<td>8191</td>
<td>106</td>
</tr>
<tr>
<td>8192</td>
<td>8703</td>
<td>107</td>
</tr>
<tr>
<td>8704</td>
<td>9215</td>
<td>108</td>
</tr>
<tr>
<td>9216</td>
<td>9727</td>
<td>109</td>
</tr>
<tr>
<td>9728</td>
<td>10239</td>
<td>110</td>
</tr>
<tr>
<td>10240</td>
<td>10751</td>
<td>111</td>
</tr>
<tr>
<td>10752</td>
<td>14847</td>
<td>112</td>
</tr>
<tr>
<td>14848</td>
<td>18943</td>
<td>113</td>
</tr>
<tr>
<td>18944</td>
<td>23039</td>
<td>114</td>
</tr>
<tr>
<td>23040</td>
<td>27135</td>
<td>115</td>
</tr>
<tr>
<td>27136</td>
<td>31231</td>
<td>116</td>
</tr>
<tr>
<td>31232</td>
<td>35327</td>
<td>117</td>
</tr>
<tr>
<td>35328</td>
<td>39423</td>
<td>118</td>
</tr>
<tr>
<td>39424</td>
<td>43519</td>
<td>119</td>
</tr>
<tr>
<td>43520</td>
<td>76287</td>
<td>120</td>
</tr>
<tr>
<td>76288</td>
<td>109055</td>
<td>121</td>
</tr>
<tr>
<td>109056</td>
<td>141823</td>
<td>122</td>
</tr>
<tr>
<td>141824</td>
<td>174591</td>
<td>123</td>
</tr>
<tr>
<td>174592</td>
<td>436735</td>
<td>124</td>
</tr>
<tr>
<td>436736</td>
<td>698879</td>
<td>125</td>
</tr>
<tr>
<td>698880</td>
<td>2^32或2^64</td>
<td>126</td>
</tr>
</tbody>
</table>
</div>
<p>注意：上表是<code>chunk</code>大小与<code>bin index</code>的对应关系，如果对于用户要分配的内存大小<code>size</code>，必须先使用<code>checked_request2size(req, sz)</code>计算出<code>chunk</code>的大小，再使用<code>bin_index(sz)</code>计算出<code>chunk</code>所属的<code>bin index</code>。</p>
<p>对于<code>SIZE_SZ</code>为4B的平台，<code>bin[0]</code>和<code>bin[1]</code>是不存在的，因为最小的<code>chunk</code>为<code>16B</code>，<code>small bins</code>一共62个，<code>large bins</code>一共63个，加起来一共125个<code>bin</code>。而<code>NBINS</code>定义为128，其实<code>bin[0]</code>和<code>bin[127]</code>都不存在，<code>bin[1]</code>为<code>unsorted bin</code>的<code>chunk</code>链表头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">(mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2])) \</span></span><br><span class="line"><span class="meta">- offsetof (struct malloc_chunk, fd))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b) ((mbinptr)((char*)(b) + (sizeof(mchunkptr)&lt;&lt;1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b) ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b) ((b)-&gt;bk)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(P, BK, FD) &#123; \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd; \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \</span></span><br><span class="line"><span class="meta">        malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P); \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123; \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK; \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size) \</span></span><br><span class="line"><span class="meta">        &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; \</span></span><br><span class="line"><span class="meta">            assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P); \</span></span><br><span class="line"><span class="meta">            assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123; \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P) \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> &#123; \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \</span></span><br><span class="line"><span class="meta">                &#125; \</span></span><br><span class="line"><span class="meta">            &#125; <span class="keyword">else</span> &#123; \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \</span></span><br><span class="line"><span class="meta">            &#125; \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>宏<code>bin_at(m, i)</code>通过<code>bin index</code>获得<code>bin</code>的链表头，<code>chunk</code>中的<code>fb</code>和<code>bk</code>用于将空闲<code>chunk</code>链入链表中，而对于每个<code>bin</code>的链表头，只需要这两个域就可以了，<code>prev_size</code>和<code>size</code>对链表都来说都没有意义，浪费空间，<code>ptmalloc</code>为了节约这点内存空间，增大<code>cpu</code>高速缓存的命中率，在<code>bins</code>数组中只为每个<code>bin</code>预留了两个指针的内存空间用于存放<code>bin</code>的链表头的<code>fb</code>和<code>bk</code>指针。</p>
<p>从<code>bin_at(m, i)</code>的定义可以看出，<code>bin[0]</code>不存在，以<code>SIZE_SZ</code>为4B的平台为例，<code>bin[1]</code>的前4B存储的是指针<code>fb</code>，后4B存储的是指针<code>bk</code>，而<code>bin_at</code>返回的是<code>malloc_chunk</code>的指针，由于<code>fb</code>在<code>malloc_chunk</code>的偏移地址为<code>offsetof (struct malloc_chunk, fd))=8</code>，所以用<code>fb</code>的地址减去8就得到<code>malloc_chunk</code>的地址。但切记，对<code>bin</code>的链表头的<code>chunk</code>，一定不能修改<code>prev_size</code>和<code>size</code>域，这两个域是与其他<code>bin</code>的链表头的<code>fb</code>和<code>bk</code>内存复用的。</p>
<p>宏<code>next_bin(b)</code>用于获得下一个<code>bin</code>的地址，根据前面的分析，我们知道只需要将当前<code>bin</code>的地址向后移动两个指针的长度就得到下一个<code>bin</code>的链表头地址。每个<code>bin</code>使用双向循环链表管理空闲<code>chunk</code>，<code>bin</code>的链表头的指针<code>fb</code>指向第一个可用的<code>chunk</code>，指针<code>bk</code>指向最后一个可用的<code>chunk</code>。</p>
<p>宏<code>first(b)</code>用于获得<code>bin</code>的第一个可用<code>chunk</code>，宏<code>last(b)</code>用于获得<code>bin</code>的最后一个可用的<code>chunk</code>，这两个宏便于遍历<code>bin</code>，而跳过<code>bin</code>的链表头。</p>
<p>宏<code>unlink(P, BK, FD)</code>用于将<code>chunk</code>从所在的空闲链表中取出来，注意<code>large bins</code>中的空闲<code>chunk</code>可能处于两个双向循环链表中，<code>unlink</code>时需要从两个链表中都删除。</p>
<h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p><code>unsorted bin</code>可以看作是<code>small bins</code>和<code>large bins</code>的<code>cache</code>，只有一个<code>unsorted bin</code>，以双向链表管理空闲<code>chunk</code>，空闲<code>chunk</code>不排序，所有的<code>chunk</code>在回收时都要先放到<code>unsorted bin</code>中，分配时，如果在<code>unsorted bin</code>中没有合适的<code>chunk</code>，就会把<code>unsorted bin</code>中的所有<code>chunk</code>分别加入到所属的<code>bin</code>中，然后再在<code>bin</code>中分配合适的<code>chunk</code>。<code>bins</code>数组中的元素<code>bin[1]</code>用于存储<code>unsorted bin</code>的<code>chunk</code>链表头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Unsorted chunks</span></span><br><span class="line"><span class="comment">All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment">in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment">The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Top</span></span><br><span class="line"><span class="comment">The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment">available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment">any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment">released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment">M_TRIM_THRESHOLD). Because top initially</span></span><br><span class="line"><span class="comment">points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment">extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment">code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment">need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment">initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment">interval between initialization and the first call to</span></span><br><span class="line"><span class="comment">sYSMALLOc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment">the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> initial_top(M) (unsorted_chunks(M))</span></span><br></pre></td></tr></table></figure>
<p>上面的宏的定义比较明显，把<code>bin[1]</code>设置为<code>unsorted bin</code>的<code>chunk</code>链表头，对<code>top chunk</code>的初始化，也暂时把<code>top chunk</code>初始化为<code>unsorted chunk</code>，仅仅是初始化一个值而已，这个<code>chunk</code>的内容肯定不能用于<code>top chunk</code>来分配内存，主要原因是<code>top chunk</code>不属于任何<code>bin</code>，但<code>ptmalloc</code>中的一些<code>check</code>代码，可能需要<code>top chunk</code>属于一个合法的<code>bin</code>。</p>
<h3 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h3><p><code>fast bins</code>主要是用于提高小内存的分配效率，默认情况下，对于<code>SIZE_SZ</code>为4B的平台，小于<code>64B</code>的<code>chunk</code>分配请求，对于<code>SIZE_SZ</code>为8B的平台，小于128B的<code>chunk</code>分配请求，首先会查找<code>fast bins</code>中是否有所需大小的<code>chunk</code>存在（精确匹配），如果存在，就直接返回。<code>fast bins</code>可以看着是<code>small bins</code>的一小部分<code>cache</code>，默认情况下，<code>fast bins</code>只<code>cache</code>了<code>small bins</code>的前7个大小的空闲<code>chunk</code>，也就是说，对于<code>SIZE_SZ</code>为4B的平台，<code>fast bins</code>有7个<code>chunk</code>空闲链表（bin），每个<code>bin</code>的<code>chunk</code>大小依次为<code>16B</code>，<code>24B</code>，<code>32B</code>，<code>40B</code>，<code>48B</code>，<code>56B</code>，<code>64B</code>；对于<code>SIZE_SZ</code>为8B的平台，<code>fast bins</code>有7个<code>chunk</code>空闲链表（bin），每个<code>bin</code>的<code>chunk</code>大小依次为<code>32B</code>，<code>48B</code>，<code>64B</code>，<code>80B</code>，<code>96B</code>，<code>112B</code>，<code>128B</code>。以32为系统为例，分配的内存大小与<code>chunk</code>大小和<code>fast bins</code>的对应关系如下表所示：<br><img src="/img/1634435791.jpg" alt=""></p>
<p><code>fast bins</code>可以看着是<code>LIFO</code>的栈，使用单向链表实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Fastbins</span></span><br><span class="line"><span class="comment">An array of lists holding recently freed small chunks. Fastbins</span></span><br><span class="line"><span class="comment">are not doubly linked. It is faster to single-link them, and</span></span><br><span class="line"><span class="comment">since chunks are never removed from the middles of these lists,</span></span><br><span class="line"><span class="comment">double linking is not necessary. Also, unlike regular bins, they</span></span><br><span class="line"><span class="comment">are not even processed in FIFO order (they use faster LIFO) since</span></span><br><span class="line"><span class="comment">ordering doesn&#x27;t much matter in the transient contexts in which</span></span><br><span class="line"><span class="comment">fastbins are normally used.</span></span><br><span class="line"><span class="comment">Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="comment">be consolidated with other free chunks. malloc_consolidate43</span></span><br><span class="line"><span class="comment">releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="comment">other free chunks.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mfastbinptr</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br></pre></td></tr></table></figure>
<p>根据<code>fast bin</code>的<code>index</code>，获得<code>fast bin</code>的地址。<code>fast bins</code>的数字定义在<code>malloc_state</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">((((unsigned int)(sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure>
<p>宏<code>fastbin_index(sz)</code>用于获得<code>fast bin</code>在<code>fast bins</code>数组中的<code>index</code>，由于<code>bin[0]</code>和<code>bin[1]</code>中的<code>chunk</code>不存在，所以需要减2，对于<code>SIZE_SZ</code>为4B的平台，将<code>sz</code>除以8减2得到<code>fast bin index</code>，对于<code>SIZE_SZ</code>为8B的平台，将<code>sz</code>除以16减去2得到<code>fast bin index</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE))+1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span></span><br><span class="line"><span class="comment">that triggers automatic consolidation of possibly-surrounding</span></span><br><span class="line"><span class="comment">fastbin chunks. This is a heuristic, so the exact value should not</span></span><br><span class="line"><span class="comment">matter too much. It is defined at half the default trim threshold as a</span></span><br><span class="line"><span class="comment">compromise heuristic to only attempt consolidation if it is likely</span></span><br><span class="line"><span class="comment">to lead to trimming. However, it is not dynamically tunable, since</span></span><br><span class="line"><span class="comment">consolidation reduces fragmentation surrounding large chunks even</span></span><br><span class="line"><span class="comment">if trimming is not used.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span></span><br></pre></td></tr></table></figure>
<p>根据<code>SIZE_SZ</code>的不同大小，定义<code>MAX_FAST_SIZE</code>为<code>80B</code>或是<code>160B</code>，<code>fast bins</code>数组的大小<code>NFASTBINS</code>为10，<code>FASTBIN_CONSOLIDATION_THRESHOLD</code>为<code>64k</code>，当每次释放的<code>chunk</code>与该<code>chunk</code>相邻的空闲<code>chunk</code>合并后的大小大于64K时，就认为内存碎片可能比较多了，就需要把<code>fast bins</code>中的所有<code>chunk</code>都进行合并，以减少内存碎片对系统的影响。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Set value of max_fast.</span></span><br><span class="line"><span class="comment">Use impossibly small value if 0.</span></span><br><span class="line"><span class="comment">Precondition: there are no existing fastbin chunks.</span></span><br><span class="line"><span class="comment">Setting the value clears fastchunk bit but preserves noncontiguous bit.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s) \</span></span><br><span class="line"><span class="meta">global_max_fast = (((s) == 0) \</span></span><br><span class="line"><span class="meta">? SMALLBIN_WIDTH: ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br></pre></td></tr></table></figure>
<p>上面的宏<code>DEFAULT_MXFAST</code>定义了默认的<code>fast bins</code>中最大的<code>chunk</code>大小，对于<code>SIZE_SZ</code>为<code>4B</code>的平台，最大<code>chunk</code>为<code>64B</code>，对于<code>SIZE_SZ</code>为8B的平台，最大<code>chunk</code>为128B。<code>ptmalloc</code>默认情况下调用<code>set_max_fast(s)</code>将全局变量<code>global_max_fast</code>设置为<code>DEFAULT_MXFAST</code>，也就是设置<code>fast bins</code>中<code>chunk</code>的最大值，<code>get_max_fast()</code>用于获得这个全局变量<code>global_max_fast</code>的值。</p>
<h2 id="核心结构体分析"><a href="#核心结构体分析" class="headerlink" title="核心结构体分析"></a>核心结构体分析</h2><p>每个分配区是<code>struct malloc_state</code>的一个实例，<code>ptmalloc</code>使用<code>malloc_state</code>来管理分配区，而参数管理使用<code>struct malloc_par</code>，全局拥有一个唯一的<code>malloc_par</code>实例。</p>
<h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><p><code>struct malloc_state</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Serialize access. */</span></span><br><span class="line">    <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags (formerly in max_fast). */</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> THREAD_STATS</span></span><br><span class="line">    <span class="comment">/* Statistics for locking. Only used if THREAD_STATS is defined. */</span></span><br><span class="line">    <span class="type">long</span> stat_lock_direct, stat_lock_loop, stat_lock_wait;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">    <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">    mchunkptr top;</span><br><span class="line">    <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">    mchunkptr last_remainder;</span><br><span class="line">    <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">    mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line">    <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line">    <span class="comment">/* Linked list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">    <span class="comment">/* Linked list for free arenas. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Memory allocated from the system in this arena. */</span></span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>mutex</code>用于串行化访问分配区，当有多个线程访问同一个分配区时，第一个获得这个<code>mutex</code>的线程将使用该分配区分配内存，分配完成后，释放该分配区的<code>mutex</code>，以便其它线程使用该分配区。</p>
<p><code>flags</code>记录了分配区的一些标志，<code>bit0</code>用于标识分配区是否包含至少一个<code>fast bin chunk</code>，<code>bit1</code>用于标识分配区是否能返回连续的虚拟地址空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment">some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment">fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment">The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment">upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment">initialization checks.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) ((M)-&gt;flags |= FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) ((M)-&gt;flags &amp;= ~FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>上面的宏用于设置或是置位<code>flags</code>中<code>fast chunk</code>的标志位<code>bit0</code>，如果<code>bit0</code>为0，表示分配区中有<code>fast chunk</code>，如果为1表示没有<code>fast chunk</code>，初始化完成后的<code>malloc_state</code>实例中，<code>flags</code>值为0，表示该分配区中有<code>fast chunk</code>，但实际上没有，试图从<code>fast bins</code>中分配<code>chunk</code>都会返回<code>NULL</code>，在第一次调用函数<code>malloc_consolidate()</code>对<code>fast bins</code>进行<code>chunk</code>合并时，如果<code>max_fast</code>大于0，会调用<code>clear_fastchunks</code>宏，标志该分配区中已经没有<code>fast chunk</code>，因为函数<code>malloc_consolidate()</code>会合并所有的<code>fast bins</code>中的<code>chunk</code>。<code>clear_fastchunks</code>宏只会在函数<code>malloc_consolidate()</code>中调用。当有<code>fast chunk</code>加入<code>fast bins</code>时，就是调用<code>set_fastchunks</code>宏标46识分配区的<code>fast bins</code>中存在<code>fast chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">regions. Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment">The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">changed dynamically if`mmap`is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br></pre></td></tr></table></figure>
<p><code>flags</code>的<code>bit1</code>如果为0，表示<code>MORCORE</code>返回连续虚拟地址空间，<code>bit1</code>为1，表示<code>MORCORE</code>返回非连续虚拟地址空间，对于主分配区，<code>MORECORE</code>其实为<code>sbr()</code>，默认返回连续虚拟地址空间，对于非主分配区，使用<code>mmap()</code>分配大块虚拟内存，然后进行切分来模拟主分配区的行为，而默认情况下<code>mmap</code>映射区域是不保证虚拟地址空间连续的，所以非住分配区默认分配非连续虚拟地址空间。</p>
<p><code>malloc_state</code>中声明了几个对锁的统计变量，默认没有定义<code>THREAD_STATS</code>，所以不会对锁的争用情况做统计。</p>
<p><code>fastbinsY</code>拥有10（<code>NFASTBINS</code>）个元素的数组，用于存放每个<code>fast chunk</code>链表头指针，所以<code>fast bins</code>最多包含10个<code>fast chunk</code>的单向链表。</p>
<p><code>top</code>是一个<code>chunk</code>指针，指向分配区的<code>top chunk</code>。</p>
<p><code>last_remainder</code>是一个<code>chunk</code>指针，分配区上次分配<code>small chunk</code>时，从一个<code>chunk</code>中分裂出一个<code>small chunk</code>返回给用户，分裂后的剩余部分形成一个<code>chunk</code>，<code>last_remainder</code>就是指向的这个<code>chunk</code>。</p>
<p><code>bins</code>用于存储<code>unstored bin</code>，<code>small bins</code>和<code>large bins</code>的<code>chunk</code>链表头，<code>small bins</code>一共62个，<code>large bins</code>一共63个，加起来一共125个<code>bin</code>。而<code>NBINS</code>定义为128，其实<code>bin[0]</code>和<code>bin[127]</code>都不存在，<code>bin[1]</code>为<code>unsorted bin</code>的<code>chunk</code>链表头，所以实际只有126个<code>bins</code>。<code>bins</code>数组能存放了254（<code>NBINS*2 – 2</code>）个<code>mchunkptr</code>指针，而我们实现需要存储<code>chunk</code>的实例，一般情况下，<code>chunk</code>实例的大小为6个<code>mchunkptr</code>大小，这254个指针的大小怎么能存下126个<code>chunk</code>呢？</p>
<p>这里使用了一个技巧，如果按照我们的常规想法，也许会申请126个<code>malloc_chunk</code>结构体指针元素的数组，然后再给链表申请一个头节点（即126个），再让每个指针元素正确指向而形成126个具有头节点的链表。事实上，对于<code>malloc_chunk</code>类型的链表“头节点”，其内的<code>prev_size</code>和<code>size</code>字段是没有任何实际作用的，<code>fd_nextsize</code>和<code>bk_nextsize</code>字段只有<code>large bins</code>中的空闲<code>chunk</code>才会用到，而对于<code>large bins</code>的空闲<code>chunk</code>链表头不需要这两个字段，因此这四个字段所占空间如果不合理使用的话那就是白白的浪费。</p>
<p>我们再来看一看128个<code>malloc_chunk</code>结构体指针元素的数组占了多少内存空间呢？假设<code>SIZE_SZ</code>的大小为<code>8B</code>，则指针的大小也为<code>8B</code>，结果为<code>126*2*8=2016</code>字节。而126个<code>malloc_chunk</code>类型的链表“头节点”需要多少内存呢？ <code>126*6*8=6048</code>，真的是6048B么？不是，刚才不是说了，<code>prev_size</code>，<code>size</code>，<code>fd_nextsize</code>和<code>bk_nextsize</code>这四个字段是没有任何实际作用的，因此完全可以被重用（覆盖），因此实际需要内存为<code>126*2*8=2016</code>。<code>bins</code>指针数组的大小为，<code>(128*2-2) *8=2032</code>，2032大于2016（事实上最后16个字节都被浪费掉了），那么这254个<code>malloc_chunk</code>结构体指针元素数组所占内存空间就可以存储这126个头节点了。</p>
<p><code>binmap</code>字段是一个<code>int</code>数组，<code>ptmalloc</code>用一个<code>bit</code>来标识该<code>bit</code>对应的<code>bin</code>中是否包含空闲<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Binmap</span></span><br><span class="line"><span class="comment">To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment">structure is used for bin-by-bin searching. `binmap&#x27; is a</span></span><br><span class="line"><span class="comment">bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment">be skipped over during during traversals. The bits are NOT always</span></span><br><span class="line"><span class="comment">cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment">when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSHIFT 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITSPERMAP (1U &lt;&lt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSIZE (NBINS / BITSPERMAP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT)-1))))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unmark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] &amp;= ~(idx2bit(i)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_binmap(m,i) ((m)-&gt;binmap[idx2block(i)] &amp; idx2bit(i))</span></span><br></pre></td></tr></table></figure>
<p><code>binmap</code>一共<code>128bit</code>，16字节，4个<code>int</code>大小，<code>binmap</code>按<code>int</code>分成4个<code>block</code>，每个<code>block</code>有32个<code>bit</code>，根据<code>bin indx</code>可以使用宏<code>idx2block</code>计算出该<code>bin</code>在<code>binmap</code>对应的<code>bit</code>属于哪个<code>block</code>。<code>idx2bit</code>宏取第<code>i</code>位为1，其它位都为0的掩码，举个例子：<code>idx2bit(3)</code>为“0000 1000”（只显示8位）。<code>mark_bin</code>设置第<code>i</code>个<code>bin</code>在<code>binmap</code>中对应的<code>bit</code>位为1； <code>unmark_bin</code>设置第<code>i</code>个<code>bin</code>在<code>binmap</code>中对应的<code>bit</code>位为0；<code>get_binmap</code>获取第<code>i</code>个<code>bin</code>在<code>binmap</code>中对应的<code>bit</code>。</p>
<p><code>next</code>字段用于将分配区以单向链表链接起来。</p>
<p><code>next_free</code>字段空闲的分配区链接在单向链表中，只有在定义了<code>PER_THREAD</code>的情况下才定义该字段。</p>
<p><code>system_mem</code>字段记录了当前分配区已经分配的内存大小。</p>
<p><code>max_system_mem</code>记录了当前分配区最大能分配的内存大小。</p>
<h3 id="malloc-par"><a href="#malloc-par" class="headerlink" title="malloc_par"></a>malloc_par</h3><p><code>struct malloc_par</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Tunable parameters */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> trim_threshold;<span class="number">48</span></span><br><span class="line">    INTERNAL_SIZE_T top_pad;</span><br><span class="line">    INTERNAL_SIZE_T mmap_threshold;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">    INTERNAL_SIZE_T arena_test;</span><br><span class="line">    INTERNAL_SIZE_T arena_max;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Memory map support */</span></span><br><span class="line">    <span class="type">int</span> n_mmaps;</span><br><span class="line">    <span class="type">int</span> n_mmaps_max;</span><br><span class="line">    <span class="type">int</span> max_n_mmaps;</span><br><span class="line">    <span class="comment">/* the mmap_threshold is dynamic, until the user sets</span></span><br><span class="line"><span class="comment">    it manually, at which point we need to disable any</span></span><br><span class="line"><span class="comment">    dynamic behavior. */</span></span><br><span class="line">    <span class="type">int</span> no_dyn_threshold;</span><br><span class="line">    <span class="comment">/* Cache malloc_getpagesize */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> pagesize;</span><br><span class="line">    <span class="comment">/* Statistics */</span></span><br><span class="line">    INTERNAL_SIZE_T mmapped_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_mmapped_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_total_mem; <span class="comment">/* only kept for NO_THREADS */</span></span><br><span class="line">    <span class="comment">/* First address handed out by MORECORE/sbrk. */</span></span><br><span class="line">    <span class="type">char</span>* sbrk_base;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>trim_threshold</code>字段表示收缩阈值，默认为<code>128KB</code>，当每个分配区的<code>top chunk</code>大小大于这个阈值时，在一定的条件下，调用<code>free</code>时会收缩内存，减小<code>top chunk</code>的大小。由于<code>mmap</code>分配阈值的动态调整，在<code>free</code>时可能将收缩阈值修改为<code>mmap</code>分配阈值的2倍，在64位系统上，<code>mmap</code>分配阈值最大值为<code>32MB</code>，所以收缩阈值的最大值为<code>64MB</code>，在32位系统上，<code>mmap</code>分配阈值最大值为<code>512KB</code>，所以收缩阈值的最大值为<code>1MB</code>。收缩阈值可以通过函数<code>mallopt()</code>进行设置。</p>
<p><code>top_pad</code>字段表示在分配内存时是否添加额外的<code>pad</code>，默认该字段为0。</p>
<p><code>mmap_threshold</code>字段表示<code>mmap</code>分配阈值，默认值为<code>128KB</code>，在32位系统上最大值为<code>512KB</code>，64位系统上的最大值为<code>32MB</code>，由于默认开启<code>mmap</code>分配阈值动态调整，该字段的值会动态修改，但不会超过最大值。</p>
<p><code>arena_test</code>和<code>arena_max</code>用于<code>PER_THREAD</code>优化，在32位系统上<code>arena_test</code>默认值为2，64位系统上的默认值为8，当每个进程的分配区数量小于等于<code>arena_test</code>时，不会重用已有的分配区。为了限制分配区的总数，用<code>arena_max</code>来保存分配区的最大数量，当系统中的分配区数量达到<code>arena_max</code>，就不会再创建新的分配区，只会重用已有的分配区。这两个字段都可以使用<code>mallopt()</code>函数设置。</p>
<p><code>n_mmaps</code>字段表示当前进程使用<code>mmap()</code>函数分配的内存块的个数。</p>
<p><code>n_mmaps_max</code>字段表示进程使用<code>mmap()</code>函数分配的内存块的最大数量，默认值为4965536，可以使用<code>mallopt()</code>函数修改。</p>
<p><code>max_n_mmaps</code>字段表示当前进程使用<code>mmap()</code>函数分配的内存块的数量的最大值，有关系<code>n_mmaps &lt;= max_n_mmaps</code>成立。这个字段是由于<code>mstats()</code>函数输出统计需要这个字段。</p>
<p><code>no_dyn_threshold</code>字段表示是否开启<code>mmap</code>分配阈值动态调整机制，默认值为0，也就是默认开启<code>mmap</code>分配阈值动态调整机制。</p>
<p><code>pagesize</code>字段表示系统的页大小，默认为4KB。<code>mmapped_mem</code>和<code>max_mmapped_mem</code>都用于统计<code>mmap</code>分配的内存大小，一般情况下两个字段的值相等，<code>max_mmapped_mem</code>用于<code>mstats()</code>函数。</p>
<p><code>max_total_mem</code>字段在单线程情况下用于统计进程分配的内存总数。<code>sbrk_base</code>字段表示堆的起始地址。</p>
<h3 id="分配区的初始化"><a href="#分配区的初始化" class="headerlink" title="分配区的初始化"></a>分配区的初始化</h3><p><code>ptmalloc</code>定义了如下几个全局变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are several instances of this struct (&quot;arenas&quot;) in this</span></span><br><span class="line"><span class="comment">malloc. If you are adapting this malloc in a way that does NOT use</span></span><br><span class="line"><span class="comment">a static or mmapped malloc_state, you MUST explicitly zero-fill it</span></span><br><span class="line"><span class="comment">before using. This malloc relies on the property that malloc_state</span></span><br><span class="line"><span class="comment">is initialized to all zeroes (as is true of C statics). */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> <span class="title">main_arena</span>;</span></span><br><span class="line"><span class="comment">/* There is only one instance of the malloc parameters. */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span>;</span></span><br><span class="line"><span class="comment">/* Maximum size of memory handled in fastbins. */</span></span><br><span class="line"><span class="type">static</span> INTERNAL_SIZE_T global_max_fast;</span><br></pre></td></tr></table></figure></p>
<p><code>main_arena</code>表示主分配区，任何进程有且仅有一个全局的主分配区，<code>mp_</code>是全局唯一的一个<code>malloc_par</code>实例，用于管理参数和统计信息，<code>global_max_fast</code>全局变量表示<code>fast bins</code>中最大的<code>chunk</code>大小。</p>
<p>分配区<code>main_arena</code>初始化函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Initialize a malloc_state struct.</span></span><br><span class="line"><span class="comment">This is called only from within malloc_consolidate, which needs</span></span><br><span class="line"><span class="comment">be called in the same contexts anyway. It is never called directly</span></span><br><span class="line"><span class="comment">outside of malloc_consolidate because some optimizing compilers try</span></span><br><span class="line"><span class="comment">to inline it at all call points, which turns out not to be an</span></span><br><span class="line"><span class="comment">optimization at all. (Inlining it in malloc_consolidate is fine though.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_init_state</span><span class="params">(mstate av)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_init_state</span><span class="params">(av)</span> mstate av;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    mbinptr bin;</span><br><span class="line">    <span class="comment">/* Establish circular links for normal bins */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i) &#123;</span><br><span class="line">        bin = bin_at(av,i);</span><br><span class="line">        bin-&gt;fd = bin-&gt;bk = bin;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CONTIGUOUS</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        set_noncontiguous(av);</span><br><span class="line">    <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">        set_max_fast(DEFAULT_MXFAST);</span><br><span class="line">    av-&gt;flags |= FASTCHUNKS_BIT;</span><br><span class="line">    av-&gt;top = initial_top(av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分配区的初始化函数默认分配区的实例<code>av</code>是全局静态变量或是已经将<code>av</code>中的所有字段都清0了。初始化函数做的工作比较简单，首先遍历所有的<code>bins</code>，初始化每个<code>bin</code>的空闲链表为空，即将<code>bin</code>的<code>fb</code>和<code>bk</code>都指向<code>bin</code>本身。由于<code>av</code>中所有字段默认为0，即默认分配连续的虚拟地址空间，但只有主分配区才能分配连续的虚拟地址空间，所以对于非主分配区，需要设置为分配非连续虚拟地址空间。如果初始化的是主分配区，需要设置<code>fast bins</code>中最大<code>chunk</code>大小，由于主分配区只有一个，并且一定是最先初始化，这就保证了对全局变量<code>global_max_fast</code>只初始化了一次，只要该全局变量的值非0，也就意味着主分配区初始化了。最后初始化<code>top chunk</code>。</p>
<p><code>ptmalloc</code>参数初始化<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set up basic state so that _int_malloc et al can work. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_init_minimal</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEFAULT_TOP_PAD != 0</span></span><br><span class="line">    mp_.top_pad = DEFAULT_TOP_PAD;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    mp_.n_mmaps_max = DEFAULT_MMAP_MAX;</span><br><span class="line">    mp_.mmap_threshold = DEFAULT_MMAP_THRESHOLD;</span><br><span class="line">    mp_.trim_threshold = DEFAULT_TRIM_THRESHOLD;</span><br><span class="line">    mp_.pagesize = malloc_getpagesize;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8))</span></span><br><span class="line">    mp_.arena_test = NARENAS_FROM_NCORES (<span class="number">1</span>);</span><br><span class="line">    narenas = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要是将全局变量<code>mp_</code>的字段初始化为默认值，值得一提的是，如果定义了编译选项<code>PER_THREAD</code>，会根据系统<code>cpu</code>的个数设置<code>arena_test</code>的值，默认32位系统是双核，64位系统为8核，<code>arena_test</code>也就设置为相应的值。</p>
<h2 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h2><p><code>ptmalloc</code>的配置选项不多，在3.2.6节已经做过概要描述，这里给出<code>mallopt()</code>函数的实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mallopt</span><span class="params">(<span class="type">int</span> param_number, <span class="type">int</span> value)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mallopt</span><span class="params">(param_number, value)</span> <span class="type">int</span> param_number; <span class="type">int</span> value;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mstate av = &amp;main_arena;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(__malloc_initialized &lt; <span class="number">0</span>)</span><br><span class="line">        ptmalloc_init ();</span><br><span class="line">    (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">    <span class="comment">/* Ensure initialization/consolidation */</span></span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">    <span class="keyword">switch</span>(param_number) &#123;</span><br><span class="line">        <span class="keyword">case</span> M_MXFAST:</span><br><span class="line">            <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt;= MAX_FAST_SIZE) &#123;</span><br><span class="line">                set_max_fast(value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> M_TRIM_THRESHOLD:</span><br><span class="line">            mp_.trim_threshold = value;</span><br><span class="line">            mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> M_TOP_PAD:</span><br><span class="line">            mp_.top_pad = value;</span><br><span class="line">            mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> M_MMAP_THRESHOLD:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_ARENAS</span></span><br><span class="line">            <span class="comment">/* Forbid setting the threshold too high. */</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>)value &gt; HEAP_MAX_SIZE/<span class="number">2</span>)</span><br><span class="line">                res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                mp_.mmap_threshold = value;</span><br><span class="line">            mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> M_MMAP_MAX:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !HAVE_MMAP</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="number">0</span>)</span><br><span class="line">                res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                mp_.n_mmaps_max = value;</span><br><span class="line">            mp_.no_dyn_threshold = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> M_CHECK_ACTION:</span><br><span class="line">            check_action = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> M_PERTURB:</span><br><span class="line">            perturb_byte = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">        <span class="keyword">case</span> M_ARENA_TEST:</span><br><span class="line">            <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line">                mp_.arena_test = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> M_ARENA_MAX:</span><br><span class="line">            <span class="keyword">if</span> (value &gt; <span class="number">0</span>)</span><br><span class="line">                mp_.arena_max = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>mallopt()</code>函数配置前，需要检查主分配区是否初始化了，如果没有初始化，调用<code>ptmalloc_init()</code>函数初始化<code>ptmalloc</code>，然后获得主分配区的锁，调用<code>malloc_consolidate()</code>函数，<code>malloc_consolidate()</code>函数会判断主分配区是否已经初始化，如果没有，则初始化主分配区。同时我们也看到，<code>mp_</code>都没有锁，对<code>mp_</code>中参数字段的修改，是通过主分配区的锁来同步的。</p>
<h2 id="ptmalloc的初始化"><a href="#ptmalloc的初始化" class="headerlink" title="ptmalloc的初始化"></a>ptmalloc的初始化</h2><p><code>ptmalloc</code>的初始化发生在进程的第一个内存分配请求，当<code>ptmalloc</code>的初始化一般都在用户的第一次调用<code>malloc()</code>或<code>remalloc()</code>之前，因为操作系统和<code>Glibc</code>库为进程的初始化做了不少工作，在用户分配内存以前，<code>Glibc</code>已经分配了多次内存。在<code>ptmalloc</code>中<code>malloc()</code>函数的实际接口函数为<code>public_malloc()</code>，这个函数最开始会执行如下的一段代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">__malloc_ptr_t</span> (*hook) (<span class="type">size_t</span>, __const <span class="type">__malloc_ptr_t</span>) = force_reg (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure></p>
<p>在定义了<code>__malloc_hook()</code>全局函数的情况下，只是执行<code>__malloc_hook()</code>函数，在进程初始化时<code>__malloc_hook</code>指向的函数为<code>malloc_hook_ini()</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">__malloc_ptr_t</span> <span class="title function_">weak_variable</span> <span class="params">(*__malloc_hook)</span></span><br><span class="line"><span class="params">(<span class="type">size_t</span> __size, <span class="type">const</span> <span class="type">__malloc_ptr_t</span>)</span> = malloc_hook_ini;</span><br></pre></td></tr></table></figure></p>
<p><code>malloc_hook_ini()</code>函数定义在<code>hooks.c</code>中，实现代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void_t</span>*</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">malloc_hook_ini(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">__malloc_ptr_t</span> caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">malloc_hook_ini(sz, caller)</span><br><span class="line"><span class="type">size_t</span> sz; </span><br><span class="line"><span class="type">const</span> <span class="type">__malloc_ptr_t</span> caller;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    __malloc_hook = <span class="literal">NULL</span>;</span><br><span class="line">    ptmalloc_init();</span><br><span class="line">    <span class="keyword">return</span> public_malloc(sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>malloc_hook_ini()</code>函数处理很简单，就是调用<code>ptmalloc</code>的初始化函数<code>ptmalloc_init()</code>，然后再重新调用<code>pbulit_malloc()</code>函数分配内存。<code>ptmalloc_init()</code>函数在初始化<code>ptmalloc</code>完成后，将全局变量<code>__malloc_initialized</code>设置为1，当<code>pbulit_malloc()</code>函数再次执行时，先执行<code>malloc_hook_ini()</code>函数，<code>malloc_hook_ini()</code>函数调用<code>ptmalloc_init()</code>，<code>ptmalloc_init()</code>函数首先判断<code>__malloc_initialized</code>是否为1，如果是，则退出<code>ptmalloc_init()</code>，不再执行<code>ptmalloc</code>初始化。</p>
<h3 id="ptmalloc未初始化时分配-释放内存"><a href="#ptmalloc未初始化时分配-释放内存" class="headerlink" title="ptmalloc未初始化时分配/释放内存"></a>ptmalloc未初始化时分配/释放内存</h3><p>当<code>ptmalloc</code>的初始化函数<code>ptmalloc_init()</code>还没有调用之前，<code>Glibc</code>中可能需要分配内存，比如线程私有实例的初始化需要分配内存，为了解决这一问题，<code>ptmalloc</code>封装了内部的分配释放函数供在这种情况下使用。<code>ptmalloc</code>提供了三个函数，<code>malloc_starter()</code>，<code>memalign_starter()</code>，<code>free_starter()</code>，但没有提供<code>realloc_starter()</code>函数。这几个函数的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void_t</span>*</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">malloc_starter(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void_t</span> *caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">malloc_starter(sz, caller) <span class="type">size_t</span> sz; <span class="type">const</span> <span class="type">void_t</span> *caller;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void_t</span>* victim;</span><br><span class="line">    victim = _int_malloc(&amp;main_arena, sz);</span><br><span class="line">    <span class="keyword">return</span> victim ? BOUNDED_N(victim, sz) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void_t</span>*</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">memalign_starter(<span class="type">size_t</span> align, <span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void_t</span> *caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">memalign_starter(align, sz, caller) <span class="type">size_t</span> align, sz; <span class="type">const</span> <span class="type">void_t</span> *caller;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void_t</span>* victim;</span><br><span class="line">    victim = _int_memalign(&amp;main_arena, align, sz);</span><br><span class="line">    <span class="keyword">return</span> victim ? BOUNDED_N(victim, sz) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">free_starter(<span class="type">void_t</span>* mem, <span class="type">const</span> <span class="type">void_t</span> *caller)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">free_starter(mem, caller) <span class="type">void_t</span>* mem; <span class="type">const</span> <span class="type">void_t</span> *caller;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mchunkptr p;</span><br><span class="line">    <span class="keyword">if</span>(!mem) <span class="keyword">return</span>;</span><br><span class="line">    p = mem2chunk(mem);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p)) &#123;</span><br><span class="line">        munmap_chunk(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    _int_free(&amp;main_arena, p, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    _int_free(&amp;main_arena, p);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的实现都很简单，只是调用<code>ptmalloc</code>的内部实现函数。</p>
<h3 id="ptmalloc-init-函数"><a href="#ptmalloc-init-函数" class="headerlink" title="ptmalloc_init()函数"></a>ptmalloc_init()函数</h3><p><code>ptmalloc_init()</code>函数比较长，将分段对这个函数做介绍。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_init</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* s;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">char</span>* s;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> secure = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(__malloc_initialized &gt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    __malloc_initialized = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>首先检查全局变量<code>__malloc_initialized</code>是否大于等于0，如果该值大于0，表示<code>ptmalloc</code>已经初始化，如果改值为0，表示<code>ptmalloc</code>正在初始化，全局变量<code>__malloc_initialized</code>用来保证全局只初始化<code>ptmalloc</code>一次。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined SHARED &amp;&amp; !USE___THREAD</span></span><br><span class="line"><span class="comment">/* ptmalloc_init_minimal may already have been called via</span></span><br><span class="line"><span class="comment">   __libc_malloc_pthread_startup, above. */</span></span><br><span class="line"><span class="keyword">if</span> (mp_.pagesize == <span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ptmalloc_init_minimal();</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_THREADS</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC</span></span><br><span class="line"><span class="comment">/* We know __pthread_initialize_minimal has already been called, and that is enough. */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> NO_STARTER</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> NO_STARTER</span></span><br><span class="line"><span class="comment">/* With some threads implementations, creating thread-specific data</span></span><br><span class="line"><span class="comment">or initializing a mutex may call malloc() itself. Provide a simple starter version (realloc() wont work). */</span></span><br><span class="line">save_malloc_hook = __malloc_hook;</span><br><span class="line">save_memalign_hook = __memalign_hook;</span><br><span class="line">save_free_hook = __free_hook;</span><br><span class="line">__malloc_hook = malloc_starter;</span><br><span class="line">__memalign_hook = memalign_starter;</span><br><span class="line">__free_hook = free_starter;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line"><span class="comment">/* Initialize the pthreads interface. */</span></span><br><span class="line"><span class="keyword">if</span> (__pthread_initialize != <span class="literal">NULL</span>)</span><br><span class="line">__pthread_initialize();</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> <span class="comment">/* !defined _LIBC */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> <span class="comment">/* !defined NO_STARTER */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !defined NO_THREADS */</span></span></span><br></pre></td></tr></table></figure></p>
<p>为多线程版本的<code>ptmalloc</code>的<code>pthread</code>初始化做准备，保存当前的<code>hooks</code>函数，并把<code>ptmalloc</code>为初始化时所有使用的分配/释放函数赋给<code>hooks</code>函数，因为在线程初始化一些私有实例时，<code>ptmalloc</code>还没有初始化，所以需要做特殊处理。从这些<code>hooks</code>函数可以看出，在<code>ptmalloc</code>未初始化时，不能使用<code>remalloc</code>函数。在相关的<code>hooks</code>函数赋值以后，执行<code>pthread_initilaize()</code>初始化<code>pthread</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutex_init(&amp;main_arena.mutex);</span><br><span class="line">main_arena.next = &amp;main_arena;</span><br></pre></td></tr></table></figure></p>
<p>初始化主分配区的<code>mutex</code>，并将主分配区的<code>next</code>指针指向自身组成环形链表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC &amp;&amp; defined SHARED</span></span><br><span class="line"><span class="comment">/* In case this libc copy is in a non-default namespace, never use brk.</span></span><br><span class="line"><span class="comment">Likewise if dlopened from statically linked program. */</span></span><br><span class="line">Dl_info di;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line"><span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">|| (_dl_addr (ptmalloc_init, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">&amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">    __morecore = __failing_morecore;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>ptmalloc</code>需要保证只有主分配区才能使用<code>sbrk()</code>分配连续虚拟内存空间，如果有多个分配区使用<code>sbrk()</code>就不能获得连续的虚拟地址空间，大多数情况下<code>Glibc</code>库都是以动态链接库的形式加载的，处于默认命名空间，多个进程共用<code>Glibc</code>库，<code>Glibc</code>库代码段在内存中只有一份拷贝，数据段在每个用户进程都有一份拷贝。但如果<code>Glibc</code>库不在默认名字空间，或是用户程序是静态编译的并调用了<code>dlopen</code>函数加载<code>Glibc</code>库中的<code>ptamalloc_init()</code>，这种情况下的<code>ptmalloc</code>不允许使用<code>sbrk()</code>分配内存，只需修改<code>__morecore</code>函数指针指向<code>__failing_morecore</code>就可以禁止使用<code>sbrk()</code>了，<code>__morecore</code>默认指向<code>sbrk()</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mutex_init(&amp;list_lock);</span><br><span class="line">tsd_key_create(&amp;arena_key, <span class="literal">NULL</span>);</span><br><span class="line">tsd_setspecific(arena_key, (<span class="type">void_t</span> *)&amp;main_arena);</span><br><span class="line">thread_atfork(ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2);</span><br></pre></td></tr></table></figure></p>
<p>初始化全局锁<code>list_lock</code>，<code>list_lock</code>主要用于同步分配区的单向循环链表。然后创建线程私有实例<code>arena_key</code>，该私有实例保存的是分配区（<code>arena</code>）的<code>malloc_state</code>实例指针。<code>arena_key</code>指向的可能是主分配区的指针，也可能是非主分配区的指针，这里将调用<code>ptmalloc_init()</code>的线程的<code>arena_key</code>绑定到主分配区上。意味着本线程首选从主分配区分配内存。</p>
<p>然后调用<code>thread_atfork()</code>设置当前进程在<code>fork</code>子线程（linux下线程是轻量级进程，使用类似<code>fork</code>进程的机制创建）时处理<code>mutex</code>的回调函数，在本进程<code>fork</code>子线程时，调用<code>ptmalloc_lock_all()</code>获得所有分配区的锁，禁止所有分配区分配内存，当子线程创建完毕，父进程调用<code>ptmalloc_unlock_all()</code>重新<code>unlock</code>每个分配区的锁<code>mutex</code>，子线程调用<code>ptmalloc_unlock_all2()</code>重新初始化每个分配区的锁<code>mutex</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_THREADS</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifndef</span> NO_STARTER</span></span><br><span class="line">__malloc_hook = save_malloc_hook;</span><br><span class="line">__memalign_hook = save_memalign_hook;</span><br><span class="line">__free_hook = save_free_hook;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">undef</span> NO_STARTER</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>当<code>pthread</code>初始化完成后，将相应的<code>hooks</code>函数还原为原值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">secure = __libc_enable_secure;</span><br><span class="line">s = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (_environ != <span class="literal">NULL</span>, <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> **runp = _environ;</span><br><span class="line">    <span class="type">char</span> *envline;</span><br><span class="line">    <span class="keyword">while</span> (__builtin_expect ((envline = next_env_entry (&amp;runp)) != <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> len = <span class="built_in">strcspn</span> (envline, <span class="string">&quot;=&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (envline[len] != <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">        <span class="comment">/* This is a &quot;MALLOC_&quot; variable at the end of the string58</span></span><br><span class="line"><span class="comment">        without a &#x27;=&#x27; character. Ignore it since otherwise we</span></span><br><span class="line"><span class="comment">        will access invalid memory below. */</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">switch</span> (len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;CHECK_&quot;</span>, <span class="number">6</span>) == <span class="number">0</span>)</span><br><span class="line">                    s = &amp;envline[<span class="number">7</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                <span class="keyword">if</span> (! secure)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;TOP_PAD_&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">                        mALLOPt(M_TOP_PAD, atoi(&amp;envline[<span class="number">9</span>]));</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;PERTURB_&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">                        mALLOPt(M_PERTURB, atoi(&amp;envline[<span class="number">9</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                <span class="keyword">if</span> (! secure)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;MMAP_MAX_&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">                        mALLOPt(M_MMAP_MAX, atoi(&amp;envline[<span class="number">10</span>]));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;ARENA_MAX&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">                        mALLOPt(M_ARENA_MAX, atoi(&amp;envline[<span class="number">10</span>]));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> (! secure)</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;ARENA_TEST&quot;</span>, <span class="number">10</span>) == <span class="number">0</span>)</span><br><span class="line">                    mALLOPt(M_ARENA_TEST, atoi(&amp;envline[<span class="number">11</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">                <span class="keyword">if</span> (! secure)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;TRIM_THRESHOLD_&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">                        mALLOPt(M_TRIM_THRESHOLD, atoi(&amp;envline[<span class="number">16</span>]));<span class="number">59</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">memcmp</span> (envline, <span class="string">&quot;MMAP_THRESHOLD_&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">                        mALLOPt(M_MMAP_THRESHOLD, atoi(&amp;envline[<span class="number">16</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">if</span> (! secure)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_TRIM_THRESHOLD_&quot;</span>)))</span><br><span class="line">        mALLOPt(M_TRIM_THRESHOLD, atoi(s));</span><br><span class="line">    <span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_TOP_PAD_&quot;</span>)))</span><br><span class="line">        mALLOPt(M_TOP_PAD, atoi(s));</span><br><span class="line">    <span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_PERTURB_&quot;</span>)))</span><br><span class="line">        mALLOPt(M_PERTURB, atoi(s));</span><br><span class="line">    <span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_MMAP_THRESHOLD_&quot;</span>)))</span><br><span class="line">        mALLOPt(M_MMAP_THRESHOLD, atoi(s));</span><br><span class="line">    <span class="keyword">if</span>((s = getenv(<span class="string">&quot;MALLOC_MMAP_MAX_&quot;</span>)))</span><br><span class="line">        mALLOPt(M_MMAP_MAX, atoi(s));</span><br><span class="line">&#125;</span><br><span class="line">s = getenv(<span class="string">&quot;MALLOC_CHECK_&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span>(s &amp;&amp; s[<span class="number">0</span>]) &#123;</span><br><span class="line">    mALLOPt(M_CHECK_ACTION, (<span class="type">int</span>)(s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">    <span class="keyword">if</span> (check_action != <span class="number">0</span>)</span><br><span class="line">        __malloc_check_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从环境变量中读取相应的配置参数值，这些参数包括<code>MALLOC_TRIM_THRESHOLD_</code>，<code>MALLOC_TOP_PAD_</code>，<code>MALLOC_PERTURB_</code>，<code>MALLOC_MMAP_THRESHOLD_</code>，<code>MALLOC_CHECK_</code>，<code>MALLOC_MMAP_MAX_</code>，<code>MALLOC_ARENA_MAX</code>，<code>MALLOC_ARENA_TEST</code>，如果这些选项中的某些项存在，调用<code>mallopt()</code>函数设置相应的选项。如果这段程序是在<code>Glibc</code>库初始化中执行的，会做更多的安全检查工作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span>) = force_reg (__malloc_initialize_hook);</span><br><span class="line"><span class="keyword">if</span> (hook != <span class="literal">NULL</span>)</span><br><span class="line">    (*hook)();</span><br><span class="line">__malloc_initialized = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>在<code>ptmalloc_init()</code>函数结束处，查看是否存在<code>__malloc_initialize_hook</code>函数，如果存在，执行该<code>hook</code>函数。最后将全局变量<code>__malloc_initialized</code>设置为1，表示<code>ptmalloc_init()</code>已经初始化完成。</p>
<h3 id="ptmalloc-lock-all-ptmalloc-unlock-all-ptmalloc-unlock-all2"><a href="#ptmalloc-lock-all-ptmalloc-unlock-all-ptmalloc-unlock-all2" class="headerlink" title="ptmalloc_lock_all(),ptmalloc_unlock_all(),ptmalloc_unlock_all2()"></a>ptmalloc_lock_all(),ptmalloc_unlock_all(),ptmalloc_unlock_all2()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Magic value for the thread-specific arena pointer when</span></span><br><span class="line"><span class="comment">malloc_atfork() is in use. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATFORK_ARENA_PTR ((void_t*)-1)</span></span><br><span class="line"><span class="comment">/* The following hooks are used while the `atfork&#x27; handling mechanism is active. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void_t</span>*</span><br><span class="line"><span class="title function_">malloc_atfork</span><span class="params">(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void_t</span> *caller)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void_t</span> *vptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">void_t</span> *victim;</span><br><span class="line">    tsd_getspecific(arena_key, vptr);</span><br><span class="line">    <span class="keyword">if</span>(vptr == ATFORK_ARENA_PTR) &#123;</span><br><span class="line">        <span class="comment">/* We are the only thread that may allocate at all. */</span></span><br><span class="line">        <span class="keyword">if</span>(save_malloc_hook != malloc_check) &#123;</span><br><span class="line">            <span class="keyword">return</span> _int_malloc(&amp;main_arena, sz);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(top_check()&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            victim = _int_malloc(&amp;main_arena, sz+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> mem2mem_check(victim, sz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Suspend the thread until the `atfork&#x27; handlers have completed.</span></span><br><span class="line"><span class="comment">        By that time, the hooks will have been reset as well, so that</span></span><br><span class="line"><span class="comment">        malloc() can be used again. */</span></span><br><span class="line">        (<span class="type">void</span>)mutex_lock(&amp;list_lock);</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br><span class="line">        <span class="keyword">return</span> public_malloc(sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当父进程中的某个线程使用<code>fork</code>的机制创建子线程时，如果进程中的线程需要分配内存，将使用<code>malloc_atfork()</code>函数分配内存。<code>malloc_atfork()</code>函数首先查看自己的线程私有实例中的分配区指针，如果该指针为<code>ATFORK_ARENA_PTR</code>，意味着本线程正在<code>fork</code>新线程，并锁住了全局锁<code>list_lock</code>和每个分配区，当前只有本线程可以分配内存，如果在<code>fork</code>线程前的分配函数不是处于<code>check</code>模式，直接调用内部分配函数<code>_int_malloc()</code>。否则在分配内存的同时做检查。如果线程私有实例中的指针不是<code>ATFORK_ARENA_PTR</code>，意味着当前线程只是常规线程，有另外的线程在<code>fork</code>子线程，当前线程只能等待<code>fork</code>子线程的线程完成分配，于是等待获得全局锁<code>list_lock</code>，如果获得全局锁成功，表示<code>fork</code>子线程的线程已经完成<code>fork</code>操作，当前线程可以分配内存了，于是是释放全局所<code>list_lock</code>，并调用<code>public_malloc()</code>分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">free_atfork</span><span class="params">(<span class="type">void_t</span>* mem, <span class="type">const</span> <span class="type">void_t</span> *caller)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void_t</span> *vptr = <span class="literal">NULL</span>;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    mchunkptr p; <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    p = mem2chunk(mem); <span class="comment">/* do not bother to replicate free_check here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">        munmap_chunk(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    ar_ptr = arena_for_chunk(p);</span><br><span class="line">    tsd_getspecific(arena_key, vptr);</span><br><span class="line">    _int_free(ar_ptr, p, vptr == ATFORK_ARENA_PTR);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ar_ptr = arena_for_chunk(p);</span><br><span class="line">    tsd_getspecific(arena_key, vptr);</span><br><span class="line">    <span class="keyword">if</span>(vptr != ATFORK_ARENA_PTR)</span><br><span class="line">        (<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">    _int_free(ar_ptr, p);</span><br><span class="line">    <span class="keyword">if</span>(vptr != ATFORK_ARENA_PTR)</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当父进程中的某个线程使用<code>fork</code>的机制创建子线程时，如果进程中的线程需要释放内存，将使用<code>free_atfork()</code>函数释放内存。 <code>free_atfork()</code>函数首先通过需<code>free</code>的内存块指针获得<code>chunk</code>的指针，如果该<code>chunk</code>是通过<code>mmap</code>分配的，调用<code>munmap()</code>释放该<code>chunk</code>，否则调用<code>_int_free()</code>函数释放内存。在调用<code>_int_free()</code>函数前，先根据<code>chunk</code>指针获得分配区指针，并读取本线程私用实例的指针，如果开启了<code>ATOMIC_FASTBINS</code>优化，这个优化使用了<code>lock-free</code>的技术优化<code>fastbins</code>中单向链表操作。如果没有开启了<code>ATOMIC_FASTBINS</code>优化，并且当前线程没有正在<code>fork</code>新子线程，则对分配区加锁，然后调用<code>_int_free()</code>函数，然后对分配区解锁。而对于正在<code>fork</code>子线程的线程来说，是不需要对分配区加锁的，因为该线程已经对所有的分配区加锁了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Counter for number of times the list is locked by the same thread. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> atfork_recursive_cntr;</span><br><span class="line"><span class="comment">/* The following two functions are registered via thread_atfork() to</span></span><br><span class="line"><span class="comment">make sure that the mutexes remain in a consistent state in the</span></span><br><span class="line"><span class="comment">fork()ed version of a thread. Also adapt the malloc and free hooks</span></span><br><span class="line"><span class="comment">temporarily, because the `atfork&#x27; handler mechanism may use</span></span><br><span class="line"><span class="comment">malloc/free internally (e.g. in LinuxThreads). */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_lock_all</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="keyword">if</span>(__malloc_initialized &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (mutex_trylock(&amp;list_lock))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">void_t</span> *my_arena;</span><br><span class="line">        tsd_getspecific(arena_key, my_arena);</span><br><span class="line">        <span class="keyword">if</span> (my_arena == ATFORK_ARENA_PTR)</span><br><span class="line">        <span class="comment">/* This is the same thread which already locks the global list.</span></span><br><span class="line"><span class="comment">        Just bump the counter. */</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="comment">/* This thread has to wait its turn. */</span></span><br><span class="line">        (<span class="type">void</span>)mutex_lock(&amp;list_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ar_ptr = &amp;main_arena;;) &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">        ar_ptr = ar_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(ar_ptr == &amp;main_arena) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    save_malloc_hook = __malloc_hook;</span><br><span class="line">    save_free_hook = __free_hook;</span><br><span class="line">    __malloc_hook = malloc_atfork;</span><br><span class="line">    __free_hook = free_atfork;</span><br><span class="line">    <span class="comment">/* Only the current thread may perform malloc/free calls now. */</span></span><br><span class="line">    tsd_getspecific(arena_key, save_arena);</span><br><span class="line">    tsd_setspecific(arena_key, ATFORK_ARENA_PTR);</span><br><span class="line">out:</span><br><span class="line">    ++atfork_recursive_cntr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当父进程中的某个线程使用<code>fork</code>的机制创建子线程时，首先调用<code>ptmalloc_lock_all()</code>函数暂时对全局锁<code>list_lock</code>和所有的分配区加锁，从而保证分配区状态的一致性。<code>ptmalloc_lock_all()</code>函数首先检查<code>ptmalloc</code>是否已经初始化，如果没有初始化，退出，如果已经初始化，尝试对全局锁<code>list_lock</code>加锁，直到获得全局锁<code>list_lock</code>，接着对所有的分配区加锁，接着保存原有的分配释放函数，将<code>malloc_atfork()</code>和<code>free_atfork()</code>函数作为<code>fork</code>子线程期间所使用的内存分配释放函数，然后保存当前线程的私有实例中的原有分配区指针，将<code>ATFORK_ARENA_PTR</code>存放到当前线程的私有实例中，用于标识当前现在正在<code>fork</code>子线程。为了保证父线程<code>fork</code>多个子线程工作正常，也就是说当前线程需要<code>fork</code>多个子线程，当一个子线程已经创建，当前线程继续创建其它子线程时，发现当前线程已经对<code>list_lock</code>和所有分配区加锁，于是对全局变量<code>atfork_recursive_cntr</code>加1，表示递归<code>fork</code>子线程的层数，保证父线程在<code>fork</code>子线程过程中，调用<code>ptmalloc_unlock_all()</code>函数加锁的次数与调用<code>ptmalloc_lock_all()</code>函数解锁的次数保持一致，同时也保证保证所有的子线程调用<code>ptmalloc_unlock_all()</code>函数加锁的次数与父线程调用<code>ptmalloc_lock_all()</code>函数解锁的次数保持一致，防止没有释放锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_unlock_all</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="keyword">if</span>(__malloc_initialized &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (--atfork_recursive_cntr != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    tsd_setspecific(arena_key, save_arena);</span><br><span class="line">    __malloc_hook = save_malloc_hook;</span><br><span class="line">    __free_hook = save_free_hook;</span><br><span class="line">    <span class="keyword">for</span>(ar_ptr = &amp;main_arena;;) &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">        ar_ptr = ar_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(ar_ptr == &amp;main_arena) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当进程的某个线程完成<code>fork</code>子线程后，父线程和子线程都调用<code>ptmall_unlock_all()</code>函数释放全局锁<code>list_lock</code>，释放所有分配区的锁。<code>ptmall_unlock_all()</code>函数首先检查<code>ptmalloc</code>是否初始化，只有初始化后才能调用该函数，接着将全局变量<code>atfork_recursive_cntr</code>减1，如果<code>atfork_recursive_cntr</code>为0，才继续执行，这保证了递归<code>fork</code>子线程只会解锁一次。接着将当前线程的私有实例还原为原来的分配区，<code>__malloc_hook</code>和<code>__free_hook</code>还原为由来的<code>hook</code>函数。然后遍历所有分配区，依次解锁每个分配区，最后解锁<code>list_lock</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __linux__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* In NPTL, unlocking a mutex in the child process after a </span></span><br><span class="line"><span class="comment">fork() is currently unsafe, whereas re-initializing it is safe and</span></span><br><span class="line"><span class="comment">does not leak resources. Therefore, a special atfork handler is</span></span><br><span class="line"><span class="comment">installed for the child. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">ptmalloc_unlock_all2</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="keyword">if</span>(__malloc_initialized &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined MALLOC_HOOKS</span></span><br><span class="line">    tsd_setspecific(arena_key, save_arena);</span><br><span class="line">    __malloc_hook = save_malloc_hook;</span><br><span class="line">    __free_hook = save_free_hook;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">    free_list = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span>(ar_ptr = &amp;main_arena;;) &#123;</span><br><span class="line">        mutex_init(&amp;ar_ptr-&gt;mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">        <span class="keyword">if</span> (ar_ptr != save_arena) &#123;</span><br><span class="line">            ar_ptr-&gt;next_free = free_list;</span><br><span class="line">            free_list = ar_ptr;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        ar_ptr = ar_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(ar_ptr == &amp;main_arena) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_init(&amp;list_lock);</span><br><span class="line">    atfork_recursive_cntr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ptmalloc_unlock_all2 ptmalloc_unlock_all</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>函数<code>ptmalloc_unlock_all2()</code>被<code>fork</code>出的子线程调用，在<code>Linux</code>系统中，子线程（进程）<code>unlock</code>从父线程（进程）中继承的<code>mutex</code>不安全，会导致资源泄漏，但重新初始化<code>mutex</code>是安全的，所有增加了这个特殊版本用于<code>Linux</code>下的<code>atfork handler</code>。<code>ptmalloc_unlock_all2()</code>函数的处理流程跟<code>ptmalloc_unlock_all()</code>函数差不多，使用<code>mutex_init()</code>代替了<code>mutex_unlock()</code>，如果开启了<code>PER_THREAD</code>的优化，将从父线程中继承来的分配区加入到<code>free_list</code>中，对于子线程来说，无论全局变量<code>atfork_recursive_cntr</code>的值是多少，都将该值设置为0，因为<code>ptmalloc_unlock_all2()</code>函数只会被子线程调用一次。</p>
<h2 id="多分配区支持"><a href="#多分配区支持" class="headerlink" title="多分配区支持"></a>多分配区支持</h2><p>由于只有一个主分配区从堆中分配小内存块，而稍大的内存块都必须从<code>mmap</code>映射区域分配，如果有多个线程都要分配小内存块，但多个线程是不能同时调用<code>sbrk()</code>函数的，因为只有一个函数调用<code>sbrk()</code>时才能保证分配的虚拟地址空间是连续的。如果多个线程都从主分配区中分配小内存块，效率很低效。为了解决这个问题，<code>ptmalloc</code>使用非主分配区来模拟主分配区的功能，非主分配区同样可以分配小内存块，并且可以创建多个非主分配区，从而在线程分配内存竞争比较激烈的情况下，可以创建更多的非主分配区来完成分配任务，减少分配区的锁竞争，提高分配效率。</p>
<p><code>ptmalloc</code>怎么用非主分配区来模拟主分配区的行为呢？首先创建一个新的非主分配区，非主分配区使用<code>mmap()</code>函数分配一大块内存来模拟堆（sub-heap），所有的从该非主分配区总分配的小内存块都从<code>sub-heap</code>中切分出来，如果一个<code>sub-heap</code>的内存用光了，或是<code>sub-heap</code>中的内存不够用时，使用<code>mmap()</code>分配一块新的内存块作为<code>sub-heap</code>，并将新的<code>sub-heap</code>链接在非主分配区中<code>sub-heap</code>的单向链表中。</p>
<p>分主分配区中的<code>sub-heap</code>所占用的内存不会无限的增长下去，同样会像主分配区那样进行进行<code>sub-heap</code>收缩，将<code>sub-heap</code>中<code>top chunk</code>的一部分返回给操作系统，如果<code>top chunk</code>为整个<code>sub-heap</code>，会把整个<code>sub-heap</code>还回给操作系统。收缩堆的条件是当前<code>free</code>的<code>chunk</code>大小加上前后能合并<code>chunk</code>的大小大于<code>64KB</code>，并且<code>top chunk</code>的大小达到<code>mmap</code>收缩阈值，才有可能收缩堆。</p>
<p>一般情况下，进程中有多个线程，也有多个分配区，线程的数据一般会比分配区数量多，所以必能保证没有线程独享一个分配区，每个分配区都有可能被多个线程使用，为了保证分配区的线程安全，对分配区的访问需要锁保护，当线程获得分配区的锁时，可以使用该分配区分配内存，并将该分配区的指针保存在线程的私有实例中。</p>
<p>当某一线程需要调用<code>malloc</code>分配内存空间时，该线程先查看线程私有变量中是否已经存在一个分配区，如果存在，尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果失败，该线程搜分配区索循环链表试图获得一个空闲的分配区。如果所有的分配区都已经加锁，那么<code>malloc</code>会开辟一个新的分配区，把该分配区加入到分配区的全局分配区循环链表并加锁，然后使用该分配区进行分配操作。在回收操作中，线程同样试图获得待回收块所在分配区的锁，如果该分配区正在被别的线程使用，则需要等待直到其他线程释放该分配区的互斥锁之后才可以进行回收操作。</p>
<h3 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h3><p><code>struct heap_info</code>定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable)</span></span><br><span class="line"><span class="comment">malloc_chunks. It is allocated with mmap() and always starts at an</span></span><br><span class="line"><span class="comment">address aligned to HEAP_MAX_SIZE. Not used unless compiling with</span></span><br><span class="line"><span class="comment">USE_ARENAS. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> &#123;</span></span><br><span class="line">    mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">    <span class="type">size_t</span> size; <span class="comment">/* Current size in bytes. */</span><span class="number">66</span></span><br><span class="line">    <span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */</span></span><br><span class="line">    <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">    that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">    MALLOC_ALIGNMENT. */</span></span><br><span class="line">    <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure></p>
<p><code>ar_ptr</code>是指向所属分配区的指针，<code>mstate</code>的定义为： <code>typedef struct malloc_state *mstate;</code></p>
<p><code>prev</code>字段用于将同一个分配区中的<code>sub_heap</code>用单向链表链接起来。<code>prev</code>指向链表中的前一个<code>sub_heap</code>。<code>size</code>字段表示当前<code>sub_heap</code>中的内存大小，以<code>page</code>对齐。<code>mprotect_size</code>字段表示当前<code>sub_heap</code>中被读写保护的内存大小，也就是说还没有被分配的内存大小。</p>
<p><code>pad</code>字段用于保证<code>sizeof (heap_info) + 2 * SIZE_SZ</code>是按<code>MALLOC_ALIGNMENT</code>对齐的。<code>MALLOC_ALIGNMENT_MASK</code>为<code>2 * SIZE_SZ - 1</code>，无论<code>SIZE_SZ</code>为4或8，<code>-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK</code>的值为0 ，如果<code>sizeof (heap_info) + 2 * SIZE_SZ</code>不是按<code>MALLOC_ALIGNMENT</code>对齐，编译的时候就会报错，编译时会执行下面的宏。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get a compile-time error if the heap_info padding is not correct</span></span><br><span class="line"><span class="comment">to make alignment work as expected in sYSMALLOc. */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> sanity_check_heap_info_alignment[(<span class="keyword">sizeof</span> (heap_info)</span><br><span class="line">+ <span class="number">2</span> * SIZE_SZ) % MALLOC_ALIGNMENT ? <span class="number">-1</span> : <span class="number">1</span>];</span><br></pre></td></tr></table></figure></p>
<p>为什么一定要保证对齐呢？作为分主分配区的第一个<code>sub_heap</code>，<code>heap_info</code>存放在<code>sub_heap</code>的头部，紧跟<code>heap_info</code>之后是该非主分配区的<code>malloc_state</code>实例，紧跟<code>malloc_state</code>实例后，是<code>sub_heap</code>中的第一个<code>chunk</code>，但<code>chunk</code>的首地址必须按照<code>MALLOC_ALIGNMENT</code>对齐，所以在<code>malloc_state</code>实例和第一个<code>chunk</code>之间可能有几个字节的<code>pad</code>，但如果<code>sub_heap</code>不是非主分配区的第一个<code>sub_heap</code>，则紧跟<code>heap_info</code>后是第一个<code>chunk</code>，但<code>sysmalloc()</code>函数默认<code>heap_info</code>是按照<code>MALLOC_ALIGNMENT</code>对齐的，没有再做对齐的工作，直接将<code>heap_info</code>后的内存强制转换成一个<code>chunk</code>。所以这里在编译时保证<code>sizeof (heap_info) + 2 * SIZE_SZ</code>是按<code>MALLOC_ALIGNMENT</code>对齐的，在运行时就不用再做检查了，也不必再做对齐。</p>
<h3 id="获取分配区"><a href="#获取分配区" class="headerlink" title="获取分配区"></a>获取分配区</h3><p>为了支持多线程，<code>ptmalloc</code>定义了如下的全局变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">tsd_key_t</span> arena_key;</span><br><span class="line"><span class="type">static</span> <span class="type">mutex_t</span> list_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> narenas;</span><br><span class="line"><span class="type">static</span> mstate free_list;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Mapped memory in non-main arenas (reliable only for NO_THREADS). */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> arena_mem;<span class="number">67</span></span><br><span class="line"><span class="comment">/* Already initialized? */</span></span><br><span class="line"><span class="type">int</span> __malloc_initialized = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p><code>arena_key</code>存放的是线程的私用实例，该私有实例保存的是分配区（arena）的<code>malloc_state</code>实例的指针。<code>arena_key</code>指向的可能是主分配区的指针，也可能是非主分配区的指针。<code>list_lock</code>用于同步分配区的单向环形链表。</p>
<p>如果定义了<code>PRE_THREAD</code>，<code>narenas</code>全局变量表示当前分配区的数量，<code>free_list</code>全局变量是空闲分配区的单向链表，这些空闲的分配区可能是从父进程那里继承来的。全局变量<code>narenas</code>和<code>free_list</code>都用锁<code>list_lock</code>同步。</p>
<p><code>arena_mem</code>只用于单线程的<code>ptmalloc</code>版本，记录了非主分配区所分配的内存大小。</p>
<p><code>__malloc_initializd</code>全局变量用来标识是否<code>ptmalloc</code>已经初始化了，其值大于0时表示已经初始化。</p>
<p><code>ptmalloc</code>使用如下的宏来获得分配区：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* arena_get() acquires an arena and locks the corresponding mutex.</span></span><br><span class="line"><span class="comment">First, try the one last locked successfully by this thread. (This</span></span><br><span class="line"><span class="comment">is the common case and handled with a macro for speed.) Then, loop</span></span><br><span class="line"><span class="comment">once over the circularly linked list of arenas. If no arena is</span></span><br><span class="line"><span class="comment">readily available, create a new one. In this latter case, `size&#x27;</span></span><br><span class="line"><span class="comment">is just a hint as to how much memory will be required immediately</span></span><br><span class="line"><span class="comment">in the new arena. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">    arena_lookup(ptr); \</span></span><br><span class="line"><span class="meta">    arena_lock(ptr, size); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lookup(ptr) do &#123; \</span></span><br><span class="line"><span class="meta">    void_t *vptr = NULL; \</span></span><br><span class="line"><span class="meta">    ptr = (mstate)tsd_getspecific(arena_key, vptr); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lock(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(ptr) \</span></span><br><span class="line"><span class="meta">        (void)mutex_lock(&amp;ptr-&gt;mutex); \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">        ptr = arena_get2(ptr, (size)); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_lock(ptr, size) do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(ptr &amp;&amp; !mutex_trylock(&amp;ptr-&gt;mutex)) &#123; \</span></span><br><span class="line"><span class="meta">        THREAD_STAT(++(ptr-&gt;stat_lock_direct)); \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">        ptr = arena_get2(ptr, (size)); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* find the heap and corresponding arena for a given ptr */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="meta">((heap_info *)((unsigned long)(ptr) &amp; ~(HEAP_MAX_SIZE-1)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="meta">(chunk_non_main_arena(ptr) ? heap_for_ptr(ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br></pre></td></tr></table></figure></p>
<p><code>arena_get</code>首先调用<code>arena_lookup</code>查找本线程的私用实例中是否包含一个分配区的指针，返回该指针，调用<code>arena_lock</code>尝试对该分配区加锁，如果加锁成功，使用该分配区分配内存，如果对该分配区加锁失败，调用<code>arena_get2</code>获得一个分配区指针。如果定义了<code>PRE_THREAD</code>，<code>arena_lock</code>的处理有些不同，如果本线程拥有的私用实例中包含分配区的指针，则直接对该分配区加锁，否则，调用<code>arena_get2</code>获得分配区指针，<code>PRE_THREAD</code>的优化保证了每个线程尽量从自己所属的分配区中分配内存，减少与其它线程因共享分配区带来的锁开销，但<code>PRE_THREAD</code>的优化并不能保证每个线程都有一个不同的分配区，当系统中的分配区数量达到配置的最大值时，不能再增加新的分配区，如果再增加新的线程，就会有多个线程共享同一个分配区。所以<code>ptmalloc</code>的<code>PRE_THREAD</code>优化，对线程少时可能会提升一些性能，但线程多时，提升性能并不明显。即使没有线程共享分配区的情况下，任然需要加锁，这是不必要的开销，每次加锁操作会消耗<code>100ns</code>左右的时间。</p>
<p>每个<code>sub_heap</code>的内存块使用<code>mmap()</code>函数分配，并以<code>HEAP_MAX_SIZE</code>对齐，所以可以根据<code>chunk</code>的指针地址，获得这个<code>chunk</code>所属的<code>sub_heap</code>的地址。<code>heap_for_ptr</code>根据<code>chunk</code>的地址获得<code>sub_heap</code>的地址。由于<code>sub_heap</code>的头部存放的是<code>heap_info</code>的实例，<code>heap_info</code>中保存了分配区的指针，所以可以通过<code>chunk</code>的地址获得分配区的地址，前提是这个<code>chunk</code>属于非主分配区，<code>arena_for_chunk</code>用来做这样的转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MIN_SIZE (32*1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_MAX_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MAX_SIZE (1024*1024) <span class="comment">/* must be a power of two */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>HEAP_MIN_SIZE</code>定义了<code>sub_heap</code>内存块的最小值，32KB。<code>HEAP_MAX_SIZE</code>定义了<code>sub_heap</code>内存块的最大值，在32位系统上，<code>HEAP_MAX_SIZE</code>默认值为1MB<code>，64为系统上，</code>HEAP_MAX_SIZE`的默认值为64MB。</p>
<h3 id="arena-get2"><a href="#arena-get2" class="headerlink" title="arena_get2()"></a>arena_get2()</h3><p><code>arena_get</code>宏尝试查看线程的私用实例中是否包含一个分配区，如果不存在分配区或是存在分配区，但对该分配区加锁失败，就会调用<code>arena_get2()</code>函数获得一个分配区，下面将分析<code>arena_get2()</code>函数的实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line">internal_function</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">arena_get2(mstate a_tsd, <span class="type">size_t</span> size)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">arena_get2(a_tsd, size) mstate a_tsd; <span class="type">size_t</span> size;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mstate a;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">    <span class="keyword">if</span> ((a = get_free_list ()) == <span class="literal">NULL</span></span><br><span class="line">    &amp;&amp; (a = reused_arena ()) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">/* Nothing immediately available, so generate a new arena. */</span></span><br><span class="line">    a = _int_new_arena(size);</span><br></pre></td></tr></table></figure></p>
<p>如果开启了<code>PER_THREAD</code>优化，首先尝试从分配区的<code>free list</code>中获得一个分配区，分配区的<code>free list</code>是从父线程（进程）中继承而来，如果<code>free list</code>中没有分配区，尝试重用已有的分配区，只有当分配区的数达到限制时才重用分配区，如果仍未获得可重用的分配区，创建一个新的分配区。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span>(!a_tsd)</span><br><span class="line">        a = a_tsd = &amp;main_arena;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        a = a_tsd-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(!a) &#123;</span><br><span class="line">            <span class="comment">/* This can only happen while initializing the new arena. */</span></span><br><span class="line">            (<span class="type">void</span>)mutex_lock(&amp;main_arena.mutex);</span><br><span class="line">            THREAD_STAT(++(main_arena.stat_lock_wait));</span><br><span class="line">            <span class="keyword">return</span> &amp;main_arena;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果线程的私有实例中没有分配区，将主分配区作为候选分配区，如果线程私有实例中存在分配区，但不能获得该分配区的锁，将该分配区的下一个分配区作为候选分配区，如果候选分配区为空，意味着当前线程私用实例中的分配区正在初始化，还没有加入到全局的分配区链表中，这种情况下，只有主分配区可选了，等待获得主分配区的锁，如果获得住分配区的锁成功，返回主分配区。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check the global, circularly linked list for available arenas. */</span></span><br><span class="line"><span class="type">bool</span> retried = <span class="literal">false</span>;</span><br><span class="line">repeat:</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!mutex_trylock(&amp;a-&gt;mutex)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (retried)</span><br><span class="line">            (<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br><span class="line">        THREAD_STAT(++(a-&gt;stat_lock_loop));</span><br><span class="line">        tsd_setspecific(arena_key, (<span class="type">void_t</span> *)a);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    a = a-&gt;next;</span><br><span class="line">&#125; <span class="keyword">while</span>(a != a_tsd);</span><br></pre></td></tr></table></figure></p>
<p>遍历全局分配区链表，尝试对当前遍历中的分配区加锁，如果对分配区加锁成功，将该分配区加入线程私有实例中并返回该分配区。如果<code>retried</code>为<code>true</code>，意味着这是第二次遍历全局分配区链表，并且获得了全局锁<code>list_lock</code>，当对分配区加锁成功时，需要释放全局锁<code>list_lock</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If not even the list_lock can be obtained, try again. This can</span></span><br><span class="line"><span class="comment">happen during `atfork&#x27;, or for example on systems where thread</span></span><br><span class="line"><span class="comment">creation makes it temporarily impossible to obtain _any_</span></span><br><span class="line"><span class="comment">locks. */</span></span><br><span class="line"><span class="keyword">if</span>(!retried &amp;&amp; mutex_trylock(&amp;list_lock)) &#123;</span><br><span class="line">    <span class="comment">/* We will block to not run in a busy loop. */</span></span><br><span class="line">    (<span class="type">void</span>)mutex_lock(&amp;list_lock);</span><br><span class="line">    <span class="comment">/* Since we blocked there might be an arena available now. */</span></span><br><span class="line">    retried = <span class="literal">true</span>;</span><br><span class="line">    a = a_tsd;</span><br><span class="line">    <span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于在<code>atfork</code>时，父线程（进程）会对所有的分配区加锁，并对全局锁<code>list_lock</code>加锁，在有线程在创建子线程的情况下，当前线程是不能获得分配区的，所以在没有重试的情况下，先尝试获得全局锁<code>list_lock</code>，如果不能获得全局锁<code>list_lock</code>，阻塞在全局锁<code>list_lock</code>上，直到获得全局锁<code>list_lock</code>，也就是说当前已没有线程在创建子线程，然后再重新遍历全局分配区链表，尝试对分配区加锁，如果经过第二次尝试仍然未能获得一个分配区，只能创建一个新的非主分配区了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Nothing immediately available, so generate a new arena. */</span></span><br><span class="line">a = _int_new_arena(size);</span><br><span class="line">(<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br></pre></td></tr></table></figure></p>
<p>通过前面的所有尝试都未能获得一个可用的分配区，只能创建一个新的非主分配区，执行到这里，可以确保获得了全局锁<code>list_lock</code>，在创建完新的分配区，并将分配区加入了全局分配区链表中以后，需要对全局锁<code>list_lock</code>解锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="int-new-arena"><a href="#int-new-arena" class="headerlink" title="_int_new_arena()"></a>_int_new_arena()</h3><p><code>_int_new_arena()</code>函数用于创建一个非主分配区，在<code>arena_get2()</code>函数中被调用，该函数的实现代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line">_int_new_arena(<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    mstate a;</span><br><span class="line">    heap_info *h;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> misalign;</span><br><span class="line">    h = new_heap(size + (<span class="keyword">sizeof</span>(*h) + <span class="keyword">sizeof</span>(*a) + MALLOC_ALIGNMENT),</span><br><span class="line">    mp_.top_pad);</span><br><span class="line">    <span class="keyword">if</span>(!h) &#123;</span><br><span class="line">        <span class="comment">/* Maybe size is too large to fit in a single heap. So, just try</span></span><br><span class="line"><span class="comment">        to create a minimally-sized arena and let _int_malloc() attempt</span></span><br><span class="line"><span class="comment">        to deal with the large request via mmap_chunk(). */</span></span><br><span class="line">        h = new_heap(<span class="keyword">sizeof</span>(*h) + <span class="keyword">sizeof</span>(*a) + MALLOC_ALIGNMENT, mp_.top_pad);</span><br><span class="line">        <span class="keyword">if</span>(!h)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>对于一个新的非主分配区，至少包含一个<code>sub_heap</code>，每个非主分配区中都有相应的管理数据结构，每个非主分配区都有一个<code>heap_info</code>实例和<code>malloc_state</code>的实例，这两个实例都位于非主分配区的第一个<code>sub_heap</code>的开始部分，<code>malloc_state</code>实例紧接着<code>heap_info</code>实例。所以在创建非主分配区时，需要为管理数据结构分配额外的内存空间。 <code>new_heap()</code>函数创建一个新的<code>sub_heap</code>，并返回<code>sub_heap</code>的指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = h-&gt;ar_ptr = (mstate)(h+<span class="number">1</span>);</span><br><span class="line">malloc_init_state(a);</span><br><span class="line"><span class="comment">/*a-&gt;next = NULL;*/</span></span><br><span class="line">a-&gt;system_mem = a-&gt;max_system_mem = h-&gt;size;</span><br><span class="line">arena_mem += h-&gt;size;</span><br></pre></td></tr></table></figure></p>
<p>在<code>heap_info</code>实例后紧接着<code>malloc_state</code>实例，初始化<code>malloc_state</code>实例，更新该分配区所分配的内存大小的统计值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NO_THREADS</span></span><br><span class="line">    <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>)(mp_.mmapped_mem + arena_mem + main_arena.system_mem) &gt; mp_.max_total_mem)</span><br><span class="line">        mp_.max_total_mem = mp_.mmapped_mem + arena_mem + main_arena.system_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Set up the top chunk, with proper alignment. */</span></span><br><span class="line">    ptr = (<span class="type">char</span> *)(a + <span class="number">1</span>);</span><br><span class="line">    misalign = (<span class="type">unsigned</span> <span class="type">long</span>)chunk2mem(ptr) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">    <span class="keyword">if</span> (misalign &gt; <span class="number">0</span>)</span><br><span class="line">    ptr += MALLOC_ALIGNMENT - misalign;</span><br><span class="line">    top(a) = (mchunkptr)ptr;</span><br><span class="line">    set_head(top(a), (((<span class="type">char</span>*)h + h-&gt;size) - ptr) | PREV_INUSE);</span><br></pre></td></tr></table></figure></p>
<p>在<code>sub_heap</code>中<code>malloc_state</code>实例后的内存可以分配给用户使用，<code>ptr</code>指向存储<code>malloc_state</code>实例后的空闲内存，对<code>ptr</code>按照<code>2*SZ_SIZE</code>对齐后，将<code>ptr</code>赋值给分配区的<code>top chunk</code>，也就是说把<code>sub_heap</code>中整个空闲内存块作为<code>top chunk</code>，然后设置<code>top chunk</code>的<code>size</code>，并标识<code>top chunk</code>的前一个<code>chunk</code>为已处于分配状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tsd_setspecific(arena_key, (<span class="type">void_t</span> *)a);</span><br><span class="line">mutex_init(&amp;a-&gt;mutex);</span><br><span class="line">(<span class="type">void</span>)mutex_lock(&amp;a-&gt;mutex);</span><br></pre></td></tr></table></figure></p>
<p>将创建好的非主分配区加入线程的私有实例中，然后对非主分配区的锁进行初始化，并获得该锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">    (<span class="type">void</span>)mutex_lock(&amp;list_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Add the new arena to the global list. */</span></span><br><span class="line">    a-&gt;next = main_arena.next;</span><br><span class="line">    atomic_write_barrier ();</span><br><span class="line">    main_arena.next = a;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PER_THREAD</span></span><br><span class="line">    ++narenas;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>将刚创建的非主分配区加入到分配区的全局链表中，如果开启了<code>PER_THREAD</code>优化，在<code>arena_get2()</code>函数中没有对全局锁<code>list_lock</code>加锁，这里修改全局分配区链表时需要获得全局锁<code>list_lock</code>。如果没有开启<code>PER_THREAD</code>优化，<code>arene_get2()</code>函数调用<code>_int_new_arena()</code>函数时已经获得了全局锁<code>list_lock</code>，所以对全局分配区链表的修改不用再加锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    THREAD_STAT(++(a-&gt;stat_lock_loop));</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="new-heap"><a href="#new-heap" class="headerlink" title="new_heap()"></a>new_heap()</h3><p><code>new_heap()</code>函数负责从<code>mmap</code>区域映射一块内存来作为<code>sub_heap</code>，在32位系统上，该函数每次映射<code>1M</code>内存，映射的内存块地址按<code>1M</code>对齐；在64位系统上，该函数映射<code>64M</code>内存，映射的内存块地址按<code>64M</code>对齐。<code>new_heap()</code>函数只是映射一块虚拟地址空间，该空间不可读写，不会被<code>swap</code>。<code>new_heap()</code>函数的实现源代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If consecutive mmap (0, HEAP_MAX_SIZE &lt;&lt; 1, ...) calls return decreasing</span></span><br><span class="line"><span class="comment">addresses as opposed to increasing, new_heap would badly fragment the</span></span><br><span class="line"><span class="comment">address space. In that case remember the second HEAP_MAX_SIZE part73</span></span><br><span class="line"><span class="comment">aligned to HEAP_MAX_SIZE from last mmap (0, HEAP_MAX_SIZE &lt;&lt; 1, ...)</span></span><br><span class="line"><span class="comment">call (if it is already aligned) and try to reuse it next time. We need</span></span><br><span class="line"><span class="comment">no locking for it, as kernel ensures the atomicity for us - worst case</span></span><br><span class="line"><span class="comment">we&#x27;ll call mmap (addr, HEAP_MAX_SIZE, ...) for some value of addr in</span></span><br><span class="line"><span class="comment">multiple threads, but only one will succeed. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *aligned_heap_area;</span><br><span class="line"><span class="comment">/* Create a new heap. size is automatically rounded up to a multiple</span></span><br><span class="line"><span class="comment">of the page size. */</span></span><br><span class="line"><span class="type">static</span> heap_info *</span><br><span class="line">internal_function</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">new_heap(<span class="type">size_t</span> size, <span class="type">size_t</span> top_pad)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">new_heap(size, top_pad) <span class="type">size_t</span> size, top_pad;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_mask = malloc_getpagesize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> *p1, *p2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ul;</span><br><span class="line">    heap_info *h;</span><br><span class="line">    <span class="keyword">if</span>(size+top_pad &lt; HEAP_MIN_SIZE)</span><br><span class="line">        size = HEAP_MIN_SIZE;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size+top_pad &lt;= HEAP_MAX_SIZE)</span><br><span class="line">        size += top_pad;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(size &gt; HEAP_MAX_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        size = HEAP_MAX_SIZE;</span><br><span class="line">    size = (size + page_mask) &amp; ~page_mask;</span><br></pre></td></tr></table></figure><br>调整<code>size</code>的大小，<code>size</code>的最小值为<code>32K</code>，最大值<code>HEAP_MAX_SIZE</code>在不同的系统上不同，在32位系统为<code>1M</code>，64位系统为<code>64M</code>，将<code>size</code>的大小调整到最小值与最大值之间，并以页对齐，如果<code>size</code>大于最大值，直接报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A memory region aligned to a multiple of HEAP_MAX_SIZE is needed.</span></span><br><span class="line"><span class="comment">No swap space needs to be reserved for the following large</span></span><br><span class="line"><span class="comment">mapping (on Linux, this is the case for all non-writable mappings</span></span><br><span class="line"><span class="comment">anyway). */</span></span><br><span class="line">    p2 = MAP_FAILED;</span><br><span class="line">    <span class="keyword">if</span>(aligned_heap_area) &#123;</span><br><span class="line">        p2 = (<span class="type">char</span> *)MMAP(aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE,</span><br><span class="line">        MAP_PRIVATE|MAP_NORESERVE);</span><br><span class="line">        aligned_heap_area = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (p2 != MAP_FAILED &amp;&amp; ((<span class="type">unsigned</span> <span class="type">long</span>)p2 &amp; (HEAP_MAX_SIZE<span class="number">-1</span>))) &#123;</span><br><span class="line">            munmap(p2, HEAP_MAX_SIZE);</span><br><span class="line">            p2 = MAP_FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>全局变量<code>aligned_heap_area</code>是上一次调用<code>mmap</code>分配内存的结束虚拟地址，并已经按照<code>HEAP_MAX_SIZE</code>大小对齐。如果<code>aligned_heap_area</code>不为空，尝试从上次映射结束地址开始映射大小为<code>HEAP_MAX_SIZE</code>的内存块，由于全局变量<code>aligned_heap_area</code>没有锁保护，可能存在多个线程同时<code>mmap()</code>函数从<code>aligned_heap_area</code>开始映射新的虚拟内存块，操作系统会保证只会有一个线程会成功，其它在同一地址映射新虚拟内存块都会失败。无论映射是否成功，都将全局变量<code>aligned_heap_area</code>设置为<code>NULL</code>。如果映射成功，但返回的虚拟地址不是按<code>HEAP_MAX_SIZE</code>大小对齐的，取消该区域的映射，映射失败。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p2 == MAP_FAILED) &#123;</span><br><span class="line">    p1 = (<span class="type">char</span> *)MMAP(<span class="number">0</span>, HEAP_MAX_SIZE&lt;&lt;<span class="number">1</span>, PROT_NONE,</span><br><span class="line">    MAP_PRIVATE|MAP_NORESERVE);</span><br></pre></td></tr></table></figure></p>
<p>全局变量<code>aligned_heap_area</code>为<code>NULL</code>，或者从<code>aligned_heap_area</code>开始映射失败了，尝试映射2倍<code>HEAP_MAX_SIZE</code>大小的虚拟内存，便于地址对齐，因为在最坏可能情况下，需要映射2倍<code>HEAP_MAX_SIZE</code>大小的虚拟内存才能实现地址按照<code>HEAP_MAX_SIZE</code>大小对齐。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p1 != MAP_FAILED) &#123;</span><br><span class="line">    p2 = (<span class="type">char</span> *)(((<span class="type">unsigned</span> <span class="type">long</span>)p1 + (HEAP_MAX_SIZE<span class="number">-1</span>)) &amp; ~(HEAP_MAX_SIZE<span class="number">-1</span>));</span><br><span class="line">    ul = p2 - p1;</span><br><span class="line">    <span class="keyword">if</span> (ul)</span><br><span class="line">        munmap(p1, ul);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        aligned_heap_area = p2 + HEAP_MAX_SIZE;</span><br><span class="line">    munmap(p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>映射2倍<code>HEAP_MAX_SIZE</code>大小的虚拟内存成功，将大于等于<code>p1</code>并按<code>HEAP_MAX_SIZE</code>大小对齐的第一个虚拟地址赋值给<code>p2</code>，<code>p2</code>作为<code>sub_heap</code>的起始虚拟地址，<code>p2+HEAP_MAX_SIZE</code>作为<code>sub_heap</code>的结束地址，并将<code>sub_heap</code>的结束地址赋值给全局变量<code>aligned_heap_area</code>，最后还需要将多余的虚拟内存还回给操作系统。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Try to take the chance that an allocation of only HEAP_MAX_SIZE</span></span><br><span class="line"><span class="comment">    is already aligned. */</span></span><br><span class="line">    p2 = (<span class="type">char</span> *)MMAP(<span class="number">0</span>, HEAP_MAX_SIZE, PROT_NONE, MAP_PRIVATE|MAP_NORESERVE);</span><br><span class="line">    <span class="keyword">if</span>(p2 == MAP_FAILED)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>)p2 &amp; (HEAP_MAX_SIZE<span class="number">-1</span>)) &#123;</span><br><span class="line">        munmap(p2, HEAP_MAX_SIZE);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>映射2倍<code>HEAP_MAX_SIZE</code>大小的虚拟内存失败了，再尝试映射<code>HEAP_MAX_SIZE</code>大小的虚拟内存，如果失败，返回；如果成功，但该虚拟地址不是按照<code>HEAP_MAX_SIZE</code>大小对齐的，返回。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(mprotect(p2, size, PROT_READ|PROT_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">    munmap(p2, HEAP_MAX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">h = (heap_info *)p2;</span><br><span class="line">h-&gt;size = size;</span><br><span class="line">h-&gt;mprotect_size = size;</span><br><span class="line">THREAD_STAT(stat_n_heaps++);</span><br></pre></td></tr></table></figure></p>
<p>调用<code>mprotect()</code>函数将<code>size</code>大小的内存设置为可读可写，如果失败，解除整个<code>sub_heap</code>的映射。然后更新<code>heap_info</code>实例中的相关字段。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="get-free-list-和reused-arena"><a href="#get-free-list-和reused-arena" class="headerlink" title="get_free_list()和reused_arena()"></a>get_free_list()和reused_arena()</h3><p>这两个函数在开启了<code>PER_THRAD</code>优化时用于获取分配区（arena），<code>arena_get2</code>首先调用<code>get_free_list()</code>尝试获得<code>arena</code>，如果失败在尝试调用<code>reused_arena()</code>获得<code>arena</code>，如果仍然没有获得分配区，调用<code>_int_new_arena()</code>创建一个新的分配区。<code>get_free_list()</code>函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">get_free_list</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mstate result = free_list;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_lock(&amp;list_lock);</span><br><span class="line">        result = free_list;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">            free_list = result-&gt;next_free;</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;list_lock);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (<span class="type">void</span>)mutex_lock(&amp;result-&gt;mutex);</span><br><span class="line">            tsd_setspecific(arena_key, (<span class="type">void_t</span> *)result);</span><br><span class="line">            THREAD_STAT(++(result-&gt;stat_lock_loop));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数实现很简单，首先查看<code>arena</code>的<code>free_list</code>中是否为<code>NULL</code>，如果不为<code>NULL</code>，获得全局锁<code>list_lock</code>，将<code>free_list</code>的第一个<code>arena</code>从单向链表中取出，解锁<code>list_lock</code>。如果从<code>free_list</code>中获得一个<code>arena</code>，对该<code>arena</code>加锁，并将该<code>arena</code>加入线程的私有实例中。</p>
<p><code>reused_arena()</code>函数的源代码实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> mstate</span><br><span class="line"><span class="title function_">reused_arena</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (narenas &lt;= mp_.arena_test)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<p>首先判断全局分配区的总数是否小于分配区的个数的限定值（arena_test） ，在32位系统上<code>arena_test</code>默认值为2，64位系统上的默认值为8，如果当前进程的分配区数量没有达到限定值，直接返回<code>NULL</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> narenas_limit;</span><br><span class="line"><span class="keyword">if</span> (narenas_limit == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mp_.arena_max != <span class="number">0</span>)</span><br><span class="line">        narenas_limit = mp_.arena_max;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = __get_nprocs ();</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">1</span>)</span><br><span class="line">            narenas_limit = NARENAS_FROM_NCORES (n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">/* We have no information about the system. Assume two cores. */</span></span><br><span class="line">            narenas_limit = NARENAS_FROM_NCORES (<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (narenas &lt; narenas_limit)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>设定全局变量<code>narenas_limit</code>，如果应用层设置了进程的最大分配区个数（arena_max），将<code>arena_max</code>赋值给<code>narenas_limit</code>，否则根据系统的<code>cpu</code>个数和系统的字大小设定<code>narenas_limit</code>的大小，<code>narenas_limit</code>的大小默认与<code>arena_test</code>大小相同。然后再次判断进程的当前分配区个数是否达到了分配区的限制个数，如果没有达到限定值，返回。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    mstate result;</span><br><span class="line">    <span class="type">static</span> mstate next_to_use;</span><br><span class="line">    <span class="keyword">if</span> (next_to_use == <span class="literal">NULL</span>)</span><br><span class="line">        next_to_use = &amp;main_arena;</span><br><span class="line">    result = next_to_use;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mutex_trylock(&amp;result-&gt;mutex))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        result = result-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (result != next_to_use);</span><br><span class="line">    <span class="comment">/* No arena available. Wait for the next in line. */</span></span><br><span class="line">    (<span class="type">void</span>)mutex_lock(&amp;result-&gt;mutex);</span><br><span class="line">out:</span><br><span class="line">    tsd_setspecific(arena_key, (<span class="type">void_t</span> *)result);</span><br><span class="line">    THREAD_STAT(++(result-&gt;stat_lock_loop));</span><br><span class="line">    next_to_use = result-&gt;next;</span><br></pre></td></tr></table></figure></p>
<p>全局变量<code>next_to_use</code>指向下一个可能可用的分配区，该全局变量没有锁保护，主要用于记录上次遍历分配区循环链表到达的位置，避免每次都从同一个分配区开始遍历，导致从某个分配区分配的内存过多。首先判断<code>next_to_use</code>是否为<code>NULL</code>，如果是，将主分配区赋值给<code>next_to_use</code>。然后从<code>next_to_use</code>开始遍历分配区链表，尝试对遍历的分配区加锁，如果加锁成功，退出循环，如果遍历分配区循环链表中的所有分配区，尝试加锁都失败了，等待获得<code>next_to_use</code>指向的分配区的锁。执行到<code>out</code>的代码，意味着已经获得一个分配区的锁，将该分配区加入线程私有实例，并将当前分配区的下一个分配区赋值给<code>next_to_use</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="grow-heap-shrink-heap-delete-heap-heap-trim"><a href="#grow-heap-shrink-heap-delete-heap-heap-trim" class="headerlink" title="grow_heap(),shrink_heap(),delete_heap(),heap_trim()"></a>grow_heap(),shrink_heap(),delete_heap(),heap_trim()</h3><p>这几个函数实现<code>sub_heap</code>和增长和收缩，<code>grow_heap()</code>函数主要将<code>sub_heap</code>中可读可写区域扩大；<code>shrink_heap()</code>函数缩小<code>sub_heap</code>的虚拟内存区域，减小该<code>sub_heap</code>的虚拟内存占用量；<code>delete_heap()</code>为一个宏，如果<code>sub_heap</code>中所有的内存都空闲，使用该宏函数将<code>sub_heap</code>的虚拟内存还回给操作系统；<code>heap_trim()</code>函数根据<code>sub_heap</code>的<code>top chunk</code>大小调用<code>shrink_heap()</code>函数收缩<code>sub_heap</code>。</p>
<p><code>grow_heap()</code>函数的实现代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">grow_heap(heap_info *h, <span class="type">long</span> diff)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">grow_heap(h, diff) heap_info *h; <span class="type">long</span> diff;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_mask = malloc_getpagesize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> new_size;</span><br><span class="line">    diff = (diff + page_mask) &amp; ~page_mask;</span><br><span class="line">    new_size = (<span class="type">long</span>)h-&gt;size + diff;</span><br><span class="line">    <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>) new_size &gt; (<span class="type">unsigned</span> <span class="type">long</span>) HEAP_MAX_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>) new_size &gt; h-&gt;mprotect_size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mprotect((<span class="type">char</span> *)h + h-&gt;mprotect_size,</span><br><span class="line">        (<span class="type">unsigned</span> <span class="type">long</span>) new_size - h-&gt;mprotect_size,</span><br><span class="line">        PROT_READ|PROT_WRITE) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        h-&gt;mprotect_size = new_size;</span><br><span class="line">    &#125;</span><br><span class="line">    -&gt;size = new_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>grow_heap()</code>函数的实现比较简单，首先将要增加的可读可写的内存大小按照页对齐，然后计算<code>sub_heap</code>总的可读可写的内存大小<code>new_size</code>，判断<code>new_size</code>是否大于<code>HEAP_MAX_SIZE</code>，如果是，返回，否则判断<code>new_size</code>是否大于当前<code>sub_heap</code>的可读可写区域大小，如果否，调用<code>mprotect()</code>设置新增的区域可读可写，并更新当前<code>sub_heap</code>的可读可写区域的大小为<code>new_size</code>。最后将当前<code>sub_heap</code>的字段<code>size</code>更新为<code>new_size</code>。<code>shrink_heap()</code>函数的实现源代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">shrink_heap(heap_info *h, <span class="type">long</span> diff)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">shrink_heap(h, diff) heap_info *h; <span class="type">long</span> diff;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> new_size;</span><br><span class="line">    new_size = (<span class="type">long</span>)h-&gt;size - diff;</span><br><span class="line">    <span class="keyword">if</span>(new_size &lt; (<span class="type">long</span>)<span class="keyword">sizeof</span>(*h))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* Try to re-map the extra heap space freshly to save memory, and make it inaccessible. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC79</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="type">char</span> *)MMAP((<span class="type">char</span> *)h + new_size, diff, PROT_NONE,</span><br><span class="line">        MAP_PRIVATE|MAP_FIXED) == (<span class="type">char</span> *) MAP_FAILED)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        h-&gt;mprotect_size = new_size;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        madvise ((<span class="type">char</span> *)h + new_size, diff, MADV_DONTNEED);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*fprintf(stderr, &quot;shrink %p %08lx\n&quot;, h, new_size);*/</span></span><br><span class="line">    h-&gt;size = new_size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>shrink_heap()</code>函数的参数<code>diff</code>已经页对齐，同时<code>sub_heap</code>的<code>size</code>也是安装页对齐的，所以计算<code>sub_heap</code>的<code>new_size</code>时不用再处理页对齐。如果<code>new_size</code>比<code>sub_heap</code>的首地址还小，报错退出，如果该函数运行在非<code>Glibc</code>中，则从<code>sub_heap</code>中切割出<code>diff</code>大小的虚拟内存，创建一个新的不可读写的映射区域，注意<code>mmap()</code>函数这里使用了<code>MAP_FIXED</code>标志，然后更新<code>sub_heap</code>的可读可写内存大小。如果该函数运行在<code>Glibc</code>库中，则调用<code>madvise()</code>函数，实际上<code>madvise()</code>函数什么也不做，只是返回错误，这里并没有处理<code>madvise()</code>函数的返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> delete_heap(heap) \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((char *)(heap) + HEAP_MAX_SIZE == aligned_heap_area) \</span></span><br><span class="line"><span class="meta">        aligned_heap_area = NULL; \</span></span><br><span class="line"><span class="meta">    munmap((char*)(heap), HEAP_MAX_SIZE); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>
<p><code>delete_heap()</code>宏函数首先判断当前删除的<code>sub_heap</code>的结束地址是否与全局变量<code>aligned_heap_area</code>指向的地址相同，如果相同，则将全局变量<code>aligned_heap_area</code>设置为<code>NULL</code>，因为当前<code>sub_heap</code>删除以后，就可以从当前<code>sub_heap</code>的起始地址或是更低的地址开始映射新的<code>sub_heap</code>，这样可以尽量从地地址映射内存。然后调用<code>munmap()</code>函数将整个<code>sub_heap</code>的虚拟内存区域释放掉。在调用<code>munmap()</code>函数时，<code>heap_trim()</code>函数调用<code>shrink_heap()</code>函数可能已将<code>sub_heap</code>切分成多个子区域，<code>munmap()</code>函数的第二个参数为<code>HEAP_MAX_SIZE</code>，无论该<code>sub_heap</code>（大小为<code>HEAP_MAX_SIZE</code>）的内存区域被切分成多少个子区域，将整个<code>sub_heap</code>都释放掉了。</p>
<p><code>heap_trim()</code>函数的源代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">internal_function80</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">heap_trim(heap_info *heap, <span class="type">size_t</span> pad)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">heap_trim(heap, pad) heap_info *heap; <span class="type">size_t</span> pad;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr = heap-&gt;ar_ptr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pagesz = mp_.pagesize;</span><br><span class="line">    mchunkptr top_chunk = top(ar_ptr), p, bck, fwd;</span><br><span class="line">    heap_info *prev_heap;</span><br><span class="line">    <span class="type">long</span> new_size, top_size, extra;</span><br><span class="line">    <span class="comment">/* Can this heap go away completely? */</span></span><br><span class="line">    <span class="keyword">while</span>(top_chunk == chunk_at_offset(heap, <span class="keyword">sizeof</span>(*heap))) &#123;</span><br></pre></td></tr></table></figure></p>
<p>每个非主分配区至少有一个<code>sub_heap</code>，每个非主分配区的第一个<code>sub_heap</code>中包含了一个<code>heap_info</code>的实例和<code>malloc_state</code>的实例，分主分配区中的其它<code>sub_heap</code>中只有一个<code>heap_info</code>实例，紧跟<code>heap_info</code>实例后，为可以用于分配的内存块。当当前非主分配区的<code>topchunk</code>与当前<code>sub_heap</code>的<code>heap_info</code>实例的结束地址相同时，意味着当前<code>sub_heap</code>中只有一个空闲<code>chunk</code>，没有已分配的<code>chunk</code>。所以可以将当前整个<code>sub_heap</code>都释放掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">prev_heap = heap-&gt;prev;</span><br><span class="line">p = chunk_at_offset(prev_heap, prev_heap-&gt;size - (MINSIZE<span class="number">-2</span>*SIZE_SZ));</span><br><span class="line">assert(p-&gt;size == (<span class="number">0</span>|PREV_INUSE)); <span class="comment">/* must be fencepost */</span></span><br><span class="line">p = prev_chunk(p);</span><br><span class="line">new_size = chunksize(p) + (MINSIZE<span class="number">-2</span>*SIZE_SZ);</span><br><span class="line">assert(new_size&gt;<span class="number">0</span> &amp;&amp; new_size&lt;(<span class="type">long</span>)(<span class="number">2</span>*MINSIZE));</span><br><span class="line"><span class="keyword">if</span>(!prev_inuse(p))</span><br><span class="line">    new_size += p-&gt;prev_size;</span><br><span class="line">assert(new_size&gt;<span class="number">0</span> &amp;&amp; new_size&lt;HEAP_MAX_SIZE);</span><br><span class="line"><span class="keyword">if</span>(new_size + (HEAP_MAX_SIZE - prev_heap-&gt;size) &lt; pad + MINSIZE + pagesz)</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>每个<code>sub_heap</code>的可读可写区域的末尾都有两个<code>chunk</code>用于<code>fencepost</code>，以64位系统为例，最后一个<code>chunk</code>占用的空间为<code>MINSIZE-2*SIZE_SZ</code>，为<code>16B</code>，最后一个<code>chuk</code>的<code>size</code>字段记录的前一个<code>chunk</code>为<code>inuse</code>状态，并标识当前<code>chunk</code>大小为0，倒数第二个<code>chunk</code>为<code>inuse</code>状态，这个<code>chunk</code>也是<code>fencepost</code>的一部分，这个<code>chunk</code>的大小为<code>2*SIZE_SZ</code>，为<code>16B</code>，所以用于<code>fencepost</code>的两个<code>chunk</code>的空间大小为32B。<code>fencepost</code>也有可能大于32B<code>，第二个</code>chunk<code>仍然为</code>16B<code>，第一个</code>chunk<code>的大小大于16B</code>，这种情况发生在<code>top chunk</code>的空间小于<code>2*MINSIZE</code>，大于<code>MINSIZE</code>，但对于一个完全空闲的<code>sub_heap</code>来说，<code>top chunk</code>的空间肯定大于<code>2*MINSIZE</code>，所以在这里不考虑这种情况。用于<code>fencepost</code>的<code>chunk</code>空间其实都是被分配给应用层使用的，<code>new_size</code>表示当前<code>sub_heap</code>中可读可写区域的可用空间，如果倒数第二个<code>chunk</code>的前一个<code>chunk</code>为空闲状态，当前<code>sub_heap</code>中可读可写区域的可用空间大小还需要加上这个空闲<code>chunk</code>的大小。如果<code>new_size</code>与<code>sub_heap</code>中剩余的不可读写的区域大小之和小于32+4K（64位系统），意味着前一个<code>sub_heap</code>的可用空间太少了，不能释放当前的<code>sub_heap</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    ar_ptr-&gt;system_mem -= heap-&gt;size;</span><br><span class="line">    arena_mem -= heap-&gt;size;</span><br><span class="line">    delete_heap(heap);</span><br><span class="line">    heap = prev_heap;</span><br><span class="line">    <span class="keyword">if</span>(!prev_inuse(p)) &#123; <span class="comment">/* consolidate backward */</span></span><br><span class="line">        p = prev_chunk(p);</span><br><span class="line">        unlink(p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line">assert(((<span class="type">unsigned</span> <span class="type">long</span>)((<span class="type">char</span>*)p + new_size) &amp; (pagesz<span class="number">-1</span>)) == <span class="number">0</span>);</span><br><span class="line">assert( ((<span class="type">char</span>*)p + new_size) == ((<span class="type">char</span>*)heap + heap-&gt;size) );</span><br><span class="line">top(ar_ptr) = top_chunk = p;</span><br><span class="line">set_head(top_chunk, new_size | PREV_INUSE);</span><br><span class="line"><span class="comment">/*check_chunk(ar_ptr, top_chunk);*/</span></span><br></pre></td></tr></table></figure></p>
<p>首先更新非主分配区的内存统计，然后调用<code>delete_heap()</code>宏函数释放该<code>sub_heap</code>，把当前<code>heap</code>设置为被释放<code>sub_heap</code>的前一个<code>sub_heap</code>，<code>p</code>指向的是被释放<code>sub_heap</code>的前一个<code>sub_heap</code>的倒数第二个<code>chunk</code>，如果<code>p</code>的前一个<code>chunk</code>为空闲状态，由于不可能出现多个连续的空闲<code>chunk</code>，所以将<code>p</code>设置为<code>p</code>的前一个<code>chunk</code>，也就是<code>p</code>指向空闲<code>chunk</code>，并将该空闲<code>chunk</code>从空闲<code>chunk</code>链表中移除，并将将该空闲<code>chunk</code>赋值给<code>sub_heap</code>的<code>top chunk</code>，并设置<code>top chunk</code>的<code>size</code>，标识<code>top chunk</code>的前一个<code>chunk</code>处于<code>inuse</code>状态。然后继续判断循环条件，如果循环条件不满足，退出循环，如果条件满足，继续对当前<code>sub_heap</code>进行收缩。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">    top_size = chunksize(top_chunk);</span><br><span class="line">    extra = ((top_size - pad - MINSIZE + (pagesz<span class="number">-1</span>))/pagesz - <span class="number">1</span>) * pagesz;</span><br><span class="line">    <span class="keyword">if</span>(extra &lt; (<span class="type">long</span>)pagesz)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Try to shrink. */</span></span><br><span class="line">    <span class="keyword">if</span>(shrink_heap(heap, extra) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ar_ptr-&gt;system_mem -= extra;</span><br><span class="line">    arena_mem -= extra;</span><br><span class="line">    <span class="comment">/* Success. Adjust top accordingly. */</span></span><br><span class="line">    set_head(top_chunk, (top_size - extra) | PREV_INUSE);</span><br><span class="line">    <span class="comment">/*check_chunk(ar_ptr, top_chunk);*/</span></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">首先查看`top chunk`的大小，如果`top chunk`的大小减去`pad`和`MINSIZE`小于一页大小，返回退出，否则调用`shrink_heap()`函数对当前`sub_heap`进行收缩，将空闲的整数个页收缩掉，仅剩下不足一页的空闲内存，如果`shrink_heap()`失败，返回退出，否则，更新内存使用统计，更新`top chunk`的大小。</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存分配malloc"><a href="#内存分配malloc" class="headerlink" title="内存分配malloc"></a>内存分配malloc</h2><p><code>ptmalloc2</code>主要的内存分配函数为<code>malloc()</code>，但源代码中并不能找到该函数，该函数是用宏定义为<code>public_malloc()</code>，因为该函数在不同的编译条件下，具有不同的名称。<code>public_malloc()</code>函数只是简单的封装<code>_int_malloc()</code>函数，<code>_int_malloc()</code>函数才是内存分配的核心实现。下面我们将分析<code>malloc</code>的实现。</p>
<h3 id="public-malloc"><a href="#public-malloc" class="headerlink" title="public_malloc()"></a>public_malloc()</h3><p>先给出源代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void_t</span>*</span><br><span class="line"><span class="title function_">public_malloc</span><span class="params">(<span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void_t</span> *victim;</span><br><span class="line">    <span class="type">__malloc_ptr_t</span> (*hook) (<span class="type">size_t</span>, __const <span class="type">__malloc_ptr_t</span>)</span><br><span class="line">    = force_reg (__malloc_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure></p>
<p>首先检查是否存在内存分配的<code>hook</code>函数，如果存在，调用<code>hook</code>函数，并返回，<code>hook</code>函数主要用于进程在创建新线程过程中分配内存，或者支持用户提供的内存分配函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arena_lookup(ar_ptr);</span><br><span class="line">arena_lock(ar_ptr, bytes);</span><br><span class="line"><span class="keyword">if</span>(!ar_ptr)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">victim = _int_malloc(ar_ptr, bytes);</span><br></pre></td></tr></table></figure>
<p>获取分配区指针，如果获取分配区失败，返回退出，否则，调用<code>_int_malloc()</code>函数分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!victim) &#123;</span><br><span class="line">    <span class="comment">/* Maybe the failure is due to running out of mmapped areas. */</span></span><br><span class="line">    <span class="keyword">if</span>(ar_ptr != &amp;main_arena) &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">        ar_ptr = &amp;main_arena;</span><br><span class="line">        (<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">        victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br></pre></td></tr></table></figure>
<p>如果<code>_int_malloc()</code>函数分配内存失败，并且使用的分配区不是主分配区，这种情况可能是<code>mmap</code>区域的内存被用光了，当主分配区可以从堆中分配内存，所以需要再尝试从主分配区中分配内存。首先释放所使用分配区的锁，然后获得主分配区的锁，并调用<code>_int_malloc()</code>函数分配内存，最后释放主分配区的锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_ARENAS</span></span><br><span class="line">            <span class="comment">/* ... or sbrk() has failed and there is still a chance to mmap() */</span></span><br><span class="line">            ar_ptr = arena_get2(ar_ptr-&gt;next ? ar_ptr : <span class="number">0</span>, bytes);</span><br><span class="line">            (<span class="type">void</span>)mutex_unlock(&amp;main_arena.mutex);</span><br><span class="line">            <span class="keyword">if</span>(ar_ptr) &#123;</span><br><span class="line">                victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">                (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>_int_malloc()</code>函数分配内存失败，并且使用的分配区是主分配区，查看是否有非主分配区，如果有，调用<code>arena_get2()</code>获取分配区，然后对主分配区解锁，如果<code>arena_get2()</code>返回一个非主分配区，尝试调用<code>_int_malloc()</code>函数从该非主分配区分配内存，最后释放该非主分配区的锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br></pre></td></tr></table></figure></p>
<p>如果<code>_int_malloc()</code>函数分配内存成功，释放所使用的分配区的锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||</span><br><span class="line">    ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br><span class="line">    <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc()"></a>_int_malloc()</h3><p><code>_int_malloc()</code>函数是内存分配的核心，根据分配的内存块的大小，该函数中实现了四种分配内存的路径，下面将分别分析这四种分配路径。</p>
<p>先给出<code>_int_malloc()</code>函数的函数定义及临时变量的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void_t</span>*</span><br><span class="line">_int_malloc(mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T nb; <span class="comment">/* normalized request size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx; <span class="comment">/* associated bin index */</span></span><br><span class="line">    mbinptr bin; <span class="comment">/* associated bin */</span></span><br><span class="line">    mchunkptr victim; <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">    INTERNAL_SIZE_T size; <span class="comment">/* its size */</span></span><br><span class="line">    <span class="type">int</span> victim_index; <span class="comment">/* its bin index */</span></span><br><span class="line">    mchunkptr remainder; <span class="comment">/* remainder from a split */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">/* its size */</span><span class="number">84</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> block; <span class="comment">/* bit map traverser */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bit; <span class="comment">/* bit map traverser */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>; <span class="comment">/* current word of binmap */</span></span><br><span class="line">    mchunkptr fwd; <span class="comment">/* misc temp for linking */</span></span><br><span class="line">    mchunkptr bck; <span class="comment">/* misc temp for linking */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">    overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">    to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">    size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">    that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">    aligned.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    checked_request2size(bytes, nb);</span><br></pre></td></tr></table></figure></p>
<p><code>checked_request2size()</code>函数将需要分配的内存大小<code>bytes</code>转换为需要分配的<code>chunk</code>大小<code>nb</code>。<code>ptmalloc</code>内部分配都是以<code>chunk</code>为单位，根据<code>chunk</code>的大小，决定如何获得满足条件的<code>chunk</code>。</p>
<h4 id="分配fast-bin-chunk"><a href="#分配fast-bin-chunk" class="headerlink" title="分配fast bin chunk"></a>分配fast bin chunk</h4><p>如果所需的<code>chunk</code>大小小于等于<code>fast bins</code>中的最大<code>chunk</code>大小，首先尝试从<code>fast bins</code>中分配<code>chunk</code>。源代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())) &#123;</span><br><span class="line">        idx = fastbin_index(nb);</span><br><span class="line">        mfastbinptr* fb = &amp;fastbin (av, idx);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">        mchunkptr pp = *fb;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            victim = pp;</span><br><span class="line">            <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) != victim);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        victim = *fb;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (victim != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">errout:</span><br><span class="line">                malloc_printerr (check_action, errstr, chunk2mem (victim));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ATOMIC_FASTBINS</span></span><br><span class="line">            *fb = victim-&gt;fd;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            check_remalloced_chunk(av, victim, nb);</span><br><span class="line">            <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">                alloc_perturb (p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没有开启<code>ATOMIC_FASTBINS</code>优化，从<code>fast bins</code>中分配一个<code>chunk</code>相当简单，首先根据所需<code>chunk</code>的大小获得该<code>chunk</code>所属<code>fast bin</code>的<code>index</code>，根据该<code>index</code>获得所需<code>fast bin</code>的空闲<code>chunk</code>链表的头指针，然后将头指针的下一个<code>chunk</code>作为空闲<code>chunk</code>链表的头部。为了加快从<code>fast bins</code>中分配<code>chunk</code>，处于<code>fast bins</code>中<code>chunk</code>的状态仍然保持为<code>inuse</code>状态，避免被相邻的空闲<code>chunk</code>合并，从<code>fast bins</code>中分配<code>chunk</code>，只需取出第一个<code>chunk</code>，并调用<code>chunk2mem()</code>函数返回用户所需的内存块。</p>
<p>如果开启<code>ATOMIC_FASTBINS</code>优化，这里使用了<code>lock-free</code>的技术实现单向链表删除第一个<code>node</code>的操作。<code>lock-free</code>算法的基础是<code>CAS</code>(Compareand-Swap)原子操作。当某个地址的原始值等于某个比较值时，把值改成新值，无论有否修改，返回这个地址的原始值。目前的<code>cpu</code>支持最多64位的<code>CAS</code>，并且指针<code>p</code>必须对齐。原子操作指一个<code>cpu</code>时钟周期内就可以完成的操作，不会被其他线程干扰。</p>
<p>一般的<code>CAS</code>使用方式是：假设有指针<code>p</code>，它指向一个32位或者64位数，</p>
<ol>
<li>复制<code>p</code>的内容（<code>*p</code>）到比较量<code>cmp</code>（原子操作）。</li>
<li>基于这个比较量计算一个新值<code>xchg</code>（非原子操作）。</li>
<li>调用<code>CAS</code>比较当前<code>*p</code>和<code>cmp</code>，如果相等把<code>*p</code>替换成<code>xchg</code>（原子操作）。</li>
<li>如果成功退出，否则回到第一步重新进行。</li>
</ol>
<p>第3步的<code>CAS</code>操作保证了写入的同时<code>p</code>没有被其他线程更改。如果<code>*p</code>已经被其他线程更改，那么第2步计算新值所使用的值<code>cmp</code>已经过期了，因此这个整个过程失败，重新来过。多线程环境下，由于3是一个原子操作，那么起码有一个线程（最快执行到3）的<code>CAS</code>操作可以成功，这样整体上看，就保证了所有的线程上在“前进”，而不需要使用效率低下的锁来协调线程，更不会导致死锁之类的麻烦。</p>
<p><code>ABA</code>问题，当<code>A</code>线程执行2的时候，被<code>B</code>线程更改了<code>*p</code>为<code>x</code>，而<code>C</code>线程又把它改回了原始值，这时回到<code>A</code>线程，<code>A</code>线程无法监测到原始值已经被更改过了，<code>CAS</code>操作会成功（实际上应该失败）。<code>ABA</code>大部分情况下会造成一些问题，因为<code>p</code>的内容一般不可能是独立的，其他内容已经更改，而<code>A</code>线程认为它没有更改就会带来不可预知的结果。</p>
<p>如果开启<code>ATOMIC_FASTBINS</code>优化，这里的实现会出现<code>ABA</code>问题吗？不会出现，如果开启了<code>ATOMIC_FASTBINS</code>优化，在<code>free</code>时，如果释放的<code>chunk</code>属于<code>fast bin</code>，不需要对分配区加锁，可以通过<code>lock-free</code>技术将该<code>chunk</code>加入<code>fast bins</code>的链表中。当从分配区分配内存时，需要对分配区加锁，所以当<code>A</code>线程获得了分配区的锁，并从<code>fast bin</code>中分配内存执行2的时候，被<code>B</code>线程调用<code>free</code>函数向<code>fast bin</code>的链表中加入了一个新的<code>chunk</code>，即更改了<code>*fb</code>为<code>x</code>，但不会存在<code>C</code>线程将<code>*fb</code>改回原值，如果存在，意味着<code>C</code>线程先分配了<code>*fb</code>所存的<code>chunk</code>，并将该<code>chunk</code>释放回了<code>fast bin</code>，但<code>C</code>线程分配<code>*fb</code>所存的<code>chunk</code>需要获得分配区的锁，但分配区的锁被<code>A</code>线程持有，所以<code>C</code>线程不可能将<code>*fb</code>改回原值，也就不会存在<code>ABA</code>问题。</p>
<h4 id="分配small-bin-chunk"><a href="#分配small-bin-chunk" class="headerlink" title="分配small bin chunk"></a>分配small bin chunk</h4><p>如果所需的<code>chunk</code>大小属于<code>small bin</code>，则会执行如下的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If a small request, check regular bin. Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">(For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">        idx = smallbin_index(nb);</span><br><span class="line">        bin = bin_at(av,idx);</span><br><span class="line">        <span class="keyword">if</span> ( (victim = last(bin)) != bin) &#123;</span><br><span class="line">            <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">                malloc_consolidate(av);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                bck = victim-&gt;bk;</span><br><span class="line">                <span class="keyword">if</span> (__builtin_expect (bck-&gt;fd != victim, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                    <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">                set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">                bin-&gt;bk = bck;</span><br><span class="line">                bck-&gt;fd = bin;</span><br><span class="line">                <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                    victim-&gt;size |= NON_MAIN_ARENA;<span class="number">87</span></span><br><span class="line">                check_malloced_chunk(av, victim, nb);</span><br><span class="line">                <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">                <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">                    alloc_perturb (p, bytes);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果分配的<code>chunk</code>属于<code>small bin</code>，首先查找<code>chunk</code>所对应<code>small bins</code>数组的<code>index</code>，然后根据<code>index</code>获得某个<code>small bin</code>的空闲<code>chunk</code>双向循环链表表头，然后将最后一个<code>chunk</code>赋值给<code>victim</code>，如果<code>victim</code>与表头相同，表示该链表为空，不能从<code>small bin</code>的空闲<code>chunk</code>链表中分配，这里不处理，等后面的步骤来处理。如果<code>victim</code>与表头不同，有两种情况，如果<code>victim</code>为0，表示<code>small bin</code>还没有初始化为双向循环链表，调用<code>malloc_consolidate()</code>函数将<code>fast bins</code>中的<code>chunk</code>合并。否则，将<code>victim</code>从<code>small bin</code>的双向循环链表中取出，设置<code>victim chunk</code>的<code>inuse</code>标志，该标志处于<code>victim chunk</code>的下一个相邻<code>chunk</code>的<code>size</code>字段的第一个<code>bit</code>。从<code>small bin</code>中取出一个<code>chunk</code>也可以用<code>unlink()</code>宏函数，只是这里没有使用。</p>
<p>接着判断当前分配区是否为非主分配区，如果是，将<code>victim chunk</code>的<code>size</code>字段中的表示非主分配区的标志<code>bit</code>清零，最后调用<code>chunk2mem()</code>函数获得<code>chunk</code>的实际可用的内存指针，将该内存指针返回给应用层。到此从<code>small bins</code>中分配<code>chunk</code>的工作完成了，但我们看到，当对应的<code>small bin</code>中没有空闲<code>chunk</code>，或是对应的<code>small bin</code>还没有初始化完成，并没有获取到<code>chunk</code>，这两种情况都需要后面的步骤来处理。</p>
<h4 id="分配large-bin-chunk"><a href="#分配large-bin-chunk" class="headerlink" title="分配large bin chunk"></a>分配large bin chunk</h4><p>如果所需的<code>chunk</code>不属于<code>small bins</code>，首先会执行如下的代码段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        idx = largebin_index(nb);</span><br><span class="line">        <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>所需<code>chunk</code>不属于<code>small bins</code>，那么就一定属于<code>large bins</code>，首先根据<code>chunk</code>的大小获得对应的<code>large bin</code>的<code>index</code>，接着判断当前分配区的<code>fast bins</code>中是否包含<code>chunk</code>，如果存在，调用<code>malloc_consolidate()</code>函数合并<code>fast bins</code>中的<code>chunk</code>，并将这些空闲<code>chunk</code>加入<code>unsorted bin</code>中。</p>
<p>下面的源代码实现从<code>last remainder chunk</code>，<code>large bins</code>和<code>top chunk</code>中分配所需的<code>chunk</code>，这里包含了多个多层循环，在这些循环中，主要工作是分配前两步都未分配成功的<code>small bin chunk</code>，<code>large bin chunk</code>和<code>large chunk</code>。最外层的循环用于重新尝试分配<code>small bin chunk</code>，因为如果在前一步分配<code>small bin chunk</code>不成功，并没有调用<code>malloc_consolidate()</code>函数合并<code>fast bins</code>中的<code>chunk</code>，将空闲<code>chunk</code>加入<code>unsorted bin</code>中，如果第一尝试从<code>last remainder chunk</code>，<code>top chunk</code>中分配<code>small bin chunk</code>都失败以后，如果<code>fast bins</code>中存在空闲<code>chunk</code>，会调用<code>malloc_consolidate()</code>函数，那么在<code>usorted bin</code>中就可能存在合适的<code>small bin chunk</code>供分配，所以需要再次尝试。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">the most recent non-exact fit. Place other traversed chunks in</span></span><br><span class="line"><span class="comment">bins. Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">chunks are placed in bins.</span></span><br><span class="line"><span class="comment">The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( (victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;</span><br></pre></td></tr></table></figure></p>
<p>反向遍历<code>unsorted bin</code>的双向循环链表，遍历结束的条件是循环链表中只剩下一个头结点。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>, chunk2mem (victim));</span><br><span class="line">size = chunksize(victim);</span><br></pre></td></tr></table></figure></p>
<p>检查当前遍历的<code>chunk</code>是否合法，<code>chunk</code>的大小不能小于等于<code>2 * SIZE_SZ</code>，也不能超过该分配区总的内存分配量。然后获取<code>chunk</code>的大小并赋值给<code>size</code>。这里的检查似乎有点小问题，直接使用了<code>victim-&gt;size</code>，但<code>victim-&gt;size</code>中包含了相关的标志位信息，使用<code>chunksize(victim)</code>才比较合理，但在<code>unsorted bin</code>中的空闲<code>chunk</code>的所有标志位都清零了，所以这里直接<code>victim-&gt;size</code>没有问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">only chunk in unsorted bin. This helps promote locality for</span></span><br><span class="line"><span class="comment">runs of consecutive small requests. This is the only89</span></span><br><span class="line"><span class="comment">exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">            <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp;</span><br><span class="line">            bck == unsorted_chunks(av) &amp;&amp;</span><br><span class="line">            victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br></pre></td></tr></table></figure>
<p>如果需要分配一个<code>small bin chunk</code>，在5.7.2.2节中的<code>small bins</code>中没有匹配到合适的<code>chunk</code>，并且<code>unsorted bin</code>中只有一个<code>chunk</code>，并且这个<code>chunk</code>为<code>last remainder chunk</code>，并且这个<code>chunk</code>的大小大于所需<code>chunk</code>的大小加上<code>MINSIZE</code>，在满足这些条件的情况下，可以使用这个<code>chunk</code>切分出需要的<code>small bin chunk</code>。这是唯一的从<code>unsorted bin</code>中分配<code>small bin chunk</code>的情况，这种优化利于<code>cpu</code>的高速缓存命中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* split and reattach remainder */</span></span><br><span class="line">remainder_size = size - nb;</span><br><span class="line">remainder = chunk_at_offset(victim, nb);</span><br><span class="line">unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;</span><br><span class="line">av-&gt;last_remainder = remainder;</span><br><span class="line">remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">&#123;</span><br><span class="line">    remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从该<code>chunk</code>中切分出所需大小的<code>chunk</code>，计算切分后剩下<code>chunk</code>的大小，将剩下的<code>chunk</code>加入<code>unsorted bin</code>的链表中，并将剩下的<code>chunk</code>作为分配区的<code>last remainder chunk</code>，若剩下的<code>chunk</code>属于<code>large bin chunk</code>，将该<code>chunk</code>的<code>fd_nextsize</code>和<code>bk_nextsize</code>设置为<code>NULL</code>，因为这个<code>chunk</code>仅仅存在于<code>unsorted bin</code>中，并且<code>unsorted bin</code>中有且仅有这一个<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set_head(victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">set_foot(remainder, remainder_size);</span><br><span class="line">check_malloced_chunk(av, victim, nb);</span><br><span class="line"><span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
<p>设置分配出的<code>chunk</code>和<code>last remainder chunk</code>的相关信息，如<code>chunk</code>的<code>size</code>，状态标志位，对于<code>last remainder chunk</code>，需要调用<code>set_foot</code>宏，因为只有处于空闲状态的<code>chunk</code>的<code>foot</code>信息（<code>prev_size</code>）才是有效的，处于<code>inuse</code>状态的<code>chunk</code>的<code>foot</code>无效，该<code>foot</code>是返回给应用层的内存块的一部分。设置完成<code>chunk</code>的相关信息，调用<code>chunk2mem()</code>获得<code>chunk</code>中可用的内存指针，返回给应用层，退出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks(av);</span><br></pre></td></tr></table></figure></p>
<p>将双向循环链表中的最后一个<code>chunk</code>移除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="keyword">if</span> (size == nb) &#123;</span><br><span class="line">    set_inuse_bit_at_offset(victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前遍历的<code>chunk</code>与所需的<code>chunk</code>大小一致，将当前<code>chunk</code>返回。首先设置当前<code>chunk</code>处于<code>inuse</code>状态，该标志位处于相邻的下一个<code>chunk</code>的<code>size</code>中，如果当前分配区不是主分配区，设置当前<code>chunk</code>的非主分配区标志位，最后调用<code>chunk2mem()</code>获得<code>chunk</code>中可用的内存指针，返回给应用层，退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(size)) &#123;</span><br><span class="line">    victim_index = smallbin_index(size);</span><br><span class="line">    bck = bin_at(av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>chunk</code>属于<code>small bins</code>，获得当前<code>chunk</code>所属<code>small bin</code>的<code>index</code>，并将该<code>small bin</code>的链表表头赋值给<code>bck</code>，第一个<code>chunk</code>赋值给<code>fwd</code>，也就是当前的<code>chunk</code>会插入到<code>bck</code>和<code>fwd</code>之间，作为<code>small bin</code>链表的第一个<code>chunk</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    victim_index = largebin_index(size);</span><br><span class="line">    bck = bin_at(av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>chunk</code>属于<code>large bins</code>，获得当前<code>chunk</code>所属<code>large bin</code>的<code>index</code>，并将该<code>large bin</code>的链表表头赋值给<code>bck</code>，第一个<code>chunk</code>赋值给<code>fwd</code>，也就是当前的<code>chunk</code>会插入到<code>bck</code>和<code>fwd</code>之间，作为<code>large bin</code>链表的第一个<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line"><span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">    <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">    size |= PREV_INUSE;</span><br><span class="line">    <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">    assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>如果<code>fwd</code>不等于<code>bck</code>，意味着<code>large bin</code>中有空闲<code>chunk</code>存在，由于<code>large bin</code>中的空闲<code>chunk</code>是按照大小顺序排序的，需要将当前从<code>unsorted bin</code>中取出的<code>chunk</code>插入到<code>large bin</code>中合适的位置。将当前<code>chunk</code>的<code>size</code>的<code>inuse</code>标志<code>bit</code>置位，相当于加1，便于加快<code>chunk</code>大小的比较，找到合适的地方插入当前<code>chunk</code>。这里还做了一次检查，断言在<code>large bin</code>双向循环链表中的最后一个<code>chunk</code>的<code>size</code>字段中的非主分配区的标志<code>bit</code>没有置位，因为所有在<code>large bin</code>中的<code>chunk</code>都处于空闲状态，该标志位一定是清零的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line">    fwd = bck;</span><br><span class="line">    bck = bck-&gt;bk;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>chunk</code>比<code>large bin</code>的最后一个<code>chunk</code>的大小还小，那么当前<code>chunk</code>就插入到<code>large bin</code>的链表的最后，作为最后一个<code>chunk</code>。可以看出<code>large bin</code>中的<code>chunk</code>是按照从大到小的顺序排序的，同时一个<code>chunk</code>存在于两个双向循环链表中，一个链表包含了<code>large bin</code>中所有的<code>chunk</code>，另一个链表为<code>chunk size</code>链表，该链表从每个相同大小的<code>chunk</code>的取出第一个<code>chunk</code>按照大小顺序链接在一起，便于一次跨域多个相同大小的<code>chunk</code>遍历下一个不同大小的<code>chunk</code>，这样可以加快在<code>large bin</code>链表中的遍历速度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">        assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>正向遍历<code>chunk size</code>链表，直到找到第一个<code>chunk</code>大小小于等于当前<code>chunk</code>大小的<code>chunk</code>退出循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">    <span class="comment">/* Always insert in the second position. */</span></span><br><span class="line">    fwd = fwd-&gt;fd;</span><br></pre></td></tr></table></figure>
<p>如果从<code>large bin</code>链表中找到了与当前<code>chunk</code>大小相同的<code>chunk</code>，则同一大小的<code>chunk</code>已经存在，那么<code>chunk size</code>链表中一定包含了<code>fwd</code>所指向的<code>chunk</code>，为了不修改<code>chunk size</code>链表，当前<code>chunk</code>只能插入<code>fwd</code>之后。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd;<span class="number">92</span></span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>
<p>如果<code>chunk size</code>链表中还没有包含当前<code>chunk</code>大小的<code>chunk</code>，也就是说当前<code>chunk</code>的大小大于<code>fwd</code>的大小，则将当前<code>chunk</code>作为该<code>chunk size</code>的代表加入<code>chunk size</code>链表，<code>chunk size</code>链表也是按照由大到小的顺序排序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        &#125;</span><br><span class="line">        bck = fwd-&gt;bk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br></pre></td></tr></table></figure>
<p>如果<code>large bin</code>链表中没有<code>chunk</code>，直接将当前<code>chunk</code>加入<code>chunk size</code>链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>
<p>上面的代码将当前<code>chunk</code>插入到<code>large bin</code>的空闲<code>chunk</code>链表中，并将<code>large bin</code>所对应<code>binmap</code>的相应<code>bit</code>置位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS 10000</span></span><br><span class="line">            <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>如果<code>unsorted bin</code>中的<code>chunk</code>超过了10000个，最多遍历10000个就退出，避免长时间处理<code>unsorted bin</code>影响内存分配的效率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当将<code>unsorted bin</code>中的空闲<code>chunk</code>加入到相应的<code>small bins</code>和<code>large bins</code>后，将使用最佳匹配法分配<code>large bin chunk</code>。源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">sorted order to find smallest that fits. Use the skip list for this.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;</span><br><span class="line">        bin = bin_at(av, idx);</span><br><span class="line">        <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">        <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>)(victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br></pre></td></tr></table></figure>
<p>如果所需分配的<code>chunk</code>为<code>large bin chunk</code>，查询对应的<code>large bin</code>链表，如果<code>large bin</code>链表为空，或者链表中最大的<code>chunk</code>也不能满足要求，则不能从<code>large bin</code>中分配。否则，遍历<code>large bin</code>链表，找到合适的<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">victim = victim-&gt;bk_nextsize;</span><br><span class="line"><span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>)(size = chunksize(victim)) &lt;</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">long</span>)(nb)))</span><br><span class="line">    victim = victim-&gt;bk_nextsize;</span><br></pre></td></tr></table></figure>
<p>反向遍历<code>chunk size</code>链表，直到找到第一个大于等于所需<code>chunk</code>大小的<code>chunk</code>退出循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">list does not have to be rerouted. */</span></span><br><span class="line"><span class="keyword">if</span> (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">    victim = victim-&gt;fd;</span><br></pre></td></tr></table></figure>
<p>如果从<code>large bin</code>链表中选取的<code>chunk victim</code>不是链表中的最后一个<code>chunk</code>，并且与<code>victim</code>大小相同的<code>chunk</code>不止一个，那么意味着<code>victim</code>为<code>chunk size</code>链表中的节点，为了不调整<code>chunk size</code>链表，需要避免将<code>chunk size</code>链表中的节点取出，所以取<code>victim-&gt;fd</code>节点对应的<code>chunk</code>作为候选<code>chunk</code>。由于<code>large bin</code>链表中的<code>chunk</code>也是按大小排序，同一大小的<code>chunk</code>有多个时，这些<code>chunk</code>必定排在一起，所以<code>victim-&gt;fd</code>节点对应的<code>chunk</code>的大小必定与<code>victim</code>的大小一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remainder_size = size - nb;</span><br><span class="line">unlink(victim, bck, fwd);</span><br></pre></td></tr></table></figure>
<p>计算将<code>victim</code>切分后剩余大小，并调用<code>unlink()</code>宏函数将<code>victim</code>从<code>large bin</code>链表中取出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Exhaust */</span></span><br><span class="line"><span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">    set_inuse_bit_at_offset(victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br></pre></td></tr></table></figure>
<p>如果将<code>victim</code>切分后剩余大小小于<code>MINSIZE</code>，则将这个<code>victim</code>分配给应用层，这种情况下，实际分配的<code>chunk</code>比所需的<code>chunk</code>要大一些。以64位系统为例，<code>remainder_size</code>的可能大小为0和16，如果为0，表示<code>victim</code>的大小刚好等于所需<code>chunk</code>的大小，设置<code>victim</code>的<code>inuse</code>标志，<code>inuse</code>标志位于下一个相邻的<code>chunk</code>的<code>size</code>字段中。如果<code>remainder_size</code>为16，则这16字节就浪费掉了。如果当前分配区不是主分配区，将<code>victim</code>的<code>size</code>字段中的非主分配区标志置位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Split */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    remainder = chunk_at_offset(victim, nb);</span><br><span class="line">    <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">    have to perform a complete insert here. */</span></span><br><span class="line">    bck = unsorted_chunks(av);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (fwd-&gt;bk != bck, <span class="number">0</span>))<span class="number">94</span></span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    remainder-&gt;bk = bck;</span><br><span class="line">    remainder-&gt;fd = fwd;</span><br><span class="line">    bck-&gt;fd = remainder;</span><br><span class="line">    fwd-&gt;bk = remainder;</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从<code>victim</code>中切分出所需的<code>chunk</code>，剩余部分作为一个新的<code>chunk</code>加入到<code>unsorted bin</code>中。如果剩余部分<code>chunk</code>属于<code>large bins</code>，将剩余部分<code>chunk</code>的<code>chunk size</code>链表指针设置为<code>NULL</code>，因为<code>unsorted bin</code>中的<code>chunk</code>是不排序的，这两个指针无用，必须清零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_head(victim, nb | PREV_INUSE |</span><br><span class="line">(av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">set_foot(remainder, remainder_size);</span><br></pre></td></tr></table></figure>
<p>设置<code>victim</code>和<code>remainder</code>的状态，由于<code>remainder</code>为空闲<code>chunk</code>，所以需要设置该<code>chunk</code>的<code>foot</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">check_malloced_chunk(av, victim, nb);</span><br><span class="line"><span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
<p>从<code>large bin</code>中使用最佳匹配法找到了合适的<code>chunk</code>，调用<code>chunk2mem()</code>获得<code>chunk</code>中可用的内存指针，返回给应用层，退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果通过上面的方式从最合适的<code>small bin</code>或<code>large bin</code>中都没有分配到需要的<code>chunk</code>，则查看比当前<code>bin</code>的<code>index</code>大的<code>small bin</code>或<code>large bin</code>是否有空闲<code>chunk</code>可利用来分配所需的<code>chunk</code>。源代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">(with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">that fits is selected.95</span></span><br><span class="line"><span class="comment">The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    ++idx;</span><br><span class="line">    bin = bin_at(av,idx);</span><br><span class="line">    block = idx2block(idx);</span><br><span class="line">    <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">    bit = idx2bit(idx);</span><br></pre></td></tr></table></figure>
<p>获取下一个相邻<code>bin</code>的空闲<code>chunk</code>链表，并获取该<code>bin</code>对于<code>binmap</code>中的<code>bit</code>位的值。<code>binmap</code>中的标识了相应的<code>bin</code>中是否有空闲<code>chunk</code>存在。<code>binmap</code>按<code>block</code>管理，每个<code>block</code>为一个<code>int</code>，共32个<code>bit</code>，可以表示32个<code>bin</code>中是否有空闲<code>chunk</code>存在。使用<code>binmap</code>可以加快查找<code>bin</code>是否包含空闲<code>chunk</code>。这里只查询比所需<code>chunk</code>大的<code>bin</code>中是否有空闲<code>chunk</code>可用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">/* Skip rest of block if there are no more set bits in this block. */</span></span><br><span class="line">    <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">            <span class="keyword">goto</span> use_top;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( (<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line">        bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>idx2bit()</code>宏将<code>idx</code>指定的位设置为1，其它位清零，<code>map</code>表示一个<code>block</code>（unsigned int）值，如果<code>bit</code>大于<code>map</code>，意味着<code>map</code>为0，该<code>block</code>所对应的所有<code>bins</code>中都没有空闲<code>chunk</code>，于是遍历<code>binmap</code>的下一个<code>block</code>，直到找到一个不为0的<code>block</code>或者遍历完所有的<code>block</code>。</p>
<p>退出循环遍历后，设置<code>bin</code>指向<code>block</code>的第一个<code>bit</code>对应的<code>bin</code>，并将<code>bit</code>置为1，表示该<code>block</code>中<code>bit 1</code>对应的<code>bin</code>，这个<code>bin</code>中如果有空闲<code>chunk</code>，该<code>chunk</code>的大小一定满足要求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line"><span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    assert(bit != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个<code>block</code>遍历对应的<code>bin</code>，直到找到一个<code>bit</code>不为0退出遍历，则该<code>bit</code>对于的<code>bin</code>中有空闲<code>chunk</code>存在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">victim = last(bin);</span><br></pre></td></tr></table></figure>
<p>将<code>bin</code>链表中的最后一个<code>chunk</code>赋值为<code>victim</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line"><span class="keyword">if</span> (victim == bin) &#123;</span><br><span class="line">    av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果<code>victim</code>与<code>bin</code>链表头指针相同，表示该<code>bin</code>中没有空闲<code>chunk</code>，<code>binmap</code>中的相应位设置不准确，将<code>binmap</code>的相应<code>bit</code>位清零，获取当前<code>bin</code>下一个<code>bin</code>，将<code>bit</code>移到下一个<code>bit</code>位，即乘以2。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    size = chunksize(victim);</span><br><span class="line">    <span class="comment">/* We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb));</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink(victim, bck, fwd);</span><br></pre></td></tr></table></figure>
<p>当前<code>bin</code>中的最后一个<code>chunk</code>满足要求，获取该<code>chunk</code>的大小，计算切分出所需<code>chunk</code>后剩余部分的大小，然后将<code>victim</code>从<code>bin</code>的链表中取出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Exhaust */</span></span><br><span class="line"><span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">    set_inuse_bit_at_offset(victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    victim-&gt;size |= NON_MAIN_ARENA;</span><br></pre></td></tr></table></figure>
<p>如果剩余部分的大小小于<code>MINSIZE</code>，将整个<code>chunk</code>分配给应用层，设置<code>victim</code>的状态为<code>inuse</code>，如果当前分配区为非主分配区，设置<code>victim</code>的非主分配区标志位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Split */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    remainder = chunk_at_offset(victim, nb);</span><br><span class="line">    <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">    have to perform a complete insert here. */</span></span><br><span class="line">    bck = unsorted_chunks(av);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (fwd-&gt;bk != bck, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    remainder-&gt;bk = bck;</span><br><span class="line">    remainder-&gt;fd = fwd;</span><br><span class="line">    bck-&gt;fd = remainder;</span><br><span class="line">    fwd-&gt;bk = remainder;</span><br><span class="line">    <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">    av-&gt;last_remainder = remainder;</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">    &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从<code>victim</code>中切分出所需的<code>chunk</code>，剩余部分作为一个新的<code>chunk</code>加入到<code>unsorted bin</code>中。如果剩余部分<code>chunk</code>属于<code>small bins</code>，将分配区的<code>last remainder chunk</code>设置为剩余部分构成的<code>chunk</code>；如果剩余部分<code>chunk</code>属于<code>large bins</code>，将剩余部分<code>chunk</code>的<code>chunk size</code>链表指针设置为<code>NULL</code>，因为<code>unsorted bin</code>中的<code>chunk</code>是不排序的，这两个指针无用，必须清零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_head(victim, nb | PREV_INUSE |</span><br><span class="line">(av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">set_foot(remainder, remainder_size);</span><br></pre></td></tr></table></figure>
<p>设置<code>victim</code>和<code>remainder</code>的状态，由于<code>remainder</code>为空闲<code>chunk</code>，所以需要设置该<code>chunk</code>的<code>foot</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">check_malloced_chunk(av, victim, nb);</span><br><span class="line"><span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
<p>调用<code>chunk2mem()</code>获得<code>chunk</code>中可用的内存指针，返回给应用层，退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果从所有的<code>bins</code>中都没有获得所需的<code>chunk</code>，可能的情况为<code>bins</code>中没有空闲<code>chunk</code>，或者所需的<code>chunk</code>大小很大，下一步将尝试从<code>top chunk</code>中分配所需<code>chunk</code>。源代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">(held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">search rule. In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">limitations).98</span></span><br><span class="line"><span class="comment">We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize(victim);</span><br></pre></td></tr></table></figure>
<p>将当前分配区的<code>top chunk</code>赋值给<code>victim</code>，并获得<code>victim</code>的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>top chunk</code>切分出所需<code>chunk</code>后，还需要<code>MINSIZE</code>的空间来作为<code>fencepost</code>，所需必须满足<code>top chunk</code>的大小大于所需<code>chunk</code>的大小加上<code>MINSIZE</code>这个条件，才能从<code>top chunk</code>中分配所需<code>chunk</code>。从<code>top chunk</code>切分出所需<code>chunk</code>的处理过程跟前面的<code>chunk</code>切分类似，不同的是，原<code>top chunk</code>切分后的剩余部分将作为新的<code>top chunk</code>，原<code>top chunk</code>的<code>fencepost</code>仍然作为新的<code>top chunk</code>的<code>fencepost</code>，所以切分之后剩余的<code>chunk</code>不用<code>set_foot</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">    here for all block sizes. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av)) &#123;</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line">        <span class="comment">/* restore original bin index */</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">            idx = smallbin_index(nb);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index(nb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>top chunk</code>也不能满足要求，查看<code>fast bins</code>中是否有空闲<code>chunk</code>存在，由于开启了<code>ATOMIC_FASTBINS</code>优化情况下，<code>free</code>属于<code>fast bins</code>的<code>chunk</code>时不需要获得分配区的锁，所以在调用<code>_int_malloc()</code>函数时，有可能有其它线程已经向<code>fast bins</code>中加入了新的空闲<code>chunk</code>，也有可能是所需的<code>chunk</code>属于<code>small bins</code>，但通过前面的步骤都没有分配到所需的<code>chunk</code>，由于分配<code>small bin chunk</code>时在前面的步骤都不会调用<code>malloc_consolidate()</code>函数将<code>fast bins</code>中的<code>chunk</code>合并加入到<code>unsorted bin</code>中。所在这里如果<code>fast bin</code>中有<code>chunk</code>存在，调用<code>malloc_consolidate()</code>函数，并重新设置当前<code>bin</code>的<code>index</code>。并转到最外层的循环，尝试重新分配<code>small bin chunk</code>或是<code>large bin chunk</code>。如果开启了<code>ATOMIC_FASTBINS</code>优化，有可能在由其它线程加入到<code>fast bins</code>中的<code>chunk</code>被合并后加入<code>unsorted bin</code>中，从<code>unsorted bin</code>中就可以分配出所需的<code>large bin chunk</code>了，所以对没有成功分配的<code>large bin chunk</code>也需要重试。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If there is space available in fastbins, consolidate and retry,</span></span><br><span class="line"><span class="comment">    to possibly avoid expanding memory. This can occur only if nb is</span></span><br><span class="line"><span class="comment">    in smallbin range so we didn&#x27;t consolidate upon entry.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av)) &#123;</span><br><span class="line">        assert(in_smallbin_range(nb));</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line">        idx = smallbin_index(nb); <span class="comment">/* restore original bin index */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>top chunk</code>也不能满足要求，查看<code>fast bins</code>中是否有空闲<code>chunk</code>存在，如果<code>fast bins</code>中有空闲<code>chunk</code>存在，在没有开启<code>ATOMIC_FASTBINS</code>优化的情况下，只有一种可能，那就是所需的<code>chunk</code>属于<code>small bins</code>，但通过前面的步骤都没有分配到所需的<code>small bin chunk</code>，由于分配<code>small bin chunk</code>时在前面的步骤都不会调用<code>malloc_consolidate()</code>函数将<code>fast bins</code>中的空闲<code>chunk</code>合并加入到<code>unsorted bin</code>中。所在这里如果<code>fast bins</code>中有空闲<code>chunk</code>存在，调用<code>malloc_consolidate()</code>函数，并重新设置当前<code>bin</code>的<code>index</code>。并转到最外层的循环，尝试重新分配<code>small bin chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">void</span> *p = sYSMALLOc(nb, av);</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure>
<p>山穷水尽了，只能向系统申请内存了。<code>sYSMALLOc()</code>函数可能分配的<code>chunk</code>包括<code>small bin chunk</code>，<code>large bin chunk</code>和<code>large chunk</code>。将在下一节中介绍该函数的实现。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，<code>_int_malloc()</code>函数的代码就罗列完了，当还有两个关键函数没有分析，一个为<code>malloc_consolidate()</code>，另一个为<code>sYSMALLOc()</code>，将在下面的章节介绍其实现。</p>
<h4 id="sYSMALLOc"><a href="#sYSMALLOc" class="headerlink" title="sYSMALLOc()"></a>sYSMALLOc()</h4><p>当<code>_int_malloc()</code>函数尝试从<code>fast bins</code>，<code>last remainder chunk</code>，<code>small bins</code>，<code>large bins</code>和<code>top chunk</code>都失败之后，就会使用<code>sYSMALLOc()</code>函数直接向系统申请内存用于分配所需的<code>chunk</code>。其实现源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sysmalloc handles malloc cases requiring more memory from the system.</span></span><br><span class="line"><span class="comment">On entry, it is assumed that av-&gt;top does not have enough</span></span><br><span class="line"><span class="comment">space to service request for nb bytes, thus requiring that av-&gt;top</span></span><br><span class="line"><span class="comment">be extended or replaced.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">static</span> <span class="type">void_t</span>* <span class="title function_">sYSMALLOc</span><span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void_t</span>* <span class="title function_">sYSMALLOc</span><span class="params">(nb, av)</span> INTERNAL_SIZE_T nb; mstate av;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mchunkptr old_top; <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">    INTERNAL_SIZE_T old_size; <span class="comment">/* its size */</span></span><br><span class="line">    <span class="type">char</span>* old_end; <span class="comment">/* its end address */</span></span><br><span class="line">    <span class="type">long</span> size; <span class="comment">/* arg to first MORECORE or`mmap`call */</span></span><br><span class="line">    <span class="type">char</span>* brk; <span class="comment">/* return value from MORECORE */</span></span><br><span class="line">    <span class="type">long</span> correction; <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">    <span class="type">char</span>* snd_brk; <span class="comment">/* 2nd return val */</span></span><br><span class="line">    INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">    INTERNAL_SIZE_T end_misalign; <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">    <span class="type">char</span>* aligned_brk; <span class="comment">/* aligned offset into brk */</span></span><br><span class="line">    mchunkptr p; <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">    mchunkptr remainder; <span class="comment">/* remainder from allocation */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">/* its size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sum; <span class="comment">/* for updating stats */</span></span><br><span class="line">    <span class="type">size_t</span> pagemask = mp_.pagesize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> tried_mmap = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If have mmap, and the request size meets the`mmap`threshold, and101</span></span><br><span class="line"><span class="comment">    the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">    allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">    rather than expanding top.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.mmap_threshold) &amp;&amp;</span><br><span class="line">    (mp_.n_mmaps &lt; mp_.n_mmaps_max)) &#123;</span><br><span class="line">        <span class="type">char</span>* mm; <span class="comment">/* return value from mmap call*/</span></span><br></pre></td></tr></table></figure>
<p>如果所需分配的<code>chunk</code>大小大于<code>mmap</code>分配阈值，默认为128K<code>，并且当前进程使用</code>mmap()<code>分配的内存块小于设定的最大值，将使用</code>mmap()`系统调用直接向操作系统申请内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try_mmap:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Round up size to nearest page. For mmapped chunks, the overhead</span></span><br><span class="line"><span class="comment">        is one SIZE_SZ unit larger than for normal chunks, because there</span></span><br><span class="line"><span class="comment">        is no following chunk whose prev_size field could be used.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">        <span class="comment">/* See the front_misalign handling below, for glibc there is no</span></span><br><span class="line"><span class="comment">        need for further alignments. */</span></span><br><span class="line">        size = (nb + SIZE_SZ + pagemask) &amp; ~pagemask;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        size = (nb + SIZE_SZ + MALLOC_ALIGN_MASK + pagemask) &amp; ~pagemask;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        tried_mmap = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>由于<code>nb</code>为所需<code>chunk</code>的大小，在<code>_int_malloc()</code>函数中已经将用户需要分配的大小转化为<code>chunk</code>大小，当如果这个<code>chunk</code>直接使用<code>mmap()</code>分配的话，该<code>chunk</code>不存在下一个相邻的<code>chunk</code>，也就没有<code>prev_size</code>的内存空间可以复用，所以还需要额外<code>SIZE_SZ</code>大小的内存。由于<code>mmap()</code>分配的内存块必须页对齐。如果使用<code>mmap()</code>分配内存，需要重新计算分配的内存大小<code>size</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line">            mm = (<span class="type">char</span>*)(MMAP(<span class="number">0</span>, size, PROT_READ|PROT_WRITE, MAP_PRIVATE));</span><br><span class="line">            <span class="keyword">if</span> (mm != MAP_FAILED) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                The offset to the start of the mmapped region is stored</span></span><br><span class="line"><span class="comment">                in the prev_size field of the chunk. This allows us to adjust</span></span><br><span class="line"><span class="comment">                returned start address to meet alignment requirements here</span></span><br><span class="line"><span class="comment">                and in memalign(), and still be able to compute proper</span></span><br><span class="line"><span class="comment">                address argument for later munmap in free() and realloc().</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">                <span class="comment">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span></span><br><span class="line"><span class="comment">                MALLOC_ALIGN_MASK is 2*SIZE_SZ-1. Each mmap&#x27;ed area is page102</span></span><br><span class="line"><span class="comment">                aligned and therefore definitely MALLOC_ALIGN_MASK-aligned. */</span></span><br><span class="line">                assert (((INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">                <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">                    p = (mchunkptr)(mm + correction);</span><br><span class="line">                    p-&gt;prev_size = correction;</span><br><span class="line">                    set_head(p, (size - correction) |IS_MMAPPED);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                &#123;</span><br><span class="line">                    p = (mchunkptr)mm;</span><br><span class="line">                    set_head(p, size|IS_MMAPPED);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>如果重新计算所需分配的<code>size</code>小于<code>nb</code>，表示溢出了，不分配内存，否则，调用<code>mmap()</code>分配所需大小的内存。如果<code>mmap()</code>分配内存成功，将<code>mmap()</code>返回的内存指针强制转换为<code>chunk</code>指针，并设置该<code>chunk</code>的大小为<code>size</code>，同时设置该<code>chunk</code>的<code>IS_MMAPPED</code>标志位，表示本<code>chunk</code>是通过<code>mmap()</code>函数直接从系统分配的。由于<code>mmap()</code>返回的内存地址是按照页对齐的，也一定是按照<code>2*SIZE_SZ</code>对齐的，满足<code>chunk</code>的边界对齐规则，使用<code>chunk2mem()</code>获取<code>chunk</code>中实际可用的内存也没有问题，所以这里不需要做额外的对齐操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                <span class="comment">/* update statistics */</span></span><br><span class="line">                <span class="keyword">if</span> (++mp_.n_mmaps &gt; mp_.max_n_mmaps)</span><br><span class="line">                    mp_.max_n_mmaps = mp_.n_mmaps;</span><br><span class="line">                sum = mp_.mmapped_mem += size;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.max_mmapped_mem))</span><br><span class="line">                    mp_.max_mmapped_mem = sum;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NO_THREADS</span></span><br><span class="line">                sum += av-&gt;system_mem;</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.max_total_mem))</span><br><span class="line">                    mp_.max_total_mem = sum;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>更新相关统计值，首先将当前进程<code>mmap</code>分配内存块的计数加一，如果使用<code>mmap()</code>分配的内存块数量大于设置的最大值，将最大值设置为最新值，这个判断不会成功，因为使用<code>mmap</code>分配内存的条件中包括了<code>mp_.n_mmaps &lt; mp_.n_mmaps_max</code>，所以<code>++mp_.n_mmaps &gt; mp_.max_n_mmaps</code>不会成立。然后更新<code>mmap</code>分配的内存总量，如果该值大于设置的最大值，将当前值赋值给<code>mp_.max_mmapped_mem</code>。如果只支持单线程，还需要计数当前进程所分配的内存总数，如果总数大于设置的最大值<code>mp_.max_total_mem</code>，修改<code>mp_.max_total_mem</code>为当前值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                check_chunk(av, p);</span><br><span class="line">                <span class="keyword">return</span> chunk2mem(p);<span class="number">103</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line">    old_top = av-&gt;top;</span><br><span class="line">    old_size = chunksize(old_top);</span><br><span class="line">    old_end = (<span class="type">char</span>*)(chunk_at_offset(old_top, old_size));</span><br><span class="line">    brk = snd_brk = (<span class="type">char</span>*)(MORECORE_FAILURE);</span><br></pre></td></tr></table></figure>
<p>保存当前<code>top chunk</code>的指针，大小和结束地址到临时变量中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">    at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">    ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">    prev_inuse(old_top) &amp;&amp;</span><br><span class="line">    ((<span class="type">unsigned</span> <span class="type">long</span>)old_end &amp; pagemask) == <span class="number">0</span>));</span><br><span class="line">    <span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">    assert((<span class="type">unsigned</span> <span class="type">long</span>)(old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE));</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    <span class="comment">/* Precondition: all fastbins are consolidated */</span></span><br><span class="line">    assert(!have_fastchunks(av));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>检查<code>top chunk</code>的合法性，如果第一次调用本函数，<code>top chunk</code>可能没有初始化，可能<code>old_size</code>为0，如果<code>top chunk</code>已经初始化，则<code>top chunk</code>的大小必须大于等于<code>MINSIZE</code>，因为<code>top chunk</code>中包含了<code>fencepost</code>，<code>fencepost</code>需要<code>MINSIZE</code>大小的内存。<code>top chunk</code>必须标识前一个<code>chunk</code>处于<code>inuse</code>状态，这是规定，并且<code>top chunk</code>的结束地址必定是页对齐的。另外<code>top chunk</code>的除去<code>fencepost</code>的大小必定小于所需<code>chunk</code>的大小，不然在<code>_int_malloc()</code>函数中就应该使用<code>top chunk</code>获得所需的<code>chunk</code>。最后检查如果没有开启<code>ATOMIC_FASTBINS</code>优化，在使用<code>_int_malloc()</code>分配内存时，获得了分配区的锁，<code>free</code>时也要获得分配区的锁才能向<code>fast bins</code>中加入新的<code>chunk</code>，由于<code>_int_malloc()</code>在调用本函数前，已经将<code>fast bins</code>中的所有<code>chunk</code>都合并加入到<code>unsorted bin</code>中了，所以，本函数中<code>fast bins</code>中一定不会有空闲<code>chunk</code>存在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena) &#123;</span><br><span class="line">        heap_info *old_heap, *heap;</span><br><span class="line">        <span class="type">size_t</span> old_heap_size;</span><br><span class="line">        <span class="comment">/* First try to extend the current heap. */</span></span><br><span class="line">        old_heap = heap_for_ptr(old_top);</span><br><span class="line">        old_heap_size = old_heap-&gt;size;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="number">0104</span></span><br><span class="line">        &amp;&amp; grow_heap(old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>) &#123;</span><br><span class="line">            av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">            arena_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">            <span class="keyword">if</span>(mmapped_mem + arena_mem + sbrked_mem &gt; max_total_mem)</span><br><span class="line">                max_total_mem = mmapped_mem + arena_mem + sbrked_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            set_head(old_top, (((<span class="type">char</span> *)old_heap + old_heap-&gt;size) - (<span class="type">char</span> *)old_top)</span><br><span class="line">            | PREV_INUSE);</span><br></pre></td></tr></table></figure>
<p>如果当前分配区为非主分配区，根据<code>top chunk</code>的指针获得当前<code>sub_heap</code>的<code>heap_info</code>实例，如果<code>top chunk</code>的剩余有效空间不足以分配出所需的<code>chunk</code>（前面已经断言，这个肯定成立），尝试增长<code>sub_heap</code>的可读可写区域大小，如果成功，修改过内存分配的统计信息，并更新新的<code>top chunk</code>的<code>size</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap(nb + (MINSIZE + <span class="keyword">sizeof</span>(*heap)), mp_.top_pad))) &#123;</span><br></pre></td></tr></table></figure>
<p>调用<code>new_heap()</code>函数创建一个新的<code>sub_heap</code>，由于这个<code>sub_heap</code>中至少需要容下大小为<code>nb</code>的<code>chunk</code>，大小为<code>MINSIZE</code>的<code>fencepost</code>和大小为<code>sizeof(*heap)</code>的<code>heap_info</code>实例，所以传入<code>new_heap()</code>函数的分配大小为<code>nb + (MINSIZE + sizeof(*heap))</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* Use a newly allocated heap. */</span></span><br><span class="line">            heap-&gt;ar_ptr = av;</span><br><span class="line">            heap-&gt;prev = old_heap;</span><br><span class="line">            av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">            arena_mem += heap-&gt;size;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">            <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>)(mmapped_mem + arena_mem + sbrked_mem) &gt; max_total_mem)</span><br><span class="line">                max_total_mem = mmapped_mem + arena_mem + sbrked_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="comment">/* Set up the new top. */</span></span><br><span class="line">            top(av) = chunk_at_offset(heap, <span class="keyword">sizeof</span>(*heap));</span><br><span class="line">            set_head(top(av), (heap-&gt;size - <span class="keyword">sizeof</span>(*heap)) | PREV_INUSE);</span><br></pre></td></tr></table></figure>
<p>使新创建的<code>sub_heap</code>保存当前的分配区指针，将该<code>sub_heap</code>加入当前分配区的<code>sub_heap</code>链表中，更新当前分配区内存分配统计，将新创建的<code>sub_heap</code>仅有的一个空闲<code>chunk</code>作为当前分配区的<code>top chunk</code>，并设置<code>top chunk</code>的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* Setup fencepost and free the old top chunk. */</span></span><br><span class="line">            <span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">            become the top chunk again later. Note that a footer is set</span></span><br><span class="line"><span class="comment">            up, too, although the chunk is marked in use. */</span></span><br><span class="line">            old_size -= MINSIZE;</span><br><span class="line">            set_head(chunk_at_offset(old_top, old_size + <span class="number">2</span>*SIZE_SZ), <span class="number">0</span>|PREV_INUSE);</span><br><span class="line">            <span class="keyword">if</span> (old_size &gt;= MINSIZE) &#123;</span><br><span class="line">                set_head(chunk_at_offset(old_top, old_size), (<span class="number">2</span>*SIZE_SZ)|PREV_INUSE);<span class="number">105</span></span><br><span class="line">                set_foot(chunk_at_offset(old_top, old_size), (<span class="number">2</span>*SIZE_SZ));</span><br><span class="line">                set_head(old_top, old_size|PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">                _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                _int_free(av, old_top);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set_head(old_top, (old_size + <span class="number">2</span>*SIZE_SZ)|PREV_INUSE);</span><br><span class="line">                set_foot(old_top, (old_size + <span class="number">2</span>*SIZE_SZ));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>设置原<code>top chunk</code>的<code>fencepost</code>，<code>fencepost</code>需要<code>MINSIZE</code>大小的内存空间，将该<code>old_size</code>减去<code>MINSIZE</code>得到原<code>top chunk</code>的有效内存空间，首先设置<code>fencepost</code>的第二个<code>chunk</code>的<code>size</code>为0，并标识前一个<code>chunk</code>处于<code>inuse</code>状态。接着判断原<code>top chunk</code>的有效内存空间上是否大于等于<code>MINSIZE</code>，如果是，表示原<code>top chunk</code>可以分配出大于等于<code>MINSIZE</code>大小的<code>chunk</code>，于是将原<code>top chunk</code>切分成空闲<code>chunk</code>和<code>fencepost</code>两部分，先设置<code>fencepost</code>的第一个<code>chunk</code>的大小为<code>2*SIZE_SZ</code>，并标识前一个<code>chunk</code>处于<code>inuse</code>状态，<code>fencepost</code>的第一个<code>chunk</code>还需要设置<code>foot</code>，表示该<code>chunk</code>处于空闲状态，而<code>fencepost</code>的第二个<code>chunk</code>却标识第一个<code>chunk</code>处于<code>inuse</code>状态，因为不能有两个空闲<code>chunk</code>相邻，才会出现这么奇怪的<code>fencepost</code>。另外其实<code>top chunk</code>切分出来的<code>chunk</code>也是处于空闲状态，但<code>fencepost</code>的第一个<code>chunk</code>却标识前一个<code>chunk</code>为<code>inuse</code>状态，然后强制将该处于<code>inuse</code>状态的<code>chunk</code>调用<code>_int_free()</code>函数释放掉。这样做完全是要遵循不能有两个空闲<code>chunk</code>相邻的约定。</p>
<p>如果原<code>top chunk</code>中有效空间不足<code>MINSIZE</code>，则将整个原<code>top chunk</code>作为<code>fencepost</code>，并设置<code>fencepost</code>的第一个<code>chunk</code>的相关状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!tried_mmap)</span><br><span class="line">    <span class="comment">/* We can at least try to use to`mmap`memory. */</span></span><br><span class="line">    <span class="keyword">goto</span> try_mmap;</span><br></pre></td></tr></table></figure>
<p>如果增长<code>sub_heap</code>的可读可写区域大小和创建新<code>sub_heap</code>都失败了，尝试使用<code>mmap()</code>函数直接从系统分配所需<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">/* av == main_arena */</span></span><br><span class="line">    <span class="comment">/* Request enough space for nb + pad + overhead */</span></span><br><span class="line">    size = nb + mp_.top_pad + MINSIZE;</span><br></pre></td></tr></table></figure>
<p>如果为当前分配区为主分配区，重新计算需要分配的<code>size</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If contiguous, we can subtract out existing space that we hope to</span></span><br><span class="line"><span class="comment">combine with new space. We add it back later only if</span></span><br><span class="line"><span class="comment">we don&#x27;t actually get contiguous space.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (contiguous(av))</span><br><span class="line">    size -= old_size;</span><br></pre></td></tr></table></figure></p>
<p>一般情况下，主分配区使用<code>sbrk()</code>从<code>heap</code>中分配内存，<code>sbrk()</code>返回连续的虚拟内存，这里调整需要分配的<code>size</code>，减掉<code>top chunk</code>中已有空闲内存大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Round to a multiple of page size.</span></span><br><span class="line"><span class="comment">If MORECORE is not contiguous, this ensures that we only call it</span></span><br><span class="line"><span class="comment">with whole-page arguments. And if MORECORE is contiguous and</span></span><br><span class="line"><span class="comment">this is not first time through, this preserves page-alignment of</span></span><br><span class="line"><span class="comment">previous calls. Otherwise, we correct to page-align below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">size = (size + pagemask) &amp; ~pagemask;</span><br></pre></td></tr></table></figure>
<p>将<code>size</code>按照页对齐，<code>sbrk()</code>必须以页为单位分配连续虚拟内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Don&#x27;t try to call MORECORE if argument is so big as to appear</span></span><br><span class="line"><span class="comment">negative. Note that since`mmap`takes size_t arg, it may succeed</span></span><br><span class="line"><span class="comment">below even if we cannot call MORECORE.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>)</span><br><span class="line">    brk = (<span class="type">char</span>*)(MORECORE(size));</span><br></pre></td></tr></table></figure>
<p>使用<code>sbrk()</code>从<code>heap</code>中分配<code>size</code>大小的虚拟内存块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (brk != (<span class="type">char</span>*)(MORECORE_FAILURE)) &#123;</span><br><span class="line">    <span class="comment">/* Call the `morecore&#x27; hook if necessary. */</span></span><br><span class="line">    <span class="type">void</span> (*hook) (<span class="type">void</span>) = force_reg (__after_morecore_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">        (*hook) ();</span><br></pre></td></tr></table></figure>
<p>如果<code>sbrk()</code>分配成功，并且<code>morecore</code>的<code>hook</code>函数存在，调用<code>morecore</code>的<code>hook</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            If have mmap, try using it as a backup when MORECORE fails or</span></span><br><span class="line"><span class="comment">            cannot be used. This is worth doing on systems that have &quot;holes&quot; in</span></span><br><span class="line"><span class="comment">            address space, so sbrk cannot extend to give contiguous space, but</span></span><br><span class="line"><span class="comment">            space is available elsewhere. Note that we ignore mmap max count</span></span><br><span class="line"><span class="comment">            and threshold limits, since the space will not be used as a</span></span><br><span class="line"><span class="comment">            segregated mmap region.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line">            <span class="comment">/* Cannot merge with old top, so add its size back in */</span></span><br><span class="line">            <span class="keyword">if</span> (contiguous(av))</span><br><span class="line">                size = (size + old_size + pagemask) &amp; ~pagemask;</span><br><span class="line">            <span class="comment">/* If we are relying on`mmap`as backup, then use larger units */</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(MMAP_AS_MORECORE_SIZE))</span><br><span class="line">                size = MMAP_AS_MORECORE_SIZE;</span><br></pre></td></tr></table></figure>
<p>如果<code>sbrk()</code>返回失败，或是<code>sbrk()</code>不可用，使用<code>mmap()</code>代替，重新计算所需分配的内存大小并按页对齐，如果重新计算的<code>size</code>小于1M<code>，将</code>size<code>设为1M</code>，也就是说使用<code>mmap()</code>作为<code>morecore</code>函数分配的最小内存块大小为1M。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line">                <span class="type">char</span> *mbrk = (<span class="type">char</span>*)(MMAP(<span class="number">0</span>, size, PROT_READ|PROT_WRITE, MAP_PRIVATE));</span><br><span class="line">                <span class="keyword">if</span> (mbrk != MAP_FAILED) &#123;</span><br><span class="line">                    <span class="comment">/* We do not need, and cannot use, another sbrk call to find end */</span></span><br><span class="line">                    brk = mbrk;</span><br><span class="line">                    snd_brk = brk + size;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    Record that we no longer have a contiguous sbrk region.</span></span><br><span class="line"><span class="comment">                    After the first time`mmap`is used as backup, we do not</span></span><br><span class="line"><span class="comment">                    ever rely on contiguous space since this could incorrectly</span></span><br><span class="line"><span class="comment">                    bridge regions.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    set_noncontiguous(av);</span><br><span class="line">                &#125;</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">如果所需分配的内存大小合法，使用`mmap()`函数分配内存。如果分配成功，更新`brk`和`snd_brk`，并将当前分配区属性设置为可分配不连续虚拟内存块。</span><br><span class="line"></span><br><span class="line">```C</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (brk != (<span class="type">char</span>*)(MORECORE_FAILURE)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp_.sbrk_base == <span class="number">0</span>)</span><br><span class="line">                mp_.sbrk_base = brk;</span><br><span class="line">            av-&gt;system_mem += size;</span><br></pre></td></tr></table></figure>
<p>如果<code>brk</code>合法，即<code>sbrk()</code>或<code>mmap()</code>分配成功，如果<code>sbrk_base</code>还没有初始化，更新<code>sbrk_base</code>和当前分配区的内存分配总量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If MORECORE extends previous space, we can likewise extend top size.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="type">char</span>*)(MORECORE_FAILURE))</span><br><span class="line">    set_head(old_top, (size + old_size) | PREV_INUSE);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (contiguous(av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end) &#123;</span><br><span class="line">    <span class="comment">/* Oops! Someone else killed our space.. Can&#x27;t touch anything. */</span></span><br><span class="line">    malloc_printerr (<span class="number">3</span>, <span class="string">&quot;break adjusted to free malloc space&quot;</span>, brk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>sbrk()</code>分配成功，更新<code>top chunk</code>的大小，并设定<code>top chunk</code>的前一个<code>chunk</code>处于<code>inuse</code>状态。如果当前分配区可分配连续虚拟内存，原<code>top chunk</code>的大小大于0，但新的<code>brk</code>值小于原<code>top chunk</code>的结束地址，出错了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Otherwise, make adjustments:</span></span><br><span class="line"><span class="comment">* If the first time through or noncontiguous, we need to call sbrk</span></span><br><span class="line"><span class="comment">just to find out where the end of memory lies.</span></span><br><span class="line"><span class="comment">* We need to ensure that all returned chunks from malloc will meet</span></span><br><span class="line"><span class="comment">MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment">* If there was an intervening foreign sbrk, we need to adjust sbrk</span></span><br><span class="line"><span class="comment">request size to account for fact that we will not be able to</span></span><br><span class="line"><span class="comment">combine new space with existing space in old_top.</span></span><br><span class="line"><span class="comment">* Almost all systems internally allocate whole pages at a time, in</span></span><br><span class="line"><span class="comment">which case we might as well use the whole last page of request.</span></span><br><span class="line"><span class="comment">So we allocate enough more memory to hit a page boundary now,</span></span><br><span class="line"><span class="comment">which in turn causes future contiguous calls to page-align.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    front_misalign = <span class="number">0</span>;</span><br><span class="line">    end_misalign = <span class="number">0</span>;</span><br><span class="line">    correction = <span class="number">0</span>;</span><br><span class="line">    aligned_brk = brk;</span><br></pre></td></tr></table></figure>
<p>执行到这个分支，意味着<code>sbrk()</code>返回的<code>brk</code>值大于原<code>top chunk</code>的结束地址，那么新的地址与原<code>top chunk</code>的地址不连续，可能是由于外部其它地方调用`sbrk()函数，这里需要处理地址的重新对齐问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* handle contiguous cases */</span></span><br><span class="line"><span class="keyword">if</span> (contiguous(av)) &#123;</span><br><span class="line">    <span class="comment">/* Count foreign sbrk as system_mem. */</span></span><br><span class="line">    <span class="keyword">if</span> (old_size)</span><br><span class="line">        av-&gt;system_mem += brk - old_end;</span><br></pre></td></tr></table></figure>
<p>如果本分配区可分配连续虚拟内存，并且有外部调用了<code>sbrk()</code>函数，将外部调用<code>sbrk()</code>分配的内存计入当前分配区所分配内存统计中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Guarantee alignment of first new chunk made from this space */</span></span><br><span class="line">front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line"><span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">    We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">    They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">    prev_inuse of av-&gt;top (and any chunk created from its start)109</span></span><br><span class="line"><span class="comment">    is always true after initialization.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">    aligned_brk += correction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算当前的<code>brk</code>要矫正的字节数据，保证<code>brk</code>地址按<code>MALLOC_ALIGNMENT</code>对齐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If this isn&#x27;t adjacent to existing space, then we will not</span></span><br><span class="line"><span class="comment">be able to merge with old_top space, so must add to 2nd request.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">correction += old_size;</span><br><span class="line"><span class="comment">/* Extend the end address to hit a page boundary */</span></span><br><span class="line">end_misalign = (INTERNAL_SIZE_T)(brk + size + correction);</span><br><span class="line">correction += ((end_misalign + pagemask) &amp; ~pagemask) - end_misalign;</span><br><span class="line">assert(correction &gt;= <span class="number">0</span>);</span><br><span class="line">snd_brk = (<span class="type">char</span>*)(MORECORE(correction));</span><br></pre></td></tr></table></figure>
<p>由于原<code>top chunk</code>的地址与当前<code>brk</code>不相邻，也就不能再使用原<code>top chunk</code>的内存了，需要重新为所需<code>chunk</code>分配足够的内存，将原<code>top chunk</code>的大小加到矫正值中，从当前<code>brk</code>中分配所需<code>chunk</code>，计算出未对齐的<code>chunk</code>结束地址<code>end_misalign</code>，然后将<code>end_misalign</code>按照页对齐计算出需要矫正的字节数加到矫正值上。然后再调用<code>sbrk()</code>分配矫正值大小的内存，如果<code>sbrk()</code>分配成功，则当前的<code>top chunk</code>中可以分配出所需的连续内存的<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If can&#x27;t allocate correction, try to at least find out current</span></span><br><span class="line"><span class="comment">brk. It might be enough to proceed without failing.</span></span><br><span class="line"><span class="comment">Note that if second sbrk did NOT fail, we assume that space</span></span><br><span class="line"><span class="comment">is contiguous with first sbrk. This is a safe assumption unless</span></span><br><span class="line"><span class="comment">program is multithreaded but doesn&#x27;t use locks and a foreign sbrk</span></span><br><span class="line"><span class="comment">occurred between our first and second calls.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (snd_brk == (<span class="type">char</span>*)(MORECORE_FAILURE)) &#123;</span><br><span class="line">    correction = <span class="number">0</span>;</span><br><span class="line">    snd_brk = (<span class="type">char</span>*)(MORECORE(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>如果<code>sbrk()</code>执行失败，更新当前<code>brk</code>的结束地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Call the `morecore&#x27; hook if necessary. */</span></span><br><span class="line">    <span class="type">void</span> (*hook) (<span class="type">void</span>) = force_reg (__after_morecore_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">        (*hook) ();</span><br></pre></td></tr></table></figure>
<p>如果<code>sbrk()</code>执行成功，并且有<code>morecore hook</code>函数存在，执行该<code>hook</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* handle non-contiguous cases */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* MORECORE/mmap must correctly align */</span></span><br><span class="line">    assert(((<span class="type">unsigned</span> <span class="type">long</span>)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Find out current end of memory */</span></span><br><span class="line">    <span class="keyword">if</span> (snd_brk == (<span class="type">char</span>*)(MORECORE_FAILURE)) &#123;</span><br><span class="line">        snd_brk = (<span class="type">char</span>*)(MORECORE(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>执行到这里，意味着<code>brk</code>是用<code>mmap()</code>分配的，断言<code>brk</code>一定是按<code>MALLOC_ALIGNMENT</code>对齐的，因为<code>mmap()</code>返回的地址按页对齐。如果<code>brk</code>的结束地址非法，使用<code>morecore</code>获得当前<code>brk</code>的结束地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Adjust top based on results of second sbrk */</span></span><br><span class="line"><span class="keyword">if</span> (snd_brk != (<span class="type">char</span>*)(MORECORE_FAILURE)) &#123;</span><br><span class="line">    av-&gt;top = (mchunkptr)aligned_brk;</span><br><span class="line">    set_head(av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="line">    av-&gt;system_mem += correction;</span><br></pre></td></tr></table></figure>
<p>如果<code>brk</code>的结束地址合法，设置当前分配区的<code>top chunk</code>为<code>brk</code>，设置<code>top chunk</code>的大小，并更新分配区的总分配内存量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    If not the first time through, we either have a</span></span><br><span class="line"><span class="comment">                    gap due to foreign sbrk or a non-contiguous region. Insert a</span></span><br><span class="line"><span class="comment">                    double fencepost at old_top to prevent consolidation with space</span></span><br><span class="line"><span class="comment">                    we don&#x27;t own. These fenceposts are artificial chunks that are</span></span><br><span class="line"><span class="comment">                    marked as inuse and are in any case too small to use. We need</span></span><br><span class="line"><span class="comment">                    two to make sizes and alignments work out.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">if</span> (old_size != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        shrink old_top to insert fenceposts, keeping size a</span></span><br><span class="line"><span class="comment">                        multiple of MALLOC_ALIGNMENT. We know there is at least</span></span><br><span class="line"><span class="comment">                        enough space in old_top to do this.</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        old_size = (old_size - <span class="number">4</span>*SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">                        set_head(old_top, old_size | PREV_INUSE);</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        Note that the following assignments completely overwrite</span></span><br><span class="line"><span class="comment">                        old_top when old_size was previously MINSIZE. This is</span></span><br><span class="line"><span class="comment">                        intentional. We need the fencepost, even if old_top otherwise gets</span></span><br><span class="line"><span class="comment">                        lost.</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        chunk_at_offset(old_top, old_size )-&gt;size =</span><br><span class="line">                        (<span class="number">2</span>*SIZE_SZ)|PREV_INUSE;</span><br><span class="line">                        chunk_at_offset(old_top, old_size + <span class="number">2</span>*SIZE_SZ)-&gt;size =</span><br><span class="line">                        (<span class="number">2</span>*SIZE_SZ)|PREV_INUSE;</span><br><span class="line">                        <span class="comment">/* If possible, release the rest. */</span></span><br><span class="line">                        <span class="keyword">if</span> (old_size &gt;= MINSIZE) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">                            _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                            _int_free(av, old_top);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure>
<p>设置原<code>top chunk</code>的<code>fencepost</code>，<code>fencepost</code>需要<code>MINSIZE</code>大小的内存空间，将该<code>old_size</code>减去<code>MINSIZE</code>得到原<code>top chunk</code>的有效内存空间，我们可以确信原<code>top chunk</code>的有效内存空间一定大于<code>MINSIZE</code>，将原<code>top chunk</code>切分成空闲<code>chunk</code>和<code>fencepost</code>两部分，首先设置切分出来的<code>chunk</code>的大小为<code>old_size</code>，并标识前一个<code>chunk</code>处于<code>inuse</code>状态，原<code>top chunk</code>切分出来的<code>chunk</code>本应处于空闲状态，但<code>fencepost</code>的第一个<code>chunk</code>却标识前一个<code>chunk</code>为<code>inuse</code>状态，然后强制将该处于<code>inuse</code>状态的<code>chunk</code>调用<code>_int_free()</code>函数释放掉。然后设置<code>fencepost</code>的第一个<code>chunk</code>的大小为<code>2*SIZE_SZ</code>，并标识前一个<code>chunk</code>处于<code>inuse</code>状态，然后设置<code>fencepost</code>的第二个<code>chunk</code>的<code>size</code>为<code>2*SIZE_SZ</code>，并标识前一个<code>chunk</code>处于<code>inuse</code>状态。这里的主分配区的<code>fencepost</code>与非主分配区的<code>fencepost</code>不同，主分配区<code>fencepost</code>的第二个<code>chunk</code>的大小设置为<code>2*SIZE_SZ</code>，而非主分配区的<code>fencepost</code>的第二个<code>chunk</code>的大小设置为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Update statistics */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NO_THREADS</span></span><br><span class="line">            sum = av-&gt;system_mem + mp_.mmapped_mem;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.max_total_mem))</span><br><span class="line">            mp_.max_total_mem = sum;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，对主分配区的分配出来完毕。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="comment">/* if (av != &amp;main_arena) */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)av-&gt;system_mem &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(av-&gt;max_system_mem))</span><br><span class="line">    av-&gt;max_system_mem = av-&gt;system_mem;</span><br></pre></td></tr></table></figure>
<p>如果当前分配区所分配的内存量大于设置的最大值，更新当前分配区最大分配的内存量，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">check_malloc_state(av);</span><br><span class="line"><span class="comment">/* finally, do the allocation */</span></span><br><span class="line">p = av-&gt;top;</span><br><span class="line">size = chunksize(p);</span><br><span class="line"><span class="comment">/* check that one of the above allocation paths succeeded */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset(p, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head(p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    check_malloced_chunk(av, p, nb);</span><br><span class="line">    <span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>top chunk</code>中已经有足够的内存来分配所需的<code>chunk</code>，从当前的<code>top chunk</code>中分配所需的<code>chunk</code>并返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* catch all failure paths */</span></span><br><span class="line">    MALLOC_FAILURE_ACTION;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate()"></a>malloc_consolidate()</h4><p><code>malloc_consolidate()</code>函数用于将<code>fast bins</code>中的<code>chunk</code>合并，并加入<code>unsorted bin</code>中，其实现源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">------------------------- malloc_consolidate -------------------------</span></span><br><span class="line"><span class="comment">malloc_consolidate is a specialized version of free() that tears</span></span><br><span class="line"><span class="comment">down chunks held in fastbins. Free itself cannot be used for this</span></span><br><span class="line"><span class="comment">purpose since, among other things, it might place chunks back onto</span></span><br><span class="line"><span class="comment">fastbins. So, instead, we need to use a minor variant of the same</span></span><br><span class="line"><span class="comment">code.113</span></span><br><span class="line"><span class="comment">Also, because this routine needs to be called the first time through</span></span><br><span class="line"><span class="comment">malloc anyway, it turns out to be the perfect place to trigger</span></span><br><span class="line"><span class="comment">initialization code.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(av)</span> mstate av;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    mfastbinptr* fb; <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">    mfastbinptr* maxfb; <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">    mchunkptr p; <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">    mchunkptr nextp; <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">    mchunkptr unsorted_bin; <span class="comment">/* bin header */</span></span><br><span class="line">    mchunkptr first_unsorted; <span class="comment">/* chunk to link to */</span></span><br><span class="line">    <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">    mchunkptr nextchunk;</span><br><span class="line">    INTERNAL_SIZE_T size;</span><br><span class="line">    INTERNAL_SIZE_T nextsize;</span><br><span class="line">    INTERNAL_SIZE_T prevsize;</span><br><span class="line">    <span class="type">int</span> nextinuse;</span><br><span class="line">    mchunkptr bck;</span><br><span class="line">    mchunkptr fwd;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">        clear_fastchunks(av);</span><br><span class="line">        unsorted_bin = unsorted_chunks(av);</span><br></pre></td></tr></table></figure>
<p>如果全局变量<code>global_max_fast</code>不为零，表示<code>ptmalloc</code>已经初始化，清除分配区<code>flag</code>中<code>fast bin</code>的标志位，该标志位表示分配区的<code>fast bins</code>中包含空闲<code>chunk</code>。然后获得分配区的<code>unsorted bin</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">        then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">        placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">        until malloc is sure that chunks aren&#x27;t immediately going to be114</span></span><br><span class="line"><span class="comment">        reused anyway.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">        <span class="comment">/* It is wrong to limit the fast bins to search using get_max_fast</span></span><br><span class="line"><span class="comment">        because, except for the main arena, all the others might have</span></span><br><span class="line"><span class="comment">        blocks in the high fast bins. It&#x27;s not worth it anyway, just</span></span><br><span class="line"><span class="comment">        search all bins all the time. */</span></span><br><span class="line">        maxfb = &amp;fastbin (av, fastbin_index(get_max_fast ()));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        fb = &amp;fastbin (av, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>将分配区最大的一个<code>fast bin</code>赋值给<code>maxfb</code>，第一个<code>fast bin</code>赋值给<code>fb</code>，然后遍历<code>fast bins</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">            p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            p = *fb;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ATOMIC_FASTBINS</span></span><br><span class="line">                *fb = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>获取当前遍历的<code>fast bin</code>中空闲<code>chunk</code>单向链表的头指针赋值给<code>p</code>，如果<code>p</code>不为0，将当前<code>fast bin</code>链表的头指针赋值为0，即删除了该<code>fast bin</code>中的空闲<code>chunk</code>链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    check_inuse_chunk(av, p);</span><br><span class="line">    nextp = p-&gt;fd;</span><br></pre></td></tr></table></figure>
<p>将空闲<code>chunk</code>链表的下一个<code>chunk</code>赋值给<code>nextp</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">nextchunk = chunk_at_offset(p, size);</span><br><span class="line">nextsize = chunksize(nextchunk);</span><br></pre></td></tr></table></figure>
<p>获得当前<code>chunk</code>的<code>size</code>，需要去除<code>size</code>中的<code>PREV_INUSE</code>和<code>NON_MAIN_ARENA</code>标志，并获取相邻的下一个<code>chunk</code>和下一个<code>chunk</code>的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));<span class="number">115</span></span><br><span class="line">    unlink(p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>chunk</code>的前一个<code>chunk</code>空闲，则将当前<code>chunk</code>与前一个<code>chunk</code>合并成一个空闲<code>chunk</code>，由于前一个<code>chunk</code>空闲，则当前<code>chunk</code>的<code>prev_size</code>保存了前一个<code>chunk</code>的大小，计算出合并后的<code>chunk</code>大小，并获取前一个<code>chunk</code>的指针，将前一个<code>chunk</code>从空闲链表中删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br></pre></td></tr></table></figure>
<p>如果与当前<code>chunk</code>相邻的下一个<code>chunk</code>不是分配区的<code>top chunk</code>，查看与当前<code>chunk</code>相邻的下一个<code>chunk</code>是否处于<code>inuse</code>状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    unlink(nextchunk, bck, fwd);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>如果与当前<code>chunk</code>相邻的下一个<code>chunk</code>处于<code>inuse</code>状态，清除当前<code>chunk</code>的<code>inuse</code>状态，则当前<code>chunk</code>空闲了。否则，将相邻的下一个空闲<code>chunk</code>从空闲链表中删除，并计算当前<code>chunk</code>与下一个<code>chunk</code>合并后的<code>chunk</code>大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">unsorted_bin-&gt;fd = p;</span><br><span class="line">first_unsorted-&gt;bk = p;</span><br></pre></td></tr></table></figure>
<p>将合并后的<code>chunk</code>加入<code>unsorted bin</code>的双向循环链表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果合并后的<code>chunk</code>属于<code>large bin</code>，将<code>chunk</code>的<code>fd_nextsize</code>和<code>bk_nextsize</code>设置为<code>NULL</code>，因为在<code>unsorted bin</code>中这两个字段无用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_head(p, size | PREV_INUSE);</span><br><span class="line">p-&gt;bk = unsorted_bin;</span><br><span class="line">p-&gt;fd = first_unsorted;</span><br><span class="line">set_foot(p, size);</span><br></pre></td></tr></table></figure>
<p>设置合并后的空闲<code>chunk</code>大小，并标识前一个<code>chunk</code>处于<code>inuse</code>状态，因为必须保证不能有两个相邻的<code>chunk</code>都处于空闲状态。然后将合并后的<code>chunk</code>加入<code>unsorted bin</code>的双向循环链表中。最后设置合并后的空闲<code>chunk</code>的<code>foot</code>，<code>chunk</code>空闲时必须设置<code>foot</code>，该<code>foot</code>处于下一个<code>chunk</code>的<code>prev_size</code>中，只有<code>chunk</code>空闲是<code>foot</code>才是有效的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);<span class="number">116</span></span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>chunk</code>的下一个<code>chunk</code>为<code>top chunk</code>，则将当前<code>chunk</code>合并入<code>top chunk</code>，修改<code>top chunk</code>的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>直到遍历完当前<code>fast bin</code>中的所有空闲<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br></pre></td></tr></table></figure>
<p>直到遍历完所有的<code>fast bins</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">malloc_init_state(av);</span><br><span class="line">check_malloc_state(av);</span><br></pre></td></tr></table></figure></p>
<p>如果<code>ptmalloc</code>没有初始化，初始化<code>ptmalloc</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存释放-free"><a href="#内存释放-free" class="headerlink" title="内存释放 free"></a>内存释放 free</h2><h3 id="public-fREe"><a href="#public-fREe" class="headerlink" title="public_fREe()"></a>public_fREe()</h3><p><code>public_fREe()</code>函数的源代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">public_fREe</span><span class="params">(<span class="type">void_t</span>* mem)</span></span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    mchunkptr p; <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line">    <span class="type">void</span> (*hook) (<span class="type">__malloc_ptr_t</span>, __const <span class="type">__malloc_ptr_t</span>)</span><br><span class="line">    = force_reg (__free_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果存在<code>free</code>的<code>hook</code>函数，执行该<code>hook</code>函数返回，<code>free</code>的<code>hook</code>函数主要用于创建新线程使用或使用用户提供的<code>free</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">p = mem2chunk(mem);</span><br></pre></td></tr></table></figure>
<p><code>free NULL</code>指针直接返回，然后根据内存指针获得<code>chunk</code>的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">        <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">        &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">        &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            mp_.mmap_threshold = chunksize (p);</span><br><span class="line">            mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">        &#125;</span><br><span class="line">        munmap_chunk(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果当前<code>free</code>的<code>chunk</code>是通过<code>mmap()</code>分配的，调用<code>munmap_chunk()</code>函数<code>unmap</code>本<code>chunk</code>。<code>munmap_chunk()</code>函数调用<code>munmap()</code>函数释放<code>mmap()</code>分配的内存块。同时查看是否开启了<code>mmap</code>分配阈值动态调整机制，默认是开启的，如果当前<code>free</code>的<code>chunk</code>的大小大于设置的<code>mmap</code>分配阈值，小于<code>mmap</code>分配阈值的最大值，将当前<code>chunk</code>的大小赋值给<code>mmap</code>分配阈值，并修改<code>mmap</code>收缩阈值为<code>mmap</code>分配阈值的2倍。默认情况下<code>mmap</code>分配阈值与<code>mmap</code>收缩阈值相等，都为128KB。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar_ptr = arena_for_chunk(p);</span><br></pre></td></tr></table></figure>
<p>根据<code>chunk</code>指针获得分配区的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    _int_free(ar_ptr, p, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>如果开启了<code>ATOMIC_FASTBINS</code>优化，不需要对分配区加锁，调用<code>_int_free()</code>函数执行实际的释放工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> THREAD_STATS</span></span><br><span class="line">    <span class="keyword">if</span>(!mutex_trylock(&amp;ar_ptr-&gt;mutex))</span><br><span class="line">        ++(ar_ptr-&gt;stat_lock_direct);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">        ++(ar_ptr-&gt;stat_lock_wait);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">    (<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">    _int_free(ar_ptr, p);</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果没有开启了<code>ATOMIC_FASTBINS</code>优化，或去分配区的锁，调用<code>_int_free()</code>函数执行实际的释放工作，然后对分配区解锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="int-free"><a href="#int-free" class="headerlink" title="_int_free()"></a>_int_free()</h3><p><code>_int_free()</code>函数的实现源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">_int_free(mstate av, mchunkptr p)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T size; <span class="comment">/* its size */</span></span><br><span class="line">    mfastbinptr* fb; <span class="comment">/* associated fastbin */</span></span><br><span class="line">    mchunkptr nextchunk; <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">    INTERNAL_SIZE_T nextsize; <span class="comment">/* its size */</span></span><br><span class="line">    <span class="type">int</span> nextinuse; <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">    INTERNAL_SIZE_T prevsize; <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">    mchunkptr bck; <span class="comment">/* misc temp for linking */</span></span><br><span class="line">    mchunkptr fwd; <span class="comment">/* misc temp for linking */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    <span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    size = chunksize(p);</span><br></pre></td></tr></table></figure>
<p>获取需要释放的<code>chunk</code>的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">    allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">    Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">    here by accident or by &quot;design&quot; from some intruder. */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">        errout:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">        <span class="keyword">if</span> (! have_lock &amp;&amp; locked)</span><br><span class="line">            (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        malloc_printerr (check_action, errstr, chunk2mem(p));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size. */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (size &lt; MINSIZE, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure>
<p>上面的代码用于安全检查，<code>chunk</code>的指针地址不能溢出，<code>chunk</code>的大小必须大于等于<code>MINSIZE</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">    bordering top into fastbins</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">        || __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">        &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">            <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">            of system_mem might have let to a false positive. Redo the test</span></span><br><span class="line"><span class="comment">            after getting the lock. */</span></span><br><span class="line">            <span class="keyword">if</span> (have_lock</span><br><span class="line">            || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">            mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">            locked = <span class="number">1</span>;</span><br><span class="line">            chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">            || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">            &#125;))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#123;</span><br><span class="line">                errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">            <span class="keyword">if</span> (! have_lock)</span><br><span class="line">            &#123;</span><br><span class="line">                (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">                locked = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>free</code>的<code>chunk</code>属于<code>fast bins</code>，查看下一个相邻的<code>chunk</code>的大小是否小于等于<code>2*SIZE_SZ</code>，下一个相邻<code>chunk</code>的大小是否大于分配区所分配的内存总量，如果是，报错。这里计算下一个相邻<code>chunk</code>的大小似乎有点问题，因为<code>chunk</code>的<code>size</code>字段中包含了一些标志位，正常情况下下一个相邻<code>chunk</code>的<code>size</code>中的<code>PREV_INUSE</code>标志位会置位，但这里就是要检出错的情况，也就是下一个相邻<code>chunk</code>的<code>size</code>中标志位都没有置位，并且该<code>chunk</code>大小为<code>2*SIZE_SZ</code>的错误情况。如果开启了<code>ATOMIC_FASTBINS</code>优化，并且调用本函数前没有对分配区加锁，所以读取分配区所分配的内存总量需要对分配区加锁，检查完以后，释放分配区的锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">    free_perturb (chunk2mem(p), size - SIZE_SZ);</span><br><span class="line">set_fastchunks(av);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">fb = &amp;fastbin (av, idx);</span><br></pre></td></tr></table></figure>
<p>设置当前分配区的<code>fast bin flag</code>，表示当前分配区的<code>fast bins</code>中已有空闲<code>chunk</code>。然后根据当前<code>free</code>的<code>chunk</code>大小获取所属的<code>fast bin</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">        mchunkptr fd;</span><br><span class="line">        mchunkptr old = *fb;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Another simple check: make sure the top of the bin is not the</span></span><br><span class="line"><span class="comment">            record we are going to add (i.e., double free). */</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (old != <span class="literal">NULL</span>)</span><br><span class="line">                old_idx = fastbin_index(chunksize(old));</span><br><span class="line">            p-&gt;fd = fd = old;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, fd)) != fd);</span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>如果开启了<code>ATOMIC_FASTBINS</code>优化，使用<code>lock-free</code>技术实现<code>fast bin</code>的单向链表插入操作。这里也没有<code>ABA</code>问题，比如当前线程获取<code>*fb</code>并保存到<code>old</code>中，在调用<code>cas</code>原子操作前，<code>b</code>线程将<code>*fb</code>修改为<code>x</code>，如果<code>B</code>线程加入了新的<code>chunk</code>，则<code>x-&gt;fb</code>指向<code>old</code>，如果<code>B</code>线程删除了<code>old</code>，则<code>x</code>为<code>old-&gt;fb</code>。如果<code>C</code>线程将<code>*fb</code>修改为<code>old</code>，则可能将<code>B</code>线程加入的<code>chunk x</code>删除，或者<code>C</code>将<code>B</code>删除的<code>old</code>又重新加入。这两种情况，都不会导致链表出错，所以不会有<code>ABA</code>问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="comment">/* Another simple check: make sure the top of the bin is not the</span></span><br><span class="line"><span class="comment">        record we are going to add (i.e., double free). */</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (*fb == p, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*fb != <span class="literal">NULL</span></span><br><span class="line">        &amp;&amp; __builtin_expect (fastbin_index(chunksize(*fb)) != idx, <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;fd = *fb;</span><br><span class="line">        *fb = p;</span><br></pre></td></tr></table></figure>
<p>如果没有开启了<code>ATOMIC_FASTBINS</code>优化，将<code>free</code>的<code>chunk</code>加入<code>fast bin</code>的单向链表中，修改过链表表头为当前<code>free</code>的<code>chunk</code>。同时需要校验是否为<code>double free</code>错误，校验表头不为<code>NULL</code>情况下，保证表头<code>chunk</code>的所属的<code>fast bin</code>与当前<code>free</code>的<code>chunk</code>所属的<code>fast bin</code>相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS122</span></span><br><span class="line">        <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> THREAD_STATS</span></span><br><span class="line">            <span class="keyword">if</span>(!mutex_trylock(&amp;av-&gt;mutex))</span><br><span class="line">                ++(av-&gt;stat_lock_direct);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">                ++(av-&gt;stat_lock_wait);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            locked = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果当前<code>free</code>的<code>chunk</code>不是通过<code>mmap()</code>分配的，并且当前还没有获得分配区的锁，获取分配区的锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextchunk = chunk_at_offset(p, size);</span><br></pre></td></tr></table></figure>
<p>获取当前<code>free</code>的<code>chunk</code>的下一个相邻的<code>chunk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">top block. */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (p == av-&gt;top, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena. */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">&amp;&amp; (<span class="type">char</span> *) nextchunk &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Or whether the block is actually not marked used. */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (!prev_inuse(nextchunk), <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>安全检查，当前<code>free</code>的<code>chunk</code>不能为<code>top chunk</code>，因为<code>top chunk</code>为空闲<code>chunk</code>，如果再次<code>free</code>就可能为<code>double free</code>错误了。如果当前<code>free</code>的<code>chunk</code>是通过<code>sbrk()</code>分配的，并且下一个相邻的<code>chunk</code>的地址已经超过了<code>top chunk</code>的结束地址，超过了当前分配区的结束地址，报错。如果当前<code>free</code>的<code>chunk</code>的下一个相邻<code>chunk</code>的<code>size</code>中标志位没有标识当前<code>free chunk</code>为<code>inuse</code>状态，可能为<code>double free</code>错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">    free_perturb (chunk2mem(p), size - SIZE_SZ);</span><br></pre></td></tr></table></figure>
<p>计算当前<code>free</code>的<code>chunk</code>的下一个相邻<code>chunk</code>的大小，该大小如果小于等于<code>2*SIZE_SZ</code>或是大于了分配区所分配区的内存总量，报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    unlink(p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>free</code>的<code>chunk</code>的前一个相邻<code>chunk</code>为空闲状态，与前一个空闲<code>chunk</code>合并。计算合并后的<code>chunk</code>大小，并将前一个相邻空闲<code>chunk</code>从空闲<code>chunk</code>链表中删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br></pre></td></tr></table></figure>
<p>如果与当前<code>free</code>的<code>chunk</code>相邻的下一个<code>chunk</code>不是分配区的<code>top chunk</code>，查看与当前<code>chunk</code>相邻的下一个<code>chunk</code>是否处于<code>inuse</code>状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate forward */</span></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    unlink(nextchunk, bck, fwd);</span><br><span class="line">    size += nextsize;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>如果与当前<code>free</code>的<code>chunk</code>相邻的下一个<code>chunk</code>处于<code>inuse</code>状态，清除当前<code>chunk</code>的<code>inuse</code>状态，则当前<code>chunk</code>空闲了。否则，将相邻的下一个空闲<code>chunk</code>从空闲链表中删除，并计算当前<code>chunk</code>与下一个<code>chunk</code>合并后的<code>chunk</code>大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are124</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">bck = unsorted_chunks(av);</span><br><span class="line">fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (fwd-&gt;bk != bck, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;fd = fwd;</span><br><span class="line">p-&gt;bk = bck;</span><br><span class="line"><span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">bck-&gt;fd = p;</span><br><span class="line">fwd-&gt;bk = p;</span><br></pre></td></tr></table></figure>
<p>将合并后的<code>chunk</code>加入<code>unsorted bin</code>的双向循环链表中。如果合并后的<code>chunk</code>属于<code>large bins</code>，将<code>chunk</code>的<code>fd_nextsize</code>和<code>bk_nextsize</code>设置为<code>NULL</code>，因为在<code>unsorted bin</code>中这两个字段无用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_head(p, size | PREV_INUSE);</span><br><span class="line">set_foot(p, size);</span><br></pre></td></tr></table></figure>
<p>设置合并后的空闲<code>chunk</code>大小，并标识前一个<code>chunk</code>处于<code>inuse</code>状态，因为必须保证不能有两个相邻的<code>chunk</code>都处于空闲状态。然后将合并后的<code>chunk</code>加入<code>unsorted bin</code>的双向循环链表中。最后设置合并后的空闲<code>chunk</code>的<code>foot</code>，<code>chunk</code>空闲时必须设置<code>foot</code>，该<code>foot</code>处于下一个<code>chunk</code>的<code>prev_size</code>中，只有<code>chunk</code>空闲是<code>foot</code>才是有效的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    check_free_chunk(av, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">consolidate into top</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">    check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前<code>free</code>的<code>chunk</code>下一个相邻的<code>chunk</code>为<code>top chunk</code>，则将当前<code>chunk</code>合并入<code>top chunk</code>，修改<code>top chunk</code>的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment">Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">has been reached unless fastbins are consolidated. But we</span></span><br><span class="line"><span class="comment">don&#x27;t want to consolidate on each free. As a compromise,</span></span><br><span class="line"><span class="comment">consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">is reached.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);</span><br></pre></td></tr></table></figure>
<p>如果合并后的<code>chunk</code>大小大于<code>64KB</code>，并且<code>fast bins</code>中存在空闲<code>chunk</code>，调用<code>malloc_consolidate()</code>函数合并<code>fast bins</code>中的空闲<code>chunk</code>到<code>unsorted bin</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">                (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">                    sYSTRIm(mp_.top_pad, av);</span><br></pre></td></tr></table></figure>
<p>如果当前分配区为主分配区，并且<code>top chunk</code>的大小大于<code>heap</code>的收缩阈值，调用<code>sYSTRIm()</code>函数首先<code>heap</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">                large, because the corresponding heap might go away. */</span></span><br><span class="line">                heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line">                assert(heap-&gt;ar_ptr == av);</span><br><span class="line">                heap_trim(heap, mp_.top_pad);</span><br></pre></td></tr></table></figure>
<p>如果为非主分配区，调用<code>heap_trim()函数收缩非主分配区的</code>sub_heap`。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">        <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">            assert (locked);</span><br><span class="line">            (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果开启了<code>ATOMIC_FASTBINS</code>优化并获得分配区的锁，则对分配区解锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap(). Note</span></span><br><span class="line"><span class="comment">    that if HAVE_MMAP is false but chunk_is_mmapped is true, then</span></span><br><span class="line"><span class="comment">    user must have overwritten memory. There&#x27;s nothing we can do to</span></span><br><span class="line"><span class="comment">    catch this error unless MALLOC_DEBUG is set, in which case</span></span><br><span class="line"><span class="comment">    check_inuse_chunk (above) will have triggered error.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line">        munmap_chunk (p);</span><br></pre></td></tr></table></figure>
<p>如果当前<code>free</code>的<code>chunk</code>是通过<code>mmap()</code>分配的，调用<code>munma_chunk()</code>释放内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sYSTRIm-和munmap-chunk"><a href="#sYSTRIm-和munmap-chunk" class="headerlink" title="sYSTRIm()和munmap_chunk()"></a>sYSTRIm()和munmap_chunk()</h3><p><code>sYSTRIm()</code>函数源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sYSTRIm is an inverse of sorts to sYSMALLOc. It gives memory back</span></span><br><span class="line"><span class="comment">to the system (via negative arguments to sbrk) if there is unused</span></span><br><span class="line"><span class="comment">memory at the `high&#x27; end of the malloc pool. It is called</span></span><br><span class="line"><span class="comment">automatically by free() when top space exceeds the trim</span></span><br><span class="line"><span class="comment">threshold. It is also called by the public malloc_trim routine. It</span></span><br><span class="line"><span class="comment">returns 1 if it actually released any memory, else 0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sYSTRIm</span><span class="params">(<span class="type">size_t</span> pad, mstate av)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sYSTRIm</span><span class="params">(pad, av)</span> <span class="type">size_t</span> pad; mstate av;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> top_size; <span class="comment">/* Amount of top-most memory */</span></span><br><span class="line">    <span class="type">long</span> extra; <span class="comment">/* Amount to release */</span></span><br><span class="line">    <span class="type">long</span> released; <span class="comment">/* Amount actually released */</span></span><br><span class="line">    <span class="type">char</span>* current_brk; <span class="comment">/* address returned by pre-check sbrk call */</span></span><br><span class="line">    <span class="type">char</span>* new_brk; <span class="comment">/* address returned by post-check sbrk call */</span></span><br><span class="line">    <span class="type">size_t</span> pagesz;</span><br><span class="line">    pagesz = mp_.pagesize;</span><br><span class="line">    top_size = chunksize(av-&gt;top);</span><br></pre></td></tr></table></figure>
<p>获取页大小和<code>top chunk</code>的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Release in pagesize units, keeping at least one page */</span></span><br><span class="line">extra = ((top_size - pad - MINSIZE + (pagesz<span class="number">-1</span>)) / pagesz - <span class="number">1</span>) * pagesz;</span><br></pre></td></tr></table></figure>
<p>计算<code>top chunk</code>中最大可释放的整数页大小，<code>top chunk</code>中至少需要<code>MINSIZE</code>的内存保存<code>fencepost</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (extra &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Only proceed if end of memory is where we last set it.</span></span><br><span class="line"><span class="comment">    This avoids problems if there were foreign sbrk calls.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    current_brk = (<span class="type">char</span>*)(MORECORE(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (current_brk == (<span class="type">char</span>*)(av-&gt;top) + top_size) &#123;</span><br></pre></td></tr></table></figure>
<p>获取当前<code>brk</code>值，如果当前<code>top chunk</code>的结束地址与当前的<code>brk</code>值相等，执行<code>heap</code>收缩。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Attempt to release memory. We ignore MORECORE return value,</span></span><br><span class="line"><span class="comment">and instead call again to find out where new end of memory is.</span></span><br><span class="line"><span class="comment">This avoids problems if first call releases less than we asked,</span></span><br><span class="line"><span class="comment">of if failure somehow altered brk value. (We could still</span></span><br><span class="line"><span class="comment">encounter problems if it altered brk in some very bad way,</span></span><br><span class="line"><span class="comment">but the only thing we can do is adjust anyway, which will cause</span></span><br><span class="line"><span class="comment">some downstream failure.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MORECORE(-extra);</span><br></pre></td></tr></table></figure>
<p>调用<code>sbrk()</code>释放指定大小的内存到<code>heap</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Call the `morecore&#x27; hook if necessary. */</span></span><br><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span>) = force_reg (__after_morecore_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    (*hook) ();</span><br><span class="line">new_brk = (<span class="type">char</span>*)(MORECORE(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>如果<code>morecore hook</code>存在，执行<code>hook</code>函数，然后获得当前新的<code>brk</code>值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (new_brk != (<span class="type">char</span>*)MORECORE_FAILURE) &#123;</span><br><span class="line">    released = (<span class="type">long</span>)(current_brk - new_brk);</span><br><span class="line">    <span class="keyword">if</span> (released != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Success. Adjust top. */</span></span><br><span class="line">        av-&gt;system_mem -= released;</span><br><span class="line">        set_head(av-&gt;top, (top_size - released) | PREV_INUSE);</span><br><span class="line">        check_malloc_state(av);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果获取新的<code>brk</code>值成功，计算释放的内存大小，更新当前分配区所分配的内存总量，更新<code>top chunk</code>的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>unmap_chunk()</code>函数源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">internal_function</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line">munmap_chunk(mchunkptr p)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">munmap_chunk(p) mchunkptr p;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T size = chunksize(p);</span><br><span class="line">    assert (chunk_is_mmapped(p));</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    assert(! ((<span class="type">char</span>*)p &gt;= mp_.sbrk_base &amp;&amp; (<span class="type">char</span>*)p &lt; mp_.sbrk_base + mp_.sbrked_mem));</span><br><span class="line">    assert((mp_.n_mmaps &gt; <span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">uintptr_t</span> block = (<span class="type">uintptr_t</span>) p - p-&gt;prev_size;</span><br><span class="line">    <span class="type">size_t</span> total_size = p-&gt;prev_size + size;</span><br><span class="line">    <span class="comment">/* Unfortunately we have to do the compilers job by hand here. Normally</span></span><br><span class="line"><span class="comment">    we would test BLOCK and TOTAL-SIZE separately for compliance with the</span></span><br><span class="line"><span class="comment">    page size. But gcc does not recognize the optimization possibility</span></span><br><span class="line"><span class="comment">    (in the moment at least) so we combine the two values into one before</span></span><br><span class="line"><span class="comment">    the bit test. */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (((block | total_size) &amp; (mp_.pagesize - <span class="number">1</span>)) != <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        malloc_printerr (check_action, <span class="string">&quot;munmap_chunk(): invalid pointer&quot;</span>, chunk2mem (p));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mp_.n_mmaps--;</span><br><span class="line">    mp_.mmapped_mem -= total_size;<span class="number">129</span></span><br><span class="line">    <span class="type">int</span> ret __attribute__ ((unused)) = munmap((<span class="type">char</span> *)block, total_size);</span><br><span class="line">    <span class="comment">/* munmap returns non-zero on failure */</span></span><br><span class="line">    assert(ret == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>munmap_chunk()</code>函数实现相当简单，首先获取当前<code>free</code>的<code>chunk</code>的大小，断言当前<code>free</code>的<code>chunk</code>是通过<code>mmap()</code>分配的，由于使用<code>mmap()</code>分配的<code>chunk</code>的<code>prev_size</code>中记录的前一个相邻空闲<code>chunk</code>的大小，<code>mmap()</code>分配的内存是页对齐的，所以一般情况下<code>prev_size</code>为0。</p>
<p>然后计算当前<code>free</code>的<code>chunk</code>占用的总内存大小<code>total_size</code>，再次校验内存块的起始地址是否是对齐的，更新分配区的<code>mmap</code>统计信息，最后调用<code>munmap()</code>函数释放<code>chunk</code>的内存。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B03/" rel="prev" title="深入分析Linux内核源码笔记3">
      <i class="fa fa-chevron-left"></i> 深入分析Linux内核源码笔记3
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/01/jemalloc%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" rel="next" title="jemalloc源码解析">
      jemalloc源码解析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#X86%E5%B9%B3%E5%8F%B0Linux%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">1.1.</span> <span class="nav-text">X86平台Linux进程内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#32%E4%BD%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80"><span class="nav-number">1.1.1.</span> <span class="nav-text">32位模式下进程内存经典布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32%E4%BD%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%BB%98%E8%AE%A4%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">1.1.2.</span> <span class="nav-text">32位模式下进程默认内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64%E4%BD%8D%E6%A8%A1%E5%BC%8F%E4%B8%8B%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">1.1.3.</span> <span class="nav-text">64位模式下进程内存布局</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">操作系统内存分配的相关函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#heap%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">heap操作相关函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mmap%E6%98%A0%E5%B0%84%E5%8C%BA%E5%9F%9F%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">mmap映射区域操作相关函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%80%E8%88%AC%E6%80%A7%E6%8F%8F%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text">内存管理一般性描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.1.</span> <span class="nav-text">内存管理的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">C风格的内存管理程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%A0%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">池式内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">引用计数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">垃圾收集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="nav-number">2.1.2.</span> <span class="nav-text">内存管理器的设计目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.1.3.</span> <span class="nav-text">常见C内存管理程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ptmalloc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="nav-number">2.2.</span> <span class="nav-text">ptmalloc内存管理概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%81%87%E8%AE%BE"><span class="nav-number">2.2.2.</span> <span class="nav-text">内存管理的设计假设</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="nav-number">2.2.3.</span> <span class="nav-text">内存管理数据结构概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Main-arena%E4%B8%8Enon-main-arena"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">Main_arena与non_main_arena</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#chunk%E7%9A%84%E7%BB%84%E7%BB%87"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">chunk的组织</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#chunk%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.2.3.2.1.</span> <span class="nav-text">chunk格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#chunk%E4%B8%AD%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E7%94%A8"><span class="nav-number">2.2.3.2.2.</span> <span class="nav-text">chunk中的空间复用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2chunk%E5%AE%B9%E5%99%A8"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">空闲chunk容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Bins"><span class="nav-number">2.2.3.3.1.</span> <span class="nav-text">Bins</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Fast-Bins"><span class="nav-number">2.2.3.3.2.</span> <span class="nav-text">Fast Bins</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Unsorted-Bin"><span class="nav-number">2.2.3.3.3.</span> <span class="nav-text">Unsorted Bin</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Top-chunk"><span class="nav-number">2.2.3.3.4.</span> <span class="nav-text">Top chunk</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mmaped-chunk"><span class="nav-number">2.2.3.3.5.</span> <span class="nav-text">mmaped chunk</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Last-remainder"><span class="nav-number">2.2.3.3.6.</span> <span class="nav-text">Last remainder</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sbrk%E4%B8%8Emmap"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">sbrk与mmap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A6%82%E8%BF%B0"><span class="nav-number">2.2.4.</span> <span class="nav-text">内存分配概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">分配算法概述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0"><span class="nav-number">2.2.5.</span> <span class="nav-text">内存回收概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9%E6%A6%82%E8%BF%B0"><span class="nav-number">2.2.6.</span> <span class="nav-text">配置选项概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">2.2.7.</span> <span class="nav-text">使用注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="nav-number">3.</span> <span class="nav-text">问题分析及解决</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">源代码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%B9%E7%95%8C%E6%A0%87%E8%AE%B0%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">边界标记法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E7%AE%B1%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">4.2.</span> <span class="nav-text">分箱式内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#small-bins"><span class="nav-number">4.2.1.</span> <span class="nav-text">small bins</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#large-bins"><span class="nav-number">4.2.2.</span> <span class="nav-text">large bins</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unsorted-bin"><span class="nav-number">4.2.3.</span> <span class="nav-text">unsorted bin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fast-bins"><span class="nav-number">4.2.4.</span> <span class="nav-text">fast bins</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%86%E6%9E%90"><span class="nav-number">4.3.</span> <span class="nav-text">核心结构体分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-state"><span class="nav-number">4.3.1.</span> <span class="nav-text">malloc_state</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-par"><span class="nav-number">4.3.2.</span> <span class="nav-text">malloc_par</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%8C%BA%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.3.3.</span> <span class="nav-text">分配区的初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9"><span class="nav-number">4.4.</span> <span class="nav-text">配置选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ptmalloc%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.5.</span> <span class="nav-text">ptmalloc的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ptmalloc%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E5%88%86%E9%85%8D-%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98"><span class="nav-number">4.5.1.</span> <span class="nav-text">ptmalloc未初始化时分配&#x2F;释放内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ptmalloc-init-%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.2.</span> <span class="nav-text">ptmalloc_init()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ptmalloc-lock-all-ptmalloc-unlock-all-ptmalloc-unlock-all2"><span class="nav-number">4.5.3.</span> <span class="nav-text">ptmalloc_lock_all(),ptmalloc_unlock_all(),ptmalloc_unlock_all2()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%88%86%E9%85%8D%E5%8C%BA%E6%94%AF%E6%8C%81"><span class="nav-number">4.6.</span> <span class="nav-text">多分配区支持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-info"><span class="nav-number">4.6.1.</span> <span class="nav-text">heap_info</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%88%86%E9%85%8D%E5%8C%BA"><span class="nav-number">4.6.2.</span> <span class="nav-text">获取分配区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#arena-get2"><span class="nav-number">4.6.3.</span> <span class="nav-text">arena_get2()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#int-new-arena"><span class="nav-number">4.6.4.</span> <span class="nav-text">_int_new_arena()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-heap"><span class="nav-number">4.6.5.</span> <span class="nav-text">new_heap()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-free-list-%E5%92%8Creused-arena"><span class="nav-number">4.6.6.</span> <span class="nav-text">get_free_list()和reused_arena()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#grow-heap-shrink-heap-delete-heap-heap-trim"><span class="nav-number">4.6.7.</span> <span class="nav-text">grow_heap(),shrink_heap(),delete_heap(),heap_trim()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8Dmalloc"><span class="nav-number">4.7.</span> <span class="nav-text">内存分配malloc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#public-malloc"><span class="nav-number">4.7.1.</span> <span class="nav-text">public_malloc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#int-malloc"><span class="nav-number">4.7.2.</span> <span class="nav-text">_int_malloc()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8Dfast-bin-chunk"><span class="nav-number">4.7.2.1.</span> <span class="nav-text">分配fast bin chunk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8Dsmall-bin-chunk"><span class="nav-number">4.7.2.2.</span> <span class="nav-text">分配small bin chunk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8Dlarge-bin-chunk"><span class="nav-number">4.7.2.3.</span> <span class="nav-text">分配large bin chunk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sYSMALLOc"><span class="nav-number">4.7.2.4.</span> <span class="nav-text">sYSMALLOc()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#malloc-consolidate"><span class="nav-number">4.7.2.5.</span> <span class="nav-text">malloc_consolidate()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE-free"><span class="nav-number">4.8.</span> <span class="nav-text">内存释放 free</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#public-fREe"><span class="nav-number">4.8.1.</span> <span class="nav-text">public_fREe()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#int-free"><span class="nav-number">4.8.2.</span> <span class="nav-text">_int_free()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sYSTRIm-%E5%92%8Cmunmap-chunk"><span class="nav-number">4.8.3.</span> <span class="nav-text">sYSTRIm()和munmap_chunk()</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
