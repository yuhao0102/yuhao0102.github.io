<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="模板面对创建一个 eBPF 项目，您是否对如何开始搭建环境以及选择编程语言感到困惑？别担心，我们为您准备了一系列 GitHub 模板，以便您快速启动一个全新的eBPF项目。只需在GitHub上点击 Use this template 按钮，即可开始使用。  https:&#x2F;&#x2F;github.com&#x2F;eunomia-bpf&#x2F;libbpf-starter-template：基于 C 语言和 libbpf">
<meta property="og:type" content="article">
<meta property="og:title" content="eBPF编程入门">
<meta property="og:url" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="模板面对创建一个 eBPF 项目，您是否对如何开始搭建环境以及选择编程语言感到困惑？别担心，我们为您准备了一系列 GitHub 模板，以便您快速启动一个全新的eBPF项目。只需在GitHub上点击 Use this template 按钮，即可开始使用。  https:&#x2F;&#x2F;github.com&#x2F;eunomia-bpf&#x2F;libbpf-starter-template：基于 C 语言和 libbpf">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013132759955-400013194.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013133225867-27638626.png">
<meta property="og:image" content="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013133852963-1268164061.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013134848755-1784463340.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013141644335-498065214.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013141955031-399253323.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013164654944-1171325899.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013164724219-394278362.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013165137710-219497107.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013170010919-379150499.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013170943644-1717727984.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013171241218-1594676762.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013171604989-1381423607.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013172007075-1761244868.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013172251554-1480894530.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013172603927-1716900284.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013172650404-460105815.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013173729117-275551336.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013174724969-1908539149.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013174902027-1666955359.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013175313179-1284218320.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013175553333-2093837334.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013184519769-399656865.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013184537887-1491314258.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013184729922-2077708626.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013184922942-1226769170.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013190707738-1545406556.png">
<meta property="og:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013190707738-1545406557.png">
<meta property="article:published_time" content="2023-09-08T04:25:00.000Z">
<meta property="article:modified_time" content="2023-09-08T09:48:54.080Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/1365470-20211013132759955-400013194.png">

<link rel="canonical" href="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>eBPF编程入门 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/09/08/eBPF%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          eBPF编程入门
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-09-08 12:25:00 / Modified: 17:48:54" itemprop="dateCreated datePublished" datetime="2023-09-08T12:25:00+08:00">2023-09-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>面对创建一个 eBPF 项目，您是否对如何开始搭建环境以及选择编程语言感到困惑？别担心，我们为您准备了一系列 GitHub 模板，以便您快速启动一个全新的eBPF项目。只需在GitHub上点击 <code>Use this template</code> 按钮，即可开始使用。</p>
<ul>
<li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Feunomia-bpf%2Flibbpf-starter-template">https://github.com/eunomia-bpf/libbpf-starter-template</a>：基于 C 语言和 libbpf 框架的eBPF 项目模板</li>
<li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Feunomia-bpf%2Fcilium-ebpf-starter-template">https://github.com/eunomia-bpf/cilium-ebpf-starter-template</a>：基于 Go 语言和cilium/框架的的 eBPF 项目模板</li>
<li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Feunomia-bpf%2Flibbpf-rs-starter-template">https://github.com/eunomia-bpf/libbpf-rs-starter-template</a>：基于 Rust 语言和libbpf-rs 框架的 eBPF 项目模板</li>
<li><a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Feunomia-bpf%2Feunomia-template">https://github.com/eunomia-bpf/eunomia-template</a>：基于 C 语言和 eunomia-bpf 框架的eBPF 项目模板</li>
</ul>
<h1 id="搭建BPF程序运行环境"><a href="#搭建BPF程序运行环境" class="headerlink" title="搭建BPF程序运行环境"></a>搭建BPF程序运行环境</h1><h2 id="下载内核源码"><a href="#下载内核源码" class="headerlink" title="下载内核源码"></a>下载内核源码</h2><p>下载的内核版本应与你系统的版本一致，查看当前内核版本 uname -r</p>
<p>然后在源码镜像站点(<a href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel)下载对应版本的内核源码">http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel)下载对应版本的内核源码</a></p>
<p>也可以通过Ubuntu apt仓库下载。Ubuntu官方自己维护了每个操作系统版本的背后的Linux内核代码，可以通过以下两种apt命令方式获取相关代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 第一种方式</span><br><span class="line"># 先搜索</span><br><span class="line">&gt; apt-cache search linux-source</span><br><span class="line">    linux-source - Linux kernel source with Ubuntu patches</span><br><span class="line">    linux-source-4.15.0 - Linux kernel source for version 4.15.0 with Ubuntu patches</span><br><span class="line">    linux-source-4.18.0 - Linux kernel source for version 4.18.0 with Ubuntu patches</span><br><span class="line">    linux-source-5.0.0 - Linux kernel source for version 5.0.0 with Ubuntu patches</span><br><span class="line">    linux-source-5.3.0 - Linux kernel source for version 5.3.0 with Ubuntu patches</span><br><span class="line"># 再安装</span><br><span class="line">&gt; apt install linux-source-4.15.0</span><br><span class="line">    </span><br><span class="line"># 第二种方式</span><br><span class="line">&gt; apt-get source linux</span><br><span class="line">    Reading package lists... Done</span><br><span class="line">    NOTICE: &#x27;linux&#x27; packaging is maintained in the &#x27;Git&#x27; version control system at:</span><br><span class="line">    git://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/bionic</span><br><span class="line">    Please use:</span><br><span class="line">    git clone git://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/bionic</span><br><span class="line">    to retrieve the latest (possibly unreleased) updates to the package.</span><br><span class="line">    Need to get 167 MB of source archives.</span><br><span class="line">    Get:2 https://mirrors.ustc.edu.cn/ubuntu bionic-updates/main linux 4.15.0-99.100 (tar) [158 MB]</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"># 以上两种方式，内核源代码均下载至/usr/src/目录下</span><br></pre></td></tr></table></figure>
<h2 id="安装依赖项"><a href="#安装依赖项" class="headerlink" title="安装依赖项"></a>安装依赖项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install libncurses5-dev flex bison libelf-dev binutils-dev libssl-dev</span><br></pre></td></tr></table></figure>
<h2 id="安装Clang和LLVM"><a href="#安装Clang和LLVM" class="headerlink" title="安装Clang和LLVM"></a>安装Clang和LLVM</h2><p>然后使用以下两条命令分别安装 clang 和 llvm</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install clang`</span><br><span class="line">`apt install llvm</span><br></pre></td></tr></table></figure>
<h2 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h2><p>在源码根目录下使用<code>make defconfig</code>生成<code>.config&lt;c/ode&gt;文件</code></p>
<h2 id="解决modpost-not-found错误"><a href="#解决modpost-not-found错误" class="headerlink" title="解决modpost: not found错误"></a>解决modpost: not found错误</h2><p>因为直接make M=samples/bpf时，会报错缺少modules的错误。修复modpost的错误，以下两种解决方案二选一</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make modules_prepare</span><br><span class="line">make script</span><br></pre></td></tr></table></figure>
<h2 id="关联内核头文件"><a href="#关联内核头文件" class="headerlink" title="关联内核头文件"></a>关联内核头文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make headers_install</span><br></pre></td></tr></table></figure>
<h2 id="编译内核程序样例"><a href="#编译内核程序样例" class="headerlink" title="编译内核程序样例"></a>编译内核程序样例</h2><p>在源码根目录下执行<code>make M=samples/bpf</code>,</p>
<p>此时进入linux-source-4.15.0/smaples/bpf中，会看到生成了BPF字节码文件*_kern.o和用户态的可执行文件</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013132759955-400013194.png"><img src="1365470-20211013132759955-400013194.png" alt="img"></a></p>
<p>你可以运行几个试试，例如sockex1</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013133225867-27638626.png"><img src="1365470-20211013133225867-27638626.png" alt="img"></a></p>
<h1 id="使用BPF-C编写hello-world程序"><a href="#使用BPF-C编写hello-world程序" class="headerlink" title="使用BPF C编写hello world程序"></a>使用BPF C编写hello world程序</h1><h2 id="先了解一下原理吧"><a href="#先了解一下原理吧" class="headerlink" title="先了解一下原理吧"></a>先了解一下原理吧</h2><p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013133852963-1268164061.png"><img src="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013133852963-1268164061.png" alt="img"></a></p>
<p>BPF程序经过Clang/LLVM编译成BPF字节码，然后通过BPF系统调用的方式加载进内核，然后交给BPF虚拟机来执行，也是JIT的方式动态转成机器码</p>
<p>内核有很多hook点，我们在写BPF程序时也会做事件源配置。当hook点上的事件发生时，就会执行我们的BPF程序。</p>
<p>我们还可以在BPF程序中创建一个Map，把我们想拿到的数据保存在Map中，然后用户态程序就可以拿到。</p>
<p>总之，就是我们可以通过BPF程序拿到内核的一些数据</p>
<h2 id="hello-world程序"><a href="#hello-world程序" class="headerlink" title="hello world程序"></a>hello world程序</h2><p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013134848755-1784463340.png"><img src="1365470-20211013134848755-1784463340.png" alt="img"></a></p>
<p>进入samples/bpf目录，可以利用自带的Makefile编译，</p>
<p>编写hello_kern.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bpf_helpers.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEC(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_enter_execve&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">bpf_prog</span><span class="params">(<span class="type">void</span> *ctx)</span>&#123;</span><br><span class="line">        <span class="type">char</span> msg[] = <span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">        bpf_trace_printk(msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> _license[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这个程序的作用就是当发生系统调用(sys_enter_execve)时在终端输出”Hello World”，其实bpf_trace_printk只是将msg写到一个管道文件中</p>
<p>编写hello_user.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bpf_load.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(load_bpf_file(<span class="string">&quot;hello_kern.o&quot;</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;The kernel didn&#x27;t load BPF program\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read_trace_pipe();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的作用是将包含BPF的文件hello_kern.o通过系统调用的方式加载进内核，read_trace_pipe()读取管道文件并打印到终端</p>
<h2 id="修改Makefile"><a href="#修改Makefile" class="headerlink" title="修改Makefile"></a>修改Makefile</h2><p>模仿原有的，有四处需要修改：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># List of programs to build</span><br><span class="line">hostprogs-y += hello</span><br><span class="line"></span><br><span class="line"># Libbpf dependencies</span><br><span class="line">hello-objs := bpf_load.o $(LIBBPF) hello_user.o</span><br><span class="line"></span><br><span class="line"># Tell kbuild to always build the programs</span><br><span class="line">always += hello_kern.o</span><br><span class="line"></span><br><span class="line">HOSTLOADLIBES_hello += -lelf</span><br></pre></td></tr></table></figure></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>可以返回源码根目录用 <code>make M=samples/bpf</code> 或 <code>make samples/bpf/</code> 编译</p>
<p>或者直接在当前目录(samples/bpf) 执行make 编译</p>
<p>可以查看编译后的结果，生成了hello可执行文件</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013141644335-498065214.png"><img src="1365470-20211013141644335-498065214.png" alt="img"></a></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013141955031-399253323.png"><img src="1365470-20211013141955031-399253323.png" alt="img"></a></p>
<h2 id="进一步"><a href="#进一步" class="headerlink" title="进一步"></a>进一步</h2><p>进一步学习BPF程序是如何转换成字节码的</p>
<h3 id="BPF程序中的节-section"><a href="#BPF程序中的节-section" class="headerlink" title="BPF程序中的节(section)"></a>BPF程序中的节(section)</h3><p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013164654944-1171325899.png"><img src="1365470-20211013164654944-1171325899.png" alt="img"></a></p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013164724219-394278362.png"><img src="1365470-20211013164724219-394278362.png" alt="img"></a></p>
<p>SEC宏会将宏里面的内容(kprobe/sys_write)作为节的名字放到elf文件中，也就是目标文件，可以用readelf工具查看</p>
<p>还用宏生成了一个名字为license的section</p>
<h3 id="BPF程序中的字节码-bytecode"><a href="#BPF程序中的字节码-bytecode" class="headerlink" title="BPF程序中的字节码(bytecode)"></a>BPF程序中的字节码(bytecode)</h3><p>可以用objdump工具查看</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013165137710-219497107.png"><img src="1365470-20211013165137710-219497107.png" alt="img"></a></p>
<p>可见是将我们的bpf程序编译到elf文件的某个节中，右边黄框内就是常说的bpf字节码，对应左边灰色内容</p>
<p>接下来讲一下，bpf程序是如何转成字节码的</p>
<h3 id="BPF内核辅助函数调用转换为BPF字节码的过程"><a href="#BPF内核辅助函数调用转换为BPF字节码的过程" class="headerlink" title="BPF内核辅助函数调用转换为BPF字节码的过程"></a>BPF内核辅助函数调用转换为BPF字节码的过程</h3><p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013170010919-379150499.png"><img src="1365470-20211013170010919-379150499.png" alt="img"></a></p>
<p>我们用到的BPF内核辅助函数是bpf_trace_printk</p>
<p>bpg_prog是我们的elf函数名字，分析下call 6是怎么得到的？</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013170943644-1717727984.png"><img src="1365470-20211013170943644-1717727984.png" alt="img"></a></p>
<p><code>BPF_FUNC_map_lookup_elem</code>(<code>BPF_FUNC_trace_printk</code>类似)是在bpf.h中定义的，只不过是宏的形式，我们将其展开：</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013171241218-1594676762.png"><img src="1365470-20211013171241218-1594676762.png" alt="img"></a></p>
<p>可见BPF_FUNC_trace_printk的相对位置是6，</p>
<p>一般BPF内核辅助函数转汇编是这样的：</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013171604989-1381423607.png"><img src="1365470-20211013171604989-1381423607.png" alt="img"></a></p>
<p>就是BPF_call id，id就是bpf_func_id中的id；</p>
<p>进一步就是BPF_EMIT_CALL(func name)</p>
<p>例如，在内核中的某一处代码，调用bpf_map_lookup_elem，在BPF指令集编程中，就是使用BPF_EMIT_CALL来调用的</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013172007075-1761244868.png"><img src="1365470-20211013172007075-1761244868.png" alt="img"></a></p>
<p>不难想象，我们调用bpf_trace_printk也是采用同样的调用方式</p>
<p>BPF_EMIT_CALL(func name)是如何转化成字节码的呢？</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013172251554-1480894530.png"><img src="1365470-20211013172251554-1480894530.png" alt="img"></a></p>
<p>_bpf_call_base啥也没做，直接返回0，可见只是需要其地址，而差值就是在enum中的位置</p>
<p>进一步分析</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013172603927-1716900284.png"><img src="1365470-20211013172603927-1716900284.png" alt="img"></a> <a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013172650404-460105815.png"><img src="1365470-20211013172650404-460105815.png" alt="img"></a></p>
<p>所以，call 6对应的字节码就是85 00 00 00 06 00 00 00</p>
<p>我们还可以进一步查看JIT前后字节码的变化：</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013173729117-275551336.png"><img src="1365470-20211013173729117-275551336.png" alt="img"></a></p>
<p>首先执行<code>objdump -s hello_kern.o</code>得到JIT之前的字节码：</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013174724969-1908539149.png"><img src="1365470-20211013174724969-1908539149.png" alt="img"></a></p>
<p>在一直运行hello </p>
<p>进入linux-source-4.15.0/tools/bpf/bpftool目录，<code>make</code>，生成bpftool工具，</p>
<p>通过 ./bpftool prog show 显示加载了哪些BPF程序：</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013174902027-1666955359.png"><img src="1365470-20211013174902027-1666955359.png" alt="img"></a></p>
<p>可见我们的hello程序对应的id为86，钩子类型为tracepoint</p>
<p>再使用./bpftool prog dump xlated id 86 opcodes 即可查看JIT之后的字节码：</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013175313179-1284218320.png"><img src="1365470-20211013175313179-1284218320.png" alt="img"></a></p>
<p>对比起来看：</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013175553333-2093837334.png"><img src="1365470-20211013175553333-2093837334.png" alt="img"></a></p>
<p>其他的没变，可以看到这个变化，这是因为JIT前call使用的id，JIT后成了调用函数到这个指令的距离</p>
<h3 id="BPF程序到BPF字节码的编译过程：Clang与LLVM"><a href="#BPF程序到BPF字节码的编译过程：Clang与LLVM" class="headerlink" title="BPF程序到BPF字节码的编译过程：Clang与LLVM"></a>BPF程序到BPF字节码的编译过程：Clang与LLVM</h3><p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013184519769-399656865.png"><img src="1365470-20211013184519769-399656865.png" alt="img"></a></p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013184537887-1491314258.png"><img src="1365470-20211013184537887-1491314258.png" alt="img"></a></p>
<p>LLVM支持很多后端，通过命令llc -version</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013184729922-2077708626.png"><img src="1365470-20211013184729922-2077708626.png" alt="img"></a></p>
<p>bpf target有三种，不指定就根据系统的大小端法</p>
<p>有两种方式编译BPF程序：</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013184922942-1226769170.png"><img src="1365470-20211013184922942-1226769170.png" alt="img"></a></p>
<p>gcc缺少BPF backend，幸运的是clang支持BPF. 之前的Makefile就是使用clang将hello_kern.c编译成hello_kern.o</p>
<p>右边的图表示一步到位和分布编译的结果是一样的，而且是之前用Makefile编译的也一样</p>
<p><a href="https://img2020.cnblogs.com/blog/1365470/202110/1365470-20211013190707738-1545406556.png"><img src="1365470-20211013190707738-1545406556.png" alt="img"></a></p>
<p>分步编译是生成中间IR文件，默认是.ll格式</p>
<h1 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h1><h2 id="Hello-World，基本框架和开发流程"><a href="#Hello-World，基本框架和开发流程" class="headerlink" title="Hello World，基本框架和开发流程"></a>Hello World，基本框架和开发流程</h2><h3 id="eBPF开发环境准备与基本开发流程"><a href="#eBPF开发环境准备与基本开发流程" class="headerlink" title="eBPF开发环境准备与基本开发流程"></a>eBPF开发环境准备与基本开发流程</h3><p>在开始编写eBPF程序之前，我们需要准备一个合适的开发环境，并了解eBPF程序的基本开发流程。本部分将详细介绍这些内容。</p>
<h3 id="安装必要的软件和工具"><a href="#安装必要的软件和工具" class="headerlink" title="安装必要的软件和工具"></a>安装必要的软件和工具</h3><p>要开发eBPF程序，您需要安装以下软件和工具：</p>
<ul>
<li>Linux 内核：由于eBPF是内核技术，因此您需要具备较新版本的Linux内核（推荐4.8及以上版本），以支持eBPF功能。</li>
<li>LLVM 和 Clang：这些工具用于编译eBPF程序。安装最新版本的LLVM和Clang可以确保您获得最佳的eBPF支持。</li>
</ul>
<p>eBPF 程序主要由两部分构成：内核态部分和用户态部分。内核态部分包含 eBPF 程序的实际逻辑，用户态部分负责加载、运行和监控内核态程序。当您选择了合适的开发框架后，如 BCC（BPF Compiler Collection）、libbpf、cilium/ebpf或eunomia-bpf等，您可以开始进行用户态和内核态程序的开发。以 BCC 工具为例，我们将介绍 eBPF 程序的基本开发流程：</p>
<p>当您选择了合适的开发框架后，如BCC（BPF Compiler Collection）、libbpf、cilium/ebpf或eunomia-bpf等，您可以开始进行用户态和内核态程序的开发。以BCC工具为例，我们将介绍eBPF程序的基本开发流程：</p>
<ul>
<li>安装BCC工具：根据您的Linux发行版，按照BCC官方文档的指南安装BCC工具和相关依赖。<br>编写eBPF程序（C语言）：使用C语言编写一个简单的eBPF程序，例如Hello World程序。该程序可以在内核空间执行并完成特定任务，如统计网络数据包数量。</li>
<li>编写用户态程序（Python或C等）：使用Python、C等语言编写用户态程序，用于加载、运行eBPF程序以及与之交互。在这个程序中，您需要使用BCC提供的API来加载和操作内核态的eBPF程序。</li>
<li>编译eBPF程序：使用BCC工具，将C语言编写的eBPF程序编译成内核可以执行的字节码。BCC会在运行时动态从源码编译eBPF程序。</li>
<li>加载并运行eBPF程序：在用户态程序中，使用BCC提供的API加载编译好的eBPF程序到内核空间，然后运行该程序。</li>
<li>与eBPF程序交互：用户态程序通过BCC提供的API与eBPF程序交互，实现数据收集、分析和展示等功能。例如，您可以使用BCC API读取eBPF程序中的map数据，以获取网络数据包统计信息。</li>
<li>卸载eBPF程序：当不再需要eBPF程序时，用户态程序应使用BCC API将其从内核空间卸载。</li>
<li>调试与优化：使用 bpftool 等工具进行eBPF程序的调试和优化，提高程序性能和稳定性。</li>
</ul>
<p>通过以上流程，您可以使用BCC工具开发、编译、运行和调试eBPF程序。请注意，其他框架（如libbpf、cilium/ebpf和eunomia-bpf）的开发流程大致相似但略有不同，因此在选择框架时，请参考相应的官方文档和示例。</p>
<p>通过这个过程，你可以开发出一个能够在内核中运行的 eBPF 程序。eunomia-bpf 是一个开源的 eBPF 动态加载运行时和开发工具链，它的目的是简化 eBPF 程序的开发、构建、分发、运行。它基于 libbpf 的 CO-RE 轻量级开发框架，支持通过用户态 WASM 虚拟机控制 eBPF 程序的加载和执行，并将预编译的 eBPF 程序打包为通用的 JSON 或 WASM 模块进行分发。我们会使用 eunomia-bpf 进行演示。</p>
<h3 id="下载安装-eunomia-bpf-开发工具"><a href="#下载安装-eunomia-bpf-开发工具" class="headerlink" title="下载安装 eunomia-bpf 开发工具"></a>下载安装 eunomia-bpf 开发工具</h3><p>可以通过以下步骤下载和安装 eunomia-bpf：</p>
<p>下载 ecli 工具，用于运行 eBPF 程序：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; <span class="built_in">chmod</span> +x ./ecli</span><br><span class="line">$ ./ecli -h</span><br><span class="line">Usage: ecli [--<span class="built_in">help</span>] [--version] [--json] [--no-cache] url-and-args</span><br></pre></td></tr></table></figure></p>
<p>下载编译器工具链，用于将 eBPF 内核代码编译为 config 文件或 WASM 模块：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecc &amp;&amp; <span class="built_in">chmod</span> +x ./ecc</span><br><span class="line">$ ./ecc -h</span><br><span class="line">eunomia-bpf compiler</span><br><span class="line">Usage: ecc [OPTIONS] &lt;SOURCE_PATH&gt; [EXPORT_EVENT_HEADER]</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>
<p>也可以使用 docker 镜像进行编译：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -v `<span class="built_in">pwd</span>`/:/src/ ghcr.io/eunomia-bpf/ecc-`<span class="built_in">uname</span> -m`:latest <span class="comment"># 使用 docker 进行编译。`pwd` 应该包含 *.bpf.c 文件和 *.h 文件。</span></span><br><span class="line"><span class="built_in">export</span> PATH=PATH:~/.eunomia/bin</span><br><span class="line">Compiling bpf object...</span><br><span class="line">Packing ebpf object and config into /src/package.json...</span><br></pre></td></tr></table></figure></p>
<h3 id="Hello-World-minimal-eBPF-program"><a href="#Hello-World-minimal-eBPF-program" class="headerlink" title="Hello World - minimal eBPF program"></a>Hello World - minimal eBPF program</h3><p>我们会先从一个简单的 eBPF 程序开始，它会在内核中打印一条消息。我们会使用 eunomia-bpf 的编译器工具链将其编译为 bpf 字节码文件，然后使用 ecli 工具加载并运行该程序。作为示例，我们可以暂时省略用户态程序的部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_NO_GLOBAL_DATA</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u32;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">pid_t</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">pid_t</span> pid_filter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual BSD/GPL&quot;</span>;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tp/syscalls/sys_enter_write&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_tp</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line"> <span class="keyword">if</span> (pid_filter &amp;&amp; pid != pid_filter)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> bpf_printk(<span class="string">&quot;BPF triggered from PID %d.\n&quot;</span>, pid);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序通过定义一个 handle_tp 函数并使用 SEC 宏把它附加到<code>sys_enter_write tracepoint</code>（即在进入 write 系统调用时执行）。该函数通过使用<code>bpf_get_current_pid_tgid</code>和<code>bpf_printk</code>函数获取调用 write 系统调用的进程 ID，并在内核日志中打印出来。</p>
<p><code>bpf_trace_printk()</code>： 一种将信息输出到<code>trace_pipe</code>(/sys/kernel/debug/tracing/trace_pipe)简单机制。 在一些简单用例中这样使用没有问题， but它也有一些限制：最多3 参数； 第一个参数必须是%s(即字符串)；同时trace_pipe在内核中全局共享，其他并行使用trace_pipe的程序有可能会将 trace_pipe 的输出扰乱。 一个更好的方式是通过<code>BPF_PERF_OUTPUT()</code>, 稍后将会讲到。</p>
<p><code>void *ctx</code>：ctx本来是具体类型的参数， 但是由于我们这里没有使用这个参数，因此就将其写成<code>void *</code>类型。<br><code>return 0;</code>必须这样，返回0。</p>
<p>要编译和运行这段程序，可以使用 ecc 工具和 ecli 命令。首先在 Ubuntu/Debian 上，执行以下命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install clang llvm</span><br></pre></td></tr></table></figure></p>
<p>ecc 编译程序：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./ecc minimal.bpf.c</span><br><span class="line">Compiling bpf object...</span><br><span class="line">Packing ebpf object and config into package.json...</span><br></pre></td></tr></table></figure></p>
<p>或使用 docker 镜像进行编译：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v `<span class="built_in">pwd</span>`/:/src/ ghcr.io/eunomia-bpf/ecc-`<span class="built_in">uname</span> -m`:latest</span><br></pre></td></tr></table></figure></p>
<p>然后使用 ecli 运行编译后的程序：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ecli run package.json</span><br><span class="line">Runing eBPF program...</span><br></pre></td></tr></table></figure></p>
<p>运行这段程序后，可以通过查看<code>/sys/kernel/debug/tracing/trace_pipe</code>文件来查看 eBPF 程序的输出：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">cat</span> /sys/kernel/debug/tracing/trace_pipe | grep <span class="string">&quot;BPF triggered sys_enter_write&quot;</span></span><br><span class="line">           &lt;...&gt;-3840345 [010] d... 3220701.101143: bpf_trace_printk: write system call from PID 3840345.</span><br><span class="line">           &lt;...&gt;-3840345 [010] d... 3220701.101143: bpf_trace_printk: write system call from PID 3840345.</span><br></pre></td></tr></table></figure></p>
<p>按 Ctrl+C 停止 ecli 进程之后，可以看到对应的输出也停止。</p>
<h3 id="eBPF-程序的基本框架"><a href="#eBPF-程序的基本框架" class="headerlink" title="eBPF 程序的基本框架"></a>eBPF 程序的基本框架</h3><p>如上所述， eBPF 程序的基本框架包括：</p>
<ul>
<li>包含头文件：需要包含 <linux/bpf.h> 和 <bpf/bpf_helpers.h> 等头文件。</li>
<li>定义许可证：需要定义许可证，通常使用 “Dual BSD/GPL”。</li>
<li>定义 BPF 函数：需要定义一个 BPF 函数，例如其名称为 handle_tp，其参数为<code>void *ctx</code>，返回值为 int。通常用 C 语言编写。</li>
<li>使用 BPF 助手函数：在例如 BPF 函数中，可以使用 BPF 助手函数<code>bpf_get_current_pid_tgid()</code>和<code>bpf_printk()</code>。</li>
<li>返回值</li>
</ul>
<h3 id="tracepoints"><a href="#tracepoints" class="headerlink" title="tracepoints"></a>tracepoints</h3><p>跟踪点（tracepoints）是内核静态插桩技术，跟踪点在技术上只是放置在内核源代码中的跟踪函数，实际上就是在源码中插入的一些带有控制条件的探测点，这些探测点允许事后再添加处理函数。比如在内核中，最常见的静态跟踪方法就是 printk，即输出日志。又比如：在系统调用、调度程序事件、文件系统操作和磁盘 I/O 的开始和结束时都有跟踪点。 于 2009 年在 Linux 2.6.32 版本中首次提供。跟踪点是一种稳定的 API，数量有限。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>eBPF 程序的开发和使用流程可以概括为如下几个步骤：</p>
<ul>
<li>定义 eBPF 程序的接口和类型：这包括定义 eBPF 程序的接口函数，定义和实现 eBPF 内核映射（maps）和共享内存（perf events），以及定义和使用 eBPF 内核帮助函数（helpers）。</li>
<li>编写 eBPF 程序的代码：这包括编写 eBPF 程序的主要逻辑，实现 eBPF 内核映射的读写操作，以及使用 eBPF 内核帮助函数。</li>
<li>编译 eBPF 程序：这包括使用 eBPF 编译器（例如 clang）将 eBPF 程序代码编译为 eBPF 字节码，并生成可执行的 eBPF 内核模块。ecc 本质上也是调用 clang 编译器来编译 eBPF 程序。</li>
<li>加载 eBPF 程序到内核：这包括将编译好的 eBPF 内核模块加载到 Linux 内核中，并将 eBPF 程序附加到指定的内核事件上。</li>
<li>使用 eBPF 程序：这包括监测 eBPF 程序的运行情况，并使用 eBPF 内核映射和共享内存进行数据交换和共享。</li>
<li>在实际开发中，还可能需要进行其他的步骤，例如配置编译和加载参数，管理 eBPF 内核模块和内核映射，以及使用其他高级功能等。</li>
<li>需要注意的是，BPF 程序的执行是在内核空间进行的，因此需要使用特殊的工具和技术来编写、编译和调试 BPF 程序。eunomia-bpf 是一个开源的 BPF 编译器和工具包，它可以帮助开发者快速和简单地编写和运行 BPF 程序。</li>
</ul>
<h2 id="在-eBPF-中使用-kprobe-监测捕获-unlink-系统调用"><a href="#在-eBPF-中使用-kprobe-监测捕获-unlink-系统调用" class="headerlink" title="在 eBPF 中使用 kprobe 监测捕获 unlink 系统调用"></a>在 eBPF 中使用 kprobe 监测捕获 unlink 系统调用</h2><h3 id="kprobes-技术背景"><a href="#kprobes-技术背景" class="headerlink" title="kprobes 技术背景"></a>kprobes 技术背景</h3><p>开发人员在内核或者模块的调试过程中，往往会需要要知道其中的一些函数有无被调用、何时被调用、执行是否正确以及函数的入参和返回值是什么等等。比较简单的做法是在内核代码对应的函数中添加日志打印信息，但这种方式往往需要重新编译内核或模块，重新启动设备之类的，操作较为复杂甚至可能会破坏原有的代码执行过程。</p>
<p>而利用kprobes技术，用户可以定义自己的回调函数，然后在内核或者模块中几乎所有的函数中动态的插入探测点，当内核执行流程执行到指定的探测函数时，会调用该回调函数，用户即可收集所需的信息了，同时内核最后还会回到原本的正常执行流程。如果用户已经收集足够的信息，不再需要继续探测，则同样可以动态地移除探测点。因此kprobes技术具有对内核执行流程影响小和操作方便的优点。</p>
<p>kprobes技术包括的3种探测手段分别时kprobe、jprobe和kretprobe。首先kprobe是最基本的探测方式，是实现后两种的基础，它可以在任意的位置放置探测点（就连函数内部的某条指令处也可以），它提供了探测点的调用前、调用后和内存访问出错3种回调方式，分别是pre_handler、post_handler和fault_handler，其中pre_handler函数将在被探测指令被执行前回调，post_handler会在被探测指令执行完毕后回调（注意不是被探测函数），fault_handler会在内存访问出错时被调用；jprobe基于kprobe实现，它用于获取被探测函数的入参值；最后kretprobe从名字中就可以看出其用途了，它同样基于kprobe实现，用于获取被探测函数的返回值。</p>
<p>kprobes的技术原理并不仅仅包含存软件的实现方案，它也需要硬件架构提供支持。其中涉及硬件架构相关的是CPU的异常处理和单步调试技术，前者用于让程序的执行流程陷入到用户注册的回调函数中去，而后者则用于单步执行被探测点指令，因此并不是所有的架构均支持，目前kprobes技术已经支持多种架构，包括i386、x86_64、ppc64、ia64、sparc64、arm、ppc和mips（有些架构实现可能并不完全，具体可参考内核的Documentation/kprobes.txt）。</p>
<p>kprobes的特点与使用限制：</p>
<ol>
<li>kprobes允许在同一个被被探测位置注册多个kprobe，但是目前jprobe却不可以；同时也不允许以其他的jprobe回调函数和kprobe的post_handler回调函数作为被探测点。</li>
<li>一般情况下，可以探测内核中的任何函数，包括中断处理函数。不过在<code>kernel/kprobes.c</code>和<code>arch/*/kernel/kprobes.c</code>程序中用于实现kprobes自身的函数是不允许被探测的，另外还有<code>do_page_fault</code>和<code>notifier_call_chain</code>；</li>
<li>如果以一个内联函数为探测点，则kprobes可能无法保证对该函数的所有实例都注册探测点。由于gcc可能会自动将某些函数优化为内联函数，因此可能无法达到用户预期的探测效果；</li>
<li>一个探测点的回调函数可能会修改被探测函数运行的上下文，例如通过修改内核的数据结构或者保存与<code>struct pt_regs</code>结构体中的触发探测器之前寄存器信息。因此kprobes可以被用来安装bug修复代码或者注入故障测试代码；</li>
<li>kprobes会避免在处理探测点函数时再次调用另一个探测点的回调函数，例如在printk()函数上注册了探测点，则在它的回调函数中可能再次调用printk函数，此时将不再触发printk探测点的回调，仅仅时增加了kprobe结构体中nmissed字段的数值；</li>
<li>在kprobes的注册和注销过程中不会使用mutex锁和动态的申请内存；</li>
<li>kprobes回调函数的运行期间是关闭内核抢占的，同时也可能在关闭中断的情况下执行，具体要视CPU架构而定。因此不论在何种情况下，在回调函数中不要调用会放弃CPU的函数（如信号量、mutex锁等）；</li>
<li>kretprobe通过替换返回地址为预定义的trampoline的地址来实现，因此栈回溯和gcc内嵌函数<code>__builtin_return_address()</code>调用将返回trampoline的地址而不是真正的被探测函数的返回地址；</li>
<li>如果一个函数的调用次数和返回次数不相等，则在类似这样的函数上注册kretprobe将可能不会达到预期的效果，例如do_exit()函数会存在问题，而do_execve()函数和do_fork()函数不会；</li>
<li>如果当在进入和退出一个函数时，CPU运行在非当前任务所有的栈上，那么往该函数上注册kretprobe可能会导致不可预料的后果，因此，kprobes不支持在X86_64的结构下为<code>__switch_to()</code>函数注册kretprobe，将直接返回-EINVAL。</li>
</ol>
<h3 id="kprobe-示例"><a href="#kprobe-示例" class="headerlink" title="kprobe 示例"></a>kprobe 示例</h3><p>完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmlinux.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_core_read.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual BSD/GPL&quot;</span>;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;kprobe/do_unlinkat&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_KPROBE</span><span class="params">(do_unlinkat, <span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *filename;</span><br><span class="line"></span><br><span class="line"> pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line"> filename = BPF_CORE_READ(name, name);</span><br><span class="line"> bpf_printk(<span class="string">&quot;KPROBE ENTRY pid = %d, filename = %s\n&quot;</span>, pid, filename);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;kretprobe/do_unlinkat&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_KRETPROBE</span><span class="params">(do_unlinkat_exit, <span class="type">long</span> ret)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"> pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line"> bpf_printk(<span class="string">&quot;KPROBE EXIT: pid = %d, ret = %ld\n&quot;</span>, pid, ret);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是一个简单的 eBPF 程序，用于监测和捕获在 Linux 内核中执行的 unlink 系统调用。unlink 系统调用的功能是删除一个文件，这个 eBPF 程序通过使用 kprobe（内核探针）在<code>do_unlinkat</code>函数的入口和退出处放置钩子，实现对该系统调用的跟踪。</p>
<p>首先，我们导入必要的头文件，如 vmlinux.h，bpf_helpers.h，bpf_tracing.h 和 bpf_core_read.h。接着，我们定义许可证，以允许程序在内核中运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmlinux.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_core_read.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual BSD/GPL&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>接下来，我们定义一个名为<code>BPF_KPROBE(do_unlinkat)</code>的 kprobe，当进入 do_unlinkat 函数时，它会被触发。该函数接受两个参数：dfd（文件描述符）和 name（文件名结构体指针）。在这个 kprobe 中，我们获取当前进程的 PID（进程标识符），然后读取文件名。最后，我们使用 bpf_printk 函数在内核日志中打印 PID 和文件名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;kprobe/do_unlinkat&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_KPROBE</span><span class="params">(do_unlinkat, <span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid;</span><br><span class="line"> <span class="type">const</span> <span class="type">char</span> *filename;</span><br><span class="line"></span><br><span class="line"> pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line"> filename = BPF_CORE_READ(name, name);</span><br><span class="line"> bpf_printk(<span class="string">&quot;KPROBE ENTRY pid = %d, filename = %s\n&quot;</span>, pid, filename);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们定义一个名为<code>BPF_KRETPROBE(do_unlinkat_exit)</code>的 kretprobe，当从 do_unlinkat 函数退出时，它会被触发。这个 kretprobe 的目的是捕获函数的返回值（ret）。我们再次获取当前进程的 PID，并使用 bpf_printk 函数在内核日志中打印 PID 和返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SEC(&quot;kretprobe/do_unlinkat&quot;)</span><br><span class="line">int BPF_KRETPROBE(do_unlinkat_exit, long ret)</span><br><span class="line">&#123;</span><br><span class="line"> pid_t pid;</span><br><span class="line"></span><br><span class="line"> pid = bpf_get_current_pid_tgid() &gt;&gt; 32;</span><br><span class="line"> bpf_printk(&quot;KPROBE EXIT: pid = %d, ret = %ld\n&quot;, pid, ret);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eunomia-bpf 是一个结合 Wasm 的开源 eBPF 动态加载运行时和开发工具链，它的目的是简化 eBPF 程序的开发、构建、分发、运行。可以参考 <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Feunomia-bpf%2Feunomia-bpf">https://github.com/eunomia-bpf/eunomia-bpf</a> 下载和安装 ecc 编译工具链和 ecli 运行时。</p>
<p>要编译这个程序，请使用 ecc 工具：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ecc kprobe-link.bpf.c</span><br><span class="line">Compiling bpf object...</span><br><span class="line">Packing ebpf object and config into package.json...</span><br></pre></td></tr></table></figure>
<p>然后运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ecli run package.json</span><br></pre></td></tr></table></figure>
<p>在另外一个窗口中：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> test1</span><br><span class="line"><span class="built_in">rm</span> test1</span><br><span class="line"><span class="built_in">touch</span> test2</span><br><span class="line"><span class="built_in">rm</span> test2</span><br></pre></td></tr></table></figure>
<p>在 /sys/kernel/debug/tracing/trace_pipe 文件中，应该能看到类似下面的 kprobe 演示输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">cat</span> /sys/kernel/debug/tracing/trace_pipe</span><br><span class="line">              rm-9346    [005] d..3  4710.951696: bpf_trace_printk: KPROBE ENTRY pid = 9346, filename = test1</span><br><span class="line">              rm-9346    [005] d..4  4710.951819: bpf_trace_printk: KPROBE EXIT: ret = 0</span><br><span class="line">              rm-9346    [005] d..3  4710.951852: bpf_trace_printk: KPROBE ENTRY pid = 9346, filename = test2</span><br><span class="line">              rm-9346    [005] d..4  4710.951895: bpf_trace_printk: KPROBE EXIT: ret = 0</span><br></pre></td></tr></table></figure>
<h2 id="在-eBPF-中使用-fentry-监测捕获-unlink-系统调用"><a href="#在-eBPF-中使用-fentry-监测捕获-unlink-系统调用" class="headerlink" title="在 eBPF 中使用 fentry 监测捕获 unlink 系统调用"></a>在 eBPF 中使用 fentry 监测捕获 unlink 系统调用</h2><h3 id="Fentry"><a href="#Fentry" class="headerlink" title="Fentry"></a>Fentry</h3><p>fentry（function entry）和fexit（function exit）是eBPF（扩展的伯克利包过滤器）中的两种探针类型，用于在Linux内核函数的入口和退出处进行跟踪。它们允许开发者在内核函数执行的特定阶段收集信息、修改参数或观察返回值。这种跟踪和监控功能在性能分析、故障排查和安全分析等场景中非常有用。</p>
<p>与 kprobes 相比，fentry 和 fexit 程序有更高的性能和可用性。在这个例子中，我们可以直接访问函数的指针参数，就像在普通的 C 代码中一样，而不需要使用各种读取帮助程序。fexit 和 kretprobe 程序最大的区别在于，fexit 程序可以访问函数的输入参数和返回值，而 kretprobe 只能访问返回值。从 5.5 内核开始，fentry 和 fexit 对 eBPF 程序可用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmlinux.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual BSD/GPL&quot;</span>;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;fentry/do_unlinkat&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_PROG</span><span class="params">(do_unlinkat, <span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"> pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line"> bpf_printk(<span class="string">&quot;fentry: pid = %d, filename = %s\n&quot;</span>, pid, name-&gt;name);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;fexit/do_unlinkat&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_PROG</span><span class="params">(do_unlinkat_exit, <span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name, <span class="type">long</span> ret)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line"> pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line"> bpf_printk(<span class="string">&quot;fexit: pid = %d, filename = %s, ret = %ld\n&quot;</span>, pid, name-&gt;name, ret);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序是用C语言编写的eBPF（扩展的伯克利包过滤器）程序，它使用BPF的fentry和fexit探针来跟踪Linux内核函数do_unlinkat。在这个教程中，我们将以这段程序作为示例，让您学会如何在eBPF中使用fentry监测捕获unlink系统调用。</p>
<p>程序包含以下部分：</p>
<ul>
<li>包含头文件：包括vmlinux.h（用于访问内核数据结构）、bpf/bpf_helpers.h（包含eBPF帮助函数）、bpf/bpf_tracing.h（用于eBPF跟踪相关功能）。</li>
<li>定义许可证：这里定义了一个名为LICENSE的字符数组，包含许可证信息”Dual BSD/GPL”。</li>
<li>定义fentry探针：我们定义了一个名为<code>BPF_PROG(do_unlinkat)</code>的fentry探针，该探针在do_unlinkat函数的入口处被触发。这个探针获取当前进程的PID（进程ID）并将其与文件名一起打印到内核日志。</li>
<li>定义fexit探针：我们还定义了一个名为<code>BPF_PROG(do_unlinkat_exit)</code>的fexit探针，该探针在do_unlinkat函数的退出处被触发。与fentry探针类似，这个探针也会获取当前进程的PID并将其与文件名和返回值一起打印到内核日志。</li>
</ul>
<p>通过这个示例，您可以学习如何在eBPF中使用fentry和fexit探针来监控和捕获内核函数调用，例如在本教程中的unlink系统调用。</p>
<p>eunomia-bpf 是一个结合 Wasm 的开源 eBPF 动态加载运行时和开发工具链，它的目的是简化 eBPF 程序的开发、构建、分发、运行。可以参考 <a href="https://github.com/eunomia-bpf/eunomia-bpf">https://github.com/eunomia-bpf/eunomia-bpf</a> 下载和安装 ecc 编译工具链和 ecli 运行时。我们使用 eunomia-bpf 编译运行这个例子。</p>
<p>编译运行上述代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ecc fentry-link.bpf.c</span><br><span class="line">Compiling bpf object...</span><br><span class="line">Packing ebpf object and config into package.json...</span><br><span class="line">$ <span class="built_in">sudo</span> ecli run package.json</span><br><span class="line">Runing eBPF program...</span><br></pre></td></tr></table></figure></p>
<p>在另外一个窗口中：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> test_file</span><br><span class="line"><span class="built_in">rm</span> test_file</span><br><span class="line"><span class="built_in">touch</span> test_file2</span><br><span class="line"><span class="built_in">rm</span> test_file2</span><br></pre></td></tr></table></figure></p>
<p>运行这段程序后，可以通过查看<code>/sys/kernel/debug/tracing/trace_pipe</code>文件来查看 eBPF 程序的输出：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">cat</span> /sys/kernel/debug/tracing/trace_pipe</span><br><span class="line">              rm-9290    [004] d..2  4637.798698: bpf_trace_printk: fentry: pid = 9290, filename = test_file</span><br><span class="line">              rm-9290    [004] d..2  4637.798843: bpf_trace_printk: fexit: pid = 9290, filename = test_file, ret = 0</span><br><span class="line">              rm-9290    [004] d..2  4637.798698: bpf_trace_printk: fentry: pid = 9290, filename = test_file2</span><br><span class="line">              rm-9290    [004] d..2  4637.798843: bpf_trace_printk: fexit: pid = 9290, filename = test_file2, ret = 0</span><br></pre></td></tr></table></figure></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这段程序是一个 eBPF 程序，通过使用 fentry 和 fexit 捕获 do_unlinkat 和 do_unlinkat_exit 函数，并通过使用 bpf_get_current_pid_tgid 和 bpf_printk 函数获取调用 do_unlinkat 的进程 ID、文件名和返回值，并在内核日志中打印出来。</p>
<h2 id="在-eBPF-中捕获进程打开文件的系统调用集合，使用全局变量过滤进程-pid"><a href="#在-eBPF-中捕获进程打开文件的系统调用集合，使用全局变量过滤进程-pid" class="headerlink" title="在 eBPF 中捕获进程打开文件的系统调用集合，使用全局变量过滤进程 pid"></a>在 eBPF 中捕获进程打开文件的系统调用集合，使用全局变量过滤进程 pid</h2><p>eBPF（Extended Berkeley Packet Filter）是一种内核执行环境，它可以让用户在内核中运行一些安全的、高效的程序。它通常用于网络过滤、性能分析、安全监控等场景。eBPF 之所以强大，是因为它能够在内核运行时捕获和修改数据包或者系统调用，从而实现对操作系统行为的监控和调整。</p>
<p>本文是 eBPF 入门开发实践教程的第四篇，主要介绍如何捕获进程打开文件的系统调用集合，并使用全局变量在 eBPF 中过滤进程 pid。</p>
<p>在 Linux 系统中，进程与文件之间的交互是通过系统调用来实现的。系统调用是用户态程序与内核态程序之间的接口，它们允许用户态程序请求内核执行特定操作。在本教程中，我们关注的是 sys_openat 系统调用，它是用于打开文件的。</p>
<p>当进程打开一个文件时，它会向内核发出<code>sys_openat</code>系统调用，并传递相关参数（例如文件路径、打开模式等）。内核会处理这个请求，并返回一个文件描述符（file descriptor），这个描述符将在后续的文件操作中用作引用。通过捕获 sys_openat 系统调用，我们可以了解进程在什么时候以及如何打开文件。</p>
<h3 id="在-eBPF-中捕获进程打开文件的系统调用集合"><a href="#在-eBPF-中捕获进程打开文件的系统调用集合" class="headerlink" title="在 eBPF 中捕获进程打开文件的系统调用集合"></a>在 eBPF 中捕获进程打开文件的系统调用集合</h3><p>首先，我们需要编写一段 eBPF 程序来捕获进程打开文件的系统调用，具体实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vmlinux.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @description &quot;Process ID to trace&quot;</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">int</span> pid_target = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_enter_openat&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">tracepoint__syscalls__sys_enter_openat</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sys_enter* ctx)</span></span><br><span class="line">&#123;</span><br><span class="line"> u64 id = bpf_get_current_pid_tgid();</span><br><span class="line"> u32 pid = id;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (pid_target &amp;&amp; pid_target != pid)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">// Use bpf_printk to print the process information</span></span><br><span class="line"> bpf_printk(<span class="string">&quot;Process ID: %d enter sys openat\n&quot;</span>, pid);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// &quot;Trace open family syscalls.&quot;</span></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>这段 eBPF 程序实现了：</p>
<ul>
<li>引入头文件：<vmlinux.h> 包含了内核数据结构的定义，<bpf/bpf_helpers.h> 包含了 eBPF 程序所需的辅助函数。</li>
<li>定义全局变量 pid_target，用于过滤指定进程 ID。这里设为 0 表示捕获所有进程的 sys_openat 调用。</li>
<li>使用 SEC 宏定义一个 eBPF 程序，关联到 tracepoint “tracepoint/syscalls/sys_enter_openat”。这个 tracepoint 会在进程发起 sys_openat 系统调用时触发。</li>
<li>实现 eBPF 程序<code>tracepoint__syscalls__sys_enter_openat</code>，它接收一个类型为<code>struct trace_event_raw_sys_enter</code>的参数 ctx。这个结构体包含了关于系统调用的信息。</li>
<li>使用<code>bpf_get_current_pid_tgid()</code>函数获取当前进程的 PID 和 TGID（线程组 ID）。由于我们只关心 PID，所以将其赋值给 u32 类型的变量 pid。</li>
<li>检查<code>pid_target</code>变量是否与当前进程的 pid 相等。如果 pid_target 不为 0 且与当前进程的 pid 不相等，则返回 false，不对该进程的<code>sys_openat</code>调用进行捕获。</li>
<li>使用<code>bpf_printk()</code>函数打印捕获到的进程 ID 和 sys_openat 调用的相关信息。这些信息将在用户空间通过 BPF 工具查看。</li>
<li>将程序许可证设置为 “GPL”，这是运行 eBPF 程序的必要条件。</li>
</ul>
<p>这个 eBPF 程序可以通过 libbpf 或 eunomia-bpf 等工具加载到内核并执行。它将捕获指定进程（或所有进程）的 sys_openat 系统调用，并在用户空间输出相关信息。</p>
<p>eunomia-bpf 是一个结合 Wasm 的开源 eBPF 动态加载运行时和开发工具链，它的目的是简化 eBPF 程序的开发、构建、分发、运行。可以参考 <a href="https://github.com/eunomia-bpf/eunomia-bpf">https://github.com/eunomia-bpf/eunomia-bpf</a> 下载和安装 ecc 编译工具链和 ecli 运行时。我们使用 eunomia-bpf 编译运行这个例子。</p>
<p>编译运行上述代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ecc opensnoop.bpf.c</span><br><span class="line">Compiling bpf object...</span><br><span class="line">Packing ebpf object and config into package.json...</span><br><span class="line">$ <span class="built_in">sudo</span> ecli run package.json</span><br><span class="line">Runing eBPF program...</span><br></pre></td></tr></table></figure></p>
<p>运行这段程序后，可以通过查看<code>/sys/kernel/debug/tracing/trace_pipe</code>文件来查看 eBPF 程序的输出：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">cat</span> /sys/kernel/debug/tracing/trace_pipe</span><br><span class="line">           &lt;...&gt;-3840345 [010] d... 3220701.101179: bpf_trace_printk: Process ID: 3840345 enter sys openat</span><br><span class="line">           &lt;...&gt;-3840345 [010] d... 3220702.158000: bpf_trace_printk: Process ID: 3840345 enter sys openat</span><br></pre></td></tr></table></figure></p>
<p>此时，我们已经能够捕获进程打开文件的系统调用了。</p>
<h3 id="使用全局变量在-eBPF-中过滤进程-pid"><a href="#使用全局变量在-eBPF-中过滤进程-pid" class="headerlink" title="使用全局变量在 eBPF 中过滤进程 pid"></a>使用全局变量在 eBPF 中过滤进程 pid</h3><p>全局变量在 eBPF 程序中充当一种数据共享机制，它们允许用户态程序与 eBPF 程序之间进行数据交互。这在过滤特定条件或修改 eBPF 程序行为时非常有用。这种设计使得用户态程序能够在运行时动态地控制 eBPF 程序的行为。</p>
<p>在我们的例子中，全局变量 pid_target 用于过滤进程 PID。用户态程序可以设置此变量的值，以便在 eBPF 程序中只捕获与指定 PID 相关的 sys_openat 系统调用。</p>
<p>使用全局变量的原理是，全局变量在 eBPF 程序的数据段（data section）中定义并存储。当 eBPF 程序加载到内核并执行时，这些全局变量会保持在内核中，可以通过 BPF 系统调用进行访问。用户态程序可以使用 BPF 系统调用中的某些特性，如<code>bpf_obj_get_info_by_fd</code>和<code>bpf_obj_get_info</code>，获取 eBPF 对象的信息，包括全局变量的位置和值。</p>
<p>可以通过执行 ecli -h 命令来查看 opensnoop 的帮助信息：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ecli package.json -h</span><br><span class="line">Usage: opensnoop_bpf [--<span class="built_in">help</span>] [--version] [--verbose] [--pid_target VAR]</span><br><span class="line"></span><br><span class="line">Trace open family syscalls.</span><br><span class="line"></span><br><span class="line">Optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>    shows <span class="built_in">help</span> message and exits </span><br><span class="line">  -v, --version prints version information and exits </span><br><span class="line">  --verbose     prints libbpf debug information </span><br><span class="line">  --pid_target  Process ID to trace </span><br><span class="line"></span><br><span class="line">Built with eunomia-bpf framework.</span><br><span class="line">See https://github.com/eunomia-bpf/eunomia-bpf <span class="keyword">for</span> more information.</span><br></pre></td></tr></table></figure></p>
<p>可以通过<code>--pid_target</code>参数来指定要捕获的进程的 pid，例如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ./ecli run package.json  --pid_target 618</span><br><span class="line">Runing eBPF program...</span><br></pre></td></tr></table></figure></p>
<p>运行这段程序后，可以通过查看<code>/sys/kernel/debug/tracing/trace_pipe</code>文件来查看 eBPF 程序的输出：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">cat</span> /sys/kernel/debug/tracing/trace_pipe</span><br><span class="line">           &lt;...&gt;-3840345 [010] d... 3220701.101179: bpf_trace_printk: Process ID: 618 enter sys openat</span><br><span class="line">           &lt;...&gt;-3840345 [010] d... 3220702.158000: bpf_trace_printk: Process ID: 618 enter sys openat</span><br></pre></td></tr></table></figure></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了如何使用 eBPF 程序来捕获进程打开文件的系统调用。在 eBPF 程序中，我们可以通过定义<code>tracepoint__syscalls__sys_enter_open</code>和<code>tracepoint__syscalls__sys_enter_openat</code>函数并使用 SEC 宏把它们附加到<code>sys_enter_open</code>和<code>sys_enter_openat</code>两个 tracepoint 来捕获进程打开文件的系统调用。我们可以使用<code>bpf_get_current_pid_tgid</code>函数获取调用 open 或 openat 系统调用的进程 ID，并使用 bpf_printk 函数在内核日志中打印出来。在 eBPF 程序中，我们还可以通过定义一个全局变量 pid_target 来指定要捕获的进程的 pid，从而过滤输出，只输出指定的进程的信息。</p>
<p>通过学习本教程，您应该对如何在 eBPF 中捕获和过滤特定进程的系统调用有了更深入的了解。这种方法在系统监控、性能分析和安全审计等场景中具有广泛的应用。</p>
<h2 id="在-eBPF-中使用-uprobe-捕获-bash-的-readline-函数调用"><a href="#在-eBPF-中使用-uprobe-捕获-bash-的-readline-函数调用" class="headerlink" title="在 eBPF 中使用 uprobe 捕获 bash 的 readline 函数调用"></a>在 eBPF 中使用 uprobe 捕获 bash 的 readline 函数调用</h2><p>本文是 eBPF 入门开发实践教程的第五篇，主要介绍如何使用 uprobe 捕获 bash 的 readline 函数调用。</p>
<h3 id="什么是uprobe"><a href="#什么是uprobe" class="headerlink" title="什么是uprobe"></a>什么是uprobe</h3><p>uprobe是一种用户空间探针，uprobe探针允许在用户空间程序中动态插桩，插桩位置包括：函数入口、特定偏移处，以及函数返回处。当我们定义uprobe时，内核会在附加的指令上创建快速断点指令（x86机器上为int3指令），当程序执行到该指令时，内核将触发事件，程序陷入到内核态，并以回调函数的方式调用探针函数，执行完探针函数再返回到用户态继续执行后序的指令。</p>
<p>uprobe基于文件，当一个二进制文件中的一个函数被跟踪时，所有使用到这个文件的进程都会被插桩，包括那些尚未启动的进程，这样就可以在全系统范围内跟踪系统调用。</p>
<p>uprobe适用于在用户态去解析一些内核态探针无法解析的流量，例如http2流量（报文header被编码，内核无法解码），https流量（加密流量，内核无法解密）。</p>
<h3 id="使用-uprobe-捕获-bash-的-readline-函数调用"><a href="#使用-uprobe-捕获-bash-的-readline-函数调用" class="headerlink" title="使用 uprobe 捕获 bash 的 readline 函数调用"></a>使用 uprobe 捕获 bash 的 readline 函数调用</h3><p>uprobe 是一种用于捕获用户空间函数调用的 eBPF 的探针，我们可以通过它来捕获用户空间程序调用的系统函数。</p>
<p>例如，我们可以使用 uprobe 来捕获 bash 的 readline 函数调用，从而获取用户在 bash 中输入的命令行。示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vmlinux.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_COMM_LEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LINE_SIZE 80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Format of u[ret]probe section definition supporting auto-attach:</span></span><br><span class="line"><span class="comment"> * u[ret]probe/binary:function[+offset]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * binary can be an absolute/relative path or a filename; the latter is resolved to a</span></span><br><span class="line"><span class="comment"> * full binary path via bpf_program__attach_uprobe_opts.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Specifying uprobe+ ensures we carry out strict matching; either &quot;uprobe&quot; must be</span></span><br><span class="line"><span class="comment"> * specified (and auto-attach is not possible) or the above format is specified for</span></span><br><span class="line"><span class="comment"> * auto-attach.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SEC(<span class="string">&quot;uretprobe//bin/bash:readline&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_KRETPROBE</span><span class="params">(printret, <span class="type">const</span> <span class="type">void</span> *ret)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> str[MAX_LINE_SIZE];</span><br><span class="line"> <span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line"> u32 pid;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!ret)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> bpf_get_current_comm(&amp;comm, <span class="keyword">sizeof</span>(comm));</span><br><span class="line"></span><br><span class="line"> pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line"> bpf_probe_read_user_str(str, <span class="keyword">sizeof</span>(str), ret);</span><br><span class="line"></span><br><span class="line"> bpf_printk(<span class="string">&quot;PID %d (%s) read: %s &quot;</span>, pid, comm, str);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这段代码的作用是在 bash 的 readline 函数返回时执行指定的<code>BPF_KRETPROBE</code>函数，即 printret 函数。</p>
<p>在 printret 函数中，我们首先获取了调用 readline 函数的进程的进程名称和进程 ID，然后通过 <code>bpf_probe_read_user_str</code>函数读取了用户输入的命令行字符串，最后通过 bpf_printk 函数打印出进程 ID、进程名称和输入的命令行字符串。</p>
<p>除此之外，我们还需要通过 SEC 宏来定义 uprobe 探针，并使用 BPF_KRETPROBE 宏来定义探针函数。</p>
<p>在 SEC 宏中，我们需要指定 uprobe 的类型、要捕获的二进制文件的路径和要捕获的函数名称。例如，上面的代码中的 SEC 宏的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;uprobe//bin/bash:readline&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这表示我们要捕获的是 /bin/bash 二进制文件中的 readline 函数。</p>
<p>接下来，我们需要使用 <code>BPF_KRETPROBE</code> 宏来定义探针函数，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BPF_KRETPROBE(printret, <span class="type">const</span> <span class="type">void</span> *ret)</span><br></pre></td></tr></table></figure>
<p>这里的 printret 是探针函数的名称，<code>const void *ret</code>是探针函数的参数，它代表被捕获的函数的返回值。</p>
<p>然后，我们使用了<code>bpf_get_current_comm</code>函数获取当前任务的名称，并将其存储在 comm 数组中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpf_get_current_comm(&amp;comm, <span class="keyword">sizeof</span>(comm));</span><br></pre></td></tr></table></figure>
<p>使用 <code>bpf_get_current_pid_tgid</code> 函数获取当前进程的 PID，并将其存储在 pid 变量中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br></pre></td></tr></table></figure>
<p>使用<code>bpf_probe_read_user_str</code>函数从用户空间读取 readline 函数的返回值，并将其存储在 str 数组中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpf_probe_read_user_str(str, <span class="keyword">sizeof</span>(str), ret);</span><br></pre></td></tr></table></figure>
<p>最后使用 bpf_printk 函数输出 PID、任务名称和用户输入的字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpf_printk(<span class="string">&quot;PID %d (%s) read: %s &quot;</span>, pid, comm, str);</span><br></pre></td></tr></table></figure>
<p>eunomia-bpf 是一个结合 Wasm 的开源 eBPF 动态加载运行时和开发工具链，它的目的是简化 eBPF 程序的开发、构建、分发、运行。可以参考 <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Feunomia-bpf%2Feunomia-bpf">https://github.com/eunomia-bpf/eunomia-bpf</a> 下载和安装 ecc 编译工具链和 ecli 运行时。我们使用 eunomia-bpf 编译运行这个例子。</p>
<p>编译运行上述代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ecc bashreadline.bpf.c</span><br><span class="line">Compiling bpf object...</span><br><span class="line">Packing ebpf object and config into package.json...</span><br><span class="line">$ <span class="built_in">sudo</span> ecli run package.json</span><br><span class="line">Runing eBPF program...</span><br></pre></td></tr></table></figure>
<p>运行这段程序后，可以通过查看 /sys/kernel/debug/tracing/trace_pipe 文件来查看 eBPF 程序的输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">cat</span> /sys/kernel/debug/tracing/trace_pipe</span><br><span class="line">            bash-32969   [000] d..31 64001.375748: bpf_trace_printk: PID 32969 (bash) <span class="built_in">read</span>: fff </span><br><span class="line">            bash-32969   [000] d..31 64002.056951: bpf_trace_printk: PID 32969 (bash) <span class="built_in">read</span>: fff</span><br></pre></td></tr></table></figure>
<p>可以看到，我们成功的捕获了 bash 的 readline 函数调用，并获取了用户在 bash 中输入的命令行。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>在上述代码中，我们使用了 SEC 宏来定义了一个 uprobe 探针，它指定了要捕获的用户空间程序 (bin/bash) 和要捕获的函数 (readline)。此外，我们还使用了 <code>BPF_KRETPROBE</code> 宏来定义了一个用于处理 readline 函数返回值的回调函数 (printret)。该函数可以获取到 readline 函数的返回值，并将其打印到内核日志中。通过这样的方式，我们就可以使用 eBPF 来捕获 bash 的 readline 函数调用，并获取用户在 bash 中输入的命令行。</p>
<h2 id="捕获进程发送信号的系统调用集合，使用-hash-map-保存状态"><a href="#捕获进程发送信号的系统调用集合，使用-hash-map-保存状态" class="headerlink" title="捕获进程发送信号的系统调用集合，使用 hash map 保存状态"></a>捕获进程发送信号的系统调用集合，使用 hash map 保存状态</h2><p>eBPF (Extended Berkeley Packet Filter) 是 Linux 内核上的一个强大的网络和性能分析工具，它允许开发者在内核运行时动态加载、更新和运行用户定义的代码。</p>
<p>本文是 eBPF 入门开发实践教程的第六篇，主要介绍如何实现一个 eBPF 工具，捕获进程发送信号的系统调用集合，使用 hash map 保存状态。</p>
<p>sigsnoop<br>示例代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vmlinux.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ENTRIES 10240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_COMM_LEN 16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> &#123;</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> pid;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> tpid;</span><br><span class="line"> <span class="type">int</span> sig;</span><br><span class="line"> <span class="type">int</span> ret;</span><br><span class="line"> <span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line"> __uint(max_entries, MAX_ENTRIES);</span><br><span class="line"> __type(key, __u32);</span><br><span class="line"> __type(value, <span class="keyword">struct</span> event);</span><br><span class="line">&#125; values <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">probe_entry</span><span class="params">(<span class="type">pid_t</span> tpid, <span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">event</span> =</span> &#123;&#125;;</span><br><span class="line"> __u64 pid_tgid;</span><br><span class="line"> __u32 tid;</span><br><span class="line"></span><br><span class="line"> pid_tgid = bpf_get_current_pid_tgid();</span><br><span class="line"> tid = (__u32)pid_tgid;</span><br><span class="line"> event.pid = pid_tgid &gt;&gt; <span class="number">32</span>;</span><br><span class="line"> event.tpid = tpid;</span><br><span class="line"> event.sig = sig;</span><br><span class="line"> bpf_get_current_comm(event.comm, <span class="keyword">sizeof</span>(event.comm));</span><br><span class="line"> bpf_map_update_elem(&amp;values, &amp;tid, &amp;event, BPF_ANY);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">probe_exit</span><span class="params">(<span class="type">void</span> *ctx, <span class="type">int</span> ret)</span></span><br><span class="line">&#123;</span><br><span class="line"> __u64 pid_tgid = bpf_get_current_pid_tgid();</span><br><span class="line"> __u32 tid = (__u32)pid_tgid;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">eventp</span>;</span></span><br><span class="line"></span><br><span class="line"> eventp = bpf_map_lookup_elem(&amp;values, &amp;tid);</span><br><span class="line"> <span class="keyword">if</span> (!eventp)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> eventp-&gt;ret = ret;</span><br><span class="line"> bpf_printk(<span class="string">&quot;PID %d (%s) sent signal %d to PID %d, ret = %d&quot;</span>,</span><br><span class="line">     eventp-&gt;pid, eventp-&gt;comm, eventp-&gt;sig, eventp-&gt;tpid, ret);</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line"> bpf_map_delete_elem(&amp;values, &amp;tid);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_enter_kill&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">kill_entry</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sys_enter *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">pid_t</span> tpid = (<span class="type">pid_t</span>)ctx-&gt;args[<span class="number">0</span>];</span><br><span class="line"> <span class="type">int</span> sig = (<span class="type">int</span>)ctx-&gt;args[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> probe_entry(tpid, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_exit_kill&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">kill_exit</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sys_exit *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> probe_exit(ctx, ctx-&gt;ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual BSD/GPL&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码定义了一个 eBPF 程序，用于捕获进程发送信号的系统调用，包括 kill、tkill 和 tgkill。它通过使用 tracepoint 来捕获系统调用的进入和退出事件，并在这些事件发生时执行指定的探针函数，例如 probe_entry 和 probe_exit。</p>
<p>在探针函数中，我们使用 bpf_map 存储捕获的事件信息，包括发送信号的进程 ID、接收信号的进程 ID、信号值和系统调用的返回值。在系统调用退出时，我们将获取存储在 bpf_map 中的事件信息，并使用 bpf_printk 打印进程 ID、进程名称、发送的信号和系统调用的返回值。</p>
<p>最后，我们还需要使用 SEC 宏来定义探针，并指定要捕获的系统调用的名称，以及要执行的探针函数。</p>
<p>我们使用 eunomia-bpf 编译运行这个例子。编译运行上述代码：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v `<span class="built_in">pwd</span>`/:/src/ ghcr.io/eunomia-bpf/ecc-`<span class="built_in">uname</span> -m`:latest</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ecc sigsnoop.bpf.c</span><br><span class="line">Compiling bpf object...</span><br><span class="line">Generating <span class="built_in">export</span> types...</span><br><span class="line">Packing ebpf object and config into package.json...</span><br><span class="line">$ <span class="built_in">sudo</span> ecli run package.json</span><br><span class="line">Runing eBPF program...</span><br></pre></td></tr></table></figure></p>
<p>运行这段程序后，可以通过查看<code>/sys/kernel/debug/tracing/trace_pipe</code>文件来查看 eBPF 程序的输出：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">cat</span> /sys/kernel/debug/tracing/trace_pipe</span><br><span class="line">            node-3517    [003] d..31 82575.798191: bpf_trace_printk: PID 3517 (node) sent signal 0 to PID 3427, ret = 0</span><br><span class="line">            node-15194   [003] d..31 82575.849227: bpf_trace_printk: PID 15194 (node) sent signal 0 to PID 3427, ret = 0</span><br><span class="line">            node-30016   [003] d..31 82576.001361: bpf_trace_printk: PID 30016 (node) sent signal 0 to PID 3427, ret = 0</span><br><span class="line">    cpptools-srv-38617   [002] d..31 82576.461085: bpf_trace_printk: PID 38617 (cpptools-srv) sent signal 0 to PID 30496, ret = 0</span><br><span class="line">            node-30040   [002] d..31 82576.467720: bpf_trace_printk: PID 30016 (node) sent signal 0 to PID 3427, ret = 0</span><br></pre></td></tr></table></figure></p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>本文主要介绍如何实现一个 eBPF 工具，捕获进程发送信号的系统调用集合，使用 hash map 保存状态。使用 hash map 需要定义一个结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line"> __uint(max_entries, MAX_ENTRIES);</span><br><span class="line"> __type(key, __u32);</span><br><span class="line"> __type(value, <span class="keyword">struct</span> event);</span><br><span class="line">&#125; values <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>并使用一些对应的 API 进行访问，例如<code>bpf_map_lookup_elem</code>、<code>bpf_map_update_elem</code>、<code>bpf_map_delete_elem</code>等。</p>
<h2 id="捕获进程执行-退出时间，通过-perf-event-array-向用户态打印输出"><a href="#捕获进程执行-退出时间，通过-perf-event-array-向用户态打印输出" class="headerlink" title="捕获进程执行/退出时间，通过 perf event array 向用户态打印输出"></a>捕获进程执行/退出时间，通过 perf event array 向用户态打印输出</h2><p>eBPF (Extended Berkeley Packet Filter) 是 Linux 内核上的一个强大的网络和性能分析工具，它允许开发者在内核运行时动态加载、更新和运行用户定义的代码。</p>
<p>本文是 eBPF 入门开发实践教程的第七篇，主要介绍如何捕获 Linux 内核中进程执行的事件，并且通过 perf event array 向用户态命令行打印输出，不需要再通过查看 /sys/kernel/debug/tracing/trace_pipe 文件来查看 eBPF 程序的输出。通过 perf event array 向用户态发送信息之后，可以进行复杂的数据处理和分析。</p>
<h3 id="perf-buffer"><a href="#perf-buffer" class="headerlink" title="perf buffer"></a>perf buffer</h3><p>eBPF 提供了两个环形缓冲区，可以用来将信息从 eBPF 程序传输到用户区控制器。第一个是perf环形缓冲区，，它至少从内核v4.15开始就存在了。第二个是后来引入的 BPF 环形缓冲区。本文只考虑perf环形缓冲区。</p>
<h3 id="execsnoop"><a href="#execsnoop" class="headerlink" title="execsnoop"></a>execsnoop</h3><p>通过 perf event array 向用户态命令行打印输出，需要编写一个头文件，一个 C 源文件。示例代码如下：</p>
<p>头文件：execsnoop.h<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __EXECSNOOP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __EXECSNOOP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_COMM_LEN 16</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> &#123;</span></span><br><span class="line"> <span class="type">int</span> pid;</span><br><span class="line"> <span class="type">int</span> ppid;</span><br><span class="line"> <span class="type">int</span> uid;</span><br><span class="line"> <span class="type">int</span> retval;</span><br><span class="line"> <span class="type">bool</span> is_exit;</span><br><span class="line"> <span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __EXECSNOOP_H */</span></span></span><br></pre></td></tr></table></figure></p>
<p>源文件：execsnoop.bpf.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vmlinux.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_core_read.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;execsnoop.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);</span><br><span class="line"> __uint(key_size, <span class="keyword">sizeof</span>(u32));</span><br><span class="line"> __uint(value_size, <span class="keyword">sizeof</span>(u32));</span><br><span class="line">&#125; events <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tracepoint/syscalls/sys_enter_execve&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">tracepoint__syscalls__sys_enter_execve</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sys_enter* ctx)</span></span><br><span class="line">&#123;</span><br><span class="line"> u64 id;</span><br><span class="line"> <span class="type">pid_t</span> pid, tgid;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">event</span>=</span>&#123;<span class="number">0</span>&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="type">uid_t</span> uid = (u32)bpf_get_current_uid_gid();</span><br><span class="line"> id = bpf_get_current_pid_tgid();</span><br><span class="line"> pid = (<span class="type">pid_t</span>)id;</span><br><span class="line"> tgid = id &gt;&gt; <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"> event.pid = tgid;</span><br><span class="line"> event.uid = uid;</span><br><span class="line"> task = (<span class="keyword">struct</span> task_struct*)bpf_get_current_task();</span><br><span class="line"> event.ppid = BPF_CORE_READ(task, real_parent, tgid);</span><br><span class="line"> bpf_get_current_comm(&amp;event.comm, <span class="keyword">sizeof</span>(event.comm));</span><br><span class="line"> bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>这段代码定义了个 eBPF 程序，用于捕获进程执行 execve 系统调用的入口。</p>
<p>在入口程序中，我们首先获取了当前进程的进程 ID 和用户 ID，然后通过 bpf_get_current_task 函数获取了当前进程的 task_struct 结构体，并通过 bpf_probe_read_str 函数读取了进程名称。最后，我们通过 bpf_perf_event_output 函数将进程执行事件输出到 perf buffer。</p>
<p>使用这段代码，我们就可以捕获 Linux 内核中进程执行的事件, 并分析进程的执行情况。</p>
<p>使用容器编译：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v `<span class="built_in">pwd</span>`/:/src/ ghcr.io/eunomia-bpf/ecc-`<span class="built_in">uname</span> -m`:latest</span><br></pre></td></tr></table></figure></p>
<p>或者使用 ecc 编译：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ecc execsnoop.bpf.c execsnoop.h</span><br></pre></td></tr></table></figure></p>
<p>运行<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ./ecli run package.json </span><br><span class="line">TIME     PID     PPID    UID     COMM    </span><br><span class="line">21:28:30  40747  3517    1000    node</span><br><span class="line">21:28:30  40748  40747   1000    sh</span><br><span class="line">21:28:30  40749  3517    1000    node</span><br><span class="line">21:28:30  40750  40749   1000    sh</span><br><span class="line">21:28:30  40751  3517    1000    node</span><br><span class="line">21:28:30  40752  40751   1000    sh</span><br><span class="line">21:28:30  40753  40752   1000    cpuUsage.sh</span><br></pre></td></tr></table></figure></p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了如何捕获 Linux 内核中进程执行的事件，并且通过 perf event array 向用户态命令行打印输出，通过 perf event array 向用户态发送信息之后，可以进行复杂的数据处理和分析。在 libbpf 对应的内核态代码中，定义这样一个结构体和对应的头文件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);</span><br><span class="line"> __uint(key_size, <span class="keyword">sizeof</span>(u32));</span><br><span class="line"> __uint(value_size, <span class="keyword">sizeof</span>(u32));</span><br><span class="line">&#125; events <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>就可以往用户态直接发送信息。</p>
<h2 id="在-eBPF-中使用-exitsnoop-监控进程退出事件，使用-ring-buffer-向用户态打印输出"><a href="#在-eBPF-中使用-exitsnoop-监控进程退出事件，使用-ring-buffer-向用户态打印输出" class="headerlink" title="在 eBPF 中使用 exitsnoop 监控进程退出事件，使用 ring buffer 向用户态打印输出"></a>在 eBPF 中使用 exitsnoop 监控进程退出事件，使用 ring buffer 向用户态打印输出</h2><p>eBPF (Extended Berkeley Packet Filter) 是 Linux 内核上的一个强大的网络和性能分析工具。它允许开发者在内核运行时动态加载、更新和运行用户定义的代码。</p>
<p>本文是 eBPF 入门开发实践教程的第八篇，在 eBPF 中使用 exitsnoop 监控进程退出事件。</p>
<h3 id="ring-buffer"><a href="#ring-buffer" class="headerlink" title="ring buffer"></a>ring buffer</h3><p>现在有一个新的 BPF 数据结构可用，eBPF 环形缓冲区（ring buffer）。它解决了 BPF perf buffer（当今从内核向用户空间发送数据的事实上的标准）的内存效率和事件重排问题，同时达到或超过了它的性能。它既提供了与 perf buffer 兼容以方便迁移，又有新的保留/提交API，具有更好的可用性。另外，合成和真实世界的基准测试表明，在几乎所有的情况下，所以考虑将其作为从BPF程序向用户空间发送数据的默认选择。</p>
<h3 id="eBPF-ringbuf-vs-eBPF-perfbuf"><a href="#eBPF-ringbuf-vs-eBPF-perfbuf" class="headerlink" title="eBPF ringbuf vs eBPF perfbuf"></a>eBPF ringbuf vs eBPF perfbuf</h3><p>只要 BPF 程序需要将收集到的数据发送到用户空间进行后处理和记录，它通常会使用 BPF perf buffer（perfbuf）来实现。Perfbuf 是每个CPU循环缓冲区的集合，它允许在内核和用户空间之间有效地交换数据。它在实践中效果很好，但由于其按CPU设计，它有两个主要的缺点，在实践中被证明是不方便的：内存的低效使用和事件的重新排序。</p>
<p>为了解决这些问题，从Linux 5.8开始，BPF提供了一个新的BPF数据结构（BPF map）。BPF环形缓冲区（ringbuf）。它是一个多生产者、单消费者（MPSC）队列，可以同时在多个CPU上安全共享。</p>
<p>BPF ringbuf 支持来自 BPF perfbuf 的熟悉的功能:</p>
<ul>
<li>变长的数据记录。</li>
<li>能够通过内存映射区域有效地从用户空间读取数据，而不需要额外的内存拷贝和/或进入内核的系统调用。</li>
<li>既支持epoll通知，又能以绝对最小的延迟进行忙环操作。</li>
</ul>
<p>同时，BPF ringbuf解决了BPF perfbuf的以下问题:</p>
<ul>
<li>内存开销。</li>
<li>数据排序。</li>
<li>浪费的工作和额外的数据复制。</li>
</ul>
<h3 id="exitsnoop"><a href="#exitsnoop" class="headerlink" title="exitsnoop"></a>exitsnoop</h3><p>本文是 eBPF 入门开发实践教程的第八篇，在 eBPF 中使用 exitsnoop 监控进程退出事件，并使用 ring buffer 向用户态打印输出。</p>
<p>使用 ring buffer 向用户态打印输出的步骤和 perf buffer 类似，首先需要定义一个头文件：</p>
<p>头文件：exitsnoop.h<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BOOTSTRAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BOOTSTRAP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_COMM_LEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FILENAME_LEN 127</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">int</span> ppid;</span><br><span class="line">    <span class="type">unsigned</span> exit_code;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> duration_ns;</span><br><span class="line">    <span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __BOOTSTRAP_H */</span></span></span><br></pre></td></tr></table></figure></p>
<p>源文件：exitsnoop.bpf.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmlinux.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_core_read.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;exitsnoop.h&quot;</span></span></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual BSD/GPL&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> __uint(type, BPF_MAP_TYPE_RINGBUF);</span><br><span class="line"> __uint(max_entries, <span class="number">256</span> * <span class="number">1024</span>);</span><br><span class="line">&#125; rb <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tp/sched/sched_process_exit&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_exit</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sched_process_template* ctx)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">e</span>;</span></span><br><span class="line"> <span class="type">pid_t</span> pid, tid;</span><br><span class="line"> u64 id, ts, *start_ts, duration_ns = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* get PID and TID of exiting thread/process */</span></span><br><span class="line"> id = bpf_get_current_pid_tgid();</span><br><span class="line"> pid = id &gt;&gt; <span class="number">32</span>;</span><br><span class="line"> tid = (u32)id;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* ignore thread exits */</span></span><br><span class="line"> <span class="keyword">if</span> (pid != tid)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* reserve sample from BPF ringbuf */</span></span><br><span class="line"> e = bpf_ringbuf_reserve(&amp;rb, <span class="keyword">sizeof</span>(*e), <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">if</span> (!e)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* fill out the sample with data */</span></span><br><span class="line"> task = (<span class="keyword">struct</span> task_struct *)bpf_get_current_task();</span><br><span class="line"></span><br><span class="line"> e-&gt;duration_ns = duration_ns;</span><br><span class="line"> e-&gt;pid = pid;</span><br><span class="line"> e-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);</span><br><span class="line"> e-&gt;exit_code = (BPF_CORE_READ(task, exit_code) &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"> bpf_get_current_comm(&amp;e-&gt;comm, <span class="keyword">sizeof</span>(e-&gt;comm));</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* send data to user-space for post-processing */</span></span><br><span class="line"> bpf_ringbuf_submit(e, <span class="number">0</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码展示了如何使用 exitsnoop 监控进程退出事件并使用 ring buffer 向用户态打印输出：</p>
<ol>
<li>首先，我们引入所需的头文件和 exitsnoop.h。</li>
<li>定义一个名为 “LICENSE” 的全局变量，内容为 “Dual BSD/GPL”，这是 eBPF 程序的许可证要求。</li>
<li>定义一个名为<code>rb</code> 的<code>BPF_MAP_TYPE_RINGBUF</code> 类型的映射，它将用于将内核空间的数据传输到用户空间。指定 <code>max_entries</code> 为 <code>256 * 1024</code>，代表 ring buffer 的最大容量。</li>
<li>定义一个名为 <code>handle_exit</code> 的 eBPF 程序，它将在进程退出事件触发时执行。传入一个名为 ctx 的 <code>trace_event_raw_sched_process_template</code> 结构体指针作为参数。</li>
<li>使用 <code>bpf_get_current_pid_tgid()</code> 函数获取当前任务的 PID 和 TID。对于主线程，PID 和 TID 相同；对于子线程，它们是不同的。我们只关心进程（主线程）的退出，因此在 PID 和 TID 不同时返回 0，忽略子线程退出事件。</li>
<li>使用 bpf_ringbuf_reserve 函数为事件结构体 e 在 ring buffer 中预留空间。如果预留失败，返回 0。</li>
<li>使用 <code>bpf_get_current_task()</code> 函数获取当前任务的 task_struct 结构指针。</li>
<li>将进程相关信息填充到预留的事件结构体 e 中，包括进程持续时间、PID、PPID、退出代码以及进程名称。</li>
<li>最后，使用 bpf_ringbuf_submit 函数将填充好的事件结构体 e 提交到 ring buffer，之后在用户空间进行处理和输出。</li>
</ol>
<p>这个示例展示了如何使用 exitsnoop 和 ring buffer 在 eBPF 程序中捕获进程退出事件并将相关信息传输到用户空间。这对于分析进程退出原因和监控系统行为非常有用。</p>
<h3 id="Compile-and-Run"><a href="#Compile-and-Run" class="headerlink" title="Compile and Run"></a>Compile and Run</h3><p>我们使用 eunomia-bpf 编译运行这个例子。</p>
<p>Compile:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v `<span class="built_in">pwd</span>`/:/src/ ghcr.io/eunomia-bpf/ecc-`<span class="built_in">uname</span> -m`:latest</span><br></pre></td></tr></table></figure></p>
<p>Or<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ecc exitsnoop.bpf.c exitsnoop.h</span><br><span class="line">Compiling bpf object...</span><br><span class="line">Generating <span class="built_in">export</span> types...</span><br><span class="line">Packing ebpf object and config into package.json...</span><br></pre></td></tr></table></figure></p>
<p>Run:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ./ecli run package.json </span><br><span class="line">TIME     PID     PPID    EXIT_CODE  DURATION_NS  COMM    </span><br><span class="line">21:40:09  42050  42049   0          0            <span class="built_in">which</span></span><br><span class="line">21:40:09  42049  3517    0          0            sh</span><br><span class="line">21:40:09  42052  42051   0          0            ps</span><br><span class="line">21:40:09  42051  3517    0          0            sh</span><br><span class="line">21:40:09  42055  42054   0          0            sed</span><br><span class="line">21:40:09  42056  42054   0          0            <span class="built_in">cat</span></span><br><span class="line">21:40:09  42057  42054   0          0            <span class="built_in">cat</span></span><br><span class="line">21:40:09  42058  42054   0          0            <span class="built_in">cat</span></span><br><span class="line">21:40:09  42059  42054   0          0            <span class="built_in">cat</span></span><br></pre></td></tr></table></figure></p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了如何使用 eunomia-bpf 开发一个简单的 BPF 程序，该程序可以监控 Linux 系统中的进程退出事件, 并将捕获的事件通过 ring buffer 发送给用户空间程序。在本文中，我们使用 eunomia-bpf 编译运行了这个例子。</p>
<h2 id="捕获进程调度延迟，以直方图方式记录"><a href="#捕获进程调度延迟，以直方图方式记录" class="headerlink" title="捕获进程调度延迟，以直方图方式记录"></a>捕获进程调度延迟，以直方图方式记录</h2><p>eBPF (Extended Berkeley Packet Filter) 是 Linux 内核上的一个强大的网络和性能分析工具。它允许开发者在内核运行时动态加载、更新和运行用户定义的代码。</p>
<p>runqlat 是一个 eBPF 工具，用于分析 Linux 系统的调度性能。具体来说，runqlat 用于测量一个任务在被调度到 CPU 上运行之前在运行队列中等待的时间。这些信息对于识别性能瓶颈和提高 Linux 内核调度算法的整体效率非常有用。</p>
<h3 id="runqlat-原理"><a href="#runqlat-原理" class="headerlink" title="runqlat 原理"></a>runqlat 原理</h3><p>本教程是 eBPF 入门开发实践系列的第九部分，主题是 “捕获进程调度延迟”。在此，我们将介绍一个名为 runqlat 的程序，其作用是以直方图的形式记录进程调度延迟。</p>
<p>Linux 操作系统使用进程来执行所有的系统和用户任务。这些进程可能被阻塞、杀死、运行，或者正在等待运行。处在后两种状态的进程数量决定了 CPU 运行队列的长度。</p>
<p>进程有几种可能的状态，如：</p>
<ul>
<li>可运行或正在运行</li>
<li>可中断睡眠</li>
<li>不可中断睡眠</li>
<li>停止</li>
<li>僵尸进程</li>
</ul>
<p>等待资源或其他函数信号的进程会处在可中断或不可中断的睡眠状态：进程被置入睡眠状态，直到它需要的资源变得可用。然后，根据睡眠的类型，进程可以转移到可运行状态，或者保持睡眠。</p>
<p>即使进程拥有它需要的所有资源，它也不会立即开始运行。它会转移到可运行状态，与其他处在相同状态的进程一起排队。CPU可以在接下来的几秒钟或毫秒内执行这些进程。调度器为 CPU 排列进程，并决定下一个要执行的进程。</p>
<p>根据系统的硬件配置，这个可运行队列（称为 CPU 运行队列）的长度可以短也可以长。短的运行队列长度表示 CPU 没有被充分利用。另一方面，如果运行队列长，那么可能意味着 CPU 不够强大，无法执行所有的进程，或者 CPU 的核心数量不足。在理想的 CPU 利用率下，运行队列的长度将等于系统中的核心数量。</p>
<p>进程调度延迟，也被称为 “run queue latency”，是衡量线程从变得可运行（例如，接收到中断，促使其处理更多工作）到实际在 CPU 上运行的时间。在 CPU 饱和的情况下，你可以想象线程必须等待其轮次。但在其他奇特的场景中，这也可能发生，而且在某些情况下，它可以通过调优减少，从而提高整个系统的性能。</p>
<p>我们将通过一个示例来阐述如何使用 runqlat 工具。这是一个负载非常重的系统：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># runqlat</span></span><br><span class="line">Tracing run queue latency... Hit Ctrl-C to end.</span><br><span class="line">^C</span><br><span class="line">     usecs           : count   distribution</span><br><span class="line">         0 -&gt; 1      : 233    |***********                             |</span><br><span class="line">         2 -&gt; 3      : 742    |************************************    |</span><br><span class="line">         4 -&gt; 7      : 203    |**********                              |</span><br><span class="line">         8 -&gt; 15     : 173    |********                                |</span><br><span class="line">        16 -&gt; 31     : 24     |*                                       |</span><br><span class="line">        32 -&gt; 63     : 0      |                                        |</span><br><span class="line">        64 -&gt; 127    : 30     |*                                       |</span><br><span class="line">       128 -&gt; 255    : 6      |                                        |</span><br><span class="line">       256 -&gt; 511    : 3      |                                        |</span><br><span class="line">       512 -&gt; 1023   : 5      |                                        |</span><br><span class="line">      1024 -&gt; 2047   : 27     |*                                       |</span><br><span class="line">      2048 -&gt; 4095   : 30     |*                                       |</span><br><span class="line">      4096 -&gt; 8191   : 20     |                                        |</span><br><span class="line">      8192 -&gt; 16383  : 29     |*                                       |</span><br><span class="line">     16384 -&gt; 32767  : 809    |****************************************|</span><br><span class="line">     32768 -&gt; 65535  : 64     |***                                     |</span><br></pre></td></tr></table></figure>
<p>在这个输出中，我们看到了一个双模分布，一个模在0到15微秒之间，另一个模在16到65毫秒之间。这些模式在分布（它仅仅是 “count” 列的视觉表示）中显示为尖峰。例如，读取一行：在追踪过程中，809个事件落入了16384到32767微秒的范围（16到32毫秒）。</p>
<p>在后续的教程中，我们将深入探讨如何利用 eBPF 对此类指标进行深度跟踪和分析，以更好地理解和优化系统性能。同时，我们也将学习更多关于 Linux 内核调度器、中断处理和 CPU 饱</p>
<p>runqlat 的实现利用了 eBPF 程序，它通过内核跟踪点和函数探针来测量进程在运行队列中的时间。当进程被排队时，trace_enqueue 函数会在一个映射中记录时间戳。当进程被调度到 CPU 上运行时，handle_switch 函数会检索时间戳，并计算当前时间与排队时间之间的时间差。这个差值（或 delta）被用于更新进程的直方图，该直方图记录运行队列延迟的分布。该直方图可用于分析 Linux 内核的调度性能。</p>
<h3 id="runqlat-代码实现"><a href="#runqlat-代码实现" class="headerlink" title="runqlat 代码实现"></a>runqlat 代码实现</h3><p>首先我们需要编写一个源代码文件 runqlat.bpf.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0</span></span><br><span class="line"><span class="comment">// Copyright (c) 2020 Wenbo Zhang</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vmlinux.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_core_read.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;runqlat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits.bpf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;maps.bpf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;core_fixes.bpf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ENTRIES 10240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING  0</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> filter_cg = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> targ_per_process = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> targ_per_thread = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> targ_per_pidns = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> targ_ms = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">pid_t</span> targ_tgid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> __uint(type, BPF_MAP_TYPE_CGROUP_ARRAY);</span><br><span class="line"> __type(key, u32);</span><br><span class="line"> __type(value, u32);</span><br><span class="line"> __uint(max_entries, <span class="number">1</span>);</span><br><span class="line">&#125; cgroup_map <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line"> __uint(max_entries, MAX_ENTRIES);</span><br><span class="line"> __type(key, u32);</span><br><span class="line"> __type(value, u64);</span><br><span class="line">&#125; start <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hist</span> <span class="title">zero</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// @sample &#123;&quot;interval&quot;: 1000, &quot;type&quot; : &quot;log2_hist&quot;&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line"> __uint(max_entries, MAX_ENTRIES);</span><br><span class="line"> __type(key, u32);</span><br><span class="line"> __type(value, <span class="keyword">struct</span> hist);</span><br><span class="line">&#125; hists <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">trace_enqueue</span><span class="params">(u32 tgid, u32 pid)</span></span><br><span class="line">&#123;</span><br><span class="line"> u64 ts;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!pid)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span> (targ_tgid &amp;&amp; targ_tgid != tgid)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> ts = bpf_ktime_get_ns();</span><br><span class="line"> bpf_map_update_elem(&amp;start, &amp;pid, &amp;ts, BPF_ANY);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">pid_namespace</span><span class="params">(<span class="keyword">struct</span> task_struct *task)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> level;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">upid</span> <span class="title">upid</span>;</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> inum;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*  get the pid namespace by following task_active_pid_ns(),</span></span><br><span class="line"><span class="comment">  *  pid-&gt;numbers[pid-&gt;level].ns</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> pid = BPF_CORE_READ(task, thread_pid);</span><br><span class="line"> level = BPF_CORE_READ(pid, level);</span><br><span class="line"> bpf_core_read(&amp;upid, <span class="keyword">sizeof</span>(upid), &amp;pid-&gt;numbers[level]);</span><br><span class="line"> inum = BPF_CORE_READ(upid.ns, ns.inum);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> inum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_switch</span><span class="params">(<span class="type">bool</span> preempt, <span class="keyword">struct</span> task_struct *prev, <span class="keyword">struct</span> task_struct *next)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">hist</span> *<span class="title">histp</span>;</span></span><br><span class="line"> u64 *tsp, slot;</span><br><span class="line"> u32 pid, hkey;</span><br><span class="line"> s64 delta;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (get_task_state(prev) == TASK_RUNNING)</span><br><span class="line">  trace_enqueue(BPF_CORE_READ(prev, tgid), BPF_CORE_READ(prev, pid));</span><br><span class="line"></span><br><span class="line"> pid = BPF_CORE_READ(next, pid);</span><br><span class="line"></span><br><span class="line"> tsp = bpf_map_lookup_elem(&amp;start, &amp;pid);</span><br><span class="line"> <span class="keyword">if</span> (!tsp)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> delta = bpf_ktime_get_ns() - *tsp;</span><br><span class="line"> <span class="keyword">if</span> (delta &lt; <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (targ_per_process)</span><br><span class="line">  hkey = BPF_CORE_READ(next, tgid);</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (targ_per_thread)</span><br><span class="line">  hkey = pid;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (targ_per_pidns)</span><br><span class="line">  hkey = pid_namespace(next);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  hkey = <span class="number">-1</span>;</span><br><span class="line"> histp = bpf_map_lookup_or_try_init(&amp;hists, &amp;hkey, &amp;zero);</span><br><span class="line"> <span class="keyword">if</span> (!histp)</span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line"> <span class="keyword">if</span> (!histp-&gt;comm[<span class="number">0</span>])</span><br><span class="line">  bpf_probe_read_kernel_str(&amp;histp-&gt;comm, <span class="keyword">sizeof</span>(histp-&gt;comm),</span><br><span class="line">     next-&gt;comm);</span><br><span class="line"> <span class="keyword">if</span> (targ_ms)</span><br><span class="line">  delta /= <span class="number">1000000U</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  delta /= <span class="number">1000U</span>;</span><br><span class="line"> slot = log2l(delta);</span><br><span class="line"> <span class="keyword">if</span> (slot &gt;= MAX_SLOTS)</span><br><span class="line">  slot = MAX_SLOTS - <span class="number">1</span>;</span><br><span class="line"> __sync_fetch_and_add(&amp;histp-&gt;slots[slot], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line"> bpf_map_delete_elem(&amp;start, &amp;pid);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;raw_tp/sched_wakeup&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_PROG</span><span class="params">(handle_sched_wakeup, <span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> trace_enqueue(BPF_CORE_READ(p, tgid), BPF_CORE_READ(p, pid));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;raw_tp/sched_wakeup_new&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_PROG</span><span class="params">(handle_sched_wakeup_new, <span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> trace_enqueue(BPF_CORE_READ(p, tgid), BPF_CORE_READ(p, pid));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;raw_tp/sched_switch&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_PROG</span><span class="params">(handle_sched_switch, <span class="type">bool</span> preempt, <span class="keyword">struct</span> task_struct *prev, <span class="keyword">struct</span> task_struct *next)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> handle_switch(preempt, prev, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这其中定义了一些常量和全局变量，用于过滤对应的追踪目标：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ENTRIES 10240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING  0</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> filter_cg = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> targ_per_process = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> targ_per_thread = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> targ_per_pidns = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> targ_ms = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">pid_t</span> targ_tgid = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这些变量包括最大映射项数量、任务状态、过滤选项和目标选项。这些选项可以通过用户空间程序设置，以定制 eBPF 程序的行为。</p>
<p>接下来，定义了一些 eBPF 映射：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> __uint(type, BPF_MAP_TYPE_CGROUP_ARRAY);</span><br><span class="line"> __type(key, u32);</span><br><span class="line"> __type(value, u32);</span><br><span class="line"> __uint(max_entries, <span class="number">1</span>);</span><br><span class="line">&#125; cgroup_map <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line"> __uint(max_entries, MAX_ENTRIES);</span><br><span class="line"> __type(key, u32);</span><br><span class="line"> __type(value, u64);</span><br><span class="line">&#125; start <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hist</span> <span class="title">zero</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line"> __uint(max_entries, MAX_ENTRIES);</span><br><span class="line"> __type(key, u32);</span><br><span class="line"> __type(value, <span class="keyword">struct</span> hist);</span><br><span class="line">&#125; hists <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这些映射包括：</p>
<ul>
<li>cgroup_map 用于过滤 cgroup；</li>
<li>start 用于存储进程入队时的时间戳；</li>
<li>hists 用于存储直方图数据，记录进程调度延迟。</li>
</ul>
<p>接下来是一些辅助函数：</p>
<p>trace_enqueue 函数用于在进程入队时记录其时间戳：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">trace_enqueue</span><span class="params">(u32 tgid, u32 pid)</span></span><br><span class="line">&#123;</span><br><span class="line"> u64 ts;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!pid)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span> (targ_tgid &amp;&amp; targ_tgid != tgid)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> ts = bpf_ktime_get_ns();</span><br><span class="line"> bpf_map_update_elem(&amp;start, &amp;pid, &amp;ts, BPF_ANY);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pid_namespace 函数用于获取进程所属的 PID namespace：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">pid_namespace</span><span class="params">(<span class="keyword">struct</span> task_struct *task)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> level;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">upid</span> <span class="title">upid</span>;</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> inum;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*  get the pid namespace by following task_active_pid_ns(),</span></span><br><span class="line"><span class="comment">  *  pid-&gt;numbers[pid-&gt;level].ns</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> pid = BPF_CORE_READ(task, thread_pid);</span><br><span class="line"> level = BPF_CORE_READ(pid, level);</span><br><span class="line"> bpf_core_read(&amp;upid, <span class="keyword">sizeof</span>(upid), &amp;pid-&gt;numbers[level]);</span><br><span class="line"> inum = BPF_CORE_READ(upid.ns, ns.inum);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> inum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handle_switch 函数是核心部分，用于处理调度切换事件，计算进程调度延迟并更新直方图数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_switch</span><span class="params">(<span class="type">bool</span> preempt, <span class="keyword">struct</span> task_struct *prev, <span class="keyword">struct</span> task_struct *next)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，函数根据 filter_cg 的设置判断是否需要过滤 cgroup。然后，如果之前的进程状态为 TASK_RUNNING，则调用 trace_enqueue 函数记录进程的入队时间。接着，函数查找下一个进程的入队时间戳，如果找不到，直接返回。计算调度延迟（delta），并根据不同的选项设置（targ_per_process，targ_per_thread，targ_per_pidns），确定直方图映射的键（hkey）。然后查找或初始化直方图映射，更新直方图数据，最后删除进程的入队时间戳记录。</p>
<p>接下来是 eBPF 程序的入口点。程序使用三个入口点来捕获不同的调度事件：</p>
<ul>
<li>handle_sched_wakeup：用于处理 sched_wakeup 事件，当一个进程从睡眠状态被唤醒时触发。</li>
<li>handle_sched_wakeup_new：用于处理 sched_wakeup_new 事件，当一个新创建的进程被唤醒时触发。</li>
<li>handle_sched_switch：用于处理 sched_switch 事件，当调度器选择一个新的进程运行时触发。</li>
</ul>
<p>这些入口点分别处理不同的调度事件，但都会调用 handle_switch 函数来计算进程的调度延迟并更新直方图数据。</p>
<p>最后，程序包含一个许可证声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这一声明指定了 eBPF 程序的许可证类型，这里使用的是 “GPL”。这对于许多内核功能是必需的，因为它们要求 eBPF 程序遵循 GPL 许可证。</p>
<h3 id="runqlat-h"><a href="#runqlat-h" class="headerlink" title="runqlat.h"></a>runqlat.h</h3><p>然后我们需要定义一个头文件<code>runqlat.h</code>，用来给用户态处理从内核态上报的事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RUNQLAT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RUNQLAT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_COMM_LEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SLOTS 26</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hist</span> &#123;</span></span><br><span class="line"> __u32 slots[MAX_SLOTS];</span><br><span class="line"> <span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __RUNQLAT_H */</span></span></span><br></pre></td></tr></table></figure>
<h3 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h3><p>我们使用 eunomia-bpf 编译运行这个例子。</p>
<p>Compile:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v `<span class="built_in">pwd</span>`/:/src/ ghcr.io/eunomia-bpf/ecc-`<span class="built_in">uname</span> -m`:latest</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ecc runqlat.bpf.c runqlat.h</span><br><span class="line">Compiling bpf object...</span><br><span class="line">Generating <span class="built_in">export</span> types...</span><br><span class="line">Packing ebpf object and config into package.json...</span><br></pre></td></tr></table></figure>
<p>Run:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ecli run examples/bpftools/runqlat/package.json -h</span><br><span class="line">Usage: runqlat_bpf [--<span class="built_in">help</span>] [--version] [--verbose] [--filter_cg] [--targ_per_process] [--targ_per_thread] [--targ_per_pidns] [--targ_ms] [--targ_tgid VAR]</span><br><span class="line"></span><br><span class="line">A simple eBPF program</span><br><span class="line"></span><br><span class="line">Optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>            shows <span class="built_in">help</span> message and exits </span><br><span class="line">  -v, --version         prints version information and exits </span><br><span class="line">  --verbose             prints libbpf debug information </span><br><span class="line">  --filter_cg           <span class="built_in">set</span> value of bool variable filter_cg </span><br><span class="line">  --targ_per_process    <span class="built_in">set</span> value of bool variable targ_per_process </span><br><span class="line">  --targ_per_thread     <span class="built_in">set</span> value of bool variable targ_per_thread </span><br><span class="line">  --targ_per_pidns      <span class="built_in">set</span> value of bool variable targ_per_pidns </span><br><span class="line">  --targ_ms             <span class="built_in">set</span> value of bool variable targ_ms </span><br><span class="line">  --targ_tgid           <span class="built_in">set</span> value of pid_t variable targ_tgid </span><br><span class="line"></span><br><span class="line">Built with eunomia-bpf framework.</span><br><span class="line">See https://github.com/eunomia-bpf/eunomia-bpf <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> ecli run examples/bpftools/runqlat/package.json</span><br><span class="line">key =  4294967295</span><br><span class="line"><span class="built_in">comm</span> = rcu_preempt</span><br><span class="line"></span><br><span class="line"> (unit)         : count distribution</span><br><span class="line">     0 -&gt; 1     : 9     |****                                    |</span><br><span class="line">     2 -&gt; 3     : 6     |**                                      |</span><br><span class="line">     4 -&gt; 7     : 12    |*****                                   |</span><br><span class="line">     8 -&gt; 15    : 28    |*************                           |</span><br><span class="line">    16 -&gt; 31    : 40    |*******************                     |</span><br><span class="line">    32 -&gt; 63    : 83    |****************************************|</span><br><span class="line">    64 -&gt; 127   : 57    |***************************             |</span><br><span class="line">   128 -&gt; 255   : 19    |*********                               |</span><br><span class="line">   256 -&gt; 511   : 11    |*****                                   |</span><br><span class="line">   512 -&gt; 1023  : 2     |                                        |</span><br><span class="line">  1024 -&gt; 2047  : 2     |                                        |</span><br><span class="line">  2048 -&gt; 4095  : 0     |                                        |</span><br><span class="line">  4096 -&gt; 8191  : 0     |                                        |</span><br><span class="line">  8192 -&gt; 16383 : 0     |                                        |</span><br><span class="line"> 16384 -&gt; 32767 : 1     |                                        |</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> ecli run examples/bpftools/runqlat/package.json --targ_per_process</span><br><span class="line">key =  3189</span><br><span class="line"><span class="built_in">comm</span> = cpptools</span><br><span class="line"></span><br><span class="line">     (unit)        : count distribution</span><br><span class="line">         0 -&gt; 1    : 0     |                                        |</span><br><span class="line">         2 -&gt; 3    : 0     |                                        |</span><br><span class="line">         4 -&gt; 7    : 0     |                                        |</span><br><span class="line">         8 -&gt; 15   : 1     |***                                     |</span><br><span class="line">        16 -&gt; 31   : 2     |*******                                 |</span><br><span class="line">        32 -&gt; 63   : 11    |****************************************|</span><br><span class="line">        64 -&gt; 127  : 8     |*****************************           |</span><br><span class="line">       128 -&gt; 255  : 3     |**********                              |</span><br></pre></td></tr></table></figure>
<p>完整源代码请见：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Feunomia-bpf%2Fbpf-developer-tutorial%2Ftree%2Fmain%2Fsrc%2F9-runqlat">https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/9-runqlat</a></p>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>runqlat 是一个 Linux 内核 BPF 程序，通过柱状图来总结调度程序运行队列延迟，显示任务等待运行在 CPU 上的时间长度。编译这个程序可以使用 ecc 工具，运行时可以使用 ecli 命令。</p>
<p>runqlat 是一种用于监控Linux内核中进程调度延迟的工具。它可以帮助您了解进程在内核中等待执行的时间，并根据这些信息优化进程调度，提高系统的性能。可以在 libbpf-tools 中找到最初的源代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Fiovisor%2Fbcc%2Fblob%2Fmaster%2Flibbpf-tools%2Frunqlat.bpf.c">https://github.com/iovisor/bcc/blob/master/libbpf-tools/runqlat.bpf.c</a></p>
<h2 id="在-eBPF-中使用-hardirqs-或-softirqs-捕获中断事件"><a href="#在-eBPF-中使用-hardirqs-或-softirqs-捕获中断事件" class="headerlink" title="在 eBPF 中使用 hardirqs 或 softirqs 捕获中断事件"></a>在 eBPF 中使用 hardirqs 或 softirqs 捕获中断事件</h2><p>eBPF (Extended Berkeley Packet Filter) 是 Linux 内核上的一个强大的网络和性能分析工具。它允许开发者在内核运行时动态加载、更新和运行用户定义的代码。</p>
<p>本文是 eBPF 入门开发实践教程的第十篇，在 eBPF 中使用 hardirqs 或 softirqs 捕获中断事件。 hardirqs 和 softirqs 是 Linux 内核中两种不同类型的中断处理程序。它们用于处理硬件设备产生的中断请求，以及内核中的异步事件。在 eBPF 中，我们可以使用同名的 eBPF 工具 hardirqs 和 softirqs 来捕获和分析内核中与中断处理相关的信息。</p>
<h3 id="hardirqs-和-softirqs-是什么？"><a href="#hardirqs-和-softirqs-是什么？" class="headerlink" title="hardirqs 和 softirqs 是什么？"></a>hardirqs 和 softirqs 是什么？</h3><p>hardirqs 是硬件中断处理程序。当硬件设备产生一个中断请求时，内核会将该请求映射到一个特定的中断向量，然后执行与之关联的硬件中断处理程序。硬件中断处理程序通常用于处理设备驱动程序中的事件，例如设备数据传输完成或设备错误。</p>
<p>softirqs 是软件中断处理程序。它们是内核中的一种底层异步事件处理机制，用于处理内核中的高优先级任务。softirqs 通常用于处理网络协议栈、磁盘子系统和其他内核组件中的事件。与硬件中断处理程序相比，软件中断处理程序具有更高的灵活性和可配置性。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>在 eBPF 中，我们可以通过挂载特定的 kprobe 或者 tracepoint 来捕获和分析 hardirqs 和 softirqs。为了捕获 hardirqs 和 softirqs，需要在相关的内核函数上放置 eBPF 程序。这些函数包括：</p>
<ul>
<li>对于 hardirqs：irq_handler_entry 和 irq_handler_exit。</li>
<li>对于 softirqs：softirq_entry 和 softirq_exit。</li>
</ul>
<p>当内核处理 hardirqs 或 softirqs 时，这些 eBPF 程序会被执行，从而收集相关信息，如中断向量、中断处理程序的执行时间等。收集到的信息可以用于分析内核中的性能问题和其他与中断处理相关的问题。</p>
<p>为了捕获 hardirqs 和 softirqs，可以遵循以下步骤：</p>
<ol>
<li>在 eBPF 程序中定义用于存储中断信息的数据结构和映射。</li>
<li>编写 eBPF 程序，将其挂载到相应的内核函数上，以捕获 hardirqs 或 softirqs。</li>
<li>在 eBPF 程序中，收集中断处理程序的相关信息，并将这些信息存储在映射中。</li>
<li>在用户空间应用程序中，读取映射中的数据以分析和展示中断处理信息。</li>
</ol>
<p>通过上述方法，我们可以在 eBPF 中使用 hardirqs 和 softirqs 捕获和分析内核中的中断事件，以识别潜在的性能问题和与中断处理相关的问题。</p>
<h3 id="hardirqs-代码实现"><a href="#hardirqs-代码实现" class="headerlink" title="hardirqs 代码实现"></a>hardirqs 代码实现</h3><p>hardirqs 程序的主要目的是获取中断处理程序的名称、执行次数和执行时间，并以直方图的形式展示执行时间的分布。让我们一步步分析这段代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0</span></span><br><span class="line"><span class="comment">// Copyright (c) 2020 Wenbo Zhang</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vmlinux.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_core_read.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hardirqs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits.bpf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;maps.bpf.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ENTRIES 256</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> filter_cg = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> targ_dist = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> targ_ns = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> do_count = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> __uint(type, BPF_MAP_TYPE_CGROUP_ARRAY);</span><br><span class="line"> __type(key, u32);</span><br><span class="line"> __type(value, u32);</span><br><span class="line"> __uint(max_entries, <span class="number">1</span>);</span><br><span class="line">&#125; cgroup_map <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);</span><br><span class="line"> __uint(max_entries, <span class="number">1</span>);</span><br><span class="line"> __type(key, u32);</span><br><span class="line"> __type(value, u64);</span><br><span class="line">&#125; start <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line"> __uint(max_entries, MAX_ENTRIES);</span><br><span class="line"> __type(key, <span class="keyword">struct</span> irq_key);</span><br><span class="line"> __type(value, <span class="keyword">struct</span> info);</span><br><span class="line">&#125; infos <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">info</span> <span class="title">zero</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_entry</span><span class="params">(<span class="type">int</span> irq, <span class="keyword">struct</span> irqaction *action)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (do_count) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">irq_key</span> <span class="title">key</span> =</span> &#123;&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">info</span> *<span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">  bpf_probe_read_kernel_str(&amp;key.name, <span class="keyword">sizeof</span>(key.name), BPF_CORE_READ(action, name));</span><br><span class="line">  info = bpf_map_lookup_or_try_init(&amp;infos, &amp;key, &amp;zero);</span><br><span class="line">  <span class="keyword">if</span> (!info)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  info-&gt;count += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  u64 ts = bpf_ktime_get_ns();</span><br><span class="line">  u32 key = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, <span class="number">0</span>))</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  bpf_map_update_elem(&amp;start, &amp;key, &amp;ts, BPF_ANY);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_exit</span><span class="params">(<span class="type">int</span> irq, <span class="keyword">struct</span> irqaction *action)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">irq_key</span> <span class="title">ikey</span> =</span> &#123;&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">info</span> *<span class="title">info</span>;</span></span><br><span class="line"> u32 key = <span class="number">0</span>;</span><br><span class="line"> u64 delta;</span><br><span class="line"> u64 *tsp;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (filter_cg &amp;&amp; !bpf_current_task_under_cgroup(&amp;cgroup_map, <span class="number">0</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> tsp = bpf_map_lookup_elem(&amp;start, &amp;key);</span><br><span class="line"> <span class="keyword">if</span> (!tsp)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> delta = bpf_ktime_get_ns() - *tsp;</span><br><span class="line"> <span class="keyword">if</span> (!targ_ns)</span><br><span class="line">  delta /= <span class="number">1000U</span>;</span><br><span class="line"></span><br><span class="line"> bpf_probe_read_kernel_str(&amp;ikey.name, <span class="keyword">sizeof</span>(ikey.name), BPF_CORE_READ(action, name));</span><br><span class="line"> info = bpf_map_lookup_or_try_init(&amp;infos, &amp;ikey, &amp;zero);</span><br><span class="line"> <span class="keyword">if</span> (!info)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!targ_dist) &#123;</span><br><span class="line">  info-&gt;count += delta;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  u64 slot;</span><br><span class="line"></span><br><span class="line">  slot = log2(delta);</span><br><span class="line">  <span class="keyword">if</span> (slot &gt;= MAX_SLOTS)</span><br><span class="line">   slot = MAX_SLOTS - <span class="number">1</span>;</span><br><span class="line">  info-&gt;slots[slot]++;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tp_btf/irq_handler_entry&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_PROG</span><span class="params">(irq_handler_entry_btf, <span class="type">int</span> irq, <span class="keyword">struct</span> irqaction *action)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> handle_entry(irq, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tp_btf/irq_handler_exit&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_PROG</span><span class="params">(irq_handler_exit_btf, <span class="type">int</span> irq, <span class="keyword">struct</span> irqaction *action)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> handle_exit(irq, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;raw_tp/irq_handler_entry&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_PROG</span><span class="params">(irq_handler_entry, <span class="type">int</span> irq, <span class="keyword">struct</span> irqaction *action)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> handle_entry(irq, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;raw_tp/irq_handler_exit&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_PROG</span><span class="params">(irq_handler_exit, <span class="type">int</span> irq, <span class="keyword">struct</span> irqaction *action)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> handle_exit(irq, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这段代码是一个 eBPF 程序，用于捕获和分析内核中硬件中断处理程序（hardirqs）的执行信息。程序的主要目的是获取中断处理程序的名称、执行次数和执行时间，并以直方图的形式展示执行时间的分布。让我们一步步分析这段代码。</p>
<p>包含必要的头文件和定义数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vmlinux.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_core_read.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hardirqs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits.bpf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;maps.bpf.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>该程序包含了 eBPF 开发所需的标准头文件，以及用于定义数据结构和映射的自定义头文件。</p>
<p>定义全局变量和映射：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ENTRIES 256</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> filter_cg = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> targ_dist = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> targ_ns = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> do_count = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>该程序定义了一些全局变量，用于配置程序的行为。例如，<code>filter_cg</code> 控制是否过滤 cgroup，<code>targ_dist</code> 控制是否显示执行时间的分布等。此外，程序还定义了三个映射，分别用于存储 cgroup 信息、开始时间戳和中断处理程序的信息。</p>
<p>定义两个辅助函数 <code>handle_entry</code> 和 <code>handle_exit</code>：</p>
<p>这两个函数分别在中断处理程序的入口和出口处被调用。<code>handle_entry</code> 记录开始时间戳或更新中断计数，<code>handle_exit</code> 计算中断处理程序的执行时间，并将结果存储到相应的信息映射中。</p>
<p>定义 eBPF 程序的入口点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;tp_btf/irq_handler_entry&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_PROG</span><span class="params">(irq_handler_entry_btf, <span class="type">int</span> irq, <span class="keyword">struct</span> irqaction *action)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> handle_entry(irq, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tp_btf/irq_handler_exit&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_PROG</span><span class="params">(irq_handler_exit_btf, <span class="type">int</span> irq, <span class="keyword">struct</span> irqaction *action)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> handle_exit(irq, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;raw_tp/irq_handler_entry&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_PROG</span><span class="params">(irq_handler_entry, <span class="type">int</span> irq, <span class="keyword">struct</span> irqaction *action)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> handle_entry(irq, action);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;raw_tp/irq_handler_exit&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_PROG</span><span class="params">(irq_handler_exit, <span class="type">int</span> irq, <span class="keyword">struct</span> irqaction *action)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> handle_exit(irq, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了四个 eBPF 程序入口点，分别用于捕获中断处理程序的入口和出口事件。<code>tp_btf</code> 和 <code>raw_tp</code> 分别代表使用 BPF Type Format（BTF）和原始 tracepoints 捕获事件。这样可以确保程序在不同内核版本上可以移植和运行。</p>
<p>Softirq 代码也类似，这里就不再赘述了。</p>
<h3 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h3><p>eunomia-bpf 是一个结合 Wasm 的开源 eBPF 动态加载运行时和开发工具链，它的目的是简化 eBPF 程序的开发、构建、分发、运行。可以参考 <a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Feunomia-bpf%2Feunomia-bpf">https://github.com/eunomia-bpf/eunomia-bpf</a> 下载和安装 ecc 编译工具链和 ecli 运行时。我们使用 eunomia-bpf 编译运行这个例子。</p>
<p>要编译这个程序，请使用 ecc 工具：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ecc hardirqs.bpf.c</span><br><span class="line">Compiling bpf object...</span><br><span class="line">Packing ebpf object and config into package.json...</span><br></pre></td></tr></table></figure>
<p>然后运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ecli run ./package.json</span><br></pre></td></tr></table></figure>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>在本章节（eBPF 入门开发实践教程十：在 eBPF 中使用 hardirqs 或 softirqs 捕获中断事件）中，我们学习了如何使用 eBPF 程序捕获和分析内核中硬件中断处理程序（hardirqs）的执行信息。我们详细讲解了示例代码，包括如何定义数据结构、映射以及 eBPF 程序入口点，以及如何在中断处理程序的入口和出口处调用辅助函数来记录执行信息。</p>
<h2 id="在-eBPF-中使用-libbpf-开发用户态程序并跟踪-exec-和-exit-系统调用"><a href="#在-eBPF-中使用-libbpf-开发用户态程序并跟踪-exec-和-exit-系统调用" class="headerlink" title="在 eBPF 中使用 libbpf 开发用户态程序并跟踪 exec() 和 exit() 系统调用"></a>在 eBPF 中使用 libbpf 开发用户态程序并跟踪 exec() 和 exit() 系统调用</h2><p>eBPF (Extended Berkeley Packet Filter) 是 Linux 内核上的一个强大的网络和性能分析工具。它允许开发者在内核运行时动态加载、更新和运行用户定义的代码。</p>
<p>在本教程中，我们将了解内核态和用户态的 eBPF 程序是如何协同工作的。我们还将学习如何使用原生的 libbpf 开发用户态程序，将 eBPF 应用打包为可执行文件，实现跨内核版本分发。</p>
<h3 id="libbpf-库，以及为什么需要使用它"><a href="#libbpf-库，以及为什么需要使用它" class="headerlink" title="libbpf 库，以及为什么需要使用它"></a>libbpf 库，以及为什么需要使用它</h3><p>libbpf 是一个 C 语言库，伴随内核版本分发，用于辅助 eBPF 程序的加载和运行。它提供了用于与 eBPF 系统交互的一组 C API，使开发者能够更轻松地编写用户态程序来加载和管理 eBPF 程序。这些用户态程序通常用于分析、监控或优化系统性能。</p>
<p>使用 libbpf 库有以下优势：</p>
<ul>
<li>它简化了 eBPF 程序的加载、更新和运行过程。</li>
<li>它提供了一组易于使用的 API，使开发者能够专注于编写核心逻辑，而不是处理底层细节。</li>
<li>它能够确保与内核中的 eBPF 子系统的兼容性，降低了维护成本。</li>
</ul>
<p>同时，libbpf 和 BTF（BPF Type Format）都是 eBPF 生态系统的重要组成部分。它们各自在实现跨内核版本兼容方面发挥着关键作用。BTF（BPF Type Format）是一种元数据格式，用于描述 eBPF 程序中的类型信息。BTF 的主要目的是提供一种结构化的方式，以描述内核中的数据结构，以便 eBPF 程序可以更轻松地访问和操作它们。</p>
<p>BTF 在实现跨内核版本兼容方面的关键作用如下：</p>
<ul>
<li>BTF 允许 eBPF 程序访问内核数据结构的详细类型信息，而无需对特定内核版本进行硬编码。这使得 eBPF 程序可以适应不同版本的内核，从而实现跨内核版本兼容。</li>
<li>通过使用 BPF CO-RE（Compile Once, Run Everywhere）技术，eBPF 程序可以利用 BTF 在编译时解析内核数据结构的类型信息，进而生成可以在不同内核版本上运行的 eBPF 程序。</li>
</ul>
<p>结合 libbpf 和 BTF，eBPF 程序可以在各种不同版本的内核上运行，而无需为每个内核版本单独编译。这极大地提高了 eBPF 生态系统的可移植性和兼容性，降低了开发和维护的难度。</p>
<h3 id="什么是-bootstrap"><a href="#什么是-bootstrap" class="headerlink" title="什么是 bootstrap"></a>什么是 bootstrap</h3><p>Bootstrap 是一个使用 libbpf 的完整应用，它利用 eBPF 程序来跟踪内核中的 exec() 系统调用（通过 <code>SEC(&quot;tp/sched/sched_process_exec&quot;) handle_exec</code> BPF 程序），这主要对应于新进程的创建（不包括 fork() 部分）。此外，它还跟踪进程的 exit() 系统调用（通过 <code>SEC(&quot;tp/sched/sched_process_exit&quot;) handle_exit</code> BPF 程序），以了解每个进程何时退出。</p>
<p>这两个 BPF 程序共同工作，允许捕获关于新进程的有趣信息，例如二进制文件的文件名，以及测量进程的生命周期，并在进程结束时收集有趣的统计信息，例如退出代码或消耗的资源量等。这是深入了解内核内部并观察事物如何真正运作的良好起点。</p>
<p>Bootstrap 还使用 argp API（libc 的一部分）进行命令行参数解析，使得用户可以通过命令行选项配置应用行为。这种方式提供了灵活性，让用户能够根据实际需求自定义程序行为。虽然这些功能使用 eunomia-bpf 工具也可以实现，但是这里我们使用 libbpf 可以在用户态提供更高的可扩展性，不过也带来了不少额外的复杂度。</p>
<h3 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h3><p>Bootstrap 分为两个部分：内核态和用户态。内核态部分是一个 eBPF 程序，它跟踪 exec() 和 exit() 系统调用。用户态部分是一个 C 语言程序，它使用 libbpf 库来加载和运行内核态程序，并处理从内核态程序收集的数据。</p>
<h5 id="内核态-eBPF-程序-bootstrap-bpf-c"><a href="#内核态-eBPF-程序-bootstrap-bpf-c" class="headerlink" title="内核态 eBPF 程序 bootstrap.bpf.c"></a>内核态 eBPF 程序 bootstrap.bpf.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause</span></span><br><span class="line"><span class="comment">/* Copyright (c) 2020 Facebook */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmlinux.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_core_read.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bootstrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual BSD/GPL&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">    __uint(max_entries, <span class="number">8192</span>);</span><br><span class="line">    __type(key, <span class="type">pid_t</span>);</span><br><span class="line">    __type(value, u64);</span><br><span class="line">&#125; exec_start <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_RINGBUF);</span><br><span class="line">    __uint(max_entries, <span class="number">256</span> * <span class="number">1024</span>);</span><br><span class="line">&#125; rb <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> min_duration_ns = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tp/sched/sched_process_exec&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_exec</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sched_process_exec *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> fname_off;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    u64 ts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remember time exec() was executed for this PID */</span></span><br><span class="line">    pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    ts = bpf_ktime_get_ns();</span><br><span class="line">    bpf_map_update_elem(&amp;exec_start, &amp;pid, &amp;ts, BPF_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* don&#x27;t emit exec events when minimum duration is specified */</span></span><br><span class="line">    <span class="keyword">if</span> (min_duration_ns)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserve sample from BPF ringbuf */</span></span><br><span class="line">    e = bpf_ringbuf_reserve(&amp;rb, <span class="keyword">sizeof</span>(*e), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!e)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fill out the sample with data */</span></span><br><span class="line">    task = (<span class="keyword">struct</span> task_struct *)bpf_get_current_task();</span><br><span class="line"></span><br><span class="line">    e-&gt;exit_event = <span class="literal">false</span>;</span><br><span class="line">    e-&gt;pid = pid;</span><br><span class="line">    e-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);</span><br><span class="line">    bpf_get_current_comm(&amp;e-&gt;comm, <span class="keyword">sizeof</span>(e-&gt;comm));</span><br><span class="line"></span><br><span class="line">    fname_off = ctx-&gt;__data_loc_filename &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    bpf_probe_read_str(&amp;e-&gt;filename, <span class="keyword">sizeof</span>(e-&gt;filename), (<span class="type">void</span> *)ctx + fname_off);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* successfully submit it to user-space for post-processing */</span></span><br><span class="line">    bpf_ringbuf_submit(e, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tp/sched/sched_process_exit&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_exit</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sched_process_template* ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="type">pid_t</span> pid, tid;</span><br><span class="line">    u64 id, ts, *start_ts, duration_ns = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* get PID and TID of exiting thread/process */</span></span><br><span class="line">    id = bpf_get_current_pid_tgid();</span><br><span class="line">    pid = id &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    tid = (u32)id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ignore thread exits */</span></span><br><span class="line">    <span class="keyword">if</span> (pid != tid)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if we recorded start of the process, calculate lifetime duration */</span></span><br><span class="line">    start_ts = bpf_map_lookup_elem(&amp;exec_start, &amp;pid);</span><br><span class="line">    <span class="keyword">if</span> (start_ts)</span><br><span class="line">        duration_ns = bpf_ktime_get_ns() - *start_ts;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (min_duration_ns)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    bpf_map_delete_elem(&amp;exec_start, &amp;pid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if process didn&#x27;t live long enough, return early */</span></span><br><span class="line">    <span class="keyword">if</span> (min_duration_ns &amp;&amp; duration_ns &lt; min_duration_ns)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reserve sample from BPF ringbuf */</span></span><br><span class="line">    e = bpf_ringbuf_reserve(&amp;rb, <span class="keyword">sizeof</span>(*e), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!e)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fill out the sample with data */</span></span><br><span class="line">    task = (<span class="keyword">struct</span> task_struct *)bpf_get_current_task();</span><br><span class="line"></span><br><span class="line">    e-&gt;exit_event = <span class="literal">true</span>;</span><br><span class="line">    e-&gt;duration_ns = duration_ns;</span><br><span class="line">    e-&gt;pid = pid;</span><br><span class="line">    e-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);</span><br><span class="line">    e-&gt;exit_code = (BPF_CORE_READ(task, exit_code) &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    bpf_get_current_comm(&amp;e-&gt;comm, <span class="keyword">sizeof</span>(e-&gt;comm));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send data to user-space for post-processing */</span></span><br><span class="line">    bpf_ringbuf_submit(e, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是一个内核态 eBPF 程序（bootstrap.bpf.c），主要用于跟踪 exec() 和 exit() 系统调用。它通过 eBPF 程序捕获进程的创建和退出事件，并将相关信息发送到用户态程序进行处理。下面是对代码的详细解释。</p>
<p>首先，我们引入所需的头文件，定义 eBPF 程序的许可证以及两个 eBPF maps：exec_start 和 rb。exec_start 是一个哈希类型的 eBPF map，用于存储进程开始执行时的时间戳。rb 是一个环形缓冲区类型的 eBPF map，用于存储捕获的事件数据，并将其发送到用户态程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmlinux.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_core_read.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bootstrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual BSD/GPL&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">    __uint(max_entries, <span class="number">8192</span>);</span><br><span class="line">    __type(key, <span class="type">pid_t</span>);</span><br><span class="line">    __type(value, u64);</span><br><span class="line">&#125; exec_start <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_RINGBUF);</span><br><span class="line">    __uint(max_entries, <span class="number">256</span> * <span class="number">1024</span>);</span><br><span class="line">&#125; rb <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> min_duration_ns = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>接下来，我们定义了一个名为 <code>handle_exec</code> 的 eBPF 程序，它会在进程执行 exec() 系统调用时触发。首先，我们从当前进程中获取 PID，记录进程开始执行的时间戳，然后将其存储在 exec_start map 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;tp/sched/sched_process_exec&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_exec</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sched_process_exec *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    ts = bpf_ktime_get_ns();</span><br><span class="line">    bpf_map_update_elem(&amp;exec_start, &amp;pid, &amp;ts, BPF_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们从环形缓冲区 map rb 中预留一个事件结构，并填充相关数据，如进程 ID、父进程 ID、进程名等。之后，我们将这些数据发送到用户态程序进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reserve sample from BPF ringbuf</span></span><br><span class="line">e = bpf_ringbuf_reserve(&amp;rb, <span class="keyword">sizeof</span>(*e), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!e)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill out the sample with data</span></span><br><span class="line">task = (<span class="keyword">struct</span> task_struct *)bpf_get_current_task();</span><br><span class="line"></span><br><span class="line">e-&gt;exit_event = <span class="literal">false</span>;</span><br><span class="line">e-&gt;pid = pid;</span><br><span class="line">e-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);</span><br><span class="line">bpf_get_current_comm(&amp;e-&gt;comm, <span class="keyword">sizeof</span>(e-&gt;comm));</span><br><span class="line"></span><br><span class="line">fname_off = ctx-&gt;__data_loc_filename &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">bpf_probe_read_str(&amp;e-&gt;filename, <span class="keyword">sizeof</span>(e-&gt;filename), (<span class="type">void</span> *)ctx + fname_off);</span><br><span class="line"></span><br><span class="line"><span class="comment">// successfully submit it to user-space for post-processing</span></span><br><span class="line">bpf_ringbuf_submit(e, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>最后，我们定义了一个名为 handle_exit 的 eBPF 程序，它会在进程执行 exit() 系统调用时触发。首先，我们从当前进程中获取 PID 和 TID（线程 ID）。如果 PID 和 TID 不相等，说明这是一个线程退出，我们将忽略此事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;tp/sched/sched_process_exit&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_exit</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_sched_process_template* ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    id = bpf_get_current_pid_tgid();</span><br><span class="line">    pid = id &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    tid = (u32)id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ignore thread exits */</span></span><br><span class="line">    <span class="keyword">if</span> (pid != tid)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，我们查找之前存储在 exec_start map 中的进程开始执行的时间戳。如果找到了时间戳，我们将计算进程的生命周期（持续时间），然后从 exec_start map 中删除该记录。如果未找到时间戳且指定了最小持续时间，则直接返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if we recorded start of the process, calculate lifetime duration</span></span><br><span class="line">start_ts = bpf_map_lookup_elem(&amp;exec_start, &amp;pid);</span><br><span class="line"><span class="keyword">if</span> (start_ts)</span><br><span class="line">    duration_ns = bpf_ktime_get_ns() - *start_ts;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (min_duration_ns)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">bpf_map_delete_elem(&amp;exec_start, &amp;pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// if process didn&#x27;t live long enough, return early</span></span><br><span class="line"><span class="keyword">if</span> (min_duration_ns &amp;&amp; duration_ns &lt; min_duration_ns)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>然后，我们从环形缓冲区 map rb 中预留一个事件结构，并填充相关数据，如进程 ID、父进程 ID、进程名、进程持续时间等。最后，我们将这些数据发送到用户态程序进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* reserve sample from BPF ringbuf */</span></span><br><span class="line">    e = bpf_ringbuf_reserve(&amp;rb, <span class="keyword">sizeof</span>(*e), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!e)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fill out the sample with data */</span></span><br><span class="line">    task = (<span class="keyword">struct</span> task_struct *)bpf_get_current_task();</span><br><span class="line"></span><br><span class="line">    e-&gt;exit_event = <span class="literal">true</span>;</span><br><span class="line">    e-&gt;duration_ns = duration_ns;</span><br><span class="line">    e-&gt;pid = pid;</span><br><span class="line">    e-&gt;ppid = BPF_CORE_READ(task, real_parent, tgid);</span><br><span class="line">    e-&gt;exit_code = (BPF_CORE_READ(task, exit_code) &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    bpf_get_current_comm(&amp;e-&gt;comm, <span class="keyword">sizeof</span>(e-&gt;comm));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send data to user-space for post-processing */</span></span><br><span class="line">    bpf_ringbuf_submit(e, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，当进程执行 exec() 或 exit() 系统调用时，我们的 eBPF 程序会捕获相应的事件，并将详细信息发送到用户态程序进行后续处理。这使得我们可以轻松地监控进程的创建和退出，并获取有关进程的详细信息。</p>
<p>除此之外，在 bootstrap.h 中，我们还定义了和用户态交互的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */</span></span><br><span class="line"><span class="comment">/* Copyright (c) 2020 Facebook */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BOOTSTRAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BOOTSTRAP_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_COMM_LEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FILENAME_LEN 127</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">int</span> ppid;</span><br><span class="line">    <span class="type">unsigned</span> exit_code;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> duration_ns;</span><br><span class="line">    <span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line">    <span class="type">char</span> filename[MAX_FILENAME_LEN];</span><br><span class="line">    <span class="type">bool</span> exit_event;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __BOOTSTRAP_H */</span></span></span><br></pre></td></tr></table></figure>
<h5 id="用户态，bootstrap-c"><a href="#用户态，bootstrap-c" class="headerlink" title="用户态，bootstrap.c"></a>用户态，bootstrap.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause)</span></span><br><span class="line"><span class="comment">/* Copyright (c) 2020 Facebook */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;argp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/libbpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bootstrap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bootstrap.skel.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">env</span> &#123;</span></span><br><span class="line">    <span class="type">bool</span> verbose;</span><br><span class="line">    <span class="type">long</span> min_duration_ms;</span><br><span class="line">&#125; env;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *argp_program_version = <span class="string">&quot;bootstrap 0.0&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *argp_program_bug_address = <span class="string">&quot;&lt;bpf@vger.kernel.org&gt;&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> argp_program_doc[] =</span><br><span class="line"><span class="string">&quot;BPF bootstrap demo application.\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;It traces process start and exits and shows associated \n&quot;</span></span><br><span class="line"><span class="string">&quot;information (filename, process duration, PID and PPID, etc).\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;USAGE: ./bootstrap [-d &lt;min-duration-ms&gt;] [-v]\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">argp_option</span> <span class="title">opts</span>[] =</span> &#123;</span><br><span class="line">    &#123; <span class="string">&quot;verbose&quot;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="string">&quot;Verbose debug output&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;duration&quot;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&quot;DURATION-MS&quot;</span>, <span class="number">0</span>, <span class="string">&quot;Minimum process duration (ms) to report&quot;</span> &#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">error_t</span> <span class="title function_">parse_arg</span><span class="params">(<span class="type">int</span> key, <span class="type">char</span> *arg, <span class="keyword">struct</span> argp_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">        env.verbose = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        env.min_duration_ms = strtol(arg, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (errno || env.min_duration_ms &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Invalid duration: %s\n&quot;</span>, arg);</span><br><span class="line">            argp_usage(state);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ARGP_KEY_ARG:</span><br><span class="line">        argp_usage(state);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> ARGP_ERR_UNKNOWN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">argp</span> <span class="title">argp</span> =</span> &#123;</span><br><span class="line">    .options = opts,</span><br><span class="line">    .parser = parse_arg,</span><br><span class="line">    .doc = argp_program_doc,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">libbpf_print_fn</span><span class="params">(<span class="keyword">enum</span> libbpf_print_level level, <span class="type">const</span> <span class="type">char</span> *format, va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == LIBBPF_DEBUG &amp;&amp; !env.verbose)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, format, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">bool</span> exiting = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    exiting = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_event</span><span class="params">(<span class="type">void</span> *ctx, <span class="type">void</span> *data, <span class="type">size_t</span> data_sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">e</span> =</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tm</span>;</span></span><br><span class="line">    <span class="type">char</span> ts[<span class="number">32</span>];</span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line"></span><br><span class="line">    time(&amp;t);</span><br><span class="line">    tm = localtime(&amp;t);</span><br><span class="line">    strftime(ts, <span class="keyword">sizeof</span>(ts), <span class="string">&quot;%H:%M:%S&quot;</span>, tm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;exit_event) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-8s %-5s %-16s %-7d %-7d [%u]&quot;</span>,</span><br><span class="line">               ts, <span class="string">&quot;EXIT&quot;</span>, e-&gt;comm, e-&gt;pid, e-&gt;ppid, e-&gt;exit_code);</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;duration_ns)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; (%llums)&quot;</span>, e-&gt;duration_ns / <span class="number">1000000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-8s %-5s %-16s %-7d %-7d %s\n&quot;</span>,</span><br><span class="line">               ts, <span class="string">&quot;EXEC&quot;</span>, e-&gt;comm, e-&gt;pid, e-&gt;ppid, e-&gt;filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ring_buffer</span> *<span class="title">rb</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootstrap_bpf</span> *<span class="title">skel</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse command line arguments */</span></span><br><span class="line">    err = argp_parse(&amp;argp, argc, argv, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up libbpf errors and debug info callback */</span></span><br><span class="line">    libbpf_set_print(libbpf_print_fn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cleaner handling of Ctrl-C */</span></span><br><span class="line">    signal(SIGINT, sig_handler);</span><br><span class="line">    signal(SIGTERM, sig_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Load and verify BPF application */</span></span><br><span class="line">    skel = bootstrap_bpf__open();</span><br><span class="line">    <span class="keyword">if</span> (!skel) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open and load BPF skeleton\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parameterize BPF code with minimum duration parameter */</span></span><br><span class="line">    skel-&gt;rodata-&gt;min_duration_ns = env.min_duration_ms * <span class="number">1000000ULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Load &amp; verify BPF programs */</span></span><br><span class="line">    err = bootstrap_bpf__load(skel);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to load and verify BPF skeleton\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attach tracepoints */</span></span><br><span class="line">    err = bootstrap_bpf__attach(skel);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to attach BPF skeleton\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up ring buffer polling */</span></span><br><span class="line">    rb = ring_buffer__new(bpf_map__fd(skel-&gt;maps.rb), handle_event, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!rb) &#123;</span><br><span class="line">        err = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to create ring buffer\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process events */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-8s %-5s %-16s %-7s %-7s %s\n&quot;</span>,</span><br><span class="line">           <span class="string">&quot;TIME&quot;</span>, <span class="string">&quot;EVENT&quot;</span>, <span class="string">&quot;COMM&quot;</span>, <span class="string">&quot;PID&quot;</span>, <span class="string">&quot;PPID&quot;</span>, <span class="string">&quot;FILENAME/EXIT CODE&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!exiting) &#123;</span><br><span class="line">        err = ring_buffer__poll(rb, <span class="number">100</span> <span class="comment">/* timeout, ms */</span>);</span><br><span class="line">        <span class="comment">/* Ctrl-C will cause -EINTR */</span></span><br><span class="line">        <span class="keyword">if</span> (err == -EINTR) &#123;</span><br><span class="line">            err = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error polling perf buffer: %d\n&quot;</span>, err);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    <span class="comment">/* Clean up */</span></span><br><span class="line">    ring_buffer__free(rb);</span><br><span class="line">    bootstrap_bpf__destroy(skel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err &lt; <span class="number">0</span> ? -err : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个用户态程序主要用于加载、验证、附加 eBPF 程序，以及接收 eBPF 程序收集的事件数据，并将其打印出来。我们将分析一些关键部分。</p>
<p>首先，我们定义了一个 env 结构，用于存储命令行参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">env</span> &#123;</span></span><br><span class="line">    <span class="type">bool</span> verbose;</span><br><span class="line">    <span class="type">long</span> min_duration_ms;</span><br><span class="line">&#125; env;</span><br></pre></td></tr></table></figure>
<p>接下来，我们使用 argp 库来解析命令行参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">argp_option</span> <span class="title">opts</span>[] =</span> &#123;</span><br><span class="line">    &#123; <span class="string">&quot;verbose&quot;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="string">&quot;Verbose debug output&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;duration&quot;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&quot;DURATION-MS&quot;</span>, <span class="number">0</span>, <span class="string">&quot;Minimum process duration (ms) to report&quot;</span> &#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">error_t</span> <span class="title function_">parse_arg</span><span class="params">(<span class="type">int</span> key, <span class="type">char</span> *arg, <span class="keyword">struct</span> argp_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">argp</span> <span class="title">argp</span> =</span> &#123;</span><br><span class="line">    .options = opts,</span><br><span class="line">    .parser = parse_arg,</span><br><span class="line">    .doc = argp_program_doc,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>main() 函数中，首先解析命令行参数，然后设置 libbpf 的打印回调函数 libbpf_print_fn，以便在需要时输出调试信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err = argp_parse(&amp;argp, argc, argv, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">libbpf_set_print(libbpf_print_fn);</span><br></pre></td></tr></table></figure>
<p>接下来，我们打开 eBPF 脚手架（skeleton）文件，将最小持续时间参数传递给 eBPF 程序，并加载和附加 eBPF 程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">skel = bootstrap_bpf__open();</span><br><span class="line"><span class="keyword">if</span> (!skel) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to open and load BPF skeleton\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skel-&gt;rodata-&gt;min_duration_ns = env.min_duration_ms * <span class="number">1000000ULL</span>;</span><br><span class="line"></span><br><span class="line">err = bootstrap_bpf__load(skel);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to load and verify BPF skeleton\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = bootstrap_bpf__attach(skel);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to attach BPF skeleton\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们创建一个环形缓冲区（ring buffer），用于接收 eBPF 程序发送的事件数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rb = ring_buffer__new(bpf_map__fd(skel-&gt;maps.rb), handle_event, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!rb) &#123;</span><br><span class="line">    err = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to create ring buffer\n&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handle_event() 函数会处理从 eBPF 程序收到的事件。根据事件类型（进程执行或退出），它会提取并打印事件信息，如时间戳、进程名、进程 ID、父进程 ID、文件名或退出代码等。</p>
<p>最后，我们使用 ring_buffer__poll() 函数轮询环形缓冲区，处理收到的事件数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!exiting) &#123;</span><br><span class="line">    err = ring_buffer__poll(rb, <span class="number">100</span> <span class="comment">/* timeout, ms */</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当程序收到 SIGINT 或 SIGTERM 信号时，它会最后完成清理、退出操作，关闭和卸载 eBPF 程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cleanup:</span><br><span class="line"> <span class="comment">/* Clean up */</span></span><br><span class="line"> ring_buffer__free(rb);</span><br><span class="line"> bootstrap_bpf__destroy(skel);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> err &lt; <span class="number">0</span> ? -err : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h5><p>构建示例需要 clang、libelf 和 zlib。包名在不同的发行版中可能会有所不同。</p>
<p>在 Ubuntu/Debian 上，你需要执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clang libelf1 libelf-dev zlib1g-dev</span><br></pre></td></tr></table></figure>
<p>在 CentOS/Fedora 上，你需要执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install clang elfutils-libelf elfutils-libelf-devel zlib-devel</span><br></pre></td></tr></table></figure>
<h5 id="编译运行-1"><a href="#编译运行-1" class="headerlink" title="编译运行"></a>编译运行</h5><p>编译运行上述代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">  BPF      .output/bootstrap.bpf.o</span><br><span class="line">  GEN-SKEL .output/bootstrap.skel.h</span><br><span class="line">  CC       .output/bootstrap.o</span><br><span class="line">  BINARY   bootstrap</span><br><span class="line">$ sudo ./bootstrap </span><br><span class="line">[sudo] password for yunwei: </span><br><span class="line">TIME     EVENT COMM             PID     PPID    FILENAME/EXIT CODE</span><br><span class="line">03:16:41 EXEC  sh               110688  80168   /bin/sh</span><br><span class="line">03:16:41 EXEC  which            110689  110688  /usr/bin/which</span><br><span class="line">03:16:41 EXIT  which            110689  110688  [0] (0ms)</span><br><span class="line">03:16:41 EXIT  sh               110688  80168   [0] (0ms)</span><br><span class="line">03:16:41 EXEC  sh               110690  80168   /bin/sh</span><br><span class="line">03:16:41 EXEC  ps               110691  110690  /usr/bin/ps</span><br><span class="line">03:16:41 EXIT  ps               110691  110690  [0] (49ms)</span><br><span class="line">03:16:41 EXIT  sh               110690  80168   [0] (51ms)</span><br></pre></td></tr></table></figure>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>通过这个实例，我们了解了如何将 eBPF 程序与用户态程序结合使用。这种结合为开发者提供了一个强大的工具集，可以实现跨内核和用户空间的高效数据收集和处理。通过使用 eBPF 和 libbpf，您可以构建更高效、可扩展和安全的监控和性能分析工具。</p>
<h2 id="使用-eBPF-程序-profile-进行性能分析"><a href="#使用-eBPF-程序-profile-进行性能分析" class="headerlink" title="使用 eBPF 程序 profile 进行性能分析"></a>使用 eBPF 程序 profile 进行性能分析</h2><p>本教程将指导您使用 libbpf 和 eBPF 程序进行性能分析。我们将利用内核中的 perf 机制，学习如何捕获函数的执行时间以及如何查看性能数据。</p>
<p>libbpf 是一个用于与 eBPF 交互的 C 库。它提供了创建、加载和使用 eBPF 程序所需的基本功能。本教程中，我们将主要使用 libbpf 完成开发工作。perf 是 Linux 内核中的性能分析工具，允许用户测量和分析内核及用户空间程序的性能，以及获取对应的调用堆栈。它利用内核中的硬件计数器和软件事件来收集性能数据。</p>
<h3 id="eBPF-工具：profile-性能分析示例"><a href="#eBPF-工具：profile-性能分析示例" class="headerlink" title="eBPF 工具：profile 性能分析示例"></a>eBPF 工具：profile 性能分析示例</h3><p><code>profile</code> 工具基于 eBPF 实现，利用 Linux 内核中的 perf 事件进行性能分析。<code>profile</code> 工具会定期对每个处理器进行采样，以便捕获内核函数和用户空间函数的执行。它可以显示栈回溯的以下信息：</p>
<ul>
<li>地址：函数调用的内存地址</li>
<li>符号：函数名称</li>
<li>文件名：源代码文件名称</li>
<li>行号：源代码中的行号</li>
</ul>
<p>这些信息有助于开发人员定位性能瓶颈和优化代码。更进一步，可以通过这些对应的信息生成火焰图，以便更直观的查看性能数据。</p>
<p>在本示例中，可以通过 libbpf 库编译运行它（以 Ubuntu/Debian 为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br><span class="line">$ sudo apt install clang libelf1 libelf-dev zlib1g-dev</span><br><span class="line">$ make</span><br><span class="line">$ sudo ./profile </span><br><span class="line">COMM: chronyd (pid=156) @ CPU 1</span><br><span class="line">Kernel:</span><br><span class="line">  0 [&lt;ffffffff81ee9f56&gt;] _raw_spin_lock_irqsave+0x16</span><br><span class="line">  1 [&lt;ffffffff811527b4&gt;] remove_wait_queue+0x14</span><br><span class="line">  2 [&lt;ffffffff8132611d&gt;] poll_freewait+0x3d</span><br><span class="line">  3 [&lt;ffffffff81326d3f&gt;] do_select+0x7bf</span><br><span class="line">  4 [&lt;ffffffff81327af2&gt;] core_sys_select+0x182</span><br><span class="line">  5 [&lt;ffffffff81327f3a&gt;] __x64_sys_pselect6+0xea</span><br><span class="line">  6 [&lt;ffffffff81ed9e38&gt;] do_syscall_64+0x38</span><br><span class="line">  7 [&lt;ffffffff82000099&gt;] entry_SYSCALL_64_after_hwframe+0x61</span><br><span class="line">Userspace:</span><br><span class="line">  0 [&lt;00007fab187bfe09&gt;]</span><br><span class="line">  1 [&lt;000000000ee6ae98&gt;]</span><br><span class="line"></span><br><span class="line">COMM: profile (pid=9843) @ CPU 6</span><br><span class="line">No Kernel Stack</span><br><span class="line">Userspace:</span><br><span class="line">  0 [&lt;0000556deb068ac8&gt;]</span><br><span class="line">  1 [&lt;0000556dec34cad0&gt;]</span><br></pre></td></tr></table></figure>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>profile 工具由两个部分组成，内核态中的 eBPF 程序和用户态中的 <code>profile</code> 符号处理程序。<code>profile</code> 符号处理程序负责加载 eBPF 程序，以及处理 eBPF 程序输出的数据。</p>
<h4 id="内核态部分"><a href="#内核态部分" class="headerlink" title="内核态部分"></a>内核态部分</h4><p>内核态 eBPF 程序的实现逻辑主要是借助 perf event，对程序的堆栈进行定时采样，从而捕获程序的执行流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause</span></span><br><span class="line"><span class="comment">/* Copyright (c) 2022 Meta Platforms, Inc. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmlinux.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_tracing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_core_read.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;profile.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual BSD/GPL&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_RINGBUF);</span><br><span class="line">    __uint(max_entries, <span class="number">256</span> * <span class="number">1024</span>);</span><br><span class="line">&#125; events <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;perf_event&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">profile</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    <span class="type">int</span> cpu_id = bpf_get_smp_processor_id();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stacktrace_event</span> *<span class="title">event</span>;</span></span><br><span class="line">    <span class="type">int</span> cp;</span><br><span class="line"></span><br><span class="line">    event = bpf_ringbuf_reserve(&amp;events, <span class="keyword">sizeof</span>(*event), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!event)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    event-&gt;pid = pid;</span><br><span class="line">    event-&gt;cpu_id = cpu_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bpf_get_current_comm(event-&gt;comm, <span class="keyword">sizeof</span>(event-&gt;comm)))</span><br><span class="line">        event-&gt;comm[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    event-&gt;kstack_sz = bpf_get_stack(ctx, event-&gt;kstack, <span class="keyword">sizeof</span>(event-&gt;kstack), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    event-&gt;ustack_sz = bpf_get_stack(ctx, event-&gt;ustack, <span class="keyword">sizeof</span>(event-&gt;ustack), BPF_F_USER_STACK);</span><br><span class="line"></span><br><span class="line">    bpf_ringbuf_submit(event, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们将重点讲解内核态代码的关键部分。</p>
<p>定义 eBPF maps <code>events</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_RINGBUF);</span><br><span class="line">    __uint(max_entries, <span class="number">256</span> * <span class="number">1024</span>);</span><br><span class="line">&#125; events <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个类型为 <code>BPF_MAP_TYPE_RINGBUF</code> 的 eBPF maps 。Ring Buffer 是一种高性能的循环缓冲区，用于在内核和用户空间之间传输数据。<code>max_entries</code> 设置了 Ring Buffer 的最大大小。</p>
<p>定义 <code>perf_event</code> eBPF 程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;perf_event&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">profile</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>profile</code> 的 eBPF 程序，它将在 perf 事件触发时执行。</p>
<p>获取进程 ID 和 CPU ID：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line"><span class="type">int</span> cpu_id = bpf_get_smp_processor_id();</span><br></pre></td></tr></table></figure>
<p><code>bpf_get_current_pid_tgid()</code> 函数返回当前进程的 PID 和 TID，通过右移 32 位，我们得到 PID。<code>bpf_get_smp_processor_id()</code> 函数返回当前 CPU 的 ID。</p>
<p>预留 Ring Buffer 空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event = bpf_ringbuf_reserve(&amp;events, <span class="keyword">sizeof</span>(*event), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!event)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>通过 <code>bpf_ringbuf_reserve()</code> 函数预留 Ring Buffer 空间，用于存储采集的栈信息。若预留失败，返回错误.</p>
<p>获取当前进程名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bpf_get_current_comm(event-&gt;comm, <span class="keyword">sizeof</span>(event-&gt;comm)))</span><br><span class="line">    event-&gt;comm[<span class="number">0</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>使用 <code>bpf_get_current_comm()</code> 函数获取当前进程名并将其存储到 <code>event-&gt;comm</code>。</p>
<p>获取内核栈信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event-&gt;kstack_sz = bpf_get_stack(ctx, event-&gt;kstack, <span class="keyword">sizeof</span>(event-&gt;kstack), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>使用 <code>bpf_get_stack()</code> 函数获取内核栈信息。将结果存储在 <code>event-&gt;kstack</code>，并将其大小存储在 <code>event-&gt;kstack_sz</code>。</p>
<p>获取用户空间栈信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event-&gt;ustack_sz = bpf_get_stack(ctx, event-&gt;ustack, <span class="keyword">sizeof</span>(event-&gt;ustack), BPF_F_USER_STACK);</span><br></pre></td></tr></table></figure>
<p>同样使用 <code>bpf_get_stack()</code> 函数，但传递 <code>BPF_F_USER_STACK</code> 标志以获取用户空间栈信息。将结果存储在 <code>event-&gt;ustack</code>，并将其大小存储在 <code>event-&gt;ustack_sz</code>。</p>
<p>将事件提交到 Ring Buffer：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bpf_ringbuf_submit(event, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>最后，使用 <code>bpf_ringbuf_submit()</code> 函数将事件提交到 Ring Buffer，以便用户空间程序可以读取和处理。</p>
<p>这个内核态 eBPF 程序通过定期采样程序的内核栈和用户空间栈来捕获程序的执行流程。这些数据将存储在 Ring Buffer 中，以便用户态的 <code>profile</code> 程序能读取。</p>
<h4 id="用户态部分"><a href="#用户态部分" class="headerlink" title="用户态部分"></a>用户态部分</h4><p>这段代码主要负责为每个在线 CPU 设置 perf event 并附加 eBPF 程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">perf_event_open</span><span class="params">(<span class="keyword">struct</span> perf_event_attr *hw_event, <span class="type">pid_t</span> pid,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> cpu, <span class="type">int</span> group_fd, <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = syscall(__NR_perf_event_open, hw_event, pid, cpu, group_fd, flags);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (cpu = <span class="number">0</span>; cpu &lt; num_cpus; cpu++) &#123;</span><br><span class="line">        <span class="comment">/* skip offline/not present CPUs */</span></span><br><span class="line">        <span class="keyword">if</span> (cpu &gt;= num_online_cpus || !online_mask[cpu])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set up performance monitoring on a CPU/Core */</span></span><br><span class="line">        pefd = perf_event_open(&amp;attr, pid, cpu, <span class="number">-1</span>, PERF_FLAG_FD_CLOEXEC);</span><br><span class="line">        <span class="keyword">if</span> (pefd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fail to set up performance monitor on a CPU/Core\n&quot;</span>);</span><br><span class="line">            err = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">        pefds[cpu] = pefd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Attach a BPF program on a CPU */</span></span><br><span class="line">        links[cpu] = bpf_program__attach_perf_event(skel-&gt;progs.profile, pefd);</span><br><span class="line">        <span class="keyword">if</span> (!links[cpu]) &#123;</span><br><span class="line">            err = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>perf_event_open</code> 这个函数是一个对 <code>perf_event_open</code> 系统调用的封装。它接收一个 perf_event_attr 结构体指针，用于指定 perf event 的类型和属性。pid 参数用于指定要监控的进程 ID（-1 表示监控所有进程），cpu 参数用于指定要监控的 CPU。group_fd 参数用于将 perf event 分组，这里我们使用 -1，表示不需要分组。flags 参数用于设置一些标志，这里我们使用 PERF_FLAG_FD_CLOEXEC 以确保在执行 exec 系列系统调用时关闭文件描述符。</p>
<p>在 main 函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (cpu = <span class="number">0</span>; cpu &lt; num_cpus; cpu++) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个循环针对每个在线 CPU 设置 perf event 并附加 eBPF 程序。首先，它会检查当前 CPU 是否在线，如果不在线则跳过。然后，使用 <code>perf_event_open()</code> 函数为当前 CPU 设置 perf event，并将返回的文件描述符存储在 pefds 数组中。最后，使用 <code>bpf_program__attach_perf_event()</code> 函数将 eBPF 程序附加到 perf event。links 数组用于存储每个 CPU 上的 BPF 链接，以便在程序结束时销毁它们。</p>
<p>通过这种方式，用户态程序为每个在线 CPU 设置 perf event，并将 eBPF 程序附加到这些 perf event 上，从而实现对系统中所有在线 CPU 的监控。</p>
<p>以下这两个函数分别用于显示栈回溯和处理从 ring buffer 接收到的事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_stack_trace</span><span class="params">(__u64 *<span class="built_in">stack</span>, <span class="type">int</span> stack_sz, <span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">blazesym_result</span> *<span class="title">result</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">blazesym_csym</span> *<span class="title">sym</span>;</span></span><br><span class="line">    sym_src_cfg src;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid) &#123;</span><br><span class="line">        src.src_type = SRC_T_PROCESS;</span><br><span class="line">        src.params.process.pid = pid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        src.src_type = SRC_T_KERNEL;</span><br><span class="line">        src.params.kernel.kallsyms = <span class="literal">NULL</span>;</span><br><span class="line">        src.params.kernel.kernel_image = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = blazesym_symbolize(symbolizer, &amp;src, <span class="number">1</span>, (<span class="type">const</span> <span class="type">uint64_t</span> *)<span class="built_in">stack</span>, stack_sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; stack_sz; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result || result-&gt;size &lt;= i || !result-&gt;entries[i].size) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;  %d [&lt;%016llx&gt;]\n&quot;</span>, i, <span class="built_in">stack</span>[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result-&gt;entries[i].size == <span class="number">1</span>) &#123;</span><br><span class="line">            sym = &amp;result-&gt;entries[i].syms[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (sym-&gt;path &amp;&amp; sym-&gt;path[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;  %d [&lt;%016llx&gt;] %s+0x%llx %s:%ld\n&quot;</span>,</span><br><span class="line">                       i, <span class="built_in">stack</span>[i], sym-&gt;symbol,</span><br><span class="line">                       <span class="built_in">stack</span>[i] - sym-&gt;start_address,</span><br><span class="line">                       sym-&gt;path, sym-&gt;line_no);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;  %d [&lt;%016llx&gt;] %s+0x%llx\n&quot;</span>,</span><br><span class="line">                       i, <span class="built_in">stack</span>[i], sym-&gt;symbol,</span><br><span class="line">                       <span class="built_in">stack</span>[i] - sym-&gt;start_address);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  %d [&lt;%016llx&gt;]\n&quot;</span>, i, <span class="built_in">stack</span>[i]);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; result-&gt;entries[i].size; j++) &#123;</span><br><span class="line">            sym = &amp;result-&gt;entries[i].syms[j];</span><br><span class="line">            <span class="keyword">if</span> (sym-&gt;path &amp;&amp; sym-&gt;path[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;        %s+0x%llx %s:%ld\n&quot;</span>,</span><br><span class="line">                       sym-&gt;symbol, <span class="built_in">stack</span>[i] - sym-&gt;start_address,</span><br><span class="line">                       sym-&gt;path, sym-&gt;line_no);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;        %s+0x%llx\n&quot;</span>, sym-&gt;symbol,</span><br><span class="line">                       <span class="built_in">stack</span>[i] - sym-&gt;start_address);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    blazesym_result_free(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Receive events from the ring buffer. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">event_handler</span><span class="params">(<span class="type">void</span> *_ctx, <span class="type">void</span> *data, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stacktrace_event</span> *<span class="title">event</span> =</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event-&gt;kstack_sz &lt;= <span class="number">0</span> &amp;&amp; event-&gt;ustack_sz &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;COMM: %s (pid=%d) @ CPU %d\n&quot;</span>, event-&gt;comm, event-&gt;pid, event-&gt;cpu_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event-&gt;kstack_sz &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Kernel:\n&quot;</span>);</span><br><span class="line">        show_stack_trace(event-&gt;kstack, event-&gt;kstack_sz / <span class="keyword">sizeof</span>(__u64), <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Kernel Stack\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event-&gt;ustack_sz &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Userspace:\n&quot;</span>);</span><br><span class="line">        show_stack_trace(event-&gt;ustack, event-&gt;ustack_sz / <span class="keyword">sizeof</span>(__u64), event-&gt;pid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Userspace Stack\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>show_stack_trace()</code> 函数用于显示内核或用户空间的栈回溯。它接收一个 stack 参数，是一个指向内核或用户空间栈的指针，stack_sz 参数表示栈的大小，pid 参数表示要显示的进程的 ID（当显示内核栈时，设置为 0）。函数中首先根据 pid 参数确定栈的来源（内核或用户空间），然后调用 blazesym_symbolize() 函数将栈中的地址解析为符号名和源代码位置。最后，遍历解析结果，输出符号名和源代码位置信息。</p>
<p><code>event_handler()</code> 函数用于处理从 ring buffer 接收到的事件。它接收一个 data 参数，指向 ring buffer 中的数据，size 参数表示数据的大小。函数首先将 data 指针转换为 stacktrace_event 结构体指针，然后检查内核和用户空间栈的大小。如果栈为空，则直接返回。接下来，函数输出进程名称、进程 ID 和 CPU ID 信息。然后分别显示内核栈和用户空间栈的回溯。调用 show_stack_trace() 函数时，分别传入内核栈和用户空间栈的地址、大小和进程 ID。</p>
<p>这两个函数作为 eBPF profile 工具的一部分，用于显示和处理 eBPF 程序收集到的栈回溯信息，帮助用户了解程序的运行情况和性能瓶颈。</p>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>通过本篇 eBPF 入门实践教程，我们学习了如何使用 eBPF 程序进行性能分析。在这个过程中，我们详细讲解了如何创建 eBPF 程序，监控进程的性能，并从 ring buffer 中获取数据以分析栈回溯。我们还学习了如何使用 perf_event_open() 函数设置性能监控，并将 BPF 程序附加到性能事件上。在本教程中，我们还展示了如何编写 eBPF 程序来捕获进程的内核和用户空间栈信息，进而分析程序性能瓶颈。通过这个例子，您可以了解到 eBPF 在性能分析方面的强大功能。</p>
<h2 id="统计-TCP-连接延时，并使用-libbpf-在用户态处理数据"><a href="#统计-TCP-连接延时，并使用-libbpf-在用户态处理数据" class="headerlink" title="统计 TCP 连接延时，并使用 libbpf 在用户态处理数据"></a>统计 TCP 连接延时，并使用 libbpf 在用户态处理数据</h2><p>eBPF (Extended Berkeley Packet Filter) 是一项强大的网络和性能分析工具，被应用在 Linux 内核上。eBPF 允许开发者动态加载、更新和运行用户定义的代码，而无需重启内核或更改内核源代码。</p>
<p>本文是 eBPF 入门开发实践教程的第十三篇，主要介绍如何使用 eBPF 统计 TCP 连接延时，并使用 libbpf 在用户态处理数据。</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在进行后端开发时，不论使用何种编程语言，我们都常常需要调用 MySQL、Redis 等数据库，或执行一些 RPC 远程调用，或者调用其他的 RESTful API。这些调用的底层，通常都是基于 TCP 协议进行的。原因是 TCP 协议具有可靠连接、错误重传、拥塞控制等优点，因此在网络传输层协议中，TCP 的应用广泛程度超过了 UDP。然而，TCP 也有一些缺点，如建立连接的延时较长。因此，也出现了一些替代方案，例如 QUIC（Quick UDP Internet Connections，快速 UDP 网络连接）。</p>
<p>分析 TCP 连接延时对网络性能分析、优化以及故障排查都非常有用。</p>
<h3 id="tcpconnlat-工具概述"><a href="#tcpconnlat-工具概述" class="headerlink" title="tcpconnlat 工具概述"></a>tcpconnlat 工具概述</h3><p><code>tcpconnlat</code> 这个工具能够跟踪内核中执行活动 TCP 连接的函数（如通过 <code>connect()</code> 系统调用），并测量并显示连接延时，即从发送 SYN 到收到响应包的时间。</p>
<h4 id="TCP-连接原理"><a href="#TCP-连接原理" class="headerlink" title="TCP 连接原理"></a>TCP 连接原理</h4><p>TCP 连接的建立过程，常被称为“三次握手”（Three-way Handshake）。以下是整个过程的步骤：</p>
<ol>
<li>客户端向服务器发送 SYN 包：客户端通过 <code>connect()</code> 系统调用发出 SYN。这涉及到本地的系统调用以及软中断的 CPU 时间开销。</li>
<li>SYN 包传送到服务器：这是一次网络传输，涉及到的时间取决于网络延迟。</li>
<li>服务器处理 SYN 包：服务器内核通过软中断接收包，然后将其放入半连接队列，并发送 SYN/ACK 响应。这主要涉及 CPU 时间开销。</li>
<li>SYN/ACK 包传送到客户端：这是另一次网络传输。</li>
<li>客户端处理 SYN/ACK：客户端内核接收并处理 SYN/ACK 包，然后发送 ACK。这主要涉及软中断处理开销。</li>
<li>ACK 包传送到服务器：这是第三次网络传输。</li>
<li>服务器接收 ACK：服务器内核接收并处理 ACK，然后将对应的连接从半连接队列移动到全连接队列。这涉及到一次软中断的 CPU 开销。</li>
<li>唤醒服务器端用户进程：被 <code>accept()</code> 系统调用阻塞的用户进程被唤醒，然后从全连接队列中取出来已经建立好的连接。这涉及一次上下文切换的CPU开销。</li>
</ol>
<p>完整的流程图如下所示：</p>
<p><img src="1365470-20211013190707738-1545406557.png" alt="tcpconnlat1"></p>
<p>在客户端视角，在正常情况下一次TCP连接总的耗时也就就大约是一次网络RTT的耗时。但在某些情况下，可能会导致连接时的网络传输耗时上涨、CPU处理开销增加、甚至是连接失败。这种时候在发现延时过长之后，就可以结合其他信息进行分析。</p>
<h3 id="tcpconnlat-的-eBPF-实现"><a href="#tcpconnlat-的-eBPF-实现" class="headerlink" title="tcpconnlat 的 eBPF 实现"></a>tcpconnlat 的 eBPF 实现</h3><p>为了理解 TCP 的连接建立过程，我们需要理解 Linux 内核在处理 TCP 连接时所使用的两个队列：</p>
<ul>
<li>半连接队列（SYN 队列）：存储那些正在进行三次握手操作的 TCP 连接，服务器收到 SYN 包后，会将该连接信息存储在此队列中。</li>
<li>全连接队列（Accept 队列）：存储已经完成三次握手，等待应用程序调用 <code>accept()</code> 函数的 TCP 连接。服务器在收到 ACK 包后，会创建一个新的连接并将其添加到此队列。</li>
</ul>
<p>理解了这两个队列的用途，我们就可以开始探究 tcpconnlat 的具体实现。tcpconnlat 的实现可以分为内核态和用户态两个部分，其中包括了几个主要的跟踪点：<code>tcp_v4_connect</code>, <code>tcp_v6_connect</code> 和 <code>tcp_rcv_state_process</code>。</p>
<p>这些跟踪点主要位于内核中的 TCP/IP 网络栈。当执行相关的系统调用或内核函数时，这些跟踪点会被激活，从而触发 eBPF 程序的执行。这使我们能够捕获和测量 TCP 连接建立的整个过程。</p>
<p>让我们先来看一下这些挂载点的源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;kprobe/tcp_v4_connect&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_KPROBE</span><span class="params">(tcp_v4_connect, <span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> trace_connect(sk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;kprobe/tcp_v6_connect&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_KPROBE</span><span class="params">(tcp_v6_connect, <span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> trace_connect(sk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;kprobe/tcp_rcv_state_process&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_KPROBE</span><span class="params">(tcp_rcv_state_process, <span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> handle_tcp_rcv_state_process(ctx, sk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码展示了三个内核探针（kprobe）的定义。<code>tcp_v4_connect</code> 和 <code>tcp_v6_connect</code> 在对应的 IPv4 和 IPv6 连接被初始化时被触发，调用 <code>trace_connect()</code> 函数，而 <code>tcp_rcv_state_process</code> 在内核处理 TCP 连接状态变化时被触发，调用 <code>handle_tcp_rcv_state_process()</code> 函数。</p>
<p>接下来的部分将分为两大块：一部分是对这些挂载点内核态部分的分析，我们将解读内核源代码来详细说明这些函数如何工作；另一部分是用户态的分析，将关注 eBPF 程序如何收集这些挂载点的数据，以及如何与用户态程序进行交互。</p>
<h4 id="tcp-v4-connect-函数解析"><a href="#tcp-v4-connect-函数解析" class="headerlink" title="tcp_v4_connect 函数解析"></a>tcp_v4_connect 函数解析</h4><p><code>tcp_v4_connect</code>函数是Linux内核处理TCP的IPv4连接请求的主要方式。当用户态程序通过<code>socket</code>系统调用创建了一个套接字后，接着通过<code>connect</code>系统调用尝试连接到远程服务器，此时就会触发<code>tcp_v4_connect</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">/* This will initiate an outgoing connection. */</span><br><span class="line">int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span><br><span class="line">&#123;</span><br><span class="line">  struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;</span><br><span class="line">  struct inet_timewait_death_row *tcp_death_row;</span><br><span class="line">  struct inet_sock *inet = inet_sk(sk);</span><br><span class="line">  struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">  struct ip_options_rcu *inet_opt;</span><br><span class="line">  struct net *net = sock_net(sk);</span><br><span class="line">  __be16 orig_sport, orig_dport;</span><br><span class="line">  __be32 daddr, nexthop;</span><br><span class="line">  struct flowi4 *fl4;</span><br><span class="line">  struct rtable *rt;</span><br><span class="line">  int err;</span><br><span class="line"></span><br><span class="line">  if (addr_len &lt; sizeof(struct sockaddr_in))</span><br><span class="line">    return -EINVAL;</span><br><span class="line"></span><br><span class="line">  if (usin-&gt;sin_family != AF_INET)</span><br><span class="line">    return -EAFNOSUPPORT;</span><br><span class="line"></span><br><span class="line">  nexthop = daddr = usin-&gt;sin_addr.s_addr;</span><br><span class="line">  inet_opt = rcu_dereference_protected(inet-&gt;inet_opt,</span><br><span class="line">               lockdep_sock_is_held(sk));</span><br><span class="line">  if (inet_opt &amp;&amp; inet_opt-&gt;opt.srr) &#123;</span><br><span class="line">    if (!daddr)</span><br><span class="line">      return -EINVAL;</span><br><span class="line">    nexthop = inet_opt-&gt;opt.faddr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  orig_sport = inet-&gt;inet_sport;</span><br><span class="line">  orig_dport = usin-&gt;sin_port;</span><br><span class="line">  fl4 = &amp;inet-&gt;cork.fl.u.ip4;</span><br><span class="line">  rt = ip_route_connect(fl4, nexthop, inet-&gt;inet_saddr,</span><br><span class="line">            sk-&gt;sk_bound_dev_if, IPPROTO_TCP, orig_sport,</span><br><span class="line">            orig_dport, sk);</span><br><span class="line">  if (IS_ERR(rt)) &#123;</span><br><span class="line">    err = PTR_ERR(rt);</span><br><span class="line">    if (err == -ENETUNREACH)</span><br><span class="line">      IP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES);</span><br><span class="line">    return err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (rt-&gt;rt_flags &amp; (RTCF_MULTICAST | RTCF_BROADCAST)) &#123;</span><br><span class="line">    ip_rt_put(rt);</span><br><span class="line">    return -ENETUNREACH;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!inet_opt || !inet_opt-&gt;opt.srr)</span><br><span class="line">    daddr = fl4-&gt;daddr;</span><br><span class="line"></span><br><span class="line">  tcp_death_row = &amp;sock_net(sk)-&gt;ipv4.tcp_death_row;</span><br><span class="line"></span><br><span class="line">  if (!inet-&gt;inet_saddr) &#123;</span><br><span class="line">    err = inet_bhash2_update_saddr(sk,  &amp;fl4-&gt;saddr, AF_INET);</span><br><span class="line">    if (err) &#123;</span><br><span class="line">      ip_rt_put(rt);</span><br><span class="line">      return err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    sk_rcv_saddr_set(sk, inet-&gt;inet_saddr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; inet-&gt;inet_daddr != daddr) &#123;</span><br><span class="line">    /* Reset inherited state */</span><br><span class="line">    tp-&gt;rx_opt.ts_recent    = 0;</span><br><span class="line">    tp-&gt;rx_opt.ts_recent_stamp = 0;</span><br><span class="line">    if (likely(!tp-&gt;repair))</span><br><span class="line">      WRITE_ONCE(tp-&gt;write_seq, 0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inet-&gt;inet_dport = usin-&gt;sin_port;</span><br><span class="line">  sk_daddr_set(sk, daddr);</span><br><span class="line"></span><br><span class="line">  inet_csk(sk)-&gt;icsk_ext_hdr_len = 0;</span><br><span class="line">  if (inet_opt)</span><br><span class="line">    inet_csk(sk)-&gt;icsk_ext_hdr_len = inet_opt-&gt;opt.optlen;</span><br><span class="line"></span><br><span class="line">  tp-&gt;rx_opt.mss_clamp = TCP_MSS_DEFAULT;</span><br><span class="line"></span><br><span class="line">  /* Socket identity is still unknown (sport may be zero).</span><br><span class="line">   * However we set state to SYN-SENT and not releasing socket</span><br><span class="line">   * lock select source port, enter ourselves into the hash tables and</span><br><span class="line">   * complete initialization after this.</span><br><span class="line">   */</span><br><span class="line">  tcp_set_state(sk, TCP_SYN_SENT);</span><br><span class="line">  err = inet_hash_connect(tcp_death_row, sk);</span><br><span class="line">  if (err)</span><br><span class="line">    goto failure;</span><br><span class="line"></span><br><span class="line">  sk_set_txhash(sk);</span><br><span class="line"></span><br><span class="line">  rt = ip_route_newports(fl4, rt, orig_sport, orig_dport,</span><br><span class="line">             inet-&gt;inet_sport, inet-&gt;inet_dport, sk);</span><br><span class="line">  if (IS_ERR(rt)) &#123;</span><br><span class="line">    err = PTR_ERR(rt);</span><br><span class="line">    rt = NULL;</span><br><span class="line">    goto failure;</span><br><span class="line">  &#125;</span><br><span class="line">  /* OK, now commit destination to socket.  */</span><br><span class="line">  sk-&gt;sk_gso_type = SKB_GSO_TCPV4;</span><br><span class="line">  sk_setup_caps(sk, &amp;rt-&gt;dst);</span><br><span class="line">  rt = NULL;</span><br><span class="line"></span><br><span class="line">  if (likely(!tp-&gt;repair)) &#123;</span><br><span class="line">    if (!tp-&gt;write_seq)</span><br><span class="line">      WRITE_ONCE(tp-&gt;write_seq,</span><br><span class="line">           secure_tcp_seq(inet-&gt;inet_saddr,</span><br><span class="line">              inet-&gt;inet_daddr,</span><br><span class="line">              inet-&gt;inet_sport,</span><br><span class="line">              usin-&gt;sin_port));</span><br><span class="line">    tp-&gt;tsoffset = secure_tcp_ts_off(net, inet-&gt;inet_saddr,</span><br><span class="line">             inet-&gt;inet_daddr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inet-&gt;inet_id = get_random_u16();</span><br><span class="line"></span><br><span class="line">  if (tcp_fastopen_defer_connect(sk, &amp;err))</span><br><span class="line">    return err;</span><br><span class="line">  if (err)</span><br><span class="line">    goto failure;</span><br><span class="line"></span><br><span class="line">  err = tcp_connect(sk);</span><br><span class="line"></span><br><span class="line">  if (err)</span><br><span class="line">    goto failure;</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">failure:</span><br><span class="line">  /*</span><br><span class="line">   * This unhashes the socket and releases the local port,</span><br><span class="line">   * if necessary.</span><br><span class="line">   */</span><br><span class="line">  tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line">  inet_bhash2_reset_saddr(sk);</span><br><span class="line">  ip_rt_put(rt);</span><br><span class="line">  sk-&gt;sk_route_caps = 0;</span><br><span class="line">  inet-&gt;inet_dport = 0;</span><br><span class="line">  return err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tcp_v4_connect);</span><br></pre></td></tr></table></figure>
<p>参考链接：<a href="https://gitee.com/link?target=https%3A%2F%2Felixir.bootlin.com%2Flinux%2Flatest%2Fsource%2Fnet%2Fipv4%2Ftcp_ipv4.c%23L340">https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp_ipv4.c#L340</a></p>
<p>接下来，我们一步步分析这个函数：</p>
<p>首先，这个函数接收三个参数：一个套接字指针<code>sk</code>，一个指向套接字地址结构的指针<code>uaddr</code>和地址的长度<code>addr_len</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span><br></pre></td></tr></table></figure>
<p>函数一开始就进行了参数检查，确认地址长度正确，而且地址的协议族必须是IPv4。不满足这些条件会导致函数返回错误。</p>
<p>接下来，函数获取目标地址，如果设置了源路由选项（这是一个高级的IP特性，通常不会被使用），那么它还会获取源路由的下一跳地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nexthop = daddr = usin-&gt;sin_addr.s_addr;</span><br><span class="line">inet_opt = rcu_dereference_protected(inet-&gt;inet_opt,</span><br><span class="line">             lockdep_sock_is_held(sk));</span><br><span class="line">if (inet_opt &amp;&amp; inet_opt-&gt;opt.srr) &#123;</span><br><span class="line">  if (!daddr)</span><br><span class="line">    return -EINVAL;</span><br><span class="line">  nexthop = inet_opt-&gt;opt.faddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，使用这些信息来寻找一个路由到目标地址的路由项。如果不能找到路由项或者路由项指向一个多播或广播地址，函数返回错误。</p>
<p>接下来，它更新了源地址，处理了一些TCP时间戳选项的状态，并设置了目标端口和地址。之后，它更新了一些其他的套接字和TCP选项，并设置了连接状态为<code>SYN-SENT</code>。</p>
<p>然后，这个函数使用<code>inet_hash_connect</code>函数尝试将套接字添加到已连接的套接字的散列表中。如果这步失败，它会恢复套接字的状态并返回错误。</p>
<p>如果前面的步骤都成功了，接着，使用新的源和目标端口来更新路由项。如果这步失败，它会清理资源并返回错误。</p>
<p>接下来，它提交目标信息到套接字，并为之后的分段偏移选择一个安全的随机值。</p>
<p>然后，函数尝试使用TCP Fast Open（TFO）进行连接，如果不能使用TFO或者TFO尝试失败，它会使用普通的TCP三次握手进行连接。</p>
<p>最后，如果上面的步骤都成功了，函数返回成功，否则，它会清理所有资源并返回错误。</p>
<p>总的来说，<code>tcp_v4_connect</code>函数是一个处理TCP连接请求的复杂函数，它处理了很多情况，包括参数检查、路由查找、源地址选择、源路由、TCP选项处理、TCP Fast Open，等等。它的主要目标是尽可能安全和有效地建立TCP连接。</p>
<h4 id="内核态代码"><a href="#内核态代码" class="headerlink" title="内核态代码"></a>内核态代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-2.0</span><br><span class="line">// Copyright (c) 2020 Wenbo Zhang</span><br><span class="line">#include &lt;vmlinux.h&gt;</span><br><span class="line">#include &lt;bpf/bpf_helpers.h&gt;</span><br><span class="line">#include &lt;bpf/bpf_core_read.h&gt;</span><br><span class="line">#include &lt;bpf/bpf_tracing.h&gt;</span><br><span class="line">#include &quot;tcpconnlat.h&quot;</span><br><span class="line"></span><br><span class="line">#define AF_INET    2</span><br><span class="line">#define AF_INET6   10</span><br><span class="line"></span><br><span class="line">const volatile __u64 targ_min_us = 0;</span><br><span class="line">const volatile pid_t targ_tgid = 0;</span><br><span class="line"></span><br><span class="line">struct piddata &#123;</span><br><span class="line">  char comm[TASK_COMM_LEN];</span><br><span class="line">  u64 ts;</span><br><span class="line">  u32 tgid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">  __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">  __uint(max_entries, 4096);</span><br><span class="line">  __type(key, struct sock *);</span><br><span class="line">  __type(value, struct piddata);</span><br><span class="line">&#125; start SEC(&quot;.maps&quot;);</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">  __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);</span><br><span class="line">  __uint(key_size, sizeof(u32));</span><br><span class="line">  __uint(value_size, sizeof(u32));</span><br><span class="line">&#125; events SEC(&quot;.maps&quot;);</span><br><span class="line"></span><br><span class="line">static int trace_connect(struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">  u32 tgid = bpf_get_current_pid_tgid() &gt;&gt; 32;</span><br><span class="line">  struct piddata piddata = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  if (targ_tgid &amp;&amp; targ_tgid != tgid)</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">  bpf_get_current_comm(&amp;piddata.comm, sizeof(piddata.comm));</span><br><span class="line">  piddata.ts = bpf_ktime_get_ns();</span><br><span class="line">  piddata.tgid = tgid;</span><br><span class="line">  bpf_map_update_elem(&amp;start, &amp;sk, &amp;piddata, 0);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int handle_tcp_rcv_state_process(void *ctx, struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">  struct piddata *piddatap;</span><br><span class="line">  struct event event = &#123;&#125;;</span><br><span class="line">  s64 delta;</span><br><span class="line">  u64 ts;</span><br><span class="line"></span><br><span class="line">  if (BPF_CORE_READ(sk, __sk_common.skc_state) != TCP_SYN_SENT)</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">  piddatap = bpf_map_lookup_elem(&amp;start, &amp;sk);</span><br><span class="line">  if (!piddatap)</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">  ts = bpf_ktime_get_ns();</span><br><span class="line">  delta = (s64)(ts - piddatap-&gt;ts);</span><br><span class="line">  if (delta &lt; 0)</span><br><span class="line">    goto cleanup;</span><br><span class="line"></span><br><span class="line">  event.delta_us = delta / 1000U;</span><br><span class="line">  if (targ_min_us &amp;&amp; event.delta_us &lt; targ_min_us)</span><br><span class="line">    goto cleanup;</span><br><span class="line">  __builtin_memcpy(&amp;event.comm, piddatap-&gt;comm,</span><br><span class="line">      sizeof(event.comm));</span><br><span class="line">  event.ts_us = ts / 1000;</span><br><span class="line">  event.tgid = piddatap-&gt;tgid;</span><br><span class="line">  event.lport = BPF_CORE_READ(sk, __sk_common.skc_num);</span><br><span class="line">  event.dport = BPF_CORE_READ(sk, __sk_common.skc_dport);</span><br><span class="line">  event.af = BPF_CORE_READ(sk, __sk_common.skc_family);</span><br><span class="line">  if (event.af == AF_INET) &#123;</span><br><span class="line">    event.saddr_v4 = BPF_CORE_READ(sk, __sk_common.skc_rcv_saddr);</span><br><span class="line">    event.daddr_v4 = BPF_CORE_READ(sk, __sk_common.skc_daddr);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    BPF_CORE_READ_INTO(&amp;event.saddr_v6, sk,</span><br><span class="line">        __sk_common.skc_v6_rcv_saddr.in6_u.u6_addr32);</span><br><span class="line">    BPF_CORE_READ_INTO(&amp;event.daddr_v6, sk,</span><br><span class="line">        __sk_common.skc_v6_daddr.in6_u.u6_addr32);</span><br><span class="line">  &#125;</span><br><span class="line">  bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU,</span><br><span class="line">      &amp;event, sizeof(event));</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">  bpf_map_delete_elem(&amp;start, &amp;sk);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(&quot;kprobe/tcp_v4_connect&quot;)</span><br><span class="line">int BPF_KPROBE(tcp_v4_connect, struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">  return trace_connect(sk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(&quot;kprobe/tcp_v6_connect&quot;)</span><br><span class="line">int BPF_KPROBE(tcp_v6_connect, struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">  return trace_connect(sk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(&quot;kprobe/tcp_rcv_state_process&quot;)</span><br><span class="line">int BPF_KPROBE(tcp_rcv_state_process, struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">  return handle_tcp_rcv_state_process(ctx, sk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(&quot;fentry/tcp_v4_connect&quot;)</span><br><span class="line">int BPF_PROG(fentry_tcp_v4_connect, struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">  return trace_connect(sk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(&quot;fentry/tcp_v6_connect&quot;)</span><br><span class="line">int BPF_PROG(fentry_tcp_v6_connect, struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">  return trace_connect(sk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(&quot;fentry/tcp_rcv_state_process&quot;)</span><br><span class="line">int BPF_PROG(fentry_tcp_rcv_state_process, struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">  return handle_tcp_rcv_state_process(ctx, sk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char LICENSE[] SEC(&quot;license&quot;) = &quot;GPL&quot;;</span><br></pre></td></tr></table></figure>
<p>这个eBPF（Extended Berkeley Packet Filter）程序主要用来监控并收集TCP连接的建立时间，即从发起TCP连接请求(<code>connect</code>系统调用)到连接建立完成(SYN-ACK握手过程完成)的时间间隔。这对于监测网络延迟、服务性能分析等方面非常有用。</p>
<p>首先，定义了两个eBPF maps：<code>start</code>和<code>events</code>。<code>start</code>是一个哈希表，用于存储发起连接请求的进程信息和时间戳，而<code>events</code>是一个<code>PERF_EVENT_ARRAY</code>类型的map，用于将事件数据传输到用户态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">  __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">  __uint(max_entries, 4096);</span><br><span class="line">  __type(key, struct sock *);</span><br><span class="line">  __type(value, struct piddata);</span><br><span class="line">&#125; start SEC(&quot;.maps&quot;);</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">  __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);</span><br><span class="line">  __uint(key_size, sizeof(u32));</span><br><span class="line">  __uint(value_size, sizeof(u32));</span><br><span class="line">&#125; events SEC(&quot;.maps&quot;);</span><br></pre></td></tr></table></figure>
<p>在<code>tcp_v4_connect</code>和<code>tcp_v6_connect</code>的kprobe处理函数<code>trace_connect</code>中，会记录下发起连接请求的进程信息（进程名、进程ID和当前时间戳），并以socket结构作为key，存储到<code>start</code>这个map中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static int trace_connect(struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">  u32 tgid = bpf_get_current_pid_tgid() &gt;&gt; 32;</span><br><span class="line">  struct piddata piddata = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  if (targ_tgid &amp;&amp; targ_tgid != tgid)</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">  bpf_get_current_comm(&amp;piddata.comm, sizeof(piddata.comm));</span><br><span class="line">  piddata.ts = bpf_ktime_get_ns();</span><br><span class="line">  piddata.tgid = tgid;</span><br><span class="line">  bpf_map_update_elem(&amp;start, &amp;sk, &amp;piddata, 0);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当TCP状态机处理到SYN-ACK包，即连接建立的时候，会触发<code>tcp_rcv_state_process</code>的kprobe处理函数<code>handle_tcp_rcv_state_process</code>。在这个函数中，首先检查socket的状态是否为<code>SYN-SENT</code>，如果是，会从<code>start</code>这个map中查找socket对应的进程信息。然后计算出从发起连接到现在的时间间隔，将该时间间隔，进程信息，以及TCP连接的详细信息（源端口，目标端口，源IP，目标IP等）作为event，通过<code>bpf_perf_event_output</code>函数发送到用户态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">static int handle_tcp_rcv_state_process(void *ctx, struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line">  struct piddata *piddatap;</span><br><span class="line">  struct event event = &#123;&#125;;</span><br><span class="line">  s64 delta;</span><br><span class="line">  u64 ts;</span><br><span class="line"></span><br><span class="line">  if (BPF_CORE_READ(sk, __sk_common.skc_state) != TCP_SYN_SENT)</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">  piddatap = bpf_map_lookup_elem(&amp;start, &amp;sk);</span><br><span class="line">  if (!piddatap)</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">  ts = bpf_ktime_get_ns();</span><br><span class="line">  delta = (s64)(ts - piddatap-&gt;ts);</span><br><span class="line">  if (delta &lt; 0)</span><br><span class="line">    goto cleanup;</span><br><span class="line"></span><br><span class="line">  event.delta_us = delta / 1000U;</span><br><span class="line">  if (targ_min_us &amp;&amp; event.delta_us &lt; targ_min_us)</span><br><span class="line">    goto</span><br><span class="line"></span><br><span class="line"> cleanup;</span><br><span class="line">  __builtin_memcpy(&amp;event.comm, piddatap-&gt;comm,</span><br><span class="line">      sizeof(event.comm));</span><br><span class="line">  event.ts_us = ts / 1000;</span><br><span class="line">  event.tgid = piddatap-&gt;tgid;</span><br><span class="line">  event.lport = BPF_CORE_READ(sk, __sk_common.skc_num);</span><br><span class="line">  event.dport = BPF_CORE_READ(sk, __sk_common.skc_dport);</span><br><span class="line">  event.af = BPF_CORE_READ(sk, __sk_common.skc_family);</span><br><span class="line">  if (event.af == AF_INET) &#123;</span><br><span class="line">    event.saddr_v4 = BPF_CORE_READ(sk, __sk_common.skc_rcv_saddr);</span><br><span class="line">    event.daddr_v4 = BPF_CORE_READ(sk, __sk_common.skc_daddr);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    BPF_CORE_READ_INTO(&amp;event.saddr_v6, sk,</span><br><span class="line">        __sk_common.skc_v6_rcv_saddr.in6_u.u6_addr32);</span><br><span class="line">    BPF_CORE_READ_INTO(&amp;event.daddr_v6, sk,</span><br><span class="line">        __sk_common.skc_v6_daddr.in6_u.u6_addr32);</span><br><span class="line">  &#125;</span><br><span class="line">  bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU,</span><br><span class="line">      &amp;event, sizeof(event));</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">  bpf_map_delete_elem(&amp;start, &amp;sk);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解这个程序的关键在于理解Linux内核的网络栈处理流程，以及eBPF程序的运行模式。Linux内核网络栈对TCP连接建立的处理过程是，首先调用<code>tcp_v4_connect</code>或<code>tcp_v6_connect</code>函数（根据IP版本不同）发起TCP连接，然后在收到SYN-ACK包时，通过<code>tcp_rcv_state_process</code>函数来处理。eBPF程序通过在这两个关键函数上设置kprobe，可以在关键时刻得到通知并执行相应的处理代码。</p>
<p>一些关键概念说明：</p>
<ul>
<li>kprobe：Kernel Probe，是Linux内核中用于动态追踪内核行为的机制。可以在内核函数的入口和退出处设置断点，当断点被触发时，会执行与kprobe关联的eBPF程序。</li>
<li>map：是eBPF程序中的一种数据结构，用于在内核态和用户态之间共享数据。</li>
<li>socket：在Linux网络编程中，socket是一个抽象概念，表示一个网络连接的端点。内核中的<code>struct sock</code>结构就是对socket的实现。</li>
</ul>
<h4 id="用户态数据处理"><a href="#用户态数据处理" class="headerlink" title="用户态数据处理"></a>用户态数据处理</h4><p>用户态数据处理是使用<code>perf_buffer__poll</code>来接收并处理从内核发送到用户态的eBPF事件。<code>perf_buffer__poll</code>是libbpf库提供的一个便捷函数，用于轮询perf event buffer并处理接收到的数据。</p>
<p>首先，让我们详细看一下主轮询循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main: poll */</span></span><br><span class="line"><span class="keyword">while</span> (!exiting) &#123;</span><br><span class="line">    err = perf_buffer__poll(pb, PERF_POLL_TIMEOUT_MS);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span> &amp;&amp; err != -EINTR) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error polling perf buffer: %s\n&quot;</span>, strerror(-err));</span><br><span class="line">        <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* reset err to return 0 if exiting */</span></span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码使用一个while循环来反复轮询perf event buffer。如果轮询出错（例如由于信号中断），会打印出错误消息。这个轮询过程会一直持续，直到收到一个退出标志<code>exiting</code>。</p>
<p>接下来，让我们来看看<code>handle_event</code>函数，这个函数将处理从内核发送到用户态的每一个eBPF事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_event</span><span class="params">(<span class="type">void</span>* ctx, <span class="type">int</span> cpu, <span class="type">void</span>* data, __u32 data_sz)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">e</span> =</span> data;</span><br><span class="line">    <span class="type">char</span> src[INET6_ADDRSTRLEN];</span><br><span class="line">    <span class="type">char</span> dst[INET6_ADDRSTRLEN];</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">x4</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">x6</span>;</span></span><br><span class="line">    &#125; s, d;</span><br><span class="line">    <span class="type">static</span> __u64 start_ts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (env.timestamp) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start_ts == <span class="number">0</span>)</span><br><span class="line">            start_ts = e-&gt;ts_us;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-9.3f &quot;</span>, (e-&gt;ts_us - start_ts) / <span class="number">1000000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;af == AF_INET) &#123;</span><br><span class="line">        s.x4.s_addr = e-&gt;saddr_v4;</span><br><span class="line">        d.x4.s_addr = e-&gt;daddr_v4;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;af == AF_INET6) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;s.x6.s6_addr, e-&gt;saddr_v6, <span class="keyword">sizeof</span>(s.x6.s6_addr));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;d.x6.s6_addr, e-&gt;daddr_v6, <span class="keyword">sizeof</span>(d.x6.s6_addr));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;broken event: event-&gt;af=%d&quot;</span>, e-&gt;af);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (env.lport) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-6d %-12.12s %-2d %-16s %-6d %-16s %-5d %.2f\n&quot;</span>, e-&gt;tgid,</span><br><span class="line">               e-&gt;comm, e-&gt;af == AF_INET ? <span class="number">4</span> : <span class="number">6</span>,</span><br><span class="line">               inet_ntop(e-&gt;af, &amp;s, src, <span class="keyword">sizeof</span>(src)), e-&gt;lport,</span><br><span class="line">               inet_ntop(e-&gt;af, &amp;d, dst, <span class="keyword">sizeof</span>(dst)), ntohs(e-&gt;dport),</span><br><span class="line">               e-&gt;delta_us / <span class="number">1000.0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-6d %-12.12s %-2d %-16s %-16s %-5d %.2f\n&quot;</span>, e-&gt;tgid, e-&gt;comm,</span><br><span class="line">               e-&gt;af == AF_INET ? <span class="number">4</span> : <span class="number">6</span>, inet_ntop(e-&gt;af, &amp;s, src, <span class="keyword">sizeof</span>(src)),</span><br><span class="line">               inet_ntop(e-&gt;af, &amp;d, dst, <span class="keyword">sizeof</span>(dst)), ntohs(e-&gt;dport),</span><br><span class="line">               e-&gt;delta_us / <span class="number">1000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>handle_event</code>函数的参数包括了CPU编号、指向数据的指针以及数据的大小。数据是一个<code>event</code>结构体，包含了之前在内核态计算得到的TCP连接的信息。</p>
<p>首先，它将接收到的事件的时间戳和起始时间戳（如果存在）进行对比，计算出事件的相对时间，并打印出来。接着，根据IP地址的类型（IPv4或IPv6），将源地址和目标地址从网络字节序转换为主机字节序。</p>
<p>最后，根据用户是否选择了显示本地端口，将进程ID、进程名称、IP版本、源IP地址、本地端口（如果有）、目标IP地址、目标端口以及连接建立时间打印出来。这个连接建立时间是我们在内核态eBPF程序中计算并发送到用户态的。</p>
<h3 id="编译运行-2"><a href="#编译运行-2" class="headerlink" title="编译运行"></a>编译运行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">...</span><br><span class="line">  BPF      .output/tcpconnlat.bpf.o</span><br><span class="line">  GEN-SKEL .output/tcpconnlat.skel.h</span><br><span class="line">  CC       .output/tcpconnlat.o</span><br><span class="line">  BINARY   tcpconnlat</span><br><span class="line">$ <span class="built_in">sudo</span> ./tcpconnlat </span><br><span class="line">PID    COMM         IP SADDR            DADDR            DPORT LAT(ms)</span><br><span class="line">222564 wget         4  192.168.88.15    110.242.68.3     80    25.29</span><br><span class="line">222684 wget         4  192.168.88.15    167.179.101.42   443   246.76</span><br><span class="line">222726 ssh          4  192.168.88.15    167.179.101.42   22    241.17</span><br><span class="line">222774 ssh          4  192.168.88.15    1.15.149.151     22    25.31</span><br></pre></td></tr></table></figure>
<p>源代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Feunomia-bpf%2Fbpf-developer-tutorial%2Ftree%2Fmain%2Fsrc%2F13-tcpconnlat">https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/13-tcpconnlat</a></p>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>通过本篇 eBPF 入门实践教程，我们学习了如何使用 eBPF 来跟踪和统计 TCP 连接建立的延时。我们首先深入探讨了 eBPF 程序如何在内核态监听特定的内核函数，然后通过捕获这些函数的调用，从而得到连接建立的起始时间和结束时间，计算出延时。</p>
<p>我们还进一步了解了如何使用 BPF maps 来在内核态存储和查询数据，从而在 eBPF 程序的多个部分之间共享数据。同时，我们也探讨了如何使用 perf events 来将数据从内核态发送到用户态，以便进一步处理和展示。</p>
<p>在用户态，我们介绍了如何使用 libbpf 库的 API，例如 perf_buffer__poll，来接收和处理内核态发送过来的数据。我们还讲解了如何对这些数据进行解析和打印，使得它们能以人类可读的形式显示出来。</p>
<h2 id="记录-TCP-连接状态与-TCP-RTT"><a href="#记录-TCP-连接状态与-TCP-RTT" class="headerlink" title="记录 TCP 连接状态与 TCP RTT"></a>记录 TCP 连接状态与 TCP RTT</h2><p>eBPF (扩展的伯克利数据包过滤器) 是一项强大的网络和性能分析工具，被广泛应用在 Linux 内核上。eBPF 使得开发者能够动态地加载、更新和运行用户定义的代码，而无需重启内核或更改内核源代码。</p>
<p>在我们的 eBPF 入门实践教程系列的这一篇，我们将介绍两个示例程序：<code>tcpstates</code> 和 <code>tcprtt</code>。<code>tcpstates</code> 用于记录 TCP 连接的状态变化，而 <code>tcprtt</code> 则用于记录 TCP 的往返时间 (RTT, Round-Trip Time)。</p>
<h3 id="tcprtt-与-tcpstates"><a href="#tcprtt-与-tcpstates" class="headerlink" title="tcprtt 与 tcpstates"></a><code>tcprtt</code> 与 <code>tcpstates</code></h3><p>网络质量在当前的互联网环境中至关重要。影响网络质量的因素有许多，包括硬件、网络环境、软件编程的质量等。为了帮助用户更好地定位网络问题，我们引入了 <code>tcprtt</code> 这个工具。<code>tcprtt</code> 可以监控 TCP 链接的往返时间，从而评估网络质量，帮助用户找出可能的问题所在。</p>
<p>当 TCP 链接建立时，<code>tcprtt</code> 会自动根据当前系统的状况，选择合适的执行函数。在执行函数中，<code>tcprtt</code> 会收集 TCP 链接的各项基本信息，如源地址、目标地址、源端口、目标端口、耗时等，并将这些信息更新到直方图型的 BPF map 中。运行结束后，<code>tcprtt</code> 会通过用户态代码，将收集的信息以图形化的方式展示给用户。</p>
<p><code>tcpstates</code> 则是一个专门用来追踪和打印 TCP 连接状态变化的工具。它可以显示 TCP 连接在每个状态中的停留时长，单位为毫秒。例如，对于一个单独的 TCP 会话，<code>tcpstates</code> 可以打印出类似以下的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SKADDR           C-PID C-COMM     LADDR           LPORT RADDR           RPORT OLDSTATE    -&gt; NEWSTATE    MS</span><br><span class="line">ffff9fd7e8192000 22384 curl       100.66.100.185  0     52.33.159.26    80    CLOSE       -&gt; SYN_SENT    0.000</span><br><span class="line">ffff9fd7e8192000 0     swapper/5  100.66.100.185  63446 52.33.159.26    80    SYN_SENT    -&gt; ESTABLISHED 1.373</span><br><span class="line">ffff9fd7e8192000 22384 curl       100.66.100.185  63446 52.33.159.26    80    ESTABLISHED -&gt; FIN_WAIT1   176.042</span><br><span class="line">ffff9fd7e819</span><br><span class="line"></span><br><span class="line">2000 0     swapper/5  100.66.100.185  63446 52.33.159.26    80    FIN_WAIT1   -&gt; FIN_WAIT2   0.536</span><br><span class="line">ffff9fd7e8192000 0     swapper/5  100.66.100.185  63446 52.33.159.26    80    FIN_WAIT2   -&gt; CLOSE       0.006</span><br></pre></td></tr></table></figure>
<p>以上输出中，最多的时间被花在了 ESTABLISHED 状态，也就是连接已经建立并在传输数据的状态，这个状态到 FIN_WAIT1 状态（开始关闭连接的状态）的转变过程中耗费了 176.042 毫秒。</p>
<p>在我们接下来的教程中，我们会更深入地探讨这两个工具，解释它们的实现原理，希望这些内容对你在使用 eBPF 进行网络和性能分析方面的工作有所帮助。</p>
<h3 id="tcpstate"><a href="#tcpstate" class="headerlink" title="tcpstate"></a>tcpstate</h3><p>由于篇幅所限，这里我们主要讨论和分析对应的 eBPF 内核态代码实现。以下是 tcpstate 的 eBPF 代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> filter_by_sport = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> filter_by_dport = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">short</span> target_family = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">    __uint(max_entries, MAX_ENTRIES);</span><br><span class="line">    __type(key, __u16);</span><br><span class="line">    __type(value, __u16);</span><br><span class="line">&#125; sports <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">    __uint(max_entries, MAX_ENTRIES);</span><br><span class="line">    __type(key, __u16);</span><br><span class="line">    __type(value, __u16);</span><br><span class="line">&#125; dports <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">    __uint(max_entries, MAX_ENTRIES);</span><br><span class="line">    __type(key, <span class="keyword">struct</span> sock *);</span><br><span class="line">    __type(value, __u64);</span><br><span class="line">&#125; timestamps <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);</span><br><span class="line">    __uint(key_size, <span class="keyword">sizeof</span>(__u32));</span><br><span class="line">    __uint(value_size, <span class="keyword">sizeof</span>(__u32));</span><br><span class="line">&#125; events <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;tracepoint/sock/inet_sock_set_state&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_set_state</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_inet_sock_set_state *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> (<span class="keyword">struct</span> sock *)ctx-&gt;skaddr;</span><br><span class="line">    __u16 family = ctx-&gt;family;</span><br><span class="line">    __u16 sport = ctx-&gt;sport;</span><br><span class="line">    __u16 dport = ctx-&gt;dport;</span><br><span class="line">    __u64 *tsp, delta_us, ts;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">event</span> =</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;protocol != IPPROTO_TCP)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_family &amp;&amp; target_family != family)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filter_by_sport &amp;&amp; !bpf_map_lookup_elem(&amp;sports, &amp;sport))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filter_by_dport &amp;&amp; !bpf_map_lookup_elem(&amp;dports, &amp;dport))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    tsp = bpf_map_lookup_elem(&amp;timestamps, &amp;sk);</span><br><span class="line">    ts = bpf_ktime_get_ns();</span><br><span class="line">    <span class="keyword">if</span> (!tsp)</span><br><span class="line">        delta_us = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        delta_us = (ts - *tsp) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    event.skaddr = (__u64)sk;</span><br><span class="line">    event.ts_us = ts / <span class="number">1000</span>;</span><br><span class="line">    event.delta_us = delta_us;</span><br><span class="line">    event.pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    event.oldstate = ctx-&gt;oldstate;</span><br><span class="line">    event.newstate = ctx-&gt;newstate;</span><br><span class="line">    event.family = family;</span><br><span class="line">    event.sport = sport;</span><br><span class="line">    event.dport = dport;</span><br><span class="line">    bpf_get_current_comm(&amp;event.task, <span class="keyword">sizeof</span>(event.task));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (family == AF_INET) &#123;</span><br><span class="line">        bpf_probe_read_kernel(&amp;event.saddr, <span class="keyword">sizeof</span>(event.saddr), &amp;sk-&gt;__sk_common.skc_rcv_saddr);</span><br><span class="line">        bpf_probe_read_kernel(&amp;event.daddr, <span class="keyword">sizeof</span>(event.daddr), &amp;sk-&gt;__sk_common.skc_daddr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* family == AF_INET6 */</span></span><br><span class="line">        bpf_probe_read_kernel(&amp;event.saddr, <span class="keyword">sizeof</span>(event.saddr), &amp;sk-&gt;__sk_common.skc_v6_rcv_saddr.in6_u.u6_addr32);</span><br><span class="line">        bpf_probe_read_kernel(&amp;event.daddr, <span class="keyword">sizeof</span>(event.daddr), &amp;sk-&gt;__sk_common.skc_v6_daddr.in6_u.u6_addr32);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bpf_perf_event_output(ctx, &amp;events, BPF_F_CURRENT_CPU, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;newstate == TCP_CLOSE)</span><br><span class="line">        bpf_map_delete_elem(&amp;timestamps, &amp;sk);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        bpf_map_update_elem(&amp;timestamps, &amp;sk, &amp;ts, BPF_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tcpstates</code>主要依赖于 eBPF 的 Tracepoints 来捕获 TCP 连接的状态变化，从而跟踪 TCP 连接在每个状态下的停留时间。</p>
<h4 id="定义-BPF-Maps"><a href="#定义-BPF-Maps" class="headerlink" title="定义 BPF Maps"></a>定义 BPF Maps</h4><p>在<code>tcpstates</code>程序中，首先定义了几个 BPF Maps，它们是 eBPF 程序和用户态程序之间交互的主要方式。<code>sports</code>和<code>dports</code>分别用于存储源端口和目标端口，用于过滤 TCP 连接；<code>timestamps</code>用于存储每个 TCP 连接的时间戳，以计算每个状态的停留时间；<code>events</code>则是一个 perf_event 类型的 map，用于将事件数据发送到用户态。</p>
<h4 id="追踪-TCP-连接状态变化"><a href="#追踪-TCP-连接状态变化" class="headerlink" title="追踪 TCP 连接状态变化"></a>追踪 TCP 连接状态变化</h4><p>程序定义了一个名为<code>handle_set_state</code>的函数，该函数是一个 tracepoint 类型的程序，它将被挂载到<code>sock/inet_sock_set_state</code>这个内核 tracepoint 上。每当 TCP 连接状态发生变化时，这个 tracepoint 就会被触发，然后执行<code>handle_set_state</code>函数。</p>
<p>在<code>handle_set_state</code>函数中，首先通过一系列条件判断确定是否需要处理当前的 TCP 连接，然后从<code>timestamps</code>map 中获取当前连接的上一个时间戳，然后计算出停留在当前状态的时间。接着，程序将收集到的数据放入一个 event 结构体中，并通过<code>bpf_perf_event_output</code>函数将该 event 发送到用户态。</p>
<h4 id="更新时间戳"><a href="#更新时间戳" class="headerlink" title="更新时间戳"></a>更新时间戳</h4><p>最后，根据 TCP 连接的新状态，程序将进行不同的操作：如果新状态为 TCP_CLOSE，表示连接已关闭，程序将从<code>timestamps</code>map 中删除该连接的时间戳；否则，程序将更新该连接的时间戳。</p>
<p>用户态的部分主要是通过 libbpf 来加载 eBPF 程序，然后通过 perf_event 来接收内核中的事件数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_event</span><span class="params">(<span class="type">void</span>* ctx, <span class="type">int</span> cpu, <span class="type">void</span>* data, __u32 data_sz)</span> &#123;</span><br><span class="line">    <span class="type">char</span> ts[<span class="number">32</span>], saddr[<span class="number">26</span>], daddr[<span class="number">26</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">e</span> =</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">tm</span>;</span></span><br><span class="line">    <span class="type">int</span> family;</span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (emit_timestamp) &#123;</span><br><span class="line">        time(&amp;t);</span><br><span class="line">        tm = localtime(&amp;t);</span><br><span class="line">        strftime(ts, <span class="keyword">sizeof</span>(ts), <span class="string">&quot;%H:%M:%S&quot;</span>, tm);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%8s &quot;</span>, ts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inet_ntop(e-&gt;family, &amp;e-&gt;saddr, saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    inet_ntop(e-&gt;family, &amp;e-&gt;daddr, daddr, <span class="keyword">sizeof</span>(daddr));</span><br><span class="line">    <span class="keyword">if</span> (wide_output) &#123;</span><br><span class="line">        family = e-&gt;family == AF_INET ? <span class="number">4</span> : <span class="number">6</span>;</span><br><span class="line">        <span class="built_in">printf</span>(</span><br><span class="line">            <span class="string">&quot;%-16llx %-7d %-16s %-2d %-26s %-5d %-26s %-5d %-11s -&gt; %-11s &quot;</span></span><br><span class="line">            <span class="string">&quot;%.3f\n&quot;</span>,</span><br><span class="line">            e-&gt;skaddr, e-&gt;pid, e-&gt;task, family, saddr, e-&gt;sport, daddr,</span><br><span class="line">            e-&gt;dport, tcp_states[e-&gt;oldstate], tcp_states[e-&gt;newstate],</span><br><span class="line">            (<span class="type">double</span>)e-&gt;delta_us / <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(</span><br><span class="line">            <span class="string">&quot;%-16llx %-7d %-10.10s %-15s %-5d %-15s %-5d %-11s -&gt; %-11s %.3f\n&quot;</span>,</span><br><span class="line">            e-&gt;skaddr, e-&gt;pid, e-&gt;task, saddr, e-&gt;sport, daddr, e-&gt;dport,</span><br><span class="line">            tcp_states[e-&gt;oldstate], tcp_states[e-&gt;newstate],</span><br><span class="line">            (<span class="type">double</span>)e-&gt;delta_us / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>handle_event</code>就是这样一个回调函数，它会被 perf_event 调用，每当内核有新的事件到达时，它就会处理这些事件。</p>
<p>在<code>handle_event</code>函数中，我们首先通过<code>inet_ntop</code>函数将二进制的 IP 地址转换成人类可读的格式，然后根据是否需要输出宽格式，分别打印不同的信息。这些信息包括了事件的时间戳、源 IP 地址、源端口、目标 IP 地址、目标端口、旧状态、新状态以及在旧状态停留的时间。</p>
<p>这样，用户就可以清晰地看到 TCP 连接状态的变化，以及每个状态的停留时间，从而帮助他们诊断网络问题。</p>
<p>总结起来，用户态部分的处理主要涉及到了以下几个步骤：</p>
<ol>
<li>使用 libbpf 加载并运行 eBPF 程序。</li>
<li>设置回调函数来接收内核发送的事件。</li>
<li>处理接收到的事件，将其转换成人类可读的格式并打印。</li>
</ol>
<p>以上就是<code>tcpstates</code>程序用户态部分的主要实现逻辑。通过这一章的学习，你应该已经对如何在用户态处理内核事件有了更深入的理解。在下一章中，我们将介绍更多关于如何使用 eBPF 进行网络监控的知识。</p>
<h4 id="tcprtt"><a href="#tcprtt" class="headerlink" title="tcprtt"></a>tcprtt</h4><p>在本章节中，我们将分析<code>tcprtt</code> eBPF 程序的内核态代码。<code>tcprtt</code>是一个用于测量 TCP 往返时间(Round Trip Time, RTT)的程序，它将 RTT 的信息统计到一个 histogram 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @sample &#123;&quot;interval&quot;: 1000, &quot;type&quot; : &quot;log2_hist&quot;&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">    __uint(max_entries, MAX_ENTRIES);</span><br><span class="line">    __type(key, u64);</span><br><span class="line">    __type(value, <span class="keyword">struct</span> hist);</span><br><span class="line">&#125; hists <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hist</span> <span class="title">zero</span>;</span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;fentry/tcp_rcv_established&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_PROG</span><span class="params">(tcp_rcv, <span class="keyword">struct</span> sock *sk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> (<span class="keyword">struct</span> inet_sock *)(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">ts</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hist</span> *<span class="title">histp</span>;</span></span><br><span class="line">    u64 key, slot;</span><br><span class="line">    u32 srtt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (targ_sport &amp;&amp; targ_sport != inet-&gt;inet_sport)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (targ_dport &amp;&amp; targ_dport != sk-&gt;__sk_common.skc_dport)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (targ_saddr &amp;&amp; targ_saddr != inet-&gt;inet_saddr)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (targ_daddr &amp;&amp; targ_daddr != sk-&gt;__sk_common.skc_daddr)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (targ_laddr_hist)</span><br><span class="line">        key = inet-&gt;inet_saddr;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (targ_raddr_hist)</span><br><span class="line">        key = inet-&gt;sk.__sk_common.skc_daddr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        key = <span class="number">0</span>;</span><br><span class="line">    histp = bpf_map_lookup_or_try_init(&amp;hists, &amp;key, &amp;zero);</span><br><span class="line">    <span class="keyword">if</span> (!histp)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ts = (<span class="keyword">struct</span> tcp_sock *)(sk);</span><br><span class="line">    srtt = BPF_CORE_READ(ts, srtt_us) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (targ_ms)</span><br><span class="line">        srtt /= <span class="number">1000U</span>;</span><br><span class="line">    slot = log2l(srtt);</span><br><span class="line">    <span class="keyword">if</span> (slot &gt;= MAX_SLOTS)</span><br><span class="line">        slot = MAX_SLOTS - <span class="number">1</span>;</span><br><span class="line">    __sync_fetch_and_add(&amp;histp-&gt;slots[slot], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (targ_show_ext) &#123;</span><br><span class="line">        __sync_fetch_and_add(&amp;histp-&gt;latency, srtt);</span><br><span class="line">        __sync_fetch_and_add(&amp;histp-&gt;cnt, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们定义了一个 hash 类型的 eBPF map，名为<code>hists</code>，它用来存储 RTT 的统计信息。在这个 map 中，键是 64 位整数，值是一个<code>hist</code>结构，这个结构包含了一个数组，用来存储不同 RTT 区间的数量。</p>
<p>接着，我们定义了一个 eBPF 程序，名为<code>tcp_rcv</code>，这个程序会在每次内核中处理 TCP 收包的时候被调用。在这个程序中，我们首先根据过滤条件（源/目标 IP 地址和端口）对 TCP 连接进行过滤。如果满足条件，我们会根据设置的参数选择相应的 key（源 IP 或者目标 IP 或者 0），然后在<code>hists</code> map 中查找或者初始化对应的 histogram。</p>
<p>接下来，我们读取 TCP 连接的<code>srtt_us</code>字段，这个字段表示了平滑的 RTT 值，单位是微秒。然后我们将这个 RTT 值转换为对数形式，并将其作为 slot 存储到 histogram 中。</p>
<p>如果设置了<code>show_ext</code>参数，我们还会将 RTT 值和计数器累加到 histogram 的<code>latency</code>和<code>cnt</code>字段中。</p>
<p>通过以上的处理，我们可以对每个 TCP 连接的 RTT 进行统计和分析，从而更好地理解网络的性能状况。</p>
<p>总结起来，<code>tcprtt</code> eBPF 程序的主要逻辑包括以下几个步骤：</p>
<ol>
<li>根据过滤条件对 TCP 连接进行过滤。</li>
<li>在<code>hists</code> map 中查找或者初始化对应的 histogram。</li>
<li>读取 TCP 连接的<code>srtt_us</code>字段，并将其转换为对数形式，存储到 histogram 中。</li>
<li>如果设置了<code>show_ext</code>参数，将 RTT 值和计数器累加到 histogram 的<code>latency</code>和<code>cnt</code>字段中。</li>
</ol>
<p>tcprtt 挂载到了内核态的 tcp_rcv_established 函数上：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tcp_rcv_established</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数是在内核中处理TCP接收数据的主要函数，主要在TCP连接处于<code>ESTABLISHED</code>状态时被调用。这个函数的处理逻辑包括一个快速路径和一个慢速路径。快速路径在以下几种情况下会被禁用：</p>
<ul>
<li>我们宣布了一个零窗口 - 零窗口探测只能在慢速路径中正确处理。</li>
<li>收到了乱序的数据包。</li>
<li>期待接收紧急数据。</li>
<li>没有剩余的缓冲区空间。</li>
<li>接收到了意外的TCP标志/窗口值/头部长度（通过检查TCP头部与预设标志进行检测）。</li>
<li>数据在两个方向上都在传输。快速路径只支持纯发送者或纯接收者（这意味着序列号或确认值必须保持不变）。</li>
<li>接收到了意外的TCP选项。</li>
</ul>
<p>当这些条件不满足时，它会进入一个标准的接收处理过程，这个过程遵循RFC793来处理所有情况。前三种情况可以通过正确的预设标志设置来保证，剩下的情况则需要内联检查。当一切都正常时，快速处理过程会在<code>tcp_data_queue</code>函数中被开启。</p>
<h3 id="编译运行-3"><a href="#编译运行-3" class="headerlink" title="编译运行"></a>编译运行</h3><p>对于 tcpstates，可以通过以下命令编译和运行 libbpf 应用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">...</span><br><span class="line">  BPF      .output/tcpstates.bpf.o</span><br><span class="line">  GEN-SKEL .output/tcpstates.skel.h</span><br><span class="line">  CC       .output/tcpstates.o</span><br><span class="line">  BINARY   tcpstates</span><br><span class="line">$ <span class="built_in">sudo</span> ./tcpstates </span><br><span class="line">SKADDR           PID     COMM       LADDR           LPORT RADDR           RPORT OLDSTATE    -&gt; NEWSTATE    MS</span><br><span class="line">ffff9bf61bb62bc0 164978  node       192.168.88.15   0     52.178.17.2     443   CLOSE       -&gt; SYN_SENT    0.000</span><br><span class="line">ffff9bf61bb62bc0 0       swapper/0  192.168.88.15   41596 52.178.17.2     443   SYN_SENT    -&gt; ESTABLISHED 225.794</span><br><span class="line">ffff9bf61bb62bc0 0       swapper/0  192.168.88.15   41596 52.178.17.2     443   ESTABLISHED -&gt; CLOSE_WAIT  901.454</span><br><span class="line">ffff9bf61bb62bc0 164978  node       192.168.88.15   41596 52.178.17.2     443   CLOSE_WAIT  -&gt; LAST_ACK    0.793</span><br><span class="line">ffff9bf61bb62bc0 164978  node       192.168.88.15   41596 52.178.17.2     443   LAST_ACK    -&gt; LAST_ACK    0.086</span><br><span class="line">ffff9bf61bb62bc0 228759  kworker/u6 192.168.88.15   41596 52.178.17.2     443   LAST_ACK    -&gt; CLOSE       0.193</span><br><span class="line">ffff9bf6d8ee88c0 229832  redis-serv 0.0.0.0         6379  0.0.0.0         0     CLOSE       -&gt; LISTEN      0.000</span><br><span class="line">ffff9bf6d8ee88c0 229832  redis-serv 0.0.0.0         6379  0.0.0.0         0     LISTEN      -&gt; CLOSE       1.763</span><br><span class="line">ffff9bf7109d6900 88750   node       127.0.0.1       39755 127.0.0.1       50966 ESTABLISHED -&gt; FIN_WAIT1   0.000</span><br></pre></td></tr></table></figure>
<p>对于 tcprtt，我们可以使用 eunomia-bpf 编译运行这个例子：</p>
<p>Compile:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v `pwd`/:/src/ ghcr.io/eunomia-bpf/ecc-`uname -m`:latest</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ecc runqlat.bpf.c runqlat.h</span><br><span class="line">Compiling bpf object...</span><br><span class="line">Generating export types...</span><br><span class="line">Packing ebpf object and config into package.json...</span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> ecli run package.json -h</span><br><span class="line">A simple eBPF program</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Usage: package.json [OPTIONS]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --verbose                  Whether to show libbpf debug information</span><br><span class="line">      --targ_laddr_hist          Set value of `bool` variable targ_laddr_hist</span><br><span class="line">      --targ_raddr_hist          Set value of `bool` variable targ_raddr_hist</span><br><span class="line">      --targ_show_ext            Set value of `bool` variable targ_show_ext</span><br><span class="line">      --targ_sport &lt;targ_sport&gt;  Set value of `__u16` variable targ_sport</span><br><span class="line">      --targ_dport &lt;targ_dport&gt;  Set value of `__u16` variable targ_dport</span><br><span class="line">      --targ_saddr &lt;targ_saddr&gt;  Set value of `__u32` variable targ_saddr</span><br><span class="line">      --targ_daddr &lt;targ_daddr&gt;  Set value of `__u32` variable targ_daddr</span><br><span class="line">      --targ_ms                  Set value of `bool` variable targ_ms</span><br><span class="line">  -h, --<span class="built_in">help</span>                     Print <span class="built_in">help</span></span><br><span class="line">  -V, --version                  Print version</span><br><span class="line"></span><br><span class="line">Built with eunomia-bpf framework.</span><br><span class="line">See https://github.com/eunomia-bpf/eunomia-bpf <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">sudo</span> ecli run package.json</span><br><span class="line">key =  0</span><br><span class="line">latency = 0</span><br><span class="line">cnt = 0</span><br><span class="line"></span><br><span class="line">     (unit)              : count    distribution</span><br><span class="line">         0 -&gt; 1          : 0        |                                        |</span><br><span class="line">         2 -&gt; 3          : 0        |                                        |</span><br><span class="line">         4 -&gt; 7          : 0        |                                        |</span><br><span class="line">         8 -&gt; 15         : 0        |                                        |</span><br><span class="line">        16 -&gt; 31         : 0        |                                        |</span><br><span class="line">        32 -&gt; 63         : 0        |                                        |</span><br><span class="line">        64 -&gt; 127        : 0        |                                        |</span><br><span class="line">       128 -&gt; 255        : 0        |                                        |</span><br><span class="line">       256 -&gt; 511        : 0        |                                        |</span><br><span class="line">       512 -&gt; 1023       : 4        |********************                    |</span><br><span class="line">      1024 -&gt; 2047       : 1        |*****                                   |</span><br><span class="line">      2048 -&gt; 4095       : 0        |                                        |</span><br><span class="line">      4096 -&gt; 8191       : 8        |****************************************|</span><br><span class="line"></span><br><span class="line">key =  0</span><br><span class="line">latency = 0</span><br><span class="line">cnt = 0</span><br><span class="line"></span><br><span class="line">     (unit)              : count    distribution</span><br><span class="line">         0 -&gt; 1          : 0        |                                        |</span><br><span class="line">         2 -&gt; 3          : 0        |                                        |</span><br><span class="line">         4 -&gt; 7          : 0        |                                        |</span><br><span class="line">         8 -&gt; 15         : 0        |                                        |</span><br><span class="line">        16 -&gt; 31         : 0        |                                        |</span><br><span class="line">        32 -&gt; 63         : 0        |                                        |</span><br><span class="line">        64 -&gt; 127        : 0        |                                        |</span><br><span class="line">       128 -&gt; 255        : 0        |                                        |</span><br><span class="line">       256 -&gt; 511        : 0        |                                        |</span><br><span class="line">       512 -&gt; 1023       : 11       |***************************             |</span><br><span class="line">      1024 -&gt; 2047       : 1        |**                                      |</span><br><span class="line">      2048 -&gt; 4095       : 0        |                                        |</span><br><span class="line">      4096 -&gt; 8191       : 16       |****************************************|</span><br><span class="line">      8192 -&gt; 16383      : 4        |**********                              |</span><br></pre></td></tr></table></figure>
<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>通过本篇 eBPF 入门实践教程，我们学习了如何使用tcpstates和tcprtt这两个 eBPF 示例程序，监控和分析 TCP 的连接状态和往返时间。我们了解了tcpstates和tcprtt的工作原理和实现方式，包括如何使用 BPF map 存储数据，如何在 eBPF 程序中获取和处理 TCP 连接信息，以及如何在用户态应用程序中解析和显示 eBPF 程序收集的数据。</p>
<h2 id="使用-USDT-捕获用户态-Java-GC-事件耗时"><a href="#使用-USDT-捕获用户态-Java-GC-事件耗时" class="headerlink" title="使用 USDT 捕获用户态 Java GC 事件耗时"></a>使用 USDT 捕获用户态 Java GC 事件耗时</h2><p>eBPF (扩展的伯克利数据包过滤器) 是一项强大的网络和性能分析工具，被广泛应用在 Linux 内核上。eBPF 使得开发者能够动态地加载、更新和运行用户定义的代码，而无需重启内核或更改内核源代码。这个特性使得 eBPF 能够提供极高的灵活性和性能，使其在网络和系统性能分析方面具有广泛的应用。此外，eBPF 还支持使用 USDT (用户级静态定义跟踪点) 捕获用户态的应用程序行为。</p>
<p>在我们的 eBPF 入门实践教程系列的这一篇，我们将介绍如何使用 eBPF 和 USDT 来捕获和分析 Java 的垃圾回收 (GC) 事件的耗时。</p>
<h3 id="USDT-介绍"><a href="#USDT-介绍" class="headerlink" title="USDT 介绍"></a>USDT 介绍</h3><p>USDT 是一种在应用程序中插入静态跟踪点的机制，它允许开发者在程序的关键位置插入可用于调试和性能分析的探针。这些探针可以在运行时被 DTrace、SystemTap 或 eBPF 等工具动态激活，从而在不重启应用程序或更改程序代码的情况下，获取程序的内部状态和性能指标。USDT 在很多开源软件，如 MySQL、PostgreSQL、Ruby、Python 和 Node.js 等都有广泛的应用。</p>
<h4 id="用户层面的追踪机制：用户级动态跟踪和-USDT"><a href="#用户层面的追踪机制：用户级动态跟踪和-USDT" class="headerlink" title="用户层面的追踪机制：用户级动态跟踪和 USDT"></a>用户层面的追踪机制：用户级动态跟踪和 USDT</h4><p>在用户层面进行动态跟踪，即用户级动态跟踪（User-Level Dynamic Tracing）允许我们对任何用户级别的代码进行插桩。比如，我们可以通过在 MySQL 服务器的 <code>dispatch_command()</code> 函数上进行插桩，来跟踪服务器的查询请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ./uprobe &#x27;p:cmd /opt/bin/mysqld:_Z16dispatch_command19enum_server_commandP3THDPcj +0(%dx):string&#x27;</span><br><span class="line">Tracing uprobe cmd (p:cmd /opt/bin/mysqld:0x2dbd40 +0(%dx):string). Ctrl-C to end.</span><br><span class="line">  mysqld-2855  [001] d... 19957757.590926: cmd: (0x6dbd40) arg1=&quot;show tables&quot;</span><br><span class="line">  mysqld-2855  [001] d... 19957759.703497: cmd: (0x6dbd40) arg1=&quot;SELECT * FROM numbers&quot;</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>这里我们使用了 <code>uprobe</code> 工具，它利用了 Linux 的内置功能：ftrace（跟踪器）和 uprobes（用户级动态跟踪，需要较新的 Linux 版本，例如 4.0 左右）。其他的跟踪器，如 perf_events 和 SystemTap，也可以实现此功能。</p>
<p>许多其他的 MySQL 函数也可以被跟踪以获取更多的信息。我们可以列出和计算这些函数的数量：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./uprobe -l /opt/bin/mysqld | more</span></span><br><span class="line">account_hash_get_key</span><br><span class="line">add_collation</span><br><span class="line">add_compiled_collation</span><br><span class="line">add_plugin_noargs</span><br><span class="line">adjust_time_range</span><br><span class="line">[...]</span><br><span class="line"><span class="comment"># ./uprobe -l /opt/bin/mysqld | wc -l</span></span><br><span class="line">21809</span><br></pre></td></tr></table></figure>
<p>这有 21,000 个函数。我们也可以跟踪库函数，甚至是单个的指令偏移。</p>
<p>用户级动态跟踪的能力是非常强大的，它可以解决无数的问题。然而，使用它也有一些困难：需要确定需要跟踪的代码，处理函数参数，以及应对代码的更改。</p>
<p>用户级静态定义跟踪（User-level Statically Defined Tracing, USDT）则可以在某种程度上解决这些问题。USDT 探针（或者称为用户级 “marker”）是开发者在代码的关键位置插入的跟踪宏，提供稳定且已经过文档说明的 API。这使得跟踪工作变得更加简单。</p>
<p>使用 USDT，我们可以简单地跟踪一个名为 <code>mysql:query__start</code> 的探针，而不是去跟踪那个名为 <code>_Z16dispatch_command19enum_server_commandP3THDPcj</code> 的 C++ 符号，也就是 <code>dispatch_command()</code> 函数。当然，我们仍然可以在需要的时候去跟踪 <code>dispatch_command()</code> 以及</p>
<p>其他 21,000 个 mysqld 函数，但只有当 USDT 探针无法解决问题的时候我们才需要这么做。</p>
<p>在 Linux 中的 USDT，无论是哪种形式的静态跟踪点，其实都已经存在了几十年。它最近由于 Sun 的 DTrace 工具的流行而再次受到关注，这使得许多常见的应用程序，包括 MySQL、PostgreSQL、Node.js、Java 等都加入了 USDT。SystemTap 则开发了一种可以消费这些 DTrace 探针的方式。</p>
<p>你可能正在运行一个已经包含了 USDT 探针的 Linux 应用程序，或者可能需要重新编译（通常是 —enable-dtrace）。你可以使用 <code>readelf</code> 来进行检查，例如对于 Node.js：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># readelf -n node</span></span><br><span class="line">[...]</span><br><span class="line">Notes at offset 0x00c43058 with length 0x00000494:</span><br><span class="line">  Owner                 Data size   Description</span><br><span class="line">  stapsdt              0x0000003c   NT_STAPSDT (SystemTap probe descriptors)</span><br><span class="line">    Provider: node</span><br><span class="line">    Name: gc__start</span><br><span class="line">    Location: 0x0000000000bf44b4, Base: 0x0000000000f22464, Semaphore: 0x0000000001243028</span><br><span class="line">    Arguments: 4@%esi 4@%edx 8@%rdi</span><br><span class="line">[...]</span><br><span class="line">  stapsdt              0x00000082       NT_STAPSDT (SystemTap probe descriptors)</span><br><span class="line">    Provider: node</span><br><span class="line">    Name: http__client__request</span><br><span class="line">    Location: 0x0000000000bf48ff, Base: 0x0000000000f22464, Semaphore: 0x0000000001243024</span><br><span class="line">    Arguments: 8@%rax 8@%rdx 8@-136(%rbp) -4@-140(%rbp) 8@-72(%rbp) 8@-80(%rbp) -4@-144(%rbp)</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>这就是使用 —enable-dtrace 重新编译的 node，以及安装了提供 “dtrace” 功能来构建 USDT 支持的 systemtap-sdt-dev 包。这里显示了两个探针：<code>node:gc__start</code>（开始进行垃圾回收）和 <code>node:http__client__request</code>。</p>
<p>在这一点上，你可以使用 SystemTap 或者 LTTng 来跟踪这些探针。然而，内置的 Linux 跟踪器，比如 ftrace 和 perf_events，目前还无法做到这一点（尽管 perf_events 的支持正在开发中）。</p>
<h3 id="Java-GC-介绍"><a href="#Java-GC-介绍" class="headerlink" title="Java GC 介绍"></a>Java GC 介绍</h3><p>Java 作为一种高级编程语言，其自动垃圾回收（GC）是其核心特性之一。Java GC 的目标是自动地回收那些不再被程序使用的内存空间，从而减轻程序员在内存管理方面的负担。然而，GC 过程可能会引发应用程序的停顿，对程序的性能和响应时间产生影响。因此，对 Java GC 事件进行监控和分析，对于理解和优化 Java 应用的性能是非常重要的。</p>
<p>在接下来的教程中，我们将演示如何使用 eBPF 和 USDT 来监控和分析 Java GC 事件的耗时，希望这些内容对你在使用 eBPF 进行应用性能分析方面的工作有所帮助。</p>
<h3 id="eBPF-实现机制"><a href="#eBPF-实现机制" class="headerlink" title="eBPF 实现机制"></a>eBPF 实现机制</h3><p>Java GC 的 eBPF 程序分为内核态和用户态两部分，我们会分别介绍这两部分的实现机制。</p>
<h4 id="内核态程序"><a href="#内核态程序" class="headerlink" title="内核态程序"></a>内核态程序</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */</span></span><br><span class="line"><span class="comment">/* Copyright (c) 2022 Chen Tao */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vmlinux.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/bpf_core_read.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bpf/usdt.bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;javagc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">    __uint(max_entries, <span class="number">100</span>);</span><br><span class="line">    __type(key, <span class="type">uint32_t</span>);</span><br><span class="line">    __type(value, <span class="keyword">struct</span> <span class="type">data_t</span>);</span><br><span class="line">&#125; data_map <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);</span><br><span class="line">    __type(key, <span class="type">int</span>);</span><br><span class="line">    __type(value, <span class="type">int</span>);</span><br><span class="line">&#125; perf_map <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">__u32 time;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gc_start</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> <span class="title">data</span> =</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    data.cpu = bpf_get_smp_processor_id();</span><br><span class="line">    data.pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    data.ts = bpf_ktime_get_ns();</span><br><span class="line">    bpf_map_update_elem(&amp;data_map, &amp;data.pid, &amp;data, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gc_end</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> <span class="title">data</span> =</span> &#123;&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> *<span class="title">p</span>;</span></span><br><span class="line">    __u32 val;</span><br><span class="line"></span><br><span class="line">    data.cpu = bpf_get_smp_processor_id();</span><br><span class="line">    data.pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    data.ts = bpf_ktime_get_ns();</span><br><span class="line">    p = bpf_map_lookup_elem(&amp;data_map, &amp;data.pid);</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    val = data.ts - p-&gt;ts;</span><br><span class="line">    <span class="keyword">if</span> (val &gt; time) &#123;</span><br><span class="line">        data.ts = val;</span><br><span class="line">        bpf_perf_event_output(ctx, &amp;perf_map, BPF_F_CURRENT_CPU, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">    bpf_map_delete_elem(&amp;data_map, &amp;data.pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;usdt&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_gc_start</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gc_start(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;usdt&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_gc_end</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gc_end(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;usdt&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_mem_pool_gc_start</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gc_start(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;usdt&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_mem_pool_gc_end</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gc_end(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> LICENSE[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;Dual BSD/GPL&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>首先，我们定义了两个映射（map）：</p>
<ul>
<li><code>data_map</code>：这个 hashmap 存储每个进程 ID 的垃圾收集开始时间。<code>data_t</code> 结构体包含进程 ID、CPU ID 和时间戳。</li>
<li><code>perf_map</code>：这是一个 perf event array，用于将数据发送回用户态程序。</li>
</ul>
<p>然后，我们有四个处理函数：<code>gc_start</code>、<code>gc_end</code> 和两个 USDT 处理函数 <code>handle_mem_pool_gc_start</code> 和 <code>handle_mem_pool_gc_end</code>。这些函数都用 BPF 的 <code>SEC(&quot;usdt&quot;)</code> 宏注解，以便在 Java 进程中捕获到与垃圾收集相关的 USDT 事件。</p>
<p><code>gc_start</code> 函数在垃圾收集开始时被调用。它首先获取当前的 CPU ID、进程 ID 和时间戳，然后将这些数据存入 <code>data_map</code>。</p>
<p><code>gc_end</code> 函数在垃圾收集结束时被调用。它执行与 <code>gc_start</code> 类似的操作，但是它还从 <code>data_map</code> 中检索开始时间，并计算垃圾收集的持续时间。如果持续时间超过了设定的阈值（变量 <code>time</code>），那么它将数据发送回用户态程序。</p>
<p><code>handle_gc_start</code> 和 <code>handle_gc_end</code> 是针对垃圾收集开始和结束事件的处理函数，它们分别调用了 <code>gc_start</code> 和 <code>gc_end</code>。</p>
<p><code>handle_mem_pool_gc_start</code> 和 <code>handle_mem_pool_gc_end</code> 是针对内存池的垃圾收集开始和结束事件的处理函数，它们也分别调用了 <code>gc_start</code> 和 <code>gc_end</code>。</p>
<p>最后，我们有一个 <code>LICENSE</code> 数组，声明了该 BPF 程序的许可证，这是加载 BPF 程序所必需的。</p>
<h4 id="用户态程序"><a href="#用户态程序" class="headerlink" title="用户态程序"></a>用户态程序</h4><p>用户态程序的主要目标是加载和运行eBPF程序，以及处理来自内核态程序的数据。它是通过 libbpf 库来完成这些操作的。这里我们省略了一些通用的加载和运行 eBPF 程序的代码，只展示了与 USDT 相关的部分。</p>
<p>第一个函数 <code>get_jvmso_path</code> 被用来获取运行的Java虚拟机（JVM）的 <code>libjvm.so</code> 库的路径。首先，它打开了 <code>/proc/&lt;pid&gt;/maps</code> 文件，该文件包含了进程地址空间的内存映射信息。然后，它在文件中搜索包含 <code>libjvm.so</code> 的行，然后复制该行的路径到提供的参数中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_jvmso_path</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> mode[<span class="number">16</span>], line[<span class="number">128</span>], buf[<span class="number">64</span>];</span><br><span class="line">    <span class="type">size_t</span> seg_start, seg_end, seg_off;</span><br><span class="line">    FILE *f;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;/proc/%d/maps&quot;</span>, env.pid);</span><br><span class="line">    f = fopen(buf, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!f)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(f, <span class="string">&quot;%zx-%zx %s %zx %*s %*d%[^\n]\n&quot;</span>,</span><br><span class="line">            &amp;seg_start, &amp;seg_end, mode, &amp;seg_off, line) == <span class="number">5</span>) &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (isblank(line[i]))</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(line + i, <span class="string">&quot;libjvm.so&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(path, line + i);</span><br><span class="line">    fclose(f);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们看到的是将 eBPF 程序（函数 <code>handle_gc_start</code> 和 <code>handle_gc_end</code>）附加到Java进程的相关USDT探针上。每个程序都通过调用 <code>bpf_program__attach_usdt</code> 函数来实现这一点，该函数的参数包括BPF程序、进程ID、二进制路径以及探针的提供者和名称。如果探针挂载成功，<code>bpf_program__attach_usdt</code> 将返回一个链接对象，该对象将存储在skeleton的链接成员中。如果挂载失败，程序将打印错误消息并进行清理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">skel-&gt;links.handle_mem_pool_gc_start = bpf_program__attach_usdt(skel-&gt;progs.handle_gc_start, env.pid,</span><br><span class="line">                                binary_path, <span class="string">&quot;hotspot&quot;</span>, <span class="string">&quot;mem__pool__gc__begin&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!skel-&gt;links.handle_mem_pool_gc_start) &#123;</span><br><span class="line">    err = errno;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;attach usdt mem__pool__gc__begin failed: %s\n&quot;</span>, strerror(err));</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skel-&gt;links.handle_mem_pool_gc_end = bpf_program__attach_usdt(skel-&gt;progs.handle_gc_end, env.pid,</span><br><span class="line">                            binary_path, <span class="string">&quot;hotspot&quot;</span>, <span class="string">&quot;mem__pool__gc__end&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!skel-&gt;links.handle_mem_pool_gc_end) &#123;</span><br><span class="line">    err = errno;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;attach usdt mem__pool__gc__end failed: %s\n&quot;</span>, strerror(err));</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skel-&gt;links.handle_gc_start = bpf_program__attach_usdt(skel-&gt;progs.handle_gc_start, env.pid,</span><br><span class="line">                                binary_path, <span class="string">&quot;hotspot&quot;</span>, <span class="string">&quot;gc__begin&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!skel-&gt;links.handle_gc_start) &#123;</span><br><span class="line">    err = errno;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;attach usdt gc__begin failed: %s\n&quot;</span>, strerror(err));</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skel-&gt;links.handle_gc_end = bpf_program__attach_usdt(skel-&gt;progs.handle_gc_end, env.pid,</span><br><span class="line">            binary_path, <span class="string">&quot;hotspot&quot;</span>, <span class="string">&quot;gc__end&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!skel-&gt;links.handle_gc_end) &#123;</span><br><span class="line">    err = errno;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;attach usdt gc__end failed: %s\n&quot;</span>, strerror(err));</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个函数 <code>handle_event</code> 是一个回调函数，用于处理从perf event array收到的数据。这个函数会被 perf event array 触发，并在每次接收到新的事件时调用。函数首先将数据转换为 <code>data_t</code> 结构体，然后将当前时间格式化为字符串，并打印出事件的时间戳、CPU ID、进程 ID，以及垃圾回收的持续时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_event</span><span class="params">(<span class="type">void</span> *ctx, <span class="type">int</span> cpu, <span class="type">void</span> *data, __u32 data_sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data_t</span> *<span class="title">e</span> =</span> (<span class="keyword">struct</span> <span class="type">data_t</span> *)data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tm</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> ts[<span class="number">16</span>];</span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line"></span><br><span class="line">    time(&amp;t);</span><br><span class="line">    tm = localtime(&amp;t);</span><br><span class="line">    strftime(ts, <span class="keyword">sizeof</span>(ts), <span class="string">&quot;%H:%M:%S&quot;</span>, tm);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-8s %-7d %-7d %-7lld\n&quot;</span>, ts, e-&gt;cpu, e-&gt;pid, e-&gt;ts/<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>构建示例需要 clang、libelf 和 zlib。包名在不同的发行版中可能会有所不同。</p>
<p>在 Ubuntu/Debian 上，你需要执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clang libelf1 libelf-dev zlib1g-dev</span><br></pre></td></tr></table></figure>
<p>在 CentOS/Fedora 上，你需要执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install clang elfutils-libelf elfutils-libelf-devel zlib-devel</span><br></pre></td></tr></table></figure>
<h3 id="编译运行-4"><a href="#编译运行-4" class="headerlink" title="编译运行"></a>编译运行</h3><p>在对应的目录中，运行 Make 即可编译运行上述代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ sudo ./javagc -p 12345</span><br><span class="line">Tracing javagc time... Hit Ctrl-C to end.</span><br><span class="line">TIME     CPU     PID     GC TIME</span><br><span class="line">10:00:01 10%     12345   50ms</span><br><span class="line">10:00:02 12%     12345   55ms</span><br><span class="line">10:00:03 9%      12345   47ms</span><br><span class="line">10:00:04 13%     12345   52ms</span><br><span class="line">10:00:05 11%     12345   50ms</span><br></pre></td></tr></table></figure>
<h2 id="编写-eBPF-程序-Memleak-监控内存泄漏"><a href="#编写-eBPF-程序-Memleak-监控内存泄漏" class="headerlink" title="编写 eBPF 程序 Memleak 监控内存泄漏"></a>编写 eBPF 程序 Memleak 监控内存泄漏</h2><p>eBPF（扩展的伯克利数据包过滤器）是一项强大的网络和性能分析工具，被广泛应用在 Linux 内核上。eBPF 使得开发者能够动态地加载、更新和运行用户定义的代码，而无需重启内核或更改内核源代码。</p>
<p>在本篇教程中，我们将探讨如何使用 eBPF 编写 Memleak 程序，以监控程序的内存泄漏。</p>
<h3 id="背景及其重要性"><a href="#背景及其重要性" class="headerlink" title="背景及其重要性"></a>背景及其重要性</h3><p>内存泄漏是计算机编程中的一种常见问题，其严重程度不应被低估。内存泄漏发生时，程序会逐渐消耗更多的内存资源，但并未正确释放。随着时间的推移，这种行为会导致系统内存逐渐耗尽，从而显著降低程序及系统的整体性能。</p>
<p>内存泄漏有多种可能的原因。这可能是由于配置错误导致的，例如程序错误地配置了某些资源的动态分配。它也可能是由于软件缺陷或错误的内存管理策略导致的，如在程序执行过程中忘记释放不再需要的内存。此外，如果一个应用程序的内存使用量过大，那么系统性能可能会因页面交换（swapping）而大幅下降，甚至可能导致应用程序被系统强制终止（Linux 的 OOM killer）。</p>
<h4 id="调试内存泄漏的挑战"><a href="#调试内存泄漏的挑战" class="headerlink" title="调试内存泄漏的挑战"></a>调试内存泄漏的挑战</h4><p>调试内存泄漏问题是一项复杂且挑战性的任务。这涉及到详细检查应用程序的配置、内存分配和释放情况，通常需要应用专门的工具来帮助诊断。例如，有一些工具可以在应用程序启动时将 malloc() 函数调用与特定的检测工具关联起来，如 Valgrind memcheck，这类工具可以模拟 CPU 来检查所有内存访问，但可能会导致应用程序运行速度大大减慢。另一个选择是使用堆分析器，如 libtcmalloc，它相对较快，但仍可能使应用程序运行速度降低五倍以上。此外，还有一些工具，如 gdb，可以获取应用程序的核心转储并进行后处理以分析内存使用情况。然而，这些工具通常在获取核心转储时需要暂停应用程序，或在应用程序终止后才能调用 free() 函数。</p>
<h3 id="eBPF-的作用"><a href="#eBPF-的作用" class="headerlink" title="eBPF 的作用"></a>eBPF 的作用</h3><p>在这种背景下，eBPF 的作用就显得尤为重要。eBPF 提供了一种高效的机制来监控和追踪系统级别的事件，包括内存的分配和释放。通过 eBPF，我们可以跟踪内存分配和释放的请求，并收集每次分配的调用堆栈。然后，我们可以分析这些信息，找出执行了内存分配但未执行释放操作的调用堆栈，这有助于我们找出导致内存泄漏的源头。这种方式的优点在于，它可以实时地在运行的应用程序中进行，而无需暂停应用程序或进行复杂的前后处理。</p>
<p><code>memleak</code> eBPF 工具可以跟踪并匹配内存分配和释放的请求，并收集每次分配的调用堆栈。随后，<code>memleak</code> 可以打印一个总结，表明哪些调用堆栈执行了分配，但是并没有随后进行释放。例如，我们运行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ./memleak -p $(pidof allocs)</span><br><span class="line">Attaching to pid 5193, Ctrl+C to quit.</span><br><span class="line">[11:16:33] Top 2 stacks with outstanding allocations:</span><br><span class="line">        80 bytes in 5 allocations from stack</span><br><span class="line">                 main+0x6d [allocs]</span><br><span class="line">                 __libc_start_main+0xf0 [libc-2.21.so]</span><br><span class="line"></span><br><span class="line">[11:16:34] Top 2 stacks with outstanding allocations:</span><br><span class="line">        160 bytes in 10 allocations from stack</span><br><span class="line">                 main+0x6d [allocs]</span><br><span class="line">                 __libc_start_main+0xf0 [libc-2.21.so]</span><br></pre></td></tr></table></figure>
<p>运行这个命令后，我们可以看到分配但未释放的内存来自于哪些堆栈，并且可以看到这些未释放的内存的大小和数量。</p>
<p>随着时间的推移，很显然，<code>allocs</code> 进程的 <code>main</code> 函数正在泄漏内存，每次泄漏 16 字节。幸运的是，我们不需要检查每个分配，我们得到了一个很好的总结，告诉我们哪个堆栈负责大量的泄漏。</p>
<h3 id="memleak-的实现原理"><a href="#memleak-的实现原理" class="headerlink" title="memleak 的实现原理"></a>memleak 的实现原理</h3><p>在基本层面上，<code>memleak</code> 的工作方式类似于在内存分配和释放路径上安装监控设备。它通过在内存分配和释放函数中插入 eBPF 程序来达到这个目标。这意味着，当这些函数被调用时，<code>memleak</code> 就会记录一些重要信息，如调用者的进程 ID（PID）、分配的内存地址以及分配的内存大小等。当释放内存的函数被调用时，<code>memleak</code> 则会在其内部的映射表（map）中删除相应的内存分配记录。这种机制使得 <code>memleak</code> 能够准确地追踪到哪些内存块已被分配但未被释放。</p>
<p>对于用户态的常用内存分配函数，如 <code>malloc</code> 和 <code>calloc</code> 等，<code>memleak</code> 利用了用户态探测（uprobe）技术来实现监控。uprobe 是一种用于用户空间应用程序的动态追踪技术，它可以在运行时不修改二进制文件的情况下在任意位置设置断点，从而实现对特定函数调用的追踪。</p>
<p>对于内核态的内存分配函数，如 <code>kmalloc</code> 等，<code>memleak</code> 则选择使用了 tracepoint 来实现监控。Tracepoint 是一种在 Linux 内核中提供的动态追踪技术，它可以在内核运行时动态地追踪特定的事件，而无需重新编译内核或加载内核模块。</p>
<h3 id="内核态-eBPF-程序实现"><a href="#内核态-eBPF-程序实现" class="headerlink" title="内核态 eBPF 程序实现"></a>内核态 eBPF 程序实现</h3><h4 id="memleak-内核态-eBPF-程序实现"><a href="#memleak-内核态-eBPF-程序实现" class="headerlink" title="memleak 内核态 eBPF 程序实现"></a><code>memleak</code> 内核态 eBPF 程序实现</h4><p><code>memleak</code> 的内核态 eBPF 程序包含一些用于跟踪内存分配和释放的关键函数。在我们深入了解这些函数之前，让我们首先观察 <code>memleak</code> 所定义的一些数据结构，这些结构在其内核态和用户态程序中均有使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MEMLEAK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MEMLEAK_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOCS_MAX_ENTRIES 1000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMBINED_ALLOCS_MAX_ENTRIES 10240</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_info</span> &#123;</span></span><br><span class="line">    __u64 size;            <span class="comment">// 分配的内存大小</span></span><br><span class="line">    __u64 timestamp_ns;    <span class="comment">// 分配时的时间戳，单位为纳秒</span></span><br><span class="line">    <span class="type">int</span> stack_id;          <span class="comment">// 分配时的调用堆栈ID</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">combined_alloc_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        __u64 total_size : <span class="number">40</span>;        <span class="comment">// 所有未释放分配的总大小</span></span><br><span class="line">        __u64 number_of_allocs : <span class="number">24</span>;   <span class="comment">// 所有未释放分配的总次数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    __u64 bits;    <span class="comment">// 结构的位图表示</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MEMLEAK_H */</span></span></span><br></pre></td></tr></table></figure>
<p>这里定义了两个主要的数据结构：<code>alloc_info</code> 和 <code>combined_alloc_info</code>。</p>
<p><code>alloc_info</code> 结构体包含了一个内存分配的基本信息，包括分配的内存大小 <code>size</code>、分配发生时的时间戳 <code>timestamp_ns</code>，以及触发分配的调用堆栈 ID <code>stack_id</code>。</p>
<p><code>combined_alloc_info</code> 是一个联合体（union），它包含一个嵌入的结构体和一个 <code>__u64</code> 类型的位图表示 <code>bits</code>。嵌入的结构体有两个成员：<code>total_size</code> 和 <code>number_of_allocs</code>，分别代表所有未释放分配的总大小和总次数。其中 40 和 24 分别表示 total_size 和 number_of_allocs这两个成员变量所占用的位数，用来限制其大小。通过这样的位数限制，可以节省combined_alloc_info结构的存储空间。同时，由于total_size和number_of_allocs在存储时是共用一个unsigned long long类型的变量bits，因此可以通过在成员变量bits上进行位运算来访问和修改total_size和number_of_allocs，从而避免了在程序中定义额外的变量和函数的复杂性。</p>
<p>接下来，<code>memleak</code> 定义了一系列用于保存内存分配信息和分析结果的 eBPF 映射（maps）。这些映射都以 <code>SEC(&quot;.maps&quot;)</code> 的形式定义，表示它们属于 eBPF 程序的映射部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">size_t</span> min_size = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">size_t</span> max_size = <span class="number">-1</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">size_t</span> page_size = <span class="number">4096</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> __u64 sample_rate = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> trace_all = <span class="literal">false</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> __u64 stack_flags = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="type">bool</span> wa_missing_free = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">    __type(key, <span class="type">pid_t</span>);</span><br><span class="line">    __type(value, u64);</span><br><span class="line">    __uint(max_entries, <span class="number">10240</span>);</span><br><span class="line">&#125; sizes <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">    __type(key, u64); <span class="comment">/* address */</span></span><br><span class="line">    __type(value, <span class="keyword">struct</span> alloc_info);</span><br><span class="line">    __uint(max_entries, ALLOCS_MAX_ENTRIES);</span><br><span class="line">&#125; allocs <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">    __type(key, u64); <span class="comment">/* stack id */</span></span><br><span class="line">    __type(value, <span class="keyword">union</span> combined_alloc_info);</span><br><span class="line">    __uint(max_entries, COMBINED_ALLOCS_MAX_ENTRIES);</span><br><span class="line">&#125; combined_allocs <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_HASH);</span><br><span class="line">    __type(key, u64);</span><br><span class="line">    __type(value, u64);</span><br><span class="line">    __uint(max_entries, <span class="number">10240</span>);</span><br><span class="line">&#125; memptrs <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type, BPF_MAP_TYPE_STACK_TRACE);</span><br><span class="line">    __type(key, u32);</span><br><span class="line">&#125; stack_traces <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">union</span> <span class="title">combined_alloc_info</span> <span class="title">initial_cinfo</span>;</span></span><br></pre></td></tr></table></figure>
<p>这段代码首先定义了一些可配置的参数，如 <code>min_size</code>, <code>max_size</code>, <code>page_size</code>, <code>sample_rate</code>, <code>trace_all</code>, <code>stack_flags</code> 和 <code>wa_missing_free</code>，分别表示最小分配大小、最大分配大小、页面大小、采样率、是否追踪所有分配、堆栈标志和是否工作在缺失释放（missing free）模式。</p>
<p>接着定义了五个映射：</p>
<ol>
<li><code>sizes</code>：这是一个哈希类型的映射，键为进程 ID，值为 <code>u64</code> 类型，存储每个进程的分配大小。</li>
<li><code>allocs</code>：这也是一个哈希类型的映射，键为分配的地址，值为 <code>alloc_info</code> 结构体，存储每个内存分配的详细信息。</li>
<li><code>combined_allocs</code>：这是另一个哈希类型的映射，键为堆栈 ID，值为 <code>combined_alloc_info</code> 联合体，存储所有未释放分配的总大小和总次数。</li>
<li><code>memptrs</code>：这也是一个哈希类型的映射，键和值都为 <code>u64</code> 类型，用于在用户空间和内核空间之间传递内存指针。</li>
<li><code>stack_traces</code>：这是一个堆栈追踪类型的映射，键为 <code>u32</code> 类型，用于存储堆栈 ID。</li>
</ol>
<p>以用户态的内存分配追踪部分为例，主要是挂钩内存相关的函数调用，如 <code>malloc</code>, <code>free</code>, <code>calloc</code>, <code>realloc</code>, <code>mmap</code> 和 <code>munmap</code>，以便在调用这些函数时进行数据记录。在用户态，<code>memleak</code> 主要使用了 uprobes 技术进行挂载。</p>
<p>每个函数调用被分为 “enter” 和 “exit” 两部分。”enter” 部分记录的是函数调用的参数，如分配的大小或者释放的地址。”exit” 部分则主要用于获取函数的返回值，如分配得到的内存地址。</p>
<p>这里，<code>gen_alloc_enter</code>, <code>gen_alloc_exit</code>, <code>gen_free_enter</code> 是实现记录行为的函数，他们分别用于记录分配开始、分配结束和释放开始的相关信息。</p>
<p>函数原型示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;uprobe&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_KPROBE</span><span class="params">(malloc_enter, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 记录分配开始的相关信息</span></span><br><span class="line">    <span class="keyword">return</span> gen_alloc_enter(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;uretprobe&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_KRETPROBE</span><span class="params">(malloc_exit)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 记录分配结束的相关信息</span></span><br><span class="line">    <span class="keyword">return</span> gen_alloc_exit(ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;uprobe&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_KPROBE</span><span class="params">(free_enter, <span class="type">void</span> *address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 记录释放开始的相关信息</span></span><br><span class="line">    <span class="keyword">return</span> gen_free_enter(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>malloc_enter</code> 和 <code>free_enter</code> 是分别挂载在 <code>malloc</code> 和 <code>free</code> 函数入口处的探针（probes），用于在函数调用时进行数据记录。而 <code>malloc_exit</code> 则是挂载在 <code>malloc</code> 函数的返回处的探针，用于记录函数的返回值。</p>
<p>这些函数使用了 <code>BPF_KPROBE</code> 和 <code>BPF_KRETPROBE</code> 这两个宏来声明，这两个宏分别用于声明 kprobe（内核探针）和 kretprobe（内核返回探针）。具体来说，kprobe 用于在函数调用时触发，而 kretprobe 则是在函数返回时触发。</p>
<p><code>gen_alloc_enter</code> 函数是在内存分配请求的开始时被调用的。这个函数主要负责在调用分配内存的函数时收集一些基本的信息。下面我们将深入探讨这个函数的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gen_alloc_enter</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; min_size || size &gt; max_size)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sample_rate &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bpf_ktime_get_ns() % sample_rate != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">pid_t</span> pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    bpf_map_update_elem(&amp;sizes, &amp;pid, &amp;size, BPF_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trace_all)</span><br><span class="line">        bpf_printk(<span class="string">&quot;alloc entered, size = %lu\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;uprobe&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_KPROBE</span><span class="params">(malloc_enter, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gen_alloc_enter(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，<code>gen_alloc_enter</code> 函数接收一个 <code>size</code> 参数，这个参数表示请求分配的内存的大小。如果这个值不在 <code>min_size</code> 和 <code>max_size</code> 之间，函数将直接返回，不再进行后续的操作。这样可以使工具专注于追踪特定范围的内存分配请求，过滤掉不感兴趣的分配请求。</p>
<p>接下来，函数检查采样率 <code>sample_rate</code>。如果 <code>sample_rate</code> 大于1，意味着我们不需要追踪所有的内存分配请求，而是周期性地追踪。这里使用 <code>bpf_ktime_get_ns</code> 获取当前的时间戳，然后通过取模运算来决定是否需要追踪当前的内存分配请求。这是一种常见的采样技术，用于降低性能开销，同时还能够提供一个代表性的样本用于分析。</p>
<p>之后，函数使用 <code>bpf_get_current_pid_tgid</code> 函数获取当前进程的 PID。注意这里的 PID 实际上是进程和线程的组合 ID，我们通过右移 32 位来获取真正的进程 ID。</p>
<p>函数接下来更新 <code>sizes</code> 这个 map，这个 map 以进程 ID 为键，以请求的内存分配大小为值。<code>BPF_ANY</code> 表示如果 key 已存在，那么更新 value，否则就新建一个条目。</p>
<p>最后，如果启用了 <code>trace_all</code> 标志，函数将打印一条信息，说明发生了内存分配。</p>
<p>最后定义了 <code>BPF_KPROBE(malloc_enter, size_t size)</code>，它会在 <code>malloc</code> 函数被调用时被 BPF uprobe 拦截执行，并通过 <code>gen_alloc_enter</code> 来记录内存分配大小。 我们刚刚分析了内存分配的入口函数 <code>gen_alloc_enter</code>，现在我们来关注这个过程的退出部分。具体来说，我们将讨论 <code>gen_alloc_exit2</code> 函数以及如何从内存分配调用中获取返回的内存地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gen_alloc_exit2</span><span class="params">(<span class="type">void</span> *ctx, u64 address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">pid_t</span> pid = bpf_get_current_pid_tgid() &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_info</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> u64* size = bpf_map_lookup_elem(&amp;sizes, &amp;pid);</span><br><span class="line">    <span class="keyword">if</span> (!size)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// missed alloc entry</span></span><br><span class="line"></span><br><span class="line">    __builtin_memset(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(info));</span><br><span class="line"></span><br><span class="line">    info.size = *size;</span><br><span class="line">    bpf_map_delete_elem(&amp;sizes, &amp;pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (address != <span class="number">0</span>) &#123;</span><br><span class="line">        info.timestamp_ns = bpf_ktime_get_ns();</span><br><span class="line"></span><br><span class="line">        info.stack_id = bpf_get_stackid(ctx, &amp;stack_traces, stack_flags);</span><br><span class="line"></span><br><span class="line">        bpf_map_update_elem(&amp;allocs, &amp;address, &amp;info, BPF_ANY);</span><br><span class="line"></span><br><span class="line">        update_statistics_add(info.stack_id, info.size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trace_all) &#123;</span><br><span class="line">        bpf_printk(<span class="string">&quot;alloc exited, size = %lu, result = %lx\n&quot;</span>,</span><br><span class="line">                info.size, address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gen_alloc_exit</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gen_alloc_exit2(ctx, PT_REGS_RC(ctx));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;uretprobe&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_KRETPROBE</span><span class="params">(malloc_exit)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gen_alloc_exit(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>gen_alloc_exit2</code> 函数在内存分配操作完成时被调用，这个函数接收两个参数，一个是上下文 <code>ctx</code>，另一个是内存分配函数返回的内存地址 <code>address</code>。</p>
<p>首先，它获取当前线程的 PID，然后使用这个 PID 作为键在 <code>sizes</code> 这个 map 中查找对应的内存分配大小。如果没有找到（也就是说，没有对应的内存分配操作的入口），函数就会直接返回。</p>
<p>接着，函数清除 <code>info</code> 结构体的内容，并设置它的 <code>size</code> 字段为之前在 map 中找到的内存分配大小。并从 <code>sizes</code> 这个 map 中删除相应的元素，因为此时内存分配操作已经完成，不再需要这个信息。</p>
<p>接下来，如果 <code>address</code> 不为 0（也就是说，内存分配操作成功了），函数就会进一步收集一些额外的信息。首先，它获取当前的时间戳作为内存分配完成的时间，并获取当前的堆栈跟踪。这些信息都会被储存在 <code>info</code> 结构体中，并随后更新到 <code>allocs</code> 这个 map 中。</p>
<p>最后，函数调用 <code>update_statistics_add</code> 更新统计数据，如果启用了所有内存分配操作的跟踪，函数还会打印一些关于内存分配操作的信息。</p>
<p>请注意，<code>gen_alloc_exit</code> 函数是 <code>gen_alloc_exit2</code> 的一个包装，它将 <code>PT_REGS_RC(ctx)</code> 作为 <code>address</code> 参数传递给 <code>gen_alloc_exit2</code>。在我们的讨论中，我们刚刚提到在<code>gen_alloc_exit2</code>函数中，调用了<code>update_statistics_add</code> 函数以更新内存分配的统计数据。下面我们详细看一下这个函数的具体实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_statistics_add</span><span class="params">(u64 stack_id, u64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">combined_alloc_info</span> *<span class="title">existing_cinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    existing_cinfo = bpf_map_lookup_or_try_init(&amp;combined_allocs, &amp;stack_id, &amp;initial_cinfo);</span><br><span class="line">    <span class="keyword">if</span> (!existing_cinfo)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">union</span> <span class="title">combined_alloc_info</span> <span class="title">incremental_cinfo</span> =</span> &#123;</span><br><span class="line">        .total_size = sz,</span><br><span class="line">        .number_of_allocs = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    __sync_fetch_and_add(&amp;existing_cinfo-&gt;bits, incremental_cinfo.bits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>update_statistics_add</code> 函数接收两个参数：当前的堆栈 ID <code>stack_id</code> 以及内存分配的大小 <code>sz</code>。这两个参数都在内存分配事件中收集到，并且用于更新内存分配的统计数据。</p>
<p>首先，函数尝试在 <code>combined_allocs</code> 这个 map 中查找键值为当前堆栈 ID 的元素，如果找不到，就用 <code>initial_cinfo</code>（这是一个默认的 combined_alloc_info 结构体，所有字段都为零）来初始化新的元素。</p>
<p>接着，函数创建一个 <code>incremental_cinfo</code>，并设置它的 <code>total_size</code> 为当前内存分配的大小，设置 <code>number_of_allocs</code> 为 1。这是因为每次调用 <code>update_statistics_add</code> 函数都表示有一个新的内存分配事件发生，而这个事件的内存分配大小就是 <code>sz</code>。</p>
<p>最后，函数使用 <code>__sync_fetch_and_add</code> 函数原子地将 <code>incremental_cinfo</code> 的值加到 <code>existing_cinfo</code> 中。请注意这个步骤是线程安全的，即使有多个线程并发地调用 <code>update_statistics_add</code> 函数，每个内存分配事件也能正确地记录到统计数据中。</p>
<p>总的来说，<code>update_statistics_add</code> 函数实现了内存分配统计的更新逻辑，通过维护每个堆栈 ID 的内存分配总量和次数，我们可以深入了解到程序的内存分配行为。 在我们对内存分配的统计跟踪过程中，我们不仅要统计内存的分配，还要考虑内存的释放。在上述代码中，我们定义了一个名为 <code>update_statistics_del</code> 的函数，其作用是在内存释放时更新统计信息。而 <code>gen_free_enter</code> 函数则是在进程调用 <code>free</code> 函数时被执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_statistics_del</span><span class="params">(u64 stack_id, u64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">combined_alloc_info</span> *<span class="title">existing_cinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    existing_cinfo = bpf_map_lookup_elem(&amp;combined_allocs, &amp;stack_id);</span><br><span class="line">    <span class="keyword">if</span> (!existing_cinfo) &#123;</span><br><span class="line">        bpf_printk(<span class="string">&quot;failed to lookup combined allocs\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">union</span> <span class="title">combined_alloc_info</span> <span class="title">decremental_cinfo</span> =</span> &#123;</span><br><span class="line">        .total_size = sz,</span><br><span class="line">        .number_of_allocs = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    __sync_fetch_and_sub(&amp;existing_cinfo-&gt;bits, decremental_cinfo.bits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>update_statistics_del</code> 函数的参数为堆栈 ID 和要释放的内存块大小。函数首先在 <code>combined_allocs</code> 这个 map 中使用当前的堆栈 ID 作为键来查找相应的 <code>combined_alloc_info</code> 结构体。如果找不到，就输出错误信息，然后函数返回。如果找到了，就会构造一个名为 <code>decremental_cinfo</code> 的 <code>combined_alloc_info</code> 结构体，设置它的 <code>total_size</code> 为要释放的内存大小，设置 <code>number_of_allocs</code> 为 1。然后使用 <code>__sync_fetch_and_sub</code> 函数原子地从 <code>existing_cinfo</code> 中减去 <code>decremental_cinfo</code> 的值。请注意，这里的 <code>number_of_allocs</code> 是负数，表示减少了一个内存分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gen_free_enter</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> u64 addr = (u64)address;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">alloc_info</span> *<span class="title">info</span> =</span> bpf_map_lookup_elem(&amp;allocs, &amp;addr);</span><br><span class="line">    <span class="keyword">if</span> (!info)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bpf_map_delete_elem(&amp;allocs, &amp;addr);</span><br><span class="line">    update_statistics_del(info-&gt;stack_id, info-&gt;size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trace_all) &#123;</span><br><span class="line">        bpf_printk(<span class="string">&quot;free entered, address = %lx, size = %lu\n&quot;</span>,</span><br><span class="line">                address, info-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;uprobe&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">BPF_KPROBE</span><span class="params">(free_enter, <span class="type">void</span> *address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> gen_free_enter(address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来看 <code>gen_free_enter</code> 函数。它接收一个地址作为参数，这个地址是内存分配的结果，也就是将要释放的内存的起始地址。函数首先在 <code>allocs</code> 这个 map 中使用这个地址作为键来查找对应的 <code>alloc_info</code> 结构体。如果找不到，那么就直接返回，因为这意味着这个地址并没有被分配过。如果找到了，那么就删除这个元素，并且调用 <code>update_statistics_del</code> 函数来更新统计数据。最后，如果启用了全局追踪，那么还会输出一条信息，包括这个地址以及它的大小。 在我们追踪和统计内存分配的同时，我们也需要对内核态的内存分配和释放进行追踪。在Linux内核中，kmem_cache_alloc函数和kfree函数分别用于内核态的内存分配和释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;tracepoint/kmem/kfree&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">memleak__kfree</span><span class="params">(<span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (has_kfree()) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">trace_event_raw_kfree___x</span> *<span class="title">args</span> =</span> ctx;</span><br><span class="line">        ptr = BPF_CORE_READ(args, ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> trace_event_raw_kmem_free___x *args = ctx;</span><br><span class="line">        ptr = BPF_CORE_READ(args, ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gen_free_enter(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码片段定义了一个函数memleak__kfree，这是一个bpf程序，会在内核调用kfree函数时执行。首先，该函数检查是否存在kfree函数。如果存在，则会读取传递给kfree函数的参数（即要释放的内存块的地址），并保存到变量ptr中；否则，会读取传递给kmem_free函数的参数（即要释放的内存块的地址），并保存到变量ptr中。接着，该函数会调用之前定义的gen_free_enter函数来处理该内存块的释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SEC(<span class="string">&quot;tracepoint/kmem/kmem_cache_alloc&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">memleak__kmem_cache_alloc</span><span class="params">(<span class="keyword">struct</span> trace_event_raw_kmem_alloc *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (wa_missing_free)</span><br><span class="line">        gen_free_enter(ctx-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    gen_alloc_enter(ctx-&gt;bytes_alloc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gen_alloc_exit2(ctx, (u64)(ctx-&gt;ptr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码定义了一个函数 memleak__kmem_cache_alloc，这也是一个bpf程序，会在内核调用 <code>kmem_cache_alloc</code>函数时执行。如果标记 wa_missing_free 被设置，则调用 gen_free_enter 函数处理可能遗漏的释放操作。然后，该函数会调用 gen_alloc_enter 函数来处理内存分配，最后调用gen_alloc_exit2函数记录分配的结果。</p>
<p>这两个 bpf 程序都使用了 SEC 宏定义了对应的 tracepoint，以便在相应的内核函数被调用时得到执行。在Linux内核中，tracepoint 是一种可以在内核中插入的静态钩子，可以用来收集运行时的内核信息，它在调试和性能分析中非常有用。</p>
<p>在理解这些代码的过程中，要注意 BPF_CORE_READ 宏的使用。这个宏用于在 bpf 程序中读取内核数据。在 bpf 程序中，我们不能直接访问内核内存，而需要使用这样的宏来安全地读取数据。</p>
<h3 id="用户态程序-1"><a href="#用户态程序-1" class="headerlink" title="用户态程序"></a>用户态程序</h3><p>在理解 BPF 内核部分之后，我们转到用户空间程序。用户空间程序与BPF内核程序紧密配合，它负责将BPF程序加载到内核，设置和管理BPF map，以及处理从BPF程序收集到的数据。用户态程序较长，我们这里可以简要参考一下它的挂载点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int attach_uprobes(struct memleak_bpf *skel)</span><br><span class="line">&#123;</span><br><span class="line">    ATTACH_UPROBE_CHECKED(skel, malloc, malloc_enter);</span><br><span class="line">    ATTACH_URETPROBE_CHECKED(skel, malloc, malloc_exit);</span><br><span class="line"></span><br><span class="line">    ATTACH_UPROBE_CHECKED(skel, calloc, calloc_enter);</span><br><span class="line">    ATTACH_URETPROBE_CHECKED(skel, calloc, calloc_exit);</span><br><span class="line"></span><br><span class="line">    ATTACH_UPROBE_CHECKED(skel, realloc, realloc_enter);</span><br><span class="line">    ATTACH_URETPROBE_CHECKED(skel, realloc, realloc_exit);</span><br><span class="line"></span><br><span class="line">    ATTACH_UPROBE_CHECKED(skel, mmap, mmap_enter);</span><br><span class="line">    ATTACH_URETPROBE_CHECKED(skel, mmap, mmap_exit);</span><br><span class="line"></span><br><span class="line">    ATTACH_UPROBE_CHECKED(skel, posix_memalign, posix_memalign_enter);</span><br><span class="line">    ATTACH_URETPROBE_CHECKED(skel, posix_memalign, posix_memalign_exit);</span><br><span class="line"></span><br><span class="line">    ATTACH_UPROBE_CHECKED(skel, memalign, memalign_enter);</span><br><span class="line">    ATTACH_URETPROBE_CHECKED(skel, memalign, memalign_exit);</span><br><span class="line"></span><br><span class="line">    ATTACH_UPROBE_CHECKED(skel, free, free_enter);</span><br><span class="line">    ATTACH_UPROBE_CHECKED(skel, munmap, munmap_enter);</span><br><span class="line"></span><br><span class="line">    // the following probes are intentinally allowed to fail attachment</span><br><span class="line"></span><br><span class="line">    // deprecated in libc.so bionic</span><br><span class="line">    ATTACH_UPROBE(skel, valloc, valloc_enter);</span><br><span class="line">    ATTACH_URETPROBE(skel, valloc, valloc_exit);</span><br><span class="line"></span><br><span class="line">    // deprecated in libc.so bionic</span><br><span class="line">    ATTACH_UPROBE(skel, pvalloc, pvalloc_enter);</span><br><span class="line">    ATTACH_URETPROBE(skel, pvalloc, pvalloc_exit);</span><br><span class="line"></span><br><span class="line">    // added in C11</span><br><span class="line">    ATTACH_UPROBE(skel, aligned_alloc, aligned_alloc_enter);</span><br><span class="line">    ATTACH_URETPROBE(skel, aligned_alloc, aligned_alloc_exit);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们看到一个名为<code>attach_uprobes</code>的函数，该函数负责将uprobes（用户空间探测点）挂载到内存分配和释放函数上。在Linux中，uprobes是一种内核机制，可以在用户空间程序中的任意位置设置断点，这使得我们可以非常精确地观察和控制用户空间程序的行为。</p>
<p>这里，每个内存相关的函数都通过两个uprobes进行跟踪：一个在函数入口（enter），一个在函数退出（exit）。因此，每当这些函数被调用或返回时，都会触发一个uprobes事件，进而触发相应的BPF程序。</p>
<p>在具体的实现中，我们使用了<code>ATTACH_UPROBE</code>和<code>ATTACH_URETPROBE</code>两个宏来附加uprobes和uretprobes（函数返回探测点）。每个宏都需要三个参数：BPF程序的骨架（skel），要监视的函数名，以及要触发的BPF程序的名称。</p>
<p>这些挂载点包括常见的内存分配函数，如malloc、calloc、realloc、mmap、posix_memalign、memalign、free等，以及对应的退出点。另外，我们也观察一些可能的分配函数，如valloc、pvalloc、aligned_alloc等，尽管它们可能不总是存在。</p>
<p>这些挂载点的目标是捕获所有可能的内存分配和释放事件，从而使我们的内存泄露检测工具能够获取到尽可能全面的数据。这种方法可以让我们不仅能跟踪到内存分配和释放，还能得到它们发生的上下文信息，例如调用栈和调用次数，从而帮助我们定位和修复内存泄露问题。</p>
<p>注意，一些内存分配函数可能并不存在或已弃用，比如valloc、pvalloc等，因此它们的附加可能会失败。在这种情况下，我们允许附加失败，并不会阻止程序的执行。这是因为我们更关注的是主流和常用的内存分配函数，而这些已经被弃用的函数往往在实际应用中较少使用。</p>
<p>完整的源代码：<a href="https://gitee.com/link?target=https%3A%2F%2Fgithub.com%2Feunomia-bpf%2Fbpf-developer-tutorial%2Ftree%2Fmain%2Fsrc%2F16-memleak">https://github.com/eunomia-bpf/bpf-developer-tutorial/tree/main/src/16-memleak</a></p>
<h3 id="编译运行-5"><a href="#编译运行-5" class="headerlink" title="编译运行"></a>编译运行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/iovisor/bcc.git --recurse-submodules </span><br><span class="line">$ cd libbpf-tools/</span><br><span class="line">$ make memleak</span><br><span class="line">$ sudo ./memleak </span><br><span class="line">using default object: libc.so.6</span><br><span class="line">using page size: 4096</span><br><span class="line">tracing kernel: true</span><br><span class="line">Tracing outstanding memory allocs...  Hit Ctrl-C to end</span><br><span class="line">[17:17:27] Top 10 stacks with outstanding allocations:</span><br><span class="line">1236992 bytes in 302 allocations from stack</span><br><span class="line">        0 [&lt;ffffffff812c8f43&gt;] &lt;null sym&gt;</span><br><span class="line">        1 [&lt;ffffffff812c8f43&gt;] &lt;null sym&gt;</span><br><span class="line">        2 [&lt;ffffffff812a9d42&gt;] &lt;null sym&gt;</span><br><span class="line">        3 [&lt;ffffffff812aa392&gt;] &lt;null sym&gt;</span><br><span class="line">        4 [&lt;ffffffff810df0cb&gt;] &lt;null sym&gt;</span><br><span class="line">        5 [&lt;ffffffff81edc3fd&gt;] &lt;null sym&gt;</span><br><span class="line">        6 [&lt;ffffffff82000b62&gt;] &lt;null sym&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>通过本篇 eBPF 入门实践教程，您已经学习了如何编写 Memleak eBPF 监控程序，以实时监控程序的内存泄漏。您已经了解了 eBPF 在内存监控方面的应用，学会了使用 BPF API 编写 eBPF 程序，创建和使用 eBPF maps，并且明白了如何用 eBPF 工具监测和分析内存泄漏问题。我们展示了一个详细的例子，帮助您理解 eBPF 代码的运行流程和原理。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/09/04/bpf%E4%B9%8B%E5%B7%85/" rel="prev" title="BPF之巅--洞悉Linux系统和应用性能">
      <i class="fa fa-chevron-left"></i> BPF之巅--洞悉Linux系统和应用性能
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/01/25/cpp%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/" rel="next" title="C++优化手册 Agner Fog">
      C++优化手册 Agner Fog <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.</span> <span class="nav-text">模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%90%AD%E5%BB%BABPF%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">2.</span> <span class="nav-text">搭建BPF程序运行环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81"><span class="nav-number">2.1.</span> <span class="nav-text">下载内核源码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E9%A1%B9"><span class="nav-number">2.2.</span> <span class="nav-text">安装依赖项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85Clang%E5%92%8CLLVM"><span class="nav-number">2.3.</span> <span class="nav-text">安装Clang和LLVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%86%85%E6%A0%B8"><span class="nav-number">2.4.</span> <span class="nav-text">配置内核</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3modpost-not-found%E9%94%99%E8%AF%AF"><span class="nav-number">2.5.</span> <span class="nav-text">解决modpost: not found错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E5%86%85%E6%A0%B8%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">2.6.</span> <span class="nav-text">关联内核头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E7%A8%8B%E5%BA%8F%E6%A0%B7%E4%BE%8B"><span class="nav-number">2.7.</span> <span class="nav-text">编译内核程序样例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8BPF-C%E7%BC%96%E5%86%99hello-world%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">使用BPF C编写hello world程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%88%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%E5%8E%9F%E7%90%86%E5%90%A7"><span class="nav-number">3.1.</span> <span class="nav-text">先了解一下原理吧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hello-world%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.2.</span> <span class="nav-text">hello world程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9Makefile"><span class="nav-number">3.3.</span> <span class="nav-text">修改Makefile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91"><span class="nav-number">3.4.</span> <span class="nav-text">编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C"><span class="nav-number">3.5.</span> <span class="nav-text">运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5"><span class="nav-number">3.6.</span> <span class="nav-text">进一步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BPF%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E8%8A%82-section"><span class="nav-number">3.6.1.</span> <span class="nav-text">BPF程序中的节(section)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BPF%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81-bytecode"><span class="nav-number">3.6.2.</span> <span class="nav-text">BPF程序中的字节码(bytecode)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BPF%E5%86%85%E6%A0%B8%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BD%AC%E6%8D%A2%E4%B8%BABPF%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">3.6.3.</span> <span class="nav-text">BPF内核辅助函数调用转换为BPF字节码的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BPF%E7%A8%8B%E5%BA%8F%E5%88%B0BPF%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%EF%BC%9AClang%E4%B8%8ELLVM"><span class="nav-number">3.6.4.</span> <span class="nav-text">BPF程序到BPF字节码的编译过程：Clang与LLVM</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%99%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">教程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Hello-World%EF%BC%8C%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E5%92%8C%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="nav-number">4.1.</span> <span class="nav-text">Hello World，基本框架和开发流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#eBPF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="nav-number">4.1.1.</span> <span class="nav-text">eBPF开发环境准备与基本开发流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E5%BF%85%E8%A6%81%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%92%8C%E5%B7%A5%E5%85%B7"><span class="nav-number">4.1.2.</span> <span class="nav-text">安装必要的软件和工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85-eunomia-bpf-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="nav-number">4.1.3.</span> <span class="nav-text">下载安装 eunomia-bpf 开发工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hello-World-minimal-eBPF-program"><span class="nav-number">4.1.4.</span> <span class="nav-text">Hello World - minimal eBPF program</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eBPF-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6"><span class="nav-number">4.1.5.</span> <span class="nav-text">eBPF 程序的基本框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tracepoints"><span class="nav-number">4.1.6.</span> <span class="nav-text">tracepoints</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">4.1.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-eBPF-%E4%B8%AD%E4%BD%BF%E7%94%A8-kprobe-%E7%9B%91%E6%B5%8B%E6%8D%95%E8%8E%B7-unlink-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">在 eBPF 中使用 kprobe 监测捕获 unlink 系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kprobes-%E6%8A%80%E6%9C%AF%E8%83%8C%E6%99%AF"><span class="nav-number">4.2.1.</span> <span class="nav-text">kprobes 技术背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kprobe-%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.2.2.</span> <span class="nav-text">kprobe 示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-eBPF-%E4%B8%AD%E4%BD%BF%E7%94%A8-fentry-%E7%9B%91%E6%B5%8B%E6%8D%95%E8%8E%B7-unlink-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">4.3.</span> <span class="nav-text">在 eBPF 中使用 fentry 监测捕获 unlink 系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Fentry"><span class="nav-number">4.3.1.</span> <span class="nav-text">Fentry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">4.3.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-eBPF-%E4%B8%AD%E6%8D%95%E8%8E%B7%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E8%BF%87%E6%BB%A4%E8%BF%9B%E7%A8%8B-pid"><span class="nav-number">4.4.</span> <span class="nav-text">在 eBPF 中捕获进程打开文件的系统调用集合，使用全局变量过滤进程 pid</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-eBPF-%E4%B8%AD%E6%8D%95%E8%8E%B7%E8%BF%9B%E7%A8%8B%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%9B%86%E5%90%88"><span class="nav-number">4.4.1.</span> <span class="nav-text">在 eBPF 中捕获进程打开文件的系统调用集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%9C%A8-eBPF-%E4%B8%AD%E8%BF%87%E6%BB%A4%E8%BF%9B%E7%A8%8B-pid"><span class="nav-number">4.4.2.</span> <span class="nav-text">使用全局变量在 eBPF 中过滤进程 pid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-number">4.4.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-eBPF-%E4%B8%AD%E4%BD%BF%E7%94%A8-uprobe-%E6%8D%95%E8%8E%B7-bash-%E7%9A%84-readline-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">4.5.</span> <span class="nav-text">在 eBPF 中使用 uprobe 捕获 bash 的 readline 函数调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFuprobe"><span class="nav-number">4.5.1.</span> <span class="nav-text">什么是uprobe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-uprobe-%E6%8D%95%E8%8E%B7-bash-%E7%9A%84-readline-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">4.5.2.</span> <span class="nav-text">使用 uprobe 捕获 bash 的 readline 函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-number">4.5.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%9B%86%E5%90%88%EF%BC%8C%E4%BD%BF%E7%94%A8-hash-map-%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81"><span class="nav-number">4.6.</span> <span class="nav-text">捕获进程发送信号的系统调用集合，使用 hash map 保存状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-4"><span class="nav-number">4.6.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C-%E9%80%80%E5%87%BA%E6%97%B6%E9%97%B4%EF%BC%8C%E9%80%9A%E8%BF%87-perf-event-array-%E5%90%91%E7%94%A8%E6%88%B7%E6%80%81%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA"><span class="nav-number">4.7.</span> <span class="nav-text">捕获进程执行&#x2F;退出时间，通过 perf event array 向用户态打印输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#perf-buffer"><span class="nav-number">4.7.1.</span> <span class="nav-text">perf buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#execsnoop"><span class="nav-number">4.7.2.</span> <span class="nav-text">execsnoop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-5"><span class="nav-number">4.7.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-eBPF-%E4%B8%AD%E4%BD%BF%E7%94%A8-exitsnoop-%E7%9B%91%E6%8E%A7%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E4%BA%8B%E4%BB%B6%EF%BC%8C%E4%BD%BF%E7%94%A8-ring-buffer-%E5%90%91%E7%94%A8%E6%88%B7%E6%80%81%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA"><span class="nav-number">4.8.</span> <span class="nav-text">在 eBPF 中使用 exitsnoop 监控进程退出事件，使用 ring buffer 向用户态打印输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ring-buffer"><span class="nav-number">4.8.1.</span> <span class="nav-text">ring buffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eBPF-ringbuf-vs-eBPF-perfbuf"><span class="nav-number">4.8.2.</span> <span class="nav-text">eBPF ringbuf vs eBPF perfbuf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exitsnoop"><span class="nav-number">4.8.3.</span> <span class="nav-text">exitsnoop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Compile-and-Run"><span class="nav-number">4.8.4.</span> <span class="nav-text">Compile and Run</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-6"><span class="nav-number">4.8.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%BB%B6%E8%BF%9F%EF%BC%8C%E4%BB%A5%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%96%B9%E5%BC%8F%E8%AE%B0%E5%BD%95"><span class="nav-number">4.9.</span> <span class="nav-text">捕获进程调度延迟，以直方图方式记录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#runqlat-%E5%8E%9F%E7%90%86"><span class="nav-number">4.9.1.</span> <span class="nav-text">runqlat 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runqlat-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.9.2.</span> <span class="nav-text">runqlat 代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runqlat-h"><span class="nav-number">4.9.3.</span> <span class="nav-text">runqlat.h</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C"><span class="nav-number">4.9.4.</span> <span class="nav-text">编译运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-7"><span class="nav-number">4.9.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-eBPF-%E4%B8%AD%E4%BD%BF%E7%94%A8-hardirqs-%E6%88%96-softirqs-%E6%8D%95%E8%8E%B7%E4%B8%AD%E6%96%AD%E4%BA%8B%E4%BB%B6"><span class="nav-number">4.10.</span> <span class="nav-text">在 eBPF 中使用 hardirqs 或 softirqs 捕获中断事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hardirqs-%E5%92%8C-softirqs-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">4.10.1.</span> <span class="nav-text">hardirqs 和 softirqs 是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">4.10.2.</span> <span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hardirqs-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.10.3.</span> <span class="nav-text">hardirqs 代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="nav-number">4.10.4.</span> <span class="nav-text">运行代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-8"><span class="nav-number">4.10.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-eBPF-%E4%B8%AD%E4%BD%BF%E7%94%A8-libbpf-%E5%BC%80%E5%8F%91%E7%94%A8%E6%88%B7%E6%80%81%E7%A8%8B%E5%BA%8F%E5%B9%B6%E8%B7%9F%E8%B8%AA-exec-%E5%92%8C-exit-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">4.11.</span> <span class="nav-text">在 eBPF 中使用 libbpf 开发用户态程序并跟踪 exec() 和 exit() 系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#libbpf-%E5%BA%93%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E5%AE%83"><span class="nav-number">4.11.1.</span> <span class="nav-text">libbpf 库，以及为什么需要使用它</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-bootstrap"><span class="nav-number">4.11.2.</span> <span class="nav-text">什么是 bootstrap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bootstrap"><span class="nav-number">4.11.3.</span> <span class="nav-text">Bootstrap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81-eBPF-%E7%A8%8B%E5%BA%8F-bootstrap-bpf-c"><span class="nav-number">4.11.3.0.1.</span> <span class="nav-text">内核态 eBPF 程序 bootstrap.bpf.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%EF%BC%8Cbootstrap-c"><span class="nav-number">4.11.3.0.2.</span> <span class="nav-text">用户态，bootstrap.c</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96"><span class="nav-number">4.11.3.0.3.</span> <span class="nav-text">安装依赖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C-1"><span class="nav-number">4.11.3.0.4.</span> <span class="nav-text">编译运行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-9"><span class="nav-number">4.11.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-eBPF-%E7%A8%8B%E5%BA%8F-profile-%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-number">4.12.</span> <span class="nav-text">使用 eBPF 程序 profile 进行性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#eBPF-%E5%B7%A5%E5%85%B7%EF%BC%9Aprofile-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E7%A4%BA%E4%BE%8B"><span class="nav-number">4.12.1.</span> <span class="nav-text">eBPF 工具：profile 性能分析示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="nav-number">4.12.2.</span> <span class="nav-text">实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E9%83%A8%E5%88%86"><span class="nav-number">4.12.2.1.</span> <span class="nav-text">内核态部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E9%83%A8%E5%88%86"><span class="nav-number">4.12.2.2.</span> <span class="nav-text">用户态部分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-10"><span class="nav-number">4.12.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1-TCP-%E8%BF%9E%E6%8E%A5%E5%BB%B6%E6%97%B6%EF%BC%8C%E5%B9%B6%E4%BD%BF%E7%94%A8-libbpf-%E5%9C%A8%E7%94%A8%E6%88%B7%E6%80%81%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE"><span class="nav-number">4.13.</span> <span class="nav-text">统计 TCP 连接延时，并使用 libbpf 在用户态处理数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">4.13.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcpconnlat-%E5%B7%A5%E5%85%B7%E6%A6%82%E8%BF%B0"><span class="nav-number">4.13.2.</span> <span class="nav-text">tcpconnlat 工具概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E8%BF%9E%E6%8E%A5%E5%8E%9F%E7%90%86"><span class="nav-number">4.13.2.1.</span> <span class="nav-text">TCP 连接原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcpconnlat-%E7%9A%84-eBPF-%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.13.3.</span> <span class="nav-text">tcpconnlat 的 eBPF 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tcp-v4-connect-%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="nav-number">4.13.3.1.</span> <span class="nav-text">tcp_v4_connect 函数解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E4%BB%A3%E7%A0%81"><span class="nav-number">4.13.3.2.</span> <span class="nav-text">内核态代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="nav-number">4.13.3.3.</span> <span class="nav-text">用户态数据处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C-2"><span class="nav-number">4.13.4.</span> <span class="nav-text">编译运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-11"><span class="nav-number">4.13.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95-TCP-%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E4%B8%8E-TCP-RTT"><span class="nav-number">4.14.</span> <span class="nav-text">记录 TCP 连接状态与 TCP RTT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tcprtt-%E4%B8%8E-tcpstates"><span class="nav-number">4.14.1.</span> <span class="nav-text">tcprtt 与 tcpstates</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcpstate"><span class="nav-number">4.14.2.</span> <span class="nav-text">tcpstate</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-BPF-Maps"><span class="nav-number">4.14.2.1.</span> <span class="nav-text">定义 BPF Maps</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%BD%E8%B8%AA-TCP-%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="nav-number">4.14.2.2.</span> <span class="nav-text">追踪 TCP 连接状态变化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E6%88%B3"><span class="nav-number">4.14.2.3.</span> <span class="nav-text">更新时间戳</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcprtt"><span class="nav-number">4.14.2.4.</span> <span class="nav-text">tcprtt</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C-3"><span class="nav-number">4.14.3.</span> <span class="nav-text">编译运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-12"><span class="nav-number">4.14.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-USDT-%E6%8D%95%E8%8E%B7%E7%94%A8%E6%88%B7%E6%80%81-Java-GC-%E4%BA%8B%E4%BB%B6%E8%80%97%E6%97%B6"><span class="nav-number">4.15.</span> <span class="nav-text">使用 USDT 捕获用户态 Java GC 事件耗时</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#USDT-%E4%BB%8B%E7%BB%8D"><span class="nav-number">4.15.1.</span> <span class="nav-text">USDT 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%B1%82%E9%9D%A2%E7%9A%84%E8%BF%BD%E8%B8%AA%E6%9C%BA%E5%88%B6%EF%BC%9A%E7%94%A8%E6%88%B7%E7%BA%A7%E5%8A%A8%E6%80%81%E8%B7%9F%E8%B8%AA%E5%92%8C-USDT"><span class="nav-number">4.15.1.1.</span> <span class="nav-text">用户层面的追踪机制：用户级动态跟踪和 USDT</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-GC-%E4%BB%8B%E7%BB%8D"><span class="nav-number">4.15.2.</span> <span class="nav-text">Java GC 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eBPF-%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">4.15.3.</span> <span class="nav-text">eBPF 实现机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E7%A8%8B%E5%BA%8F"><span class="nav-number">4.15.3.1.</span> <span class="nav-text">内核态程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E7%A8%8B%E5%BA%8F"><span class="nav-number">4.15.3.2.</span> <span class="nav-text">用户态程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96-1"><span class="nav-number">4.15.4.</span> <span class="nav-text">安装依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C-4"><span class="nav-number">4.15.5.</span> <span class="nav-text">编译运行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99-eBPF-%E7%A8%8B%E5%BA%8F-Memleak-%E7%9B%91%E6%8E%A7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">4.16.</span> <span class="nav-text">编写 eBPF 程序 Memleak 监控内存泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E6%99%AF%E5%8F%8A%E5%85%B6%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-number">4.16.1.</span> <span class="nav-text">背景及其重要性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%8C%91%E6%88%98"><span class="nav-number">4.16.1.1.</span> <span class="nav-text">调试内存泄漏的挑战</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eBPF-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.16.2.</span> <span class="nav-text">eBPF 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memleak-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">4.16.3.</span> <span class="nav-text">memleak 的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%80%81-eBPF-%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.16.4.</span> <span class="nav-text">内核态 eBPF 程序实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#memleak-%E5%86%85%E6%A0%B8%E6%80%81-eBPF-%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.16.4.1.</span> <span class="nav-text">memleak 内核态 eBPF 程序实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E7%A8%8B%E5%BA%8F-1"><span class="nav-number">4.16.5.</span> <span class="nav-text">用户态程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C-5"><span class="nav-number">4.16.6.</span> <span class="nav-text">编译运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-13"><span class="nav-number">4.16.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
