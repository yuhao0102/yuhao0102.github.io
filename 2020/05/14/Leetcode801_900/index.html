<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Leetcode802. Find Eventual Safe StatesWe start at some node in a directed graph, and every turn, we walk along a directed edge of the graph. If we reach a terminal node (that is, it has no outgoing di">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode801 - 900">
<meta property="og:url" content="http://yoursite.com/2020/05/14/Leetcode801_900/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode802. Find Eventual Safe StatesWe start at some node in a directed graph, and every turn, we walk along a directed edge of the graph. If we reach a terminal node (that is, it has no outgoing di">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/20210904105200.png">
<meta property="og:image" content="http://yoursite.com/img/1028_2.png">
<meta property="og:image" content="http://yoursite.com/img/1028_1.png">
<meta property="og:image" content="http://yoursite.com/img/1028.png">
<meta property="og:image" content="http://yoursite.com/img/1631001223.jpg">
<meta property="og:image" content="http://yoursite.com/img/20200526000300.png">
<meta property="og:image" content="http://yoursite.com/img/20210921184300.png">
<meta property="og:image" content="http://yoursite.com/img/20210921184301.png">
<meta property="og:image" content="http://yoursite.com/img/20190825104.png">
<meta property="og:image" content="http://yoursite.com/img/20190827001.png">
<meta property="og:image" content="http://yoursite.com/img/20190827002.png">
<meta property="og:image" content="http://yoursite.com/img/fivetrees.png">
<meta property="article:published_time" content="2020-05-13T16:41:00.000Z">
<meta property="article:modified_time" content="2022-12-26T08:02:37.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/20210904105200.png">

<link rel="canonical" href="http://yoursite.com/2020/05/14/Leetcode801_900/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>Leetcode801 - 900 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/resume.pdf" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">128</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yuhao0102" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/14/Leetcode801_900/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Leetcode801 - 900
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-14 00:41:00" itemprop="dateCreated datePublished" datetime="2020-05-14T00:41:00+08:00">2020-05-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 16:02:37" itemprop="dateModified" datetime="2022-12-26T16:02:37+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Leetcode802-Find-Eventual-Safe-States"><a href="#Leetcode802-Find-Eventual-Safe-States" class="headerlink" title="Leetcode802. Find Eventual Safe States"></a>Leetcode802. Find Eventual Safe States</h1><p>We start at some node in a directed graph, and every turn, we walk along a directed edge of the graph. If we reach a terminal node (that is, it has no outgoing directed edges), we stop.</p>
<p>We define a starting node to be safe if we must eventually walk to a terminal node. More specifically, there is a natural number k, so that we must have stopped at a terminal node in less than k steps for any choice of where to walk.</p>
<p>Return an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.</p>
<p>The directed graph has n nodes with labels from 0 to n - 1, where n is the length of graph. The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph, going from node i to node j.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Illustration of graph</span><br><span class="line">Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]</span><br><span class="line">Output: [2,4,5,6]</span><br><span class="line">Explanation: The given graph is shown above.</span><br></pre></td></tr></table></figure><br><img src="/img/20210904105200.png" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]</span><br><span class="line">Output: [4]</span><br></pre></td></tr></table></figure></p>
<p>深度优先搜索。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// -1: unknow, 1: safe, 2: visiting, 3: unsafe</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">eventualSafeNodes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">safe</span><span class="params">(size, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">helper</span>(graph, safe, i) == <span class="number">1</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="type">int</span>&gt;&amp; safe, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (safe[cur] == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> safe[cur] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (safe[cur] != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> safe[cur];</span><br><span class="line">        safe[cur] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[cur].<span class="built_in">size</span>(); i ++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">helper</span>(graph, safe, graph[cur][i]) == <span class="number">3</span>)</span><br><span class="line">                <span class="keyword">return</span> safe[cur] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> safe[cur] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode804-Unique-Morse-Code-Words"><a href="#Leetcode804-Unique-Morse-Code-Words" class="headerlink" title="Leetcode804. Unique Morse Code Words"></a>Leetcode804. Unique Morse Code Words</h1><p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: “a” maps to “.-“, “b” maps to “-…”, “c” maps to “-.-.”, and so on.</p>
<p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p>
<p>[“.-“,”-…”,”-.-.”,”-..”,”.”,”..-.”,”—.”,”….”,”..”,”.—-“,”-.-“,”.-..”,”—“,”-.”,”—-“,”.—.”,”—.-“,”.-.”,”…”,”-“,”..-“,”…-“,”.—“,”-..-“,”-.—“,”—..”]<br>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cba” can be written as “-.-..—…”, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word.</p>
<p>Return the number of different transformations among all words we have.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">The transformation of each word is:</span><br><span class="line">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br></pre></td></tr></table></figure><br>There are 2 different transformations, “—…-.” and “—…—.”.<br>Note:</p>
<ul>
<li>The length of words will be at most 100.</li>
<li>Each words[i] will have length in range [1, 12].</li>
<li>words[i] will only consist of lowercase letters.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        string map[<span class="number">26</span>] = &#123;<span class="string">&quot;.-&quot;</span>,<span class="string">&quot;-...&quot;</span>,<span class="string">&quot;-.-.&quot;</span>,<span class="string">&quot;-..&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;..-.&quot;</span>,<span class="string">&quot;--.&quot;</span>,<span class="string">&quot;....&quot;</span>,<span class="string">&quot;..&quot;</span>,<span class="string">&quot;.---&quot;</span>,<span class="string">&quot;-.-&quot;</span>,<span class="string">&quot;.-..&quot;</span>,<span class="string">&quot;--&quot;</span>,<span class="string">&quot;-.&quot;</span>,<span class="string">&quot;---&quot;</span>,<span class="string">&quot;.--.&quot;</span>,<span class="string">&quot;--.-&quot;</span>,<span class="string">&quot;.-.&quot;</span>,<span class="string">&quot;...&quot;</span>,<span class="string">&quot;-&quot;</span>,<span class="string">&quot;..-&quot;</span>,<span class="string">&quot;...-&quot;</span>,<span class="string">&quot;.--&quot;</span>,<span class="string">&quot;-..-&quot;</span>,<span class="string">&quot;-.--&quot;</span>,<span class="string">&quot;--..&quot;</span>&#125;;</span><br><span class="line">        set&lt;string&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; words[i].<span class="built_in">length</span>(); j ++)</span><br><span class="line">                temp += map[words[i][j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            result.<span class="built_in">insert</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>借助set和数组辅助，遍历保存结果，最后统计哈希表的大小</p>
<h1 id="Leetcode806-Number-of-Lines-To-Write-String"><a href="#Leetcode806-Number-of-Lines-To-Write-String" class="headerlink" title="Leetcode806. Number of Lines To Write String"></a>Leetcode806. Number of Lines To Write String</h1><p>We are to write the letters of a given string S, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an array widths, an array where widths[0] is the width of ‘a’, widths[1] is the width of ‘b’, …, and widths[25] is the width of ‘z’.</p>
<p>Now answer two questions: how many lines have at least one character from S, and what is the width used by the last such line? Return your answer as an integer list of length 2.</p>
<p>Example :<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]</span><br><span class="line">S = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">Output: [3, 60]</span><br><span class="line">Explanation: </span><br><span class="line">All letters have the same length of 10. To write all 26 letters,</span><br><span class="line">we need two full lines and one line with 60 units.</span><br></pre></td></tr></table></figure><br>Example :<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]</span><br><span class="line">S = &quot;bbbcccdddaaa&quot;</span><br><span class="line">Output: [2, 4]</span><br><span class="line">Explanation: </span><br><span class="line">All letters except &#x27;a&#x27; have the same length of 10, and </span><br><span class="line">&quot;bbbcccdddaa&quot; will cover 9 * 10 + 2 * 4 = 98 units.</span><br><span class="line">For the last &#x27;a&#x27;, it is written on the second line because</span><br><span class="line">there is only 2 units left in the first line.</span><br><span class="line">So the answer is 2 lines, plus 4 units in the second line.</span><br></pre></td></tr></table></figure><br>Note:</p>
<ul>
<li>The length of S will be in the range [1, 1000].</li>
<li>S will only contain lowercase letters.</li>
<li>widths is an array of length 26.</li>
<li>widths[i] will be in the range of [2, 10].</li>
</ul>
<p>好坑啊，一个字母还不能拆开放。。。。现在的行长度是cur，如果cur加上当前的字母长度超过100了，则从下一行开始，cur变为当前的字母长度。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numberOfLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; widths, string S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;S.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> width = widths[S[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            res = cur + width &gt; <span class="number">100</span> ? res<span class="number">+1</span> : res; </span><br><span class="line">            cur = cur + width &gt; <span class="number">100</span> ? width : cur+width;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;res,cur&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode807-Max-Increase-to-Keep-City-Skyline"><a href="#Leetcode807-Max-Increase-to-Keep-City-Skyline" class="headerlink" title="Leetcode807. Max Increase to Keep City Skyline"></a>Leetcode807. Max Increase to Keep City Skyline</h1><p>In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well. </p>
<p>At the end, the “skyline” when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city’s skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example.</p>
<p>What is the maximum total sum that the height of the buildings can be increased?</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]</span><br><span class="line">Output: 35</span><br><span class="line">Explanation: </span><br><span class="line">The grid is:</span><br><span class="line">[ [3, 0, 8, 4], </span><br><span class="line">  [2, 4, 5, 7],</span><br><span class="line">  [9, 2, 6, 3],</span><br><span class="line">  [0, 3, 1, 0] ]</span><br><span class="line"></span><br><span class="line">The skyline viewed from top or bottom is: [9, 4, 8, 7]</span><br><span class="line">The skyline viewed from left or right is: [8, 7, 9, 3]</span><br><span class="line"></span><br><span class="line">The grid after increasing the height of buildings without affecting skylines is:</span><br><span class="line"></span><br><span class="line">gridNew = [ [8, 4, 8, 7],</span><br><span class="line">            [7, 4, 7, 7],</span><br><span class="line">            [9, 4, 8, 7],</span><br><span class="line">            [3, 3, 3, 3] ]</span><br></pre></td></tr></table></figure></p>
<p>Notes:</p>
<ol>
<li>1 &lt; grid.length = grid[0].length &lt;= 50.</li>
<li>All heights grid[i][j] are in the range [0, 100].</li>
<li>All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism.</li>
</ol>
<p>这道题非常简单，首先找到每行每列的最大值，然后每个元素要小于对应的最大值中的小者，比如grid[0][0]要小于topmax[0]和leftmax[0]之中的最小值，grid[0][1]要小于topmax[0]和leftmax[1]之中的最小值。为什么花了这么长时间呢，是因为傻逼了，max数组设成了4爆了。。。煞笔。。。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxIncreaseKeepingSkyline</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span>* topmax,*leftmax;</span><br><span class="line">        topmax = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*length);</span><br><span class="line">        leftmax = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*length);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i ++)</span><br><span class="line">            topmax[i] = leftmax[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] &gt; topmax[i])</span><br><span class="line">                    topmax[i] = grid[i][j];</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] &gt; leftmax[j])</span><br><span class="line">                    leftmax[j] = grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; length; j ++)</span><br><span class="line">                result += ((leftmax[j] &gt; topmax[i] ? topmax[i] : leftmax[j]) - grid[i][j]);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode808-Soup-Servings"><a href="#Leetcode808-Soup-Servings" class="headerlink" title="Leetcode808. Soup Servings"></a>Leetcode808. Soup Servings</h1><p>There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:</p>
<ul>
<li>Serve 100 ml of soup A and 0 ml of soup B</li>
<li>Serve 75 ml of soup A and 25 ml of soup B</li>
<li>Serve 50 ml of soup A and 50 ml of soup B</li>
<li>Serve 25 ml of soup A and 75 ml of soup B</li>
</ul>
<p>When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup.</p>
<p>Note that we do not have the operation where all 100 ml’s of soup B are used first.  </p>
<p>Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 50</span><br><span class="line">Output: 0.625</span><br><span class="line">Explanation: </span><br><span class="line">If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.</span><br></pre></td></tr></table></figure></p>
<p>Notes:</p>
<ul>
<li>0 &lt;= N &lt;= 10^9. </li>
<li>Answers within 10^-6 of the true value will be accepted as correct.</li>
</ul>
<p>自己当初写的代码的思路是对的，但是细节实现上没考虑周全。这里还是参考了网上代码的总结：</p>
<p>我们在这里采用的方法严格来讲是DFS + memorization，也就是需要计算一个子问题的时候，我们首先在表格中查找，看看原来有没有被计算过，如果被计算过，则直接返回结果，否则就再重新计算，并将结果保存在表格中。这样的好处是没必要计算每个子问题，只计算递归过程中用到的子问题。如果我们定义f(a, b)表示有a毫升的A和b毫升的B时符合条件的概率，那么容易知道递推公式就是：<code>f(a, b) = 0.25 * (f(a - 4, b) + f(a - 3, b - 1) + f(a - 2, b - 2) + f(a - 1, b - 3))</code>，其中平凡条件是：</p>
<p>当a &lt; 0 &amp;&amp; b &lt; 0时，f(a, b) = 0.5，表示A和B同时用完；</p>
<p>当a &lt;= 0 &amp;&amp; b &gt; 0时，f(a, b) = 1.0，表示A先用完；</p>
<p>当a &gt; 0 &amp;&amp; b&lt;= 0时，f(a, b) = 0.0，表示B先用完。</p>
<p>所以当遇到这三种情况的时候，我们直接返回对应的平凡值；否则就首先查表，看看原来有没有计算过，如果已经计算过了，就直接返回；否则才开始按照递推公式计算。</p>
<p>1）如果A或者B不足25ml，但是又大于0ml，那么我们需要把它当做完整的25ml来对待。另外，由于A和B serve的最小单位是25ml，所以我们在f(a, b)中约定a和b是25ml的倍数，具体在实现中，我们需要首先对n做<code>n = ceil(N / 25.0)</code>的处理。</p>
<p>2）题目中给出N的范围是[0, 10^9]，这是一个特别大的数字了。另外又提到当我们返回的结果与真实误差小于10^6的时候，就算正确。直觉告诉我们，当N趋向于无穷大时，A先被serve完以及A和B同时被serve完的概率会无限接近于1。经过严格计算我们知道当N &gt;= 4800之后，返回的概率值与1的差距就小于10^6了。所以当N &gt;= 4800的时候，我们就直接返回1。如果不这样做的话，就会导致memo需要开辟的内容特别大，引起MLE。</p>
<p>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">soupServings</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">ceil</span>(N / <span class="number">25.0</span>);</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">4800</span> ?  <span class="number">1.0</span> : <span class="built_in">f</span>(n, n);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= <span class="number">0</span> &amp;&amp; b &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[a][b] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[a][b];</span><br><span class="line">        &#125;</span><br><span class="line">        memo[a][b] = <span class="number">0.25</span> * (<span class="built_in">f</span>(a - <span class="number">4</span>, b) + <span class="built_in">f</span>(a - <span class="number">3</span>, b - <span class="number">1</span>) + <span class="built_in">f</span>(a - <span class="number">2</span>, b - <span class="number">2</span>) + <span class="built_in">f</span>(a - <span class="number">1</span>, b - <span class="number">3</span>));</span><br><span class="line">        <span class="keyword">return</span> memo[a][b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> memo[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode809-Expressive-Words"><a href="#Leetcode809-Expressive-Words" class="headerlink" title="Leetcode809. Expressive Words"></a>Leetcode809. Expressive Words</h1><p>Sometimes people repeat letters to represent extra feeling. For example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot; -&gt; &quot;heeellooo&quot;</span><br><span class="line">&quot;hi&quot; -&gt; &quot;hiiii&quot;</span><br></pre></td></tr></table></figure></p>
<p>In these strings like “heeellooo”, we have groups of adjacent letters that are all the same: “h”, “eee”, “ll”, “ooo”.</p>
<p>You are given a string s and an array of query strings words. A query word is stretchy if it can be made to be equal to s by any number of applications of the following extension operation: choose a group consisting of characters c, and add some number of characters c to the group so that the size of the group is three or more.</p>
<p>For example, starting with “hello”, we could do an extension on the group “o” to get “hellooo”, but we cannot get “helloo” since the group “oo” has a size less than three. Also, we could do another extension like “ll” -&gt; “lllll” to get “helllllooo”. If s = “helllllooo”, then the query word “hello” would be stretchy because of these two extension operations: query = “hello” -&gt; “hellooo” -&gt; “helllllooo” = s.<br>Return the number of query strings that are stretchy.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;heeellooo&quot;, words = [&quot;hello&quot;, &quot;hi&quot;, &quot;helo&quot;]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">We can extend &quot;e&quot; and &quot;o&quot; in the word &quot;hello&quot; to get &quot;heeellooo&quot;.</span><br><span class="line">We can&#x27;t extend &quot;helo&quot; to get &quot;heeellooo&quot; because the group &quot;ll&quot; is not size 3 or more.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;zzzzzyyyyy&quot;, words = [&quot;zzyy&quot;,&quot;zy&quot;,&quot;zyy&quot;]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>依次按顺序统计s与各个单词的字母个数，如果相同顺序（连续相等字母算顺序中的一位）的字母不相等，则不符合条件，如果s的字母个数小于3且s与单词的字母个数不等，不符合条件，如果s的字母个数大于等于3且小于单词的字母个数，不符合条件，执行到某个字符串结束，如果没都达到最后，则不符合条件，否则满足条件。Version 2只统计s一次，然后再比对。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">expressiveWords</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> legal = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (string word : words) &#123;</span><br><span class="line">            <span class="type">int</span> len2 = word.<span class="built_in">length</span>();</span><br><span class="line">            legal = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (len &lt; len2)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; len &amp;&amp; p2 &lt; len2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[p1] == word[p2]) &#123;</span><br><span class="line">                    <span class="type">int</span> t1 = <span class="number">1</span>, t2 = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (p1 &lt; len<span class="number">-1</span> &amp;&amp; s[p1] == s[p1<span class="number">+1</span>]) &#123;</span><br><span class="line">                        t1 ++; p1 ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (p2 &lt; len2<span class="number">-1</span> &amp;&amp; word[p2] == word[p2<span class="number">+1</span>]) &#123;</span><br><span class="line">                        t2 ++; p2 ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (t1 == <span class="number">2</span> &amp;&amp; t1 - t2 == <span class="number">1</span>)</span><br><span class="line">                        legal = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((t1 &lt; <span class="number">3</span> &amp;&amp; t1 != t2) || t1 &lt; t2)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p1 ++;</span><br><span class="line">                p2 ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p1 == len &amp;&amp; p2 == word.<span class="built_in">size</span>() &amp;&amp; legal)</span><br><span class="line">                res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode811-Subdomain-Visit-Count"><a href="#Leetcode811-Subdomain-Visit-Count" class="headerlink" title="Leetcode811. Subdomain Visit Count"></a>Leetcode811. Subdomain Visit Count</h1><p>A website domain like “discuss.leetcode.com” consists of various subdomains. At the top level, we have “com”, at the next level, we have “leetcode.com”, and at the lowest level, “discuss.leetcode.com”. When we visit a domain like “discuss.leetcode.com”, we will also visit the parent domains “leetcode.com” and “com” implicitly.</p>
<p>Now, call a “count-paired domain” to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be “9001 discuss.leetcode.com”.</p>
<p>We are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;9001 discuss.leetcode.com&quot;]</span><br><span class="line">Output: </span><br><span class="line">[&quot;9001 discuss.leetcode.com&quot;, &quot;9001 leetcode.com&quot;, &quot;9001 com&quot;]</span><br><span class="line">Explanation: </span><br><span class="line">We only have one website domain: &quot;discuss.leetcode.com&quot;. As discussed above, the subdomain &quot;leetcode.com&quot; and &quot;com&quot; will also be visited. So they will all be visited 9001 times.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]</span><br><span class="line">Output: </span><br><span class="line">[&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;]</span><br><span class="line">Explanation: </span><br><span class="line">We will visit &quot;google.mail.com&quot; 900 times, &quot;yahoo.com&quot; 50 times, &quot;intel.mail.com&quot; once and &quot;wiki.org&quot; 5 times. For the subdomains, we will visit &quot;mail.com&quot; 900 + 1 = 901 times, &quot;com&quot; 900 + 50 + 1 = 951 times, and &quot;org&quot; 5 times.</span><br></pre></td></tr></table></figure><br>这个题就是非常简单的统计字符串，如果用java和python做的话几分钟就出来了，但是用了原生C++，没有用高级功能，自己手写的一些函数，就当熟悉熟悉了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">subdomainVisits</span><span class="params">(vector&lt;string&gt;&amp; cpdomains)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt; m;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cpdomains.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">            string domain=cpdomains[i];</span><br><span class="line">            <span class="type">int</span> domain_len = domain.<span class="built_in">length</span>();</span><br><span class="line">            <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(domain[j]!=<span class="string">&#x27; &#x27;</span>) </span><br><span class="line">                j++;</span><br><span class="line">         </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;j;i++)</span><br><span class="line">                num = num *<span class="number">10</span> + (domain[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            vector&lt;string&gt; temp;</span><br><span class="line">            <span class="type">int</span> part_end=j<span class="number">+1</span>;</span><br><span class="line">            string tt;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=j<span class="number">+1</span>;i&lt;domain_len;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(domain[i]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line"> 	               tt = domain.<span class="built_in">substr</span>(part_end,part_end-i<span class="number">+1</span>);</span><br><span class="line">	               temp.<span class="built_in">push_back</span>(tt);</span><br><span class="line">                   part_end=i<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tt=domain.<span class="built_in">substr</span>(part_end,domain_len-part_end);</span><br><span class="line">            temp.<span class="built_in">push_back</span>(tt);</span><br><span class="line">		        </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;temp.<span class="built_in">size</span>();i++)</span><br><span class="line">                <span class="keyword">if</span>(m.<span class="built_in">find</span>(temp[i])==m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(temp[i],num));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    m[temp[i]]+=num;           </span><br><span class="line">        &#125;</span><br><span class="line">	    unordered_map&lt;string,<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(it=m.<span class="built_in">begin</span>();it!=m.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">            string ddd = <span class="built_in">to_string</span>(it-&gt;second)+<span class="string">&quot; &quot;</span>+it-&gt;first;</span><br><span class="line">            res.<span class="built_in">push_back</span>(ddd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>贴一下其他解法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">subdomainVisits</span><span class="params">(vector&lt;string&gt;&amp; cpdomains)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; domains;</span><br><span class="line">        <span class="keyword">for</span>(string s:cpdomains)&#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, s.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>)));</span><br><span class="line">            domains[s.<span class="built_in">substr</span>(s.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>) + <span class="number">1</span>)] += count;</span><br><span class="line">            domains[s.<span class="built_in">substr</span>(s.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span>)] += count;</span><br><span class="line">            <span class="comment">// try to find the second &#x27;.&#x27;</span></span><br><span class="line">            string sub = s.<span class="built_in">substr</span>(s.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(sub.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>) != <span class="number">-1</span>)&#123;</span><br><span class="line">                domains[sub.<span class="built_in">substr</span>(sub.<span class="built_in">find</span>(<span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span>)] += count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = domains.<span class="built_in">begin</span>(); it!= domains.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(it-&gt;second) + <span class="string">&quot; &quot;</span> + it-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>python版本的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subdomainVisits</span>(<span class="params">self, cpdomains</span>):</span><br><span class="line">        ans = collections.Counter()</span><br><span class="line">        <span class="keyword">for</span> domain <span class="keyword">in</span> cpdomains:</span><br><span class="line">            count, domain = domain.split()</span><br><span class="line">            count = <span class="built_in">int</span>(count)</span><br><span class="line">            frags = domain.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(frags)):</span><br><span class="line">	            ans[<span class="string">&quot;.&quot;</span>.join(frags[i:])] += count</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(ct, dom) <span class="keyword">for</span> dom, ct <span class="keyword">in</span> ans.items()]</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode812-Largest-Triangle-Area"><a href="#Leetcode812-Largest-Triangle-Area" class="headerlink" title="Leetcode812. Largest Triangle Area"></a>Leetcode812. Largest Triangle Area</h1><p>You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><br>Explanation:<br>The five points are show in the figure below. The red triangle is the largest.</p>
<p>给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。</p>
<p>示例:输入: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] 输出: 2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getLength</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> x2, <span class="type">int</span> y1, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="type">double</span>)(x1-x2)*(x1-x2)+(<span class="type">double</span>)(y1-y2)*(y1-y2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">largestTriangleArea</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">double</span> a, b, c, q;</span><br><span class="line">        <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k ++) &#123;</span><br><span class="line">                     <span class="type">double</span> area = <span class="number">0.5</span> * <span class="built_in">abs</span>(points[i][<span class="number">0</span>] * points[j][<span class="number">1</span>] + points[j][<span class="number">0</span>] * points[k][<span class="number">1</span>] + points[k][<span class="number">0</span>] * points[i][<span class="number">1</span>] -points[i][<span class="number">0</span>] * points[k][<span class="number">1</span>] - points[k][<span class="number">0</span>] * points[j][<span class="number">1</span>] - points[j][<span class="number">0</span>] * points[i][<span class="number">1</span>]);</span><br><span class="line">                    result = <span class="built_in">max</span>(result, area);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode813-Largest-Sum-of-Averages"><a href="#Leetcode813-Largest-Sum-of-Averages" class="headerlink" title="Leetcode813. Largest Sum of Averages"></a>Leetcode813. Largest Sum of Averages</h1><p>We partition a row of numbers A into at most K adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve?</p>
<p>Note that our partition must use every number in A, and that scores are not necessarily integers.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">A = [9,1,2,3,9]</span><br><span class="line">K = 3</span><br><span class="line">Output: 20</span><br><span class="line">Explanation: </span><br><span class="line">The best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.</span><br><span class="line">We could have also partitioned A into [9, 1], [2], [3, 9], for example.</span><br><span class="line">That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 100.</li>
<li>1 &lt;= A[i] &lt;= 10000.</li>
<li>1 &lt;= K &lt;= A.length.</li>
<li>Answers within 10^-6 of the correct answer will be accepted as correct. </li>
</ul>
<p>首先来考虑dp数组的定义，dp数组不把K加进去的话就不知道当前要分几组，这个Hidden Information是解题的关键。这是DP中比较难的一类，有些DP题的隐藏信息藏的更深，不挖出来就无法解题。这道题的dp数组应该是个二维数组，其中dp[i][k]表示范围是[i, n-1]的子数组分成k组的最大得分。那么这里你就会纳闷了，为啥范围是[i, n-1]而不是[0, i]，为啥要取后半段呢。由于把[i, n-1]范围内的子数组分成k组，那么suppose我们已经知道了任意范围内分成k-1组的最大分数，这是此类型题目的破题关键所在，要求状态k，一定要先求出所有的状态k-1，那么问题就转换成了从k-1组变成k组，即多分出一组，那么在范围[i, n-1]多分出一组，实际上就是将其分成两部分，一部分是一组，另一部分是k-1组，怎么分，就用一个变量j，遍历范围(i, n-1)中的每一个位置，那么分成的这两部分的分数如何计算呢？第一部分[i, j)，由于是一组，那么直接求出平均值即可，另一部分由于是k-1组，由于我们已经知道了所有k-1的情况，可以直接从cache中读出来dp[j][k-1]，二者相加即可 avg(i, j) + dp[j][k-1]，所以我们可以得出状态转移方程如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k] = max(avg(i, n) + max_&#123;j &gt; i&#125; (avg(i, j) + dp[j][k-1]))</span><br></pre></td></tr></table></figure><br>这里的avg(i, n)是其可能出现的情况，由于是至多分为k组，所以我们可以不分组，所以直接计算范围[i, n-1]内的平均值，然后用j来遍历区间(i, n-1)中的每一个位置，最终得到的dp[i][k]就即为所求。注意这里我们通过建立累加和数组sums来快速计算某个区间之和。前面提到了dp[i][k]表示的是范围[i, n-1]的子数组分成k组的最大得分，现在想想貌似定义为[0, i]范围内的子数组分成k组的最大得分应该也是可以的，那么此时j就是遍历(0, i)中的每个位置了，好像也没什么不妥的地方，有兴趣的童鞋可以尝试的写一下～</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">largestSumOfAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">sums</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(K));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>] = sums[i] + A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = (sums[n] - sums[i]) / (n - i);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; K; ++k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                    dp[i][k] = <span class="built_in">max</span>(dp[i][k], (sums[j] - sums[i]) / (j - i) + dp[j][k - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][K - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以对空间进行优化，由于每次的状态k，只跟前一个状态k-1有关，所以我们不需要将所有的状态都保存起来，只需要保存前一个状态的值就行了，那么我们就用一个一维数组就可以了，不断的进行覆盖，从而达到了节省空间的目的，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">largestSumOfAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">sums</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>] = sums[i] + A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = (sums[n] - sums[i]) / (n - i);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; K; ++k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], (sums[j] - sums[i]) / (j - i) + dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以是用递归加记忆数组的方式来实现，记忆数组的运作原理和DP十分类似，也是一种cache，将已经计算过的结果保存起来，用的时候直接取即可，避免了大量的重复计算，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">largestSumOfAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">memo</span>(<span class="number">101</span>, <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(<span class="number">101</span>));</span><br><span class="line">        <span class="type">double</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            cur += A[i];</span><br><span class="line">            memo[i + <span class="number">1</span>][<span class="number">1</span>] = cur / (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(A, K, n, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> k, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[j][k] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[j][k];</span><br><span class="line">        <span class="type">double</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = j - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            cur += A[i];</span><br><span class="line">            memo[j][k] = <span class="built_in">max</span>(memo[j][k], <span class="built_in">helper</span>(A, k - <span class="number">1</span>, i, memo) + cur / (j - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[j][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode814-Binary-Tree-Pruning"><a href="#Leetcode814-Binary-Tree-Pruning" class="headerlink" title="Leetcode814. Binary Tree Pruning"></a>Leetcode814. Binary Tree Pruning</h1><p>We are given the head node root of a binary tree, where additionally every node’s value is either a 0 or a 1.</p>
<p>Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.</p>
<p>(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,null,0,0,1]</span><br><span class="line">Output: [1,null,0,null,1]</span><br></pre></td></tr></table></figure><br>Explanation:<br>Only the red nodes satisfy the property “every subtree not containing a 1”.<br>The diagram on the right represents the answer.<br><img src="/img/1028_2.png" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,1,0,0,0,1]</span><br><span class="line">Output: [1,null,1,null,1]</span><br></pre></td></tr></table></figure><br><img src="/img/1028_1.png" alt=""></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,0,1,1,0,1,0]</span><br><span class="line">Output: [1,1,0,1,1,null,1]</span><br></pre></td></tr></table></figure><br><img src="/img/1028.png" alt=""></p>
<p>删掉子树里没有1的，返回这棵树。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dele</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> a1 = <span class="built_in">dele</span>(root-&gt;left);</span><br><span class="line">        <span class="type">bool</span> a2 = <span class="built_in">dele</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(!a1) root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!a2) root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val==<span class="number">1</span> || a1 || a2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">pruneTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dele</span>(root)?root:<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode816-Ambiguous-Coordinates"><a href="#Leetcode816-Ambiguous-Coordinates" class="headerlink" title="Leetcode816. Ambiguous Coordinates"></a>Leetcode816. Ambiguous Coordinates</h1><p>We had some 2-dimensional coordinates, like “(1, 3)” or “(2, 0.5)”.  Then, we removed all commas, decimal points, and spaces, and ended up with the string S.  Return a list of strings representing all possibilities for what our original coordinates could have been.</p>
<p>Our original representation never had extraneous zeroes, so we never started with numbers like “00”, “0.0”, “0.00”, “1.0”, “001”, “00.01”, or any other number that can be represented with less digits.  Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like “.1”.</p>
<p>The final answer list can be returned in any order.  Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.)</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(123)&quot;</span><br><span class="line">Output: [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(00011)&quot;</span><br><span class="line">Output:  [&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;]</span><br><span class="line">Explanation: </span><br><span class="line">0.0, 00, 0001 or 00.01 are not allowed.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(0123)&quot;</span><br><span class="line">Output: [&quot;(0, 123)&quot;, &quot;(0, 12.3)&quot;, &quot;(0, 1.23)&quot;, &quot;(0.1, 23)&quot;, &quot;(0.1, 2.3)&quot;, &quot;(0.12, 3)&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(100)&quot;</span><br><span class="line">Output: [(10, 0)]</span><br><span class="line">Explanation: </span><br><span class="line">1.0 is not allowed.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>4 &lt;= S.length &lt;= 12.</li>
<li>S[0] = “(“, S[S.length - 1] = “)”, and the other elements in S are digits.</li>
</ul>
<p>这道题给了我们一个模糊坐标，括号里面很只有一个数字字符串，没有逗号也没有小数点，让我们自己添加逗号和小数点，让把所有可能的组合都返回。题目中给了很多例子，理解起题意来很容易。这道题的难点是如何合理的拆分，很多拆分是不合法的，题目举了很多不合法的例子，比如 “00”, “0.0”, “0.00”, “1.0”, “001”, “00.01”。那么我们需要归纳出所有不合法的corner case，然后剩下一般情况比如123，我们就按位加小数点即可。那么我们再来看一下那些非法的例子，我们发现一眼望去好多0，不错，0就是trouble maker，首先不能有0开头的长度大于1的整数，比如00， 001。其次，不能有0结尾的小数，比如0.0，0.00，1.0等。还有，小数的整数位上也不能有0开头的长度大于1的整数。那么我们来归纳一下吧，首先如果字符串为空，那么直接返回空集合。然后如果字符串长度大于1，且首尾字符都是0的话，那么不可分，比如 0xxx0，因为整数长度大于1的话不能以0开头，中间也没法加小数点，因为小数最后一位不能是0。如果长度大于1，第一位是0，但最后一位不是0，那我们可以在第一个0后面加个小数点返回，这时就必须要加小数点了，因为长度大于1的整数不能以0开头。再之后，如果最后一位是0，说明不能加小数点，直接把当前值返回即可。最后就是一般情况了，我们先把原数加入结果res，然后遍历中间的每个位置，都加个小数点，所有情况归纳如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if S == “”: return []</span><br><span class="line">if S == “0”: return [S]</span><br><span class="line">if S == “0XXX0”: return []</span><br><span class="line">if S == “0XXX”: return [“0.XXX”]</span><br><span class="line">if S == “XXX0”: return [S]</span><br><span class="line">return [S, “X.XXX”, “XX.XX”, “XXX.X”…]</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">ambiguousCoordinates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="type">int</span> n = S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            vector&lt;string&gt; A = <span class="built_in">findAll</span>(S.<span class="built_in">substr</span>(<span class="number">1</span>, i)), B = <span class="built_in">findAll</span>(S.<span class="built_in">substr</span>(i + <span class="number">1</span>, n - <span class="number">2</span> - i));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : A) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;b : B) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="string">&quot;(&quot;</span> + a + <span class="string">&quot;, &quot;</span> + b + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findAll</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || (n &gt; <span class="number">1</span> &amp;&amp; S[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; S[n - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">1</span> &amp;&amp; S[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> &#123;<span class="string">&quot;0.&quot;</span> + S.<span class="built_in">substr</span>(<span class="number">1</span>)&#125;;</span><br><span class="line">        <span class="keyword">if</span> (S[n - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> &#123;S&#125;;</span><br><span class="line">        vector&lt;string&gt; res&#123;S&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) res.<span class="built_in">push_back</span>(S.<span class="built_in">substr</span>(<span class="number">0</span>, i) + <span class="string">&quot;.&quot;</span> + S.<span class="built_in">substr</span>(i));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode817-Linked-List-Components"><a href="#Leetcode817-Linked-List-Components" class="headerlink" title="Leetcode817. Linked List Components"></a>Leetcode817. Linked List Components</h1><p>We are given head, the head node of a linked list containing unique integer values.</p>
<p>We are also given the list G, a subset of the values in the linked list.</p>
<p>Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">head: 0-&gt;1-&gt;2-&gt;3</span><br><span class="line">G = [0, 1, 3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">0 and 1 are connected, so [0, 1] and [3] are the two connected components.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">head: 0-&gt;1-&gt;2-&gt;3-&gt;4</span><br><span class="line">G = [0, 3, 1, 4]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>If N is the length of the linked list given by head, 1 &lt;= N &lt;= 10000.</li>
<li>The value of each node in the linked list will be in the range [0, N - 1].</li>
<li>1 &lt;= G.length &lt;= 10000.</li>
<li>G is a subset of all values in the linked list.</li>
</ul>
<p>这道题给了我们一个链表，又给了我们一个结点值数组，里面不一定包括了链表中所有的结点值。让我们返回结点值数组中有多少个相连的组件，因为缺失的结点值会将原链表断开，实际上就是让我们求有多少个相连的子链表，题目中给的例子很好的说明题意。这道题并不需要什么特别高深的技巧，难懂的算法，直接按题目的要求来找就可以了。首先，为了快速的在结点值数组中查找某个结点值是否存在，我们可以将所有的结点值放到一个HashSet中，这样我们就能在常数级的时间复杂度中查找。然后我们就可以来遍历链表了，对于遍历到的每个结点值，我们只有两种情况，在或者不在HashSet中。不在HashSet中的情况比较好办，说明此时断开了，而在HashSet中的结点，有可能是该连续子链表的起始点，或者是中间的某个点，而我们的计数器对该子链表只能自增1，所以我们需要想办法来hanlde这种情况。博主最先想到的办法是先处理不在HashSet中的结点，处理方法就是直接跳到下一个结点。那么对于在HashSet中的结点，我们首先将计数器res自增1，然后再来个循环，将之后所有在集合中的结点都遍历完，这样才不会对同一个子链表多次增加计数器，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numComponents</span><span class="params">(ListNode* head, vector&lt;<span class="type">int</span>&gt;&amp; G)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nodeSet</span><span class="params">(G.begin(), G.end())</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!nodeSet.<span class="built_in">count</span>(head-&gt;val)) &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">while</span> (head &amp;&amp; nodeSet.<span class="built_in">count</span>(head-&gt;val)) &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode819-Most-Common-Word"><a href="#Leetcode819-Most-Common-Word" class="headerlink" title="Leetcode819. Most Common Word"></a>Leetcode819. Most Common Word</h1><p>Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn’t banned, and that the answer is unique.</p>
<p>Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;</span><br><span class="line">banned = [&quot;hit&quot;]</span><br><span class="line">Output: &quot;ball&quot;</span><br></pre></td></tr></table></figure><br>Explanation:<br>“hit” occurs 3 times, but it is a banned word.<br>“ball” occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.<br>Note that words in the paragraph are not case sensitive,<br>that punctuation is ignored (even if adjacent to words, such as “ball,”),<br>and that “hit” isn’t the answer even though it occurs more because it is banned.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">mostCommonWord</span><span class="params">(string paragraph, vector&lt;string&gt;&amp; banned)</span> </span>&#123;</span><br><span class="line">        map&lt;string, <span class="type">int</span>&gt; mapp;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="type">int</span> length = paragraph.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i ++)</span><br><span class="line">            <span class="keyword">if</span>(paragraph[i]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; paragraph[i]&lt;=<span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">                paragraph[i] -= (<span class="string">&#x27;A&#x27;</span>-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length;i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(paragraph[i]==<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;length &amp;&amp; paragraph[i]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; paragraph[i]&lt;=<span class="string">&#x27;z&#x27;</span>) </span><br><span class="line">                temp += paragraph[i++];</span><br><span class="line">            <span class="keyword">if</span> (mapp.<span class="built_in">find</span>(temp) == mapp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                mapp[temp] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mapp[temp] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">        string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(map&lt;string, <span class="type">int</span>&gt;::iterator iter = mapp.<span class="built_in">begin</span>(); iter != mapp.<span class="built_in">end</span>(); iter ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;second &gt; maxx &amp;&amp; <span class="built_in">find</span>(banned.<span class="built_in">begin</span>(), banned.<span class="built_in">end</span>(), iter-&gt;first) == banned.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result = iter-&gt;first;</span><br><span class="line">                maxx = iter-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">mostCommonWord</span><span class="params">(string p, vector&lt;string&gt;&amp; banned)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">ban</span><span class="params">(banned.begin(), banned.end())</span></span>;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; c: p) c = <span class="built_in">isalpha</span>(c) ? <span class="built_in">tolower</span>(c) : <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="function">istringstream <span class="title">iss</span><span class="params">(p)</span></span>;</span><br><span class="line">        string w;</span><br><span class="line">        <span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">res</span> <span class="params">(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (iss &gt;&gt; w)</span><br><span class="line">            <span class="keyword">if</span> (ban.<span class="built_in">find</span>(w) == ban.<span class="built_in">end</span>() &amp;&amp; ++count[w] &gt; res.second)</span><br><span class="line">                res = <span class="built_in">make_pair</span>(w, count[w]);</span><br><span class="line">        <span class="keyword">return</span> res.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">mostCommonWord</span><span class="params">(string paragraph, vector&lt;string&gt;&amp; banned)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; paragraph.<span class="built_in">size</span>();)&#123;</span><br><span class="line">            string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; paragraph.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isalpha</span>(paragraph[i])) s.<span class="built_in">push_back</span>(<span class="built_in">tolower</span>(paragraph[i++]));</span><br><span class="line">            <span class="keyword">while</span>(i &lt; paragraph.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isalpha</span>(paragraph[i])) i++;</span><br><span class="line">            m[s]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: banned) m[x] = <span class="number">0</span>;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: m)</span><br><span class="line">            <span class="keyword">if</span>(x.second &gt; count) res = x.first, count = x.second;</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode820-Short-Encoding-of-Words"><a href="#Leetcode820-Short-Encoding-of-Words" class="headerlink" title="Leetcode820. Short Encoding of Words"></a>Leetcode820. Short Encoding of Words</h1><p>A valid encoding of an array of words is any reference string s and array of indices indices such that:</p>
<ul>
<li>words.length == indices.length</li>
<li>The reference string s ends with the ‘#’ character.</li>
<li>For each index indices[i], the substring of s starting from indices[i] and up to (but not including) the next ‘#’ character is equal to words[i].</li>
</ul>
<p>Given an array of words, return the length of the shortest reference string s possible of any valid encoding of words.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: A valid encoding would be s = &quot;time#bell#&quot; and indices = [0, 2, 5].</span><br><span class="line">words[0] = &quot;time&quot;, the substring of s starting from indices[0] = 0 to the next &#x27;#&#x27; is underlined in &quot;time#bell#&quot;</span><br><span class="line">words[1] = &quot;me&quot;, the substring of s starting from indices[1] = 2 to the next &#x27;#&#x27; is underlined in &quot;time#bell#&quot;</span><br><span class="line">words[2] = &quot;bell&quot;, the substring of s starting from indices[2] = 5 to the next &#x27;#&#x27; is underlined in &quot;time#bell#&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;t&quot;]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: A valid encoding would be s = &quot;t#&quot; and indices = [0].</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个单词数组，让我们对其编码，不同的单词之间加入#号，每个单词的起点放在一个坐标数组内，终点就是#号，能合并的单词要进行合并，问输入字符串的最短长度。题意不难理解，难点在于如何合并单词，我们观察题目的那个例子，me和time是能够合并的，只要标清楚其实位置，time的起始位置是0，me的起始位置是2，那么根据#号位置的不同就可以顺利的取出me和time。需要注意的是，如果me换成im，或者tim的话，就不能合并了，因为我们是要从起始位置到#号之前所有的字符都要取出来。搞清楚了这一点之后，我们在接着观察，由于me是包含在time中的，所以我们处理的顺序应该是先有time#，然后再看能否包含me，而不是先生成了me#之后再处理time，所以我们可以得出结论，应该先处理长单词，那么就给单词数组按长度排序一下就行，自己重写一个comparator就行。然后我们遍历数组，对于每个单词，我们都在编码字符串查找一下，如果没有的话，直接加上这个单词，再加一个#号，如果有的话，就可以得到出现的位置。比如在time#中查找me，得到found=2，然后我们要验证该单词后面是否紧跟着一个#号，所以我们直接访问<code>found+word.size()</code>这个位置，如果不是#号，说明不能合并，我们还是要加上这个单词和#号。最后返回编码字符串的长度即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](string &amp;a, string &amp;b)&#123; <span class="keyword">return</span> a.<span class="built_in">length</span>() &gt; b.<span class="built_in">length</span>();&#125;);</span><br><span class="line">        <span class="keyword">for</span> (string word : words) &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="number">0</span>, <span class="type">prev_t</span> = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>((t=res.<span class="built_in">find</span>(word, t))!=string::npos) &#123;</span><br><span class="line">                <span class="type">prev_t</span> = t;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="type">prev_t</span> == <span class="number">-1</span> || res[<span class="type">prev_t</span> + word.<span class="built_in">length</span>()] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                res += (word + <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">length</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode821-Shortest-Distance-to-a-Character"><a href="#Leetcode821-Shortest-Distance-to-a-Character" class="headerlink" title="Leetcode821. Shortest Distance to a Character"></a>Leetcode821. Shortest Distance to a Character</h1><p>Given a string S and a character C, return an array of integers representing the shortest distance from the character C in the string.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;loveleetcode&quot;, C = &#x27;e&#x27;</span><br><span class="line">Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]</span><br></pre></td></tr></table></figure><br>简单题，这里是对于每个是字符C的位置，然后分别像左右两边扩散，不停是更新距离，这样当所有的字符C的点都扩散完成之后，每个非字符C位置上的数字就是到字符C的最短距离了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shortestToChar</span><span class="params">(string S, <span class="type">char</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = S.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> signal[len];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(len,INT_MAX)</span></span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] == C)&#123;</span><br><span class="line">                res[i]=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;len;j++)</span><br><span class="line">                res[j]=<span class="built_in">min</span>(res[j],j-i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">                res[j]=<span class="built_in">min</span>(res[j],i-j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面这种方法也是建立距离场的思路，不过更加巧妙一些，只需要正反两次遍历就行。首先进行正向遍历，若当前位置是字符C，那么直接赋0，否则看如果不是首位置，那么当前位置的值等于前一个位置的值加1。这里不用和当前的值进行比较，因为这个算出来的值不会大于初始化的值。然后再进行反向遍历，要从倒数第二个值开始往前遍历，用后一个值加1来更新当前位置的值，此时就要和当前值做比较，取较小的那个，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shortestToChar</span><span class="params">(string S, <span class="type">char</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(S.size(), S.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == C) res[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span>) res[i] = res[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="type">int</span>)S.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            res[i] = <span class="built_in">min</span>(res[i], res[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode822-Card-Flipping-Game"><a href="#Leetcode822-Card-Flipping-Game" class="headerlink" title="Leetcode822. Card Flipping Game"></a>Leetcode822. Card Flipping Game</h1><p>On a table are N cards, with a positive integer printed on the front and back of each card (possibly different).</p>
<p>We flip any number of cards, and after we choose one card. </p>
<p>If the number X on the back of the chosen card is not on the front of any card, then this number X is good.</p>
<p>What is the smallest number that is good?  If no number is good, output 0.</p>
<p>Here, fronts[i] and backs[i] represent the number on the front and back of card i. </p>
<p>A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa.</p>
<p>Example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3].</span><br><span class="line">We choose the second card, which has number 2 on the back, and it isn&#x27;t on the front of any card, so 2 is good.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= fronts.length == backs.length &lt;= 1000.</li>
<li>1 &lt;= fronts[i] &lt;= 2000.</li>
<li>1 &lt;= backs[i] &lt;= 2000.</li>
</ul>
<p>给了一些正反都有正数的卡片，可以翻面，让我们找到一个最小的数字，在卡的背面，且要求其他卡正面上均没有这个数字。简而言之，就是要在backs数组找一个最小数字，使其不在fronts数组中。我们想，既然不能在fronts数组中，说明卡片背面的数字肯定跟其正面的数字不相同，否则翻来翻去都是相同的数字，肯定会在fronts数组中。那么我们可以先把正反数字相同的卡片都找出来，将数字放入一个HashSet，也方便我们后面的快速查找。现在其实我们只需要在其他的数字中找到一个最小值即可，因为正反数字不同，就算fronts中其他卡片的正面还有这个最小值，我们可以将那张卡片翻面，使得相同的数字到backs数组，总能使得fronts数组不包含有这个最小值，就像题目中给的例子一样，数字2在第二张卡的背面，就算其他卡面也有数字2，只要其不是正反都是2，我们都可以将2翻到背面去，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">flipgame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fronts, vector&lt;<span class="type">int</span>&gt;&amp; backs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = INT_MAX, n = fronts.<span class="built_in">size</span>();</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; same;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fronts[i] == backs[i]) same.<span class="built_in">insert</span>(fronts[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> front : fronts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!same.<span class="built_in">count</span>(front)) res = <span class="built_in">min</span>(res, front);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> back : backs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!same.<span class="built_in">count</span>(back)) res = <span class="built_in">min</span>(res, back);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (res == INT_MAX) ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode823-Binary-Trees-With-Factors"><a href="#Leetcode823-Binary-Trees-With-Factors" class="headerlink" title="Leetcode823. Binary Trees With Factors"></a>Leetcode823. Binary Trees With Factors</h1><p>Given an array of unique integers, each integer is strictly greater than 1.</p>
<p>We make a binary tree using these integers and each number may be used for any number of times.</p>
<p>Each non-leaf node’s value should be equal to the product of the values of it’s children.</p>
<p>How many binary trees can we make?  Return the answer modulo 10 ** 9 + 7.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2, 4]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can make these trees: [2], [4], [4, 2, 2]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2, 4, 5, 10]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 1000.</li>
<li>2 &lt;= A[i] &lt;= 10 ^ 9.</li>
</ul>
<p>两个难点，定义dp表达式跟推导状态转移方程。怎么简单怎么来呗，我们用一个一维dp数组，其中dp[i]表示值为i的结点做根结点时，能够形成的符合题意的二叉树的个数。这样我们将数组A中每个结点的dp值都累加起来就是最终的结果了。好了，有了定义式，接下来就是最大的难点了，推导状态转移方程。题目中的要求是根结点的值必须是左右子结点值的乘积，那么根结点的dp值一定是跟左右子结点的dp值有关的，是要加上左右子结点的dp值的乘积的，为啥是乘呢，比如有两个球，一个有2种颜色，另一个有3种颜色，问两个球放一起总共能有多少种不同的颜色组合，当然是相乘啦。每个结点的dp值初始化为1，因为就算是当个光杆司令的叶结点，也是符合题意的，所以至少是1。然后就要找其左右两个子结点了，怎么找，有点像 Two Sum 的感觉，先确定一个，然后在HashMap中快速定位另一个，想到了这一层的话，我们的dp定义式就需要做个小修改，之前说的是用一个一维dp数组，现在看来就不太合适了，因为我们需要快速查找某个值，所以这里我们用一个HashMap来定义dp。好，继续，既然要先确定一个结点，由于都是大于1的正数，那么这个结点肯定要比根结点值小，为了遍历方便，我们想把小的放前面，那么我们就需要给数组A排个序，这样就可以遍历之前较小的数字了，那么如何快速定位另一个子结点呢，我们只要用根结点值对遍历值取余，若为0，说明可以整除，然后再在HashMap中查找这个商是否存在，在的话，说明存在这样的两个结点，其结点值之积等于结点A[i]，然后我们将这两个结点值之积加到dp[A[i]]中即可，注意还要对超大数取余，防止溢出。最后当所有结点的dp值都更新完成了，将其和算出来返回即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numFactoredBinaryTrees</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> res = <span class="number">0</span>, M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">long</span>&gt; dp;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[A[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] % A[j] == <span class="number">0</span> &amp;&amp; dp.<span class="built_in">count</span>(A[i] / A[j])) &#123;</span><br><span class="line">                    dp[A[i]] = (dp[A[i]] + dp[A[j]] * dp[A[i] / A[j]]) % M;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : dp) res = (res + a.second) % M;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode824-Goat-Latin"><a href="#Leetcode824-Goat-Latin" class="headerlink" title="Leetcode824. Goat Latin"></a>Leetcode824. Goat Latin</h1><p>A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.</p>
<p>We would like to convert the sentence to “Goat Latin” (a made-up language similar to Pig Latin.)</p>
<p>The rules of Goat Latin are as follows:</p>
<ul>
<li>If a word begins with a vowel (a, e, i, o, or u), append “ma” to the end of the word.<br>For example, the word ‘apple’ becomes ‘applema’.</li>
<li>If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add “ma”.<br>For example, the word “goat” becomes “oatgma”.</li>
<li>Add one letter ‘a’ to the end of each word per its word index in the sentence, starting with 1.<br>For example, the first word gets “a” added to the end, the second word gets “aa” added to the end and so on.<br>Return the final sentence representing the conversion from S to Goat Latin. </li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;I speak Goat Latin&quot;</span><br><span class="line">Output: &quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot;</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;The quick brown fox jumped over the lazy dog&quot;</span><br><span class="line">Output: &quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot;</span><br></pre></td></tr></table></figure></p>
<p>Notes:</p>
<ol>
<li>S contains only uppercase, lowercase and spaces. Exactly one space between each word.</li>
<li>1 &lt;= S.length &lt;= 150.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isvowel</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;A&#x27;</span> || c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;I&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;O&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">toGoatLatin</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; words;</span><br><span class="line">        string result, temp;</span><br><span class="line">        <span class="type">int</span> length = S.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(S[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; i &lt; length) &#123;</span><br><span class="line">                temp += S[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            words.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isvowel</span>(words[i][<span class="number">0</span>]))</span><br><span class="line">                result = result + words[i] + <span class="string">&quot;ma&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result = result + words[i].<span class="built_in">substr</span>(<span class="number">1</span>) + words[i][<span class="number">0</span>] + <span class="string">&quot;ma&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j ++)</span><br><span class="line">                result += <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            result += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.<span class="built_in">substr</span>(<span class="number">0</span>, result.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">toGoatLatin</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(S)</span></span>;</span><br><span class="line">        string word;</span><br><span class="line">        string res;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; vowels&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; word) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!vowels.<span class="built_in">count</span>(word[<span class="number">0</span>])) &#123;</span><br><span class="line">                std::<span class="built_in">reverse</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>());</span><br><span class="line">                std::<span class="built_in">reverse</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res += word + <span class="string">&quot;ma&quot;</span> + <span class="built_in">string</span>(count, <span class="string">&#x27;a&#x27;</span>) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> space_pos = res.<span class="built_in">find_last_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        res = res.<span class="built_in">substr</span>(<span class="number">0</span>, space_pos);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode825-Friends-Of-Appropriate-Ages"><a href="#Leetcode825-Friends-Of-Appropriate-Ages" class="headerlink" title="Leetcode825. Friends Of Appropriate Ages"></a>Leetcode825. Friends Of Appropriate Ages</h1><p>Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person. </p>
<p>Person A will NOT friend request person B (B != A) if any of the following conditions are true:</p>
<ul>
<li><code>age[B] &lt;= 0.5 * age[A] + 7</code></li>
<li><code>age[B] &gt; age[A]</code></li>
<li><code>age[B] &gt; 100 &amp;&amp; age[A] &lt; 100</code></li>
</ul>
<p>Otherwise, A will friend request B.</p>
<p>Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves.</p>
<p>How many total friend requests are made?</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [16,16]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 2 people friend request each other.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [16,17,18]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Friend requests are made 17 -&gt; 16, 18 -&gt; 17.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [20,30,100,110,120]</span><br><span class="line">Output: </span><br><span class="line">Explanation: Friend requests are made 110 -&gt; 100, 120 -&gt; 110, 120 -&gt; 100.</span><br></pre></td></tr></table></figure></p>
<p>Notes:</p>
<ul>
<li>1 &lt;= ages.length &lt;= 20000.</li>
<li>1 &lt;= ages[i] &lt;= 120.</li>
</ul>
<p>这道题是关于好友申请的，说是若A想要加B的好友，下面三个条件一个都不能满足才行：</p>
<ol>
<li>B的年龄小于等于A的年龄的一半加7。</li>
<li>B的年龄大于A的年龄。</li>
<li>B大于100岁，且A小于100岁。</li>
</ol>
<p>实际上如果你仔细看条件3，B要是大于100岁，A小于100岁，那么B一定大于A，这就跟条件2重复了。那么由于只能给比自己小的人发送好友请求，那么博主就想到我们可以献给所有人拍个序，然后从后往前遍历，对于每个遍历到的人，再遍历所有比他小的人，这样第二个条件就满足了，前面说了，第三个条件可以不用管了，那么只要看满足第一个条件就可以了，还有要注意的，假如两个人年龄相同，那么满足了前两个条件后，其实是可以互粉的，所以要额外的加1，这样才不会漏掉任何一个好友申请，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numFriendRequests</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ages)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = ages.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(ages.<span class="built_in">begin</span>(), ages.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ages[j] &lt;= <span class="number">0.5</span> * ages[i] + <span class="number">7</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (ages[i] == ages[j]) ++res;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个方法会超时。</p>
<p>我们可以来优化一下上面的解法，根据上面的分析，其实题目给的这三个条件可以归纳成一个条件，若A想加B的好友，那么B的年龄必须在 <code>(A*0.5+7, A]</code> 这个范围内，由于区间要有意义的话，A0.5+7 &lt; A 必须成立，解出 A &gt; 14，那么A最小就只能取15了。意思说你不能加小于15岁的好友（青少年成长保护？？？）。我们的优化思路是对于每一个年龄，我们都只要求出上面那个区间范围内的个数，就是符合题意的。那么既然是求区域和，建立累加数组就是一个很好的选择了，首先我们先建立一个统计数组numInAge，范围是[0, 120]，用来统计在各个年龄点上有多少人，然后再建立累加和数组sumInAge。这个都建立好了以后，我们就可以开始遍历，由于之前说了不能加小于15的好友，所以我们从15开始遍历，如果某个年龄点没有人，直接跳过。然后就是统计出 <code>(A*0.5+7, A]</code> 这个范围内有多少人，可以通过累计和数组来快速求的，由于当前时间点的人可以跟这个区间内的所有发好友申请，而当前时间点可能还有多人，所以二者相乘，但由于我们但区间里还包括但当前年龄点本身，所以还要减去当前年龄点上的人数，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numFriendRequests</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ages)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numInAge</span><span class="params">(<span class="number">121</span>)</span>, <span class="title">sumInAge</span><span class="params">(<span class="number">121</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> age : ages) ++numInAge[age];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">120</span>; ++i) &#123;</span><br><span class="line">            sumInAge[i] = numInAge[i] + sumInAge[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">15</span>; i &lt;= <span class="number">120</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numInAge[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> cnt = sumInAge[i] - sumInAge[i * <span class="number">0.5</span> + <span class="number">7</span>];</span><br><span class="line">            res += cnt * numInAge[i] - numInAge[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode826-Most-Profit-Assigning-Work"><a href="#Leetcode826-Most-Profit-Assigning-Work" class="headerlink" title="Leetcode826. Most Profit Assigning Work"></a>Leetcode826. Most Profit Assigning Work</h1><p>You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:</p>
<p><code>difficulty[i]</code>and <code>profit[i]</code> are the difficulty and the profit of the ith job, and <code>worker[j]</code> is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most <code>worker[j]</code>).</p>
<p>Every worker can be assigned at most one job, but one job can be completed multiple times.</p>
<p>For example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0. Return the maximum profit we can achieve after assigning the workers to the jobs.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]</span><br><span class="line">Output: 100</span><br><span class="line">Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>贪心的策略是给每个工人计算在他的能力范围内，他能获得的最大收益，把这样的工作分配给他。</p>
<p>做的方法是先把困难程度和收益压缩排序，然后对工人排序，再对每个工人，通过从左到右的遍历确定其能获得收益最大值。由于工作和工人都已经排好序了，每次只需要从上次停止的位置继续即可，因此各自只需要遍历一次。</p>
<p>你可能会想到，每个工作的收益和其困难程度可能不是正相关的，可能存在某个工作难度小，但是收益反而很大，这种怎么处理呢？其实这也就是这个算法妙的地方，curMax并不是在每个工人查找其满足条件的工作时初始化的，而是在一开始就初始化了，这样一直保持的是所有的工作难度小于工人能力的工作中，能获得的收益最大值。</p>
<p>也就是说在查找满足条件的工作的时候，curMax有可能不更新，其保存的是目前为止的最大。res加的也就是在满足工人能力情况下的最大收益了。</p>
<p>时间复杂度是O(M+N)，空间复杂度是O(MN)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfitAssignment</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; difficulty, vector&lt;<span class="type">int</span>&gt;&amp; profit, vector&lt;<span class="type">int</span>&gt;&amp; worker)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, curmax = <span class="number">0</span>, curwork = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = difficulty.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">            v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(difficulty[i], profit[i]));</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a,pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)&#123; <span class="keyword">return</span> a.first &lt; b.first; &#125;);</span><br><span class="line">        <span class="built_in">sort</span>(worker.<span class="built_in">begin</span>(), worker.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; worker.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (worker[i] &lt; v[j].first) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                curmax = <span class="built_in">max</span>(curmax, v[j].second);</span><br><span class="line">                j ++;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            res += curmax;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode830-Positions-of-Large-Groups"><a href="#Leetcode830-Positions-of-Large-Groups" class="headerlink" title="Leetcode830. Positions of Large Groups"></a>Leetcode830. Positions of Large Groups</h1><p>In a string S of lowercase letters, these letters form consecutive groups of the same character. For example, a string like S = “abbxxxxzyy” has the groups “a”, “bb”, “xxxx”, “z” and “yy”.</p>
<p>Call a group large if it has 3 or more characters.  We would like the starting and ending positions of every large group. The final answer should be in lexicographic order.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abbxxxxzzy&quot;</span><br><span class="line">Output: [[3,6]]</span><br><span class="line">Explanation: &quot;xxxx&quot; is the single large group with starting  3 and ending positions 6.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abc&quot;</span><br><span class="line">Output: []</span><br><span class="line">Explanation: We have &quot;a&quot;,&quot;b&quot; and &quot;c&quot; but no large group.</span><br></pre></td></tr></table></figure><br>找到长度大于3的子串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">largeGroupPositions</span>(string S) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> len = S.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> begin, end;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            begin = i;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; len<span class="number">-1</span> &amp;&amp; S[i] == S[i<span class="number">+1</span>])</span><br><span class="line">                i ++;</span><br><span class="line">            <span class="keyword">if</span>(i - begin + <span class="number">1</span> &gt;= <span class="number">3</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;begin, i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode831-Masking-Personal-Information"><a href="#Leetcode831-Masking-Personal-Information" class="headerlink" title="Leetcode831. Masking Personal Information"></a>Leetcode831. Masking Personal Information</h1><p>We are given a personal information string S, which may represent either an email address or a phone number.</p>
<p>We would like to mask this personal information according to the following rules:</p>
<ul>
<li>Email address:<ul>
<li>We define a name to be a string of length ≥ 2consisting of only lowercase letters a-z or uppercase letters A-Z.</li>
<li>An email address starts with a name, followed by the symbol ‘@’, followed by a name, followed by the dot ‘.’ and followed by a name. </li>
<li>All email addresses are guaranteed to be valid and in the format of “name1@name2.name3”.</li>
<li>To mask an email, all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks ‘*’.</li>
</ul>
</li>
<li>Phone number:<ul>
<li>A phone number is a string consisting of only the digits 0-9or the characters from the set {‘+’, ‘-‘, ‘(‘, ‘)’, ‘ ‘}. You may assume a phone number contains 10 to 13 digits.</li>
<li>The last 10 digits make up the local number, while the digits before those make up the country code. Note that the country code is optional. We want to expose only the last 4 digits and mask all other digits.</li>
<li>The local number should be formatted and masked as <code>***-***-1111</code>, where 1 represents the exposed digits.</li>
<li>To mask a phone number with country code like <code>+111 111 111 1111</code>, we write it in the form <code>+***-***-***-1111</code>. The ‘+’ sign and the first ‘-‘ sign before the local number should only exist if there is a country code.  For example, a 12 digit phone number mask should start with “+**-“.</li>
</ul>
</li>
</ul>
<p>Note that extraneous characters like “(“, “)”, “ “, as well as extra dashes or plus signs not part of the above formatting scheme should be removed.</p>
<p>Return the correct “mask” of the information provided.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;LeetCode@LeetCode.com&quot;</span><br><span class="line">Output: &quot;l*****e@leetcode.com&quot;</span><br><span class="line">Explanation: All names are converted to lowercase, and the letters between the</span><br><span class="line">             first and last letter of the first name is replaced by 5 asterisks.</span><br><span class="line">             Therefore, &quot;leetcode&quot; -&gt; &quot;l*****e&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;AB@qq.com&quot;</span><br><span class="line">Output: &quot;a*****b@qq.com&quot;</span><br><span class="line">Explanation: There must be 5 asterisks between the first and last letter </span><br><span class="line">             of the first name &quot;ab&quot;. Therefore, &quot;ab&quot; -&gt; &quot;a*****b&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;1(234)567-890&quot;</span><br><span class="line">Output: &quot;***-***-7890&quot;</span><br><span class="line">Explanation: 10 digits in the phone number, which means all digits make up the local number.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;86-(10)12345678&quot;</span><br><span class="line">Output: &quot;+**-***-***-5678&quot;</span><br><span class="line">Explanation: 12 digits, 2 digits for country code and 10 digits for local number. </span><br></pre></td></tr></table></figure></p>
<p>这道题让我们给个人信息打码。这里对邮箱和电话分别进行了不同的打码方式，对于邮箱来说，只保留用户名的首尾两个字符，然后中间固定加上五个星号，还有就是所有的字母转小写。对于电话来说，有两种方式，有和没有国家代号，有的话其前面必须有加号，跟后面的区域号用短杠隔开，后面的10个电话号分为三组，个数分别为3，3，4。每组之间还是用短杠隔开，除了最后一组的数字保留之外，其他的都用星号代替。弄清楚了题意，就开始解题吧。既然是字符串的题目，那么肯定要遍历这个字符串了，我们关心的主要是数字和字母，所以要用个变量str来保存遍历到的数字和字母，所以判断，如果是数字或者小写字母的话，直接加入str中，若是大写字母的话，转成小写字母再加入str，如果遇到了 ‘@’ 号，那么表示当前处理的是邮箱，而此时的用户已经全部读入str了，那直接就取出首尾字符，然后中间加五个星号，并再加上 ‘@’ 号存入结果res中，并把str清空。若遇到了点，说明此时是邮箱的后半段，因为题目中限制了用户名中不会有点存在，那么我们将str和点一起加入结果res，并将str清空。当遍历结束时，若此时结果res不为空，说明我们处理的是邮箱，那么返回结果res加上str，因为str中存的是 “com”，还没有来得及加入结果res。若res为空，说明处理的是电话号码，所有的数字都已经加入了str，由于国家代号可能有也可能没有，所以判断一下存入的数字的个数，如果超过10个了，说明有国家代号，那么将超过的部分取出来拼装一下，前面加 ‘+’ 号，后面加短杠。然后再将10位号码的前六位的星号格式加上，并加上最后四个数字即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">tolower</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> c + (<span class="string">&#x27;a&#x27;</span>-<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">maskPII</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string t, res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">bool</span> is_email = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> _size = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> aa = <span class="number">0</span>, bb = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;@&#x27;</span> == s[i]) &#123;</span><br><span class="line">                is_email = <span class="literal">true</span>;</span><br><span class="line">                aa = i<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;-&#x27;</span> == s[i])</span><br><span class="line">                _size ++;</span><br><span class="line">            <span class="keyword">if</span> (_size == <span class="number">1</span> &amp;&amp; bb == <span class="number">-1</span> &amp;&amp; <span class="string">&#x27;-&#x27;</span> == s[i])</span><br><span class="line">                bb = i;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;+&#x27;</span> == s[i] || <span class="string">&#x27;-&#x27;</span> == s[i] || <span class="string">&#x27;(&#x27;</span> == s[i] || <span class="string">&#x27;)&#x27;</span> == s[i] || <span class="string">&#x27; &#x27;</span> == s[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            t.<span class="built_in">push_back</span>(<span class="built_in">tolower</span>(s[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (is_email) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">length</span>(); i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    res += t[i];</span><br><span class="line">                    res += <span class="string">&quot;*****&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= aa)</span><br><span class="line">                    res += t[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> length = t.<span class="built_in">length</span>();</span><br><span class="line">            <span class="keyword">if</span> (length &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                res += <span class="string">&quot;+&quot;</span>;</span><br><span class="line">                res += <span class="built_in">string</span>(length<span class="number">-10</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">                res += <span class="string">&quot;-&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += <span class="string">&quot;***-***-&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = length<span class="number">-4</span>; i &lt; length; i ++)</span><br><span class="line">                res += t[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode832-Flipping-an-Image"><a href="#Leetcode832-Flipping-an-Image" class="headerlink" title="Leetcode832. Flipping an Image"></a>Leetcode832. Flipping an Image</h1><p>Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.</p>
<p>To flip an image horizontally means that each row of the image is reversed.  For example, flipping [1, 1, 0] horizontally results in [0, 1, 1].</p>
<p>To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0].</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">Output: [[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].</span><br><span class="line">Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br><span class="line">Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br><span class="line">Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].</span><br><span class="line">Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br></pre></td></tr></table></figure><br>没啥好说的，普通的矩阵操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">flipAndInvertImage</span>(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>, k = A[i].<span class="built_in">size</span>()<span class="number">-1</span>; j &lt; A[i].<span class="built_in">size</span>() / <span class="number">2</span>; j ++, k --)&#123;</span><br><span class="line">                <span class="type">int</span> temp = A[i][j];</span><br><span class="line">                A[i][j] = A[i][k];</span><br><span class="line">                A[i][k] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>, k = A[i].<span class="built_in">size</span>()<span class="number">-1</span>; j &lt; A[i].<span class="built_in">size</span>(); j ++, k --)&#123;</span><br><span class="line">                A[i][j] = <span class="number">1</span> - A[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode833-Find-And-Replace-in-String"><a href="#Leetcode833-Find-And-Replace-in-String" class="headerlink" title="Leetcode833. Find And Replace in String"></a>Leetcode833. Find And Replace in String</h1><p>To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size).</p>
<p>Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y.  The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y.  If not, we do nothing.</p>
<p>For example, if we have S = “abcd” and we have some replacement operation i = 2, x = “cd”, y = “ffff”, then because “cd” starts at position 2 in the original string S, we will replace it with “ffff”.</p>
<p>Using another example on S = “abcd”, if we have both the replacement operation i = 0, x = “ab”, y = “eee”, as well as another replacement operation i = 2, x = “ec”, y = “ffff”, this second operation does nothing because in the original string S[2] = ‘c’, which doesn’t match x[0] = ‘e’.</p>
<p>All these operations occur simultaneously.  It’s guaranteed that there won’t be any overlap in replacement: for example, S = “abc”, indexes = [0, 1], sources = [“ab”,”bc”] is not a valid test case.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;a&quot;,&quot;cd&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]</span><br><span class="line">Output: &quot;eeebffff&quot;</span><br><span class="line">Explanation: &quot;a&quot; starts at index 0 in S, so it&#x27;s replaced by &quot;eee&quot;.</span><br><span class="line">&quot;cd&quot; starts at index 2 in S, so it&#x27;s replaced by &quot;ffff&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;ab&quot;,&quot;ec&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]</span><br><span class="line">Output: &quot;eeecd&quot;</span><br><span class="line">Explanation: &quot;ab&quot; starts at index 0 in S, so it&#x27;s replaced by &quot;eee&quot;. </span><br><span class="line">&quot;ec&quot; doesn&#x27;t starts at index 2 in the original S, so we do nothing.</span><br></pre></td></tr></table></figure></p>
<p>Notes:</p>
<ul>
<li>0 &lt;= indexes.length = sources.length = targets.length &lt;= 100</li>
<li>0 &lt; indexes[i] &lt; S.length &lt;= 1000</li>
<li>All characters in given inputs are lowercase letters.</li>
</ul>
<p>这道题给了我们一个字符串S，并给了一个坐标数组，还有一个源字符串数组，还有目标字符串数组，意思是若某个坐标位置起，源字符串数组中对应位置的字符串出现了，将其替换为目标字符串。此题的核心操作就两个，查找和替换，需要注意的是，由于替换操作会改变原字符串，但是我们查找始终是基于最初始的S。</p>
<p>首先我们需要给indexes数组排个序，因为可能不是有序的，但是却不能直接排序，这样会丢失和sources，targets数组的对应关系，这很麻烦。所以我们新建了一个保存pair对儿的数组，将indexes数组中的数字跟其位置坐标组成pair对儿，加入新数组v中，然后给这个新数组按从大到小的方式排序。</p>
<p>下面就要开始遍历新数组v了，对于遍历到的pair对儿，取出第一个数字，保存到i，表示S中需要查找的位置，取出第二个数字，然后根据这个位置分别到sources和targets数组中取出源字符串和目标字符串，然后我们在S中的i位置，向后取出和源字符串长度相同的子串，然后比较，若正好和源字符串相等，则将其替换为目标字符串即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">findReplaceString</span><span class="params">(string s, vector&lt;<span class="type">int</span>&gt;&amp; indices, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; indices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(&#123;indices[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len &amp;&amp; p1 &lt; v.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = i, j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; indices[v[p1].second])</span><br><span class="line">                p1 ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == indices[v[p1].second]) &#123;</span><br><span class="line">                <span class="type">int</span> len2 = sources[v[p1].second].<span class="built_in">length</span>();</span><br><span class="line">                <span class="keyword">while</span>(j &lt; len2 &amp;&amp; tmp &lt; len)  &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sources[v[p1].second][j] != s[tmp]) </span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    j ++; tmp++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == len2) &#123;</span><br><span class="line">                    res += targets[v[p1].second];</span><br><span class="line">                    p1 ++;</span><br><span class="line">                    i += len2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    res += s[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; len)  </span><br><span class="line">                res += s[i++];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; len)</span><br><span class="line">            res += s[i++];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode835-Image-Overlap"><a href="#Leetcode835-Image-Overlap" class="headerlink" title="Leetcode835. Image Overlap"></a>Leetcode835. Image Overlap</h1><p>You are given two images, img1 and img2, represented as binary, square matrices of size n x n. A binary matrix has only 0s and 1s as values.</p>
<p>We translate one image however we choose by sliding all the 1 bits left, right, up, and/or down any number of units. We then place it on top of the other image. We can then calculate the overlap by counting the number of positions that have a 1 in both images.</p>
<p>Note also that a translation does not include any kind of rotation. Any 1 bits that are translated outside of the matrix borders are erased.</p>
<p>Return the largest possible overlap.</p>
<p><img src="/img/1631001223.jpg" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: img1 = [[1]], img2 = [[1]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: img1 = [[0]], img2 = [[0]]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>经过观察</p>
<p>(0,0)-&gt;(1,1)-&gt;(0,0)-(1,1)=(-1,-1)</p>
<p>(0,1)-&gt;(1,2)-&gt;(0,1)-(1,2)=(-1,-1)</p>
<p>(1,1)-&gt;(2,2)-&gt;(1,1)-(2,2)=(-1,-1)</p>
<p>从A对应到B是把整个矩阵的坐标x轴-1， y轴-1；</p>
<p>变相就是在求所有A矩阵1的点到B矩阵1的点的X轴和Y轴距离;</p>
<p>所有坐标的取值范围在(-N—N)之间;</p>
<p>实际上就是把一个一维求距离的easy的题换成了二维的题目;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestOverlap</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; A, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = A.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">m_map</span>(<span class="number">2</span>*n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>*n<span class="number">+1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; n; ++ii) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; n; ++jj) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (B[ii][jj] == <span class="number">1</span>)</span><br><span class="line">                                ++m_map[i-ii+n][j-jj+n];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_map.<span class="built_in">size</span>(); i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m_map[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">                res = <span class="built_in">max</span>(m_map[i][j], res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode836-Rectangle-Overlap"><a href="#Leetcode836-Rectangle-Overlap" class="headerlink" title="Leetcode836. Rectangle Overlap"></a>Leetcode836. Rectangle Overlap</h1><p>A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner.</p>
<p>Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap.</p>
<p>Given two (axis-aligned) rectangles, return whether they overlap.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>这道题让我们求两个矩形是否是重叠，矩形的表示方法是用两个点，左下和右上点来定位的。下面的讲解是参见网友大神jayesch的帖子来的，首先，返璞归真，在玩 2D 之前，先看下 1D 上是如何运作的。对于两条线段，它们相交的话可以是如下情况：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">          x3             x4</span><br><span class="line">          |--------------|</span><br><span class="line">|--------------|</span><br><span class="line">x1             x2</span><br></pre></td></tr></table></figure><br>我们可以直观的看出一些关系： x1 &lt; x3 &lt; x2 &amp;&amp; x3 &lt; x2 &lt; x4，可以稍微化简一下：x1 &lt; x4 &amp;&amp; x3 &lt; x2。就算是调换个位置：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">          x1             x2</span><br><span class="line">          |--------------|</span><br><span class="line">|--------------|</span><br><span class="line">x3             x4</span><br></pre></td></tr></table></figure><br>还是能得到同样的关系：x3 &lt; x2 &amp;&amp; x1 &lt; x4。好，下面我们进军 2D 的世界，实际上 2D 的重叠就是两个方向都同时满足 1D 的重叠条件即可。由于题目中说明了两个矩形的重合面积为正才算 overlap，就是说挨着边的不算重叠，那么两个矩形重叠主要有这四种情况：</p>
<p>1）两个矩形在矩形1的右上角重叠：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">          ____________________x4,y4</span><br><span class="line">         |                   |</span><br><span class="line">  _______|______x2,y2        |</span><br><span class="line"> |       |______|____________|</span><br><span class="line"> |      x3,y3   |</span><br><span class="line"> |______________|</span><br><span class="line">x1,y1</span><br></pre></td></tr></table></figure><br>满足的条件为：x1 &lt; x4 &amp;&amp; x3 &lt; x2 &amp;&amp; y1 &lt; y4 &amp;&amp; y3 &lt; y2</p>
<p>2）两个矩形在矩形1的左上角重叠：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   ___________________  x4,y4</span><br><span class="line">  |                   |</span><br><span class="line">  |            _______|____________x2,y2</span><br><span class="line">  |___________|_______|           |</span><br><span class="line">x3,y3         |                   | </span><br><span class="line">              |___________________|</span><br><span class="line">            x1,y1</span><br></pre></td></tr></table></figure><br>满足的条件为：x3 &lt; x2 &amp;&amp; x1 &lt; x4 &amp;&amp; y1 &lt; y4 &amp;&amp; y3 &lt; y2</p>
<p>3）两个矩形在矩形1的左下角重叠：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">          ____________________x2,y2</span><br><span class="line">         |                   |</span><br><span class="line">  _______|______x4,y4        |</span><br><span class="line"> |       |______|____________|</span><br><span class="line"> |      x1,y1   |</span><br><span class="line"> |______________|</span><br><span class="line">x3,y3</span><br></pre></td></tr></table></figure><br>满足的条件为：x3 &lt; x2 &amp;&amp; x1 &lt; x4 &amp;&amp; y3 &lt; y2 &amp;&amp; y1 &lt; y4</p>
<p>4）两个矩形在矩形1的右下角重叠：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   ___________________  x2,y2</span><br><span class="line">  |                   |</span><br><span class="line">  |            _______|____________x4,y4</span><br><span class="line">  |___________|_______|           |</span><br><span class="line">x1,y1         |                   | </span><br><span class="line">              |___________________|</span><br><span class="line">            x3,y3</span><br></pre></td></tr></table></figure><br>满足的条件为：x1 &lt; x4 &amp;&amp; x3 &lt; x2 &amp;&amp; y3 &lt; y2 &amp;&amp; y1 &lt; y4</p>
<p>仔细观察可以发现，上面四种情况的满足条件其实都是相同的，只不过顺序调换了位置，所以我们只要一行就可以解决问题了，碉堡了。。。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isRectangleOverlap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; rec1, vector&lt;<span class="type">int</span>&gt;&amp; rec2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rec1[<span class="number">0</span>] &lt; rec2[<span class="number">2</span>] &amp;&amp; rec2[<span class="number">0</span>] &lt; rec1[<span class="number">2</span>] &amp;&amp; rec1[<span class="number">1</span>] &lt; rec2[<span class="number">3</span>] &amp;&amp; rec2[<span class="number">1</span>] &lt; rec1[<span class="number">3</span>]; </span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode838-Push-Dominoes"><a href="#Leetcode838-Push-Dominoes" class="headerlink" title="Leetcode838. Push Dominoes"></a>Leetcode838. Push Dominoes</h1><p>There are N dominoes in a line, and we place each domino vertically upright.</p>
<p>In the beginning, we simultaneously push some of the dominoes either to the left or to the right.</p>
<p>After each second, each domino that is falling to the left pushes the adjacent domino on the left.</p>
<p>Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.</p>
<p>When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.</p>
<p>For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.</p>
<p>Given a string “S” representing the initial state. S[i] = ‘L’, if the i-th domino has been pushed to the left; S[i] = ‘R’, if the i-th domino has been pushed to the right; S[i] = ‘.’, if the i-th domino has not been pushed.</p>
<p>Return a string representing the final state. </p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;.L.R...LR..L..&quot;</span><br><span class="line">Output: &quot;LL.RR.LLRRLL..&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;RR.L&quot;</span><br><span class="line">Output: &quot;RR.L&quot;</span><br><span class="line">Explanation: The first domino expends no additional force on the second domino.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 &lt;= N &lt;= 10^5</li>
<li>String dominoes contains only ‘L‘, ‘R’ and ‘.’</li>
</ul>
<p>这道题给我们摆好了一个多米诺骨牌阵列，但是与一般的玩法不同的是，这里没有从一头开始推，而是在很多不同的位置分别往两个方向推，结果是骨牌各自向不同的方向倒下了，而且有的骨牌由于左右两边受力均等，依然屹立不倒，这样的话骨牌就很难受了，能不能让哥安心的倒下去？！生而为骨牌，总是要倒下去啊，就像漫天飞舞的樱花，秒速五厘米的落下，回到最终归宿泥土里。喂，不要给骨牌强行加戏好么！～ 某个位置的骨牌会不会倒，并且朝哪个方向倒，是由左右两边受到的力的大小决定的，那么可以分为下列四种情况：</p>
<p>1）R….R  -&gt;  RRRRRR</p>
<p>这是当两个向右推的操作连在一起时，那么中间的骨牌毫无悬念的都要向右边倒去。</p>
<p>2）L….L  -&gt;  LLLLLL</p>
<p>同理，</p>
<p>当两个向左推的操作连在一起时，那么中间的骨牌毫无悬念的都要向左边倒去。</p>
<p>3）L….R  -&gt;  L….R</p>
<p>当左边界的骨牌向左推，右边界的骨牌向右推，那么中间的骨牌不会收到力，所以依然保持坚挺。</p>
<p>4）R….L  -&gt; RRRLLL   or   R…..L  -&gt;  RRR.LLL</p>
<p>当左边界的骨牌向右推，右边界的骨牌向左推时，就要看中间的骨牌个数了，若是偶数，那么对半分，若是奇数，那么最中间的骨牌保持站立，其余的对半分。 </p>
<p>由于上述四种情况包含了所有的情况，所以我们的目标就是在字符串中找出中间是‘点’的小区间，为了便于我们一次遍历就处理完，我们在dominoes字符串左边加个L，右边加个R，这并不会影响骨牌倒下的情况。我们使用双指针来遍历，其中i初始化为0，j初始化为1，当j指向‘点’时，我们就跳过，目标是i指向小区间的左边界，j指向右边界，然后用 j-i-1 算出中间‘点’的个数，为0表示中间没有点。若此时 i&gt;0，则将左边界加入结果res中。若左右边界相同，那么中间的点都填成左边界，这是上述的情况一和二；若左边界是L，右边界是R，则是上述的情况三，中间还是保持点不变；若左边界是R，右边界是L，则是情况四，那么先加 mid/2 个R，再加 mid%2 个点，最后加 mid/2 个L即可。然后i更新为j，继续循环即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">pushDominoes</span><span class="params">(string dominoes)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        dominoes = <span class="string">&quot;L&quot;</span> + dominoes + <span class="string">&quot;R&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; j &lt; dominoes.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dominoes[j] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> mid = j - i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) res += dominoes[i];</span><br><span class="line">            <span class="keyword">if</span> (dominoes[i] == dominoes[j]) res += <span class="built_in">string</span>(mid, dominoes[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dominoes[i] == <span class="string">&#x27;L&#x27;</span> &amp;&amp; dominoes[j] == <span class="string">&#x27;R&#x27;</span>) res += <span class="built_in">string</span>(mid, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> res += <span class="built_in">string</span>(mid / <span class="number">2</span>, <span class="string">&#x27;R&#x27;</span>) + <span class="built_in">string</span>(mid % <span class="number">2</span>, <span class="string">&#x27;.&#x27;</span>) + <span class="built_in">string</span>(mid / <span class="number">2</span>, <span class="string">&#x27;L&#x27;</span>);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面这种解法遍历了两次字符串，第一次遍历是先把R后面的点全变成R，同时累加一个cnt数组，其中cnt[i]表示在dominoes数组中i位置时R连续出现的个数，那么拿题目中的例子1来说，第一次遍历之后，原dominoes数组，修改后的dominoes数组，以及cnt数组分别为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.L.R...LR..L..</span><br><span class="line">.L.RRRRLRRRL..</span><br><span class="line">00001230012000</span><br></pre></td></tr></table></figure></p>
<p>我们可以发现cnt数字记录的是R连续出现的个数，第一次遍历只模拟了所有往右推倒的情况，很明显不是最终答案，因为还需要往左推，那么就要把某些点变成L，已经把某些R变成点或者L，这时我们的cnt数组就非常重要，因为它相当于记录了往右推的force的大小。第二次遍历是从右往左，我们找所有L前面的位置，若其为点，则直接变为L。若其为R，那么也有可能变L，此时就要计算往左的force，通过 cnt[i+1] + 1 获得，然后跟往右的force比较，若此位置往右的force大，说明当前骨牌应该往左倒，更新此时cnt[i]为往左的force。若此时左右force相等了，说明当前骨牌不会向任意一遍倒，改为点即可，最终修改后的dominoes数组和cnt数组分别为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LL.RR.LLRRLL..</span><br><span class="line">10001210011000</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">pushDominoes</span><span class="params">(string dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = dominoes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dominoes[i - <span class="number">1</span>] == <span class="string">&#x27;R&#x27;</span> &amp;&amp; dominoes[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                dominoes[i] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">                cnt[i] = cnt[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>, cur = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dominoes[i + <span class="number">1</span>] != <span class="string">&#x27;L&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            cur = cnt[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dominoes[i] == <span class="string">&#x27;.&#x27;</span> || cnt[i] &gt; cur) &#123;</span><br><span class="line">                dominoes[i] = <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">                cnt[i] = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dominoes[i] == <span class="string">&#x27;R&#x27;</span> &amp;&amp; cnt[i] == cur) &#123;</span><br><span class="line">                dominoes[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dominoes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode840-Magic-Squares-In-Grid"><a href="#Leetcode840-Magic-Squares-In-Grid" class="headerlink" title="Leetcode840. Magic Squares In Grid"></a>Leetcode840. Magic Squares In Grid</h1><p>A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.</p>
<p>Given an grid of integers, how many 3 x 3 “magic square” subgrids are there?  (Each subgrid is contiguous).</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: [[4,3,8,4],</span><br><span class="line">        [9,5,1,9],</span><br><span class="line">        [2,7,6,2]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">The following subgrid is a 3 x 3 magic square:</span><br><span class="line">438</span><br><span class="line">951</span><br><span class="line">276</span><br><span class="line"></span><br><span class="line">while this one is not:</span><br><span class="line">384</span><br><span class="line">519</span><br><span class="line">762</span><br></pre></td></tr></table></figure><br>In total, there is only one magic square inside the given grid.</p>
<p>幻方的特点是，全体数和=3X幻和，幻和=3×中心数。在基本三阶幻方中，幻和=1+2+…+9=45/3=15，所以中心数=5。因此只要从[1,1]开始判断中间数为5，再进一步判断是否为幻方。进一步判断：首先可使用二进制数来判断是否该矩阵是由1～9的组成。再判断通过中心的4组对角值和为10，&amp;&amp; 第一行和第一列和为15。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMagic</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> chknum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a=i<span class="number">-1</span>; a&lt;=i<span class="number">+1</span>; a++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b=j<span class="number">-1</span>; b&lt;=j<span class="number">+1</span>; b++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[a][b]&gt;<span class="number">0</span> &amp;&amp; grid[a][b]&lt;<span class="number">10</span>)</span><br><span class="line">                chknum |= <span class="number">1</span>&lt;&lt;(grid[a][b]<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(chknum!=<span class="number">0b111111111</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i<span class="number">+1</span>][j<span class="number">+1</span>]==<span class="number">10</span> &amp;&amp; grid[i][j<span class="number">-1</span>]+grid[i][j<span class="number">+1</span>]==<span class="number">10</span> &amp;&amp;</span><br><span class="line">          grid[i<span class="number">-1</span>][j]+grid[i<span class="number">+1</span>][j]==<span class="number">10</span> &amp;&amp; grid[i<span class="number">-1</span>][j<span class="number">+1</span>]+grid[i<span class="number">+1</span>][j<span class="number">-1</span>]==<span class="number">10</span> &amp;&amp;</span><br><span class="line">          grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i<span class="number">-1</span>][j]+grid[i<span class="number">-1</span>][j<span class="number">+1</span>]==<span class="number">15</span> &amp;&amp;</span><br><span class="line">          grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i][j<span class="number">-1</span>]+grid[i<span class="number">+1</span>][j<span class="number">-1</span>]==<span class="number">15</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numMagicSquaresInside</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> N=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;N<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;N<span class="number">-1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">5</span> &amp;&amp; <span class="built_in">isMagic</span>(i,j,grid))&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode841-Keys-and-Rooms"><a href="#Leetcode841-Keys-and-Rooms" class="headerlink" title="Leetcode841. Keys and Rooms"></a>Leetcode841. Keys and Rooms</h1><p>There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, …, N-1, and each room may have some keys to access the next room. </p>
<p>Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, …, N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v.</p>
<p>Initially, all the rooms start locked (except for room 0). </p>
<p>You can walk back and forth between rooms freely.</p>
<p>Return true if and only if you can enter every room.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1],[2],[3],[]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:  </span><br><span class="line">We start in room 0, and pick up key 1.</span><br><span class="line">We then go to room 1, and pick up key 2.</span><br><span class="line">We then go to room 2, and pick up key 3.</span><br><span class="line">We then go to room 3.  Since we were able to go to every room, we return true.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[3,0,1],[2],[0]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: We can&#x27;t enter the room with number 2.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= rooms.length &lt;= 1000</li>
<li>0 &lt;= rooms[i].length &lt;= 1000</li>
<li>The number of keys in all rooms combined is at most 3000.</li>
</ul>
<p>这道题给了我们一些房间，房间里有一些钥匙，用钥匙可以打开对应的房间，说是起始时在房间0，问最终是否可以打开所有的房间。这不由得让博主想起了惊悚片《万能钥匙》，还真是头皮发麻啊。赶紧扯回来，这是一道典型的有向图的遍历的题，邻接链表都已经建立好了，这里直接遍历就好了，这里先用 BFS 来遍历。使用一个 HashSet 来记录访问过的房间，先把0放进去，然后使用 queue 来辅助遍历，同样将0放入。之后进行典型的 BFS 遍历，取出队首的房间，然后遍历其中的所有钥匙，若该钥匙对应的房间已经遍历过了，直接跳过，否则就将钥匙加入 HashSet。此时看若 HashSet 中的钥匙数已经等于房间总数了，直接返回 true，因为这表示所有房间已经访问过了，否则就将钥匙加入队列继续遍历。最后遍历结束后，就看 HashSet 中的钥匙数是否和房间总数相等即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; visited&#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q&#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> key : rooms[t]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">count</span>(key)) <span class="keyword">continue</span>;</span><br><span class="line">                visited.<span class="built_in">insert</span>(key);</span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">size</span>() == rooms.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.<span class="built_in">size</span>() == rooms.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我自己的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = rooms.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            visited[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rooms[t].<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[rooms[t][i]])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(rooms[t][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">            <span class="keyword">if</span> (!visited[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode844-Backspace-String-Compare"><a href="#Leetcode844-Backspace-String-Compare" class="headerlink" title="Leetcode844. Backspace String Compare"></a>Leetcode844. Backspace String Compare</h1><p>Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.</p>
<p>Note that after backspacing an empty text, the text will continue empty.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ab#c&quot;, T = &quot;ad#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;ac&quot;.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ab##&quot;, T = &quot;c#d#&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;&quot;.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;a##c&quot;, T = &quot;#a#c&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Both S and T become &quot;c&quot;.</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;a#c&quot;, T = &quot;b&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: S becomes &quot;c&quot; while T becomes &quot;b&quot;.</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string S, string T)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; a, b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">length</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                a.<span class="built_in">push</span>(S[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!a.<span class="built_in">empty</span>())</span><br><span class="line">                a.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        string r1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!a.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            r1 += a.<span class="built_in">top</span>();</span><br><span class="line">            a.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; T.<span class="built_in">length</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(T[i] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                a.<span class="built_in">push</span>(T[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!a.<span class="built_in">empty</span>())</span><br><span class="line">                a.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        string r2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!a.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            r2 += a.<span class="built_in">top</span>();</span><br><span class="line">            a.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r1 == r2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一种更好的做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                k--;</span><br><span class="line">                k=<span class="built_in">max</span>(<span class="number">0</span>,k);</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               s[k]=s[i];</span><br><span class="line">               k++;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[i]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p--;</span><br><span class="line">                p=<span class="built_in">max</span>(<span class="number">0</span>,p);</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               t[p]=t[i];</span><br><span class="line">               p++;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k!=p)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]!=t[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode845-Longest-Mountain-in-Array-数组中最长的山"><a href="#Leetcode845-Longest-Mountain-in-Array-数组中最长的山" class="headerlink" title="Leetcode845. Longest Mountain in Array 数组中最长的山"></a>Leetcode845. Longest Mountain in Array 数组中最长的山</h1><p>Let’s call any (contiguous) subarray B (of A) a mountain if the following properties hold:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.length &gt;= 3</span><br></pre></td></tr></table></figure></p>
<p>There exists some <code>0 &lt; i &lt; B.length - 1</code> such that <code>B[0] &lt; B[1] &lt; ... B[i-1] &lt; B[i] &gt; B[i+1] &gt; ... &gt; B[B.length - 1]</code><br>(Note that B could be any subarray of A, including the entire array A.)</p>
<p>Given an array A of integers, return the length of the longest mountain. </p>
<p>Return 0 if there is no mountain.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,4,7,3,2,5]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The largest mountain is [1,4,7,3,2] which has length 5.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,2]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no mountain.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 &lt;= A.length &lt;= 10000</li>
<li>0 &lt;= A[i] &lt;= 10000</li>
</ul>
<p>这道题给了我们一个数组，然后定义了一种像山一样的子数组，就是先递增再递减的子数组，注意这里是强行递增或者递减的，并不存在相等的情况。那么实际上这道题就是让在数组中寻找一个位置，使得以此位置为终点的递增数组和以此位置为起点的递减数组的长度最大。而以某个位置为起点的递减数组，如果反个方向来看，其实就是就该位置为终点的递增数列，那么既然都是求最长的递增数列，我们可以分别用两个 dp 数组 up 和 down，其中<code>up[i]</code>表示以<code>i</code>位置为终点的最长递增数列的个数，<code>down[i]</code>表示以<code>i</code>位置为起点的最长递减数列的个数，这样我们正向更新<code>up</code>数组，反向更新<code>down</code>数组即可。先反向更新好了<code>down</code>之后，在正向更新<code>up</code>数组的同时，也可以更新结果<code>res</code>，当某个位置的<code>up[i]</code>和<code>down[i]</code>均大于0的时候，那么就可以用<code>up[i] + down[i] + 1</code>来更新结果<code>res</code>了，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestMountain</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">up</span><span class="params">(n)</span>, <span class="title">down</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>]) down[i] = down[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i - <span class="number">1</span>]) up[i] = up[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (up[i] &gt; <span class="number">0</span> &amp;&amp; down[i] &gt; <span class="number">0</span>) res = <span class="built_in">max</span>(res, up[i] + down[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以对空间进行优化，不必使用两个数组来记录所有位置的信息，而是只用两个变量 up 和 down 来分别记录以当前位置为终点的最长递增数列的长度，和以当前位置为终点的最长递减数列的长度。 我们从 i=1 的位置开始遍历，因为山必须要有上坡和下坡，所以 i=0 的位置永远不可能成为 peak。此时再看，如果当前位置跟前面的位置相等了，那么当前位置的 up 和 down 都要重置为0，从当前位置开始找新的山，和之前的应该断开。或者是当 down 不为0，说明此时是在下坡，如果当前位置大于之前的了，突然变上坡了，那么之前的累计也需要重置为0。然后当前位置再进行判断，若大于前一个位置，则是上坡，up 自增1，若小于前一个位置，是下坡，down 自增1。当 up 和 down 同时为正数，则用 up+down+1 来更新结果 res 即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestMountain</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, up = <span class="number">0</span>, down = <span class="number">0</span>, n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((down &amp;&amp; A[i - <span class="number">1</span>] &lt; A[i]) || (A[i - <span class="number">1</span>] == A[i])) &#123;</span><br><span class="line">                up = down = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &lt; A[i]) ++up;</span><br><span class="line">            <span class="keyword">if</span> (A[i - <span class="number">1</span>] &gt; A[i]) ++down;</span><br><span class="line">            <span class="keyword">if</span> (up &gt; <span class="number">0</span> &amp;&amp; down &gt; <span class="number">0</span>) res = <span class="built_in">max</span>(res, up + down + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode848-Shifting-Letters"><a href="#Leetcode848-Shifting-Letters" class="headerlink" title="Leetcode848. Shifting Letters"></a>Leetcode848. Shifting Letters</h1><p>You are given a string s of lowercase English letters and an integer array shifts of the same length.</p>
<p>Call the shift() of a letter, the next letter in the alphabet, (wrapping around so that ‘z’ becomes ‘a’).</p>
<p>For example, shift(‘a’) = ‘b’, shift(‘t’) = ‘u’, and shift(‘z’) = ‘a’.<br>Now for each shifts[i] = x, we want to shift the first i + 1 letters of s, x times.</p>
<p>Return the final string after all such shifts to s are applied.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abc&quot;, shifts = [3,5,9]</span><br><span class="line">Output: &quot;rpl&quot;</span><br><span class="line">Explanation: We start with &quot;abc&quot;.</span><br><span class="line">After shifting the first 1 letters of s by 3, we have &quot;dbc&quot;.</span><br><span class="line">After shifting the first 2 letters of s by 5, we have &quot;igc&quot;.</span><br><span class="line">After shifting the first 3 letters of s by 9, we have &quot;rpl&quot;, the answer.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;aaa&quot;, shifts = [1,2,3]</span><br><span class="line">Output: &quot;gfd&quot;</span><br></pre></td></tr></table></figure></p>
<p>题目大意：给定一组反转数，要求你将字母向前翻转（字母范围a~z）（z反转为a）</p>
<p>思路方法：这题用前缀和处理，一次性求出每个字母需要翻转的次数，否则会超时，当然要防止数据溢出，所以要将过程取余。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">shiftingLetters</span><span class="params">(string s, vector&lt;<span class="type">int</span>&gt;&amp; shifts)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = shifts.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (shifts.<span class="built_in">size</span>() == <span class="number">0</span> || s == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sums</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">            shifts[i] = (shifts[i<span class="number">+1</span>]%<span class="number">26</span> + shifts[i]%<span class="number">26</span>) %<span class="number">26</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">            s[i] = <span class="string">&#x27;a&#x27;</span> + (s[i] - <span class="string">&#x27;a&#x27;</span> + shifts[i]%<span class="number">26</span>) % <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode849-Maximize-Distance-to-Closest-Person"><a href="#Leetcode849-Maximize-Distance-to-Closest-Person" class="headerlink" title="Leetcode849. Maximize Distance to Closest Person"></a>Leetcode849. Maximize Distance to Closest Person</h1><p>In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty. </p>
<p>There is at least one empty seat, and at least one person sitting.</p>
<p>Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized. </p>
<p>Return that maximum distance to closest person.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,0,0,1,0,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.</span><br><span class="line">If Alex sits in any other open seat, the closest person has distance 1.</span><br><span class="line">Thus, the maximum distance to the closest person is 2.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,0,0]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">If Alex sits in the last seat, the closest person is 3 seats away.</span><br><span class="line">This is the maximum distance possible, so the answer is 3.</span><br></pre></td></tr></table></figure><br>Note:</p>
<ol>
<li>1 &lt;= seats.length &lt;= 20000</li>
<li>seats contains only 0s or 1s, at least one 0, and at least one 1.</li>
</ol>
<p>这道题给了我们一个只有0和1且长度为n的数组，代表n个座位，其中0表示空座位，1表示有人座。现在说是爱丽丝想找个位置坐下，但是希望能离最近的人越远越好，这个不难理解，就是想左右两边尽量跟人保持距离，让我们求这个距离最近的人的最大距离。来看题目中的例子1，有三个空位连在一起，那么爱丽丝肯定是坐在中间的位置比较好，这样跟左右两边人的距离都是2。例子2有些特别，当空位连到了末尾的时候，这里可以想像成靠墙，那么靠墙坐肯定离最远啦，所以例子2中爱丽丝坐在最右边的位子上距离左边的人距离最远为3。那么不难发现，爱丽丝肯定需要先找出最大的连续空位长度，若连续空位靠着墙了，那么就直接挨着墙坐，若两边都有人，那么就坐到空位的中间位置。如何能快速知道连续空位的长度呢，只要知道了两边人的位置，相减就是中间连续空位的个数。所以博主最先使用的方法是用一个数组来保存所有1的位置，即有人坐的位置，然后用相邻的两个位置相减，就可以得到连续空位的长度。当然，靠墙这种特殊情况要另外处理一下。当把所有1位置存入数组 nums 之后，开始遍历 nums 数组，第一个人的位置有可能不靠墙，那么他的位置坐标就是他左边靠墙的连续空位个数，直接更新结果 res 即可，因为靠墙连续空位的个数就是离右边人的最远距离。然后对于其他的位置，我们减去前一个人的位置坐标，然后除以2，更新结果 res。还有最右边靠墙的情况也要处理一下，就用 n-1 减去最后一个人的位置坐标，然后更新结果 res 即可，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDistToClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = seats.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seats[i] == <span class="number">1</span>) nums.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) res = <span class="built_in">max</span>(res, nums[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span> res = <span class="built_in">max</span>(res, (nums[i] - nums[i - <span class="number">1</span>]) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!nums.<span class="built_in">empty</span>()) </span><br><span class="line">			res = <span class="built_in">max</span>(res, n - <span class="number">1</span> - nums.<span class="built_in">back</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><br>我们也可以只用一次遍历，那么就需要在遍历的过程中统计出连续空位的个数，即连续0的个数。那么采用双指针来做，start 指向连续0的起点，初始化为0，i为当前遍历到的位置。遍历 seats 数组，跳过0的位置，当遇到1的时候，此时先判断下 start 的值，若是0的话，表明当前这段连续的空位是靠着墙的，所以要用连续空位的长度 i-start 来直接更新结果 res，否则的话就是两头有人的中间的空位，那么用长度加1除以2来更新结果 res，此时 start 要更新为 i+1，指向下一段连续空位的起始位置。for 循环退出后，还是要处理最右边靠墙的位置，用 n-start 来更新结果 res 即可，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDistToClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; seats)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = seats.<span class="built_in">size</span>(), start = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seats[i] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (start == <span class="number">0</span>) res = <span class="built_in">max</span>(res, i - start);</span><br><span class="line">            <span class="keyword">else</span> res = <span class="built_in">max</span>(res, (i - start + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, n - start);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>讨论：这道题的一个很好的 follow up 是让我们返回爱丽丝坐下的位置，那么要在结果 res 可以被更新的时候，同时还应该记录下连续空位的起始位置 start，这样有了 start 和 最大距离 res，那么就可以定位出爱丽丝的座位了。</p>
<h1 id="Leetcode851-Loud-and-Rich"><a href="#Leetcode851-Loud-and-Rich" class="headerlink" title="Leetcode851. Loud and Rich"></a>Leetcode851. Loud and Rich</h1><p>There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness.</p>
<p>You are given an array richer where <code>richer[i] = [ai, bi]</code> indicates that ai has more money than bi and an integer array quiet where <code>quiet[i]</code> is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time).</p>
<p>Return an integer array answer where <code>answer[x] = y</code> if <code>y</code> is the least quiet person (that is, the person <code>y</code> with the smallest value of <code>quiet[y]</code>) among all people who definitely have equal to or more money than the person x.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]</span><br><span class="line">Output: [5,5,2,5,4,5,6,7]</span><br><span class="line">Explanation: </span><br><span class="line">answer[0] = 5.</span><br><span class="line">Person 5 has more money than 3, which has more money than 1, which has more money than 0.</span><br><span class="line">The only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0.</span><br><span class="line">answer[7] = 7.</span><br><span class="line">Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.</span><br><span class="line">The other answers can be filled out with similar reasoning.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: richer = [], quiet = [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure></p>
<p>有n 个人，编号0 ∼ n − 1 ，它们有两个属性，财富和安静，给定两个数组r和q，r里面的元素都是数对，<code>(a , b)</code>表示a比b财富严格更多，而q qq存的是每个人的安静值。要求返回一个数组c，使得<code>c[i]</code>表示对于编号i的这个人，财富不少于他的所有人里安静值最小的人的编号。题目保证财富比较的传递关系没有环。</p>
<p>思路是记忆化搜索。先建图，将这些人看成若干个点，从财富少的到多的人连一条边，然后从每个点开始DFS。DFS到顶点u uu的时候，先DFS所有u的邻接点，这样就求出了u的邻接点的c值，接着在这些邻接点的c值里找到q值最小的（即找的安静值最小的）即可。可以做记忆化，当某个点的c值已经算出了，则不必重复算。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">loudAndRich</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; richer, vector&lt;<span class="type">int</span>&gt;&amp; quiet)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = quiet.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(len, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : richer) </span><br><span class="line">            m[a[<span class="number">1</span>]].<span class="built_in">push_back</span>(a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">            <span class="built_in">helper</span>(m, quiet, i, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt;&amp; m, vector&lt;<span class="type">int</span>&gt;&amp; quiet, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res[i] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        res[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ii : m[i]) &#123;</span><br><span class="line">            <span class="built_in">helper</span>(m, quiet, ii, res);</span><br><span class="line">            <span class="keyword">if</span> (quiet[res[i]] &gt; quiet[res[ii]])</span><br><span class="line">                res[i] = res[ii];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode852-Peak-Index-in-a-Mountain-Array"><a href="#Leetcode852-Peak-Index-in-a-Mountain-Array" class="headerlink" title="Leetcode852. Peak Index in a Mountain Array"></a>Leetcode852. Peak Index in a Mountain Array</h1><p>Let’s call an array A a mountain if the following properties hold:</p>
<p>A.length &gt;= 3<br>There exists some 0 &lt; i &lt; A.length - 1 such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]<br>Given an array that is definitely a mountain, return any i such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1].</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,2,1,0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><br>Note:</p>
<p>3 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt;= 10^6<br>A is a mountain, as defined above.</p>
<p>判断一个“山峰”数组的山峰在哪里，本来以为还要判断这个是不是山峰数组的，所以多写了一些，对结果没影响，懒得删了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="type">bool</span> isreal=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(A.<span class="built_in">size</span>()&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;A[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">if</span>(!isreal)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isreal)&#123;</span><br><span class="line">                    res=i<span class="number">-1</span>;</span><br><span class="line">                    isreal=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我这个做法不好，可以用二分查找。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="type">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lo = <span class="number">0</span>, hi = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="type">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mi] &lt; A[mi + <span class="number">1</span>])</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode853-Car-Fleet"><a href="#Leetcode853-Car-Fleet" class="headerlink" title="Leetcode853. Car Fleet"></a>Leetcode853. Car Fleet</h1><p><code>N</code> cars are going to the same destination along a one lane road.  The destination is <code>target</code> miles away.<br>Each car i has a constant speed speed[i] (in miles per hour), and initial position position[i] miles towards the target along the road.</p>
<p>A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.</p>
<p>The distance between these two cars is ignored - they are assumed to have the same position.</p>
<p>A car fleet is some non-empty set of cars driving at the same position and same speed.  Note that a single car is also a car fleet.</p>
<p>If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.<br>How many car fleets will arrive at the destination?</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The cars starting at 10 and 8 become a fleet, meeting each other at 12.</span><br><span class="line">The car starting at 0 doesn&#x27;t catch up to any other car, so it is a fleet by itself.</span><br><span class="line">The cars starting at 5 and 3 become a fleet, meeting each other at 6.</span><br><span class="line">Note that no other cars meet these fleets before the destination, so the answer is 3.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 &lt;= N &lt;= 10 ^ 4</li>
<li>0 &lt; target &lt;= 10 ^ 6</li>
<li>0 &lt; speed[i] &lt;= 10 ^ 6</li>
<li>0 &lt;= position[i] &lt; target</li>
<li>All initial positions are different.</li>
</ul>
<p>这道题说是路上有一系列的车，车在不同的位置，且分别有着不同的速度，但行驶的方向都相同。如果后方的车在到达终点之前追上前面的车了，那么它就会如痴汉般尾随在其后，且速度降至和前面的车相同，可以看作是一个车队，当然，单独的一辆车也可以看作是一个车队，问我们共有多少个车队到达终点。这道题是小学时候的应用题的感觉，什么狗追人啊，人追狗啊之类的。这道题的正确解法的思路其实不太容易想，因为我们很容易把注意力都集中到每辆车，去计算其每个时刻所在的位置，以及跟前面的车相遇的位置，这其实把这道题想复杂了，其实并不需要知道车的相遇位置，只关心是否能组成车队一同经过终点线，那么如何才能知道是否能一起过线呢，最简单的方法就是看时间，假如车B在车A的后面，而车B到终点线的时间小于等于车A，那么就知道车A和B一定会组成车队一起过线。这样的话，就可以从离终点最近的一辆车开始，先算出其撞线的时间，然后再一次遍历身后的车，若后面的车撞线的时间小于等于前面的车的时间，则会组成车队。反之，若大于前面的车的时间，则说明无法追上前面的车，于是自己会形成一个新的车队，且是车头，则结果 res 自增1即可。<br>思路有了，就可以具体实现了，使用一个 TreeMap 来建立小车位置和其到达终点时间之间的映射，这里的时间使用 double 型，通过终点位置减去当前位置，并除以速度来获得。我们希望能从 position 大的小车开始处理，而 TreeMap 是把小的数字排在前面，这里使用了个小 trick，就是映射的时候使用的是 position 的负数，这样就能先处理原来 position 大的车，从而统计出正确的车队数量，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">carFleet</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; position, vector&lt;<span class="type">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="type">double</span> cur = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">double</span>&gt; pos2time;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; position.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            pos2time[-position[i]] = (<span class="type">double</span>)(target - position[i]) / speed[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : pos2time) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.second &lt;= cur) <span class="keyword">continue</span>;</span><br><span class="line">            cur = a.second;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode855-Exam-Room"><a href="#Leetcode855-Exam-Room" class="headerlink" title="Leetcode855. Exam Room"></a>Leetcode855. Exam Room</h1><p>In an exam room, there are N seats in a single row, numbered 0, 1, 2, …, N-1.</p>
<p>When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.)</p>
<p>Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room.  It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;ExamRoom&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;leave&quot;,&quot;seat&quot;], [[10],[],[],[],[],[4],[]]</span><br><span class="line">Output: [null,0,9,4,2,null,5]</span><br><span class="line">Explanation:</span><br><span class="line">ExamRoom(10) -&gt; null</span><br><span class="line">seat() -&gt; 0, no one is in the room, then the student sits at seat number 0.</span><br><span class="line">seat() -&gt; 9, the student sits at the last seat number 9.</span><br><span class="line">seat() -&gt; 4, the student sits at the last seat number 4.</span><br><span class="line">seat() -&gt; 2, the student sits at the last seat number 2.</span><br><span class="line">leave(4) -&gt; null</span><br><span class="line">seat() -&gt; 5, the student sits at the last seat number 5.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 10^9</li>
<li>ExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases.</li>
<li>Calls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p.</li>
</ul>
<p>有个考场，每个考生入座的时候都要尽可能的跟左右两边的人距离保持最大，当最大距离相同的时候，考生坐在座位编号较小的那个位置。对于墙的处理跟之前那道是一样的，能靠墙就尽量靠墙，这样肯定离别人最远。</p>
<p>最先想的方法是用一个大小为N的数组来表示所有的座位，初始化为0，表示没有一个人，若有人入座了，则将该位置变为1，离开则变为0，那么对于 leave() 函数就十分简单了，直接将对应位置改为0即可。重点就是 seat() 函数了，采用双指针来做，主要就是找连续的0进行处理，还是要分 start 是否为0的情况，因为空位从墙的位置开始，跟空位在两人之间的处理情况是不同的，若空位从墙开始，肯定是坐墙边，而若是在两人之间，则需要坐在最中间，还要记得更新 start 为下一个空座位。最后在处理末尾空位连到墙的时候，跟之前稍有些不同，因为题目要求当最大距离相同的时候，需要选择座位号小的位置，而当此时 start 为0的时候，说明所有的位置都是空的，那么我们不需要再更新 idx 了，就用其初始值0，表示就坐在第一个位置，是符合题意的。最后别忘了将 idx 位置赋值为1，表示有人坐了。</p>
<p>那么比较直接的改进方法就是去掉那些0，我们只保存有人坐的位置，即所有1的位置。这样省去了遍历0的时间，大大提高了效率，此时我们就可以使用 TreeSet 来保存1的位置，其余部分并不怎么需要改变，在确定了座位 idx 时，将其加入 TreeSet 中。在 leave() 中，直接移除离开人的座位位置即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExamRoom</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ExamRoom</span>(<span class="type">int</span> N) &#123;</span><br><span class="line">        n = N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">seat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, pos = <span class="number">0</span>, left = <span class="number">-1</span>, dist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist &lt; i - start) &#123;</span><br><span class="line">                    dist = i - start;</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist &lt; (i - start + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">                    dist = (i - start + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    pos = start + dist - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (start &gt; <span class="number">0</span> &amp;&amp; dist &lt; n - start)</span><br><span class="line">            pos = n<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        s.<span class="built_in">insert</span>(pos);</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">leave</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">erase</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode856-Score-of-Parentheses"><a href="#Leetcode856-Score-of-Parentheses" class="headerlink" title="Leetcode856. Score of Parentheses"></a>Leetcode856. Score of Parentheses</h1><p>Given a balanced parentheses string <code>S</code>, compute the score of the string based on the following rule:</p>
<ul>
<li><code>()</code> has score 1</li>
<li><code>AB</code> has score A + B, where A and B are balanced parentheses strings.</li>
<li><code>(A)</code> has score 2 * A, where A is a balanced parentheses string.</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(())&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()()&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()(()))&quot;</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>S is a balanced parentheses string, containing only ( and ).</li>
<li>2 &lt;= S.length &lt;= 50</li>
</ul>
<p>这道题给了我们一个只有括号的字符串，一个简单的括号值1分，并排的括号是分值是相加的关系，包含的括号是乘的关系，每包含一层，都要乘以个2。题目中给的例子很好的说明了题意，博主最先尝试的方法是递归来做，思路是先找出每一个最外层的括号，再对其中间的整体部分调用递归，比如对于 “()(())” 来说，第一个最外边的括号是 “()”，其中间为空，对空串调用递归返回0，但是结果 res 还是加1，这个特殊的处理后面会讲到。第二个最外边的括号是 “(())” 的外层括号，对其中间的 “()” 调用递归，返回1，再乘以2，则得到 “(())” 的值，然后把二者相加，就是最终需要的结果了。找部分合法的括号字符串的方法就是使用一个计数器，遇到左括号，计数器自增1，反之右括号计数器自减1，那么当计数器为0的时候，就是一个合法的字符串了，我们对除去最外层的括号的中间内容调用递归，然后把返回值乘以2，并和1比较，取二者间的较大值加到结果 res 中，这是因为假如中间是空串，那么返回值是0，乘以2还是0，但是 “()” 的分值应该是1，所以累加的时候要跟1做比较。之后记得要更新i都正确的位置，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">scoreOfParentheses</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">    	<span class="type">int</span> res = <span class="number">0</span>, n = S.<span class="built_in">size</span>();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    		<span class="keyword">if</span> (S[i] == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="type">int</span> pos = i + <span class="number">1</span>, cnt = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (cnt != <span class="number">0</span>) &#123;</span><br><span class="line">    			(S[pos++] == <span class="string">&#x27;(&#x27;</span>) ? ++cnt : --cnt;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="type">int</span> cur = <span class="built_in">scoreOfParentheses</span>(S.<span class="built_in">substr</span>(i + <span class="number">1</span>, pos - i - <span class="number">2</span>));</span><br><span class="line">    		res += <span class="built_in">max</span>(<span class="number">2</span> * cur, <span class="number">1</span>);</span><br><span class="line">    		i = pos - <span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以使用迭代来做，这里就要借助栈 stack 来做，因为递归在调用的时候，其实也是将当前状态压入栈中，等递归退出后再从栈中取出之前的状态。这里的实现思路是，遍历字符串S，当遇到左括号时，将当前的分数压入栈中，并把当前得分清0，若遇到的是右括号，说明此时已经形成了一个完整的合法的括号字符串了，而且除去外层的括号，内层的得分已经算出来了，就是当前的结果 res，此时就要乘以2，并且要跟1比较，取二者中的较大值，这样操作的原因已经在上面解法的讲解中解释过了。然后还要加上栈顶的值，因为栈顶的值是之前合法括号子串的值，跟当前的是并列关系，所以是相加的操作，最后不要忘了要将栈顶元素移除即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">scoreOfParentheses</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(res);</span><br><span class="line">                res = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = st.<span class="built_in">top</span>() + <span class="built_in">max</span>(res * <span class="number">2</span>, <span class="number">1</span>); </span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们可以对空间复杂度进行进一步的优化，并不需要使用栈去保留所有的中间情况，可以只用一个变量 cnt 来记录当前在第几层括号之中，因为本题的括号累加值是有规律的，”()” 是1，因为最中间的括号在0层括号内，2^0 = 1。”(())” 是2，因为最中间的括号在1层括号内，2^1 = 2。”((()))” 是4，因为最中间的括号在2层括号内，2^2 = 4。因此类推，其实只需要统计出最中间那个括号外变有几个括号，就可以直接算出整个多重包含的括号字符串的值，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">scoreOfParentheses</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>, n = S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            (S[i] == <span class="string">&#x27;(&#x27;</span>) ? ++cnt : --cnt;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; S[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) res += (<span class="number">1</span> &lt;&lt; cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode858-Mirror-Reflection"><a href="#Leetcode858-Mirror-Reflection" class="headerlink" title="Leetcode858. Mirror Reflection"></a>Leetcode858. Mirror Reflection</h1><p>There is a special square room with mirrors on each of the four walls.  Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2.</p>
<p>The square room has walls of length p, and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor.</p>
<p>Return the number of the receptor that the ray meets first.  (It is guaranteed that the ray will meet a receptor eventually.)<br><img src="/img/20200526000300.png" alt=""></p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: p = 2, q = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.</span><br></pre></td></tr></table></figure></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>存在一个方形空间，如上图所示，一束光从左下角射出，方形空间的四条边都会反射，在0,1,2处存在3个接收器，问，给定方形空间的边长 p 和第一次到达右边界时距离0号接收器的距离，这束光最终会落到哪个接收器上？</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先对于给定的p,q，如果我们把这两个数都同时放大N倍，光线的走法结果不会改变，因此，首先要找p,q得最大公约数，使得p,q互质；<br>然后，当p,q互质时，不可能两个都是偶数，因此分情况，当p为偶数，q为奇数时，光线会一直走右边界的奇数坐标（1,3,5,7….）,然后再走左边的偶数坐标，因此最终必定会走到左边界，即2号接收器；若p为奇数，q为偶数，那么光线射到右边界时是偶数坐标，射到左边界时也是偶数坐标，而由于边长p是奇数，因此最终是不会走到左边界或右边界，即不会到接收器1和2，而是经过1,2之间的边界进行反向，然后往下走，而下面只有接收器0，因此最终必定会走到0；若p是奇数，且q也是奇数，那么光线到右边界时是奇数坐标，到左边界时是偶数坐标，因此最终一定走到接收器1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            temp = m % n;</span><br><span class="line">            m = n;</span><br><span class="line">            n = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mirrorReflection</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="built_in">gcd</span>(p, q);</span><br><span class="line">        p = p / temp;</span><br><span class="line">        q = q / temp;</span><br><span class="line">        <span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">		    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span>(q%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">		    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">		    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode859-Buddy-Strings"><a href="#Leetcode859-Buddy-Strings" class="headerlink" title="Leetcode859. Buddy Strings"></a>Leetcode859. Buddy Strings</h1><p>Given two strings A and B of lowercase letters, return true if and only if we can swap two letters in A so that the result equals B.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;ab&quot;, B = &quot;ba&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;ab&quot;, B = &quot;ab&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;aa&quot;, B = &quot;aa&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;aaaaaaabc&quot;, B = &quot;aaaaaaacb&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 5:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;&quot;, B = &quot;aa&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>0 &lt;= A.length &lt;= 20000</li>
<li>0 &lt;= B.length &lt;= 20000</li>
<li>A and B consist only of lowercase letters.</li>
</ol>
<ul>
<li>如果两个字符串长度不相等，则返回 false。</li>
<li>如果两个字符串有超过两处位置，其对应字符不一致，返回 false。</li>
<li>如果仅有两处位置字符不相同，则分别判断这两处位置交换后是否相同。</li>
<li>如果仅有一处位置字符不相同，则返回 false。</li>
<li>如果没有位置字符不相同，则根据题意，我们不得不找到两处位置交换。如果字符串中有两处位置字符相同，则返回 true；否则返回 false。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">buddyStrings</span><span class="params">(string A, string B)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lengtha = A.<span class="built_in">length</span>(), lengthb = B.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(lengtha != lengthb)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> flag1 = <span class="number">-1</span>, flag2 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lengtha; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] != B[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag1 != <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag2 != <span class="number">-1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        flag2 = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    flag1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag1 == <span class="number">-1</span> &amp;&amp; flag2 == <span class="number">-1</span>) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; aa = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lengtha; i ++) &#123;</span><br><span class="line">                aa[A[i] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">                <span class="keyword">if</span>(aa[A[i] - <span class="string">&#x27;a&#x27;</span>] &gt;= <span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(A[flag1] != B[flag2] || A[flag2] != B[flag1])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag1 != <span class="number">-1</span> &amp;&amp; flag2 == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode860-Lemonade-Change"><a href="#Leetcode860-Lemonade-Change" class="headerlink" title="Leetcode860. Lemonade Change"></a>Leetcode860. Lemonade Change</h1><p>At a lemonade stand, each lemonade costs $5. </p>
<p>Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills).</p>
<p>Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.</p>
<p>Note that you don’t have any change in hand at first.</p>
<p>Return true if and only if you can provide every customer with correct change.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,5,10,20]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Explanation: </p>
<ul>
<li>From the first 3 customers, we collect three $5 bills in order.</li>
<li>From the fourth customer, we collect a $10 bill and give back a $5.</li>
<li>From the fifth customer, we give a $10 bill and a $5 bill.</li>
<li>Since all customers got correct change, we output true.</li>
</ul>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,10]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,10]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,10,10,20]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Explanation: </p>
<ul>
<li>From the first two customers in order, we collect two $5 bills.</li>
<li>For the next two customers in order, we collect a $10 bill and give back a $5 bill.</li>
<li>For the last customer, we can’t give change of $15 back because we only have two $10 bills.</li>
<li>Since not every customer received correct change, the answer is false.</li>
</ul>
<p>Note:</p>
<ol>
<li>0 &lt;= bills.length &lt;= 10000</li>
<li>bills[i] will be either 5, 10, or 20.</li>
</ol>
<p>题目大意:卖lemon，5块钱一个，现在有3种面值的钞票分别为10，20，5，开始的时候没有找零的钱，问能否让每个人都有找零。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = bills.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> cnt5 = <span class="number">0</span>, cnt10 = <span class="number">0</span>, cnt20 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bills[i] == <span class="number">5</span>)</span><br><span class="line">                cnt5 ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bills[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt5 &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt5 --;</span><br><span class="line">                    cnt10 ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bills[i] == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt10 &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt5&lt;<span class="number">3</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        cnt5 -= <span class="number">3</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt5 &lt; <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    cnt5 --;</span><br><span class="line">                    cnt10 --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode861-Score-After-Flipping-Matrix"><a href="#Leetcode861-Score-After-Flipping-Matrix" class="headerlink" title="Leetcode861. Score After Flipping Matrix"></a>Leetcode861. Score After Flipping Matrix</h1><p>We have a two dimensional matrix A where each value is 0 or 1.</p>
<p>A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s.</p>
<p>After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.</p>
<p>Return the highest possible score.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]</span><br><span class="line">Output: 39</span><br><span class="line">Explanation:</span><br><span class="line">Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].</span><br><span class="line">0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= A.length &lt;= 20<br>1 &lt;= A[0].length &lt;= 20<br>A[i][j] is 0 or 1.</p>
<p>思路：对一个只有0和1的二维矩阵，移动是指选择任一行或任一列，将所有的0变成1，所有的1变成0，在作出任意次数的移动后，将该矩阵中的每一行都按照二进制数来解释，输出和的最大值。要注意的是行和列任意次移动，达到最大值。即以求出最优解为目标（可重复移动）。按二进制数来解释，注意数组[0-n]对应二进制“高位-低位”。</p>
<p>首先对行移动求最优解：二进制数，高位的有效值“1”大于后面所有位数之和，举个例子：10000=16   01010=10   00111=7。所以我们需要判断A[i]<a href="每行首元素">0</a>是否为“1”，将为“0”的进行移动操作，本行即达到最优。重复每行即为所有行最优</p>
<p>再对列移动求最优解：本题为矩阵，所以同一列的数字在二进制解释中位于相同的位置（2^n），当一列中”1”的数量最大时,结果值最大。即为列最优解，同理求出所有列最优解。</p>
<p>最后计算矩阵的总和，注意从低位（数组尾部开始计算）。</p>
<ol>
<li>若行最高位（数组行首元素）不为“1”，移动行。</li>
<li>若列“0”数量多于“1”，移动列。</li>
<li>从低位（行数组尾部）开始计算数组行值。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">matrixScore</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)</span><br><span class="line">            <span class="keyword">if</span>(A[i][<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;A[i].<span class="built_in">size</span>();j++)</span><br><span class="line">                    A[i][j]=<span class="number">1</span>-A[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;A[<span class="number">0</span>].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="type">int</span> zero=<span class="number">0</span>,one=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i][j]==<span class="number">0</span>)</span><br><span class="line">                    zero++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    one++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(zero&gt;one)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)</span><br><span class="line">                    A[i][j]=<span class="number">1</span>-A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp = <span class="number">0</span>,in=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=A[i].<span class="built_in">size</span>()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                temp+=A[i][j]*in;</span><br><span class="line">                in*=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>附上Solution：</p>
<p>Notice that a 1 in the i’th column from the right, contributes 2^i to the score.</p>
<p>Say we are finished toggling the rows in some configuration. Then for each column, (to maximize the score), we’ll toggle the column if it would increase the number of 1s.</p>
<p>We can brute force over every possible way to toggle rows.</p>
<p>Say the matrix has R rows and C columns.</p>
<p>For each state, the transition <code>trans = state ^ (state-1)</code> represents the rows that must be toggled to get into the state of toggled rows represented by (the bits of) state.</p>
<p>We’ll toggle them, and also maintain the correct column sums of the matrix on the side.</p>
<p>Afterwards, we’ll calculate the score. If for example the last column has a column sum of 3, then the score is max(3, R-3), where R-3 represents the score we get from toggling the last column.</p>
<p>In general, the score is increased by max(col_sum, R - col_sum) * (1 &lt;&lt; (C-1-c)), where the factor (1 &lt;&lt; (C-1-c)) is the power of 2 that each 1 contributes.</p>
<p>Note that this approach may not run in the time allotted.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">matrixScore</span><span class="params">(<span class="type">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> R = A.length, C = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] colsums = <span class="keyword">new</span> <span class="type">int</span>[C];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; R; ++r)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; C; ++c)</span><br><span class="line">                colsums[c] += A[r][c];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> state = <span class="number">0</span>; state &lt; (<span class="number">1</span>&lt;&lt;R); ++state) &#123;</span><br><span class="line">            <span class="comment">// Toggle the rows so that after, &#x27;state&#x27; represents</span></span><br><span class="line">            <span class="comment">// the toggled rows.</span></span><br><span class="line">            <span class="keyword">if</span> (state &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> trans = state ^ (state<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; R; ++r) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((trans &gt;&gt; r) &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; C; ++c) &#123;</span><br><span class="line">                            colsums[c] += A[r][c] == <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">                            A[r][c] ^= <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Calculate the score with the rows toggled by &#x27;state&#x27;</span></span><br><span class="line">            <span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; C; ++c)</span><br><span class="line">                score += Math.<span class="built_in">max</span>(colsums[c], R - colsums[c]) * (<span class="number">1</span> &lt;&lt; (C<span class="number">-1</span>-c));</span><br><span class="line">            ans = Math.<span class="built_in">max</span>(ans, score);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode863-All-Nodes-Distance-K-in-Binary-Tree"><a href="#Leetcode863-All-Nodes-Distance-K-in-Binary-Tree" class="headerlink" title="Leetcode863. All Nodes Distance K in Binary Tree"></a>Leetcode863. All Nodes Distance K in Binary Tree</h1><p>Given the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node.</p>
<p>You can return the answer in any order.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2</span><br><span class="line">Output: [7,4,1]</span><br><span class="line">Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.</span><br></pre></td></tr></table></figure><br><img src="/img/20210921184300.png" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1], target = 1, k = 3</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一棵二叉树，一个目标结点 target，还有一个整数K，让返回所有跟目标结点 target 相距K的结点。我们知道在子树中寻找距离为K的结点很容易，因为只需要一层一层的向下遍历即可，难点就在于符合题意的结点有可能是祖先结点，或者是在旁边的兄弟子树中，这就比较麻烦了，因为二叉树只有从父结点到子结点的路径，反过来就不行。既然没有，我们就手动创建这样的反向连接即可，这样树的遍历问题就转为了图的遍历（其实树也是一种特殊的图）。建立反向连接就是用一个 HashMap 来来建立每个结点和其父结点之间的映射，使用先序遍历建立好所有的反向连接，然后再开始查找和目标结点距离K的所有结点，这里需要一个 HashSet 来记录所有已经访问过了的结点。</p>
<p>在递归函数中，首先判断当前结点是否已经访问过，是的话直接返回，否则就加入到 visited 中。再判断此时K是否为0，是的话说明当前结点已经是距离目标结点为K的点了，将其加入结果 res 中，然后直接返回。否则分别对当前结点的左右子结点调用递归函数，注意此时带入 K-1，这两步是对子树进行查找。之前说了，还得对父结点，以及兄弟子树进行查找，这是就体现出建立的反向连接 HashMap 的作用了，若当前结点的父结点存在，我们也要对其父结点调用递归函数，并同样带入 K-1，这样就能正确的找到所有满足题意的点了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distanceK</span><span class="params">(TreeNode* root, TreeNode* target, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        unordered_map&lt;TreeNode*, TreeNode*&gt; parents;</span><br><span class="line">        unordered_set&lt;TreeNode*&gt; visited;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">build_parent</span>(root, parents);</span><br><span class="line">        <span class="built_in">find_res</span>(target, k, visited, parents, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find_res</span><span class="params">(TreeNode* root, <span class="type">int</span> k, unordered_set&lt;TreeNode*&gt; visited, unordered_map&lt;TreeNode*, TreeNode*&gt; parents, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.<span class="built_in">count</span>(root))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        visited.<span class="built_in">insert</span>(root);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) <span class="built_in">find_res</span>(root-&gt;left, k<span class="number">-1</span>, visited, parents, res);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) <span class="built_in">find_res</span>(root-&gt;right, k<span class="number">-1</span>, visited, parents, res);</span><br><span class="line">        <span class="keyword">if</span> (parents[root]) <span class="built_in">find_res</span>(parents[root], k<span class="number">-1</span>, visited, parents,res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build_parent</span><span class="params">(TreeNode* root, unordered_map&lt;TreeNode*, TreeNode*&gt;&amp; parents)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) parents[root-&gt;left] = root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) parents[root-&gt;right] = root;</span><br><span class="line">        <span class="built_in">build_parent</span>(root-&gt;left, parents);</span><br><span class="line">        <span class="built_in">build_parent</span>(root-&gt;right, parents);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>既然是图的遍历，那就也可以使用 BFS 来做，为了方便起见，我们直接建立一个邻接链表，即每个结点最多有三个跟其相连的结点，左右子结点和父结点，使用一个 HashMap 来建立每个结点和其相邻的结点数组之间的映射，这样就几乎完全将其当作图来对待了，建立好邻接链表之后，原来的树的结构都不需要用了。既然是 BFS 进行层序遍历，就要使用队列 queue，还要一个 HashSet 来记录访问过的结点。在 while 循环中，若K为0了，说明当前这层的结点都是符合题意的，就把当前队列中所有的结点加入结果 res，并返回即可。否则就进行层序遍历，取出当前层的每个结点，并在邻接链表中找到和其相邻的结点，若没有访问过，就加入 visited 和 queue 中即可。记得每层遍历完成之后，K要自减1，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distanceK</span><span class="params">(TreeNode* root, TreeNode* target, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        unordered_map&lt;TreeNode*, vector&lt;TreeNode*&gt;&gt; m;</span><br><span class="line">        queue&lt;TreeNode*&gt; q&#123;&#123;target&#125;&#125;;</span><br><span class="line">        unordered_set&lt;TreeNode*&gt; visited&#123;&#123;target&#125;&#125;;</span><br><span class="line">        <span class="built_in">findParent</span>(root, <span class="literal">NULL</span>, m);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">        		<span class="keyword">for</span> (<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        			res.<span class="built_in">push_back</span>(q.<span class="built_in">front</span>()-&gt;val); q.<span class="built_in">pop</span>();</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">return</span> res;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">for</span> (<span class="type">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        		TreeNode *t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        		<span class="keyword">for</span> (TreeNode *node : m[t]) &#123;</span><br><span class="line">        			<span class="keyword">if</span> (visited.<span class="built_in">count</span>(node)) <span class="keyword">continue</span>;</span><br><span class="line">        			visited.<span class="built_in">insert</span>(node);</span><br><span class="line">        			q.<span class="built_in">push</span>(node);</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	--K;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findParent</span><span class="params">(TreeNode* node, TreeNode* pre, unordered_map&lt;TreeNode*, vector&lt;TreeNode*&gt;&gt;&amp; m)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    	<span class="keyword">if</span> (m.<span class="built_in">count</span>(node)) <span class="keyword">return</span>;</span><br><span class="line">    	<span class="keyword">if</span> (pre) &#123;</span><br><span class="line">    		m[node].<span class="built_in">push_back</span>(pre);</span><br><span class="line">    		m[pre].<span class="built_in">push_back</span>(node);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">findParent</span>(node-&gt;left, node, m);</span><br><span class="line">    	<span class="built_in">findParent</span>(node-&gt;right, node, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其实这道题也可以不用 HashMap，不建立邻接链表，直接在递归中完成所有的需求，真正体现了递归的博大精深。在进行递归之前，我们要先判断一个 corner case，那就是当 K==0 时，此时要返回的就是目标结点值本身，可以直接返回。否则就要进行递归了。这里的递归函数跟之前的有所不同，是需要返回值的，这个返回值表示的含义比较复杂，若为0，表示当前结点为空或者当前结点就是距离目标结点为K的点，此时返回值为0，是为了进行剪枝，使得不用对其左右子结点再次进行递归。当目标结点正好是当前结点的时候，递归函数返回值为1，其他的返回值为当前结点离目标结点的距离加1。还需要一个参数 dist，其含义为离目标结点的距离，注意和递归的返回值区别，这里不用加1，且其为0时候不是为了剪枝，而是真不知道离目标结点的距离。</p>
<p>在递归函数中，首先判断若当前结点为空，则直接返回0。然后判断 dist 是否为k，是的话，说目标结点距离当前结点的距离为K，是符合题意的，需要加入结果 res 中，并返回0，注意这里返回0是为了剪枝。否则判断，若当前结点正好就是目标结点，或者已经遍历过了目标结点（表现为 dist 大于0），那么对左右子树分别调用递归函数，并将返回值分别存入 left 和 right 两个变量中。注意此时应带入 dist+1，因为是先序遍历，若目标结点之前被遍历到了，那么说明目标结点肯定不在当前结点的子树中，当前要往子树遍历的话，肯定离目标结点又远了一些，需要加1。若当前结点不是目标结点，也还没见到目标结点时，同样也需要对左右子结点调用递归函数，但此时 dist 不加1，因为不确定目标结点的位置。若 left 或者 right 值等于K，则说明目标结点在子树中，且距离当前结点为K（为啥呢？因为目标结点本身是返回1，所以当左右子结点返回K时，和当前结点距离是K）。接下来判断，若当前结点是目标结点，直接返回1，这个前面解释过了。然后再看 left 和 right 的值是否大于0，若 left 值大于0，说明目标结点在左子树中，我们此时就要对右子结点再调用一次递归，并且 dist 带入 left+1，同理，若 right 值大于0，说明目标结点在右子树中，我们此时就要对左子结点再调用一次递归，并且 dist 带入 right+1。这两步很重要，是之所以能不建立邻接链表的关键所在。若 left 大于0，则返回 left+1，若 right 大于0，则返回 right+1，否则就返回0，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distanceK</span><span class="params">(TreeNode* root, TreeNode* target, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span>) <span class="keyword">return</span> &#123;target-&gt;val&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">helper</span>(root, target, K, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(TreeNode* node, TreeNode* target, <span class="type">int</span> k, <span class="type">int</span> dist, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span> (dist == k) &#123;res.<span class="built_in">push_back</span>(node-&gt;val); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    	<span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span> (node-&gt;val == target-&gt;val || dist &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    		left = <span class="built_in">helper</span>(node-&gt;left, target, k, dist + <span class="number">1</span>, res);</span><br><span class="line">    		right = <span class="built_in">helper</span>(node-&gt;right, target, k, dist + <span class="number">1</span>, res);</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		left = <span class="built_in">helper</span>(node-&gt;left, target, k, dist, res);</span><br><span class="line">    		right = <span class="built_in">helper</span>(node-&gt;right, target, k, dist, res);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (left == k || right == k) &#123;res.<span class="built_in">push_back</span>(node-&gt;val); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    	<span class="keyword">if</span> (node-&gt;val == target-&gt;val) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span> (left &gt; <span class="number">0</span>) <span class="built_in">helper</span>(node-&gt;right, target, k, left + <span class="number">1</span>, res);</span><br><span class="line">    	<span class="keyword">if</span> (right &gt; <span class="number">0</span>) <span class="built_in">helper</span>(node-&gt;left, target, k, right + <span class="number">1</span>, res);</span><br><span class="line">    	<span class="keyword">if</span> (left &gt; <span class="number">0</span> || right &gt; <span class="number">0</span>) <span class="keyword">return</span> left &gt; <span class="number">0</span> ? left + <span class="number">1</span> : right + <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode865-Smallest-Subtree-with-all-the-Deepest-Nodes"><a href="#Leetcode865-Smallest-Subtree-with-all-the-Deepest-Nodes" class="headerlink" title="Leetcode865. Smallest Subtree with all the Deepest Nodes"></a>Leetcode865. Smallest Subtree with all the Deepest Nodes</h1><p>Given the root of a binary tree, the depth of each node is the shortest distance to the root.</p>
<p>Return the smallest subtree such that it contains all the deepest nodes in the original tree.</p>
<p>A node is called the deepest if it has the largest depth possible among any node in the entire tree.</p>
<p>The subtree of a node is tree consisting of that node, plus the set of all descendants of that node.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4]</span><br><span class="line">Output: [2,7,4]</span><br><span class="line">Explanation: We return the node with value 2, colored in yellow in the diagram.</span><br><span class="line">The nodes coloured in blue are the deepest nodes of the tree.</span><br><span class="line">Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.</span><br></pre></td></tr></table></figure><br><img src="/img/20210921184301.png" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The root is the deepest node in the tree.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [0,1,3,null,2]</span><br><span class="line">Output: [2]</span><br><span class="line">Explanation: The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.</span><br></pre></td></tr></table></figure></p>
<p>题目的意思是：给定一个根为 root 的二叉树，每个结点的深度是它到根的最短距离。如果一个结点在整个树的任意结点之间具有最大的深度，则该结点是最深的。一个结点的子树是该结点加上它的所有后代的集合。<br>返回能满足“以该结点为根的子树中包含所有最深的结点”这一条件的具有最大深度的结点。</p>
<p>二叉树一般就是递归，思路很直接，代码很简洁，用到pair把深度和root回传。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">subtreeWithAllDeepest</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(root).second;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, TreeNode*&gt; <span class="title">solve</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="number">0</span>, root);</span><br><span class="line">        pair&lt;<span class="type">int</span>, TreeNode*&gt; left = <span class="built_in">solve</span>(root-&gt;left);</span><br><span class="line">        pair&lt;<span class="type">int</span>, TreeNode*&gt; right = <span class="built_in">solve</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (left.first == right.first) <span class="keyword">return</span> <span class="built_in">make_pair</span>(left.first<span class="number">+1</span>, root);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left.first &gt; right.first) <span class="keyword">return</span> <span class="built_in">make_pair</span>(left.first<span class="number">+1</span>, left.second);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">make_pair</span>(right.first<span class="number">+1</span>, right.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode867-Transpose-Matrix"><a href="#Leetcode867-Transpose-Matrix" class="headerlink" title="Leetcode867. Transpose Matrix"></a>Leetcode867. Transpose Matrix</h1><p>Given a matrix A, return the transpose of A.</p>
<p>The transpose of a matrix is the matrix flipped over it’s main diagonal, switching the row and column indices of the matrix.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6]]</span><br><span class="line">Output: [[1,4],[2,5],[3,6]]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>1 &lt;= A.length &lt;= 1000</li>
<li>1 &lt;= A[0].length &lt;= 1000</li>
</ol>
<p>Easy题目，矩阵转置基本操作，i,j下标对调<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">transpose</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; A) &#123;</span><br><span class="line">        <span class="type">int</span> m = A.<span class="built_in">size</span>(), n = A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">result</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                result[j][i] = A[i][j];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode868-Binary-Gap"><a href="#Leetcode868-Binary-Gap" class="headerlink" title="Leetcode868. Binary Gap"></a>Leetcode868. Binary Gap</h1><p>Given a positive integer N, find and return the longest distance between two consecutive 1’s in the binary representation of N.</p>
<p>If there aren’t two consecutive 1’s, return 0.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: 22</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">22 in binary is 0b10110.</span><br><span class="line">In the binary representation of 22, there are three ones, and two consecutive pairs of 1&#x27;s.</span><br><span class="line">The first consecutive pair of 1&#x27;s have distance 2.</span><br><span class="line">The second consecutive pair of 1&#x27;s have distance 1.</span><br><span class="line">The answer is the largest of these two distances, which is 2.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">5 in binary is 0b101.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">6 in binary is 0b110.</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: </span><br><span class="line">8 in binary is 0b1000.</span><br><span class="line">There aren&#x27;t any consecutive pairs of 1&#x27;s in the binary representation of 8, so we return 0.</span><br></pre></td></tr></table></figure><br>找到一个数的二进制表示中最远的两个1的距离。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">binaryGap</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, prev = <span class="number">-1</span>, cur = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(N) &#123;</span><br><span class="line">            <span class="type">int</span> temp = N &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="number">1</span>) &#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = count;</span><br><span class="line">                <span class="keyword">if</span>(prev != <span class="number">-1</span> &amp;&amp; cur != <span class="number">-1</span>) </span><br><span class="line">                    res = <span class="built_in">max</span>(res, cur - prev);</span><br><span class="line">            &#125;</span><br><span class="line">            count ++;</span><br><span class="line">            N = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="LeetCode869-Reordered-Power-of-2"><a href="#LeetCode869-Reordered-Power-of-2" class="headerlink" title="LeetCode869. Reordered Power of 2"></a>LeetCode869. Reordered Power of 2</h1><p>Starting with a positive integer <code>N</code>, we reorder the digits in any order (including the original order) such that the leading digit is not zero.<br>Return true if and only if we can do this in a way such that the resulting number is a power of 2.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 24</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 46</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 10^9</li>
</ul>
<p>这道题说是给了我们一个正整数N，让对各位上的数字进行重新排序，但是要保证最高位上不是0，问能否变为2的指数。刚开始的时候博主理解错了，以为是对N的二进制数的各位进行重排序，但除了2的指数本身，其他数字怎么也组不成2的指数啊，因为2的指数的二进制数只有最高位是1，其余都是0。后来才发现，是让对N的十进制数的各位上的数字进行重排序，比如 N=46，那么换个位置，变成 64，就是2的指数了。搞清了题意后，就可以开始解题了，由于N给定了范围，在 [1, 1e9] 之间，所以其调换位数能组成的二进制数也是有范围的，为 [2^0, 2^30] 之间，这样的话，一个比较直接的解法就是，现将整数N转为字符串，然后对字符串进行排序。然后遍历所有可能的2的指数，将每个2的指数也转为字符串并排序，这样只要某个排序后的字符串跟之前由N生成的字符串相等的话，则表明整数N是符合题意的，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        string str = <span class="built_in">to_string</span>(N);</span><br><span class="line">        <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; ++i) &#123;</span><br><span class="line">            string t = <span class="built_in">to_string</span>(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            <span class="built_in">sort</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span> (t == str) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面这种方法没有将数字转为字符串并排序，而是使用了另一种比较巧妙的方法来实现类似的功能，是通过对N的每位上的数字都变为10的倍数，并相加，这样相当于将N的各位的上的数字都加码到了10的指数空间，而对于所有的2的指数，进行相同的操作，只要某个加码后的数字跟之前整数N的处理后的数字相同，则说明N是符合题意的。需要注意的是，为了防止整型移除，加码后的数字用长整型来表示即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> sum = <span class="built_in">helper</span>(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">helper</span>(<span class="number">1</span> &lt;&lt; i) == sum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">helper</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; N; N /= <span class="number">10</span>) res += <span class="built_in">pow</span>(<span class="number">10</span>, N % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode870-Advantage-Shuffle"><a href="#Leetcode870-Advantage-Shuffle" class="headerlink" title="Leetcode870. Advantage Shuffle"></a>Leetcode870. Advantage Shuffle</h1><p>Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] &gt; B[i].</p>
<p>Return any permutation of A that maximizes its advantage with respect to B.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,7,11,15], B = [1,10,4,11]</span><br><span class="line">Output: [2,11,7,15]</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [12,24,8,32], B = [13,25,32,11]</span><br><span class="line">Output: [24,32,8,12]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length = B.length &lt;= 10000</li>
<li>0 &lt;= A[i] &lt;= 10^9</li>
<li>0 &lt;= B[i] &lt;= 10^9</li>
</ul>
<p>这道题给了我们两个数组A和B，让对A进行重排序，使得每个对应对位置上A中的数字尽可能的大于B。这不就是大名鼎鼎的田忌赛马么，但想出高招并不是田忌，而是孙膑，就是孙子兵法的作者，但这 credit 好像都给了田忌，让人误以为是田忌的智慧，不禁想起了高富帅重金买科研成果的冠名权的故事。孙子原话是，“今以君之下驷与彼上驷，取君上驷与彼中驷，取君中驷与彼下驷”。就是自己的下马跟人上马比，稳输不用管，上马跟其中马跑，稳赢，中马跟其下马跑，还是稳赢。那我还全马跟其半马跑，能赢否？不过说的，今天博主所在的城市还真有马拉松比赛，而且博主还报了半马，但是由于身不由己的原因无法去跑，实在是可惜，没事，来日方长，总是有机会的。扯了这么久的犊子，赶紧拉回来做题吧。其实这道题的思路还真是田忌赛马的智慧一样，既然要想办法大过B中的数，那么对于B中的每个数（可以看作每匹马），先在A中找刚好大于该数的数字（这就是为啥中马跟其下马比，而不是上马跟其下马比），用太大的数字就浪费了，而如果A中没有比之大的数字，就用A中最小的数字（用下马跟其上马比，不过略有不同的是此时我们没有上马）。就用这种贪婪算法的思路就可以成功解题了，为了方便起见，就是用一个 MultiSet 来做，相当于一个允许重复的 TreeSet，既允许重复又自带排序功能，岂不美哉！那么遍历B中每个数字，在A进行二分搜索第一个大于的数字，这里使用了 STL 自带的 upper_bound 来做，当然想自己写二分也没问题。然后看，若不存在，则将A中最小的数字加到结果 res 中，否则就将第一个大于的数字加入结果 res 中，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">advantageCount</span><span class="params">(vector&amp; A, vector&amp; B)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="function">multiset&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(A.begin(), A.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; B.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = (*st.<span class="built_in">rbegin</span>() &lt;= B[i]) ? st.<span class="built_in">begin</span>() : st.<span class="built_in">upper_bound</span>(B[i]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(*it);</span><br><span class="line">            st.<span class="built_in">erase</span>(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当两个数组都是有序的时候，我们就能快速的直到各自的最大值与最小值，问题就变得容易很多了。比如可以先从B的最大值开始，这是就看A的最大值能否大过B，能的话，就移动到对应位置，不能的话就用最小值，然后再看B的次大值，这样双指针就可以解决问题。所以可以先给A按从小到大的顺序，对于B的话，不能直接排序，因为这样的话原来的顺序就完全丢失了，所以将B中每个数字和其原始坐标位置组成一个 pair 对儿，加入到一个最大堆中，这样B中的最大值就会最先被取出来，再进行上述的操作，这时候就可以发现保存的原始坐标就发挥用处了，根据其坐标就可以直接更新结果 res 中对应的位置了，参见代码如下：<br>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector <span class="title">advantageCount</span><span class="params">(vector&amp; A, vector&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = A.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>());</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            q.<span class="built_in">push</span>(&#123;B[i], i&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> val = q.<span class="built_in">top</span>().first, idx = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (A[right] &gt; val) res[idx] = A[right--];</span><br><span class="line">            <span class="keyword">else</span> res[idx] = A[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode871-Minimum-Number-of-Refueling-Stops"><a href="#Leetcode871-Minimum-Number-of-Refueling-Stops" class="headerlink" title="Leetcode871. Minimum Number of Refueling Stops"></a>Leetcode871. Minimum Number of Refueling Stops</h1><p>A car travels from a starting position to a destination which is target miles east of the starting position.</p>
<p>Along the way, there are gas stations.  Each station[i] represents a gas station that is station[i][0] miles east of the starting position, and has station[i][1] liters of gas.</p>
<p>The car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it.  It uses 1 liter of gas per 1 mile that it drives.</p>
<p>When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.</p>
<p>What is the least number of refueling stops the car must make in order to reach its destination?  If it cannot reach the destination, return -1.</p>
<p>Note that if the car reaches a gas station with 0 fuel left, the car can still refuel there.  If the car reaches the destination with 0 fuel left, it is still considered to have arrived.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 1, startFuel = 1, stations = []</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: We can reach the target without refueling.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 100, startFuel = 1, stations = [[10,100]]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: We can&#x27;t reach the target (or even the first gas station).</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">We start with 10 liters of fuel.</span><br><span class="line">We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.</span><br><span class="line">Then, we drive from position 10 to position 60 (expending 50 liters of fuel),</span><br><span class="line">and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.</span><br><span class="line">We made 2 refueling stops along the way, so we return 2.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= target, startFuel, stations[i][1] &lt;= 10^9</li>
<li>0 &lt;= stations.length &lt;= 500</li>
<li>0 &lt; stations[0][0] &lt; stations[1][0] &lt; … &lt; stations[stations.length-1][0] &lt; target</li>
</ul>
<p>这道题说有一辆小车，需要向东行驶 target 的距离，路上有许多加油站，每个加油站有两个信息，一个是距离起点的距离，另一个是可以加的油量，问我们到达 target 位置最少需要加的油量。我们可以从第三个例子来分析，开始时有 10 升油，可以到达第一个加油站，此时花掉了 10 升，但是可以补充 60 升，当前的油可以到达其他所有的加油站，由于已经开了 10 迈，所以到达后面的加油站的距离分别为 10，20，和 50。若我们到最后一个加油站，那离起始位置就有 60 迈了，再加上此加油站提供的 40 升油，直接就可以到达 100 位置，不用再加油了，所以总共只需要加2次油。由此可以看出来其实我们希望到达尽可能远的加油站的位置，同时最好该加油站中的油也比较多，这样下一次就能到达更远的位置。像这种求极值的问题，十有八九要用动态规划 Dynamic Programming 来做，但是这道题的 dp 定义式并不是直接来定义需要的最少加油站的个数，那样定义的话不太好推导出状态转移方程。正确的定义应该是根据加油次数能到达的最远距离，我们就用一个一维的 dp 数组，其中 dp[i] 表示加了i次油能到达的最远距离，那么最后只要找第一个i值使得 dp[i] 大于等于 target 即可。dp 数组的大小初始化为加油站的个数加1，值均初始化为 startFuel 即可，因为初始的油量能到达的距离是确定的。现在来推导状态转移方程了，遍历每一个加油站，对于每个遍历到的加油站k，需要再次遍历其之前的所有的加油站i，能到达当前加油站k的条件是当前的 dp[i] 值大于等于加油站k距起点的距离，若大于等于的话，我们可以更新 dp[i+1] 为 dp[i]+stations[k][1]，这样就可以得到最远能到达的距离。当 dp 数组更新完成后，需要再遍历一遍，找到第一个大于等于 target 的 dp[i] 值，并返回i即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minRefuelStops</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> startFuel, vector&lt;vector&gt;&amp; stations)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = stations.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, startFuel)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &gt;= <span class="number">0</span> &amp;&amp; dp[i] &gt;= stations[k][<span class="number">0</span>]; --i) &#123;</span><br><span class="line">            dp[i + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>], dp[i] + stations[k][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt;= target) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这道题还有一个标签是 Heap，说明还可以用堆来做，这里是用最大堆。因为之前也分析了，我们关心的是在最小的加油次数下能达到的最远距离，那么每个加油站的油量就是关键因素，可以将所有能到达的加油站根据油量的多少放入最大堆，这样每一次都选择油量最多的加油站去加油，才能尽可能的到达最远的地方（如果骄傲没被现实大海冷冷拍下，又怎会懂得要多努力，才走得到远方。。。打住打住，要唱起来了 ^o^）。这里需要一个变量i来记录当前遍历到的加油站的位置，外层循环的终止条件是 startFuel 小于 target，然后在内部也进行循环，若当前加油站的距离小于等于 startFuel，说明可以到达，则把该加油站油量存入最大堆，这个 while 循环的作用就是把所有当前能到达的加油站的油量都加到最大堆中。这样取出的堆顶元素就是最大的油量，也是我们下一步需要去的地方（最想要去的地方，怎么能在半路就返航？！），假如此时堆为空，则直接返回 -1，表示无法到达 target。否则就把堆顶元素加到 startFuel 上，此时的startFuel 就表示当前能到的最远距离，是不是跟上面的 DP 解法核心思想很类似。由于每次只能去一个加油站，此时结果 res 也自增1，当 startFuel 到达 target 时，结果 res 就是最小的加油次数，参见代码如下：<br>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minRefuelStops</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> startFuel, vector&lt;vector&gt;&amp; stations)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, n = stations.<span class="built_in">size</span>();</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">    <span class="keyword">for</span> (; startFuel &lt; target; ++res) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; stations[i][<span class="number">0</span>] &lt;= startFuel) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(stations[i++][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pq.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        startFuel += pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode872-Leaf-Similar-Trees"><a href="#Leetcode872-Leaf-Similar-Trees" class="headerlink" title="Leetcode872. Leaf-Similar Trees"></a>Leetcode872. Leaf-Similar Trees</h1><p>Consider all the leaves of a binary tree.  From left to right order, the values of those leaves form a leaf value sequence.</p>
<p>For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.</p>
<p>题目并不是很难，只不过利用dfs的方法对树进行遍历，并利用vector对叶子节点进行记录，最后再比较两个得到的vector是否相同就可以得到结果了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">leafSimilar</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v1, v2;</span><br><span class="line">        <span class="built_in">dfs</span>(root1, v1);</span><br><span class="line">        <span class="built_in">dfs</span>(root2, v2);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">issim</span>(v1, v2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">issim</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v1, vector&lt;<span class="type">int</span>&gt; v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v<span class="number">1.</span><span class="built_in">size</span>() != v<span class="number">2.</span><span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v<span class="number">1.</span><span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v1[i] != v2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, v);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode873-Length-of-Longest-Fibonacci-Subsequence"><a href="#Leetcode873-Length-of-Longest-Fibonacci-Subsequence" class="headerlink" title="Leetcode873. Length of Longest Fibonacci Subsequence"></a>Leetcode873. Length of Longest Fibonacci Subsequence</h1><p>A sequence x1, x2, …, xn is Fibonacci-like if:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n &gt;= 3</span><br><span class="line">xi + xi+1 == xi+2 for all i + 2 &lt;= n</span><br></pre></td></tr></table></figure></p>
<p>Given a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.</p>
<p>A subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,2,3,4,5,6,7,8]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,3,7,11,12,14,18]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].</span><br></pre></td></tr></table></figure></p>
<p>这道题的 DP 定义式也是难点之一，一般来说，对于子数组子序列的问题，我们都会使用一个二维的 dp 数组，其中<code>dp[i][j]</code>表示范围 [i, j] 内的极值，但是在这道题不行，就算你知道了子区间 [i, j] 内的最长斐波那契数列的长度，还是无法更新其他区间。再回过头来看一下斐波那契数列的定义，从第三个数开始，每个数都是前两个数之和，所以若想增加数列的长度，这个条件一定要一直保持，比如对于数组 [1, 2, 3, 4, 7]，在子序列 [1, 2, 3] 中以3结尾的斐氏数列长度为3，虽然 [3, 4, 7] 也可以组成斐氏数列，但是以7结尾的斐氏数列长度更新的时候不能用以3结尾的斐氏数列长度的信息，因为 [1, 2, 3, 4, 7] 不是一个正确的斐氏数列，虽然 1+2=3, 3+4=7，但是 2+3!=4。所以每次只能增加一个长度，而且必须要知道前两个数字，正确的<code>dp[i][j]</code>应该是表示以<code>A[i]</code>和<code>A[j]</code>结尾的斐氏数列的长度。</p>
<p>接下来看该怎么更新 dp 数组，我们还是要确定两个数字，跟之前的解法不同的是，先确定一个数字，然后遍历之前比其小的所有数字，这样<code>A[i]</code>和<code>A[j]</code>两个数字确定了，此时要找一个比<code>A[i]</code>和<code>A[j]</code>都小的数，即<code>A[i]-A[j]</code>，若这个数字存在的话，说明斐氏数列存在，因为<code>[A[i]-A[j], A[j], A[i]]</code>是满足斐氏数列要求的。这样状态转移就有了，<code>dp[j][i] = dp[indexOf(A[i]-A[j])][j] + 1</code>，可能看的比较晕，但其实就是<code>A[i]</code>加到了以<code>A[j]</code>和<code>A[i]-A[j]</code>结尾的斐氏数列的后面，使得长度增加了1。不过前提是<code>A[i]-A[j]</code>必须要在原数组中存在，而且还需要知道某个数字在原数组中的坐标，那么就用 HashMap 来建立数字跟其坐标之间的映射。可以事先把所有数字都存在 HashMap 中，也可以在遍历i的时候建立，因为我们只关心位置i之前的数字。这样在算出<code>A[i]-A[j]</code>之后，在 HashMap 查找差值是否存在，不存在的话赋值为 -1。在更新<code>dp[j][i]</code>的时候，我们看<code>A[i]-A[j] &lt; A[j]</code>且 k&gt;=0 是否成立，因为<code>A[i]-A[j]</code>是斐氏数列中最小的数，且其位置k必须要存在才能更新。否则的话更新为2。最后还是要注意，若 res 小于3的时候，要返回0，因为斐波那契数列的最低消费是3个，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = arr.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(len, <span class="number">0</span>));</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">            m[arr[i]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] - arr[j] &lt; arr[j] &amp;&amp; m.<span class="built_in">count</span>(arr[i]-arr[j]))</span><br><span class="line">                        dp[j][i] = dp[m[arr[i]-arr[j]]][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j][i] = <span class="number">2</span>;</span><br><span class="line">                res = <span class="built_in">max</span>(res, dp[j][i]);        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res &gt; <span class="number">2</span> ? res : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode874-Walking-Robot-Simulation"><a href="#Leetcode874-Walking-Robot-Simulation" class="headerlink" title="Leetcode874. Walking Robot Simulation"></a>Leetcode874. Walking Robot Simulation</h1><p>A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:</p>
<ul>
<li>-2: turn left 90 degrees</li>
<li>-1: turn right 90 degrees</li>
<li>1 &lt;= x &lt;= 9: move forward x units</li>
<li>Some of the grid squares are obstacles. </li>
</ul>
<p>The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1])</p>
<p>If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)</p>
<p>Return the square of the maximum Euclidean distance that the robot will be from the origin.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: commands = [4,-1,3], obstacles = []</span><br><span class="line">Output: 25</span><br><span class="line">Explanation: robot will go to (3, 4)</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]</span><br><span class="line">Output: 65</span><br><span class="line">Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>0 &lt;= commands.length &lt;= 10000</li>
<li>0 &lt;= obstacles.length &lt;= 10000</li>
<li>-30000 &lt;= obstacle[i][0] &lt;= 30000</li>
<li>-30000 &lt;= obstacle[i][1] &lt;= 30000</li>
<li>The answer is guaranteed to be less than 2 ^ 31.</li>
</ol>
<p>把障碍存在一个set里，方便以后查找判断。每次计算目前最大的x^2 + y^2，用一个大小为2的数组来表示X、Y坐标，之后只需要用axis=0来表示X，axis=1来表示Y即可，不需要知道到底是哪个轴。在进行移动的时候，每次只走一格，计算max_square。值得注意的是，max_square的初始值为0，因为如果被障碍遮挡或者根本没有移动指令导致原地不动的情况下，最大值是0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">robotSim</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; commands, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacles)</span> </span>&#123;</span><br><span class="line">        set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; obs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; obstacles.<span class="built_in">size</span>(); i++)</span><br><span class="line">            obs.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(obstacles[i][<span class="number">0</span>], obstacles[i][<span class="number">1</span>]));</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> coord[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, dir = <span class="number">1</span>; <span class="comment">// x-y coordinate 0: x, 1: y, 2: -x, 3: -y</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; commands.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(commands[i] == <span class="number">-2</span>) </span><br><span class="line">                dir = (dir<span class="number">+1</span>) % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(commands[i] == <span class="number">-1</span>) </span><br><span class="line">                dir = (dir<span class="number">+3</span>) % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> axis, forward;</span><br><span class="line">                <span class="keyword">switch</span>(dir)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        axis = <span class="number">0</span>;  forward = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        axis = <span class="number">1</span>;  forward = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        axis = <span class="number">0</span>;  forward = <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        axis = <span class="number">1</span>;  forward = <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">0</span>; m &lt; commands[i]; m ++) &#123;</span><br><span class="line">                    coord[axis] += forward;</span><br><span class="line">                    <span class="keyword">if</span>(obs.<span class="built_in">find</span>(<span class="built_in">make_pair</span>(coord[<span class="number">0</span>], coord[<span class="number">1</span>])) != obs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                        coord[axis] -= forward;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result = <span class="built_in">max</span>(result, coord[<span class="number">0</span>]*coord[<span class="number">0</span>] + coord[<span class="number">1</span>]*coord[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode875-Koko-Eating-Bananas"><a href="#Leetcode875-Koko-Eating-Bananas" class="headerlink" title="Leetcode875. Koko Eating Bananas"></a>Leetcode875. Koko Eating Bananas</h1><p>Koko loves to eat bananas.  There are <code>N</code> piles of bananas, the <code>i</code>-th pile has <code>piles[i]</code> bananas.  The guards have gone and will come back in <code>H</code> hours.<br>Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won’t eat any more bananas during this hour.</p>
<p>Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.</p>
<p>Return the minimum integer K such that she can eat all the bananas within Hhours.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [3,6,7,11], H = 8</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [30,11,23,4,20], H = 5</span><br><span class="line">Output: 30</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [30,11,23,4,20], H = 6</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= piles.length &lt;= 10^4</li>
<li>piles.length &lt;= H &lt;= 10^9</li>
<li>1 &lt;= piles[i] &lt;= 10^9</li>
</ul>
<p>这道题说有一只叫科科的猩猩，非常的喜欢吃香蕉，现在有N堆香蕉，每堆的个数可能不同，科科有H小时的时间来吃。要求是，每个小时内，科科只能选某一堆香蕉开始吃，若科科的吃速固定为K，即便在一小时内科科已经吃完了该堆的香蕉，也不能换堆，直到下一个小时才可以去另一堆吃。为了健康，科科想尽可能的吃慢一些，但同时也想在H小时内吃完所有的N堆香蕉，让我们找出一个最小的吃速K值。那么首先来想，既然每个小时只能吃一堆，总共要在H小时内吃完N堆，那么H一定要大于等于N，不然一定没法吃完N堆，这个条件题目中给了，所以就不用再 check 了。我们想一下K的可能的取值范围，当H无穷大的时候，科科有充足的时间去吃，那么就可以每小时只吃一根，也可以吃完，所以K的最小取值是1。那么当H最小，等于N时，那么一个小时内必须吃完任意一堆，那么K值就应该是香蕉最多的那一堆的个数，题目中限定了不超过 1e9，这就是最大值。所以要求的K值的范围就是 [1, 1e9]，固定的范围内查找数字，当然，最暴力的方法就是一个一个的试，凭博主多年与 OJ 抗衡的经验来说，基本可以不用考虑的。那么二分查找法就是不二之选了，我们知道经典的二分查找法，是要求数组有序的，而这里香蕉个数数组又不一定是有序的。这是一个很好的观察，但是要弄清楚到底是什么应该是有序的，要查找的K是吃速，跟香蕉堆的个数并没有直接的关系，而K所在的数组其实应该是 [1, 1e9] 这个数组，其本身就是有序的，所以二分查找没有问题。当求出了 mid 之后，需要统计用该速度吃完所有的香蕉堆所需要的时间，统计的方法就是遍历每堆的香蕉个数，然后算吃完该堆要的时间。比如 K=4，那么假如有3个香蕉，需要1个小时，有4香蕉，还是1个小时，有5个香蕉，就需要两个小时，如果将三种情况融合为一个式子呢，就是用吃速加上香蕉个数减去1，再除以吃速即可，即 (pile+mid-1)/mid，大家可以自行带数字检验，是没有问题的。算出需要的总时间后去跟H比较，若小于H，说明吃的速度慢了，需要加快速度，所以 left 更新为 mid+1，否则 right 更新为 mid，最后返回 right 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>, right = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>, cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> pile : piles) cnt += (pile + mid - <span class="number">1</span>) / mid;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; H) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode876-Middle-of-the-Linked-List"><a href="#Leetcode876-Middle-of-the-Linked-List" class="headerlink" title="Leetcode876. Middle of the Linked List"></a>Leetcode876. Middle of the Linked List</h1><p>Given a non-empty, singly linked list with head node head, return a middle node of linked list.</p>
<p>If there are two middle nodes, return the second middle node.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: Node 3 from this list (Serialization: [3,4,5])</span><br><span class="line">The returned node has value 3.  (The judge&#x27;s serialization of this node is [3,4,5]).</span><br><span class="line">Note that we returned a ListNode object ans, such that:</span><br><span class="line">ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6]</span><br><span class="line">Output: Node 4 from this list (Serialization: [4,5,6])</span><br><span class="line">Since the list has two middle nodes with values 3 and 4, we return the second one.</span><br></pre></td></tr></table></figure><br>Note: The number of nodes in the given list will be between 1 and 100.</p>
<p>题目大意：求链表的中间节点。思路：构造两个节点，遍历链接，一个每次走一步，另一个每次走两步，一个遍历完链表，另一个恰好在中间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = head, *pp = head;</span><br><span class="line">        <span class="keyword">while</span>(pp != <span class="literal">NULL</span> &amp;&amp; pp-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pp = pp-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>久仰大名的快慢指针做法，但是这里有坑，一定要注意while里的判断条件是两个，保证在有奇数个数和偶数个数的链表都不会访问空指针。</p>
<h1 id="Leetcode877-Stone-Game"><a href="#Leetcode877-Stone-Game" class="headerlink" title="Leetcode877. Stone Game"></a>Leetcode877. Stone Game</h1><p>Alex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].</p>
<p>The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties.</p>
<p>Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins.</p>
<p>Assuming Alex and Lee play optimally, return True if and only if Alex wins the game.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,3,4,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">Alex starts first, and can only take the first 5 or the last 5.</span><br><span class="line">Say he takes the first 5, so that the row becomes [3, 4, 5].</span><br><span class="line">If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.</span><br><span class="line">If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.</span><br><span class="line">This demonstrated that taking the first 5 was a winning move for Alex, so we return true.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>2 &lt;= piles.length &lt;= 500</li>
<li>piles.length is even.</li>
<li>1 &lt;= piles[i] &lt;= 500</li>
<li>sum(piles) is odd.</li>
</ul>
<p>这道题说是有偶数堆的石子，每堆的石子个数可能不同，但石子总数是奇数个。现在 Alex 和 Lee （不应该是 Alice 和 Bob 么？？）两个人轮流选石子堆，规则是每次只能选开头和末尾中的一堆，最终获得石子总数多的人获胜。若 Alex 先选，两个人都会一直做最优选择，问我们最终 Alex 是否能获胜。博主最先想到的方法是像 Predict the Winner 中的那样，用个 player 变量来记录当前是哪个玩家在操作，若为0，表示 Alex 在选，那么他只有两种选择，要么拿首堆，要么拿尾堆，两种情况分别调用递归，两个递归函数只要有一个能返回 true，则表示 Alex 可以获胜，还需要用个变量 cur0 来记录当前 Alex 的石子总数。同理，若 Lee 在选，即 player 为1的时候，也是只有两种选择，分别调用递归，两个递归函数只要有一个能返回 true，则表示 Lee 可以获胜，用 cur1 来记录当前 Lee 的石子总数。需要注意的是，当首堆或尾堆被选走了后，我们需要标记，这里就有两种方法，一种是从原 piles 中删除选走的堆（或者是新建一个不包含选走堆的数组），但是这种方法会包括大量的拷贝运算，无法通过 OJ。另一种方法是用两个指针 left 和 right，分别指向首尾的位置。当选取了首堆时，则 left 自增1，若选了尾堆时，则 right 自减1。这样就不用执行删除操作，或是拷贝数组了，大大的提高了运行效率，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(piles, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, (<span class="type">int</span>)piles.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>);     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles, <span class="type">int</span> cur0, <span class="type">int</span> cur1, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> cur0 &gt; cur1;</span><br><span class="line">        <span class="keyword">if</span> (player == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">helper</span>(piles, cur0 + piles[left], cur1, left + <span class="number">1</span>, right, <span class="number">1</span>) || <span class="built_in">helper</span>(piles, cur0 + piles[right], cur1, left + <span class="number">1</span>, right, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">helper</span>(piles, cur0, cur1 + piles[left], left, right - <span class="number">1</span>, <span class="number">0</span>) || <span class="built_in">helper</span>(piles, cur0, cur1 + piles[right], left, right - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这道题也可以使用动态规划 Dynamic Programming 来做，由于玩家获胜的规则是拿到的石子数多，那么多的石子数就可以量化为 dp 值。所以我们用一个二维数组，其中<code>dp[i][j]</code>表示在区间<code>[i, j]</code>内 Alex 比 Lee 多拿的石子数，若为正数，说明 Alex 拿得多，若为负数，则表示 Lee 拿得多。则最终只要看<code>dp[0][n-1]</code>的值，若为正数，则 Alex 能获胜。现在就要找状态转移方程了，我们想，在区间<code>[i, j]</code>内要计算 Alex 比 Lee 多拿的石子数，在这个区间内，Alex 只能拿i或者j位置上的石子，那么当 Alex 拿了<code>piles[i]</code>的话，等于 Alex 多了<code>piles[i]</code>个石子，此时区间缩小成了<code>[i+1, j]</code>，此时应该 Lee 拿了，此时根据我们以往的 DP 经验，应该调用子区间的 dp 值，没错，但这里<code>dp[i+1][j]</code>表示是在区间<code>[i+1, j]</code>内 Alex 多拿的石子数，但是若区间<code>[i+1, j]</code>内 Lee 先拿的话，其多拿的石子数也应该是<code>dp[i+1][j]</code>，因为两个人都要最优化拿，那么<code>dp[i][j]</code>的值其实可以被<code>piles[i] - dp[i+1][j]</code>更新，因为 Alex 拿了<code>piles[i]</code>，减去 Lee 多出的<code>dp[i+1][j]</code>，就是区间<code>[i, j]</code>中 Alex 多拿的石子数。同理，假如 Alex 先拿<code>piles[j]</code>，那么就用<code>piles[j] - dp[i][j-1]</code>来更新<code>dp[i][j]</code>，则我们用二者的较大值来更新即可。注意开始的时候要把<code>dp[i][i]</code>都初始化为<code>piles[i]</code>，还需要注意的是，这里的更新顺序很重要，是从小区间开始更新<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = piles.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) dp[i][i] = piles[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt; n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - len; ++i) &#123;</span><br><span class="line">                <span class="type">int</span> j = i + len;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(piles[i] - dp[i + <span class="number">1</span>][j], piles[j] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>] &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其实这道题是一道脑筋急转弯题，跟之前那道 Nim Game 有些像。原因就在于题目中的一个条件，那就是总共有偶数堆，那么就是可以分为堆数相等的两堆，比如我们按奇偶分为两堆。题目还说了石子总数为奇数个，那么分出的这两堆的石子总数一定是不相等的，那么我们只要每次一直取石子总数多的奇数堆或者偶数堆，Alex 就一定可以躺赢，所以最叼的方法就是直接返回 true。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">stoneGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode881-Boats-to-Save-People"><a href="#Leetcode881-Boats-to-Save-People" class="headerlink" title="Leetcode881. Boats to Save People"></a>Leetcode881. Boats to Save People</h1><p>You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.</p>
<p>Return the minimum number of boats to carry every given person.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: people = [1,2], limit = 3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 1 boat (1, 2)</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: people = [3,2,2,1], limit = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 3 boats (1, 2), (2) and (3)</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: people = [3,5,3,4], limit = 5</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: 4 boats (3), (3), (4), (5)</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们载人过河，说是每个人的体重不同，每条船承重有个限度 limit（限定了这个载重大于等于最重人的体重），同时要求每条船不能超过两人，问我们将所有人载到对岸最少需要多少条船。从题目中的例子2可以看出，最肥的人有可能一人占一条船，当然如果船的载量够大的话，可能还能挤上一个瘦子，那么最瘦的人是最可能挤上去的，所以策略就是胖子加瘦子的上船组合。那么这就是典型的贪婪算法的适用场景啊，首先要给所有人按体重排个序，从瘦子到胖子，这样我们才能快速的知道当前最重和最轻的人。然后使用双指针，left 指向最瘦的人，right 指向最胖的人，当 left 小于等于 right 的时候，进行 while 循环。在循环中，胖子是一定要上船的，所以 right 自减1是肯定有的，但是还是要看能否再带上一个瘦子，能的话 left 自增1。然后结果 res 一定要自增1，因为每次都要用一条船，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numRescueBoats</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; people, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = people.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (people[left] + people[right] &gt; limit)</span><br><span class="line">                right --;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right --;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode883-Projection-Area-of-3D-Shapes"><a href="#Leetcode883-Projection-Area-of-3D-Shapes" class="headerlink" title="Leetcode883. Projection Area of 3D Shapes"></a>Leetcode883. Projection Area of 3D Shapes</h1><p>On a N <em> N grid, we place some 1 </em> 1 * 1 cubes that are axis-aligned with the x, y, and z axes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Now we view the projection of these cubes onto the xy, yz, and zx planes. A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane. </p>
<p>Here, we are viewing the “shadow” when looking at the cubes from the top, the front, and the side. Return the total area of all three projections.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2]]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure><br>Example 2:<br><img src="/img/20190825104.png" alt=""><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2],[3,4]]</span><br><span class="line">Output: 17</span><br><span class="line">Explanation: </span><br><span class="line">Here are the three projections (&quot;shadows&quot;) of the shape made with each axis-aligned plane.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0],[0,2]]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: 14</span><br></pre></td></tr></table></figure><br>Example 5:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure><br>Note:</p>
<ul>
<li>1 &lt;= grid.length = grid[0].length &lt;= 50</li>
<li>0 &lt;= grid[i][j] &lt;= 50</li>
</ul>
<p>投影题，之前做过类似的，从上往下看的数量是不为零的格子数，从左往右看和从右往左看是每行（或列）最高的，求和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">projectionArea</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> y = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; y; j ++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] != <span class="number">0</span>)</span><br><span class="line">                    res ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; i ++)&#123;</span><br><span class="line">            max = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; y; j ++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] &gt; max)</span><br><span class="line">                    max = grid[i][j];</span><br><span class="line">            res += max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; y; i ++)&#123;</span><br><span class="line">            max = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; x; j ++)</span><br><span class="line">                <span class="keyword">if</span>(grid[j][i] &gt; max)</span><br><span class="line">                    max = grid[j][i];</span><br><span class="line">            res += max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">projectionArea</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> N = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N;  ++i) &#123;</span><br><span class="line">            <span class="type">int</span> bestRow = <span class="number">0</span>;  <span class="comment">// largest of grid[i][j]</span></span><br><span class="line">            <span class="type">int</span> bestCol = <span class="number">0</span>;  <span class="comment">// largest of grid[j][i]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] &gt; <span class="number">0</span>) ans++;  <span class="comment">// top shadow</span></span><br><span class="line">                bestRow = <span class="built_in">max</span>(bestRow, grid[i][j]);</span><br><span class="line">                bestCol = <span class="built_in">max</span>(bestCol, grid[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans += bestRow + bestCol;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode884-Uncommon-Words-from-Two-Sentences"><a href="#Leetcode884-Uncommon-Words-from-Two-Sentences" class="headerlink" title="Leetcode884. Uncommon Words from Two Sentences"></a>Leetcode884. Uncommon Words from Two Sentences</h1><p>We are given two sentences A and B.  (A sentence is a string of space separated words.  Each word consists only of lowercase letters.)</p>
<p>A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.</p>
<p>Return a list of all uncommon words. </p>
<p>You may return the list in any order.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;this apple is sweet&quot;, B = &quot;this apple is sour&quot;</span><br><span class="line">Output: [&quot;sweet&quot;,&quot;sour&quot;]</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;apple apple&quot;, B = &quot;banana&quot;</span><br><span class="line">Output: [&quot;banana&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>0 &lt;= A.length &lt;= 200</li>
<li>0 &lt;= B.length &lt;= 200</li>
<li>A and B both contain only spaces and lowercase letters.</li>
</ol>
<p>把单词合并然后找到只出现过一次的就好。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">uncommonFromSentences</span><span class="params">(string A, string B)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        map&lt;string, <span class="type">int</span>&gt; mapp;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">length</span>(); i ++) &#123;</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; A.<span class="built_in">length</span>() &amp;&amp; A[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                temp += A[i++];</span><br><span class="line">            cout&lt;&lt;temp&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(mapp.<span class="built_in">find</span>(temp) == mapp.<span class="built_in">end</span>())</span><br><span class="line">                mapp[temp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                mapp[temp] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; B.<span class="built_in">length</span>(); i ++) &#123;</span><br><span class="line">            temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; B.<span class="built_in">length</span>() &amp;&amp; B[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                temp += B[i++];</span><br><span class="line">            cout&lt;&lt;temp&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(mapp.<span class="built_in">find</span>(temp) == mapp.<span class="built_in">end</span>())</span><br><span class="line">                mapp[temp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                mapp[temp] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = mapp.<span class="built_in">begin</span>(); iter != mapp.<span class="built_in">end</span>(); iter ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;second == <span class="number">1</span>)</span><br><span class="line">                result.<span class="built_in">push_back</span>(iter-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>简洁做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">uncommonFromSentences</span><span class="params">(string A, string B)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="function">istringstream <span class="title">iss</span><span class="params">(A + <span class="string">&quot; &quot;</span> + B)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (iss &gt;&gt; A) count[A]++;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> w: count)</span><br><span class="line">            <span class="keyword">if</span> (w.second == <span class="number">1</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(w.first);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode885-Spiral-Matrix-III"><a href="#Leetcode885-Spiral-Matrix-III" class="headerlink" title="Leetcode885. Spiral Matrix III"></a>Leetcode885. Spiral Matrix III</h1><p>On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east. Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column. Now, we walk in a clockwise spiral shape to visit every position in this grid. </p>
<p>Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) Eventually, we reach all R * C spaces of the grid. Return a list of coordinates representing the positions of the grid in the order they were visited.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 1, C = 4, r0 = 0, c0 = 0</span><br><span class="line">Output: [[0,0],[0,1],[0,2],[0,3]]</span><br></pre></td></tr></table></figure><br><img src="/img/20190827001.png" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 5, C = 6, r0 = 1, c0 = 4</span><br><span class="line">Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]</span><br></pre></td></tr></table></figure><br><img src="/img/20190827002.png" alt=""></p>
<p>给定起点（r0,c0），螺旋走路，输出经过的点坐标，简单，只是注意细节。按照顺序，先向右走，再向下走，再向左走，再向上走，经观察发现每个方向的步数依次为1,1,2,2,3,3,…，依次类推，按照步骤走即可，发现不在网格内就跳过。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">spiralMatrixIII</span>(<span class="type">int</span> R, <span class="type">int</span> C, <span class="type">int</span> r0, <span class="type">int</span> c0) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;r0, c0&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; res.<span class="built_in">size</span>() &lt; R * C; i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j ++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    r0 += dir[j][<span class="number">0</span>];</span><br><span class="line">                    c0 += dir[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(<span class="number">0</span> &lt;= r0 &amp;&amp; r0 &lt; R &amp;&amp; <span class="number">0</span> &lt;= c0 &amp;&amp; c0 &lt; C)</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;r0,c0&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt; <span class="number">4</span>; j ++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i<span class="number">+1</span>; k++) &#123;</span><br><span class="line">                    r0 += dir[j][<span class="number">0</span>];</span><br><span class="line">                    c0 += dir[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(<span class="number">0</span> &lt;= r0 &amp;&amp; r0 &lt; R &amp;&amp; <span class="number">0</span> &lt;= c0 &amp;&amp; c0 &lt; C)</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;r0,c0&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个大佬给了三种做法：</p>
<p>这道题给了我们一个二维矩阵，还给了其中一个位置，让从这个位置开始螺旋打印矩阵。首先是打印给定的位置，然后向右走一位，打印出来，再向下方走一位打印，再向左边走两位打印，再向上方走三位打印，以此类推，螺旋打印。那仔细观察，可以发现，刚开始只是走一步，后来步子越来越大，若只看每个方向走的距离，可以得到如下数组 1,1,2,2,3,3… </p>
<p>步长有了，下面就是方向了，由于确定了起始是向右走，那么方向就是 右-&gt;下-&gt;左-&gt;上 这样的循环。方向和步长都分析清楚了，现在就可以尝试进行遍历了。由于最终是会遍历完所有的位置的，那么最后结果 res 里面的位置个数一定是等于 RxC 的，所以循环的条件就是当结果 res 中的位置数小于<code>R*C</code>。我们还需要一个变量 step 表示当前的步长，初始化为1。</p>
<p>在循环中，首先要向右走 step 步，一步一步走，走到一个新的位置上，要进行判断，若当前位置没有越界，才能加入结果 res 中，由于每次都要判断，所以把这部分抽取出来，放到一个子函数中。由于是向右走，每走一步之后，c0 都要自增1。右边走完了之后，再向下方走 step 步，同理，每走一步之后，要将 r0 自增1。再向左边走之前，要将步数增1，不然无法形成正确的螺旋，同理，再完成向上方走 step 步之后，step 要再增1，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">spiralMatrixIII</span>(<span class="type">int</span> R, <span class="type">int</span> C, <span class="type">int</span> r0, <span class="type">int</span> c0) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (res.<span class="built_in">size</span>() &lt; R * C) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; step; ++i) <span class="built_in">add</span>(R, C, r0, c0++, res);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; step; ++i) <span class="built_in">add</span>(R, C, r0++, c0, res);</span><br><span class="line">            ++step;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; step; ++i) <span class="built_in">add</span>(R, C, r0, c0--, res);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; step; ++i) <span class="built_in">add</span>(R, C, r0--, c0, res);</span><br><span class="line">            ++step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> R, <span class="type">int</span> C, <span class="type">int</span> x, <span class="type">int</span> y, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; R &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; C) res.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以用两个数组 dirX 和 dirY 来控制下一个方向，就像迷宫遍历中的那样，这样只需要一个变量 cur，来分别到 dirX 和 dirY 中取值，初始化为0，表示向右的方向。从螺旋遍历的机制可以看出，每当向右或者向左前进时，步长就要加1，那么我们只要判断当 cur 为0或者2的时候，step 就自增1。由于 cur 初始化为0，所以刚开始 step 就会增1，那么就可以将 step 初始化为0，同时还需要把起始位置提前加入结果 res 中。此时在 while 循环中只需要一个 for 循环即可，朝当前的 cur 方向前进 step 步，r0 加上 dirX[cur]，c0 加上 dirY[cur]，若没有越界，则加入结果 res 中即可。之后记得 cur 要自增1，为了防止越界，对4取余，就像循环数组一样的操作，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">spiralMatrixIII</span>(<span class="type">int</span> R, <span class="type">int</span> C, <span class="type">int</span> r0, <span class="type">int</span> c0) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res&#123;&#123;r0, c0&#125;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dirX&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dirY&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> step = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (res.<span class="built_in">size</span>() &lt; R * C) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span> || cur == <span class="number">2</span>) ++step;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; step; ++i) &#123;</span><br><span class="line">                r0 += dirX[cur]; c0 += dirY[cur];</span><br><span class="line">                <span class="keyword">if</span> (r0 &gt;= <span class="number">0</span> &amp;&amp; r0 &lt; R &amp;&amp; c0 &gt;= <span class="number">0</span> &amp;&amp; c0 &lt; C) res.<span class="built_in">push_back</span>(&#123;r0, c0&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = (cur + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以不使用方向数组，若仔细观察 右-&gt;下-&gt;左-&gt;上 四个方向对应的值 (0, 1) -&gt; (1, 0) -&gt; (0, -1) -&gt; (-1, 0), 实际上，下一个位置的x值是当前的y值，下一个位置的y值是当前的-x值，因为两个方向是相邻的两个方向是垂直的，由向量的叉乘得到 (x, y, 0) × (0, 0, 1) = (y, -x, 0)。所以可以通过当前的x和y值，来计算出下一个位置的值。同理，根据之前的说的步长数组 1,1,2,2,3,3…，可以推出通项公式为 n/2 + 1，这样连步长变量 step 都省了，不过需要统计当前已经遍历的位置的个数，实在想偷懒，也可以用 res.size() 来代替，参见代码如下：</p>
<p>解法三：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">spiralMatrixIII</span>(<span class="type">int</span> R, <span class="type">int</span> C, <span class="type">int</span> r0, <span class="type">int</span> c0) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res&#123;&#123;r0, c0&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; res.<span class="built_in">size</span>() &lt; R * C; ++k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k / <span class="number">2</span> + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                r0 += x; c0 += y;</span><br><span class="line">                <span class="keyword">if</span> (r0 &gt;= <span class="number">0</span> &amp;&amp; r0 &lt; R &amp;&amp; c0 &gt;= <span class="number">0</span> &amp;&amp; c0 &lt; C) res.<span class="built_in">push_back</span>(&#123;r0, c0&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            t = x; x = y; y = -t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="LeetCode886-Possible-Bipartition"><a href="#LeetCode886-Possible-Bipartition" class="headerlink" title="LeetCode886. Possible Bipartition"></a>LeetCode886. Possible Bipartition</h1><p>Given a set of N people (numbered 1, 2, …, N), we would like to split everyone into two groups of any size.</p>
<p>Each person may dislike some other people, and they should not go into the same group. </p>
<p>Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group.</p>
<p>Return true if and only if it is possible to split everyone into two groups in this way.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, dislikes = [[1,2],[1,3],[2,4]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: group1 [1,4], group2 [2,3]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, dislikes = [[1,2],[1,3],[2,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 2000</li>
<li>0 &lt;= dislikes.length &lt;= 10000</li>
<li>1 &lt;= dislikes[i][j] &lt;= N</li>
<li>dislikes[i][0] &lt; dislikes[i][1]</li>
<li>There does not exist i != j for which dislikes[i] == dislikes[j].</li>
</ul>
<p>这道题又是关于二分图的题，第一次接触的时候是 Is Graph Bipartite?，那道题给的是建好的邻接链表（虽然是用数组实现的），但是本质上和这道题是一样的，同一条边上的两点是不能在同一个集合中的，那么这就相当于本题中的 dislike 的关系，也可以把每个 dislike 看作是一条边，那么两端的两个人不能在同一个集合中。看透了题目的本质后，就不难做了，跟之前的题相比，这里唯一不同的就是邻接链表没有给我们建好，需要自己去建。不管是建邻接链表，还是邻接矩阵都行，反正是要先把图建起来才能遍历。那么这里我们先建立一个邻接矩阵好了，建一个大小为 (N+1) x (N+1) 的二维数组g，其中若 g[i][j] 为1，说明i和j互相不鸟。那么先根据 dislikes 的情况，把二维数组先赋上值，注意这里 g[i][j] 和 g[j][i] 都要更新，因为是互相不鸟，而并不是某一方热脸贴冷屁股。下面就要开始遍历了，还是使用染色法，使用一个一维的 colors 数组，大小为 N+1，初始化是0，由于只有两组，可以用1和 -1 来区分。那么开始遍历图中的结点，对于每个遍历到的结点，如果其还未被染色，还是一张白纸的时候，调用递归函数对其用颜色1进行尝试染色。在递归函数中，现将该结点染色，然后就要遍历所有跟其合不来的人，这里就发现邻接矩阵的好处了吧，不然每次还得遍历 dislikes 数组。由于这里是邻接矩阵，所以只有在其值为1的时候才处理，当找到一个跟其合不来的人，首先检测其染色情况，如果此时两个人颜色相同了，说明已经在一个组里了，这就矛盾了，直接返回 false。如果那个人还是白纸一张，我们尝试用相反的颜色去染他，如果无法成功染色，则返回 false。循环顺序退出后，返回 true，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">g</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">color</span><span class="params">(n<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dislikes.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            g[dislikes[i][<span class="number">0</span>]][dislikes[i][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            g[dislikes[i][<span class="number">1</span>]][dislikes[i][<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) </span><br><span class="line">            <span class="keyword">if</span> (color[i] == <span class="number">0</span> &amp;&amp; !<span class="built_in">helper</span>(g, i, color, <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">helper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; g, <span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; color, <span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">        color[cur] = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[cur][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (color[i] == col)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (color[i] == <span class="number">0</span> &amp;&amp; !<span class="built_in">helper</span>(g, i, color, -col))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode888-Fair-Candy-Swap"><a href="#Leetcode888-Fair-Candy-Swap" class="headerlink" title="Leetcode888. Fair Candy Swap"></a>Leetcode888. Fair Candy Swap</h1><p>Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has.</p>
<p>Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.  (The total amount of candy a person has is the sum of the sizes of candy bars they have.)</p>
<p>Return an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange.</p>
<p>If there are multiple answers, you may return any one of them.  It is guaranteed an answer exists.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,1], B = [2,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2], B = [2,3]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2], B = [1,3]</span><br><span class="line">Output: [2,3]</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,5], B = [2,4]</span><br><span class="line">Output: [5,4]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 10000</li>
<li>1 &lt;= B.length &lt;= 10000</li>
<li>1 &lt;= A[i] &lt;= 100000</li>
<li>1 &lt;= B[i] &lt;= 100000</li>
<li>It is guaranteed that Alice and Bob have different total amounts of candy.</li>
<li>It is guaranteed there exists an answer.</li>
</ul>
<p>考虑到最终两个人的糖果总量相等，那么可以计算出最终这个相等的总量是多少。</p>
<p>比如1中的例子，A的总量是8，B的总量是6，那么平均下来每个人应该是7。</p>
<p>那么接下来就要在A中找到一个元素比B中某个元素大1的，逐个对比，可以发现交换5和4就可以达成目标。</p>
<p>其中逐个对比这个部分，难道我们要做一个双重循环吗？也没有必要。</p>
<p>我们先做一个升序排序，接着就是两个指针在A中和B中不断地移动就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fairCandySwap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(),A.<span class="built_in">end</span>());<span class="comment">//升序排序</span></span><br><span class="line">    <span class="built_in">sort</span>(B.<span class="built_in">begin</span>(),B.<span class="built_in">end</span>());<span class="comment">//升序排序</span></span><br><span class="line">    <span class="type">int</span> sum1=<span class="number">0</span>,sum2=<span class="number">0</span>,sum3,cha,cha1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:A)<span class="comment">//sum1存储A中的总量</span></span><br><span class="line">        sum1+=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:B)<span class="comment">//sum2存储B中的总量</span></span><br><span class="line">        sum2+=i;</span><br><span class="line">    sum3=(sum1+sum2)/<span class="number">2</span>;<span class="comment">//sum3是平均值</span></span><br><span class="line">    cha=sum1-sum3;<span class="comment">//cha表示A和平均值之间的差，如果大于0，说明A要在B中找一个小cha这个数值的，如果小于0，同理</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;A.<span class="built_in">size</span>()&amp;&amp;j&lt;B.<span class="built_in">size</span>())<span class="comment">//i和j两个索引不断地向后走</span></span><br><span class="line">    &#123;</span><br><span class="line">        cha1=A[i]-B[j];</span><br><span class="line">        <span class="keyword">if</span>(cha1==cha)<span class="comment">//如果刚好等于，那么返回两个数值</span></span><br><span class="line">            <span class="keyword">return</span> &#123;A[i],B[j]&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cha1&lt;cha)<span class="comment">//如果小于，那么说明A[i]数值太小，应该更大一点</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//如果大于，那么说明B[j]数值太小，应该更大一点</span></span><br><span class="line">            j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal"><a href="#Leetcode889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal" class="headerlink" title="Leetcode889. Construct Binary Tree from Preorder and Postorder Traversal"></a>Leetcode889. Construct Binary Tree from Preorder and Postorder Traversal</h1><p>Return any binary tree that matches the given preorder and postorder traversals.</p>
<p>Values in the traversals pre and post are distinct positive integers.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]</span><br><span class="line">Output: [1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= pre.length == post.length &lt;= 30</li>
<li>pre[] and post[] are both permutations of 1, 2, …, pre.length.</li>
<li>It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.</li>
</ul>
<p>这道题给了一棵树的先序遍历和后序遍历的数组，让我们根据这两个数组来重建出原来的二叉树。之前也做过二叉树的先序遍历 Binary Tree Preorder Traversal 和 后序遍历 Binary Tree Postorder Traversal，所以应该对其遍历的顺序并不陌生。其实二叉树最常用的三种遍历方式，先序，中序，和后序遍历，只要知道其中的任意两种遍历得到的数组，就可以重建出原始的二叉树，而且正好都在 LeetCode 中有出现，其他两道分别是 Construct Binary Tree from Inorder and Postorder Traversal 和 Construct Binary Tree from Preorder and Inorder Traversal。如果做过之前两道题，那么这道题就没有什么难度了，若没有的话，可能还是有些 tricky 的，虽然这仅仅只是一道 Medium 的题。</p>
<p>我们知道，先序遍历的顺序是 根-&gt;左-&gt;右，而后序遍历的顺序是 左-&gt;右-&gt;根，既然要建立树，那么肯定要从根结点开始创建，然后再创建左右子结点，若你做过很多树相关的题目的话，就会知道大多数都是用递归才做，那么创建的时候也是对左右子结点调用递归来创建。心中有这么个概念就好，可以继续来找这个重复的 pattern。由于先序和后序各自的特点，根结点的位置是固定的，既是先序遍历数组的第一个，又是后序遍历数组的最后一个，而如果给我们的是中序遍历的数组，那么根结点的位置就只能从另一个先序或者后序的数组中来找了，但中序也有中序的好处，其根结点正好分割了左右子树，就不在这里细讲了，还是回到本题吧。知道了根结点的位置后，我们需要分隔左右子树的区间，先序和后序的各个区间表示如下：</p>
<ul>
<li>preorder -&gt; [root] [left subtree] [right subtree]</li>
<li>postorder -&gt; [left subtree] [right substree] [root]</li>
</ul>
<p>具体到题目中的例子就是：</p>
<ul>
<li>preorder -&gt; [1] [2,4,5] [3,6,7]</li>
<li>postorder -&gt; [4,5,2] [6,7,3] [root]</li>
</ul>
<p>先序和后序中各自的左子树区间的长度肯定是相等的，但是其数字顺序可能是不同的，但是我们仔细观察的话，可以发现先序左子树区间的第一个数字2，在后序左右子树区间的最后一个位置，而且这个规律对右子树区间同样适用，这是为啥呢，这就要回到各自遍历的顺序了，先序遍历的顺序是 根-&gt;左-&gt;右，而后序遍历的顺序是 左-&gt;右-&gt;根，其实这个2就是左子树的根结点，当然会一个在开头，一个在末尾了。发现了这个规律，就可以根据其来定位左右子树区间的位置范围了。既然要拆分数组，那么就有两种方式，一种是真的拆分成小的子数组，另一种是用双指针来指向子区间的开头和末尾。前一种方法无疑会有大量的数组拷贝，不是很高效，所以我们这里采用第二种方法来做。用 preL 和 preR 分别表示左子树区间的开头和结尾位置，postL 和 postR 表示右子树区间的开头和结尾位置，那么若 preL 大于 preR 或者 postL 大于 postR 的时候，说明已经不存在子树区间，直接返回空指针。然后要先新建当前树的根结点，就通过 pre[preL] 取到即可，接下来要找左子树的根结点在 post 中的位置，最简单的方法就是遍历 post 中的区间 [postL, postR]，找到其位置 idx，然后根据这个 idx，就可以算出左子树区间长度为 len = (idx-postL)+1，那么 pre 数组中左子树区间为 [preL+1, preL+len]，右子树区间为 [preL+1+len, preR]，同理，post 数组中左子树区间为 [postL, idx]，右子树区间为 [idx+1, postR-1]。知道了这些信息，就可以分别调用递归函数了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pre, vector&lt;<span class="type">int</span>&gt;&amp; post)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(pre, <span class="number">0</span>, (<span class="type">int</span>)pre.<span class="built_in">size</span>() - <span class="number">1</span>, post, <span class="number">0</span>, (<span class="type">int</span>)post.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pre, <span class="type">int</span> preL, <span class="type">int</span> preR, vector&lt;<span class="type">int</span>&gt;&amp; post, <span class="type">int</span> postL, <span class="type">int</span> postR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preL &gt; preR || postL &gt; postR) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pre[preL]);</span><br><span class="line">        <span class="keyword">if</span> (preL == preR) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (idx = postL; idx &lt;= postR; ++idx) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[preL + <span class="number">1</span>] == post[idx]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;left = <span class="built_in">helper</span>(pre, preL + <span class="number">1</span>, preL + <span class="number">1</span> + (idx - postL), post, postL, idx);</span><br><span class="line">        node-&gt;right = <span class="built_in">helper</span>(pre, preL + <span class="number">1</span> + (idx - postL) + <span class="number">1</span>, preR, post, idx + <span class="number">1</span>, postR - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode890-Find-and-Replace-Pattern"><a href="#Leetcode890-Find-and-Replace-Pattern" class="headerlink" title="Leetcode890. Find and Replace Pattern"></a>Leetcode890. Find and Replace Pattern</h1><p>You have a list of words and a pattern, and you want to know which words in words matches the pattern.</p>
<p>A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.</p>
<p>(Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.)</p>
<p>Return a list of the words in words that match the given pattern. </p>
<p>You may return the answer in any order.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot;</span><br><span class="line">Output: [&quot;mee&quot;,&quot;aqq&quot;]</span><br><span class="line">Explanation: &quot;mee&quot; matches the pattern because there is a permutation &#123;a -&gt; m, b -&gt; e, ...&#125;. </span><br><span class="line">&quot;ccc&quot; does not match the pattern because &#123;a -&gt; c, b -&gt; c, ...&#125; is not a permutation,</span><br><span class="line">since a and b map to the same letter.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= words.length &lt;= 50</li>
<li>1 &lt;= pattern.length = words[i].length &lt;= 20</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(string word,string pattern)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="type">bool</span> seen[<span class="number">26</span>];</span><br><span class="line">        map&lt;<span class="type">char</span>,<span class="type">char</span>&gt; table;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">char</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            seen[i]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;word.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            it = table.<span class="built_in">find</span>(word[j]);</span><br><span class="line">            <span class="keyword">if</span>(it==table.<span class="built_in">end</span>())&#123;</span><br><span class="line">                table[word[j]]=pattern[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(table[word[j]]!=pattern[j] )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            seen[i]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(it=table.<span class="built_in">begin</span>();it!=table.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seen[it-&gt;second-<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            seen[it-&gt;second-<span class="string">&#x27;a&#x27;</span>]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findAndReplacePattern</span><span class="params">(vector&lt;string&gt;&amp; words, string pattern)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">match</span>(words[i],pattern))</span><br><span class="line">                res.<span class="built_in">push_back</span>(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个题判断给定的字符串是不是符合pattern串的模式，很简单的题搞复杂了。用了一个map来匹配字符组合，用seen判断这个pattern字符是否出现过，如果出现过就是非法的了。</p>
<h1 id="Leetcode892-Surface-Area-of-3D-Shapes"><a href="#Leetcode892-Surface-Area-of-3D-Shapes" class="headerlink" title="Leetcode892. Surface Area of 3D Shapes"></a>Leetcode892. Surface Area of 3D Shapes</h1><p>On a N <em> N grid, we place some 1 </em> 1 * 1 cubes.</p>
<p>Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j).</p>
<p>Return the total surface area of the resulting shapes. </p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2]]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2],[3,4]]</span><br><span class="line">Output: 34</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0],[0,2]]</span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: 32</span><br></pre></td></tr></table></figure><br>Example 5:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">Output: 46</span><br></pre></td></tr></table></figure><br>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 50</li>
<li>0 &lt;= grid[i][j] &lt;= 50</li>
</ul>
<p>这道题给了我们一个二维数组 grid，其中 grid[i][j] 表示在位置 (i,j) 上累计的小正方体的个数，实际上就像搭积木一样，由这些小正方体来组成一个三维的物体，这里让我们求这个三维物体的表面积。我们知道每个小正方体的表面积是6，若在同一个位置累加两个，表面积就是10，三个累加到了一起就是14，其实是有规律的，n个小正方体累在一起，表面积是 4n+2。</p>
<p>现在不仅仅是累加在一个小正方体上，而是在 nxn 的区间，累加出一个三维物体。当中间的小方块缺失了之后，实际上缺失的地方会产生出四个新的面，而这四个面是应该算在表面积里的，但是用投影的方法是没法算进去的。无奈只能另辟蹊径，实际上这道题正确的思路是一个位置一个位置的累加表面积，就类似微积分的感觉，前面提到了当n个小正方体累到一起的表面积是 4n+2，而这个n就是每个位置的值 grid[i][j]，当你在旁边紧挨着再放一个累加的物体时，二者就会产生重叠，重叠的面数就是二者较矮的那堆正方体的个数再乘以2。</p>
<p>明白了这一点，我们就可以从 (0,0) 位置开始累加，先根据 grid[0][0] 的值算出若仅有该位置的三维物体的表面积，然后向 (0,1) 位置遍历，同样要先根据 grid[0][1] 的值算出若仅有该位置的三维物体的表面积，跟之前 grid[0][0] 的累加，然后再减去遮挡住的面积，通过 min(grid[0][0],grid[0][1])x2 来得到，这样每次可以计算出水平方向的遮挡面积，同时还需要减去竖直方向的遮挡面积 min(grid[i][j],grid[i-1][j])x2，这样才能算出正确的表面积.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">surfaceArea</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>  n =grid.<span class="built_in">size</span>(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; n; i ++)</span><br><span class="line">	        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">		        <span class="keyword">if</span>(grid[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res += <span class="number">4</span> * grid[i][j] + <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt; <span class="number">0</span>) res -= <span class="built_in">min</span>(grid[i][j], grid[i<span class="number">-1</span>][j]) * <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(j &gt; <span class="number">0</span>) res -= <span class="built_in">min</span>(grid[i][j], grid[i][j<span class="number">-1</span>]) * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode893-Groups-of-Special-Equivalent-Strings"><a href="#Leetcode893-Groups-of-Special-Equivalent-Strings" class="headerlink" title="Leetcode893. Groups of Special-Equivalent Strings"></a>Leetcode893. Groups of Special-Equivalent Strings</h1><p>You are given an array A of strings.</p>
<p>A move onto S consists of swapping any two even indexed characters of S, or any two odd indexed characters of S.</p>
<p>Two strings S and T are special-equivalent if after any number of moves onto S, S == T.</p>
<p>For example, S = “zzxy” and T = “xyzz” are special-equivalent because we may make the moves “zzxy” -&gt; “xzzy” -&gt; “xyzz” that swap S[0] and S[2], then S[1] and S[3].</p>
<p>Now, a group of special-equivalent strings from A is a non-empty subset of A such that:</p>
<p>Every pair of strings in the group are special equivalent, and;<br>The group is the largest size possible (ie., there isn’t a string S not in the group such that S is special equivalent to every string in the group)<br>Return the number of groups of special-equivalent strings from A.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;abcd&quot;,&quot;cdab&quot;,&quot;cbad&quot;,&quot;xyzz&quot;,&quot;zzxy&quot;,&quot;zzyx&quot;]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">One group is [&quot;abcd&quot;, &quot;cdab&quot;, &quot;cbad&quot;], since they are all pairwise special equivalent, and none of the other strings are all pairwise special equivalent to these.</span><br><span class="line"></span><br><span class="line">The other two groups are [&quot;xyzz&quot;, &quot;zzxy&quot;] and [&quot;zzyx&quot;].  Note that in particular, &quot;zzxy&quot; is not special equivalent to &quot;zzyx&quot;.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><br>对于一个字符串，假如其偶数位字符之间可以互相交换，且其奇数位字符之间可以互相交换，交换后若能跟另一个字符串相等，则这两个字符串是特殊相等的关系。现在给了我们一个字符串数组，将所有特殊相等的字符串放到一个群组中，问最终能有几个不同的群组。最开始的时候博主没仔细审题，以为是随意交换字母，就直接对每个单词进行排序，然后扔到一个 HashSet 中就行了。后来发现只能是奇偶位上互相交换，于是只能现先将奇偶位上的字母分别抽离出来，然后再进行分别排序，之后再合并起来组成一个新的字符串，再丢到 HashSet 中即可，利用 HashSet 的自动去重复功能，这样最终留下来的就是不同的群组了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSpecialEquivGroups</span><span class="params">(vector&lt;string&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (string word : A) &#123;</span><br><span class="line">            string even, odd;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); ++i) </span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) even += word[i];</span><br><span class="line">                <span class="keyword">else</span> odd += word[i];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">sort</span>(even.<span class="built_in">begin</span>(), even.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">sort</span>(odd.<span class="built_in">begin</span>(), odd.<span class="built_in">end</span>());</span><br><span class="line">            st.<span class="built_in">insert</span>(even + odd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode894-All-Possible-Full-Binary-Trees"><a href="#Leetcode894-All-Possible-Full-Binary-Trees" class="headerlink" title="Leetcode894. All Possible Full Binary Trees"></a>Leetcode894. All Possible Full Binary Trees</h1><p>A full binary tree is a binary tree where each node has exactly 0 or 2 children.</p>
<p>Return a list of all possible full binary trees with N nodes.  Each element of the answer is the root node of one possible tree.</p>
<p>Each node of each tree in the answer must have node.val = 0.</p>
<p>You may return the final list of trees in any order.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 7</span><br><span class="line">Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]</span><br></pre></td></tr></table></figure><br>Explanation:<br><img src="/img/fivetrees.png" alt=""></p>
<p>给出了个N，代表一棵二叉树有N个节点，求所能构成的树。</p>
<p>解题方法<br>所有能构成的树，并且返回的不是数目，而是真正的树。所以一定会把所有的节点都求出来。一般就使用了递归。</p>
<p>这个题中，重点是返回一个列表，也就是说每个能够成的树的根节点都要放到这个列表里。而且当左子树、右子树的节点个数固定的时候，也会出现排列组合的情况，所以使用了两重for循环来完成所有的左右子树的组合。</p>
<p>另外的一个技巧就是，左右子树的个数一定是奇数个。</p>
<p>递归方法，虽然比较慢，但是容易理解，就是组成小的子树，一个个拼接，为啥要减1，是因为一定会有个根节点，先把这个减去再说。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">allPossibleFBT</span><span class="params">(<span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        N--;</span><br><span class="line">        vector&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; left : <span class="built_in">allPossibleFBT</span>(i)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; right : <span class="built_in">allPossibleFBT</span>(N - i)) &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">                    root-&gt;left = left;</span><br><span class="line">                    root-&gt;right = right;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(root);           </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode896-Monotonic-Array"><a href="#Leetcode896-Monotonic-Array" class="headerlink" title="Leetcode896. Monotonic Array"></a>Leetcode896. Monotonic Array</h1><p>An array is monotonic if it is either monotone increasing or monotone decreasing.</p>
<p>An array A is monotone increasing if for all i &lt;= j, A[i] &lt;= A[j].  An array A is monotone decreasing if for all i &lt;= j, A[i] &gt;= A[j].</p>
<p>Return true if and only if the given array A is monotonic.</p>
<p>判断数组是否单调。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMonotonic</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> inc=<span class="literal">true</span>, dec=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>()<span class="number">-1</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[i<span class="number">+1</span>]) inc = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt; A[i<span class="number">+1</span>]) dec = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inc || dec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode897-Increasing-Order-Search-Tree"><a href="#Leetcode897-Increasing-Order-Search-Tree" class="headerlink" title="Leetcode897. Increasing Order Search Tree"></a>Leetcode897. Increasing Order Search Tree</h1><p>Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.</p>
<p>Example 1:<br>Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">    3    6</span><br><span class="line">   / \    \</span><br><span class="line">  2   4    8</span><br><span class="line"> /        / \ </span><br><span class="line">1        7   9</span><br></pre></td></tr></table></figure><br>Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br><span class="line">           \</span><br><span class="line">            7</span><br><span class="line">             \</span><br><span class="line">              8</span><br><span class="line">               \</span><br><span class="line">                9  </span><br></pre></td></tr></table></figure><br>Note:</p>
<p>The number of nodes in the given tree will be between 1 and 100.<br>Each node will have a unique integer value from 0 to 1000.</p>
<p>本题要求把二叉树的结点重新排列，使其成为从小到大只有右孩子的二叉树。考虑使用中序遍历的迭代方法，对每个结点入栈，出栈时先访问左结点，然后中结点，最后把右指针和下一个入栈的结点链接起来。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        stack&lt;TreeNode*&gt; dst;</span><br><span class="line">        TreeNode *head = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>), *pre = head;</span><br><span class="line">        <span class="keyword">while</span>(root || !dst.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                dst.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = dst.<span class="built_in">top</span>();</span><br><span class="line">            dst.<span class="built_in">pop</span>();</span><br><span class="line">            pre-&gt;right=root;</span><br><span class="line">            pre = pre -&gt; right;</span><br><span class="line">            root -&gt; left = <span class="literal">NULL</span>;</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;right;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>然后朴素的中序遍历是这样<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    TreeNode *s=<span class="literal">NULL</span>,*p=<span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">		            </span><br><span class="line">            <span class="keyword">if</span>(s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                s = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root-&gt;val); </span><br><span class="line">                p = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode* temp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root-&gt;val);</span><br><span class="line">                s-&gt;right = temp;</span><br><span class="line">                s = s-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode900-RLE-Iterator"><a href="#Leetcode900-RLE-Iterator" class="headerlink" title="Leetcode900. RLE Iterator"></a>Leetcode900. RLE Iterator</h1><p>Write an iterator that iterates through a run-length encoded sequence.</p>
<p>The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence.  More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence.</p>
<p>The iterator supports one function: next(int n), which exhausts the next n elements (n &gt;= 1) and returns the last element exhausted in this way.  If there is no element left to exhaust, next returns -1instead.</p>
<p>For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].  This is because the sequence can be read as “three eights, zero nines, two fives”.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;RLEIterator&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]</span><br><span class="line">Output: [null,8,8,5,-1]</span><br><span class="line">Explanation:</span><br><span class="line">RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).</span><br><span class="line">This maps to the sequence [8,8,8,5,5].</span><br><span class="line">RLEIterator.next is then called 4 times:</span><br><span class="line"></span><br><span class="line">.next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].</span><br><span class="line">.next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].</span><br><span class="line">.next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].</span><br><span class="line">.next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5, but the second term did not exist.  Since the last term exhausted does not exist, we return -1.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 &lt;= A.length &lt;= 1000</li>
<li>A.length is an even integer.</li>
<li>0 &lt;= A[i] &lt;= 10^9</li>
</ul>
<p>这道题给了我们一种 Run-Length Encoded 的数组，就是每两个数字组成一个数字对儿，前一个数字表示后面的一个数字重复出现的次数。然后有一个 next 函数，让我们返回数组的第n个数字，题目中给的例子也很好的说明了题意。将每个数字对儿抽离出来，放到一个新的数组中。这样我们就只要遍历这个只有数字对儿的数组，当出现次数是0的时候，直接跳过当前数字对儿。若出现次数大于等于n，那么现将次数减去n，然后再返回该数字。否则用n减去次数，并将次数赋值为0，继续遍历下一个数字对儿。若循环退出了，直接返回 -1 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RLEIterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> pointer_en, pointer_m;</span><br><span class="line">    <span class="built_in">RLEIterator</span>(vector&lt;<span class="type">int</span>&gt;&amp; encoding) &#123;</span><br><span class="line">        <span class="type">int</span> len = encoding.<span class="built_in">size</span>();</span><br><span class="line">        pointer_en = <span class="number">0</span>;</span><br><span class="line">        pointer_m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (encoding[i] &gt; <span class="number">0</span>)</span><br><span class="line">                m.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(encoding[i], encoding[i<span class="number">+1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = m.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(pointer_m &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[pointer_m].first &lt; n) &#123;</span><br><span class="line">                n -= m[pointer_m].first;</span><br><span class="line">                pointer_m ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                m[pointer_m].first -= n;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pointer_m &lt; len)</span><br><span class="line">            <span class="keyword">return</span> m[pointer_m].second;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其实我们根本不用将数字对儿抽离出来，直接用输入数组的形式就可以，再用一个指针 cur，指向当前数字对儿的次数即可。那么在 next 函数中，我们首先来个 while 循环，判读假如 cur 没有越界，且当n大于当前当次数了，则n减去当前次数，cur 自增2，移动到下一个数字对儿的次数上。当 while 循环结束后，判断若此时 cur 已经越界了，则返回 -1，否则当前次数减去n，并且返回当前数字即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RLEIterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RLEIterator</span>(vector&amp; A): <span class="built_in">nums</span>(A), <span class="built_in">cur</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; nums.<span class="built_in">size</span>() &amp;&amp; n &gt; nums[cur]) &#123;</span><br><span class="line">            n -= nums[cur];</span><br><span class="line">            cur += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nums[cur] -= n;</span><br><span class="line">        <span class="keyword">return</span> nums[cur + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">    vector nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/12/Leetcode701_800/" rel="prev" title="Leetcode701 - 800">
      <i class="fa fa-chevron-left"></i> Leetcode701 - 800
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/20/Leetcode1_100/" rel="next" title="Leetcode1 - 100">
      Leetcode1 - 100 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode802-Find-Eventual-Safe-States"><span class="nav-number">1.</span> <span class="nav-text">Leetcode802. Find Eventual Safe States</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode804-Unique-Morse-Code-Words"><span class="nav-number">2.</span> <span class="nav-text">Leetcode804. Unique Morse Code Words</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode806-Number-of-Lines-To-Write-String"><span class="nav-number">3.</span> <span class="nav-text">Leetcode806. Number of Lines To Write String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode807-Max-Increase-to-Keep-City-Skyline"><span class="nav-number">4.</span> <span class="nav-text">Leetcode807. Max Increase to Keep City Skyline</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode808-Soup-Servings"><span class="nav-number">5.</span> <span class="nav-text">Leetcode808. Soup Servings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode809-Expressive-Words"><span class="nav-number">6.</span> <span class="nav-text">Leetcode809. Expressive Words</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode811-Subdomain-Visit-Count"><span class="nav-number">7.</span> <span class="nav-text">Leetcode811. Subdomain Visit Count</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode812-Largest-Triangle-Area"><span class="nav-number">8.</span> <span class="nav-text">Leetcode812. Largest Triangle Area</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode813-Largest-Sum-of-Averages"><span class="nav-number">9.</span> <span class="nav-text">Leetcode813. Largest Sum of Averages</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode814-Binary-Tree-Pruning"><span class="nav-number">10.</span> <span class="nav-text">Leetcode814. Binary Tree Pruning</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode816-Ambiguous-Coordinates"><span class="nav-number">11.</span> <span class="nav-text">Leetcode816. Ambiguous Coordinates</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode817-Linked-List-Components"><span class="nav-number">12.</span> <span class="nav-text">Leetcode817. Linked List Components</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode819-Most-Common-Word"><span class="nav-number">13.</span> <span class="nav-text">Leetcode819. Most Common Word</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode820-Short-Encoding-of-Words"><span class="nav-number">14.</span> <span class="nav-text">Leetcode820. Short Encoding of Words</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode821-Shortest-Distance-to-a-Character"><span class="nav-number">15.</span> <span class="nav-text">Leetcode821. Shortest Distance to a Character</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode822-Card-Flipping-Game"><span class="nav-number">16.</span> <span class="nav-text">Leetcode822. Card Flipping Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode823-Binary-Trees-With-Factors"><span class="nav-number">17.</span> <span class="nav-text">Leetcode823. Binary Trees With Factors</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode824-Goat-Latin"><span class="nav-number">18.</span> <span class="nav-text">Leetcode824. Goat Latin</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode825-Friends-Of-Appropriate-Ages"><span class="nav-number">19.</span> <span class="nav-text">Leetcode825. Friends Of Appropriate Ages</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode826-Most-Profit-Assigning-Work"><span class="nav-number">20.</span> <span class="nav-text">Leetcode826. Most Profit Assigning Work</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode830-Positions-of-Large-Groups"><span class="nav-number">21.</span> <span class="nav-text">Leetcode830. Positions of Large Groups</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode831-Masking-Personal-Information"><span class="nav-number">22.</span> <span class="nav-text">Leetcode831. Masking Personal Information</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode832-Flipping-an-Image"><span class="nav-number">23.</span> <span class="nav-text">Leetcode832. Flipping an Image</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode833-Find-And-Replace-in-String"><span class="nav-number">24.</span> <span class="nav-text">Leetcode833. Find And Replace in String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode835-Image-Overlap"><span class="nav-number">25.</span> <span class="nav-text">Leetcode835. Image Overlap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode836-Rectangle-Overlap"><span class="nav-number">26.</span> <span class="nav-text">Leetcode836. Rectangle Overlap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode838-Push-Dominoes"><span class="nav-number">27.</span> <span class="nav-text">Leetcode838. Push Dominoes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode840-Magic-Squares-In-Grid"><span class="nav-number">28.</span> <span class="nav-text">Leetcode840. Magic Squares In Grid</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode841-Keys-and-Rooms"><span class="nav-number">29.</span> <span class="nav-text">Leetcode841. Keys and Rooms</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode844-Backspace-String-Compare"><span class="nav-number">30.</span> <span class="nav-text">Leetcode844. Backspace String Compare</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode845-Longest-Mountain-in-Array-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%B1%B1"><span class="nav-number">31.</span> <span class="nav-text">Leetcode845. Longest Mountain in Array 数组中最长的山</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode848-Shifting-Letters"><span class="nav-number">32.</span> <span class="nav-text">Leetcode848. Shifting Letters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode849-Maximize-Distance-to-Closest-Person"><span class="nav-number">33.</span> <span class="nav-text">Leetcode849. Maximize Distance to Closest Person</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode851-Loud-and-Rich"><span class="nav-number">34.</span> <span class="nav-text">Leetcode851. Loud and Rich</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode852-Peak-Index-in-a-Mountain-Array"><span class="nav-number">35.</span> <span class="nav-text">Leetcode852. Peak Index in a Mountain Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode853-Car-Fleet"><span class="nav-number">36.</span> <span class="nav-text">Leetcode853. Car Fleet</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode855-Exam-Room"><span class="nav-number">37.</span> <span class="nav-text">Leetcode855. Exam Room</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode856-Score-of-Parentheses"><span class="nav-number">38.</span> <span class="nav-text">Leetcode856. Score of Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode858-Mirror-Reflection"><span class="nav-number">39.</span> <span class="nav-text">Leetcode858. Mirror Reflection</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E5%A4%A7%E6%84%8F%EF%BC%9A"><span class="nav-number">39.1.</span> <span class="nav-text">题目大意：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="nav-number">39.2.</span> <span class="nav-text">解题思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode859-Buddy-Strings"><span class="nav-number">40.</span> <span class="nav-text">Leetcode859. Buddy Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode860-Lemonade-Change"><span class="nav-number">41.</span> <span class="nav-text">Leetcode860. Lemonade Change</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode861-Score-After-Flipping-Matrix"><span class="nav-number">42.</span> <span class="nav-text">Leetcode861. Score After Flipping Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode863-All-Nodes-Distance-K-in-Binary-Tree"><span class="nav-number">43.</span> <span class="nav-text">Leetcode863. All Nodes Distance K in Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode865-Smallest-Subtree-with-all-the-Deepest-Nodes"><span class="nav-number">44.</span> <span class="nav-text">Leetcode865. Smallest Subtree with all the Deepest Nodes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode867-Transpose-Matrix"><span class="nav-number">45.</span> <span class="nav-text">Leetcode867. Transpose Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode868-Binary-Gap"><span class="nav-number">46.</span> <span class="nav-text">Leetcode868. Binary Gap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode869-Reordered-Power-of-2"><span class="nav-number">47.</span> <span class="nav-text">LeetCode869. Reordered Power of 2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode870-Advantage-Shuffle"><span class="nav-number">48.</span> <span class="nav-text">Leetcode870. Advantage Shuffle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode871-Minimum-Number-of-Refueling-Stops"><span class="nav-number">49.</span> <span class="nav-text">Leetcode871. Minimum Number of Refueling Stops</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode872-Leaf-Similar-Trees"><span class="nav-number">50.</span> <span class="nav-text">Leetcode872. Leaf-Similar Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode873-Length-of-Longest-Fibonacci-Subsequence"><span class="nav-number">51.</span> <span class="nav-text">Leetcode873. Length of Longest Fibonacci Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode874-Walking-Robot-Simulation"><span class="nav-number">52.</span> <span class="nav-text">Leetcode874. Walking Robot Simulation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode875-Koko-Eating-Bananas"><span class="nav-number">53.</span> <span class="nav-text">Leetcode875. Koko Eating Bananas</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode876-Middle-of-the-Linked-List"><span class="nav-number">54.</span> <span class="nav-text">Leetcode876. Middle of the Linked List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode877-Stone-Game"><span class="nav-number">55.</span> <span class="nav-text">Leetcode877. Stone Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode881-Boats-to-Save-People"><span class="nav-number">56.</span> <span class="nav-text">Leetcode881. Boats to Save People</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode883-Projection-Area-of-3D-Shapes"><span class="nav-number">57.</span> <span class="nav-text">Leetcode883. Projection Area of 3D Shapes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode884-Uncommon-Words-from-Two-Sentences"><span class="nav-number">58.</span> <span class="nav-text">Leetcode884. Uncommon Words from Two Sentences</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode885-Spiral-Matrix-III"><span class="nav-number">59.</span> <span class="nav-text">Leetcode885. Spiral Matrix III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode886-Possible-Bipartition"><span class="nav-number">60.</span> <span class="nav-text">LeetCode886. Possible Bipartition</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode888-Fair-Candy-Swap"><span class="nav-number">61.</span> <span class="nav-text">Leetcode888. Fair Candy Swap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal"><span class="nav-number">62.</span> <span class="nav-text">Leetcode889. Construct Binary Tree from Preorder and Postorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode890-Find-and-Replace-Pattern"><span class="nav-number">63.</span> <span class="nav-text">Leetcode890. Find and Replace Pattern</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode892-Surface-Area-of-3D-Shapes"><span class="nav-number">64.</span> <span class="nav-text">Leetcode892. Surface Area of 3D Shapes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode893-Groups-of-Special-Equivalent-Strings"><span class="nav-number">65.</span> <span class="nav-text">Leetcode893. Groups of Special-Equivalent Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode894-All-Possible-Full-Binary-Trees"><span class="nav-number">66.</span> <span class="nav-text">Leetcode894. All Possible Full Binary Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode896-Monotonic-Array"><span class="nav-number">67.</span> <span class="nav-text">Leetcode896. Monotonic Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode897-Increasing-Order-Search-Tree"><span class="nav-number">68.</span> <span class="nav-text">Leetcode897. Increasing Order Search Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode900-RLE-Iterator"><span class="nav-number">69.</span> <span class="nav-text">Leetcode900. RLE Iterator</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuhao0102" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuhao0102" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuhhpc0203@gmail.com" title="E-Mail → mailto:yuhhpc0203@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
