<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zn-ch">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
<meta property="og:type" content="website">
<meta property="og:title" content="Hao Yu&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
<meta property="og:locale" content="zn_CH">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="HPC PC IA">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>Hao Yu's blog</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/08/18/modern-cpp-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/18/modern-cpp-tutorial/" itemprop="url">modern-cpp-tutorial</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-18T14:49:00+08:00">
                2022-08-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第-2-章-语言可用性的强化"><a href="#第-2-章-语言可用性的强化" class="headerlink" title="第 2 章 语言可用性的强化"></a>第 2 章 语言可用性的强化</h1><p>当我们声明、定义一个变量或者常量，对代码进行流程控制、面向对象的功能、模板编程等这些都是运行时之前，可能发生在编写代码或编译器编译代码时的行为。为此，我们通常谈及<strong>语言可用性</strong>，是指那些发生在运行时之前的语言行为。</p>
<h2 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h2><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p><code>nullptr</code> 出现的目的是为了替代 <code>NULL</code>。在某种意义上来说，传统 C++ 会把 <code>NULL</code>、<code>0</code> 视为同一种东西，这取决于编译器如何定义 <code>NULL</code>，有些编译器会将 <code>NULL</code> 定义为 <code>((void*)0)</code>，有些则会直接将其定义为 <code>0</code>。</p>
<p>C++ <strong>不允许</strong>直接将 <code>void *</code> 隐式转换到其他类型。但如果编译器尝试把 <code>NULL</code> 定义为 <code>((void*)0)</code>，那么在下面这句代码中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *ch = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>没有了 <code>void *</code> 隐式转换的 C++ 只好将 <code>NULL</code> 定义为 <code>0</code>。而这依然会产生新的问题，将 <code>NULL</code> 定义成 <code>0</code> 将导致 <code>C++</code> 中重载特性发生混乱。考虑下面这两个 <code>foo</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>那么 <code>foo(NULL);</code> 这个语句将会去调用 <code>foo(int)</code>，从而导致代码违反直觉。</p>
<p>为了解决这个问题，C++11 引入了 <code>nullptr</code> 关键字，专门用来区分空指针、<code>0</code>。而 <code>nullptr</code> 的类型为 <code>nullptr_t</code>，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p>
<p>你可以尝试使用 <code>clang++</code> 编译下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>(<span class="number">0</span>)&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == 0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>((<span class="type">void</span>*)<span class="number">0</span>)&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == (void *)0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), std::<span class="type">nullptr_t</span>&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">0</span>);          <span class="comment">// 调用 foo(int)</span></span><br><span class="line">    <span class="comment">// foo(NULL);    // 该行不能通过编译</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">nullptr</span>);    <span class="comment">// 调用 foo(char*)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> *)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(char*) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(int) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(int) is called</span><br><span class="line">foo(char*) is called</span><br></pre></td></tr></table></figure>
<p>从输出中我们可以看出，<code>NULL</code> 不同于 <code>0</code> 与 <code>nullptr</code>。所以，请养成直接使用 <code>nullptr</code>的习惯。</p>
<p>此外，在上面的代码中，我们使用了 <code>decltype</code> 和 <code>std::is_same</code> 这两个属于现代 C++ 的语法，简单来说，<code>decltype</code> 用于类型推导，而 <code>std::is_same</code> 用于比较两个类型是否相同，我们会在后面 <a href="#decltype">decltype</a> 一节中详细讨论。</p>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>C++ 本身已经具备了常量表达式的概念，比如 <code>1+2</code>, <code>3*4</code> 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。一个非常明显的例子就是在数组的定义阶段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">len_foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">len_foo_constexpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">fibonacci</span>(n<span class="number">-1</span>)+<span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arr_1[<span class="number">10</span>];                      <span class="comment">// 合法</span></span><br><span class="line">    <span class="type">char</span> arr_2[LEN];                     <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// char arr_3[len];                  // 非法</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len_2 = len + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> len_2_constexpr = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// char arr_4[len_2];                // 非法</span></span><br><span class="line">    <span class="type">char</span> arr_4[len_2_constexpr];         <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// char arr_5[len_foo()+5];          // 非法</span></span><br><span class="line">    <span class="type">char</span> arr_6[<span class="built_in">len_foo_constexpr</span>() + <span class="number">1</span>]; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fibonacci</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 1, 1, 2, 3, 5, 8, 13, 21, 34, 55</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fibonacci</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>char arr_4[len_2]</code> 可能比较令人困惑，因为 <code>len_2</code> 已经被定义为了常量。为什么 <code>char arr_4[len_2]</code> 仍然是非法的呢？这是因为 C++ 标准中数组的长度必须是一个常量表达式，而对于 <code>len_2</code> 而言，这是一个 <code>const</code> 常数，而不是一个常量表达式，因此（即便这种行为在大部分编译器中都支持，但是）它是一个非法的行为，我们需要使用接下来即将介绍的 C++11 引入的 <code>constexpr</code> 特性来解决这个问题；而对于 <code>arr_5</code> 来说，C++98 之前的编译器无法得知 <code>len_foo()</code> 在运行期实际上是返回一个常数，这也就导致了非法的产生。</p>
<blockquote>
<p>注意，现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会变得合法，若需重现编译报错的现象需要使用老版本的编译器。</p>
</blockquote>
<p>C++11 提供了 <code>constexpr</code> 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这个关键字明确的告诉编译器应该去验证 <code>len_foo</code> 在编译期就应该是一个常量表达式。</p>
<p>此外，<code>constexpr</code> 修饰的函数可以使用递归：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">fibonacci</span>(n<span class="number">-1</span>)+<span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 C++14 开始，<code>constexpr</code> 函数可以在内部使用局部变量、循环和分支等简单语句，例如下面的代码在 C++11 的标准下是不能够通过编译的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为此，我们可以写出下面这类简化的版本来使得函数从 C++11 开始即可用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-变量及其初始化"><a href="#2-2-变量及其初始化" class="headerlink" title="2.2 变量及其初始化"></a>2.2 变量及其初始化</h2><h3 id="if-switch-变量声明强化"><a href="#if-switch-变量声明强化" class="headerlink" title="if/switch 变量声明强化"></a>if/switch 变量声明强化</h3><p>在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 <code>for</code> 语句内能够声明一个临时变量 <code>int</code>，但始终没有办法在 <code>if</code> 和 <code>switch</code> 语句中声明一个临时的变量。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 c++17 之前</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (itr != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        *itr = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要重新定义一个新的变量</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator itr2 = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (itr2 != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        *itr2 = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将输出 1, 4, 3, 4</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator element = vec.<span class="built_in">begin</span>(); element != vec.<span class="built_in">end</span>(); </span><br><span class="line">        ++element)</span><br><span class="line">        std::cout &lt;&lt; *element &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们可以看到 <code>itr</code> 这一变量是定义在整个 <code>main()</code> 的作用域内的，这导致当我们需要再次遍历整个 <code>std::vectors</code> 时，需要重新命名另一个变量。C++17 消除了这一限制，使得我们可以在 <code>if</code>（或 <code>switch</code>）中完成这一操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将临时变量放到 if 语句内</span></span><br><span class="line"><span class="keyword">if</span> (<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    itr != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    *itr = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么样，是不是和 Go 语言很像？</p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化时进行使用。在传统 C++ 中，不同的对象有着不同的初始化方法，例如普通数组、POD （<strong>P</strong>lain <strong>O</strong>ld <strong>D</strong>ata，即没有构造、析构和虚函数的类或结构体）类型都可以使用 <code>&#123;&#125;</code> 进行初始化，也就是我们所说的初始化列表。而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 <code>()</code> 进行。这些不同方法都针对各自对象，不能通用。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value_a;</span><br><span class="line">    <span class="type">int</span> value_b;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">value_a</span>(a), <span class="built_in">value_b</span>(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// before C++11</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function">Foo <span class="title">foo</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;arr[0]: &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo:&quot;</span> &lt;&lt; foo.value_a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; foo.value_b &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为解决这个问题，C++11 首先把初始化列表的概念绑定到类型上，称其为 <code>std::initializer_list</code>，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">MagicFoo</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (std::initializer_list&lt;<span class="type">int</span>&gt;::iterator it = list.<span class="built_in">begin</span>();</span><br><span class="line">             it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// after C++11</span></span><br><span class="line">    MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = magicFoo.vec.<span class="built_in">begin</span>(); </span><br><span class="line">        it != magicFoo.vec.<span class="built_in">end</span>(); ++it) </span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。</p>
<p>初始化列表除了用在对象构造上，还能将其作为普通函数的形参，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (std::initializer_list&lt;<span class="type">int</span>&gt;::iterator it = list.<span class="built_in">begin</span>();</span><br><span class="line">            it != list.<span class="built_in">end</span>(); ++it) vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">magicFoo.<span class="built_in">foo</span>(&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>其次，C++11 还提供了统一的语法来初始化任意的对象，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo foo2 &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h3><p>结构化绑定提供了类似其他语言中提供的多返回值的功能。在容器一章中，我们会学到 C++11 新增了 <code>std::tuple</code> 容器用于构造一个元组，进而囊括多个返回值。但缺陷是，C++11/14 并没有提供一种简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 <code>std::tie</code> 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。</p>
<p>C++17 完善了这一设定，给出的结构化绑定可以让我们写出这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">&quot;456&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = <span class="built_in">f</span>();</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 <code>auto</code> 类型推导会在 <a href="#auto">auto 类型推导</a>一节中进行介绍。</p>
<h2 id="2-3-类型推导"><a href="#2-3-类型推导" class="headerlink" title="2.3 类型推导"></a>2.3 类型推导</h2><p>在传统 C 和 C++ 中，参数的类型都必须明确定义，这其实对我们快速进行编码没有任何帮助，尤其是当我们面对一大堆复杂的模板类型时，必须明确的指出变量的类型才能进行后续的编码，这不仅拖慢我们的开发效率，也让代码变得又臭又长。</p>
<p>C++11 引入了 <code>auto</code> 和 <code>decltype</code> 这两个关键字实现了类型推导，让编译器来操心变量的类型。这使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。</p>
<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p><code>auto</code> 在很早以前就已经进入了 C++，但是他始终作为一个存储类型的指示符存在，与 <code>register</code> 并存。在传统 C++ 中，如果一个变量没有声明为 <code>register</code> 变量，将自动被视为一个 <code>auto</code> 变量。而随着 <code>register</code> 被弃用（在 C++17 中作为保留关键字，以后使用，目前不具备实际意义），对 <code>auto</code> 的语义变更也就非常自然了。</p>
<p>使用 <code>auto</code> 进行类型推导的一个最为常见而且显著的例子就是迭代器。你应该在前面的小节里看到了传统 C++ 中冗长的迭代写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 C++11 之前</span></span><br><span class="line"><span class="comment">// 由于 cbegin() 将返回 vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="comment">// 所以 itr 也应该是 vector&lt;int&gt;::const_iterator 类型</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::const_iterator it = vec.<span class="built_in">cbegin</span>(); itr != vec.<span class="built_in">cend</span>(); ++it)</span><br></pre></td></tr></table></figure>
<p>而有了 <code>auto</code> 之后可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">MagicFoo</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list) &#123;</span><br><span class="line">        <span class="comment">// 从 C++11 起, 使用 auto 关键字进行类型推导</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = magicFoo.vec.<span class="built_in">begin</span>(); it != magicFoo.vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一些其他的常见用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>;              <span class="comment">// i 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> arr = <span class="keyword">new</span> <span class="built_in">auto</span>(<span class="number">10</span>); <span class="comment">// arr 被推导为 int *</span></span><br></pre></td></tr></table></figure>
<p>从 C++ 20 起，<code>auto</code> 甚至能用于函数传参，考虑下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> j = <span class="number">6</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add</span>(i, j) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>&gt;</p>
<blockquote>
<p><strong>注意</strong>：<code>auto</code> 还不能用于推导数组类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> auto_arr2[<span class="number">10</span>] = &#123;arr&#125;; <span class="comment">// 错误, 无法推导数组元素类型</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.6</span>.<span class="keyword">auto</span>.cpp:<span class="number">30</span>:<span class="number">19</span>: error: <span class="string">&#x27;auto_arr2&#x27;</span> declared as array of <span class="string">&#x27;auto&#x27;</span></span><br><span class="line">    <span class="keyword">auto</span> auto_arr2[<span class="number">10</span>] = &#123;arr&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p><code>decltype</code> 关键字是为了解决 <code>auto</code> 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 <code>typeof</code> 很相似：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(表达式)</span><br></pre></td></tr></table></figure>
<p>有时候，我们可能需要计算某个表达式的类型，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;</span><br></pre></td></tr></table></figure>
<p>你已经在前面的例子中看到 <code>decltype</code> 用于推断类型的用法，下面这个例子就是判断上面的变量 <code>x, y, z</code> 是否是同一类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(x), <span class="type">int</span>&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type x == int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(x), <span class="type">float</span>&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type x == float&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(x), <span class="keyword">decltype</span>(z)&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type z == type x&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>其中，<code>std::is_same&lt;T, U&gt;</code> 用于判断 <code>T</code> 和 <code>U</code> 这两个类型是否相等。输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type x == int</span><br><span class="line">type z == type x</span><br></pre></td></tr></table></figure>
<h3 id="尾返回类型推导"><a href="#尾返回类型推导" class="headerlink" title="尾返回类型推导"></a>尾返回类型推导</h3><p>你可能会思考，在介绍 <code>auto</code> 时，我们已经提过 <code>auto</code> 不能用于函数形参进行类型推导，那么 <code>auto</code> 能不能用于推导函数的返回类型呢？还是考虑一个加法函数的例子，在传统 C++ 中我们必须这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：typename 和 class 在模板参数列表中没有区别，在 typename 这个关键字出现之前，都是使用 class 来定义模板参数的。但在模板中定义有<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/dependent_name#The_typename_disambiguator_for_dependent_names">嵌套依赖类型</a>的变量时，需要用 typename 消除歧义</p>
</blockquote>
<p>这样的代码其实变得很丑陋，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。但事实上我们并不知道 <code>add()</code> 这个函数会做什么样的操作，以及获得一个什么样的返回类型。</p>
<p>在 C++11 中这个问题得到解决。虽然你可能马上会反应出来使用 <code>decltype</code> 推导 <code>x+y</code> 的类型，写出这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(x+y) <span class="built_in">add</span>(T x, U y)</span><br></pre></td></tr></table></figure>
<p>但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，<code>x</code> 和 <code>y</code> 尚未被定义。为了解决这个问题，C++11 还引入了一个叫做尾返回类型（trailing return type），利用 <code>auto</code> 关键字将返回类型后置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add2</span><span class="params">(T x, U y)</span> -&gt; <span class="title">decltype</span><span class="params">(x+y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>令人欣慰的是从 C++14 开始是可以直接让普通函数具备返回值推导，因此下面的写法变得合法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add3</span><span class="params">(T x, U y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以检查一下类型推导是否正确：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// after c++11</span></span><br><span class="line"><span class="keyword">auto</span> w = <span class="built_in">add2</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(w), <span class="type">double</span>&gt;::value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w is double: &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; w &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after c++14</span></span><br><span class="line"><span class="keyword">auto</span> q = <span class="built_in">add3</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">1.0</span>, <span class="number">2</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;q: &quot;</span> &lt;&lt; q &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h3 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype(auto)"></a>decltype(auto)</h3><p><code>decltype(auto)</code> 是 C++14 开始提供的一个略微复杂的用法。</p>
<blockquote>
<p>要理解它你需要知道 C++ 中参数转发的概念，我们会在<a href="./03-runtime.md">语言运行时强化</a>一章中详细介绍，你可以到时再回来看这一小节的内容。</p>
</blockquote>
<p>简单来说，<code>decltype(auto)</code> 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 <code>decltype</code> 的参数表达式。考虑看下面的例子，当我们需要对下面两个函数进行封装时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string  <span class="title">lookup1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">lookup2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>在 C++11 中，封装实现是如下形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">look_up_a_string_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">look_up_a_string_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而有了 <code>decltype(auto)</code>，我们可以让编译器完成这一件烦人的参数转发：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">look_up_a_string_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">look_up_a_string_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-控制流"><a href="#2-4-控制流" class="headerlink" title="2.4 控制流"></a>2.4 控制流</h2><h3 id="if-constexpr"><a href="#if-constexpr" class="headerlink" title="if constexpr"></a>if constexpr</h3><p>正如本章开头出，我们知道了 C++11 引入了 <code>constexpr</code> 关键字，它将表达式或函数编译为常量结果。一个很自然的想法是，如果我们把这一特性引入到条件判断中去，让代码在编译时就完成分支判断，岂不是能让程序效率更高？C++17 将 <code>constexpr</code> 这个关键字引入到 <code>if</code> 语句中，允许在代码中声明常量表达式的判断条件，考虑下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print_type_info</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">3.14</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译时，实际代码就会表现为如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">print_type_info</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">print_type_info</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">3.14</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间-for-迭代"><a href="#区间-for-迭代" class="headerlink" title="区间 for 迭代"></a>区间 for 迭代</h3><p>终于，C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句，我们可以进一步简化前面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>); itr != vec.<span class="built_in">end</span>()) *itr = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; std::endl; <span class="comment">// read only</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;element : vec) &#123;</span><br><span class="line">        element += <span class="number">1</span>;                      <span class="comment">// writeable</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; std::endl; <span class="comment">// read only</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h2><p>C++ 的模板一直是这门语言的一种特殊的艺术，模板甚至可以独立作为一门新的语言来进行使用。模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理，仅在运行时处理那些最核心的动态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。</p>
<h3 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h3><p>传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且，我们没有办法通知编译器不要触发模板的实例化。</p>
<p>为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能够显式的通知编译器何时进行模板的实例化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">std</span>::vector&lt;<span class="type">bool</span>&gt;;          <span class="comment">// 强行实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">std</span>::vector&lt;<span class="type">double</span>&gt;; <span class="comment">// 不在该当前编译文件中实例化模板</span></span><br></pre></td></tr></table></figure>
<h3 id="尖括号-“-gt-”"><a href="#尖括号-“-gt-”" class="headerlink" title="尖括号 “&gt;”"></a>尖括号 “&gt;”</h3><p>在传统 C++ 的编译器中，<code>&gt;&gt;</code>一律被当做右移运算符来进行处理。但实际上我们很容易就写出了嵌套模板的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; matrix;</span><br></pre></td></tr></table></figure>
<p>这在传统 C++ 编译器下是不能够被编译的，而 C++11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译。甚至于像下面这种写法都能够通过编译：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicType</span> &#123;</span><br><span class="line">    <span class="type">bool</span> magic = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in main function:</span></span><br><span class="line">std::vector&lt;MagicType&lt;(1&gt;<span class="number">2</span>)&gt;&gt; magic; <span class="comment">// 合法, 但不建议写出这样的代码</span></span><br></pre></td></tr></table></figure>
<h3 id="类型别名模板"><a href="#类型别名模板" class="headerlink" title="类型别名模板"></a>类型别名模板</h3><p>在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话：<strong>模板是用来产生类型的。</strong>在传统 C++ 中，<code>typedef</code>  可以为类型定义一个新的名称，但是却没有办法为模板定义一个新的名称。因为，模板不是类型。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicType</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T dark;</span><br><span class="line">    U magic;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> MagicType&lt;std::vector&lt;T&gt;, std::string&gt; FakeDarkMagic;</span><br></pre></td></tr></table></figure>
<p>C++11 使用 <code>using</code> 引入了下面这种形式的写法，并且同时支持对传统 <code>typedef</code> 相同的功效：</p>
<blockquote>
<p>通常我们使用 <code>typedef</code> 定义别名的语法是：<code>typedef 原名称 新名称;</code>，但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*process)</span><span class="params">(<span class="type">void</span> *)</span></span>;</span><br><span class="line"><span class="keyword">using</span> NewProcess = <span class="built_in">int</span>(*)(<span class="type">void</span> *);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> TrueDarkMagic = MagicType&lt;std::vector&lt;T&gt;, std::string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TrueDarkMagic&lt;<span class="type">bool</span>&gt; you;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变长参数模板"><a href="#变长参数模板" class="headerlink" title="变长参数模板"></a>变长参数模板</h3><p>模板一直是 C++ 所独有的<strong>黑魔法</strong>（一起念：<strong>Dark Magic</strong>）之一。<br>在 C++11 之前，无论是类模板还是函数模板，都只能按其指定的样子，<br>接受一组固定数量的模板参数；而 C++11 加入了新的表示方法，<br>允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; <span class="keyword">class</span> <span class="title class_">Magic</span>;</span><br></pre></td></tr></table></figure>
<p>模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数，例如下面的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Magic</span>&lt;<span class="type">int</span>,</span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;,</span><br><span class="line">            std::map&lt;std::string,</span><br><span class="line">            std::vector&lt;<span class="type">int</span>&gt;&gt;&gt; darkMagic;</span><br></pre></td></tr></table></figure>
<p>既然是任意形式，所以个数为 <code>0</code> 的模板参数也是可以的：<code>class Magic&lt;&gt; nothing;</code>。</p>
<p>如果不希望产生的模板参数个数为 <code>0</code>，可以手动的定义至少一个模板参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Require, <span class="keyword">typename</span>... Args&gt; <span class="keyword">class</span> <span class="title class_">Magic</span>;</span><br></pre></td></tr></table></figure>
<p>变长参数模板也能被直接调整到到模板函数上。传统 C 中的 <code>printf</code> 函数，<br>虽然也能达成不定个数的形参的调用，但其并非类别安全。<br>而 C++11 除了能定义类别安全的变长参数函数外，<br>还可以使类似 <code>printf</code> 的函数能自然地处理非自带类别的对象。<br>除了在模板参数中能使用 <code>...</code> 表示不定长模板参数外，<br>函数参数也使用同样的表示法代表不定长参数，<br>这也就为我们简单编写变长参数函数提供了便捷的手段，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; <span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> std::string &amp;str, Args... args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>那么我们定义了变长的模板参数，如何对参数进行解包呢？</p>
<p>首先，我们可以使用 <code>sizeof...</code> 来计算参数的个数，：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">magic</span><span class="params">(Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以传递任意个参数给 <code>magic</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">magic</span>(); <span class="comment">// 输出0</span></span><br><span class="line"><span class="built_in">magic</span>(<span class="number">1</span>); <span class="comment">// 输出1</span></span><br><span class="line"><span class="built_in">magic</span>(<span class="number">1</span>, <span class="string">&quot;&quot;</span>); <span class="comment">// 输出2</span></span><br></pre></td></tr></table></figure>
<p>其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理手法：</p>
<p><strong>1. 递归模板函数</strong></p>
<p>递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归地向函数传递模板参数，进而达到递归遍历所有模板参数的目的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf1</span><span class="params">(T0 value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf1</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printf1</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf1</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;123&quot;</span>, <span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 变参模板展开</strong></p>
<p>你应该感受到了这很繁琐，在 C++17 中增加了变参模板展开的支持，于是你可以在一个函数中完成 <code>printf</code> 的编写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf2</span><span class="params">(T0 t0, T... t)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; t0 &lt;&lt; std::endl;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(t) &gt; <span class="number">0</span>)</span> <span class="title">printf2</span><span class="params">(t...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事实上，有时候我们虽然使用了变参模板，却不一定需要对参数做逐个遍历，我们可以利用 <code>std::bind</code> 及完美转发等特性实现对函数和参数的绑定，从而达到成功调用的目的。</p>
</blockquote>
<p><strong>3. 初始化列表展开</strong></p>
<p>递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。</p>
<p>这里介绍一种使用初始化列表展开的黑魔法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">printf3</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    (<span class="type">void</span>) std::initializer_list&lt;T&gt;&#123;([&amp;args] &#123;</span><br><span class="line">        std::cout &lt;&lt; args &lt;&lt; std::endl;</span><br><span class="line">    &#125;(), value)...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个代码中，额外使用了 C++11 中提供的初始化列表以及 Lambda 表达式的特性（下一节中将提到）。</p>
<p>通过初始化列表，<code>(lambda 表达式, value)...</code> 将会被展开。由于逗号表达式的出现，首先会执行前面的 lambda 表达式，完成参数的输出。<br>为了避免编译器警告，我们可以将 <code>std::initializer_list</code> 显式的转为 <code>void</code>。</p>
<h3 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h3><p>C++ 17 中将变长参数这种特性进一步带给了表达式，考虑下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T ... t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t + ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非类型模板参数推导"><a href="#非类型模板参数推导" class="headerlink" title="非类型模板参数推导"></a>非类型模板参数推导</h3><p>前面我们主要提及的是模板参数的一种形式：类型模板参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中模板的参数 <code>T</code> 和 <code>U</code> 为具体的类型。<br>但还有一种常见模板参数形式可以让不同字面量成为模板参数，即非类型模板参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> BufSize&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">buffer_t</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T&amp; <span class="title">alloc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[BufSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">buffer_t</span>&lt;<span class="type">int</span>, <span class="number">100</span>&gt; buf; <span class="comment">// 100 作为模板参数</span></span><br></pre></td></tr></table></figure>
<p>在这种模板参数形式下，我们可以将 <code>100</code> 作为模板的参数进行传递。<br>在 C++11 引入了类型推导这一特性后，我们会很自然的问，既然此处的模板参数<br>以具体的字面量进行传递，能否让编译器辅助我们进行类型推导，<br>通过使用占位符 <code>auto</code> 从而不再需要明确指明类型？<br>幸运的是，C++17 引入了这一特性，我们的确可以 <code>auto</code> 关键字，让编译器辅助完成具体类型的推导，<br>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> value&gt; <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>&lt;<span class="number">10</span>&gt;();  <span class="comment">// value 被推导为 int 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-6-面向对象"><a href="#2-6-面向对象" class="headerlink" title="2.6 面向对象"></a>2.6 面向对象</h2><h3 id="委托构造"><a href="#委托构造" class="headerlink" title="委托构造"></a>委托构造</h3><p>C++11 引入了委托构造的概念，这使得构造函数可以在同一个类中一个构造函数调用另一个构造函数，从而达到简化代码的目的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value1;</span><br><span class="line">    <span class="type">int</span> value2;</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value) : <span class="built_in">Base</span>() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">        value2 = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; b.value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; b.value2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承构造"><a href="#继承构造" class="headerlink" title="继承构造"></a>继承构造</h3><p>在传统 C++ 中，构造函数如果需要继承是需要将参数一一传递的，这将导致效率低下。C++11 利用关键字 <code>using</code> 引入了继承构造函数的概念：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value1;</span><br><span class="line">    <span class="type">int</span> value2;</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value) : <span class="built_in">Base</span>() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">        value2 = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subclass</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base; <span class="comment">// 继承构造</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Subclass <span class="title">s</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; s.value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; s.value2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="显式虚函数重载"><a href="#显式虚函数重载" class="headerlink" title="显式虚函数重载"></a>显式虚函数重载</h3><p>在传统 C++ 中，经常容易发生意外重载虚函数的事情。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass</span>: Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>SubClass::foo</code> 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。另一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成为了一个普通的类方法，这将造成灾难性的后果。</p>
<p>C++11 引入了 <code>override</code> 和 <code>final</code> 这两个关键字来防止上述情形的发生。</p>
<h4 id="override"><a href="#override" class="headerlink" title="override"></a>override</h4><p>当重载虚函数时，引入 <code>override</code> 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass</span>: Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 合法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">float</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 非法, 父类没有此虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p><code>final</code> 则是为了防止类被继续继承以及终止虚函数继续重载引入的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass1</span> <span class="keyword">final</span>: Base &#123;</span><br><span class="line">&#125;; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass2</span> : SubClass1 &#123;</span><br><span class="line">&#125;; <span class="comment">// 非法, SubClass1 已 final</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SubClass3</span>: Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// 非法, foo 已 final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="显式禁用默认函数"><a href="#显式禁用默认函数" class="headerlink" title="显式禁用默认函数"></a>显式禁用默认函数</h3><p>在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成默认构造函数、<br>复制构造、赋值算符以及析构函数。<br>另外，C++ 也为所有类定义了诸如 <code>new</code> <code>delete</code> 这样的运算符。<br>当程序员有需要时，可以重载这部分函数。</p>
<p>这就引发了一些需求：无法精确控制默认函数的生成行为。<br>例如禁止类的拷贝时，必须将复制构造函数与赋值算符声明为 <code>private</code>。<br>尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式。</p>
<p>并且，编译器产生的默认构造函数与用户定义的构造函数无法同时存在。<br>若用户定义了任何构造函数，编译器将不再生成默认构造函数，<br>但有时候我们却希望同时拥有这两种构造函数，这就造成了尴尬。</p>
<p>C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数。<br>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Magic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Magic</span>() = <span class="keyword">default</span>; <span class="comment">// 显式声明使用编译器生成的构造</span></span><br><span class="line">    Magic&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Magic&amp;) = <span class="keyword">delete</span>; <span class="comment">// 显式声明拒绝编译器生成构造</span></span><br><span class="line">    <span class="built_in">Magic</span>(<span class="type">int</span> magic_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h3><p>在传统 C++中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），<strong>甚至同一个命名空间中的不同枚举类型的枚举值名字不能相同</strong>，这通常不是我们希望看到的结果。</p>
<p>C++11 引入了枚举类（enumeration class），并使用 <code>enum class</code> 的语法进行声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">new_enum</span> : <span class="type">unsigned</span> <span class="type">int</span> &#123;</span><br><span class="line">    value1,</span><br><span class="line">    value2,</span><br><span class="line">    value3 = <span class="number">100</span>,</span><br><span class="line">    value4 = <span class="number">100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较，<br>更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (new_enum::value3 == new_enum::value4) &#123;</span><br><span class="line">    <span class="comment">// 会输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;new_enum::value3 == new_enum::value4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个语法中，枚举类型后面使用了冒号及类型关键字来指定枚举中枚举值的类型，这使得我们能够为枚举赋值（未指定时将默认使用 <code>int</code>）。</p>
<p>而我们希望获得枚举值的值时，将必须显式的进行类型转换，不过我们可以通过重载 <code>&lt;&lt;</code> 这个算符来进行输出，可以收藏下面这个代码段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;std::is_enum&lt;T&gt;::value,</span><br><span class="line">        std::ostream&gt;::type&amp; stream, <span class="type">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> stream &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::underlying_type&lt;T&gt;::type&gt;(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时，下面的代码将能够被编译：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; new_enum::value3 &lt;&lt; std::endl</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节介绍了现代 C++ 中对语言可用性的增强，其中笔者认为最为重要的几个特性是几乎所有人都需要了解并熟练使用的：</p>
<ol>
<li><code>auto</code> 类型推导</li>
<li>范围 <code>for</code> 迭代</li>
<li>初始化列表</li>
<li>变参模板</li>
</ol>
<h1 id="第-3-章-语言运行期的强化"><a href="#第-3-章-语言运行期的强化" class="headerlink" title="第 3 章 语言运行期的强化"></a>第 3 章 语言运行期的强化</h1><h2 id="3-1-Lambda-表达式"><a href="#3-1-Lambda-表达式" class="headerlink" title="3.1 Lambda 表达式"></a>3.1 Lambda 表达式</h2><p>Lambda 表达式是现代 C++ 中最重要的特性之一，而 Lambda 表达式，实际上就是提供了一个类似匿名函数的特性，<br>而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多，<br>所以匿名函数几乎是现代编程语言的标配。</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>Lambda 表达式的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表) mutable(可选) 异常属性 -&gt; 返回类型 &#123;</span><br><span class="line">// 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的语法规则除了 <code>[捕获列表]</code> 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去，<br>返回值使用了一个 <code>-&gt;</code> 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）。</p>
<p>所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的，<br>这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：</p>
<h4 id="1-值捕获"><a href="#1-值捕获" class="headerlink" title="1. 值捕获"></a>1. 值捕获</h4><p>与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被创建时拷贝，<br>而非调用时才拷贝：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_value_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = <span class="built_in">copy_value</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stored_value = &quot;</span> &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 1, 而 value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 在创建时就保存了一份 value 的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-引用捕获"><a href="#2-引用捕获" class="headerlink" title="2. 引用捕获"></a>2. 引用捕获</h4><p>与引用传参类似，引用捕获保存的是引用，值会发生变化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_reference_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [&amp;value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = <span class="built_in">copy_value</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stored_value = &quot;</span> &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 这时, stored_value == 100, value == 100.</span></span><br><span class="line">    <span class="comment">// 因为 copy_value 保存的是引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-隐式捕获"><a href="#3-隐式捕获" class="headerlink" title="3. 隐式捕获"></a>3. 隐式捕获</h4><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个<br><code>&amp;</code> 或 <code>=</code> 向编译器声明采用引用捕获或者值捕获.</p>
<p>总结一下，捕获提供了 Lambda 表达式对外部值进行使用的功能，捕获列表的最常用的四种形式可以是：</p>
<ul>
<li>[] 空捕获列表</li>
<li>[name1, name2, …] 捕获一系列变量</li>
<li>[&amp;] 引用捕获, 让编译器自行推导引用列表</li>
<li>[=] 值捕获, 让编译器自行推导值捕获列表</li>
</ul>
<h4 id="4-表达式捕获"><a href="#4-表达式捕获" class="headerlink" title="4. 表达式捕获"></a>4. 表达式捕获</h4><blockquote>
<p>这部分内容需要了解后面马上要提到的右值引用以及智能指针</p>
</blockquote>
<p>上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的均为左值，而不能捕获右值。</p>
<p>C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获，<br>被声明的捕获变量类型会根据表达式进行判断，判断方式与使用 <code>auto</code> 本质上是相同的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// std::make_unique</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_expression_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> important = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = std::<span class="built_in">move</span>(important)](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，important 是一个独占指针，是不能够被 “=” 值捕获到，这时候我们可以将其转移为右值，在表达式中初始化。</p>
<h3 id="泛型-Lambda"><a href="#泛型-Lambda" class="headerlink" title="泛型 Lambda"></a>泛型 Lambda</h3><p>上一节中我们提到了 <code>auto</code> 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。<br>但是 Lambda 表达式并不是普通函数，所以在没有明确指明参数表类型的情况下，Lambda 表达式并不能够模板化。<br>幸运的是，这种麻烦只存在于 C++11 中，从 C++14 开始，Lambda 函数的形式参数可以使用 <code>auto</code><br>关键字来产生意义上的泛型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1.1</span>, <span class="number">2.2</span>);</span><br></pre></td></tr></table></figure>
<h2 id="3-2-函数对象包装器"><a href="#3-2-函数对象包装器" class="headerlink" title="3.2 函数对象包装器"></a>3.2 函数对象包装器</h2><p>这部分内容虽然属于标准库的一部分，但是从本质上来看，它却增强了 C++ 语言运行时的能力，<br>这部分内容也相当重要，所以放到这里来进行介绍。</p>
<h3 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a><code>std::function</code></h3><p>Lambda 表达式的本质是一个和函数对象类型相似的类类型（称为闭包类型）的对象（称为闭包对象），<br>当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> foo = <span class="built_in">void</span>(<span class="type">int</span>); <span class="comment">// 定义函数类型, using 的使用见上一节中的别名语法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functional</span><span class="params">(foo f)</span> </span>&#123; <span class="comment">// 参数列表中定义的函数类型 foo 被视为退化后的函数指针类型 foo*</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="type">int</span> value) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">functional</span>(f); <span class="comment">// 传递闭包对象，隐式转换为 foo* 类型的函数指针值</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// lambda 表达式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用，<br>而另一种则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，将能够被调用的对象的类型，<br>统一称之为可调用类型。而这种类型，便是通过 <code>std::function</code> 引入的。</p>
<p>C++11 <code>std::function</code> 是一种通用、多态的函数封装，<br>它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作，<br>它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数指针的调用不是类型安全的），<br>换句话说，就是函数的容器。当我们有了函数的容器之后便能够更加方便的将函数、函数指针作为对象进行处理。<br>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> para)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::function 包装了一个返回值为 int, 参数为 int 的函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func = foo;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> important = <span class="number">10</span>;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func2 = [&amp;](<span class="type">int</span> value) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+value+important;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="std-bind-和-std-placeholder"><a href="#std-bind-和-std-placeholder" class="headerlink" title="std::bind 和 std::placeholder"></a><code>std::bind</code> 和 <code>std::placeholder</code></h3><p>而 <code>std::bind</code> 则是用来绑定函数调用的参数的，<br>它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，<br>我们可以将部分调用参数提前绑定到函数身上成为一个新的对象，然后在参数齐全后，完成调用。<br>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将参数1,2绑定到函数 foo 上，</span></span><br><span class="line">    <span class="comment">// 但使用 std::placeholders::_1 来对第一个参数进行占位</span></span><br><span class="line">    <span class="keyword">auto</span> bindFoo = std::<span class="built_in">bind</span>(foo, std::placeholders::_1, <span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 这时调用 bindFoo 时，只需要提供第一个参数即可</span></span><br><span class="line">    <span class="built_in">bindFoo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示：</strong>注意 <code>auto</code> 关键字的妙用。有时候我们可能不太熟悉一个函数的返回值类型，<br>但是我们却可以通过 <code>auto</code> 的使用来规避这一问题的出现。</p>
</blockquote>
<h2 id="3-3-右值引用"><a href="#3-3-右值引用" class="headerlink" title="3.3 右值引用"></a>3.3 右值引用</h2><p>右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。它的引入解决了 C++ 中大量的历史遗留问题，<br>消除了诸如 <code>std::vector</code>、<code>std::string</code> 之类的额外开销，<br>也才使得函数对象容器 <code>std::function</code> 成为了可能。</p>
<h3 id="左值、右值的纯右值、将亡值、右值"><a href="#左值、右值的纯右值、将亡值、右值" class="headerlink" title="左值、右值的纯右值、将亡值、右值"></a>左值、右值的纯右值、将亡值、右值</h3><p>要弄明白右值引用到底是怎么一回事，必须要对左值和右值做一个明确的理解。</p>
<p><strong>左值</strong> (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说，<br>左值是表达式（不一定是赋值表达式）后依然存在的持久对象。</p>
<p><strong>右值</strong> (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。</p>
<p>而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。</p>
<p><strong>纯右值</strong> (prvalue, pure rvalue)，纯粹的右值，要么是纯粹的字面量，例如 <code>10</code>, <code>true</code>；<br>要么是求值结果相当于字面量或匿名临时对象，例如 <code>1+2</code>。非引用返回的临时变量、运算表达式产生的临时变量、<br>原始字面量、Lambda 表达式都属于纯右值。</p>
<p>需要注意的是，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 <code>const char</code> 数组。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正确，&quot;01234&quot; 类型为 const char [6]，因此是左值</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">char</span> <span class="params">(&amp;left)</span>[6] </span>= <span class="string">&quot;01234&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 断言正确，确实是 const char [6] 类型，注意 decltype(expr) 在 expr 是左值</span></span><br><span class="line">    <span class="comment">// 且非无括号包裹的 id 表达式与类成员表达式时，会返回左值引用</span></span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same&lt;<span class="keyword">decltype</span>(<span class="string">&quot;01234&quot;</span>), <span class="type">const</span> <span class="built_in">char</span>(&amp;)[<span class="number">6</span>]&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误，&quot;01234&quot; 是左值，不可被右值引用</span></span><br><span class="line">    <span class="comment">// const char (&amp;&amp;right)[6] = &quot;01234&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是注意，数组可以被隐式转换成相对应的指针类型，而转换表达式的结果（如果不是左值引用）则一定是个右值（右值引用为将亡值，否则为纯右值）。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>*   p   = <span class="string">&quot;01234&quot;</span>;  <span class="comment">// 正确，&quot;01234&quot; 被隐式转换为 const char*</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*&amp;&amp; pr  = <span class="string">&quot;01234&quot;</span>;  <span class="comment">// 正确，&quot;01234&quot; 被隐式转换为 const char*，该转换的结果是纯右值</span></span><br><span class="line"><span class="comment">// const char*&amp; pl = &quot;01234&quot;; // 错误，此处不存在 const char* 类型的左值</span></span><br></pre></td></tr></table></figure>
<p><strong>将亡值(xvalue, expiring value)</strong>，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++ 中，<br>纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。</p>
<p>将亡值可能稍有些难以理解，我们来看这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; temp = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = <span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure>
<p>在这样的代码中，就传统的理解而言，函数 <code>foo</code> 的返回值 <code>temp</code> 在内部创建然后被赋值给 <code>v</code>，<br>然而 <code>v</code> 获得这个对象时，会将整个 <code>temp</code> 拷贝一份，然后把 <code>temp</code> 销毁，如果这个 <code>temp</code> 非常大，<br>这将造成大量额外的开销（这也就是传统 C++ 一直被诟病的问题）。在最后一行中，<code>v</code> 是左值、<br><code>foo()</code> 返回的值就是右值（也是纯右值）。但是，<code>v</code> 可以被别的变量捕获到，<br>而 <code>foo()</code> 产生的那个返回值作为一个临时值，一旦被 <code>v</code> 复制后，将立即被销毁，无法获取、也不能修改。<br>而将亡值就定义了这样一种行为：临时的值能够被识别、同时又能够被移动。</p>
<p>在 C++11 之后，编译器为我们做了一些工作，此处的左值 <code>temp</code> 会被进行此隐式右值转换，<br>等价于 <code>static_cast&lt;std::vector&lt;int&gt; &amp;&amp;&gt;(temp)</code>，进而此处的 <code>v</code> 会将 <code>foo</code> 局部返回的值进行移动。<br>也就是后面我们将会提到的移动语义。</p>
<h3 id="右值引用和左值引用"><a href="#右值引用和左值引用" class="headerlink" title="右值引用和左值引用"></a>右值引用和左值引用</h3><p>要拿到一个将亡值，就需要用到右值引用：<code>T &amp;&amp;</code>，其中 <code>T</code> 是类型。<br>右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。</p>
<p>C++11 提供了 <code>std::move</code> 这个方法将左值参数无条件的转换为右值，<br>有了它我们就能够方便的获得一个右值临时对象，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(std::string&amp;&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string lv1 = <span class="string">&quot;string,&quot;</span>; <span class="comment">// lv1 是一个左值</span></span><br><span class="line">    <span class="comment">// std::string&amp;&amp; r1 = lv1; // 非法, 右值引用不能引用左值</span></span><br><span class="line">    std::string&amp;&amp; rv1 = std::<span class="built_in">move</span>(lv1); <span class="comment">// 合法, std::move可以将左值转移为右值</span></span><br><span class="line">    std::cout &lt;&lt; rv1 &lt;&lt; std::endl; <span class="comment">// string,</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string&amp; lv2 = lv1 + lv1; <span class="comment">// 合法, 常量左值引用能够延长临时变量的生命周期</span></span><br><span class="line">    <span class="comment">// lv2 += &quot;Test&quot;; // 非法, 常量引用无法被修改</span></span><br><span class="line">    std::cout &lt;&lt; lv2 &lt;&lt; std::endl; <span class="comment">// string,string,</span></span><br><span class="line"></span><br><span class="line">    std::string&amp;&amp; rv2 = lv1 + lv2; <span class="comment">// 合法, 右值引用延长临时对象生命周期</span></span><br><span class="line">    rv2 += <span class="string">&quot;Test&quot;</span>; <span class="comment">// 合法, 非常量引用能够修改临时变量</span></span><br><span class="line">    std::cout &lt;&lt; rv2 &lt;&lt; std::endl; <span class="comment">// string,string,string,Test</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">reference</span>(rv2); <span class="comment">// 输出左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rv2</code> 虽然引用了一个右值，但由于它是一个引用，所以 <code>rv2</code> 依然是一个左值。</p>
<p>注意，这里有一个很有趣的历史遗留问题，我们先看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int &amp;a = std::move(1);    // 不合法，非常量左引用无法引用右值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;b = std::<span class="built_in">move</span>(<span class="number">1</span>); <span class="comment">// 合法, 常量左引用允许引用右值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个问题，为什么不允许非常量引用绑定到非左值？这是因为这种做法存在逻辑错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">(<span class="type">int</span> &amp; v)</span> </span>&#123;</span><br><span class="line">    v++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">increase</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <code>int&amp;</code> 不能引用 <code>double</code> 类型的参数，因此必须产生一个临时值来保存 <code>s</code> 的值，<br>从而当 <code>increase()</code> 修改这个临时值时，调用完成后 <code>s</code> 本身并没有被修改。</p>
<p>第二个问题，为什么常量引用允许绑定到非左值？原因很简单，因为 Fortran 需要。</p>
<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝/复制的概念，但为了实现对资源的移动操作，<br>调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。<br>试想，搬家的时候是把家里的东西直接搬到新家去，而不是将所有东西复制一份（重买）再放到新家、<br>再把原来的东西全部扔掉（销毁），这是非常反人类的一件事情。</p>
<p>传统的 C++ 没有区分『移动』和『拷贝』的概念，造成了大量的数据拷贝，浪费时间和空间。<br>右值引用的出现恰好就解决了这两个概念的混淆问题，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *pointer;</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">pointer</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;构造&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp; a):<span class="built_in">pointer</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.pointer)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;拷贝&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="comment">// 无意义的对象拷贝</span></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; a):<span class="built_in">pointer</span>(a.pointer) &#123;</span><br><span class="line">        a.pointer = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;移动&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;析构&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> pointer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 防止编译器优化</span></span><br><span class="line"><span class="function">A <span class="title">return_rvalue</span><span class="params">(<span class="type">bool</span> test)</span> </span>&#123;</span><br><span class="line">    A a,b;</span><br><span class="line">    <span class="keyword">if</span>(test) <span class="keyword">return</span> a; <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(a);</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;     <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(b);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A obj = <span class="built_in">return_rvalue</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; obj.pointer &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *obj.pointer &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中：</p>
<ol>
<li>首先会在 <code>return_rvalue</code> 内部构造两个 <code>A</code> 对象，于是获得两个构造函数的输出；</li>
<li>函数返回后，产生一个将亡值，被 <code>A</code> 的移动构造（<code>A(A&amp;&amp;)</code>）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 <code>obj</code> 中，而将亡值的指针被设置为 <code>nullptr</code>，防止了这块内存区域被销毁。</li>
</ol>
<p>从而避免了无意义的拷贝构造，加强了性能。再来看看涉及标准库的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::move</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// std::string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::string str = <span class="string">&quot;Hello world.&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将使用 push_back(const T&amp;), 即产生拷贝行为</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(str);</span><br><span class="line">    <span class="comment">// 将输出 &quot;str: Hello world.&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将使用 push_back(const T&amp;&amp;), 不会出现拷贝行为</span></span><br><span class="line">    <span class="comment">// 而整个字符串会被移动到 vector 中，所以有时候 std::move 会用来减少拷贝出现的开销</span></span><br><span class="line">    <span class="comment">// 这步操作后, str 中的值会变为空</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str));</span><br><span class="line">    <span class="comment">// 将输出 &quot;str: &quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>前面我们提到了，一个声明的右值引用其实是一个左值。这就为我们进行参数转发（传递）造成了问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;普通传参:&quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(v); <span class="comment">// 始终调用 reference(int&amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递右值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">pass</span>(<span class="number">1</span>); <span class="comment">// 1是右值, 但输出是左值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递左值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pass</span>(l); <span class="comment">// l 是左值, 输出左值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>pass(1)</code> 来说，虽然传递的是右值，但由于 <code>v</code> 是一个引用，所以同时也是左值。<br>因此 <code>reference(v)</code> 会调用 <code>reference(int&amp;)</code>，输出『左值』。<br>而对于<code>pass(l)</code>而言，<code>l</code>是一个左值，为什么会成功传递给 <code>pass(T&amp;&amp;)</code> 呢？</p>
<p>这是基于<strong>引用坍缩规则</strong>的：在传统 C++ 中，我们不能够对一个引用类型继续进行引用，<br>但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用，<br>既能左引用，又能右引用。但是却遵循如下规则：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数形参类型</th>
<th style="text-align:center">实参参数类型</th>
<th style="text-align:center">推导后函数形参类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T&amp;</td>
<td style="text-align:center">左引用</td>
<td style="text-align:center">T&amp;</td>
</tr>
<tr>
<td style="text-align:center">T&amp;</td>
<td style="text-align:center">右引用</td>
<td style="text-align:center">T&amp;</td>
</tr>
<tr>
<td style="text-align:center">T&amp;&amp;</td>
<td style="text-align:center">左引用</td>
<td style="text-align:center">T&amp;</td>
</tr>
<tr>
<td style="text-align:center">T&amp;&amp;</td>
<td style="text-align:center">右引用</td>
<td style="text-align:center">T&amp;&amp;</td>
</tr>
</tbody>
</table>
</div>
<p>因此，模板函数中使用 <code>T&amp;&amp;</code> 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。<br>更准确的讲，<strong>无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型</strong>。<br>这才使得 <code>v</code> 作为左值的成功传递。</p>
<p>完美转发就是基于上述规律产生的。所谓完美转发，就是为了让我们在传递参数的时候，<br>保持原来的参数类型（左引用保持左引用，右引用保持右引用）。<br>为了解决这个问题，我们应该使用 <code>std::forward</code> 来进行参数的转发（传递）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左值引用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右值引用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;              普通传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(v);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;       std::move 传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(std::<span class="built_in">move</span>(v));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;    std::forward 传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(std::forward&lt;T&gt;(v));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;static_cast&lt;T&amp;&amp;&gt; 传参: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(<span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递右值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">pass</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;传递左值:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pass</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">传递右值:</span><br><span class="line">              普通传参: 左值引用</span><br><span class="line">       std::move 传参: 右值引用</span><br><span class="line">    std::forward 传参: 右值引用</span><br><span class="line">static_cast&lt;T&amp;&amp;&gt; 传参: 右值引用</span><br><span class="line">传递左值:</span><br><span class="line">              普通传参: 左值引用</span><br><span class="line">       std::move 传参: 右值引用</span><br><span class="line">    std::forward 传参: 左值引用</span><br><span class="line">static_cast&lt;T&amp;&amp;&gt; 传参: 左值引用</span><br></pre></td></tr></table></figure>
<p>无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发，<br>所以 <code>std::move</code> 总会接受到一个左值，从而转发调用了<code>reference(int&amp;&amp;)</code> 输出右值引用。</p>
<p>唯独 <code>std::forward</code> 即没有造成任何多余的拷贝，同时<strong>完美转发</strong>(传递)了函数的实参给了内部调用的其他函数。</p>
<p><code>std::forward</code> 和 <code>std::move</code> 一样，没有做任何事情，<code>std::move</code> 单纯的将左值转化为右值，<br><code>std::forward</code> 也只是单纯的将参数做了一个类型的转换，从现象上来看，<br><code>std::forward&lt;T&gt;(v)</code> 和 <code>static_cast&lt;T&amp;&amp;&gt;(v)</code> 是完全一样的。</p>
<p>读者可能会好奇，为何一条语句能够针对两种类型的返回对应的值，<br>我们再简单看一看 <code>std::forward</code> 的具体实现机制，<code>std::forward</code> 包含两个重载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">        <span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这份实现中，<code>std::remove_reference</code> 的功能是消除类型中的引用，<br><code>std::is_lvalue_reference</code> 则用于检查类型推导是否正确，在 <code>std::forward</code> 的第二个实现中<br>检查了接收到的值确实是一个左值，进而体现了坍缩规则。</p>
<p>当 <code>std::forward</code> 接受左值时，<code>_Tp</code> 被推导为左值，所以返回值为左值；而当其接受右值时，<br><code>_Tp</code> 被推导为 右值引用，则基于坍缩规则，返回值便成为了 <code>&amp;&amp; + &amp;&amp;</code> 的右值。<br>可见 <code>std::forward</code> 的原理在于巧妙的利用了模板类型推导中产生的差异。</p>
<p>这时我们能回答这样一个问题：为什么在使用循环语句的过程中，<code>auto&amp;&amp;</code> 是最安全的方式？<br>因为当 <code>auto</code> 被推导为不同的左右引用时，与 <code>&amp;&amp;</code> 的坍缩组合是完美转发。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了现代 C++ 中最为重要的几个语言运行时的增强，其中笔者认为本节中提到的所有特性都是值得掌握的：</p>
<ol>
<li>Lambda 表达式</li>
<li>函数对象容器 std::function</li>
<li>右值引用</li>
</ol>
<h1 id="第-4-章-容器"><a href="#第-4-章-容器" class="headerlink" title="第 4 章 容器"></a>第 4 章 容器</h1><h2 id="4-1-线性容器"><a href="#4-1-线性容器" class="headerlink" title="4.1 线性容器"></a>4.1 线性容器</h2><h3 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a><code>std::array</code></h3><p>看到这个容器的时候肯定会出现这样的问题：</p>
<ol>
<li>为什么要引入 <code>std::array</code> 而不是直接使用 <code>std::vector</code>？</li>
<li>已经有了传统数组，为什么要用 <code>std::array</code>?</li>
</ol>
<p>先回答第一个问题，与 <code>std::vector</code> 不同，<code>std::array</code> 对象的大小是固定的，如果容器大小是固定的，那么可以优先考虑使用 <code>std::array</code> 容器。<br>另外由于 <code>std::vector</code> 是自动扩容的，当存入大量的数据后，并且对容器进行了删除操作，<br>容器并不会自动归还被删除元素相应的内存，这时候就需要手动运行 <code>shrink_to_fit()</code> 释放这部分内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// 输出 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下可看出 std::vector 的存储是自动管理的，按需自动扩张</span></span><br><span class="line"><span class="comment">// 但是如果空间不足，需要重新分配更多内存，而重分配内存通常是性能上有开销的操作</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// 输出 3</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的自动扩张逻辑与 Golang 的 slice 很像</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// 输出 5</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如下可看出容器虽然清空了元素，但是被清空元素的内存并没有归还</span></span><br><span class="line">v.<span class="built_in">clear</span>();                                             </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// 输出 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 额外内存可通过 shrink_to_fit() 调用返回给系统</span></span><br><span class="line">v.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// 输出 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// 输出 0</span></span><br></pre></td></tr></table></figure>
<p>而第二个问题就更加简单，使用 <code>std::array</code> 能够让代码变得更加“现代化”，而且封装了一些操作函数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 <code>std::sort</code>。</p>
<p>使用 <code>std::array</code> 很简单，只需指定其类型和大小即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="type">int</span>, 4&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">arr.<span class="built_in">empty</span>(); <span class="comment">// 检查容器是否为空</span></span><br><span class="line">arr.<span class="built_in">size</span>();  <span class="comment">// 返回容纳的元素数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器支持</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : arr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 lambda 表达式排序</span></span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组大小参数必须是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> len = <span class="number">4</span>;</span><br><span class="line">std::array&lt;<span class="type">int</span>, len&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非法,不同于 C 风格数组，std::array 不会自动退化成 T*</span></span><br><span class="line"><span class="comment">// int *arr_p = arr;</span></span><br></pre></td></tr></table></figure>
<p>当我们开始用上了 <code>std::array</code> 时，难免会遇到要将其兼容 C 风格的接口，这里有三种做法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="type">int</span>, 4&gt; arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C 风格接口传参</span></span><br><span class="line"><span class="comment">// foo(arr, arr.size()); // 非法, 无法隐式转换</span></span><br><span class="line"><span class="built_in">foo</span>(&amp;arr[<span class="number">0</span>], arr.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">foo</span>(arr.<span class="built_in">data</span>(), arr.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `std::sort`</span></span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h3 id="std-forward-list"><a href="#std-forward-list" class="headerlink" title="std::forward_list"></a><code>std::forward_list</code></h3><p><code>std::forward_list</code> 是一个列表容器，使用方法和 <code>std::list</code> 基本类似，因此我们就不花费篇幅进行介绍了。</p>
<p>需要知道的是，和 <code>std::list</code> 的双向链表的实现不同，<code>std::forward_list</code> 使用单向链表进行实现，<br>提供了 <code>O(1)</code> 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），<br>也是标准库容器中唯一一个不提供 <code>size()</code> 方法的容器。当不需要双向迭代时，具有比 <code>std::list</code> 更高的空间利用率。</p>
<h2 id="4-2-无序容器"><a href="#4-2-无序容器" class="headerlink" title="4.2 无序容器"></a>4.2 无序容器</h2><p>我们已经熟知了传统 C++ 中的有序容器 <code>std::map</code>/<code>std::set</code>，这些元素内部通过红黑树进行实现，<br>插入和搜索的平均复杂度均为 <code>O(log(size))</code>。在插入元素时候，会根据 <code>&lt;</code> 操作符比较元素大小并判断元素是否相同，<br>并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 <code>&lt;</code> 操作符的顺序来逐个遍历。</p>
<p>而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 <code>O(constant)</code>，<br>在不关心容器内部元素顺序时，能够获得显著的性能提升。</p>
<p>C++11 引入了的两组无序容器分别是：<code>std::unordered_map</code>/<code>std::unordered_multimap</code> 和<br><code>std::unordered_set</code>/<code>std::unordered_multiset</code>。</p>
<p>它们的用法和原有的 <code>std::map</code>/<code>std::multimap</code>/<code>std::set</code>/<code>set::multiset</code> 基本类似，<br>由于这些容器我们已经很熟悉了，便不一一举例，我们直接来比较一下<code>std::map</code>和<code>std::unordered_map</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两组结构按同样的顺序初始化</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::string&gt; u = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="string">&quot;3&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; v = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="string">&quot;3&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别对两组结构进行遍历</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::unordered_map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">const</span> <span class="keyword">auto</span> &amp; n : u)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key:[&quot;</span> &lt;&lt; n.first &lt;&lt; <span class="string">&quot;] Value:[&quot;</span> &lt;&lt; n.second &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">const</span> <span class="keyword">auto</span> &amp; n : v)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key:[&quot;</span> &lt;&lt; n.first &lt;&lt; <span class="string">&quot;] Value:[&quot;</span> &lt;&lt; n.second &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的输出结果为：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map</span><br><span class="line">Key:[2] Value:[2]</span><br><span class="line">Key:[3] Value:[3]</span><br><span class="line">Key:[1] Value:[1]</span><br><span class="line"></span><br><span class="line">std::map</span><br><span class="line">Key:[1] Value:[1]</span><br><span class="line">Key:[2] Value:[2]</span><br><span class="line">Key:[3] Value:[3]</span><br></pre></td></tr></table></figure>
<h2 id="4-3-元组"><a href="#4-3-元组" class="headerlink" title="4.3 元组"></a>4.3 元组</h2><p>了解过 Python 的程序员应该知道元组的概念，纵观传统 C++ 中的容器，除了 <code>std::pair</code> 外，<br>似乎没有现成的结构能够用来存放不同类型的数据（通常我们会自己定义结构）。<br>但 <code>std::pair</code> 的缺陷是显而易见的，只能保存两个元素。</p>
<h3 id="元组基本操作"><a href="#元组基本操作" class="headerlink" title="元组基本操作"></a>元组基本操作</h3><p>关于元组的使用有三个核心的函数：</p>
<ol>
<li><code>std::make_tuple</code>: 构造元组</li>
<li><code>std::get</code>: 获得元组某个位置的值</li>
<li><code>std::tie</code>: 元组拆包</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_student</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回类型被推断为 std::tuple&lt;double, char, std::string&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">3.8</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">2.9</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">1.7</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">0.0</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果只写 0 会出现推断错误, 编译失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> student = <span class="built_in">get_student</span>(<span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: 0, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;GPA: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;成绩: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(student) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> gpa;</span><br><span class="line">    <span class="type">char</span> grade;</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元组进行拆包</span></span><br><span class="line">    std::<span class="built_in">tie</span>(gpa, grade, name) = <span class="built_in">get_student</span>(<span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: 1, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;GPA: &quot;</span> &lt;&lt; gpa &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;成绩: &quot;</span> &lt;&lt; grade &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">    &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::get</code> 除了使用常量获取元组对象外，C++14 增加了使用类型来获取元组中的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">double</span>, <span class="type">double</span>, <span class="type">int</span>&gt; <span class="title">t</span><span class="params">(<span class="string">&quot;123&quot;</span>, <span class="number">4.5</span>, <span class="number">6.7</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;std::string&gt;(t) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="type">double</span>&gt;(t) &lt;&lt; std::endl; <span class="comment">// 非法, 引发编译期错误</span></span><br><span class="line">std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(t) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h3 id="运行期索引"><a href="#运行期索引" class="headerlink" title="运行期索引"></a>运行期索引</h3><p>如果你仔细思考一下可能就会发现上面代码的问题，<code>std::get&lt;&gt;</code> 依赖一个编译期的常量，所以下面的方式是不合法的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line">std::<span class="built_in">get</span>&lt;index&gt;(t);</span><br></pre></td></tr></table></figure>
<p>那么要怎么处理？答案是，使用 <code>std::variant&lt;&gt;</code>（C++ 17 引入），提供给 <code>variant&lt;&gt;</code> 的类型模板参数<br>可以让一个 <code>variant&lt;&gt;</code> 从而容纳提供的几种类型的变量（在其他语言，例如 Python/JavaScript 等，表现为动态类型）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> n, <span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> std::variant&lt;T...&gt; _tuple_index(<span class="type">const</span> std::tuple&lt;T...&gt;&amp; tpl, <span class="type">size_t</span> i) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(n &gt;= <span class="keyword">sizeof</span>...(T))</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throw</span> <span class="title">std::out_of_range</span><span class="params">(<span class="string">&quot;越界.&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (i == n)</span><br><span class="line">        <span class="keyword">return</span> std::variant&lt;T...&gt;&#123; std::in_place_index&lt;n&gt;, std::<span class="built_in">get</span>&lt;n&gt;(tpl) &#125;;</span><br><span class="line">    <span class="keyword">return</span> _tuple_index&lt;(n &lt; <span class="keyword">sizeof</span>...(T)<span class="number">-1</span> ? n+<span class="number">1</span> : <span class="number">0</span>)&gt;(tpl, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::variant&lt;T...&gt; <span class="title">tuple_index</span><span class="params">(<span class="type">const</span> std::tuple&lt;T...&gt;&amp; tpl, <span class="type">size_t</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _tuple_index&lt;<span class="number">0</span>&gt;(tpl, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line">std::ostream &amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream &amp; s, std::variant&lt;T0, Ts...&gt; <span class="type">const</span> &amp; v) &#123; </span><br><span class="line">    std::<span class="built_in">visit</span>([&amp;](<span class="keyword">auto</span> &amp;&amp; x)&#123; s &lt;&lt; x;&#125;, v); </span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">tuple_index</span>(t, i) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h3 id="元组合并与遍历"><a href="#元组合并与遍历" class="headerlink" title="元组合并与遍历"></a>元组合并与遍历</h3><p>还有一个常见的需求就是合并两个元组，这可以通过 <code>std::tuple_cat</code> 来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> new_tuple = std::<span class="built_in">tuple_cat</span>(<span class="built_in">get_student</span>(<span class="number">1</span>), std::<span class="built_in">move</span>(t));</span><br></pre></td></tr></table></figure>
<p>马上就能够发现，应该如何快速遍历一个元组？但是我们刚才介绍了如何在运行期通过非常数索引一个 <code>tuple</code> 那么遍历就变得简单了，<br>首先我们需要知道一个元组的长度，可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">tuple_len</span><span class="params">(T &amp;tpl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::tuple_size&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就能够对元组进行迭代了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i != <span class="built_in">tuple_len</span>(new_tuple); ++i)</span><br><span class="line">    <span class="comment">// 运行期索引</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">tuple_index</span>(new_tuple, i) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>本章简单介绍了现代 C++ 中新增的容器，它们的用法和传统 C++ 中已有的容器类似，相对简单，可以根据实际场景丰富的选择需要使用的容器，从而获得更好的性能。</p>
<p><code>std::tuple</code> 虽然有效，但是标准库提供的功能有限，没办法满足运行期索引和迭代的需求，好在我们还有其他的方法可以自行实现。</p>
<h1 id="第-5-章-智能指针与内存管理"><a href="#第-5-章-智能指针与内存管理" class="headerlink" title="第 5 章 智能指针与内存管理"></a>第 5 章 智能指针与内存管理</h1><h2 id="5-1-RAII-与引用计数"><a href="#5-1-RAII-与引用计数" class="headerlink" title="5.1 RAII 与引用计数"></a>5.1 RAII 与引用计数</h2><p>了解 <code>Objective-C</code>/<code>Swift</code> 的程序员应该知道引用计数的概念。引用计数这种计数是为了防止内存泄露而产生的。<br>基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次，<br>每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。</p>
<p>在传统 C++ 中，『记得』手动释放资源，总不是最佳实践。因为我们很有可能就忘记了去释放资源而导致泄露。<br>所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，<br>也就是我们常说的 RAII 资源获取即初始化技术。</p>
<p>凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 <code>new</code> 和 <code>delete</code> 去<br>『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。<br>这些智能指针包括 <code>std::shared_ptr</code>/<code>std::unique_ptr</code>/<code>std::weak_ptr</code>，使用它们需要包含头文件 <code>&lt;memory&gt;</code>。</p>
<blockquote>
<p>注意：引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待，<br>更能够清晰明确的表明资源的生命周期。</p>
</blockquote>
<h2 id="5-2-std-shared-ptr"><a href="#5-2-std-shared-ptr" class="headerlink" title="5.2 std::shared_ptr"></a>5.2 <code>std::shared_ptr</code></h2><p><code>std::shared_ptr</code> 是一种智能指针，它能够记录多少个 <code>shared_ptr</code> 共同指向一个对象，从而消除显式的调用<br><code>delete</code>，当引用计数变为零的时候就会将对象自动删除。</p>
<p>但还不够，因为使用 <code>std::shared_ptr</code> 仍然需要使用 <code>new</code> 来调用，这使得代码出现了某种程度上的不对称。</p>
<p><code>std::make_shared</code> 就能够用来消除显式的使用 <code>new</code>，所以<code>std::make_shared</code> 会分配创建传入参数中的对象，<br>并返回这个对象类型的<code>std::shared_ptr</code>指针。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::shared_ptr&lt;<span class="type">int</span>&gt; i)</span> </span>&#123;</span><br><span class="line">    (*i)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// auto pointer = new int(10); // illegal, no direct assignment</span></span><br><span class="line">    <span class="comment">// Constructed a std::shared_ptr</span></span><br><span class="line">    <span class="keyword">auto</span> pointer = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">foo</span>(pointer);</span><br><span class="line">    std::cout &lt;&lt; *pointer &lt;&lt; std::endl; <span class="comment">// 11</span></span><br><span class="line">    <span class="comment">// The shared_ptr will be destructed before leaving the scope</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::shared_ptr</code> 可以通过 <code>get()</code> 方法来获取原始指针，通过 <code>reset()</code> 来减少一个引用计数，<br>并通过<code>use_count()</code>来查看一个对象的引用计数。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pointer = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">auto</span> pointer2 = pointer; <span class="comment">// 引用计数+1</span></span><br><span class="line"><span class="keyword">auto</span> pointer3 = pointer; <span class="comment">// 引用计数+1</span></span><br><span class="line"><span class="type">int</span> *p = pointer.<span class="built_in">get</span>();  <span class="comment">// 这样不会增加引用计数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.<span class="built_in">use_count</span>() &lt;&lt; std::endl;   <span class="comment">// 3</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span> &lt;&lt; pointer2.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 3</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer3.use_count() = &quot;</span> &lt;&lt; pointer3.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">pointer2.<span class="built_in">reset</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;reset pointer2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.<span class="built_in">use_count</span>() &lt;&lt; std::endl;   <span class="comment">// 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span></span><br><span class="line">          &lt;&lt; pointer2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;           <span class="comment">// pointer2 已 reset; 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer3.use_count() = &quot;</span> &lt;&lt; pointer3.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 2</span></span><br><span class="line">pointer3.<span class="built_in">reset</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;reset pointer3:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.<span class="built_in">use_count</span>() &lt;&lt; std::endl;   <span class="comment">// 1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span> &lt;&lt; pointer2.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer3.use_count() = &quot;</span></span><br><span class="line">          &lt;&lt; pointer3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;           <span class="comment">// pointer3 已 reset; 0</span></span><br></pre></td></tr></table></figure>
<h2 id="5-3-std-unique-ptr"><a href="#5-3-std-unique-ptr" class="headerlink" title="5.3 std::unique_ptr"></a>5.3 <code>std::unique_ptr</code></h2><p><code>std::unique_ptr</code> 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; pointer = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>); <span class="comment">// make_unique 从 C++14 引入</span></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; pointer2 = pointer; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>make_unique</code> 并不复杂，C++11 没有提供 <code>std::make_unique</code>，可以自行实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">( Args&amp;&amp; ...args )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;( <span class="keyword">new</span> <span class="built_in">T</span>( std::forward&lt;Args&gt;(args)... ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于为什么没有提供，C++ 标准委员会主席 Herb Sutter 在他的<a target="_blank" rel="noopener" href="https://herbsutter.com/gotw/_102/">博客</a>中提到原因是因为『被他们忘记了』。</p>
</blockquote>
<p>既然是独占，换句话说就是不可复制。但是，我们可以利用 <code>std::move</code> 将其转移给其他的 <code>unique_ptr</code>，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Foo::Foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Foo::~Foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Foo::foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Foo &amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f(const Foo&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Foo&gt; <span class="title">p1</span><span class="params">(std::make_unique&lt;Foo&gt;())</span></span>;</span><br><span class="line">    <span class="comment">// p1 不空, 输出</span></span><br><span class="line">    <span class="keyword">if</span> (p1) p1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;Foo&gt; <span class="title">p2</span><span class="params">(std::move(p1))</span></span>;</span><br><span class="line">        <span class="comment">// p2 不空, 输出</span></span><br><span class="line">        <span class="built_in">f</span>(*p2);</span><br><span class="line">        <span class="comment">// p2 不空, 输出</span></span><br><span class="line">        <span class="keyword">if</span>(p2) p2-&gt;<span class="built_in">foo</span>();</span><br><span class="line">        <span class="comment">// p1 为空, 无输出</span></span><br><span class="line">        <span class="keyword">if</span>(p1) p1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">        p1 = std::<span class="built_in">move</span>(p2);</span><br><span class="line">        <span class="comment">// p2 为空, 无输出</span></span><br><span class="line">        <span class="keyword">if</span>(p2) p2-&gt;<span class="built_in">foo</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p2 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p1 不空, 输出</span></span><br><span class="line">    <span class="keyword">if</span> (p1) p1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    <span class="comment">// Foo 的实例会在离开作用域时被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-std-weak-ptr"><a href="#5-4-std-weak-ptr" class="headerlink" title="5.4 std::weak_ptr"></a>5.4 <code>std::weak_ptr</code></h2><p>如果你仔细思考 <code>std::shared_ptr</code> 就会发现依然存在着资源无法释放的问题。看下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;B&gt; pointer;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; pointer;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;pointer = b;</span><br><span class="line">    b-&gt;pointer = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 <code>a,b</code>，这使得 <code>a,b</code> 的引用计数均变为了 2，而离开作用域时，<code>a,b</code> 智能指针被析构，却只能造成这块区域的引用计数减一，这样就导致了 <code>a,b</code> 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露，如图 5.1：</p>
<p><img src="../../assets/figures/pointers1.png" alt="图 5.1"></p>
<p>解决这个问题的办法就是使用弱引用指针 <code>std::weak_ptr</code>，<code>std::weak_ptr</code>是一种弱引用（相比较而言 <code>std::shared_ptr</code> 就是一种强引用）。弱引用不会引起引用计数增加，当换用弱引用时候，最终的释放流程如图 5.2 所示：</p>
<p><img src="../../assets/figures/pointers2.png" alt="图 5.2"></p>
<p>在上图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。</p>
<p><code>std::weak_ptr</code> 没有 <code>*</code> 运算符和 <code>-&gt;</code> 运算符，所以不能够对资源进行操作，它可以用于检查 <code>std::shared_ptr</code> 是否存在，其 <code>expired()</code> 方法能在资源未被释放时，会返回 <code>false</code>，否则返回 <code>true</code>；除此之外，它也可以用于获取指向原始对象的 <code>std::shared_ptr</code> 指针，其 <code>lock()</code> 方法在原始对象未被释放时，返回一个指向原始对象的 <code>std::shared_ptr</code> 指针，进而访问原始对象的资源，否则返回<code>nullptr</code>。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>智能指针这种技术并不新奇，在很多语言中都是一种常见的技术，现代 C++ 将这项技术引进，在一定程度上消除了 <code>new</code>/<code>delete</code> 的滥用，是一种更加成熟的编程范式。</p>
<h1 id="第-6-章-正则表达式"><a href="#第-6-章-正则表达式" class="headerlink" title="第 6 章 正则表达式"></a>第 6 章 正则表达式</h1><h2 id="6-1-正则表达式简介"><a href="#6-1-正则表达式简介" class="headerlink" title="6.1 正则表达式简介"></a>6.1 正则表达式简介</h2><p>正则表达式不是 C++ 语言的一部分，这里仅做简单的介绍。</p>
<p>正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：</p>
<ol>
<li>检查一个串是否包含某种形式的子串；</li>
<li>将匹配的子串替换；</li>
<li>从某个串中取出符合条件的子串。</li>
</ol>
<p>正则表达式是由普通字符（例如 a 到 z）以及特殊字符组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。<br>正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
<h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>特殊字符是正则表达式里有特殊含义的字符，也是正则表达式的核心匹配语法。参见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特别字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>$</code></td>
<td style="text-align:left">匹配输入字符串的结尾位置。</td>
</tr>
<tr>
<td style="text-align:center"><code>(</code>,<code>)</code></td>
<td style="text-align:left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:left">匹配前面的子表达式零次或多次。</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:left">匹配前面的子表达式一次或多次。</td>
</tr>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:left">匹配除换行符 <code>\n</code> 之外的任何单字符。</td>
</tr>
<tr>
<td style="text-align:center"><code>[</code></td>
<td style="text-align:left">标记一个中括号表达式的开始。</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td>
</tr>
<tr>
<td style="text-align:center"><code>\</code></td>
<td style="text-align:left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， <code>n</code> 匹配字符 <code>n</code>。<code>\n</code> 匹配换行符。序列 <code>\\</code> 匹配 <code>&#39;\&#39;</code> 字符，而 <code>\(</code> 则匹配 <code>&#39;(&#39;</code> 字符。</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:left">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。</td>
</tr>
<tr>
<td style="text-align:center"><code>&#123;</code></td>
<td style="text-align:left">标记限定符表达式的开始。</td>
</tr>
<tr>
<td style="text-align:center">`\</td>
<td style="text-align:left">`</td>
<td>指明两项之间的一个选择。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定的组件必须要出现多少次才能满足匹配。见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:left">匹配前面的子表达式零次或多次。例如，<code>foo*</code> 能匹配 <code>fo</code> 以及 <code>foooo</code>。<code>*</code> 等价于<code>&#123;0,&#125;</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:left">匹配前面的子表达式一次或多次。例如，<code>foo+</code> 能匹配 <code>foo</code> 以及 <code>foooo</code>，但不能匹配 <code>fo</code>。<code>+</code> 等价于 <code>&#123;1,&#125;</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:left">匹配前面的子表达式零次或一次。例如，<code>Your(s)?</code> 可以匹配 <code>Your</code> 或 <code>Yours</code> 中的<code>Your</code> 。<code>?</code> 等价于 <code>&#123;0,1&#125;</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>&#123;n&#125;</code></td>
<td style="text-align:left"><code>n</code> 是一个非负整数。匹配确定的 <code>n</code> 次。例如，<code>o&#123;2&#125;</code> 不能匹配 <code>for</code> 中的 <code>o</code>，但是能匹配 <code>foo</code> 中的两个 <code>o</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>&#123;n,&#125;</code></td>
<td style="text-align:left"><code>n</code> 是一个非负整数。至少匹配 <code>n</code> 次。例如，<code>o&#123;2,&#125;</code> 不能匹配 <code>for</code> 中的 <code>o</code>，但能匹配 <code>foooooo</code> 中的所有 <code>o</code>。<code>o&#123;1,&#125;</code> 等价于 <code>o+</code>。<code>o&#123;0,&#125;</code> 则等价于 <code>o*</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>&#123;n,m&#125;</code></td>
<td style="text-align:left"><code>m</code> 和 <code>n</code> 均为非负整数，其中 <code>n</code> 小于等于 <code>m</code>。最少匹配 <code>n</code> 次且最多匹配 <code>m</code> 次。例如，<code>o&#123;1,3&#125;</code> 将匹配 <code>foooooo</code> 中的前三个 <code>o</code>。<code>o&#123;0,1&#125;</code> 等价于 <code>o?</code>。注意，在逗号和两个数之间不能有空格。</td>
</tr>
</tbody>
</table>
</div>
<p>有了这两张表，我们通常就能够读懂几乎所有的正则表达式了。</p>
<h2 id="6-2-std-regex-及其相关"><a href="#6-2-std-regex-及其相关" class="headerlink" title="6.2 std::regex 及其相关"></a>6.2 std::regex 及其相关</h2><p>对字符串内容进行匹配的最常见手段就是使用正则表达式。<br>可惜在传统 C++ 中正则表达式一直没有得到语言层面的支持，没有纳入标准库，<br>而 C++ 作为一门高性能语言，在后台服务的开发中，对 URL 资源链接进行判断时，<br>使用正则表达式也是工业界最为成熟的普遍做法。</p>
<p>一般的解决方案就是使用 <code>boost</code> 的正则表达式库。<br>而 C++11 正式将正则表达式的的处理方法纳入标准库的行列，从语言级上提供了标准的支持，<br>不再依赖第三方。</p>
<p>C++11 提供的正则表达式库操作 <code>std::string</code> 对象，<br>模式 <code>std::regex</code> (本质是 <code>std::basic_regex</code>)进行初始化，<br>通过 <code>std::regex_match</code> 进行匹配，<br>从而产生 <code>std::smatch</code> （本质是 <code>std::match_results</code> 对象）。</p>
<p>我们通过一个简单的例子来简单介绍这个库的使用。考虑下面的正则表达式:</p>
<ul>
<li><code>[a-z]+\.txt</code>: 在这个正则表达式中, <code>[a-z]</code> 表示匹配一个小写字母, <code>+</code> 可以使前面的表达式匹配多次，<br>因此 <code>[a-z]+</code> 能够匹配一个小写字母组成的字符串。<br>在正则表达式中一个 <code>.</code> 表示匹配任意字符，而 <code>\.</code> 则表示匹配字符 <code>.</code>，<br>最后的 <code>txt</code> 表示严格匹配 <code>txt</code> 则三个字母。因此这个正则表达式的所要匹配的内容就是由纯小写字母组成的文本文件。</li>
</ul>
<p><code>std::regex_match</code> 用于匹配字符串和正则表达式，有很多不同的重载形式。<br>最简单的一个形式就是传入 <code>std::string</code> 以及一个 <code>std::regex</code> 进行匹配，<br>当匹配成功时，会返回 <code>true</code>，否则返回 <code>false</code>。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string fnames[] = &#123;<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;bar.txt&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;a0.txt&quot;</span>, <span class="string">&quot;AAA.txt&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 在 C++ 中 \ 会被作为字符串内的转义符，</span></span><br><span class="line">    <span class="comment">// 为使 \. 作为正则表达式传递进去生效，需要对 \ 进行二次转义，从而有 \\.</span></span><br><span class="line">    <span class="function">std::regex <span class="title">txt_regex</span><span class="params">(<span class="string">&quot;[a-z]+\\.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;fname: fnames)</span><br><span class="line">        std::cout &lt;&lt; fname &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; std::<span class="built_in">regex_match</span>(fname, txt_regex) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种常用的形式就是依次传入 <code>std::string</code>/<code>std::smatch</code>/<code>std::regex</code> 三个参数，<br>其中 <code>std::smatch</code> 的本质其实是 <code>std::match_results</code>。<br>故而在标准库的实现中， <code>std::smatch</code> 被定义为了 <code>std::match_results&lt;std::string::const_iterator&gt;</code>，<br>也就是一个子串迭代器类型的 <code>match_results</code>。<br>使用 <code>std::smatch</code> 可以方便的对匹配的结果进行获取，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::regex <span class="title">base_regex</span><span class="params">(<span class="string">&quot;([a-z]+)\\.txt&quot;</span>)</span></span>;</span><br><span class="line">std::smatch base_match;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;fname: fnames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_match</span>(fname, base_match, base_regex)) &#123;</span><br><span class="line">        <span class="comment">// std::smatch 的第一个元素匹配整个字符串</span></span><br><span class="line">        <span class="comment">// std::smatch 的第二个元素匹配了第一个括号表达式</span></span><br><span class="line">        <span class="keyword">if</span> (base_match.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">            std::string base = base_match[<span class="number">1</span>].<span class="built_in">str</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;sub-match[0]: &quot;</span> &lt;&lt; base_match[<span class="number">0</span>].<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; fname &lt;&lt; <span class="string">&quot; sub-match[1]: &quot;</span> &lt;&lt; base &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上两个代码段的输出结果为：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo.txt: 1</span><br><span class="line">bar.txt: 1</span><br><span class="line">test: 0</span><br><span class="line">a0.txt: 0</span><br><span class="line">AAA.txt: 0</span><br><span class="line">sub-match[0]: foo.txt</span><br><span class="line">foo.txt sub-match[1]: foo</span><br><span class="line">sub-match[0]: bar.txt</span><br><span class="line">bar.txt sub-match[1]: bar</span><br></pre></td></tr></table></figure>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>本节简单介绍了正则表达式本身，然后根据使用正则表达式的主要需求，通过一个实际的例子介绍了正则表达式库的使用。</p>
<h1 id="第-7-章-并行与并发"><a href="#第-7-章-并行与并发" class="headerlink" title="第 7 章 并行与并发"></a>第 7 章 并行与并发</h1><h2 id="7-1-并行基础"><a href="#7-1-并行基础" class="headerlink" title="7.1 并行基础"></a>7.1 并行基础</h2><p><code>std::thread</code> 用于创建一个执行的线程实例，所以它是一切并发编程的基础，使用时需要包含 <code>&lt;thread&gt;</code> 头文件，<br>它提供了很多基本的线程操作，例如 <code>get_id()</code> 来获取所创建线程的线程 ID，使用 <code>join()</code> 来加入一个线程等等，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;hello world.&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-2-互斥量与临界区"><a href="#7-2-互斥量与临界区" class="headerlink" title="7.2 互斥量与临界区"></a>7.2 互斥量与临界区</h2><p>我们在操作系统、亦或是数据库的相关知识中已经了解过了有关并发技术的基本知识，<code>mutex</code> 就是其中的核心之一。<br>C++11 引入了 <code>mutex</code> 相关的类，其所有相关的函数都放在 <code>&lt;mutex&gt;</code> 头文件中。</p>
<p><code>std::mutex</code> 是 C++11 中最基本的 <code>mutex</code> 类，通过实例化 <code>std::mutex</code> 可以创建互斥量，<br>而通过其成员函数 <code>lock()</code> 可以进行上锁，<code>unlock()</code> 可以进行解锁。<br>但是在实际编写代码的过程中，最好不去直接调用成员函数，<br>因为调用成员函数就需要在每个临界区的出口处调用 <code>unlock()</code>，当然，还包括异常。<br>这时候 C++11 还为互斥量提供了一个 RAII 语法的模板类 <code>std::lock_guard</code>。<br>RAII 在不失代码简洁性的同时，很好的保证了代码的异常安全性。</p>
<p>在 RAII 用法下，对于临界区的互斥量的创建只需要在作用域的开始部分，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">critical_section</span><span class="params">(<span class="type">int</span> change_v)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行竞争操作</span></span><br><span class="line">    v = change_v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 离开此作用域后 mtx 会被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(critical_section, <span class="number">2</span>)</span>, <span class="title">t2</span><span class="params">(critical_section, <span class="number">3</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 C++ 保证了所有栈对象在生命周期结束时会被销毁，所以这样的代码也是异常安全的。<br>无论 <code>critical_section()</code> 正常返回、还是在中途抛出异常，都会引发堆栈回退，也就自动调用了 <code>unlock()</code>。</p>
<p>而 <code>std::unique_lock</code> 则是相对于 <code>std::lock_guard</code> 出现的，<code>std::unique_lock</code> 更加灵活，<br><code>std::unique_lock</code> 的对象会以独占所有权（没有其他的 <code>unique_lock</code> 对象同时拥有某个 <code>mutex</code> 对象的所有权）<br>的方式管理 <code>mutex</code> 对象上的上锁和解锁的操作。所以在并发编程中，推荐使用 <code>std::unique_lock</code>。</p>
<p><code>std::lock_guard</code> 不能显式的调用 <code>lock</code> 和 <code>unlock</code>， 而 <code>std::unique_lock</code> 可以在声明后的任意位置调用，<br>可以缩小锁的作用范围，提供更高的并发度。</p>
<p>如果你用到了条件变量 <code>std::condition_variable::wait</code> 则必须使用 <code>std::unique_lock</code> 作为参数。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">critical_section</span><span class="params">(<span class="type">int</span> change_v)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 执行竞争操作</span></span><br><span class="line">    v = change_v;</span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 将锁进行释放</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此期间，任何人都可以抢夺 v 的持有权</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始另一组竞争操作，再次加锁</span></span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line">    v += <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(critical_section, <span class="number">2</span>)</span>, <span class="title">t2</span><span class="params">(critical_section, <span class="number">3</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-3-期物"><a href="#7-3-期物" class="headerlink" title="7.3 期物"></a>7.3 期物</h2><p>期物（Future）表现为 <code>std::future</code>，它提供了一个访问异步操作结果的途径，这句话很不好理解。<br>为了理解这个特性，我们需要先理解一下在 C++11 之前的多线程行为。</p>
<p>试想，如果我们的主线程 A 希望新开辟一个线程 B 去执行某个我们预期的任务，并返回我一个结果。<br>而这时候，线程 A 可能正在忙其他的事情，无暇顾及 B 的结果，<br>所以我们会很自然的希望能够在某个特定的时间获得线程 B 的结果。</p>
<p>在 C++11 的 <code>std::future</code> 被引入之前，通常的做法是：<br>创建一个线程 A，在线程 A 里启动任务 B，当准备完毕后发送一个事件，并将结果保存在全局变量中。<br>而主函数线程 A 里正在做其他的事情，当需要结果的时候，调用一个线程等待函数来获得执行的结果。</p>
<p>而 C++11 提供的 <code>std::future</code> 简化了这个流程，可以用来获取异步任务的结果。<br>自然地，我们很容易能够想象到把它作为一种简单的线程同步手段，即屏障（barrier）。</p>
<p>为了看一个例子，我们这里额外使用 <code>std::packaged_task</code>，它可以用来封装任何可以调用的目标，从而用于实现异步的调用。<br>举例来说：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将一个返回值为7的 lambda 表达式封装到 task 中</span></span><br><span class="line">    <span class="comment">// std::packaged_task 的模板参数为要封装函数的类型</span></span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">([]()&#123;<span class="keyword">return</span> <span class="number">7</span>;&#125;)</span></span>;</span><br><span class="line">    <span class="comment">// 获得 task 的期物</span></span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>(); <span class="comment">// 在一个线程中执行 task</span></span><br><span class="line">    std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task)).<span class="built_in">detach</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;waiting...&quot;</span>;</span><br><span class="line">    result.<span class="built_in">wait</span>(); <span class="comment">// 在此设置屏障，阻塞到期物的完成</span></span><br><span class="line">    <span class="comment">// 输出执行结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;done!&quot;</span> &lt;&lt; std:: endl &lt;&lt; <span class="string">&quot;future result is &quot;</span></span><br><span class="line">              &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在封装好要调用的目标后，可以使用 <code>get_future()</code> 来获得一个 <code>std::future</code> 对象，以便之后实施线程同步。</p>
<h2 id="7-4-条件变量"><a href="#7-4-条件变量" class="headerlink" title="7.4 条件变量"></a>7.4 条件变量</h2><p>条件变量 <code>std::condition_variable</code> 是为了解决死锁而生，当互斥操作不够用而引入的。<br>比如，线程可能需要等待某个条件为真才能继续执行，<br>而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。<br>所以，<code>condition_variable</code> 实例被创建出现主要就是用于唤醒等待线程从而避免死锁。<br><code>std::condition_variable</code>的 <code>notify_one()</code> 用于唤醒一个线程；<br><code>notify_all()</code> 则是通知所有线程。下面是一个生产者和消费者模型的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; produced_nums;</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    std::condition_variable cv;</span><br><span class="line">    <span class="type">bool</span> notified = <span class="literal">false</span>;  <span class="comment">// 通知信号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者</span></span><br><span class="line">    <span class="keyword">auto</span> producer = [&amp;]() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">900</span>));</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;producing &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">            produced_nums.<span class="built_in">push</span>(i);</span><br><span class="line">            notified = <span class="literal">true</span>;</span><br><span class="line">            cv.<span class="built_in">notify_all</span>(); <span class="comment">// 此处也可以使用 notify_one</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 消费者</span></span><br><span class="line">    <span class="keyword">auto</span> consumer = [&amp;]() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">            <span class="keyword">while</span> (!notified) &#123;  <span class="comment">// 避免虚假唤醒</span></span><br><span class="line">                cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 短暂取消锁，使得生产者有机会在消费者消费空前继续生产</span></span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="comment">// 消费者慢于生产者</span></span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1000</span>));</span><br><span class="line">            lock.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">while</span> (!produced_nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;consuming &quot;</span> &lt;&lt; produced_nums.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">                produced_nums.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            notified = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别在不同的线程中运行</span></span><br><span class="line">    <span class="function">std::thread <span class="title">p</span><span class="params">(producer)</span></span>;</span><br><span class="line">    std::thread cs[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        cs[i] = std::<span class="built_in">thread</span>(consumer);</span><br><span class="line">    &#125;</span><br><span class="line">    p.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        cs[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，在生产者中我们虽然可以使用 <code>notify_one()</code>，但实际上并不建议在此处使用，<br>因为在多消费者的情况下，我们的消费者实现中简单放弃了锁的持有，这使得可能让其他消费者<br>争夺此锁，从而更好的利用多个消费者之间的并发。话虽如此，但实际上因为 <code>std::mutex</code> 的排他性，<br>我们根本无法期待多个消费者能真正意义上的并行消费队列的中生产的内容，我们仍需要粒度更细的手段。</p>
<h2 id="7-5-原子操作与内存模型"><a href="#7-5-原子操作与内存模型" class="headerlink" title="7.5 原子操作与内存模型"></a>7.5 原子操作与内存模型</h2><p>细心的读者可能会对前一小节中生产者消费者模型的例子可能存在编译器优化导致程序出错的情况产生疑惑。<br>例如，布尔值 <code>notified</code> 没有被 <code>volatile</code> 修饰，编译器可能对此变量存在优化，例如将其作为一个寄存器的值，<br>从而导致消费者线程永远无法观察到此值的变化。这是一个好问题，为了解释清楚这个问题，我们需要进一步讨论<br>从 C++ 11 起引入的内存模型这一概念。我们首先来看一个问题，下面这段代码输出结果是多少？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">while</span> (flag != <span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> b = a;</span></span></span><br><span class="line"><span class="params"><span class="function">        std::cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        a = <span class="number">5</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        flag = <span class="number">1</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从直观上看，<code>t2</code> 中 <code>a = 5;</code> 这一条语句似乎总在 <code>flag = 1;</code> 之前得到执行，而 <code>t1</code> 中 <code>while (flag != 1)</code><br>似乎保证了 <code>std::cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; std::endl;</code> 不会再标记被改变前执行。从逻辑上看，似乎 <code>b</code> 的值应该等于 5。<br>但实际情况远比此复杂得多，或者说这段代码本身属于未定义的行为，因为对于 <code>a</code> 和 <code>flag</code> 而言，他们在两个并行的线程中被读写，<br>出现了竞争。除此之外，即便我们忽略竞争读写，仍然可能受 CPU 的乱序执行，编译器对指令的重排的影响，<br>导致 <code>a = 5</code> 发生在 <code>flag = 1</code> 之后。从而 <code>b</code> 可能输出 0。</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p><code>std::mutex</code> 可以解决上面出现的并发读写的问题，但互斥锁是操作系统级的功能，<br>这是因为一个互斥锁的实现通常包含两条基本原理：</p>
<ol>
<li>提供线程间自动的状态转换，即『锁住』这个状态</li>
<li>保障在互斥锁操作期间，所操作变量的内存与临界区外进行隔离</li>
</ol>
<p>这是一组非常强的同步条件，换句话说当最终编译为 CPU 指令时会表现为非常多的指令（我们之后再来看如何实现一个简单的互斥锁）。<br>这对于一个仅需原子级操作（没有中间态）的变量，似乎太苛刻了。</p>
<p>关于同步条件的研究有着非常久远的历史，我们在这里不进行赘述。读者应该明白，现代 CPU 体系结构提供了 CPU 指令级的原子操作，<br>因此在 C++11 中多线程下共享变量的读写这一问题上，还引入了 <code>std::atomic</code> 模板，使得我们实例化一个原子类型，将一个<br>原子类型读写操作从一组指令，最小化到单个 CPU 指令。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; counter;</span><br></pre></td></tr></table></figure>
<p>并为整数或浮点数的原子类型提供了基本的数值成员函数，举例来说，<br>包括 <code>fetch_add</code>, <code>fetch_sub</code> 等，同时通过重载方便的提供了对应的 <code>+</code>，<code>-</code> 版本。<br>比如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; count = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        count.fetch_add(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">([]()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        count++;        <span class="comment">// 等价于 fetch_add</span></span></span></span><br><span class="line"><span class="params"><span class="function">        count += <span class="number">1</span>;     <span class="comment">// 等价于 fetch_add</span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，并非所有的类型都能提供原子操作，这是因为原子操作的可行性取决于具体的 CPU 架构，以及所实例化的类型结构是否能够满足该 CPU 架构对内存对齐<br>条件的要求，因而我们总是可以通过 <code>std::atomic&lt;T&gt;::is_lock_free</code> 来检查该原子类型是否需支持原子操作，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::atomic&lt;A&gt; a;</span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; a.<span class="built_in">is_lock_free</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><p>并行执行的多个线程，从某种宏观层面上讨论，可以粗略的视为一种分布式系统。<br>在分布式系统中，任何通信乃至本地操作都需要消耗一定时间，甚至出现不可靠的通信。</p>
<p>如果我们强行将一个变量 <code>v</code> 在多个线程之间的操作设为原子操作，即任何一个线程在操作完 <code>v</code> 后，<br>其他线程均能<strong>同步</strong>感知到 <code>v</code> 的变化，则对于变量 <code>v</code> 而言，表现为顺序执行的程序，它并没有由于引入多线程<br>而得到任何效率上的收益。对此有什么办法能够适当的加速呢？答案便是削弱原子操作的在进程间的同步条件。</p>
<p>从原理上看，每个线程可以对应为一个集群节点，而线程间的通信也几乎等价于集群节点间的通信。<br>削弱进程间的同步条件，通常我们会考虑四种不同的一致性模型：</p>
<ol>
<li><p>线性一致性：又称强一致性或原子一致性。它要求任何一次读操作都能读到某个数据的最近一次写的数据，并且所有线程的操作顺序与全局时钟下的顺序是一致的。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        x.store(1)      x.load()</span><br><span class="line">T1 ---------+----------------+------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T2 -------------------+-------------&gt;</span><br><span class="line">                x.store(2)</span><br></pre></td></tr></table></figure>
<p> 在这种情况下线程 <code>T1</code>, <code>T2</code> 对 <code>x</code> 的两次写操作是原子的，且 <code>x.store(1)</code> 是严格的发生在 <code>x.store(2)</code> 之前，<code>x.store(2)</code> 严格的发生在 <code>x.load()</code> 之前。<br> 值得一提的是，线性一致性对全局时钟的要求是难以实现的，这也是人们不断研究比这个一致性更弱条件下其他一致性的算法的原因。</p>
</li>
<li><p>顺序一致性：同样要求任何一次读操作都能读到数据最近一次写入的数据，但未要求与全局时钟的顺序一致。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        x.store(1)  x.store(3)   x.load()</span><br><span class="line">T1 ---------+-----------+----------+-----&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T2 ---------------+----------------------&gt;</span><br><span class="line">              x.store(2)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">        x.store(1)  x.store(3)   x.load()</span><br><span class="line">T1 ---------+-----------+----------+-----&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T2 ------+-------------------------------&gt;</span><br><span class="line">      x.store(2)</span><br></pre></td></tr></table></figure>
<p> 在顺序一致性的要求下，<code>x.load()</code> 必须读到最近一次写入的数据，因此 <code>x.store(2)</code> 与 <code>x.store(1)</code> 并无任何先后保障，即 只要 <code>T2</code> 的 <code>x.store(2)</code> 发生在 <code>x.store(3)</code> 之前即可。</p>
</li>
<li><p>因果一致性：它的要求进一步降低，只需要有因果关系的操作顺序得到保障，而非因果关系的操作顺序则不做要求。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">      a = 1      b = 2</span><br><span class="line">T1 ----+-----------+----------------------------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T2 ------+--------------------+--------+--------&gt;</span><br><span class="line">      x.store(3)         c = a + b    y.load()</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">      a = 1      b = 2</span><br><span class="line">T1 ----+-----------+----------------------------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T2 ------+--------------------+--------+--------&gt;</span><br><span class="line">      x.store(3)          y.load()   c = a + b</span><br><span class="line"></span><br><span class="line">亦或者</span><br><span class="line"></span><br><span class="line">     b = 2       a = 1</span><br><span class="line">T1 ----+-----------+----------------------------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T2 ------+--------------------+--------+--------&gt;</span><br><span class="line">      y.load()            c = a + b  x.store(3)</span><br></pre></td></tr></table></figure>
<p> 上面给出的三种例子都是属于因果一致的，因为整个过程中，只有 <code>c</code> 对 <code>a</code> 和 <code>b</code> 产生依赖，而 <code>x</code> 和 <code>y</code><br> 在此例子中表现为没有关系（但实际情况中我们需要更详细的信息才能确定 <code>x</code> 与 <code>y</code> 确实无关）</p>
</li>
<li><p>最终一致性：是最弱的一致性要求，它只保障某个操作在未来的某个时间节点上会被观察到，但并未要求被观察到的时间。因此我们甚至可以对此条件稍作加强，例如规定某个操作被观察到的时间总是有界的。当然这已经不在我们的讨论范围之内了。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    x.store(3)  x.store(4)</span><br><span class="line">T1 ----+-----------+--------------------------------------------&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T2 ---------+------------+--------------------+--------+--------&gt;</span><br><span class="line">         x.read      x.read()           x.read()   x.read()</span><br></pre></td></tr></table></figure>
<p> 在上面的情况中，如果我们假设 x 的初始值为 0，则 <code>T2</code> 中四次 <code>x.read()</code> 结果可能但不限于以下情况：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 4 4 4 // x 的写操作被很快观察到</span><br><span class="line">0 3 3 4 // x 的写操作被观察到的时间存在一定延迟</span><br><span class="line">0 0 0 4 // 最后一次读操作读到了 x 的最终值，但此前的变化并未观察到</span><br><span class="line">0 0 0 0 // 在当前时间段内 x 的写操作均未被观察到，</span><br><span class="line">        // 但未来某个时间点上一定能观察到 x 为 4 的情况</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="内存顺序"><a href="#内存顺序" class="headerlink" title="内存顺序"></a>内存顺序</h3><p>为了追求极致的性能，实现各种强度要求的一致性，C++11 为原子操作定义了六种不同的内存顺序 <code>std::memory_order</code> 的选项，表达了四种多线程间的同步模型：</p>
<ol>
<li><p>宽松模型：在此模型下，单个线程内的原子操作都是顺序执行的，不允许指令重排，但不同线程间原子操作的顺序是任意的。类型通过 <code>std::memory_order_relaxed</code> 指定。我们来看一个例子：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; counter = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::vector&lt;std::thread&gt; vt;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    vt.<span class="built_in">emplace_back</span>([&amp;]()&#123;</span><br><span class="line">        counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vt) &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;current counter:&quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放/消费模型：在此模型中，我们开始限制进程间的操作顺序，如果某个线程需要修改某个值，但另一个线程会对该值的某次操作产生依赖，即后者依赖前者。具体而言，线程 A 完成了三次对 <code>x</code> 的写操作，线程 <code>B</code> 仅依赖其中第三次 <code>x</code> 的写操作，与 <code>x</code> 的前两次写行为无关，则当 <code>A</code> 主动 <code>x.release()</code> 时候（即使用 <code>std::memory_order_release</code>），选项 <code>std::memory_order_consume</code> 能够确保 <code>B</code> 在调用 <code>x.load()</code> 时候观察到 <code>A</code> 中第三次对 <code>x</code> 的写操作。我们来看一个例子：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化为 nullptr 防止 consumer 线程从野指针进行读取</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>*&gt; <span class="title">ptr</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="function">std::thread <span class="title">producer</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    v = <span class="number">1024</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    ptr.store(p, std::memory_order_release);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">consumer</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>* p;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">while</span>(!(p = ptr.load(std::memory_order_consume)));</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; <span class="string">&quot;v: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">producer.<span class="built_in">join</span>();</span><br><span class="line">consumer.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放/获取模型：在此模型下，我们可以进一步加紧对不同线程间原子操作的顺序的限制，在释放 <code>std::memory_order_release</code> 和获取 <code>std::memory_order_acquire</code> 之间规定时序，即发生在释放（release）操作之前的<strong>所有</strong>写操作，对其他线程的任何获取（acquire）操作都是可见的，亦即发生顺序（happens-before）。</p>
<p> 可以看到，<code>std::memory_order_release</code> 确保了它之前的写操作不会发生在释放操作之后，是一个向后的屏障（backward），而 <code>std::memory_order_acquire</code> 确保了它之前的写行为不会发生在该获取操作之后，是一个向前的屏障（forward）。对于选项 <code>std::memory_order_acq_rel</code> 而言，则结合了这两者的特点，唯一确定了一个内存屏障，使得当前线程对内存的读写不会被重排并越过此操作的前后：</p>
<p> 我们来看一个例子：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; flag = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function">std::thread <span class="title">release</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    v.push_back(<span class="number">42</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">    flag.store(<span class="number">1</span>, std::memory_order_release);</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">acqrel</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> expected = <span class="number">1</span>; <span class="comment">// must before compare_exchange_strong</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">while</span>(!flag.compare_exchange_strong(expected, <span class="number">2</span>, std::memory_order_acq_rel))</span></span></span><br><span class="line"><span class="params"><span class="function">        expected = <span class="number">1</span>; <span class="comment">// must after compare_exchange_strong</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// flag has changed to 2</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">acquire</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">while</span>(flag.load(std::memory_order_acquire) &lt; <span class="number">2</span>);</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">    std::cout &lt;&lt; v.at(<span class="number">0</span>) &lt;&lt; std::endl; <span class="comment">// must be 42</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line">release.<span class="built_in">join</span>();</span><br><span class="line">acqrel.<span class="built_in">join</span>();</span><br><span class="line">acquire.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
<p> 在此例中我们使用了 <code>compare_exchange_strong</code> 比较交换原语（Compare-and-swap primitive），它有一个更弱的版本，即 <code>compare_exchange_weak</code>，它允许即便交换成功，也仍然返回 <code>false</code> 失败。其原因是因为在某些平台上虚假故障导致的，具体而言，当 CPU 进行上下文切换时，另一线程加载同一地址产生的不一致。除此之外，<code>compare_exchange_strong</code> 的性能可能稍差于 <code>compare_exchange_weak</code>，但大部分情况下，鉴于其使用的复杂度而言，<code>compare_exchange_weak</code> 应该被有限考虑。</p>
</li>
<li><p>顺序一致模型：在此模型下，原子操作满足顺序一致性，进而可能对性能产生损耗。可显式的通过 <code>std::memory_order_seq_cst</code> 进行指定。最后来看一个例子：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; counter = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">std::vector&lt;std::thread&gt; vt;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">    vt.<span class="built_in">emplace_back</span>([&amp;]()&#123;</span><br><span class="line">        counter.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_seq_cst);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vt) &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;current counter:&quot;</span> &lt;&lt; counter &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p> 这个例子与第一个宽松模型的例子本质上没有区别，仅仅只是将原子操作的内存顺序修改为了 <code>memory_order_seq_cst</code>，有兴趣的读者可以自行编写程序测量这两种不同内存顺序导致的性能差异。</p>
</li>
</ol>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>C++11 语言层提供了并发编程的相关支持，本节简单的介绍了 <code>std::thread</code>, <code>std::mutex</code>, <code>std::future</code> 这些并发编程中不可回避的重要工具。<br>除此之外，我们还介绍了 C++11 最重要的几个特性之一的『内存模型』，<br>它们为 C++ 在标准化高性能计算中提供了重要的基础。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/08/12/gloo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/12/gloo/" itemprop="url">gloo介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-12T12:52:00+08:00">
                2022-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Gloo 是一个集合通信库。它带有许多对机器学习应用有用的集体算法。参与机器之间的数据传输是抽象的，因此可以随时使用 IP，或者在可用时使用 InifiniBand（或 RoCE）。 在后一种情况下，如果使用 InfiniBand 传输，GPUDirect可用于加速跨机器 GPU 到 GPU 的内存传输。</p>
<p>在适用的情况下，算法具有一种适用于系统内存缓冲区的实现，以及一种适用于 NVIDIA GPU 内存缓冲区的实现。 在后一种情况下，主机和设备之间不需要复制内存； 这是由算法实现处理的。</p>
<h1 id="aligned-allocator"><a href="#aligned-allocator" class="headerlink" title="aligned_allocator"></a>aligned_allocator</h1><p>将分配的内存区域对齐到32字节。使用了using和模板。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Align buffers to 32 bytes to support vectorized code</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> kBufferAlignment = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> ALIGNMENT = kBufferAlignment&gt;</span><br><span class="line"><span class="keyword">class</span> aligned_allocator &#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(</span><br><span class="line">      !(ALIGNMENT &amp; (ALIGNMENT - <span class="number">1</span>)),</span><br><span class="line">      <span class="string">&quot;alignment must be a power of 2&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> pointer = value_type*;</span><br><span class="line">  <span class="keyword">using</span> const_pointer = <span class="type">const</span> value_type*;</span><br><span class="line">  <span class="keyword">using</span> reference = value_type&amp;;</span><br><span class="line">  <span class="keyword">using</span> const_reference = <span class="type">const</span> value_type&amp;;</span><br><span class="line">  <span class="keyword">using</span> size_type = std::<span class="type">size_t</span>;</span><br><span class="line">  <span class="keyword">using</span> difference_type = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">rebind</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> other = aligned_allocator&lt;U, ALIGNMENT&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">explicit</span> <span class="title">aligned_allocator</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">  <span class="keyword">inline</span> ~<span class="built_in">aligned_allocator</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">explicit</span> <span class="title">aligned_allocator</span><span class="params">(<span class="type">const</span> aligned_allocator&amp; a)</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> pointer <span class="title">address</span><span class="params">(reference r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> const_pointer <span class="title">address</span><span class="params">(const_reference r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> pointer <span class="title">allocate</span><span class="params">(size_type sz)</span> </span>&#123;</span><br><span class="line">    pointer p;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">posix_memalign</span>(</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(&amp;p), ALIGNMENT, <span class="built_in">sizeof</span>(T) * sz)) &#123;</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer p, size_type <span class="comment">/*sz*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>posix_memalign(void **memptr, size_t alignment, size_t size)</code>成功时会返回size字节的动态内存，并且这块内存的地址是alignment的倍数。参数alignment必须是2的幂，还是void指针的大小的倍数。返回的内存块的地址放在了memptr里面，函数返回值是0。调用失败时，没有内存会被分配，memptr的值没有被定义，返回如下错误码之一：</p>
<ul>
<li>EINVAL：参数不是2的幂，或者不是void指针的倍数。</li>
<li>ENOMEM：没有足够的内存去满足函数的请求。</li>
</ul>
<h1 id="transport"><a href="#transport" class="headerlink" title="transport"></a>transport</h1><p>一个样例是这样调用mpi的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> <span class="comment">/*argc*/</span>, <span class="type">char</span>** <span class="comment">/*argv*/</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We&#x27;ll use the TCP transport in this example</span></span><br><span class="line">  <span class="keyword">auto</span> dev = gloo::transport::tcp::<span class="built_in">CreateDevice</span>(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create Gloo context and delegate management of MPI_Init/MPI_Finalize</span></span><br><span class="line">  <span class="keyword">auto</span> context = gloo::mpi::Context::<span class="built_in">createManaged</span>();</span><br><span class="line">  context-&gt;<span class="built_in">connectFullMesh</span>(dev);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create and run simple allreduce</span></span><br><span class="line">  <span class="type">int</span> rank = context-&gt;rank;</span><br><span class="line">  <span class="function">gloo::AllreduceRing&lt;<span class="type">int</span>&gt; <span class="title">allreduce</span><span class="params">(context, &#123;&amp;rank&#125;, <span class="number">1</span>)</span></span>;</span><br><span class="line">  allreduce.<span class="built_in">run</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; rank &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>transport共有三种通信方式：ibverbs、tcp、uv。</p>
<h2 id="ibverbs"><a href="#ibverbs" class="headerlink" title="ibverbs"></a>ibverbs</h2><p>应该是RDMA方式。context应该是上下文，记录通信设备和rank相关信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ibverbs &#123;</span><br><span class="line"></span><br><span class="line">Context::<span class="built_in">Context</span>(std::shared_ptr&lt;Device&gt; device, <span class="type">int</span> rank, <span class="type">int</span> size)</span><br><span class="line">    : ::gloo::transport::<span class="built_in">Context</span>(rank, size), <span class="built_in">device_</span>(device) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Context::~<span class="built_in">Context</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;transport::Pair&gt;&amp; <span class="title">Context::createPair</span><span class="params">(<span class="type">int</span> rank)</span> </span>&#123;</span><br><span class="line">  pairs_[rank] = std::<span class="built_in">unique_ptr</span>&lt;transport::Pair&gt;(</span><br><span class="line">      <span class="keyword">new</span> ibverbs::<span class="built_in">Pair</span>(device_, <span class="built_in">getTimeout</span>()));</span><br><span class="line">  <span class="keyword">return</span> pairs_[rank];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;transport::UnboundBuffer&gt; <span class="title">Context::createUnboundBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">GLOO_THROW_INVALID_OPERATION_EXCEPTION</span>(</span><br><span class="line">      <span class="string">&quot;Unbound buffers not supported yet for ibverbs transport&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;transport::UnboundBuffer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace ibverbs</span></span><br></pre></td></tr></table></figure>
<p>这个pair是不能复制和赋值，避免出现内存问题，感觉应该是通信双方组成一个pair：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> : <span class="keyword">public</span> ::gloo::transport::Pair &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> kMaxBuffers = <span class="number">8</span>;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> kRecvCompletionQueueCapacity = kMaxBuffers;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> kSendCompletionQueueCapacity = kMaxBuffers;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> kCompletionQueueCapacity =</span><br><span class="line">    kRecvCompletionQueueCapacity + kSendCompletionQueueCapacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The ibv_req_notify(3) function takes an argument called</span></span><br><span class="line">  <span class="comment">// &#x27;solicited_only&#x27; which makes it only trigger a notification for</span></span><br><span class="line">  <span class="comment">// work requests that are flagged as solicited. Every completion</span></span><br><span class="line">  <span class="comment">// should trigger a notification, so always pass 0.</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> kNotifyOnAnyCompletion = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Pair</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::shared_ptr&lt;Device&gt;&amp; dev,</span></span></span><br><span class="line"><span class="params"><span class="function">      std::chrono::milliseconds timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Pair</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Pair</span>(<span class="type">const</span> Pair&amp; that) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  Pair&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Pair&amp; that) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> Address&amp; <span class="title">address</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt;&amp; bytes)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setSync</span><span class="params">(<span class="type">bool</span> enable, <span class="type">bool</span> busyPoll)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;::gloo::transport::Buffer&gt;</span></span><br><span class="line"><span class="function">  <span class="title">createSendBuffer</span><span class="params">(<span class="type">int</span> slot, <span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;::gloo::transport::Buffer&gt;</span></span><br><span class="line"><span class="function">  <span class="title">createRecvBuffer</span><span class="params">(<span class="type">int</span> slot, <span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Send from the specified buffer to remote side of pair.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">send</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      transport::UnboundBuffer* tbuf,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">uint64_t</span> tag,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">size_t</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">size_t</span> nbytes)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Receive into the specified buffer from the remote side of pair.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">recv</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      transport::UnboundBuffer* tbuf,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">uint64_t</span> tag,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">size_t</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">size_t</span> nbytes)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleCompletionEvent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pollCompletions</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleCompletion</span><span class="params">(<span class="keyword">struct</span> ibv_wc* wc)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(Buffer* buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> length, <span class="type">size_t</span> roffset)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  std::shared_ptr&lt;Device&gt; dev_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether or not this pair is running in sync mode.</span></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; sync_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether or not this pair is busy polling in sync mode.</span></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; busyPoll_;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> std::chrono::milliseconds timeout_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该pair的完成队列处理的完成事件数。在销毁完成队列之前，需要确认这么多事件。否则，销毁将挂起。</span></span><br><span class="line">  <span class="type">int</span> completionEventsHandled_;</span><br><span class="line"></span><br><span class="line">  Address self_;</span><br><span class="line">  Address peer_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_cq</span>* cq_;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_qp</span>* qp_;</span><br><span class="line"></span><br><span class="line">  std::mutex m_;</span><br><span class="line">  std::condition_variable cv_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For us to copy the remote peer&#x27;s ibv_mr into.</span></span><br><span class="line">  std::map&lt;<span class="type">int</span>, <span class="keyword">struct</span> ibv_mr&gt; peerMemoryRegions_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这些字段存储pair的远程端可以发送到的内存区域以及pair的本地端可以从中发送的内存区域。</span></span><br><span class="line">  <span class="comment">// 注册接收缓冲区时，本地 ibv_mr 被发送到pair的远程端，并且相应的 MemoryRegion 实例保留在 mappedSendRegions_ 列表中，直到发送操作完成。</span></span><br><span class="line">  <span class="comment">// 为了允许pair的远程端发送其内存区域，我们在 mappedRecvRegions_ 中保留了固定数量的 MemoryRegion 实例。</span></span><br><span class="line">  <span class="comment">// 对于每个发布的接收工作请求，这些区域都会被循环引用。</span></span><br><span class="line">  std::map&lt;<span class="type">int</span>, std::unique_ptr&lt;MemoryRegion&gt; &gt; mappedSendRegions_;</span><br><span class="line">  std::array&lt;std::unique_ptr&lt;MemoryRegion&gt;, kMaxBuffers&gt; mappedRecvRegions_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跟踪发布和完成的请求工作请求的数量。 在发布 WR 和完成 WR 时，都需要对 mappedRecvRegions_ 数组进行索引。</span></span><br><span class="line">  <span class="type">uint64_t</span> recvPosted_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Completions on behalf of buffers need to be forwarded to those buffers.</span></span><br><span class="line">  std::map&lt;<span class="type">int</span>, Buffer*&gt; sendCompletionHandlers_;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, Buffer*&gt; recvCompletionHandlers_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendMemoryRegion</span><span class="params">(<span class="keyword">struct</span> ibv_mr* mr, <span class="type">int</span> slot)</span></span>;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">ibv_mr</span>* <span class="built_in">getMemoryRegion</span>(<span class="type">int</span> slot);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">postReceive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  std::<span class="function">chrono::milliseconds <span class="title">getTimeout</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timeout_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> Address&amp; <span class="title">peer</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> peer_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::exception_ptr ex_;</span><br><span class="line">  <span class="type">bool</span> closed_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Used to signal IO exceptions from one thread and propagate onto others.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">signalIoFailure</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">checkErrorState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Buffer</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以下是逐个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">Pair::<span class="built_in">Pair</span>(</span><br><span class="line">    <span class="type">const</span> std::shared_ptr&lt;Device&gt;&amp; dev,</span><br><span class="line">    std::chrono::milliseconds timeout)</span><br><span class="line">    : <span class="built_in">dev_</span>(dev),</span><br><span class="line">      <span class="built_in">sync_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">busyPoll_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">timeout_</span>(timeout),</span><br><span class="line">      <span class="built_in">completionEventsHandled_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">recvPosted_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">ex_</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="type">int</span> rv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create completion queue</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 必须向设备的完成通道注册此完成队列以支持异步完成处理。</span></span><br><span class="line">    <span class="comment">// Pairs 默认使用异步完成处理，因此我们调用 ibv_req_notify_cq(3) 来请求第一个通知。</span></span><br><span class="line">    cq_ = <span class="built_in">ibv_create_cq</span>(</span><br><span class="line">      dev_-&gt;context_,</span><br><span class="line">      kCompletionQueueCapacity,</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      dev_-&gt;comp_channel_,</span><br><span class="line">      <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(cq_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在完成队列 (CQ) 上请求Completion Notification（完成通知）。</span></span><br><span class="line">    rv = <span class="built_in">ibv_req_notify_cq</span>(cq_, kNotifyOnAnyCompletion);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create queue pair</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ibv_qp_init_attr</span> attr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> ibv_qp_init_attr));</span><br><span class="line">    attr.send_cq = cq_;</span><br><span class="line">    attr.recv_cq = cq_;</span><br><span class="line">    attr.cap.max_send_wr = Pair::kSendCompletionQueueCapacity;</span><br><span class="line">    attr.cap.max_recv_wr = Pair::kRecvCompletionQueueCapacity;</span><br><span class="line">    attr.cap.max_send_sge = <span class="number">1</span>;</span><br><span class="line">    attr.cap.max_recv_sge = <span class="number">1</span>;</span><br><span class="line">    attr.qp_type = IBV_QPT_RC;</span><br><span class="line">    qp_ = <span class="built_in">ibv_create_qp</span>(dev-&gt;pd_, &amp;attr);</span><br><span class="line">    <span class="comment">// 创建queue pair</span></span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(qp_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Init queue pair</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ibv_qp_attr</span> attr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> ibv_qp_attr));</span><br><span class="line">    attr.qp_state = IBV_QPS_INIT;</span><br><span class="line">    attr.pkey_index = <span class="number">0</span>;</span><br><span class="line">    attr.port_num = dev_-&gt;attr_.port;</span><br><span class="line">    attr.qp_access_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE;</span><br><span class="line">    rv = <span class="built_in">ibv_modify_qp</span>(</span><br><span class="line">        qp_,</span><br><span class="line">        &amp;attr,</span><br><span class="line">        IBV_QP_STATE | IBV_QP_PKEY_INDEX | IBV_QP_PORT | IBV_QP_ACCESS_FLAGS);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Populate local address.</span></span><br><span class="line">  <span class="comment">// The Packet Sequence Number field (PSN) is random which makes that</span></span><br><span class="line">  <span class="comment">// the remote end of this pair needs to have the contents of the</span></span><br><span class="line">  <span class="comment">// full address struct in order to connect, and vice versa.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ibv_port_attr</span> attr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> ibv_port_attr));</span><br><span class="line">    rv = <span class="built_in">ibv_query_port</span>(dev_-&gt;context_, dev_-&gt;attr_.port, &amp;attr);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line">    rv = <span class="built_in">ibv_query_gid</span>(</span><br><span class="line">        dev_-&gt;context_,</span><br><span class="line">        dev_-&gt;attr_.port,</span><br><span class="line">        dev_-&gt;attr_.index,</span><br><span class="line">        &amp;self_.addr_.ibv_gid);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line">    self_.addr_.lid = attr.lid;</span><br><span class="line">    self_.addr_.qpn = qp_-&gt;qp_num;</span><br><span class="line">    self_.addr_.psn = <span class="built_in">rand</span>() &amp; <span class="number">0xffffff</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在连接之前发布接收请求。</span></span><br><span class="line">  <span class="comment">// 每当这pair的远程端注册接收缓冲区时，就会触发它们的内存注册被发送到这一端。</span></span><br><span class="line">  <span class="comment">// 由于这些发送是单方面的，我们总是需要一整套接收工作请求。</span></span><br><span class="line">  <span class="comment">// 内存区域接收可以与常规缓冲区写入交错，因此我们主动在每个接收工作请求中包含一个内存区域。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kMaxBuffers; ++i) &#123;</span><br><span class="line">    mappedRecvRegions_[i] = <span class="built_in">make_unique</span>&lt;MemoryRegion&gt;(dev_-&gt;pd_);</span><br><span class="line">    <span class="built_in">postReceive</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pair::~<span class="built_in">Pair</span>() &#123;</span><br><span class="line">  <span class="type">int</span> rv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Acknowledge number of completion events handled by this</span></span><br><span class="line">  <span class="comment">// pair&#x27;s completion queue (also see ibv_get_cq_event(3)).</span></span><br><span class="line">  <span class="built_in">ibv_ack_cq_events</span>(cq_, completionEventsHandled_);</span><br><span class="line"></span><br><span class="line">  rv = <span class="built_in">ibv_destroy_qp</span>(qp_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  rv = <span class="built_in">ibv_destroy_cq</span>(cq_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (closed_) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add proper handling of duplicate closes T21171834</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  closed_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Address&amp; <span class="title">Pair::address</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> self_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>连接函数先获取到对方的地址，更新attr结构体，使用ibv_modify_qp函数修改RDMA通信所需的结构体。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::connect</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt;&amp; bytes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_qp_attr</span> attr;</span><br><span class="line">  <span class="type">int</span> rv;</span><br><span class="line">  <span class="built_in">checkErrorState</span>();</span><br><span class="line"></span><br><span class="line">  peer_ = <span class="built_in">Address</span>(bytes);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="built_in">sizeof</span>(attr));</span><br><span class="line">  attr.qp_state = IBV_QPS_RTR;</span><br><span class="line">  attr.path_mtu = IBV_MTU_1024;</span><br><span class="line">  attr.dest_qp_num = peer_.addr_.qpn;</span><br><span class="line">  attr.rq_psn = peer_.addr_.psn;</span><br><span class="line">  attr.max_dest_rd_atomic = <span class="number">1</span>;</span><br><span class="line">  attr.min_rnr_timer = <span class="number">20</span>;</span><br><span class="line">  attr.ah_attr.is_global = <span class="number">0</span>;</span><br><span class="line">  attr.ah_attr.dlid = peer_.addr_.lid;</span><br><span class="line">  attr.ah_attr.port_num = dev_-&gt;attr_.port;</span><br><span class="line">  <span class="keyword">if</span> (peer_.addr_.ibv_gid.global.interface_id) &#123;</span><br><span class="line">    attr.ah_attr.is_global = <span class="number">1</span>;</span><br><span class="line">    attr.ah_attr.grh.hop_limit = <span class="number">1</span>;</span><br><span class="line">    attr.ah_attr.grh.dgid = peer_.addr_.ibv_gid;</span><br><span class="line">    attr.ah_attr.grh.sgid_index = dev_-&gt;attr_.index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ibv_modify_qp()修改队列对的属性。更改的属性描述了QP的发送和接收属性。</span></span><br><span class="line">  <span class="comment">// ibv_create_qp仅仅分配了资源，要通过这个modify来让硬件进入工作状态。</span></span><br><span class="line">  <span class="comment">// Move to Ready To Receive (RTR) state</span></span><br><span class="line">  rv = <span class="built_in">ibv_modify_qp</span>(</span><br><span class="line">      qp_,</span><br><span class="line">      &amp;attr,</span><br><span class="line">      IBV_QP_STATE | IBV_QP_PATH_MTU | IBV_QP_DEST_QPN | IBV_QP_RQ_PSN |</span><br><span class="line">          IBV_QP_AV | IBV_QP_MAX_DEST_RD_ATOMIC | IBV_QP_MIN_RNR_TIMER);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="built_in">sizeof</span>(attr));</span><br><span class="line">  attr.qp_state = IBV_QPS_RTS;</span><br><span class="line">  attr.sq_psn = self_.addr_.psn;</span><br><span class="line">  attr.ah_attr.is_global = <span class="number">1</span>;</span><br><span class="line">  attr.timeout = <span class="number">14</span>;</span><br><span class="line">  attr.retry_cnt = <span class="number">7</span>;</span><br><span class="line">  attr.rnr_retry = <span class="number">7</span>; <span class="comment">/* infinite */</span></span><br><span class="line">  attr.max_rd_atomic = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Move to Ready To Send (RTS) state</span></span><br><span class="line">  rv = <span class="built_in">ibv_modify_qp</span>(</span><br><span class="line">      qp_,</span><br><span class="line">      &amp;attr,</span><br><span class="line">      IBV_QP_STATE | IBV_QP_TIMEOUT | IBV_QP_RETRY_CNT | IBV_QP_RNR_RETRY |</span><br><span class="line">          IBV_QP_SQ_PSN | IBV_QP_MAX_QP_RD_ATOMIC);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Switches the pair into synchronous mode.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note: busy polling is NOT optional. Currently, since all pairs</span></span><br><span class="line"><span class="comment">// share a single completion channel, busy polling is mandatory</span></span><br><span class="line"><span class="comment">// through ibv_poll_cq(3). If a use case comes up for supporting</span></span><br><span class="line"><span class="comment">// synchronous mode where the calling thread should be suspended, this</span></span><br><span class="line"><span class="comment">// can be revisited and we can add a completion channel per pair.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::setSync</span><span class="params">(<span class="type">bool</span> sync, <span class="type">bool</span> busyPoll)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">checkErrorState</span>();</span><br><span class="line">  <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">    <span class="built_in">GLOO_THROW_INVALID_OPERATION_EXCEPTION</span>(<span class="string">&quot;Can only switch to sync mode&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!busyPoll) &#123;</span><br><span class="line">    <span class="built_in">GLOO_THROW_INVALID_OPERATION_EXCEPTION</span>(</span><br><span class="line">        <span class="string">&quot;The ibverbs transport only supports busy polling in sync mode&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The notification mechanism for this pair&#x27;s completion queue is</span></span><br><span class="line">  <span class="comment">// still armed. This means the device thread will still call</span></span><br><span class="line">  <span class="comment">// handleCompletions() one more time, but this is ignored.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// No need to lock a mutex; these are atomics.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  sync_ = <span class="literal">true</span>;</span><br><span class="line">  busyPoll_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用ibv_post_send函数发送，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::sendMemoryRegion</span><span class="params">(<span class="keyword">struct</span> ibv_mr* src, <span class="type">int</span> slot)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> mr = <span class="built_in">make_unique</span>&lt;MemoryRegion&gt;(dev_-&gt;pd_, src);</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_sge</span> list = mr-&gt;<span class="built_in">sge</span>();</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_send_wr</span> wr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;wr, <span class="number">0</span>, <span class="built_in">sizeof</span>(wr));</span><br><span class="line">  wr.wr_id = slot;</span><br><span class="line">  wr.sg_list = &amp;list;</span><br><span class="line">  wr.num_sge = <span class="number">1</span>;</span><br><span class="line">  wr.opcode = IBV_WR_SEND_WITH_IMM;</span><br><span class="line">  wr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line">  wr.imm_data = slot;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工作请求被序列化并发送到驱动程序，因此它不需要在 ibv_post_send 调用后有效。</span></span><br><span class="line">  <span class="comment">// ibv_post_send和recv用于发送verb，verb承载在一个称为ibv_send_wr或者ibv_recv_wr的数据结构中，里面是verb类型和mr的相关细节。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_send_wr</span>* bad_wr = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">int</span> rv = <span class="built_in">ibv_post_send</span>(qp_, &amp;wr, &amp;bad_wr);</span><br><span class="line">  <span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">signalIoFailure</span>(<span class="built_in">GLOO_ERROR_MSG</span>(<span class="string">&quot;ibv_post_send: &quot;</span>, rv));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(mappedSendRegions_.<span class="built_in">count</span>(slot), <span class="number">0</span>);</span><br><span class="line">  mappedSendRegions_[slot] = std::<span class="built_in">move</span>(mr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先获取到锁，如果是异步的，需要检查是不是超时了；否则就等待。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">ibv_mr</span>* Pair::<span class="built_in">getMemoryRegion</span>(<span class="type">int</span> slot) &#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (sync_) &#123;</span><br><span class="line">    <span class="keyword">auto</span> it = peerMemoryRegions_.<span class="built_in">find</span>(slot);</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">while</span> (it == peerMemoryRegions_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="built_in">pollCompletions</span>();</span><br><span class="line">      lock.<span class="built_in">lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (timeout_ != kNoTimeout &amp;&amp;</span><br><span class="line">          (std::chrono::steady_clock::<span class="built_in">now</span>() - start) &gt;= timeout_) &#123;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="built_in">signalIoFailure</span>(</span><br><span class="line">            <span class="built_in">GLOO_ERROR_MSG</span>(</span><br><span class="line">                <span class="string">&quot;Timeout waiting for memory region from &quot;</span>,</span><br><span class="line">                peer_.<span class="built_in">str</span>()));</span><br><span class="line">        <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Unexpected code path&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      it = peerMemoryRegions_.<span class="built_in">find</span>(slot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;it-&gt;second;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> pred = [&amp;]&#123;</span><br><span class="line">      <span class="keyword">return</span> peerMemoryRegions_.<span class="built_in">find</span>(slot) != peerMemoryRegions_.<span class="built_in">end</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (timeout_ == kNoTimeout) &#123;</span><br><span class="line">      <span class="comment">// No timeout set. Wait for read to complete.</span></span><br><span class="line">      cv_.<span class="built_in">wait</span>(lock, pred);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> done = cv_.<span class="built_in">wait_for</span>(lock, timeout_, pred);</span><br><span class="line">      <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        <span class="built_in">signalIoFailure</span>(</span><br><span class="line">            <span class="built_in">GLOO_ERROR_MSG</span>(</span><br><span class="line">                <span class="string">&quot;Timeout waiting for memory region from &quot;</span>,</span><br><span class="line">                peer_.<span class="built_in">str</span>()));</span><br><span class="line">        <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Unexpected code path&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> it = peerMemoryRegions_.<span class="built_in">find</span>(slot);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(it != peerMemoryRegions_.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> &amp;it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::postReceive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; mr = mappedRecvRegions_[recvPosted_++ % kMaxBuffers];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_sge</span> list = mr-&gt;<span class="built_in">sge</span>();</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_recv_wr</span> wr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;wr, <span class="number">0</span>, <span class="built_in">sizeof</span>(wr));</span><br><span class="line">  wr.sg_list = &amp;list;</span><br><span class="line">  wr.num_sge = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工作请求被序列化并发送到驱动程序，因此它不需要在 ibv_post_recv 调用后有效。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_recv_wr</span>* bad_wr = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">auto</span> rv = <span class="built_in">ibv_post_recv</span>(qp_, &amp;wr, &amp;bad_wr);</span><br><span class="line">  <span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">signalIoFailure</span>(<span class="built_in">GLOO_ERROR_MSG</span>(<span class="string">&quot;ibv_post_recv: &quot;</span>, rv));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;::gloo::transport::Buffer&gt;</span></span><br><span class="line"><span class="function"><span class="title">Pair::createSendBuffer</span><span class="params">(<span class="type">int</span> slot, <span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个buffer</span></span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(sendCompletionHandlers_.<span class="built_in">count</span>(slot), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">auto</span> buffer = <span class="keyword">new</span> <span class="built_in">Buffer</span>(<span class="keyword">this</span>, slot, ptr, size);</span><br><span class="line">  sendCompletionHandlers_[slot] = buffer;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;::gloo::transport::Buffer&gt;(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;::gloo::transport::Buffer&gt;</span></span><br><span class="line"><span class="function"><span class="title">Pair::createRecvBuffer</span><span class="params">(<span class="type">int</span> slot, <span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(recvCompletionHandlers_.<span class="built_in">count</span>(slot), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">auto</span> buffer = <span class="keyword">new</span> <span class="built_in">Buffer</span>(<span class="keyword">this</span>, slot, ptr, size);</span><br><span class="line">  recvCompletionHandlers_[slot] = buffer;</span><br><span class="line">  <span class="built_in">sendMemoryRegion</span>(buffer-&gt;mr_, buffer-&gt;slot_);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;::gloo::transport::Buffer&gt;(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send from the specified buffer to remote side of pair.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::send</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    transport::UnboundBuffer* tbuf,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span> <span class="comment">/* unused */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> <span class="comment">/* unused */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> <span class="comment">/* unused */</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">GLOO_THROW_INVALID_OPERATION_EXCEPTION</span>(</span><br><span class="line">      <span class="string">&quot;Unbound buffers not supported yet for ibverbs transport&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Receive into the specified buffer from the remote side of pair.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::recv</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    transport::UnboundBuffer* tbuf,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span> <span class="comment">/* unused */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> <span class="comment">/* unused */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> <span class="comment">/* unused */</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">GLOO_THROW_INVALID_OPERATION_EXCEPTION</span>(</span><br><span class="line">      <span class="string">&quot;Unbound buffers not supported yet for ibverbs transport&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handleCompletionEvent is called by the device thread when it</span></span><br><span class="line"><span class="comment">// received an event for this pair&#x27;s completion queue on its</span></span><br><span class="line"><span class="comment">// completion channel.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::handleCompletionEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> rv;</span><br><span class="line"></span><br><span class="line">  completionEventsHandled_++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If in sync mode, the pair was just switched and this is</span></span><br><span class="line">  <span class="comment">// the last notification from the device thread because</span></span><br><span class="line">  <span class="comment">// the notification mechanism is not re-armed below.</span></span><br><span class="line">  <span class="keyword">if</span> (sync_) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">checkErrorState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Arm notification mechanism for completion queue.</span></span><br><span class="line">    rv = <span class="built_in">ibv_req_notify_cq</span>(cq_, kNotifyOnAnyCompletion);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now poll for work completions to drain the completion queue.</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">    <span class="built_in">pollCompletions</span>();</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> ::gloo::IoException&amp;) &#123;</span><br><span class="line">    <span class="comment">// Catch IO exceptions on the event handling thread. The exception has</span></span><br><span class="line">    <span class="comment">// already been saved and user threads signaled.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>轮询这pair的完成队列以获取工作完成情况。当从设备线程调用时，这对的互斥锁已经被获取。从用户线程调用时，不会获取互斥锁（因为只有一个线程使用这对）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::pollCompletions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::array&lt;<span class="keyword">struct</span> ibv_wc, kCompletionQueueCapacity&gt; wc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invoke handler for every work completion.</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">auto</span> nwc = <span class="built_in">ibv_poll_cq</span>(cq_, wc.<span class="built_in">size</span>(), wc.<span class="built_in">data</span>());</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_GE</span>(nwc, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle work completions</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nwc; i++) &#123;</span><br><span class="line">      <span class="built_in">checkErrorState</span>();</span><br><span class="line">      <span class="built_in">handleCompletion</span>(&amp;wc[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Break unless wc was filled</span></span><br><span class="line">    <span class="keyword">if</span> (nwc == <span class="number">0</span> || nwc &lt; wc.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::handleCompletion</span><span class="params">(<span class="keyword">struct</span> ibv_wc* wc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (wc-&gt;opcode == IBV_WC_RECV_RDMA_WITH_IMM) &#123;</span><br><span class="line">    <span class="comment">// Incoming RDMA write completed.</span></span><br><span class="line">    <span class="comment">// Slot is encoded in immediate data on receive work completion.</span></span><br><span class="line">    <span class="comment">// It is set in the Pair::send function.</span></span><br><span class="line">    <span class="keyword">auto</span> slot = wc-&gt;imm_data;</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>( wc-&gt;status, IBV_WC_SUCCESS, <span class="string">&quot;Recv for slot &quot;</span>, slot, <span class="string">&quot;: &quot;</span>, <span class="built_in">ibv_wc_status_str</span>(wc-&gt;status));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(recvCompletionHandlers_[slot] != <span class="literal">nullptr</span>);</span><br><span class="line">    recvCompletionHandlers_[slot]-&gt;<span class="built_in">handleCompletion</span>(wc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Backfill receive work requests.</span></span><br><span class="line">    <span class="built_in">postReceive</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wc-&gt;opcode == IBV_WC_RDMA_WRITE) &#123;</span><br><span class="line">    <span class="comment">// Outbound RDMA write completed.</span></span><br><span class="line">    <span class="comment">// Slot is encoded in wr_id fields on send work request. Unlike</span></span><br><span class="line">    <span class="comment">// the receive work completions, the immediate data field on send</span></span><br><span class="line">    <span class="comment">// work requests are not pass to the respective work completion.</span></span><br><span class="line">    <span class="keyword">auto</span> slot = wc-&gt;wr_id;</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>( wc-&gt;status, IBV_WC_SUCCESS, <span class="string">&quot;Send for slot &quot;</span>, slot, <span class="string">&quot;: &quot;</span>, <span class="built_in">ibv_wc_status_str</span>(wc-&gt;status));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(sendCompletionHandlers_[slot] != <span class="literal">nullptr</span>);</span><br><span class="line">    sendCompletionHandlers_[slot]-&gt;<span class="built_in">handleCompletion</span>(wc);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wc-&gt;opcode == IBV_WC_RECV) &#123;</span><br><span class="line">    <span class="comment">// 内存区域 recv 完成。</span></span><br><span class="line">    <span class="comment">// 仅由pair的远程端用于传递 ibv_mr。</span></span><br><span class="line">    <span class="comment">// 它们以 FIFO 顺序写入，因此我们可以在映射的接收区域列表中选择并使用第一个 MemoryRegion 实例。</span></span><br><span class="line">    <span class="comment">// 尝试写入此插槽的缓冲区可能正在等待该对的另一端发送其内存区域。</span></span><br><span class="line">    <span class="comment">// 锁定访问权限，然后通知任何等待的人。</span></span><br><span class="line">    <span class="comment">// 时隙在接收工作完成后立即编码为数据。 它在 Pair::sendMemoryRegion 函数中设置。</span></span><br><span class="line">    <span class="keyword">auto</span> slot = wc-&gt;imm_data;</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(</span><br><span class="line">      wc-&gt;status,</span><br><span class="line">      IBV_WC_SUCCESS,</span><br><span class="line">      <span class="string">&quot;Memory region recv for slot &quot;</span>,</span><br><span class="line">      slot,</span><br><span class="line">      <span class="string">&quot;: &quot;</span>,</span><br><span class="line">      <span class="built_in">ibv_wc_status_str</span>(wc-&gt;status));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move ibv_mr from memory region &#x27;inbox&#x27; to final slot.</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; mr = mappedRecvRegions_[recvPosted_ % kMaxBuffers];</span><br><span class="line">    peerMemoryRegions_[slot] = mr-&gt;<span class="built_in">mr</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Notify any buffer waiting for the details of its remote peer.</span></span><br><span class="line">    cv_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Backfill receive work requests.</span></span><br><span class="line">    <span class="built_in">postReceive</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wc-&gt;opcode == IBV_WC_SEND) &#123;</span><br><span class="line">    <span class="comment">// Memory region send completed.</span></span><br><span class="line">    <span class="keyword">auto</span> slot = wc-&gt;wr_id;</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(</span><br><span class="line">      wc-&gt;status,</span><br><span class="line">      IBV_WC_SUCCESS,</span><br><span class="line">      <span class="string">&quot;Memory region send for slot &quot;</span>,</span><br><span class="line">      slot,</span><br><span class="line">      <span class="string">&quot;: &quot;</span>,</span><br><span class="line">      <span class="built_in">ibv_wc_status_str</span>(wc-&gt;status));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_GT</span>(mappedSendRegions_.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(mappedSendRegions_.<span class="built_in">count</span>(slot), <span class="number">1</span>);</span><br><span class="line">    mappedSendRegions_.<span class="built_in">erase</span>(slot);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Unexpected completion with opcode: &quot;</span>, wc-&gt;opcode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用一些信息填充结构体，获取到内存区域后发送<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::send</span><span class="params">(Buffer* buffer, <span class="type">size_t</span> offset, <span class="type">size_t</span> length, <span class="type">size_t</span> roffset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_sge</span> list;</span><br><span class="line">  list.addr = (<span class="type">uint64_t</span>)buffer-&gt;ptr_ + offset;</span><br><span class="line">  list.length = length;</span><br><span class="line">  list.lkey = buffer-&gt;mr_-&gt;lkey;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_send_wr</span> wr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;wr, <span class="number">0</span>, <span class="built_in">sizeof</span>(wr));</span><br><span class="line">  wr.wr_id = buffer-&gt;slot_;</span><br><span class="line">  wr.sg_list = &amp;list;</span><br><span class="line">  wr.num_sge = <span class="number">1</span>;</span><br><span class="line">  wr.opcode = IBV_WR_RDMA_WRITE_WITH_IMM;</span><br><span class="line">  wr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line">  wr.imm_data = buffer-&gt;slot_;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">ibv_mr</span>* peer = <span class="built_in">getMemoryRegion</span>(buffer-&gt;slot_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_NE</span>(peer, (<span class="type">const</span> <span class="keyword">struct</span> ibv_mr*)<span class="literal">nullptr</span>);</span><br><span class="line">  wr.wr.rdma.remote_addr = (<span class="type">uint64_t</span>)peer-&gt;addr + roffset;</span><br><span class="line">  wr.wr.rdma.rkey = peer-&gt;rkey;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_send_wr</span>* bad_wr;</span><br><span class="line">  <span class="keyword">auto</span> rv = <span class="built_in">ibv_post_send</span>(qp_, &amp;wr, &amp;bad_wr);</span><br><span class="line">  <span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">signalIoFailure</span>(<span class="built_in">GLOO_ERROR_MSG</span>(<span class="string">&quot;ibv_post_send: &quot;</span>, rv));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::signalIoFailure</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> ex = ::gloo::<span class="built_in">IoException</span>(msg);</span><br><span class="line">  <span class="keyword">if</span> (ex_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// If we haven&#x27;t seen an error yet, store the exception to throw on future calling threads.</span></span><br><span class="line">    ex_ = std::<span class="built_in">make_exception_ptr</span>(ex);</span><br><span class="line">    <span class="comment">// Loop through the completion handlers and signal that an error has</span></span><br><span class="line">    <span class="comment">// occurred.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : recvCompletionHandlers_) &#123;</span><br><span class="line">      <span class="built_in">GLOO_ENFORCE</span>(it.second != <span class="literal">nullptr</span>);</span><br><span class="line">      it.second-&gt;<span class="built_in">signalError</span>(ex_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : sendCompletionHandlers_) &#123;</span><br><span class="line">      <span class="built_in">GLOO_ENFORCE</span>(it.second != <span class="literal">nullptr</span>);</span><br><span class="line">      it.second-&gt;<span class="built_in">signalError</span>(ex_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Finally, throw the exception on this thread.</span></span><br><span class="line">  <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::checkErrorState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// If we previously encountered an error, rethrow here.</span></span><br><span class="line">  <span class="keyword">if</span> (ex_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    std::<span class="built_in">rethrow_exception</span>(ex_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>device 保存了设备信息，以下是构建一个设备<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Device::<span class="built_in">Device</span>(<span class="type">const</span> <span class="keyword">struct</span> attr&amp; attr, ibv_context* context)</span><br><span class="line">    : <span class="built_in">attr_</span>(attr),</span><br><span class="line">      <span class="built_in">pciBusID_</span>(<span class="built_in">infinibandToBusID</span>(attr.name)),</span><br><span class="line">      <span class="built_in">hasNvPeerMem_</span>(<span class="built_in">kernelModules</span>().<span class="built_in">count</span>(<span class="string">&quot;nv_peer_mem&quot;</span>) &gt; <span class="number">0</span>),</span><br><span class="line">      <span class="built_in">context_</span>(context) &#123;</span><br><span class="line">  <span class="type">int</span> rv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Query and store device attributes</span></span><br><span class="line">  rv = <span class="built_in">ibv_query_device</span>(context_, &amp;deviceAttr_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>, <span class="string">&quot;ibv_query_device: &quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Query and store port attributes</span></span><br><span class="line">  rv = <span class="built_in">ibv_query_port</span>(context_, attr_.port, &amp;portAttr_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>, <span class="string">&quot;ibv_query_port: &quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Protection domain</span></span><br><span class="line">  pd_ = <span class="built_in">ibv_alloc_pd</span>(context_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(pd_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Completion channel</span></span><br><span class="line">  comp_channel_ = <span class="built_in">ibv_create_comp_channel</span>(context_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(comp_channel_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start thread to poll completion queue and dispatch</span></span><br><span class="line">  <span class="comment">// completions for completed work requests.</span></span><br><span class="line">  done_ = <span class="literal">false</span>;</span><br><span class="line">  loop_.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(&amp;Device::loop, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>buffer分配一个缓冲区<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Buffer::<span class="built_in">Buffer</span>(Pair* pair, <span class="type">int</span> slot, <span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span><br><span class="line">    : ::gloo::transport::<span class="built_in">Buffer</span>(slot, ptr, size),</span><br><span class="line">      <span class="built_in">pair_</span>(pair),</span><br><span class="line">      <span class="built_in">recvCompletions_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">sendCompletions_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">sendPending_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">ex_</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// 注册一个memory region</span></span><br><span class="line">  mr_ = <span class="built_in">ibv_reg_mr</span>(</span><br><span class="line">      pair_-&gt;dev_-&gt;pd_,</span><br><span class="line">      ptr_,</span><br><span class="line">      size_,</span><br><span class="line">      IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Provide hint if the error is EFAULT and nv_peer_mem is not loaded</span></span><br><span class="line">  <span class="keyword">if</span> (mr_ == <span class="literal">nullptr</span> &amp;&amp; errno == EFAULT) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pair-&gt;dev_-&gt;hasNvPeerMem_) &#123;</span><br><span class="line">      <span class="built_in">GLOO_ENFORCE</span>(</span><br><span class="line">        mr_ != <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="string">&quot;ibv_reg_mr: &quot;</span>,</span><br><span class="line">        <span class="built_in">strerror</span>(errno),</span><br><span class="line">        <span class="string">&quot; (kernel module &#x27;nv_peer_mem&#x27; not loaded;&quot;</span></span><br><span class="line">        <span class="string">&quot; did you specify a pointer to GPU memory?)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Provide hint if the error is ENOMEM</span></span><br><span class="line">  <span class="keyword">if</span> (mr_ == <span class="literal">nullptr</span> &amp;&amp; errno == ENOMEM) &#123;</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(</span><br><span class="line">      mr_ != <span class="literal">nullptr</span>,</span><br><span class="line">      <span class="string">&quot;ibv_reg_mr: &quot;</span>,</span><br><span class="line">      <span class="built_in">strerror</span>(errno),</span><br><span class="line">      <span class="string">&quot; (did you run into the locked memory limit?)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(mr_ != <span class="literal">nullptr</span>, <span class="string">&quot;ibv_reg_mr: &quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>等待接收操作完成。根据是不是异步判断是否需要等待<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::waitRecv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果该pair处于同步模式，则当前线程负责轮询工作完成情况。</span></span><br><span class="line">  <span class="comment">// 由于单个pair可能为多个缓冲区提供服务，因此完成可能旨在用于另一个缓冲区。</span></span><br><span class="line">  <span class="keyword">auto</span> timeout = pair_-&gt;<span class="built_in">getTimeout</span>();</span><br><span class="line">  <span class="keyword">if</span> (pair_-&gt;sync_) &#123;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// We can assume a single pair is never used by more than one</span></span><br><span class="line">    <span class="comment">// thread, so there is no need to acquire the mutex here.</span></span><br><span class="line">    <span class="keyword">while</span> (recvCompletions_ == <span class="number">0</span>) &#123;</span><br><span class="line">      pair_-&gt;<span class="built_in">pollCompletions</span>();</span><br><span class="line">      <span class="keyword">if</span> (timeout != kNoTimeout &amp;&amp;</span><br><span class="line">          (std::chrono::steady_clock::<span class="built_in">now</span>() - start) &gt;= timeout) &#123;</span><br><span class="line">        pair_-&gt;<span class="built_in">signalIoFailure</span>(</span><br><span class="line">          <span class="built_in">GLOO_ERROR_MSG</span>(<span class="string">&quot;Read timeout &quot;</span>, pair_-&gt;<span class="built_in">peer</span>().<span class="built_in">str</span>()));</span><br><span class="line">        <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Unexpected code path&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    recvCompletions_--;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// The device thread will signal completion. If the completion</span></span><br><span class="line">    <span class="comment">// hasn&#x27;t arrived yet, wait until it does.</span></span><br><span class="line">    <span class="keyword">auto</span> pred = [&amp;]&#123;</span><br><span class="line">      <span class="built_in">checkErrorState</span>();</span><br><span class="line">      <span class="keyword">return</span> recvCompletions_ &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (timeout == kNoTimeout) &#123;</span><br><span class="line">      <span class="comment">// No timeout set. Wait for read to complete.</span></span><br><span class="line">      recvCv_.<span class="built_in">wait</span>(lock, pred);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> done = recvCv_.<span class="built_in">wait_for</span>(lock, timeout, pred);</span><br><span class="line">      <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        <span class="comment">// Release the mutex before calling into the pair to avoid deadlock.</span></span><br><span class="line">        <span class="comment">// Calling signalIoFailure() will throw, so no need to</span></span><br><span class="line">        <span class="comment">// reacquire.</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        pair_-&gt;<span class="built_in">signalIoFailure</span>(</span><br><span class="line">          <span class="built_in">GLOO_ERROR_MSG</span>(<span class="string">&quot;Read timeout &quot;</span>, pair_-&gt;<span class="built_in">peer</span>().<span class="built_in">str</span>()));</span><br><span class="line">        <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Unexpected code path&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    recvCompletions_--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>等待发送操作完成。根据是不是异步判断是否需要等待<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wait for the previous send operation to finish.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::waitSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果该pair处于同步模式，则当前线程负责轮询工作完成情况。</span></span><br><span class="line">  <span class="keyword">auto</span> timeout = pair_-&gt;<span class="built_in">getTimeout</span>();</span><br><span class="line">  <span class="keyword">if</span> (pair_-&gt;sync_) &#123;</span><br><span class="line">    <span class="comment">// We can assume a single pair is never used by more than one</span></span><br><span class="line">    <span class="comment">// thread, so there is no need to acquire the mutex here.</span></span><br><span class="line">    <span class="keyword">if</span> (sendCompletions_ == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">GLOO_ENFORCE_GT</span>(sendPending_, <span class="number">0</span>, <span class="string">&quot;No send to wait for&quot;</span>);</span><br><span class="line">      <span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">      <span class="comment">// We can assume a single pair is never used by more than one</span></span><br><span class="line">      <span class="comment">// thread, so there is no need to acquire the mutex here.</span></span><br><span class="line">      <span class="keyword">while</span> (sendCompletions_ == <span class="number">0</span>) &#123;</span><br><span class="line">        pair_-&gt;<span class="built_in">pollCompletions</span>();</span><br><span class="line">        <span class="keyword">if</span> (timeout != kNoTimeout &amp;&amp;</span><br><span class="line">            (std::chrono::steady_clock::<span class="built_in">now</span>() - start) &gt;= timeout) &#123;</span><br><span class="line">          pair_-&gt;<span class="built_in">signalIoFailure</span>(</span><br><span class="line">            <span class="built_in">GLOO_ERROR_MSG</span>(<span class="string">&quot;Send timeout &quot;</span>, pair_-&gt;<span class="built_in">peer</span>().<span class="built_in">str</span>()));</span><br><span class="line">          <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Unexpected code path&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sendCompletions_--;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// The device thread will signal completion. If the completion</span></span><br><span class="line">    <span class="comment">// hasn&#x27;t arrived yet, wait until it does.</span></span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(m_);</span><br><span class="line">    <span class="built_in">checkErrorState</span>();</span><br><span class="line">    <span class="keyword">if</span> (sendCompletions_ == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">GLOO_ENFORCE_GT</span>(sendPending_, <span class="number">0</span>, <span class="string">&quot;No send to wait for&quot;</span>);</span><br><span class="line">      <span class="keyword">auto</span> pred = [&amp;]&#123;</span><br><span class="line">        <span class="built_in">checkErrorState</span>();</span><br><span class="line">        <span class="keyword">return</span> sendCompletions_ &gt; <span class="number">0</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">if</span> (timeout == kNoTimeout) &#123;</span><br><span class="line">        <span class="comment">// No timeout set. Wait for read to complete.</span></span><br><span class="line">        sendCv_.<span class="built_in">wait</span>(lock, pred);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> done = sendCv_.<span class="built_in">wait_for</span>(lock, timeout, pred);</span><br><span class="line">        <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">          <span class="comment">// Release the mutex before calling into the pair to avoid deadlock.</span></span><br><span class="line">          <span class="comment">// Calling signalIoFailure() will throw, so no need to</span></span><br><span class="line">          <span class="comment">// reacquire.</span></span><br><span class="line">          lock.<span class="built_in">unlock</span>();</span><br><span class="line">          pair_-&gt;<span class="built_in">signalIoFailure</span>(</span><br><span class="line">            <span class="built_in">GLOO_ERROR_MSG</span>(<span class="string">&quot;Send timeout &quot;</span>, pair_-&gt;<span class="built_in">peer</span>().<span class="built_in">str</span>()));</span><br><span class="line">          <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Unexpected code path&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sendCompletions_--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::send</span><span class="params">(<span class="type">size_t</span> offset, <span class="type">size_t</span> length, <span class="type">size_t</span> roffset)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> rv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Can&#x27;t assert on roffset, since we don&#x27;t know the size of</span></span><br><span class="line">  <span class="comment">// the remote buffer. Refactor of initialization code needed</span></span><br><span class="line">  <span class="comment">// to support this.</span></span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_LE</span>(offset + length, size_);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">    <span class="built_in">checkErrorState</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (debug_) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;send &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot; bytes&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Increment number of sends in flight</span></span><br><span class="line">  sendPending_++;</span><br><span class="line"></span><br><span class="line">  pair_-&gt;<span class="built_in">send</span>(<span class="keyword">this</span>, offset, length, roffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h2><p>TCP中包含一个tls层。TLS（Transport Layer Security，安全传输层)，TLS是建立在传输层TCP协议之上的协议，服务于应用层，它的前身是SSL（Secure Socket Layer，安全套接字层），它实现了将应用层的报文进行加密后再交由TCP进行传输的功能。</p>
<h3 id="tls"><a href="#tls" class="headerlink" title="tls"></a>tls</h3><p>上下文：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Context::<span class="built_in">Context</span>(std::shared_ptr&lt;Device&gt; device, <span class="type">int</span> rank, <span class="type">int</span> size)</span><br><span class="line">    : ::gloo::transport::tcp::<span class="built_in">Context</span>(</span><br><span class="line">          std::<span class="built_in">dynamic_pointer_cast</span>&lt;::gloo::transport::tcp::Device&gt;(device),</span><br><span class="line">          rank, size),</span><br><span class="line">      <span class="built_in">ssl_ctx_</span>(<span class="built_in">create_ssl_ctx</span>(<span class="built_in">c_str_or_null</span>(device-&gt;<span class="built_in">getPKeyFile</span>()),</span><br><span class="line">                              <span class="built_in">c_str_or_null</span>(device-&gt;<span class="built_in">getCertFile</span>()),</span><br><span class="line">                              <span class="built_in">c_str_or_null</span>(device-&gt;<span class="built_in">getCAFile</span>()),</span><br><span class="line">                              <span class="built_in">c_str_or_null</span>(device-&gt;<span class="built_in">getCAPath</span>())),</span><br><span class="line">               [](::SSL_CTX *x) &#123; ::_glootls::<span class="built_in">SSL_CTX_free</span>(x); &#125;) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>真正创建ssl context的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SSL_CTX *<span class="title">Context::create_ssl_ctx</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pkey, <span class="type">const</span> <span class="type">char</span> *cert,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> <span class="type">char</span> *ca_file, <span class="type">const</span> <span class="type">char</span> *ca_path)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(pkey != <span class="literal">nullptr</span> &amp;&amp; cert != <span class="literal">nullptr</span>,</span><br><span class="line">               <span class="string">&quot;Private key and certificate location must be specified&quot;</span>);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(ca_file != <span class="literal">nullptr</span> || ca_path != <span class="literal">nullptr</span>,</span><br><span class="line">               <span class="string">&quot;CAfile or CApath must be specified&quot;</span>);</span><br><span class="line">  <span class="type">static</span> std::once_flag ssl_ctx_init_;</span><br><span class="line">  std::<span class="built_in">call_once</span>(ssl_ctx_init_, [] &#123;</span><br><span class="line">    <span class="comment">//    SSL_load_error_strings();</span></span><br><span class="line">    <span class="comment">//    SSL_library_init();</span></span><br><span class="line">    _glootls::<span class="built_in">OPENSSL_init_ssl</span>(</span><br><span class="line">        OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, <span class="literal">NULL</span>);</span><br><span class="line">    _glootls::<span class="built_in">OPENSSL_init_ssl</span>(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  SSL_CTX *ssl_ctx = _glootls::<span class="built_in">SSL_CTX_new</span>(_glootls::<span class="built_in">TLS_method</span>());</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(ssl_ctx != <span class="literal">nullptr</span>, <span class="built_in">getSSLErrorMessage</span>());</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(</span><br><span class="line">      _glootls::<span class="built_in">SSL_CTX_set_min_proto_version</span>(ssl_ctx, TLS_MAX_VERSION) == <span class="number">1</span>,</span><br><span class="line">      <span class="built_in">getSSLErrorMessage</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// As we don&#x27;t need to handle legacy clients,</span></span><br><span class="line">  <span class="comment">// let&#x27;s remove support for legacy renegotiation:</span></span><br><span class="line">  _glootls::<span class="built_in">SSL_CTX_clear_options</span>(ssl_ctx, SSL_OP_LEGACY_SERVER_CONNECT);</span><br><span class="line"></span><br><span class="line">  _glootls::<span class="built_in">SSL_CTX_set_verify_depth</span>(ssl_ctx, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// To enforcing a higher security level, set it to 3.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 2级</span></span><br><span class="line">  <span class="comment">// 安全级别设置为 112 位安全。 因此，禁止使用短于 2048 位的 RSA、DSA 和 DH 密钥以及短于 224 位的 ECC 密钥。</span></span><br><span class="line">  <span class="comment">// 除了 1 级排除之外，还禁止使用任何使用 RC4 的密码套件。 SSL 版本 3 也是不允许的。 压缩被禁用。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Level 3</span></span><br><span class="line">  <span class="comment">// 安全级别设置为 128 位安全。</span></span><br><span class="line">  <span class="comment">// 因此，禁止使用小于 3072 位的 RSA、DSA 和 DHkey 以及小于 256 位的 ECC 密钥。</span></span><br><span class="line">  <span class="comment">// 除了 2 级排除之外，禁止使用不提供前向保密的密码套件。 不允许使用低于 1.1 的 TLS 版本。 会话票证被禁用。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> should be 3, but it doesn&#x27;t work yet :(</span></span><br><span class="line">  _glootls::<span class="built_in">SSL_CTX_set_security_level</span>(ssl_ctx, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(</span><br><span class="line">      _glootls::<span class="built_in">SSL_CTX_load_verify_locations</span>(ssl_ctx, ca_file, ca_path) == <span class="number">1</span>,</span><br><span class="line">      <span class="built_in">getSSLErrorMessage</span>());</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(_glootls::<span class="built_in">SSL_CTX_use_certificate_chain_file</span>(ssl_ctx, cert) == <span class="number">1</span>,</span><br><span class="line">               <span class="built_in">getSSLErrorMessage</span>());</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(_glootls::<span class="built_in">SSL_CTX_use_PrivateKey_file</span>(ssl_ctx, pkey,</span><br><span class="line">                                                     SSL_FILETYPE_PEM) == <span class="number">1</span>,</span><br><span class="line">               <span class="built_in">getSSLErrorMessage</span>());</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(_glootls::<span class="built_in">SSL_CTX_check_private_key</span>(ssl_ctx) == <span class="number">1</span>,</span><br><span class="line">               <span class="built_in">getSSLErrorMessage</span>());</span><br><span class="line">  <span class="comment">// SSL_VERIFY_PEER</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 服务器模式：服务器向客户端发送客户端证书请求。</span></span><br><span class="line">  <span class="comment">// 检查返回的证书（如果有）。 如果验证过程失败，TLS/SSL 握手会立即终止，并发出一条包含验证失败原因的警报消息。</span></span><br><span class="line">  <span class="comment">// 该行为可以通过附加的 SSL_VERIFY_FAIL_IF_NO_PEER_CERT 和 SSL_VERIFY_CLIENT_ONCE 标志来控制。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 客户端模式：验证服务器证书。</span></span><br><span class="line">  <span class="comment">// 如果验证过程失败，TLS/SSL 握手会立即终止，并发出一条包含验证失败原因的警报消息。</span></span><br><span class="line">  <span class="comment">// 如果没有发送服务器证书，因为使用了匿名密码，SSL_VERIFY_PEER 将被忽略。</span></span><br><span class="line">  _glootls::<span class="built_in">SSL_CTX_set_verify</span>(ssl_ctx,</span><br><span class="line">                               SSL_VERIFY_PEER |</span><br><span class="line">                                   SSL_VERIFY_FAIL_IF_NO_PEER_CERT |</span><br><span class="line">                                   SSL_VERIFY_CLIENT_ONCE,</span><br><span class="line">                               <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">return</span> ssl_ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="正经tcp"><a href="#正经tcp" class="headerlink" title="正经tcp"></a>正经tcp</h3><p>同样需要创建通信对，缓冲区，以及处理通信等。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;transport::Pair&gt;&amp; <span class="title">Context::createPair</span><span class="params">(<span class="type">int</span> rank)</span> </span>&#123;</span><br><span class="line">  pairs_[rank] = std::<span class="built_in">unique_ptr</span>&lt;transport::Pair&gt;(</span><br><span class="line">      <span class="keyword">new</span> tcp::<span class="built_in">Pair</span>(<span class="keyword">this</span>, device_.<span class="built_in">get</span>(), rank, <span class="built_in">getTimeout</span>()));</span><br><span class="line">  <span class="keyword">return</span> pairs_[rank];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;transport::UnboundBuffer&gt; <span class="title">Context::createUnboundBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> buf = <span class="keyword">new</span> tcp::<span class="built_in">UnboundBuffer</span>(<span class="built_in">shared_from_this</span>(), ptr, size);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;transport::UnboundBuffer&gt;(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是处理通信的过程<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Context::recvFromAny</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    UnboundBuffer* buf,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span> slot,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> nbytes,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;<span class="type">int</span>&gt; srcRanks)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// Find rank of pair we can attempt a recv from</span></span><br><span class="line">    <span class="keyword">auto</span> rank = <span class="built_in">recvFromAnyFindRank</span>(buf, slot, offset, nbytes, srcRanks);</span><br><span class="line">    <span class="keyword">if</span> (rank == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Try recv from returned rank</span></span><br><span class="line">    <span class="keyword">auto</span> ptr = pairs_[rank].<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(ptr != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">auto</span> pair = <span class="built_in">dynamic_cast</span>&lt;Pair*&gt;(ptr);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(pair != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (pair-&gt;<span class="built_in">tryRecv</span>(buf, slot, offset, nbytes)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Context::recvFromAnyFindRank</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    UnboundBuffer* buf,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span> slot,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> nbytes,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; srcRanks)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See if there is a remote pending send that can fulfill this recv.</span></span><br><span class="line">  <span class="keyword">auto</span> it = <span class="built_in">findPendingOperations</span>(slot);</span><br><span class="line">  <span class="keyword">if</span> (it != pendingOperations_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; pendingOperation = *it;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Out of all remote pending sends, find the first one</span></span><br><span class="line">    <span class="comment">// that exists in the set of eligible ranks.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> rank : pendingOperation.<span class="built_in">getSendList</span>()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> srcRank : srcRanks) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rank == srcRank) &#123;</span><br><span class="line">          <span class="comment">// 我们找到了一个可以满足这个recv的等级。</span></span><br><span class="line">          <span class="comment">// 此函数的调用者将尝试进行recv，如果该远程挂起发送操作仍然存在，它将删除它。</span></span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No candidates; register buffer for recv</span></span><br><span class="line">  pendingRecv_[slot].<span class="built_in">emplace_back</span>(</span><br><span class="line">      buf-&gt;<span class="built_in">getWeakNonOwningPtr</span>(),</span><br><span class="line">      offset,</span><br><span class="line">      nbytes,</span><br><span class="line">      std::<span class="built_in">unordered_set</span>&lt;<span class="type">int</span>&gt;(srcRanks.<span class="built_in">begin</span>(), srcRanks.<span class="built_in">end</span>()));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allowed to be called only by ContextMutator::findRecvFromAny,</span></span><br><span class="line"><span class="comment">// where the context lock is already held.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Context::findRecvFromAny</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span> slot,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> rank,</span></span></span><br><span class="line"><span class="params"><span class="function">    WeakNonOwningPtr&lt;UnboundBuffer&gt;* buf,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span>* offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span>* nbytes)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// See if there is a pending recv for this slot.</span></span><br><span class="line">  <span class="keyword">auto</span> pit = pendingRecv_.<span class="built_in">find</span>(slot);</span><br><span class="line">  <span class="keyword">if</span> (pit != pendingRecv_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; recvs = pit-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over available buffers to find a match.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> rit = recvs.<span class="built_in">begin</span>(); rit != recvs.<span class="built_in">end</span>(); rit++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; ranks = std::<span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(*rit);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果此对等点的rank在此插槽的可接受rank集中，我们可以继续并将缓冲区返回到 recv 中。</span></span><br><span class="line">      <span class="keyword">if</span> (ranks.<span class="built_in">count</span>(rank) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Capture values to return.</span></span><br><span class="line">        *buf = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(*rit);</span><br><span class="line">        *offset = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(*rit);</span><br><span class="line">        *nbytes = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(*rit);</span><br><span class="line">        <span class="comment">// Cleanup.</span></span><br><span class="line">        recvs.<span class="built_in">erase</span>(rit);</span><br><span class="line">        <span class="keyword">if</span> (recvs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          pendingRecv_.<span class="built_in">erase</span>(pit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>其中包含了epoll的使用方法，单独拿出来</p>
<p>创建一个epoll<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Loop::<span class="built_in">Loop</span>() &#123;</span><br><span class="line">  fd_ = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_NE</span>(fd_, <span class="number">-1</span>, <span class="string">&quot;epoll_create: &quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">  loop_.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(&amp;Loop::run, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>epoll_ctl，用于操作epoll函数所生成的实例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys / epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> epoll_ctl（<span class="type">int</span> epfd，<span class="type">int</span> op，<span class="type">int</span> fd，<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> * <span class="title">event</span>）;</span></span><br></pre></td></tr></table></figure><br>该系统调用对文件描述符epfd引用的epoll实例执行控制操作。它要求操作op对目标文件描述符fd执行。op参数的有效值为：</p>
<ul>
<li>EPOLL_CTL_ADD：在文件描述符epfd所引用的epoll实例上注册目标文件描述符fd，并将事件事件与内部文件链接到fd。</li>
<li>EPOLL_CTL_MOD：更改与目标文件描述符fd相关联的事件事件。</li>
<li>EPOLL_CTL_DEL：从epfd引用的epoll实例中删除（注销）目标文件描述符fd。该事件将被忽略，并且可以为NULL。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Loop::registerDescriptor</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, Handler* h)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">  ev.events = events;</span><br><span class="line">  ev.data.ptr = h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> rv = <span class="built_in">epoll_ctl</span>(fd_, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">  <span class="keyword">if</span> (rv == <span class="number">-1</span> &amp;&amp; errno == EEXIST) &#123;</span><br><span class="line">    rv = <span class="built_in">epoll_ctl</span>(fd_, EPOLL_CTL_MOD, fd, &amp;ev);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_NE</span>(rv, <span class="number">-1</span>, <span class="string">&quot;epoll_ctl: &quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Loop::unregisterDescriptor</span><span class="params">(<span class="type">int</span> fd, Handler* h)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> rv = <span class="built_in">epoll_ctl</span>(fd_, EPOLL_CTL_DEL, fd, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_NE</span>(rv, <span class="number">-1</span>, <span class="string">&quot;epoll_ctl: &quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for loop to tick before returning, to make sure the handler</span></span><br><span class="line">  <span class="comment">// for this fd is not called once this function returns.</span></span><br><span class="line">  <span class="keyword">if</span> (std::this_thread::<span class="built_in">get_id</span>() != loop_-&gt;<span class="built_in">get_id</span>()) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">    cv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">    <span class="built_in">TSAN_ANNOTATE_HAPPENS_AFTER</span>(h);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等待某个epoll完成<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Loop::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::array&lt;<span class="keyword">struct</span> epoll_event, capacity_&gt; events;</span><br><span class="line">  <span class="type">int</span> nfds;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!done_) &#123;</span><br><span class="line">    <span class="comment">// Wakeup everyone waiting for a loop tick to finish.</span></span><br><span class="line">    cv_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for something to happen</span></span><br><span class="line">    nfds = <span class="built_in">epoll_wait</span>(fd_, events.<span class="built_in">data</span>(), events.<span class="built_in">size</span>(), <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">-1</span> &amp;&amp; errno == EINTR) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_NE</span>(nfds, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">      Handler* h = <span class="built_in">reinterpret_cast</span>&lt;Handler*&gt;(events[i].data.ptr);</span><br><span class="line">      h-&gt;<span class="built_in">handleEvents</span>(events[i].events);</span><br><span class="line">      <span class="built_in">TSAN_ANNOTATE_HAPPENS_BEFORE</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="mpi"><a href="#mpi" class="headerlink" title="mpi"></a>mpi</h1><p>mpi相关的通信操作，MPIScope应该是MPI的上下文什么的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;MPIScope&gt; <span class="title">getMPIScope</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> std::once_flag once;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use weak pointer so that the initializer is destructed when the</span></span><br><span class="line">  <span class="comment">// last context referring to it is destructed, not when statics</span></span><br><span class="line">  <span class="comment">// are destructed on program termination.</span></span><br><span class="line">  <span class="type">static</span> std::weak_ptr&lt;MPIScope&gt; wptr;</span><br><span class="line">  std::shared_ptr&lt;MPIScope&gt; sptr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create MPIScope only once</span></span><br><span class="line">  std::<span class="built_in">call_once</span>(once, [&amp;]() &#123;</span><br><span class="line">      sptr = std::<span class="built_in">make_shared</span>&lt;MPIScope&gt;();</span><br><span class="line">      wptr = sptr;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create shared_ptr&lt;MPIScope&gt; from weak_ptr</span></span><br><span class="line">  sptr = wptr.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(sptr, <span class="string">&quot;Cannot create MPI context after MPI_Finalize()&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> sptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回MPI上下文（通信域）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Context&gt; <span class="title">Context::createManaged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> mpiScope = <span class="built_in">getMPIScope</span>();</span><br><span class="line">  <span class="keyword">auto</span> context = std::<span class="built_in">make_shared</span>&lt;Context&gt;(MPI_COMM_WORLD);</span><br><span class="line">  context-&gt;mpiScope_ = std::<span class="built_in">move</span>(mpiScope);</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Context::<span class="built_in">Context</span>(<span class="type">const</span> MPI_Comm&amp; comm)</span><br><span class="line">    : ::gloo::<span class="built_in">Context</span>(<span class="built_in">MPICommRank</span>(comm), <span class="built_in">MPICommSize</span>(comm)) &#123;</span><br><span class="line">  <span class="keyword">auto</span> error = <span class="built_in">MPI_Comm_dup</span>(comm, &amp;comm_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(error == MPI_SUCCESS, <span class="string">&quot;MPI_Comm_dup: &quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Context::~<span class="built_in">Context</span>() &#123;</span><br><span class="line">  <span class="built_in">MPI_Comm_free</span>(&amp;comm_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为本进程和其他进程创建通信对pair和缓冲区<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Context::connectFullMesh</span><span class="params">(std::shared_ptr&lt;transport::Device&gt;&amp; dev)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">addresses</span>(size);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> maxLength = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> rv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create pair to connect to every other node in the collective</span></span><br><span class="line">  <span class="keyword">auto</span> transportContext = dev-&gt;<span class="built_in">createContext</span>(rank, size);</span><br><span class="line">  transportContext-&gt;<span class="built_in">setTimeout</span>(<span class="built_in">getTimeout</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == rank) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; pair = transportContext-&gt;<span class="built_in">createPair</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store address for pair for this rank</span></span><br><span class="line">    <span class="keyword">auto</span> address = pair-&gt;<span class="built_in">address</span>().<span class="built_in">bytes</span>();</span><br><span class="line">    maxLength = std::<span class="built_in">max</span>(maxLength, address.<span class="built_in">size</span>());</span><br><span class="line">    addresses[i] = std::<span class="built_in">move</span>(address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Agree on maximum length so we can prepare buffers</span></span><br><span class="line">  rv = <span class="built_in">MPI_Allreduce</span>(</span><br><span class="line">    MPI_IN_PLACE, &amp;maxLength, <span class="number">1</span>, MPI_UNSIGNED_LONG, MPI_MAX, comm_);</span><br><span class="line">  <span class="keyword">if</span> (rv != MPI_SUCCESS) &#123;</span><br><span class="line">    <span class="built_in">GLOO_THROW_IO_EXCEPTION</span>(<span class="string">&quot;MPI_Allreduce: &quot;</span>, rv);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prepare input and output</span></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">in</span><span class="params">(size * maxLength)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">out</span><span class="params">(size * size * maxLength)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == rank) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; address = addresses[i];</span><br><span class="line">    <span class="built_in">memcpy</span>(in.<span class="built_in">data</span>() + (i * maxLength), address.<span class="built_in">data</span>(), address.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allgather to collect all addresses of all pairs</span></span><br><span class="line">  rv = <span class="built_in">MPI_Allgather</span>(</span><br><span class="line">    in.<span class="built_in">data</span>(), in.<span class="built_in">size</span>(), MPI_BYTE, out.<span class="built_in">data</span>(), in.<span class="built_in">size</span>(), MPI_BYTE, comm_);</span><br><span class="line">  <span class="keyword">if</span> (rv != MPI_SUCCESS) &#123;</span><br><span class="line">    <span class="built_in">GLOO_THROW_IO_EXCEPTION</span>(<span class="string">&quot;MPI_Allgather: &quot;</span>, rv);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Connect every pair</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == rank) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> offset = (rank + i * size) * maxLength;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">address</span><span class="params">(maxLength)</span></span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(address.<span class="built_in">data</span>(), out.<span class="built_in">data</span>() + offset, maxLength);</span><br><span class="line">    transportContext-&gt;<span class="built_in">getPair</span>(i)-&gt;<span class="built_in">connect</span>(address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  device_ = dev;</span><br><span class="line">  transportContext_ = std::<span class="built_in">move</span>(transportContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><p>首先得获取本进程的左方和右方<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper for ring algorithms</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;transport::Pair&gt;&amp; <span class="title">Algorithm::getLeftPair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> rank = (context_-&gt;size + context_-&gt;rank - <span class="number">1</span>) % context_-&gt;size;</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(context_-&gt;<span class="built_in">getPair</span>(rank), <span class="string">&quot;pair missing (index &quot;</span>, rank, <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> context_-&gt;<span class="built_in">getPair</span>(rank);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper for ring algorithms</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;transport::Pair&gt;&amp; <span class="title">Algorithm::getRightPair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> rank = (context_-&gt;rank + <span class="number">1</span>) % context_-&gt;size;</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(context_-&gt;<span class="built_in">getPair</span>(rank), <span class="string">&quot;pair missing (index &quot;</span>, rank, <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> context_-&gt;<span class="built_in">getPair</span>(rank);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>gloo支持reduce的一些操作，对于一些reduce时自定义的方法，gloo也做了兼容：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type of reduction function.</span></span><br><span class="line"><span class="comment">// 如果reduce类型是内置类型之一，则算法实现可以使用加速版本（如果可用）。</span></span><br><span class="line"><span class="comment">// 例如，如果将 ReductionType 等于 SUM 的 ReductionFunction 传递给 CUDA 感知的 Allreduce，它知道它可以使用 NCCL 实现而不是指定的函数。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ReductionType</span> &#123;</span><br><span class="line">  SUM = <span class="number">1</span>,</span><br><span class="line">  PRODUCT = <span class="number">2</span>,</span><br><span class="line">  MAX = <span class="number">3</span>,</span><br><span class="line">  MIN = <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use larger number so we have plenty of room to add built-ins</span></span><br><span class="line">  CUSTOM = <span class="number">1000</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReductionFunction</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Function = <span class="built_in">void</span>(T*, <span class="type">const</span> T*, <span class="type">size_t</span> n);</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> ReductionFunction&lt;T&gt;* sum;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> ReductionFunction&lt;T&gt;* product;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> ReductionFunction&lt;T&gt;* min;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> ReductionFunction&lt;T&gt;* max;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReductionFunction</span>(ReductionType type, Function* fn)</span><br><span class="line">      : <span class="built_in">type_</span>(type), <span class="built_in">fn_</span>(fn) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ReductionType <span class="title">type</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">(T* x, <span class="type">const</span> T* y, <span class="type">size_t</span> n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fn_</span>(x, y, n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ReductionType type_;</span><br><span class="line">  Function* fn_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> ReductionFunction&lt;T&gt;* ReductionFunction&lt;T&gt;::sum =</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">ReductionFunction</span>&lt;T&gt;(SUM, &amp;::gloo::sum&lt;T&gt;);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> ReductionFunction&lt;T&gt;* ReductionFunction&lt;T&gt;::product =</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">ReductionFunction</span>&lt;T&gt;(PRODUCT, &amp;::gloo::product&lt;T&gt;);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> ReductionFunction&lt;T&gt;* ReductionFunction&lt;T&gt;::min =</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">ReductionFunction</span>&lt;T&gt;(MIN, &amp;::gloo::min&lt;T&gt;);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> ReductionFunction&lt;T&gt;* ReductionFunction&lt;T&gt;::max =</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">ReductionFunction</span>&lt;T&gt;(MAX, &amp;::gloo::max&lt;T&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Local operation.</span></span><br><span class="line"><span class="comment">// If an algorithm uses multiple local pointers, local operations</span></span><br><span class="line"><span class="comment">// can be used for local reduction, broadcast, gathering, etc.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LocalOp</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">LocalOp</span>() <span class="built_in">noexcept</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">runAsync</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">wait</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Synchronous run is equal to asynchronous run and wait.</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">runAsync</span>();</span><br><span class="line">    <span class="built_in">wait</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="allgather"><a href="#allgather" class="headerlink" title="allgather"></a>allgather</h1><p>AllgatherRing 类似于 MPI_Allgather，所有进程都从所有其他进程接收缓冲区（inPtrs）。 调用者需要传递一个预先分配的接收缓冲区 (outPtr)，其大小等于[ 上下文大小 x 发送缓冲区的总大小] (inPtrs)，其中 rank = k 的进程的发送缓冲区将被写入 outPtr[k <em> 输入缓冲区数量 </em> count] 连续。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AllgatherRing</span> : <span class="keyword">public</span> Algorithm &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AllgatherRing</span>(</span><br><span class="line">      <span class="type">const</span> std::shared_ptr&lt;Context&gt;&amp; context,</span><br><span class="line">      <span class="type">const</span> std::vector&lt;<span class="type">const</span> T*&gt;&amp; inPtrs,</span><br><span class="line">      T* outPtr,</span><br><span class="line">      <span class="type">int</span> count)</span><br><span class="line">      : <span class="built_in">Algorithm</span>(context),</span><br><span class="line">        <span class="built_in">inPtrs_</span>(inPtrs),</span><br><span class="line">        <span class="built_in">outPtr_</span>(outPtr),</span><br><span class="line">        <span class="built_in">count_</span>(count),</span><br><span class="line">        <span class="built_in">bytes_</span>(count * <span class="built_in">sizeof</span>(T)),</span><br><span class="line">        <span class="built_in">inputStride_</span>(count_ * inPtrs_.<span class="built_in">size</span>()),</span><br><span class="line">        <span class="built_in">leftPair_</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getLeftPair</span>()),</span><br><span class="line">        <span class="built_in">rightPair_</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getRightPair</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> slot = <span class="keyword">this</span>-&gt;context_-&gt;<span class="built_in">nextSlot</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;transport::Buffer&gt;</span></span><br><span class="line">    sendDataBuf_ = rightPair_-&gt;<span class="built_in">createSendBuffer</span>(</span><br><span class="line">        slot, outPtr_, inPtrs_.<span class="built_in">size</span>() * context_-&gt;size * bytes_);</span><br><span class="line">    recvDataBuf_ = leftPair_-&gt;<span class="built_in">createRecvBuffer</span>(</span><br><span class="line">        slot, outPtr_, inPtrs_.<span class="built_in">size</span>() * context_-&gt;size * bytes_);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> notificationSlot = <span class="keyword">this</span>-&gt;context_-&gt;<span class="built_in">nextSlot</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;transport::Buffer&gt;</span></span><br><span class="line">    sendNotificationBuf_ =</span><br><span class="line">        leftPair_-&gt;<span class="built_in">createSendBuffer</span>(notificationSlot, &amp;dummy_, <span class="built_in">sizeof</span>(dummy_));</span><br><span class="line">    recvNotificationBuf_ =</span><br><span class="line">        rightPair_-&gt;<span class="built_in">createRecvBuffer</span>(notificationSlot, &amp;dummy_, <span class="built_in">sizeof</span>(dummy_));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>真正运行的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> rank = <span class="keyword">this</span>-&gt;contextRank_;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numRounds = <span class="keyword">this</span>-&gt;contextSize_ - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy local buffers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inPtrs_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(outPtr_ + rank * inputStride_ + i * count_, inPtrs_[i], bytes_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We send input buffers in order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inPtrs_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="comment">// We start every iteration by sending local buffer.</span></span><br><span class="line">      <span class="type">int</span> inRank = rank;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 10个进程，就是9个round。1号进程，第一个round给0，第二个round给9，第三个round给8...</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> round = <span class="number">0</span>; round &lt; numRounds; round++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sendOffset = inRank * inputStride_ + i * count_;</span><br><span class="line">        sendDataBuf_-&gt;<span class="built_in">send</span>(</span><br><span class="line">            sendOffset * <span class="built_in">sizeof</span>(T), bytes_, sendOffset * <span class="built_in">sizeof</span>(T));</span><br><span class="line">        recvDataBuf_-&gt;<span class="built_in">waitRecv</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Nodes receive data from the left node in every round and forward it</span></span><br><span class="line">        <span class="comment">// to the right node.</span></span><br><span class="line">        inRank = (numRounds - round + rank) % <span class="keyword">this</span>-&gt;contextSize_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Send notification to node on the left that this node is ready for an</span></span><br><span class="line">        <span class="comment">// inbox write.</span></span><br><span class="line">        sendNotificationBuf_-&gt;<span class="built_in">send</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait for notification from node on the right.</span></span><br><span class="line">        recvNotificationBuf_-&gt;<span class="built_in">waitRecv</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> std::vector&lt;<span class="type">const</span> T*&gt; inPtrs_;</span><br><span class="line">  T* outPtr_;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> count_;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> bytes_;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> inputStride_;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;transport::Pair&gt;&amp; leftPair_;</span><br><span class="line">  std::unique_ptr&lt;transport::Pair&gt;&amp; rightPair_;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;transport::Buffer&gt; sendDataBuf_;</span><br><span class="line">  std::unique_ptr&lt;transport::Buffer&gt; recvDataBuf_;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> dummy_;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;transport::Buffer&gt; sendNotificationBuf_;</span><br><span class="line">  std::unique_ptr&lt;transport::Buffer&gt; recvNotificationBuf_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="一般的allgather"><a href="#一般的allgather" class="headerlink" title="一般的allgather"></a>一般的allgather</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">allgather</span><span class="params">(AllgatherOptions&amp; opts)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  transport::UnboundBuffer* in = opts.in.<span class="built_in">get</span>();</span><br><span class="line">  transport::UnboundBuffer* out = opts.out.<span class="built_in">get</span>();</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kAllgatherSlotPrefix, opts.tag);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> recvRank = (context-&gt;size + context-&gt;rank - <span class="number">1</span>) % context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> sendRank = (context-&gt;size + context-&gt;rank + <span class="number">1</span>) % context-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> inBytes = out-&gt;size / context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> outBytes = out-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the input buffer is specified, this is NOT an in place operation,</span></span><br><span class="line">  <span class="comment">// and the output buffer needs to be primed with the input.</span></span><br><span class="line">  <span class="keyword">if</span> (in != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out-&gt;ptr) + context-&gt;rank * in-&gt;size,</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(in-&gt;ptr),</span><br><span class="line">        in-&gt;size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Short circuit if there is only a single process.</span></span><br><span class="line">  <span class="keyword">if</span> (context-&gt;size == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The chunk size may not be divisible by 2; use dynamic lookup.</span></span><br><span class="line">  std::array&lt;<span class="type">size_t</span>, 2&gt; chunkSize;</span><br><span class="line">  chunkSize[<span class="number">0</span>] = inBytes / <span class="number">2</span>;</span><br><span class="line">  chunkSize[<span class="number">1</span>] = inBytes - chunkSize[<span class="number">0</span>];</span><br><span class="line">  std::array&lt;<span class="type">size_t</span>, 2&gt; chunkOffset;</span><br><span class="line">  chunkOffset[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  chunkOffset[<span class="number">1</span>] = chunkSize[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 10个进程，1号进程</span></span><br><span class="line">  <span class="comment">// send to 2，recv from 0</span></span><br><span class="line">  <span class="comment">// send seg = 11 11 10 10 9 9 8 8 ...</span></span><br><span class="line">  <span class="comment">// recv seg = 10 10 9  9  8 8 7 7 ...</span></span><br><span class="line">  <span class="comment">// i &amp; 0x1  = 0  1  0  1  0 1 0 1 ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; (context-&gt;size - <span class="number">1</span>) * <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> sendSegment = context-&gt;size + context-&gt;rank - (i / <span class="number">2</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> recvSegment = sendSegment - <span class="number">1</span>;</span><br><span class="line">    <span class="type">size_t</span> sendOffset =</span><br><span class="line">        ((sendSegment * inBytes) + chunkOffset[i &amp; <span class="number">0x1</span>]) % outBytes;</span><br><span class="line">    <span class="type">size_t</span> recvOffset =</span><br><span class="line">        ((recvSegment * inBytes) + chunkOffset[i &amp; <span class="number">0x1</span>]) % outBytes;</span><br><span class="line">    <span class="type">size_t</span> size = chunkSize[i &amp; <span class="number">0x1</span>];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      out-&gt;<span class="built_in">send</span>(sendRank, slot, sendOffset, size);</span><br><span class="line">      out-&gt;<span class="built_in">recv</span>(recvRank, slot, recvOffset, size);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for pending operations to complete to synchronize with the</span></span><br><span class="line">    <span class="comment">// previous iteration. Because we kick off two operations before</span></span><br><span class="line">    <span class="comment">// getting here we always wait for the next-to-last operation.</span></span><br><span class="line">    out-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">    out-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">    out-&gt;<span class="built_in">send</span>(sendRank, slot, sendOffset, size);</span><br><span class="line">    out-&gt;<span class="built_in">recv</span>(recvRank, slot, recvOffset, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for completes</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    out-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">    out-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="allgatherv"><a href="#allgatherv" class="headerlink" title="allgatherv"></a>allgatherv</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">allgatherv</span><span class="params">(AllgathervOptions&amp; opts)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  transport::UnboundBuffer* in = opts.in.<span class="built_in">get</span>();</span><br><span class="line">  transport::UnboundBuffer* out = opts.out.<span class="built_in">get</span>();</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kAllgatherSlotPrefix, opts.tag);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> recvRank = (context-&gt;size + context-&gt;rank - <span class="number">1</span>) % context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> sendRank = (context-&gt;size + context-&gt;rank + <span class="number">1</span>) % context-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算每个进程对应的长度和偏移</span></span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt; byteCounts;</span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt; byteOffsets;</span><br><span class="line">  byteCounts.<span class="built_in">reserve</span>(context-&gt;size);</span><br><span class="line">  byteOffsets.<span class="built_in">reserve</span>(context-&gt;size);</span><br><span class="line">  <span class="type">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elements : opts.elements) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> bytes = elements * opts.elementSize;</span><br><span class="line">    byteCounts.<span class="built_in">push_back</span>(bytes);</span><br><span class="line">    byteOffsets.<span class="built_in">push_back</span>(offset);</span><br><span class="line">    offset += bytes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果指定了输入缓冲区，则需要准备输出缓冲区。</span></span><br><span class="line">  <span class="keyword">if</span> (in != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(byteCounts[context-&gt;rank], in-&gt;size);</span><br><span class="line">    <span class="keyword">if</span> (byteCounts[context-&gt;rank] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out-&gt;ptr) + byteOffsets[context-&gt;rank],</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(in-&gt;ptr),</span><br><span class="line">          in-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Short circuit if there is only a single process.</span></span><br><span class="line">  <span class="keyword">if</span> (context-&gt;size == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> baseIndex = context-&gt;size + context-&gt;rank;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; context-&gt;size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> sendIndex = (baseIndex - i) % context-&gt;size;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> recvIndex = (baseIndex - i - <span class="number">1</span>) % context-&gt;size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      out-&gt;<span class="built_in">send</span>(sendRank, slot, byteOffsets[sendIndex], byteCounts[sendIndex]);</span><br><span class="line">      out-&gt;<span class="built_in">recv</span>(recvRank, slot, byteOffsets[recvIndex], byteCounts[recvIndex]);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for previous operations to complete before kicking off new ones.</span></span><br><span class="line">    out-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">    out-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">    out-&gt;<span class="built_in">send</span>(sendRank, slot, byteOffsets[sendIndex], byteCounts[sendIndex]);</span><br><span class="line">    out-&gt;<span class="built_in">recv</span>(recvRank, slot, byteOffsets[recvIndex], byteCounts[recvIndex]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for final operations to complete.</span></span><br><span class="line">  out-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">  out-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="allreduce"><a href="#allreduce" class="headerlink" title="allreduce"></a>allreduce</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> BufferVector = std::vector&lt;std::unique_ptr&lt;transport::UnboundBuffer&gt;&gt;;</span><br><span class="line"><span class="keyword">using</span> ReductionFunction = AllreduceOptions::Func;</span><br><span class="line"><span class="keyword">using</span> ReduceRangeFunction = std::function&lt;<span class="built_in">void</span>(<span class="type">size_t</span>, <span class="type">size_t</span>)&gt;;</span><br><span class="line"><span class="keyword">using</span> BroadcastRangeFunction = std::function&lt;<span class="built_in">void</span>(<span class="type">size_t</span>, <span class="type">size_t</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Forward declaration of ring algorithm implementation.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ring</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> detail::AllreduceOptionsImpl&amp; opts,</span></span></span><br><span class="line"><span class="params"><span class="function">    ReduceRangeFunction reduceInputs,</span></span></span><br><span class="line"><span class="params"><span class="function">    BroadcastRangeFunction broadcastOutputs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Forward declaration of bcube algorithm implementation.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bcube</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> detail::AllreduceOptionsImpl&amp; opts,</span></span></span><br><span class="line"><span class="params"><span class="function">    ReduceRangeFunction reduceInputs,</span></span></span><br><span class="line"><span class="params"><span class="function">    BroadcastRangeFunction broadcastOutputs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReductionFunction type describes the function to use for element wise reduction.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Its arguments are:</span></span><br><span class="line"><span class="comment">//   1. non-const output pointer</span></span><br><span class="line"><span class="comment">//   2. const input pointer 1 (may be equal to 1)</span></span><br><span class="line"><span class="comment">//   3. const input pointer 2 (may be equal to 1)</span></span><br><span class="line"><span class="comment">//   4. number of elements to reduce.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 请注意，此函数不是严格类型的，并且采用 void 指针。</span></span><br><span class="line"><span class="comment">// 这样做是为了避免需要模板化选项类和模板化算法实现。</span></span><br><span class="line"><span class="comment">// 我们发现这对编译时间和代码大小的增加几乎没有任何价值。s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回计算输入的局部reduce并将其存储在这些缓冲区中给定范围的输出中的函数。</span></span><br><span class="line"><span class="comment">// 这是在向邻居发送区域或reduce从邻居接收的区域之前完成的。</span></span><br><span class="line"><span class="function">ReduceRangeFunction <span class="title">genLocalReduceFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> BufferVector&amp; in, <span class="comment">// UnboundBuffer的unique_ptr的vector</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> BufferVector&amp; out,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> elementSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    ReductionFunction fn)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据传进来的buffer长度，执行reduce函数</span></span><br><span class="line">  <span class="keyword">if</span> (in.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (in.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [&amp;in, &amp;out](<span class="type">size_t</span> offset, <span class="type">size_t</span> length) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(in[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">            length);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> [&amp;in, &amp;out, elementSize, fn](<span class="type">size_t</span> offset, <span class="type">size_t</span> length) &#123;</span><br><span class="line">        <span class="built_in">fn</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">           <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(in[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">           <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(in[<span class="number">1</span>]-&gt;ptr) + offset,</span><br><span class="line">           length / elementSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">2</span>; i &lt; in.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          <span class="built_in">fn</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">             <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">             <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(in[i]-&gt;ptr) + offset,</span><br><span class="line">             length / elementSize);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [&amp;out, elementSize, fn](<span class="type">size_t</span> offset, <span class="type">size_t</span> length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; out.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">fn</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">           <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">           <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(out[i]-&gt;ptr) + offset,</span><br><span class="line">           length / elementSize);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对缓冲区中给定范围的输出执行本地广播的函数。 这是在接收到每个全局reduce的块之后执行的。</span></span><br><span class="line"><span class="function">BroadcastRangeFunction <span class="title">genLocalBroadcastFunction</span><span class="params">(<span class="type">const</span> BufferVector&amp; out)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [&amp;out](<span class="type">size_t</span> offset, <span class="type">size_t</span> length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; out.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out[i]-&gt;ptr) + offset,</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">          length);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allreduce</span><span class="params">(<span class="type">const</span> detail::AllreduceOptionsImpl&amp; opts)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (opts.elements == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  <span class="type">const</span> std::vector&lt;std::unique_ptr&lt;transport::UnboundBuffer&gt;&gt;&amp; in = opts.in;</span><br><span class="line">  <span class="type">const</span> std::vector&lt;std::unique_ptr&lt;transport::UnboundBuffer&gt;&gt;&amp; out = opts.out;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kAllreduceSlotPrefix, opts.tag);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化本地归约和广播功能。</span></span><br><span class="line">  <span class="comment">// 请注意，如果仅指定单个输出并将其用作输入和输出，则这些是无操作的。</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> reduceInputs =</span><br><span class="line">      <span class="built_in">genLocalReduceFunction</span>(in, out, opts.elementSize, opts.reduce);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> broadcastOutputs = <span class="built_in">genLocalBroadcastFunction</span>(out);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Simple circuit if there is only a single process.</span></span><br><span class="line">  <span class="keyword">if</span> (context-&gt;size == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">reduceInputs</span>(<span class="number">0</span>, totalBytes);</span><br><span class="line">    <span class="built_in">broadcastOutputs</span>(<span class="number">0</span>, totalBytes);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (opts.algorithm) &#123;</span><br><span class="line">    <span class="keyword">case</span> detail::AllreduceOptionsImpl::UNSPECIFIED:</span><br><span class="line">    <span class="keyword">case</span> detail::AllreduceOptionsImpl::RING:</span><br><span class="line">      <span class="built_in">ring</span>(opts, reduceInputs, broadcastOutputs);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> detail::AllreduceOptionsImpl::BCUBE:</span><br><span class="line">      <span class="built_in">bcube</span>(opts, reduceInputs, broadcastOutputs);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Algorithm not handled.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="allreduce的ring方法"><a href="#allreduce的ring方法" class="headerlink" title="allreduce的ring方法"></a>allreduce的ring方法</h2><p>给定的输入被分成与进程数相等的块数。 算法完成后，每个进程按顺序托管一个reduction输出块（rank 0 具有块 0，rank 1 具有块 1，等等）。由于输入可能不能被进程数整除，因此最终的块有部分输出或可能为空。</p>
<p>当一个块沿着环传递并且包含连续更多rank的reduction时，我们必须在为该块执行 I/O 和计算接收到的块和本地块之间的reduction之间交替。为了避免这种交替模式，我们将一个块分成多个段（&gt; = 2），并确保我们有一个段在运行，同时计算另一个段的reduction。</p>
<p>段大小有一个上限，以最大限度地减少内存使用并避免不良的缓存行为。 这意味着在处理非常大的输入时，每个块可能有很多段。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ring</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> detail::AllreduceOptionsImpl&amp; opts,</span></span></span><br><span class="line"><span class="params"><span class="function">    ReduceRangeFunction reduceInputs,</span></span></span><br><span class="line"><span class="params"><span class="function">    BroadcastRangeFunction broadcastOutputs)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  <span class="type">const</span> std::vector&lt;std::unique_ptr&lt;transport::UnboundBuffer&gt;&gt;&amp; out = opts.out;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kAllreduceSlotPrefix, opts.tag);</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> totalBytes = opts.elements * opts.elementSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: context-&gt;size &gt; 1</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> recvRank = (context-&gt;size + context-&gt;rank + <span class="number">1</span>) % context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> sendRank = (context-&gt;size + context-&gt;rank - <span class="number">1</span>) % context-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保最大段大小是元素大小的倍数。</span></span><br><span class="line">  <span class="comment">// 否则，在向上舍入到元素大小的最接近倍数后，段大小可能会超过最大段大小。</span></span><br><span class="line">  <span class="comment">// 例如，如果maxSegmentSize = 10，而elementSize = 4，则向上取整后：segmentSize = 12；</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> maxSegmentBytes = opts.elementSize *</span><br><span class="line">      std::<span class="built_in">max</span>((<span class="type">size_t</span>)<span class="number">1</span>, opts.maxSegmentSize / opts.elementSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute how many segments make up the input buffer.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 向上舍入到上下文大小的最接近的倍数，以便每个进程有相同数量的段，并且跨进程的执行是对称的。</span></span><br><span class="line">  <span class="comment">// 最小值是上下文大小的两倍，因为下面的算法将发送/接收一个段与计算另一个段的reduction。</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> numSegments = <span class="built_in">roundUp</span>(</span><br><span class="line">      std::<span class="built_in">max</span>(</span><br><span class="line">          (totalBytes + (maxSegmentBytes - <span class="number">1</span>)) / maxSegmentBytes,</span><br><span class="line">          (<span class="type">size_t</span>)context-&gt;size * <span class="number">2</span>),</span><br><span class="line">      (<span class="type">size_t</span>)context-&gt;size);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> numSegmentsPerRank = numSegments / context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> segmentBytes =</span><br><span class="line">      <span class="built_in">roundUp</span>((totalBytes + numSegments - <span class="number">1</span>) / numSegments, opts.elementSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate scratch space to hold two chunks</span></span><br><span class="line">  <span class="function">std::unique_ptr&lt;<span class="type">uint8_t</span>[]&gt; <span class="title">tmpAllocation</span><span class="params">(<span class="keyword">new</span> <span class="type">uint8_t</span>[segmentBytes * <span class="number">2</span>])</span></span>;</span><br><span class="line">  std::unique_ptr&lt;transport::UnboundBuffer&gt; tmpBuffer =</span><br><span class="line">      context-&gt;<span class="built_in">createUnboundBuffer</span>(tmpAllocation.<span class="built_in">get</span>(), segmentBytes * <span class="number">2</span>);</span><br><span class="line">  transport::UnboundBuffer* tmp = tmpBuffer.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用动态查找临时缓冲区中的块偏移量。</span></span><br><span class="line">  <span class="comment">// 在进行两个操作时，我们需要两个偏移量。 可以使用循环计数器对它们进行索引。</span></span><br><span class="line">  std::array&lt;<span class="type">size_t</span>, 2&gt; segmentOffset;</span><br><span class="line">  segmentOffset[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  segmentOffset[<span class="number">1</span>] = segmentBytes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算在reduce/scatter为给定迭代发送和接收的段的偏移量和长度。</span></span><br><span class="line">  <span class="keyword">auto</span> computeReduceScatterOffsets = [&amp;](<span class="type">size_t</span> i) &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      <span class="type">size_t</span> sendOffset;</span><br><span class="line">      <span class="type">size_t</span> recvOffset;</span><br><span class="line">      <span class="type">ssize_t</span> sendLength;</span><br><span class="line">      <span class="type">ssize_t</span> recvLength;</span><br><span class="line">    &#125; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算要发送的段索引（到 rank-1）和要接收的段索引（从 rank+1）。</span></span><br><span class="line">    <span class="comment">// 乘以块中的字节数以获得偏移量。</span></span><br><span class="line">    <span class="comment">// 允许偏移量超出范围（&gt;=totalBytes），计算相关长度时会考虑到这一点。</span></span><br><span class="line">    result.sendOffset =</span><br><span class="line">        ((((context-&gt;rank + <span class="number">1</span>) * numSegmentsPerRank) + i) * segmentBytes) %</span><br><span class="line">        (numSegments * segmentBytes);</span><br><span class="line">    result.recvOffset =</span><br><span class="line">        ((((context-&gt;rank + <span class="number">2</span>) * numSegmentsPerRank) + i) * segmentBytes) %</span><br><span class="line">        (numSegments * segmentBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the segment is entirely in range, the following statement is</span></span><br><span class="line">    <span class="comment">// equal to segmentBytes. If it isn&#x27;t, it will be less, or even</span></span><br><span class="line">    <span class="comment">// negative. This is why the ssize_t typecasts are needed.</span></span><br><span class="line">    result.sendLength = std::<span class="built_in">min</span>(</span><br><span class="line">        (<span class="type">ssize_t</span>)segmentBytes,</span><br><span class="line">        (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)result.sendOffset);</span><br><span class="line">    result.recvLength = std::<span class="built_in">min</span>(</span><br><span class="line">        (<span class="type">ssize_t</span>)segmentBytes,</span><br><span class="line">        (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)result.recvOffset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ring reduce/scatter.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 迭代次数计算如下：</span></span><br><span class="line">  <span class="comment">// - 使用 `numSegments` 作为段的总数，</span></span><br><span class="line">  <span class="comment">// - 减去 `numSegmentsPerRank`，因为最终段包含部分结果，在此阶段不得转发。</span></span><br><span class="line">  <span class="comment">// - 添加 2，因为我们通过管道发送和接收操作（我们在迭代 0 和 1 上发出发送/接收操作并等待它们在迭代 2 和 3 上完成）。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; (numSegments - numSegmentsPerRank + <span class="number">2</span>); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">// 计算两次迭代前的发送和接收偏移量和长度。</span></span><br><span class="line">      <span class="comment">// 需要这样我们知道何时等待操作以及何时忽略（当偏移量超出范围时），并知道在哪里减少临时缓冲区的内容。</span></span><br><span class="line">      <span class="keyword">auto</span> prev = <span class="built_in">computeReduceScatterOffsets</span>(i - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (prev.recvLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Prepare out[0]-&gt;ptr to hold the local reduction</span></span><br><span class="line">        <span class="built_in">reduceInputs</span>(prev.recvOffset, prev.recvLength);</span><br><span class="line">        <span class="comment">// Wait for segment from neighbor.</span></span><br><span class="line">        tmp-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">        <span class="comment">// 对收到的段进行reduce</span></span><br><span class="line">        opts.<span class="built_in">reduce</span>(</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + prev.recvOffset,</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + prev.recvOffset,</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tmp-&gt;ptr) + segmentOffset[i &amp; <span class="number">0x1</span>],</span><br><span class="line">            prev.recvLength / opts.elementSize);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (prev.sendLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out[<span class="number">0</span>]-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在最后两次迭代之外的所有迭代中发出新的发送和接收操作。</span></span><br><span class="line">    <span class="comment">// 那时我们已经发送了我们需要的所有数据，只需要等待最终的段被reduce到输出中。</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; (numSegments - numSegmentsPerRank)) &#123;</span><br><span class="line">      <span class="comment">// Compute send and receive offsets and lengths for this iteration.</span></span><br><span class="line">      <span class="keyword">auto</span> cur = <span class="built_in">computeReduceScatterOffsets</span>(i);</span><br><span class="line">      <span class="keyword">if</span> (cur.recvLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        tmp-&gt;<span class="built_in">recv</span>(recvRank, slot, segmentOffset[i &amp; <span class="number">0x1</span>], cur.recvLength);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur.sendLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Prepare out[0]-&gt;ptr to hold the local reduction for this segment</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; numSegmentsPerRank) &#123;</span><br><span class="line">          <span class="built_in">reduceInputs</span>(cur.sendOffset, cur.sendLength);</span><br><span class="line">        &#125;</span><br><span class="line">        out[<span class="number">0</span>]-&gt;<span class="built_in">send</span>(sendRank, slot, cur.sendOffset, cur.sendLength);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Function computes the offsets and lengths of the segments to be</span></span><br><span class="line">  <span class="comment">// sent and received for a given iteration during allgather.</span></span><br><span class="line">  <span class="keyword">auto</span> computeAllgatherOffsets = [&amp;](<span class="type">size_t</span> i) &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      <span class="type">size_t</span> sendOffset;</span><br><span class="line">      <span class="type">size_t</span> recvOffset;</span><br><span class="line">      <span class="type">ssize_t</span> sendLength;</span><br><span class="line">      <span class="type">ssize_t</span> recvLength;</span><br><span class="line">    &#125; result;</span><br><span class="line"></span><br><span class="line">    result.sendOffset =</span><br><span class="line">        ((((context-&gt;rank) * numSegmentsPerRank) + i) * segmentBytes) %</span><br><span class="line">        (numSegments * segmentBytes);</span><br><span class="line">    result.recvOffset =</span><br><span class="line">        ((((context-&gt;rank + <span class="number">1</span>) * numSegmentsPerRank) + i) * segmentBytes) %</span><br><span class="line">        (numSegments * segmentBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the segment is entirely in range, the following statement is</span></span><br><span class="line">    <span class="comment">// equal to segmentBytes. If it isn&#x27;t, it will be less, or even</span></span><br><span class="line">    <span class="comment">// negative. This is why the ssize_t typecasts are needed.</span></span><br><span class="line">    result.sendLength = std::<span class="built_in">min</span>(</span><br><span class="line">        (<span class="type">ssize_t</span>)segmentBytes,</span><br><span class="line">        (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)result.sendOffset);</span><br><span class="line">    result.recvLength = std::<span class="built_in">min</span>(</span><br><span class="line">        (<span class="type">ssize_t</span>)segmentBytes,</span><br><span class="line">        (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)result.recvOffset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ring allgather.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 注意：totalBytes &lt;= (numSegments * segmentBytes)，</span></span><br><span class="line">  <span class="comment">// 这与在进程间贡献相同的通用 allgather 算法不兼容。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; (numSegments - numSegmentsPerRank + <span class="number">2</span>); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">auto</span> prev = <span class="built_in">computeAllgatherOffsets</span>(i - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (prev.recvLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out[<span class="number">0</span>]-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">        <span class="comment">// Broadcast received segments to output buffers.</span></span><br><span class="line">        <span class="built_in">broadcastOutputs</span>(prev.recvOffset, prev.recvLength);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (prev.sendLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out[<span class="number">0</span>]-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在最后两次迭代之外的所有迭代中发出新的发送和接收操作。</span></span><br><span class="line">    <span class="comment">// 那时我们已经发送了我们需要的所有数据，只需要等待最终的段被发送到输出。</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; (numSegments - numSegmentsPerRank)) &#123;</span><br><span class="line">      <span class="keyword">auto</span> cur = <span class="built_in">computeAllgatherOffsets</span>(i);</span><br><span class="line">      <span class="keyword">if</span> (cur.recvLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out[<span class="number">0</span>]-&gt;<span class="built_in">recv</span>(recvRank, slot, cur.recvOffset, cur.recvLength);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur.sendLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out[<span class="number">0</span>]-&gt;<span class="built_in">send</span>(sendRank, slot, cur.sendOffset, cur.sendLength);</span><br><span class="line">        <span class="comment">// Broadcast first segments to outputs buffers.</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; numSegmentsPerRank) &#123;</span><br><span class="line">          <span class="built_in">broadcastOutputs</span>(cur.sendOffset, cur.sendLength);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于给定的上下文大小和所需的组大小，计算每步的实际组大小。</span></span><br><span class="line"><span class="comment">// 请注意，对于所有步骤，每一步的组大小为 n，仅当 n^(#steps) == 大小时。</span></span><br><span class="line"><span class="comment">// 否则，最终组大小为 != n。</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">size_t</span>&gt; <span class="title">computeGroupSizePerStep</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt; result;</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_GT</span>(n, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (size % n == <span class="number">0</span>) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(n);</span><br><span class="line">    size /= n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bcube-算法"><a href="#bcube-算法" class="headerlink" title="bcube 算法"></a>bcube 算法</h2><p>bcube 算法实现了一种类似超立方体的reduce策略。约束是进程的数量可以分解。如果分解中的最小分量为 2，并且进程数等于 2 的幂，则该算法与递归减半/加倍相同。</p>
<p>分解中的元素数量决定了算法的步数。分解的每个元素决定了每个进程在算法的特定步骤中与之通信的进程数。如果进程数不可分解，则该算法与直接reduce-scatter 后allgather 相同。</p>
<p>例如，如果#processes == 8，并且我们将其分解为 4 * 2，则算法分 2 步运行。在第一步中，2 组 4 个进程之间交换数据，以使所有进程具有部分结果的 1/4。第二步，4组2个进程交换它们的部分结果，使得所有进程都有1/8的结果。然后，反向执行相同的分解以执行 allgather。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bcube</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> detail::AllreduceOptionsImpl&amp; opts,</span></span></span><br><span class="line"><span class="params"><span class="function">    ReduceRangeFunction reduceInputs,</span></span></span><br><span class="line"><span class="params"><span class="function">    BroadcastRangeFunction broadcastOutputs)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kAllreduceSlotPrefix, opts.tag);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> elementSize = opts.elementSize;</span><br><span class="line">  <span class="keyword">auto</span>&amp; out = opts.out[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> n = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算出这个算法的步数。</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> groupSizePerStep = <span class="built_in">computeGroupSizePerStep</span>(context-&gt;size, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">group</span> &#123;</span><br><span class="line">    <span class="comment">// Distance between peers in this group.</span></span><br><span class="line">    <span class="type">size_t</span> peerDistance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Segment that this group is responsible for reducing.</span></span><br><span class="line">    <span class="type">size_t</span> bufferOffset;</span><br><span class="line">    <span class="type">size_t</span> bufferLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The process ranks that are a member of this group.</span></span><br><span class="line">    std::vector&lt;<span class="type">size_t</span>&gt; ranks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Upper bound of the length of the chunk that each process has the</span></span><br><span class="line">    <span class="comment">// reduced values for by the end of the reduction for this group.</span></span><br><span class="line">    <span class="type">size_t</span> chunkLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Chunk within the segment that this process is responsible for reducing.</span></span><br><span class="line">    <span class="type">size_t</span> myChunkOffset;</span><br><span class="line">    <span class="type">size_t</span> myChunkLength;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在每个算法步骤计算组的详细信息。</span></span><br><span class="line">  <span class="comment">// 我们将它保存在一个向量中，因为我们在reduce/scatter阶段以正序迭代它，在全聚集阶段以反向顺序迭代它。</span></span><br><span class="line">  std::vector&lt;<span class="keyword">struct</span> group&gt; groups;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">group</span> group;</span><br><span class="line">    group.peerDistance = <span class="number">1</span>;</span><br><span class="line">    group.bufferOffset = <span class="number">0</span>;</span><br><span class="line">    group.bufferLength = opts.elements;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">size_t</span> groupSize : groupSizePerStep) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> groupRank = (context-&gt;rank / group.peerDistance) % groupSize;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> baseRank = context-&gt;rank - (groupRank * group.peerDistance);</span><br><span class="line">      group.ranks.<span class="built_in">reserve</span>(groupSize);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; groupSize; i++) &#123;</span><br><span class="line">        group.ranks.<span class="built_in">push_back</span>(baseRank + i * group.peerDistance);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 每隔groupSize个进程是一组，也就是说一个组内的rank都隔着groupSize</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Compute the length of the chunk we&#x27;re exchanging at this step.</span></span><br><span class="line">      group.chunkLength = ((group.bufferLength + (groupSize - <span class="number">1</span>)) / groupSize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 此过程正在计算当前段中位于 &lt;rank&gt;/&lt;size&gt; 的块的减少量。</span></span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      group.myChunkOffset =</span><br><span class="line">          group.bufferOffset + (groupRank * group.chunkLength);</span><br><span class="line">      group.myChunkLength = std::<span class="built_in">min</span>(</span><br><span class="line">          <span class="built_in">size_t</span>(group.chunkLength),</span><br><span class="line">          <span class="built_in">size_t</span>(std::<span class="built_in">max</span>(</span><br><span class="line">              <span class="built_in">int64_t</span>(<span class="number">0</span>),</span><br><span class="line">              <span class="built_in">int64_t</span>(group.bufferLength) -</span><br><span class="line">                  <span class="built_in">int64_t</span>(groupRank * group.chunkLength))));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Store a const copy of this group in the vector.</span></span><br><span class="line">      groups.<span class="built_in">push_back</span>(group);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用更新的对等距离和段偏移和长度进行初始化。</span></span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">group</span> nextGroup;</span><br><span class="line">      nextGroup.peerDistance = group.peerDistance * groupSize;</span><br><span class="line">      nextGroup.bufferOffset = group.myChunkOffset;</span><br><span class="line">      nextGroup.bufferLength = group.myChunkLength;</span><br><span class="line">      std::<span class="built_in">swap</span>(group, nextGroup);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 块长度向上取整，因此我们需要的最大暂存空间可能大于输出缓冲区的大小。 计算最大值</span></span><br><span class="line">  <span class="type">size_t</span> bufferLength = opts.elements;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; group : groups) &#123;</span><br><span class="line">    bufferLength =</span><br><span class="line">        std::<span class="built_in">max</span>(bufferLength, group.ranks.<span class="built_in">size</span>() * group.chunkLength);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配暂存空间以从对等方接收数据。</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bufferSize = bufferLength * elementSize;</span><br><span class="line">  <span class="function">std::unique_ptr&lt;<span class="type">uint8_t</span>[]&gt; <span class="title">buffer</span><span class="params">(<span class="keyword">new</span> <span class="type">uint8_t</span>[bufferSize])</span></span>;</span><br><span class="line">  std::unique_ptr&lt;transport::UnboundBuffer&gt; tmp =</span><br><span class="line">      context-&gt;<span class="built_in">createUnboundBuffer</span>(buffer.<span class="built_in">get</span>(), bufferSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reduce/scatter.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> step = <span class="number">0</span>; step &lt; groups.<span class="built_in">size</span>(); step++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; group = groups[step];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从对等点发出块的接收操作。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> src = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (src == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tmp-&gt;<span class="built_in">recv</span>(</span><br><span class="line">          src,</span><br><span class="line">          slot,</span><br><span class="line">          i * group.chunkLength * elementSize,</span><br><span class="line">          group.myChunkLength * elementSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向对等方发出本地块的发送操作。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> dst = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (dst == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> currentChunkOffset =</span><br><span class="line">          group.bufferOffset + i * group.chunkLength;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> currentChunkLength = std::<span class="built_in">min</span>(</span><br><span class="line">          <span class="built_in">size_t</span>(group.chunkLength),</span><br><span class="line">          <span class="built_in">size_t</span>(std::<span class="built_in">max</span>(</span><br><span class="line">              <span class="built_in">int64_t</span>(<span class="number">0</span>),</span><br><span class="line">              <span class="built_in">int64_t</span>(group.bufferLength) - <span class="built_in">int64_t</span>(i * group.chunkLength))));</span><br><span class="line">      <span class="comment">// 仅在算法的第一步中计算局部reduce。</span></span><br><span class="line">      <span class="comment">// 在随后的步骤中，我们已经得到了部分reduce的结果。</span></span><br><span class="line">      <span class="keyword">if</span> (step == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">reduceInputs</span>(</span><br><span class="line">            currentChunkOffset * elementSize, currentChunkLength * elementSize);</span><br><span class="line">      &#125;</span><br><span class="line">      out-&gt;<span class="built_in">send</span>(</span><br><span class="line">          dst,</span><br><span class="line">          slot,</span><br><span class="line">          currentChunkOffset * elementSize,</span><br><span class="line">          currentChunkLength * elementSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for send and receive operations to complete.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> peer = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (peer == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tmp-&gt;<span class="built_in">waitRecv</span>();</span><br><span class="line">      out-&gt;<span class="built_in">waitSend</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步，准备这个进程负责的chunk</span></span><br><span class="line">    <span class="comment">// 使用其输入的简化版本（如果指定了多个）。</span></span><br><span class="line">    <span class="keyword">if</span> (step == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">reduceInputs</span>(</span><br><span class="line">          group.myChunkOffset * elementSize, group.myChunkLength * elementSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reduce chunks from peers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> src = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (src == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      opts.<span class="built_in">reduce</span>(</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out-&gt;ptr) + (group.myChunkOffset * elementSize),</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(out-&gt;ptr) +</span><br><span class="line">              (group.myChunkOffset * elementSize),</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tmp-&gt;ptr) +</span><br><span class="line">              (i * group.chunkLength * elementSize),</span><br><span class="line">          group.myChunkLength);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有一个块包含最终结果，并且该块已经可以在本地广播到 out[1..N]（如果适用）。</span></span><br><span class="line">  <span class="comment">// 这样做意味着我们只需要在本地广播到 out[1..N] 所有块，因为我们在 allgather 阶段从对等方接收到它们。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; group = groups.<span class="built_in">back</span>();</span><br><span class="line">    <span class="built_in">broadcastOutputs</span>(</span><br><span class="line">        group.myChunkOffset * elementSize, group.myChunkLength * elementSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allgather.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = groups.<span class="built_in">rbegin</span>(); it != groups.<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; group = *it;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Issue receive operations for reduced chunks from peers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> src = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (src == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> currentChunkOffset =</span><br><span class="line">          group.bufferOffset + i * group.chunkLength;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> currentChunkLength = std::<span class="built_in">min</span>(</span><br><span class="line">          <span class="built_in">size_t</span>(group.chunkLength),</span><br><span class="line">          <span class="built_in">size_t</span>(std::<span class="built_in">max</span>(</span><br><span class="line">              <span class="built_in">int64_t</span>(<span class="number">0</span>),</span><br><span class="line">              <span class="built_in">int64_t</span>(group.bufferLength) - <span class="built_in">int64_t</span>(i * group.chunkLength))));</span><br><span class="line">      out-&gt;<span class="built_in">recv</span>(</span><br><span class="line">          src,</span><br><span class="line">          slot,</span><br><span class="line">          currentChunkOffset * elementSize,</span><br><span class="line">          currentChunkLength * elementSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Issue send operations for reduced chunk to peers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> dst = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (dst == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      out-&gt;<span class="built_in">send</span>(</span><br><span class="line">          dst,</span><br><span class="line">          slot,</span><br><span class="line">          group.myChunkOffset * elementSize,</span><br><span class="line">          group.myChunkLength * elementSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for operations to complete.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> peer = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (peer == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      out-&gt;<span class="built_in">waitRecv</span>();</span><br><span class="line">      out-&gt;<span class="built_in">waitSend</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Broadcast result to multiple output buffers, if applicable.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> peer = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (peer == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> currentChunkOffset =</span><br><span class="line">          group.bufferOffset + i * group.chunkLength;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> currentChunkLength = std::<span class="built_in">min</span>(</span><br><span class="line">          <span class="built_in">size_t</span>(group.chunkLength),</span><br><span class="line">          <span class="built_in">size_t</span>(std::<span class="built_in">max</span>(</span><br><span class="line">              <span class="built_in">int64_t</span>(<span class="number">0</span>),</span><br><span class="line">              <span class="built_in">int64_t</span>(group.bufferLength) - <span class="built_in">int64_t</span>(i * group.chunkLength))));</span><br><span class="line">      <span class="built_in">broadcastOutputs</span>(</span><br><span class="line">          currentChunkOffset * elementSize, currentChunkLength * elementSize);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="alltoallv"><a href="#alltoallv" class="headerlink" title="alltoallv"></a>alltoallv</h1><p>同alltoall一样，只不过alltoallv的实现多了offset，没有什么高深的算法，只是在send-recv<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">alltoallv</span><span class="params">(AlltoallvOptions&amp; opts)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  transport::UnboundBuffer* in = opts.in.<span class="built_in">get</span>();</span><br><span class="line">  transport::UnboundBuffer* out = opts.out.<span class="built_in">get</span>();</span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt;&amp; inOffsetPerRank = opts.inOffsetPerRank;</span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt;&amp; inLengthPerRank = opts.inLengthPerRank;</span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt;&amp; outOffsetPerRank = opts.outOffsetPerRank;</span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt;&amp; outLengthPerRank = opts.outLengthPerRank;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kAlltoallSlotPrefix, opts.tag);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> myRank = context-&gt;rank;</span><br><span class="line">  <span class="type">int</span> worldSize = context-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Local copy.</span></span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(inLengthPerRank[myRank] == outLengthPerRank[myRank]);</span><br><span class="line">  <span class="type">size_t</span> myInOffset = inOffsetPerRank[myRank];</span><br><span class="line">  <span class="type">size_t</span> myOutOffset = outOffsetPerRank[myRank];</span><br><span class="line">  <span class="type">size_t</span> myChunkSize = inLengthPerRank[myRank];</span><br><span class="line">  <span class="built_in">memcpy</span>(</span><br><span class="line">      <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(out-&gt;ptr) + myOutOffset,</span><br><span class="line">      <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(in-&gt;ptr) + myInOffset,</span><br><span class="line">      myChunkSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remote copy.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; worldSize; i++) &#123;</span><br><span class="line">    <span class="type">int</span> sendRank = (myRank + i) % worldSize;</span><br><span class="line">    <span class="type">int</span> recvRank = (myRank + worldSize - i) % worldSize;</span><br><span class="line">    in-&gt;<span class="built_in">send</span>(</span><br><span class="line">        sendRank, slot, inOffsetPerRank[sendRank], inLengthPerRank[sendRank]);</span><br><span class="line">    out-&gt;<span class="built_in">recv</span>(</span><br><span class="line">        recvRank, slot, outOffsetPerRank[recvRank], outLengthPerRank[recvRank]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; worldSize; i++) &#123;</span><br><span class="line">    in-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">    out-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h1><p>如果是共有16进程的话，</p>
<p>0号进程会与15 1，14 2，12 4，8 8进程recv send</p>
<p>1号进程会与0 2，15 3，13 5，9 9进程recv send</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">barrier</span><span class="params">(BarrierOptions&amp; opts)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  <span class="keyword">auto</span>&amp; buffer = opts.buffer;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kBarrierSlotPrefix, opts.tag);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Below implements a dissemination barrier, described in &quot;Two algorithms</span></span><br><span class="line">  <span class="comment">// for barrier synchronization (1988)&quot; by Hensgen, Finkel and Manber.</span></span><br><span class="line">  <span class="comment">// PDF: https://www.inf.ed.ac.uk/teaching/courses/ppls/BarrierPaper.pdf</span></span><br><span class="line">  <span class="comment">// DOI: 10.1007/BF01379320</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instead of iterating over i up to log2(context-&gt;size), we immediately</span></span><br><span class="line">  <span class="comment">// compute 2^i and compare with context-&gt;size.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> d = <span class="number">1</span>; d &lt; context-&gt;size; d &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    buffer-&gt;<span class="built_in">recv</span>((context-&gt;size + context-&gt;rank - d) % context-&gt;size, slot);</span><br><span class="line">    buffer-&gt;<span class="built_in">send</span>((context-&gt;size + context-&gt;rank + d) % context-&gt;size, slot);</span><br><span class="line">    buffer-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">    buffer-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast"></a>broadcast</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">broadcast</span><span class="params">(BroadcastOptions&amp; opts)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  transport::UnboundBuffer* in = opts.in.<span class="built_in">get</span>();</span><br><span class="line">  transport::UnboundBuffer* out = opts.out.<span class="built_in">get</span>();</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kBroadcastSlotPrefix, opts.tag);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (context-&gt;rank == opts.root) &#123;</span><br><span class="line">    in = out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将rank映射到根进程rank为 0 的新rank。</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> vsize = context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> vrank = (context-&gt;rank + vsize - opts.root) % vsize;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> dim = <span class="built_in">log2ceil</span>(vsize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跟踪未决发送操作的数量。</span></span><br><span class="line">  <span class="comment">// 发送操作可以异步完成，因为迭代之间存在依赖关系。</span></span><br><span class="line">  <span class="comment">// 这与必须在任何发送操作排队之前完成的 recv 操作不同。</span></span><br><span class="line">  <span class="type">size_t</span> numSends = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建全为 1 的掩码，我们从 LSB 开始逐步将位设置为 0。</span></span><br><span class="line">  <span class="comment">// 当应用于虚拟rank的掩码等于 0 时，我们知道该进程必须参与。</span></span><br><span class="line">  <span class="comment">// 这导致从虚拟rank 0 和 1 开始的指数级参与.</span></span><br><span class="line">  <span class="type">size_t</span> mask = (<span class="number">1</span> &lt;&lt; dim) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; dim; i++) &#123;</span><br><span class="line">    <span class="comment">// Clear bit `i`. 在第一次迭代中，虚拟rank 0 和 1 参与。</span></span><br><span class="line">    <span class="comment">// 在第二次迭代中，0、1、2 和 3 参与，依此类推。</span></span><br><span class="line">    mask ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">if</span> ((vrank &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The virtual rank of the peer in this iteration has opposite bit `i`.</span></span><br><span class="line">    <span class="keyword">auto</span> vpeer = vrank ^ (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">if</span> (vpeer &gt;= vsize) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map virtual rank of peer to actual rank of peer.</span></span><br><span class="line">    <span class="keyword">auto</span> peer = (vpeer + opts.root) % vsize;</span><br><span class="line">    <span class="keyword">if</span> ((vrank &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line">      in-&gt;<span class="built_in">send</span>(peer, slot);</span><br><span class="line">      numSends++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      out-&gt;<span class="built_in">recv</span>(peer, slot);</span><br><span class="line">      out-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy local input to output if applicable.</span></span><br><span class="line">  <span class="keyword">if</span> (context-&gt;rank == opts.root &amp;&amp; in != out) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(out-&gt;ptr, in-&gt;ptr, out-&gt;size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait on pending sends.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; numSends; i++) &#123;</span><br><span class="line">    in-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="avx优化"><a href="#avx优化" class="headerlink" title="avx优化"></a>avx优化</h1><p>一些reduce函数使用了avx。<code>_mm256_cvtph_ps</code>将八个半精度（16 位）浮点值转换为单精度浮点值。<code>_mm256_cvtps_ph</code>将八个单精度浮点值转换为半精度（16 位）浮点值。<code>_mm_storeu_si128</code>将计算结果等SSE暂存器的数据保存到内存中。<code>_mm256_mul_ps</code>对第一个源向量 m1 中的八个压缩单精度浮点元素（float32 元素）与第二个源向量 m2 中的八个 float32 元素执行 SIMD 乘法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//假设 x 和 y 要么都对齐到 32 字节，要么未对齐相同的偏移量，就像在对齐缓冲区内的偏移量处减少时会发生的那样</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">sum</span>&lt;float16&gt;(<span class="type">void</span>* c_, <span class="type">const</span> <span class="type">void</span>* a_, <span class="type">const</span> <span class="type">void</span>* b_, <span class="type">size_t</span> n) &#123;</span><br><span class="line">  float16* c = <span class="built_in">static_cast</span>&lt;float16*&gt;(c_);</span><br><span class="line">  <span class="type">const</span> float16* a = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(a_);</span><br><span class="line">  <span class="type">const</span> float16* b = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(b_);</span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (n / <span class="number">8</span>) * <span class="number">8</span>; i += <span class="number">8</span>) &#123;</span><br><span class="line">    __m256 va32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;a[i])));</span><br><span class="line">    __m256 vb32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;b[i])));</span><br><span class="line">    __m128i vc16 = _mm256_cvtps_ph(_mm256_add_ps(va32, vb32), <span class="number">0</span>);</span><br><span class="line">    _mm_storeu_si128((__m128i*)(&amp;c[i]), vc16);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Leftovers</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; i++) &#123;</span><br><span class="line">    c[i] = a[i] + b[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">product</span>&lt;float16&gt;(<span class="type">void</span>* c_, <span class="type">const</span> <span class="type">void</span>* a_, <span class="type">const</span> <span class="type">void</span>* b_, <span class="type">size_t</span> n) &#123;</span><br><span class="line">  float16* c = <span class="built_in">static_cast</span>&lt;float16*&gt;(c_);</span><br><span class="line">  <span class="type">const</span> float16* a = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(a_);</span><br><span class="line">  <span class="type">const</span> float16* b = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(b_);</span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (n / <span class="number">8</span>) * <span class="number">8</span>; i += <span class="number">8</span>) &#123;</span><br><span class="line">    __m256 va32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;a[i])));</span><br><span class="line">    __m256 vb32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;b[i])));</span><br><span class="line">    __m128i vc16 = _mm256_cvtps_ph(_mm256_mul_ps(va32, vb32), <span class="number">0</span>);</span><br><span class="line">    _mm_storeu_si128((__m128i*)(&amp;c[i]), vc16);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Leftovers</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; i++) &#123;</span><br><span class="line">    c[i] = a[i] * b[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">max</span>&lt;float16&gt;(<span class="type">void</span>* c_, <span class="type">const</span> <span class="type">void</span>* a_, <span class="type">const</span> <span class="type">void</span>* b_, <span class="type">size_t</span> n) &#123;</span><br><span class="line">  float16* c = <span class="built_in">static_cast</span>&lt;float16*&gt;(c_);</span><br><span class="line">  <span class="type">const</span> float16* a = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(a_);</span><br><span class="line">  <span class="type">const</span> float16* b = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(b_);</span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (n / <span class="number">8</span>) * <span class="number">8</span>; i += <span class="number">8</span>) &#123;</span><br><span class="line">    __m256 va32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;a[i])));</span><br><span class="line">    __m256 vb32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;b[i])));</span><br><span class="line">    __m128i vc16 = _mm256_cvtps_ph(_mm256_max_ps(va32, vb32), <span class="number">0</span>);</span><br><span class="line">    _mm_storeu_si128((__m128i*)(&amp;c[i]), vc16);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Leftovers</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; i++) &#123;</span><br><span class="line">    c[i] = std::<span class="built_in">max</span>(a[i], b[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">min</span>&lt;float16&gt;(<span class="type">void</span>* c_, <span class="type">const</span> <span class="type">void</span>* a_, <span class="type">const</span> <span class="type">void</span>* b_, <span class="type">size_t</span> n) &#123;</span><br><span class="line">  float16* c = <span class="built_in">static_cast</span>&lt;float16*&gt;(c_);</span><br><span class="line">  <span class="type">const</span> float16* a = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(a_);</span><br><span class="line">  <span class="type">const</span> float16* b = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(b_);</span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (n / <span class="number">8</span>) * <span class="number">8</span>; i += <span class="number">8</span>) &#123;</span><br><span class="line">    __m256 va32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;a[i])));</span><br><span class="line">    __m256 vb32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;b[i])));</span><br><span class="line">    __m128i vc16 = _mm256_cvtps_ph(_mm256_min_ps(va32, vb32), <span class="number">0</span>);</span><br><span class="line">    _mm_storeu_si128((__m128i*)(&amp;c[i]), vc16);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Leftovers</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; i++) &#123;</span><br><span class="line">    c[i] = std::<span class="built_in">min</span>(a[i], b[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reduce</span><span class="params">(ReduceOptions&amp; opts)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (opts.elements == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  transport::UnboundBuffer* in = opts.in.<span class="built_in">get</span>();</span><br><span class="line">  transport::UnboundBuffer* out = opts.out.<span class="built_in">get</span>();</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kReduceSlotPrefix, opts.tag);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> recvRank = (context-&gt;size + context-&gt;rank + <span class="number">1</span>) % context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> sendRank = (context-&gt;size + context-&gt;rank - <span class="number">1</span>) % context-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If input buffer is not specified, the output is also the input</span></span><br><span class="line">  <span class="keyword">if</span> (in == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    in = out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果只有一个进程，则短路。</span></span><br><span class="line">  <span class="keyword">if</span> (context-&gt;size == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (in != out) &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(out-&gt;ptr, in-&gt;ptr, opts.elements * opts.elementSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The ring algorithm works as follows.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 给定的输入被分成与进程数相等的块数。</span></span><br><span class="line">  <span class="comment">// 算法完成后，每个进程按顺序托管一个reduce输出块（rank 0 具有块 0，rank 1 具有块 1，等等）。</span></span><br><span class="line">  <span class="comment">// 由于输入可能不能被进程数整除，因此最终的块可能有部分输出或可能为空。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 当一个块沿着环传递并包含连续更多rank的reduce时，我们必须在为该块执行 I/O 和计算接收到的块和本地块之间的减少之间交替。</span></span><br><span class="line">  <span class="comment">// 为了避免这种交替模式，我们将一个块分成多个段（&gt; = 2），并确保我们有一个段在运行，同时计算另一个段的reduce。</span></span><br><span class="line">  <span class="comment">// 段大小有一个上限，以最大限度地减少内存使用并避免不良的缓存行为。这意味着在处理非常大的输入时，每个块可能有很多段。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 这里的命名法反映在下面的变量命名中（每个rank一个块，每个块多个段）。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> totalBytes = opts.elements * opts.elementSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保最大段大小是元素大小的倍数。 否则，在向上舍入到元素大小的最接近倍数后，段大小可能会超过最大段大小。 例如，如果maxSegmentSize = 10，而elementSize = 4，则向上取整后：segmentSize = 12；</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> maxSegmentSize =</span><br><span class="line">      opts.elementSize * (opts.maxSegmentSize / opts.elementSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每个段的字节数必须是每个元素的字节数的倍数才能进行缩减； 必要时四舍五入。</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> segmentBytes = <span class="built_in">roundUp</span>(</span><br><span class="line">      std::<span class="built_in">min</span>(</span><br><span class="line">          <span class="comment">// Rounded division to have &gt;= 2 segments per chunk.</span></span><br><span class="line">          (totalBytes + (context-&gt;size * <span class="number">2</span> - <span class="number">1</span>)) / (context-&gt;size * <span class="number">2</span>),</span><br><span class="line">          <span class="comment">// Configurable segment size limit</span></span><br><span class="line">          maxSegmentSize),</span><br><span class="line">      opts.elementSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute how many segments make up the input buffer.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 向上舍入到上下文大小的最接近的倍数，以便每个进程有相同数量的段，并且跨进程的执行是对称的。</span></span><br><span class="line">  <span class="comment">// 最小值是上下文大小的两倍，因为下面的算法将发送/接收一个段与计算另一个段的缩减重叠。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> numSegments = <span class="built_in">roundUp</span>(</span><br><span class="line">      std::<span class="built_in">max</span>(</span><br><span class="line">          (totalBytes + (segmentBytes - <span class="number">1</span>)) / segmentBytes,</span><br><span class="line">          (<span class="type">size_t</span>)context-&gt;size * <span class="number">2</span>),</span><br><span class="line">      (<span class="type">size_t</span>)context-&gt;size);</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> numSegmentsPerRank = numSegments / context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> chunkBytes = numSegmentsPerRank * segmentBytes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配暂存空间以容纳两个块</span></span><br><span class="line">  <span class="function">std::unique_ptr&lt;<span class="type">uint8_t</span>[]&gt; <span class="title">tmpAllocation</span><span class="params">(<span class="keyword">new</span> <span class="type">uint8_t</span>[segmentBytes * <span class="number">2</span>])</span></span>;</span><br><span class="line">  std::unique_ptr&lt;transport::UnboundBuffer&gt; tmpBuffer =</span><br><span class="line">      context-&gt;<span class="built_in">createUnboundBuffer</span>(tmpAllocation.<span class="built_in">get</span>(), segmentBytes * <span class="number">2</span>);</span><br><span class="line">  transport::UnboundBuffer* tmp = tmpBuffer.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用动态查找临时缓冲区中的块偏移量。</span></span><br><span class="line">  <span class="comment">// 在进行两个操作时，我们需要两个偏移量。</span></span><br><span class="line">  <span class="comment">// 可以使用循环计数器对它们进行索引。</span></span><br><span class="line">  std::array&lt;<span class="type">size_t</span>, 2&gt; segmentOffset;</span><br><span class="line">  segmentOffset[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  segmentOffset[<span class="number">1</span>] = segmentBytes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数计算给定块迭代要发送和接收的块的偏移量和长度。</span></span><br><span class="line">  <span class="keyword">auto</span> computeReduceScatterOffsets = [&amp;](<span class="type">size_t</span> i) &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      <span class="type">size_t</span> sendOffset;</span><br><span class="line">      <span class="type">size_t</span> recvOffset;</span><br><span class="line">      <span class="type">ssize_t</span> sendLength;</span><br><span class="line">      <span class="type">ssize_t</span> recvLength;</span><br><span class="line">    &#125; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算要发送的段索引（到 rank - 1）和要接收的段索引（从 rank + 1）。</span></span><br><span class="line">    <span class="comment">// 乘以块中的字节数以获得偏移量。</span></span><br><span class="line">    <span class="comment">// 允许偏移量超出范围（&gt;=totalBytes），计算相关长度时会考虑到这一点。</span></span><br><span class="line">    result.sendOffset =</span><br><span class="line">        ((((context-&gt;rank + <span class="number">1</span>) * numSegmentsPerRank) + i) * segmentBytes) %</span><br><span class="line">        (numSegments * segmentBytes);</span><br><span class="line">    result.recvOffset =</span><br><span class="line">        ((((context-&gt;rank + <span class="number">2</span>) * numSegmentsPerRank) + i) * segmentBytes) %</span><br><span class="line">        (numSegments * segmentBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果段完全在范围内，则以下语句等于段字节。</span></span><br><span class="line">    <span class="comment">// 如果不是，它会更少，甚至是负面的。 这就是需要 ssize_t 类型转换的原因。</span></span><br><span class="line">    result.sendLength = std::<span class="built_in">min</span>(</span><br><span class="line">        (<span class="type">ssize_t</span>)segmentBytes,</span><br><span class="line">        (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)result.sendOffset);</span><br><span class="line">    result.recvLength = std::<span class="built_in">min</span>(</span><br><span class="line">        (<span class="type">ssize_t</span>)segmentBytes,</span><br><span class="line">        (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)result.recvOffset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; numSegments; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">// 计算两次迭代前的发送和接收偏移量和长度。</span></span><br><span class="line">      <span class="comment">// 需要这样我们知道何时等待操作以及何时忽略（当偏移量超出范围时），</span></span><br><span class="line">      <span class="comment">// 并知道在哪里减少临时缓冲区的内容。</span></span><br><span class="line">      <span class="keyword">auto</span> prev = <span class="built_in">computeReduceScatterOffsets</span>(i - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (prev.recvLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        tmp-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">        opts.<span class="built_in">reduce</span>(</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out-&gt;ptr) + prev.recvOffset,</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(in-&gt;ptr) + prev.recvOffset,</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tmp-&gt;ptr) + segmentOffset[i &amp; <span class="number">0x1</span>],</span><br><span class="line">            prev.recvLength / opts.elementSize);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (prev.sendLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i - <span class="number">2</span>) &lt; numSegmentsPerRank) &#123;</span><br><span class="line">          in-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          out-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在最后两次迭代之外的所有迭代中发出新的发送和接收操作。</span></span><br><span class="line">    <span class="comment">// 那时我们已经发送了我们需要的所有数据，只需要等待最终的段被减少到输出中。</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; (numSegments - <span class="number">2</span>)) &#123;</span><br><span class="line">      <span class="comment">// Compute send and receive offsets and lengths for this iteration.</span></span><br><span class="line">      <span class="keyword">auto</span> cur = <span class="built_in">computeReduceScatterOffsets</span>(i);</span><br><span class="line">      <span class="keyword">if</span> (cur.recvLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        tmp-&gt;<span class="built_in">recv</span>(recvRank, slot, segmentOffset[i &amp; <span class="number">0x1</span>], cur.recvLength);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur.sendLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; numSegmentsPerRank) &#123;</span><br><span class="line">          in-&gt;<span class="built_in">send</span>(sendRank, slot, cur.sendOffset, cur.sendLength);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          out-&gt;<span class="built_in">send</span>(sendRank, slot, cur.sendOffset, cur.sendLength);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Gather to root rank.</span></span><br><span class="line">  <span class="comment">// 注意：totalBytes &lt;= (numSegments * segmentBytes)，</span></span><br><span class="line">  <span class="comment">// 这与在进程间贡献相同的通用聚集算法不兼容。</span></span><br><span class="line">  <span class="keyword">if</span> (context-&gt;rank == opts.root) &#123;</span><br><span class="line">    <span class="type">size_t</span> numRecv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> rank = <span class="number">0</span>; rank &lt; context-&gt;size; rank++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (rank == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">size_t</span> recvOffset = rank * numSegmentsPerRank * segmentBytes;</span><br><span class="line">      <span class="type">ssize_t</span> recvLength = std::<span class="built_in">min</span>(</span><br><span class="line">          (<span class="type">ssize_t</span>)chunkBytes, (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)recvOffset);</span><br><span class="line">      <span class="keyword">if</span> (recvLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out-&gt;<span class="built_in">recv</span>(rank, slot, recvOffset, recvLength);</span><br><span class="line">        numRecv++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numRecv; i++) &#123;</span><br><span class="line">      out-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> sendOffset = context-&gt;rank * numSegmentsPerRank * segmentBytes;</span><br><span class="line">    <span class="type">ssize_t</span> sendLength = std::<span class="built_in">min</span>(</span><br><span class="line">        (<span class="type">ssize_t</span>)chunkBytes, (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)sendOffset);</span><br><span class="line">    <span class="keyword">if</span> (sendLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      out-&gt;<span class="built_in">send</span>(opts.root, slot, sendOffset, sendLength);</span><br><span class="line">      out-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/" itemprop="url">面经整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-28T17:00:00+08:00">
                2022-05-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-语言基础-C-C"><a href="#1-语言基础-C-C" class="headerlink" title="1. 语言基础 (C/C++)"></a>1. 语言基础 (C/C++)</h1><h4 id="（0）-指针和引用的区别"><a href="#（0）-指针和引用的区别" class="headerlink" title="（0） 指针和引用的区别"></a>（0） 指针和引用的区别</h4><ul>
<li>指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作</li>
<li>指针可以有多级，引用只有一级</li>
<li>传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改</li>
<li>指针的大小一般是4个字节，引用的大小取决于被引用对象的大小</li>
<li>指针可以为空，引用不可以。</li>
</ul>
<h4 id="（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"><a href="#（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？" class="headerlink" title="（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？"></a>（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？</h4><ul>
<li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li>
<li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li>
<li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</li>
</ul>
<h4 id="（2）-堆和栈有什么区别"><a href="#（2）-堆和栈有什么区别" class="headerlink" title="（2） 堆和栈有什么区别"></a>（2） 堆和栈有什么区别</h4><ul>
<li>从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。</li>
<li>堆空间因为会有频繁的分配释放操作，会产生内存碎片</li>
<li>堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小</li>
</ul>
<h4 id="（3）堆快一点还是栈快一点？（字节提前批一面）"><a href="#（3）堆快一点还是栈快一点？（字节提前批一面）" class="headerlink" title="（3）堆快一点还是栈快一点？（字节提前批一面）"></a>（3）堆快一点还是栈快一点？（字节提前批一面）</h4><p>栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p>
<h4 id="（4）-new和delete是如何实现的，new-与-malloc的异同处"><a href="#（4）-new和delete是如何实现的，new-与-malloc的异同处" class="headerlink" title="（4） new和delete是如何实现的，new 与 malloc的异同处"></a>（4） new和delete是如何实现的，new 与 malloc的异同处</h4><p>在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。delete会调用对象的析构函数，然后调用free回收内存。</p>
<p>new与malloc都会分配空间，但是new还会调用对象的构造函数进行初始化，malloc需要给定空间大小，而new只需要对象名</p>
<h4 id="（5）既然有了malloc-free，C-中为什么还需要new-delete呢？"><a href="#（5）既然有了malloc-free，C-中为什么还需要new-delete呢？" class="headerlink" title="（5）既然有了malloc/free，C++中为什么还需要new/delete呢？"></a>（5）既然有了malloc/free，C++中为什么还需要new/delete呢？</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leikun153/article/details/80612130">https://blog.csdn.net/leikun153/article/details/80612130</a></p>
<ul>
<li>malloc/free和new/delete都是用来申请内存和回收内存的。</li>
<li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free。</li>
</ul>
<h4 id="（6）-C和C-的区别"><a href="#（6）-C和C-的区别" class="headerlink" title="（6） C和C++的区别"></a>（6） C和C++的区别</h4><p>包括但不限于：</p>
<ul>
<li>C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性。封装隐藏了实现细节，使得代码模块化。继承通过子类继承父类的方法和属性，实现了代码重用。多态则是“一个接口，多个实现”，通过子类重写父类的虚函数，实现了接口重用。</li>
<li>C和C++内存管理的方法不一样，C使用malloc/free，C++除此之外还用new/delete</li>
<li>C++中还有函数重载和引用等概念，C中没有</li>
</ul>
<h4 id="（7）delete和delete-的区别"><a href="#（7）delete和delete-的区别" class="headerlink" title="（7）delete和delete[]的区别"></a>（7）delete和delete[]的区别</h4><ul>
<li><p>delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数</p>
</li>
<li><p>用new分配的内存用delete释放，用new[]分配的内存用delete[]释放</p>
</li>
</ul>
<h4 id="（8）-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"><a href="#（8）-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）" class="headerlink" title="（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"></a>（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</h4><p>包括但不限于：</p>
<ul>
<li>C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高。</li>
<li>C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法</li>
<li>C++有指针，Java没有指针，只有引用</li>
<li>JAVA和C++都有构造函数，但是C++有析构函数但是Java没有</li>
</ul>
<h4 id="（9）C-和python的区别"><a href="#（9）C-和python的区别" class="headerlink" title="（9）C++和python的区别"></a>（9）C++和python的区别</h4><p>包括但不限于：</p>
<ol>
<li>python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。</li>
<li>python使用缩进来区分不同的代码块，C++使用花括号来区分</li>
<li>C++中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等等</li>
<li>python的库函数比C++的多，调用起来很方便</li>
</ol>
<h4 id="（10）-Struct和class的区别"><a href="#（10）-Struct和class的区别" class="headerlink" title="（10） Struct和class的区别"></a>（10） Struct和class的区别</h4><ul>
<li>使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的</li>
<li>struct的继承默认是public继承，而class的继承默认是private继承</li>
<li>class可以用作模板，而struct不能</li>
</ul>
<h4 id="（11）-define-和const的联系与区别（编译阶段、安全性、内存占用等）"><a href="#（11）-define-和const的联系与区别（编译阶段、安全性、内存占用等）" class="headerlink" title="（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）"></a>（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）</h4><p>联系：它们都是定义常量的一种方法。</p>
<p>区别：</p>
<ul>
<li>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。</li>
<li>define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</li>
<li>define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。</li>
<li>const可以定义函数而define不可以。</li>
</ul>
<h4 id="（12）-在C-中const的用法（定义，用途）"><a href="#（12）-在C-中const的用法（定义，用途）" class="headerlink" title="（12） 在C++中const的用法（定义，用途）"></a>（12） 在C++中const的用法（定义，用途）</h4><ul>
<li>const修饰类的成员变量时，表示常量不能被修改</li>
<li>const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数</li>
</ul>
<h4 id="（13）-C-中的static用法和意义"><a href="#（13）-C-中的static用法和意义" class="headerlink" title="（13） C++中的static用法和意义"></a>（13） C++中的static用法和意义</h4><p>static的意思是静态的，可以用来修饰变量，函数和类成员。</p>
<ul>
<li><p>变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件里。</p>
</li>
<li><p>函数：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突。</p>
</li>
<li><p>类：而在类中，被static修饰的成员变量是类静态成员，这个静态成员会被类的多个对象共用。被static修饰的成员函数也属于静态成员，不是属于某个对象的，访问这个静态函数不需要引用对象名，而是通过引用类名来访问。</p>
</li>
</ul>
<p>【note】静态成员函数要访问非静态成员时，要用过对象来引用。局部静态变量在函数调用结束后也不会被回收，会一直在程序内存中，直到该函数再次被调用，它的值还是保持上一次调用结束后的值。</p>
<p>注意和const的区别。const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用。</p>
<h4 id="（14）-计算下面几个类的大小："><a href="#（14）-计算下面几个类的大小：" class="headerlink" title="（14） 计算下面几个类的大小："></a>（14） 计算下面几个类的大小：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。</p>
<p>空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 4(32位机器)/8(64位机器);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节<br><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">static</span> <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 1;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="type">static</span> <span class="type">int</span> a; <span class="type">int</span> b; &#125;;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  A a; </span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(a)&lt;&lt;endl;<span class="comment">// 输出 4;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节</p>
<h4 id="（15）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"><a href="#（15）-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等" class="headerlink" title="（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"></a>（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</h4><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p>
<ul>
<li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li>
<li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li>
<li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</li>
</ul>
<h4 id="（16）-STL源码中的hash表的实现"><a href="#（16）-STL源码中的hash表的实现" class="headerlink" title="（16） STL源码中的hash表的实现"></a>（16） STL源码中的hash表的实现</h4><p>STL中的hash表就unordered_map。使用的是哈希进行实现（注意与map的区别）。它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。</p>
<p>unordered_map的底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，当桶的大小超过8时，就自动转为红黑树进行组织。</p>
<h4 id="（17）解决哈希冲突的方式？"><a href="#（17）解决哈希冲突的方式？" class="headerlink" title="（17）解决哈希冲突的方式？"></a>（17）解决哈希冲突的方式？</h4><ol>
<li>线性探查。该元素的哈希值对应的桶不能存放元素时，循序往后一一查找，直到找到一个空桶为止，在查找时也一样，当哈希值对应位置上的元素与所要寻找的元素不同时，就往后一一查找，直到找到吻合的元素，或者空桶。</li>
<li>二次探查。该元素的哈希值对应的桶不能存放元素时，就往后寻找1^2,2^2,3^2,4^2…..i^2个位置。</li>
<li>双散列函数法。当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长。</li>
<li>开链法。在每一个桶中维护一个链表，由元素哈希值寻找到这个桶，然后将元素插入到对应的链表中，STL的hashtable就是采用这种实现方式。</li>
<li>建立公共溢出区。当发生冲突时，将所有冲突的数据放在公共溢出区。</li>
</ol>
<h4 id="（18）-STL中unordered-map和map的区别"><a href="#（18）-STL中unordered-map和map的区别" class="headerlink" title="（18） STL中unordered_map和map的区别"></a>（18） STL中unordered_map和map的区别</h4><ul>
<li>unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现==操作符。</li>
<li>map底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(&lt;)。</li>
</ul>
<h4 id="（19）-STL中vector的实现"><a href="#（19）-STL中vector的实现" class="headerlink" title="（19） STL中vector的实现"></a>（19） STL中vector的实现</h4><p>STL中的vector是封装了动态数组的顺序容器。不过与动态数组不同的是，vector可以根据需要自动扩大容器的大小。具体策略是每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。</p>
<p>在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。</p>
<h4 id="（20）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。"><a href="#（20）-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。" class="headerlink" title="（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。"></a>（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</h4><p>如果需要频繁插入，最好先指定vector的大小，因为vector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用push_back()会使得程序花费很多时间在vector扩容上，会变得很慢。这种情况可以考虑使用list。</p>
<h4 id="（21）C-中vector和list的区别"><a href="#（21）C-中vector和list的区别" class="headerlink" title="（21）C++中vector和list的区别"></a>（21）C++中vector和list的区别</h4><p>vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。</p>
<p>list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。</p>
<p>vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+=”，“&lt;”等操作符。</p>
<p>list的内存空间可以是不连续，它不支持随机访问，因此list::iterator则不支持“+”、“+=”、“&lt;”等</p>
<p>vector::iterator和list::iterator都重载了“++”运算符。</p>
<p>总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;</p>
<p>如果需要大量的插入和删除，而不关心随机存取，则应使用list。</p>
<h4 id="（22）-C-中的重载和重写的区别："><a href="#（22）-C-中的重载和重写的区别：" class="headerlink" title="（22） C++中的重载和重写的区别："></a>（22） C++中的重载和重写的区别：</h4><ul>
<li>重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。</li>
<li>重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30379911/article/details/99497160">https://blog.csdn.net/weixin_30379911/article/details/99497160</a></p>
<h4 id="（23）-C-内存管理（热门问题）"><a href="#（23）-C-内存管理（热门问题）" class="headerlink" title="（23） C ++内存管理（热门问题）"></a>（23） C ++内存管理（热门问题）</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43152052/article/details/98889139">https://blog.csdn.net/qq_43152052/article/details/98889139</a></p>
<p>在C++中，内存分成5个区，他们分别是堆、栈、全局/静态存储区和常量存储区和代码区。</p>
<ul>
<li>栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li>
<li>堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</li>
<li>全局/静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。</li>
<li>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。</li>
<li>代码区，存放程序的二进制代码</li>
</ul>
<p>关于这个有很多种说法，有的会增加一个自由存储区，存放malloc分配得到的内存，与堆相似。</p>
<h4 id="（24）-介绍面向对象的三大特性，并且举例说明每一个。"><a href="#（24）-介绍面向对象的三大特性，并且举例说明每一个。" class="headerlink" title="（24） 介绍面向对象的三大特性，并且举例说明每一个。"></a>（24） 介绍面向对象的三大特性，并且举例说明每一个。</h4><p>面向对象的三大特性是：封装，继承和多态。</p>
<ul>
<li>封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public；</li>
<li>继承使得子类可以复用父类的成员和方法，实现了代码重用；</li>
<li>多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。</li>
</ul>
<h4 id="（25）-多态的实现（和下个问题一起回答）"><a href="#（25）-多态的实现（和下个问题一起回答）" class="headerlink" title="（25） 多态的实现（和下个问题一起回答）"></a>（25） 多态的实现（和下个问题一起回答）</h4><p>C++ 多态包括编译时多态和运行时多态，编译时多态体现在函数重载和模板上，运行时多态体现在虚函数上。</p>
<ul>
<li>虚函数：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.</li>
</ul>
<h4 id="（26）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"><a href="#（26）-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）" class="headerlink" title="（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"></a>（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</h4><p>C++的虚函数是实现多态的机制。它是通过虚函数表实现的，虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。</p>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lihao21/article/details/50688337">C++虚函数表剖析</a></p>
<ul>
<li>如果多重继承和多继承的话，子类的虚函数表长什么样子？<br>多重继承的情况下越是祖先的父类的虚函数更靠前，多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前。详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36359022/article/details/81870219">https://blog.csdn.net/qq_36359022/article/details/81870219</a></li>
</ul>
<h4 id="（27）-实现编译器处理虚函数表应该如何处理"><a href="#（27）-实现编译器处理虚函数表应该如何处理" class="headerlink" title="（27） 实现编译器处理虚函数表应该如何处理"></a>（27） 实现编译器处理虚函数表应该如何处理</h4><p>编译器处理虚函数的方法是：<br>如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。<br>为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。<br>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/iFuMI/article/details/51088091">虚函数的作用及其底层实现机制</a></p>
<h4 id="（28）-基类的析构函数一般写成虚函数的原因"><a href="#（28）-基类的析构函数一般写成虚函数的原因" class="headerlink" title="（28） 基类的析构函数一般写成虚函数的原因"></a>（28） 基类的析构函数一般写成虚函数的原因</h4><p>首先析构函数可以为虚函数，当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。</p>
<p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。</p>
<h4 id="（29）-构造函数为什么一般不定义为虚函数"><a href="#（29）-构造函数为什么一般不定义为虚函数" class="headerlink" title="（29） 构造函数为什么一般不定义为虚函数"></a>（29） 构造函数为什么一般不定义为虚函数</h4><p>1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，<strong>由于对象还未创建成功，编译器无法知道对象的实际类型</strong>，是类本身还是类的派生类等等</p>
<p>2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了</p>
<h4 id="（30）-构造函数或者析构函数中调用虚函数会怎样"><a href="#（30）-构造函数或者析构函数中调用虚函数会怎样" class="headerlink" title="（30） 构造函数或者析构函数中调用虚函数会怎样"></a>（30） 构造函数或者析构函数中调用虚函数会怎样</h4><p>在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。</p>
<p>在析构函数中调用虚函数，此时调用的是子类的函数实现方式。</p>
<h4 id="（31）-纯虚函数"><a href="#（31）-纯虚函数" class="headerlink" title="（31） 纯虚函数"></a>（31） 纯虚函数</h4><p>纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承</p>
<p>包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象</p>
<p>使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。</p>
<h4 id="（32）-静态绑定和动态绑定的介绍"><a href="#（32）-静态绑定和动态绑定的介绍" class="headerlink" title="（32） 静态绑定和动态绑定的介绍"></a>（32） 静态绑定和动态绑定的介绍</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lizhenghn/p/3657717.html">C++中的静态绑定和动态绑定</a></p>
<p>静态绑定也就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。</p>
<p>动态绑定就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。</p>
<h4 id="（33）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"><a href="#（33）-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）" class="headerlink" title="（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"></a>（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h4><p>浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。</p>
<p>而深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。</p>
<p>深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。</p>
<h4 id="（34）-对象复用的了解，零拷贝的了解"><a href="#（34）-对象复用的了解，零拷贝的了解" class="headerlink" title="（34） 对象复用的了解，零拷贝的了解"></a>（34） 对象复用的了解，零拷贝的了解</h4><p>对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是继承和组合模式了。</p>
<p>零拷贝指的是在进行操作时，避免CPU从一处存储拷贝到另一处存储。在Linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read调用。</p>
<blockquote>
<p>用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。</p>
</blockquote>
<h4 id="（35）-介绍C-所有的构造函数"><a href="#（35）-介绍C-所有的构造函数" class="headerlink" title="（35） 介绍C++所有的构造函数"></a>（35） 介绍C++所有的构造函数</h4><p>C++中的构造函数主要有三种类型：默认构造函数、重载构造函数和拷贝构造函数</p>
<ul>
<li>默认构造函数是当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。</li>
<li>重载构造函数也称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。</li>
<li>拷贝构造函数是在发生对象复制的时候调用的。 <h4 id="（36）-什么情况下会调用拷贝构造函数（三种情况）"><a href="#（36）-什么情况下会调用拷贝构造函数（三种情况）" class="headerlink" title="（36） 什么情况下会调用拷贝构造函数（三种情况）"></a>（36） 什么情况下会调用拷贝构造函数（三种情况）</h4></li>
<li><p>对象以值传递的方式传入函数参数 </p>
<blockquote>
<p>如 <code>void func(Dog dog)&#123;&#125;;</code></p>
</blockquote>
</li>
<li><p>对象以值传递的方式从函数返回</p>
<blockquote>
<p>如 <code>Dog func()&#123; Dog d; return d;&#125;</code></p>
</blockquote>
</li>
<li>对象需要通过另外一个对象进行初始化</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lwbeyond/article/details/6202256">C++拷贝构造函数详解</a></p>
<h4 id="（37）-结构体内存对齐方式和为什么要进行内存对齐？"><a href="#（37）-结构体内存对齐方式和为什么要进行内存对齐？" class="headerlink" title="（37） 结构体内存对齐方式和为什么要进行内存对齐？"></a>（37） 结构体内存对齐方式和为什么要进行内存对齐？</h4><p>因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。</p>
<p>对齐规则：</p>
<ul>
<li>第一个成员在与结构体变量偏移量为0的地址</li>
<li>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。</li>
<li>对齐数=编译器默认的一个对齐数 与 该成员大小的较小值。</li>
<li>linux 中默认为4</li>
<li>vs 中的默认值为8<br>结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）</li>
</ul>
<h4 id="（38）-内存泄露的定义，如何检测与避免？"><a href="#（38）-内存泄露的定义，如何检测与避免？" class="headerlink" title="（38） 内存泄露的定义，如何检测与避免？"></a>（38） 内存泄露的定义，如何检测与避免？</h4><p>动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。</p>
<p>造成内存泄漏的几种原因：</p>
<p>1）类的构造函数和析构函数中new和delete没有配套</p>
<p>2）在释放对象数组时没有使用delete[]，使用了delete</p>
<p>3）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</p>
<p>4）没有正确的清楚嵌套的对象指针</p>
<p>避免方法：</p>
<ol>
<li>malloc/free要配套</li>
<li>使用智能指针；</li>
<li>将基类的析构函数设为虚函数；<h4 id="（39）-C-的智能指针有哪些"><a href="#（39）-C-的智能指针有哪些" class="headerlink" title="（39） C++的智能指针有哪些"></a>（39） C++的智能指针有哪些</h4>C++中的智能指针有auto_ptr,shared_ptr,weak_ptr和unique_ptr。智能指针其实是将指针进行了封装，可以像普通指针一样进行使用，同时可以自行进行释放，避免忘记释放指针指向的内存地址造成内存泄漏。</li>
</ol>
<ul>
<li>auto_ptr是较早版本的智能指针，在进行指针拷贝和赋值的时候，新指针直接接管旧指针的资源并且将旧指针指向空，但是这种方式在需要访问旧指针的时候，就会出现问题。</li>
<li>unique_ptr是auto_ptr的一个改良版，不能赋值也不能拷贝，保证一个对象同一时间只有一个智能指针。</li>
<li>shared_ptr可以使得一个对象可以有多个智能指针，当这个对象所有的智能指针被销毁时就会自动进行回收。（内部使用计数机制进行维护）</li>
<li>weak_ptr是为了协助shared_ptr而出现的。它不能访问对象，只能观测shared_ptr的引用计数，防止出现死锁。<h4 id="（40）-调试程序的方法"><a href="#（40）-调试程序的方法" class="headerlink" title="（40） 调试程序的方法"></a>（40） 调试程序的方法</h4></li>
<li>通过设置断点进行调试</li>
<li>打印log进行调试</li>
<li><p>打印中间结果进行调试</p>
<h4 id="（41）-遇到coredump要怎么调试"><a href="#（41）-遇到coredump要怎么调试" class="headerlink" title="（41） 遇到coredump要怎么调试"></a>（41） 遇到coredump要怎么调试</h4><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p>
</li>
<li><p>使用gdb命令对core文件进行调试</p>
</li>
</ul>
<p>以下例子在Linux上编写一段代码并导致segment fault 并产生core文件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir coredumpTest</span><br><span class="line">vim coredumpTest.cpp</span><br></pre></td></tr></table></figure><br>在编辑器内键入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int i;</span><br><span class="line">    scanf(&quot;%d&quot;,i);//正确的应该是&amp;i,这里使用i会导致segment fault</span><br><span class="line">    printf(&quot;%d\n&quot;,i);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>编译<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ coredumpTest.cpp -g -o coredumpTest</span><br></pre></td></tr></table></figure><br>运行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./coredumpTest</span><br></pre></td></tr></table></figure><br>使用gdb调试coredump<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb [可执行文件名] [core文件名]</span><br></pre></td></tr></table></figure></p>
<h4 id="（42）-inline关键字说一下-和宏定义有什么区别"><a href="#（42）-inline关键字说一下-和宏定义有什么区别" class="headerlink" title="（42） inline关键字说一下 和宏定义有什么区别"></a>（42） inline关键字说一下 和宏定义有什么区别</h4><p>inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。</p>
<p>1、内联函数在编译时展开，而宏在预编译时展开</p>
<p>2、在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</p>
<p>3、内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。</p>
<p>4、宏不是函数，而inline是函数</p>
<p>5、宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。</p>
<p>6、inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</p>
<p>7、宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</p>
<h4 id="（43）-模板的用法与适用场景-实现原理"><a href="#（43）-模板的用法与适用场景-实现原理" class="headerlink" title="（43） 模板的用法与适用场景 实现原理"></a>（43） 模板的用法与适用场景 实现原理</h4><p>用template \<typename T\>关键字进行声明，接下来就可以进行模板函数和模板类的编写了</p>
<p>编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，这次编译只会进行一个语法检查，并不会生成具体的代码。在运行时对代码进行参数替换后再进行编译，生成具体的函数代码。</p>
<h4 id="（44）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"><a href="#（44）-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？" class="headerlink" title="（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"></a>（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</h4><p>成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    FaceImage face;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>&amp; inputID,string&amp; inputName,FaceImage&amp; inputFace):<span class="built_in">id</span>(inputID),<span class="built_in">name</span>(inputName),<span class="built_in">face</span>(inputFace)&#123;&#125; <span class="comment">// 成员初始化列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>因为使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程，否则会调用一次传入参数的默认构造函数。所以使用成员初始化列表效率会高一些。<br><br>另外，有三种情况是必须使用成员初始化列表进行初始化的：</p>
<ul>
<li>常量成员的初始化，因为常量成员只能初始化不能赋值</li>
<li>引用类型</li>
<li>没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化</li>
</ul>
<p>详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html">C++ 初始化列表</a></p>
<h4 id="（45）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"><a href="#（45）-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）" class="headerlink" title="（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"></a>（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</h4><ul>
<li>自动类型推导auto：auto的自动类型推导用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作</li>
<li><p>nullptr：nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，而nullptr是void*类型的</p>
</li>
<li><p>lambda表达式：它类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：<br><code>[函数对象参数](操作符重载函数参数)mutable或exception声明-&gt;返回值类型&#123;函数体&#125;</code></p>
</li>
<li>thread类和mutex类</li>
<li>新的智能指针 unique_ptr和shared_ptr</li>
</ul>
<ul>
<li>更多详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279">https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279</a></li>
</ul>
<h4 id="（46）-C-的调用惯例（简单一点C-函数调用的压栈过程）"><a href="#（46）-C-的调用惯例（简单一点C-函数调用的压栈过程）" class="headerlink" title="（46） C++的调用惯例（简单一点C++函数调用的压栈过程）"></a>（46） C++的调用惯例（简单一点C++函数调用的压栈过程）</h4><p>函数的调用过程：</p>
<p>1）从栈空间分配存储空间</p>
<p>2）从实参的存储空间复制值到形参栈空间</p>
<p>3）进行运算</p>
<p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p>
<p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。</p>
<p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。</p>
<h4 id="（47）-C-的四种强制转换"><a href="#（47）-C-的四种强制转换" class="headerlink" title="（47） C++的四种强制转换"></a>（47） C++的四种强制转换</h4><p>四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast</p>
<ul>
<li>1）static_cast ：<br>用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。<blockquote>
<p>特性与要点：</p>
<ol>
<li>它没有运行时类型检查，所以是有安全隐患的。</li>
<li>在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。</li>
<li>static_cast不能转换const，volatile等属性</li>
</ol>
</blockquote>
</li>
<li>2）dynamic_cast：<br>用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。<br>dynamic_cast能够提供运行时类型检查，只用于含有虚函数的类。<br>dynamic_cast如果不能转换返回NULL。</li>
<li>3）const_cast：<br>用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。</li>
<li>4）reinterpret_cast<br>几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等。但是不够安全。<h4 id="（48）string的底层实现"><a href="#（48）string的底层实现" class="headerlink" title="（48）string的底层实现"></a>（48）string的底层实现</h4>string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。</li>
</ul>
<p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</p>
<h4 id="（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的"><a href="#（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的" class="headerlink" title="（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的"></a>（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的</h4><p>预处理，编译，汇编，链接</p>
<ul>
<li>预处理： 对预处理命令进行替换等预处理操作</li>
<li>编译：代码优化和生成汇编代码</li>
<li>汇编：将汇编代码转化为机器语言</li>
<li>链接：将目标文件彼此链接起来<h4 id="（50）set，map和vector的插入复杂度"><a href="#（50）set，map和vector的插入复杂度" class="headerlink" title="（50）set，map和vector的插入复杂度"></a>（50）set，map和vector的插入复杂度</h4>set,map的插入复杂度就是红黑树的插入复杂度，是log(N)。</li>
</ul>
<p>unordered_set,unordered_map的插入复杂度是常数，最坏是O(N).</p>
<p>vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝</p>
<h4 id="（51）定义和声明的区别"><a href="#（51）定义和声明的区别" class="headerlink" title="（51）定义和声明的区别"></a>（51）定义和声明的区别</h4><ul>
<li><p>声明是告诉编译器变量的类型和名字，不会为变量分配空间</p>
</li>
<li><p>定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次</p>
<h4 id="（52）typdef和define区别"><a href="#（52）typdef和define区别" class="headerlink" title="（52）typdef和define区别"></a>（52）typdef和define区别</h4></li>
</ul>
<p>define是预处理命令，在预处理是执行简单的替换，不做正确性的检查</p>
<p>typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名</p>
<h4 id="（53）被free回收的内存是立即返还给操作系统吗？为什么"><a href="#（53）被free回收的内存是立即返还给操作系统吗？为什么" class="headerlink" title="（53）被free回收的内存是立即返还给操作系统吗？为什么"></a>（53）被free回收的内存是立即返还给操作系统吗？为什么</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/YMY_mine/article/details/81180168">https://blog.csdn.net/YMY_mine/article/details/81180168</a></p>
<p>不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p>
<h4 id="（54）引用作为函数参数以及返回值的好处"><a href="#（54）引用作为函数参数以及返回值的好处" class="headerlink" title="（54）引用作为函数参数以及返回值的好处"></a>（54）引用作为函数参数以及返回值的好处</h4><p>对比值传递，引用传参的好处：</p>
<p>1）在函数内部可以对此参数进行修改</p>
<p>2）提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）</p>
<p>如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</p>
<p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。</p>
<p>但是有以下的限制：</p>
<p>1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁</p>
<p>2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</p>
<p>3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。 </p>
<h4 id="（55）友元函数和友元类"><a href="#（55）友元函数和友元类" class="headerlink" title="（55）友元函数和友元类"></a>（55）友元函数和友元类</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhuguanhao/p/6286145.html">https://www.cnblogs.com/zhuguanhao/p/6286145.html</a></p>
<p>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</p>
<p>1）友元函数</p>
<p>有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span></span>;      <span class="comment">//该函数是友元函数的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span>  <span class="comment">//友元函数定义，为了访问类A中的成员</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a.data = x;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。</p>
<p>2）友元类</p>
<p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。<br>但是另一个类里面也要相应的进行声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">C</span>;                         <span class="comment">//这是友元类的声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>             <span class="comment">//友元类定义，为了访问类A中的成员</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_show</span><span class="params">(<span class="type">int</span> x, A &amp;a)</span> </span>&#123; a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">A</span> a;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C</span> c;</span><br><span class="line"></span><br><span class="line">    c.<span class="built_in">set_show</span>(<span class="number">1</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用友元类时注意： </p>
<p>(1) 友元关系不能被继承。 </p>
<p>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 </p>
<p>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p>
<h4 id="（56）-说一下volatile关键字的作用"><a href="#（56）-说一下volatile关键字的作用" class="headerlink" title="（56） 说一下volatile关键字的作用"></a>（56） 说一下volatile关键字的作用</h4><p>volatile的意思是“脆弱的”，表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而提供稳定的访问。每次读取volatile的变量时，系统总是会从内存中读取这个变量，并且将它的值立刻保存。</p>
<h4 id="（57）-STL中的sort-算法是用什么实现的，stable-sort-呢"><a href="#（57）-STL中的sort-算法是用什么实现的，stable-sort-呢" class="headerlink" title="（57） STL中的sort()算法是用什么实现的，stable_sort()呢"></a>（57） STL中的sort()算法是用什么实现的，stable_sort()呢</h4><p>STL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。</p>
<h4 id="（58）vector会迭代器失效吗？什么情况下会迭代器失效？"><a href="#（58）vector会迭代器失效吗？什么情况下会迭代器失效？" class="headerlink" title="（58）vector会迭代器失效吗？什么情况下会迭代器失效？"></a>（58）vector会迭代器失效吗？什么情况下会迭代器失效？</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html">https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html</a></p>
<ul>
<li>会</li>
<li>当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效</li>
<li>当vector在插入的时候，end迭代器肯定会失效</li>
<li>当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。</li>
</ul>
<h4 id="（58）为什么C-没有实现垃圾回收？"><a href="#（58）为什么C-没有实现垃圾回收？" class="headerlink" title="（58）为什么C++没有实现垃圾回收？"></a>（58）为什么C++没有实现垃圾回收？</h4><ul>
<li>首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。  </li>
<li>垃圾回收会使得C++不适合进行很多底层的操作。</li>
</ul>
<h1 id="2-计网相关"><a href="#2-计网相关" class="headerlink" title="2. 计网相关"></a>2. 计网相关</h1><h4 id="（1）-建立TCP服务器的各个系统调用"><a href="#（1）-建立TCP服务器的各个系统调用" class="headerlink" title="（1） 建立TCP服务器的各个系统调用"></a>（1） 建立TCP服务器的各个系统调用</h4><p>建立TCP服务器连接的过程中主要通过以下系统调用序列来获取某些函数，这些系统调用主要包括：socket（），bind（），listen（），accept（），send（）和recv（）。<br>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37964547/article/details/81429627">建立TCP 服务器的系统调用</a></p>
<h4 id="（2）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"><a href="#（2）-继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？" class="headerlink" title="（2） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？"></a>（2） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？</h4><pre><code>socket()    创建套接字   
bind()      绑定本机端口    
connect()   建立连接     （TCP三次握手在调用这个函数时进行）
listen()    监听端口
accept()    接受连接
recv(), read(), recvfrom()  数据接收
send(), write(), sendto()   数据发送
close(), shutdown() 关闭套接字
</code></pre><p>使用close()时，只有当套接字的引用计数为0的时候才会终止连接，而用shutdown()就可以直接关闭连接</p>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/junjun150013652/article/details/37994907">网络编程Socket之TCP之close/shutdown详解</a></p>
<p>TCP连接与断开详解： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/felixzh/p/8359066.html">https://www.cnblogs.com/felixzh/p/8359066.html</a></p>
<h4 id="（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP"><a href="#（3）-对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP" class="headerlink" title="（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP."></a>（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP.</h4><ul>
<li><p>RIP“路由信息协议(Route Information Protocol)”的简写，主要传递路由信息，通过每隔30秒广播一次路由表，维护相邻路由器的位置关系，同时根据收到的路由表信息使用动态规划的方式计算自己的路由表信息。RIP是一个距离矢量路由协议,最大跳数为16跳,16跳以及超过16跳的网络则认为目标网络不可达。</p>
</li>
<li><p>OSPF：详见：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41341540">https://zhuanlan.zhihu.com/p/41341540</a></p>
</li>
</ul>
<h4 id="（4）-UDP如何实现可靠传输"><a href="#（4）-UDP如何实现可靠传输" class="headerlink" title="（4） UDP如何实现可靠传输"></a>（4） UDP如何实现可靠传输</h4><p>因为UDP是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，只能从应用层实现。需要实现seq/ack机制，重传机制和窗口确认机制。</p>
<p>就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。</p>
<p>作者：姚冬<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/283995548/answer/661809748">https://www.zhihu.com/question/283995548/answer/661809748</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h4 id="（5）-TCP和UDP的区别"><a href="#（5）-TCP和UDP的区别" class="headerlink" title="（5） TCP和UDP的区别"></a>（5） TCP和UDP的区别</h4><ul>
<li>TCP是面向连接的协议，提供的是可靠传输，在收发数据前需要通过三次握手建立连接，使用ACK对收发的数据进行正确性检验。而UDP是无连接的协议，不管对方有没有收到或者收到的数据是否正确。</li>
<li>TCP提供流量控制和拥塞控制，而UDP没有。</li>
<li>TCP对系统资源的要求高于UDP，所以速度也比UDP慢。</li>
<li>TCP数据包是没有边界的，会出现粘包的问题，UDP包是独立的，不会出现粘包问题。</li>
<li>所以在应用方面，如果强调数据的完整性和正确性用TCP，当要求性能和速度的时候，使用UDP更加合适。</li>
</ul>
<p>注：单凭TCP是不能保证完整性的，要是有黑客伪造TCP包，是无法识别的。</p>
<h4 id="（6）-TCP和UDP相关的协议与端口号"><a href="#（6）-TCP和UDP相关的协议与端口号" class="headerlink" title="（6） TCP和UDP相关的协议与端口号"></a>（6） TCP和UDP相关的协议与端口号</h4><p>TCP族的协议有HTTP，HTTPS，SMTP，TelNet，FTP等，UDP族的协议有DNS，DHCP等等。<br>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22080999/article/details/81105051">https://blog.csdn.net/qq_22080999/article/details/81105051</a></p>
<h4 id="（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）"><a href="#（7）-TCP（UDP，IP）等首部的认识（http请求报文构成）" class="headerlink" title="（7） TCP（UDP，IP）等首部的认识（http请求报文构成）"></a>（7） TCP（UDP，IP）等首部的认识（http请求报文构成）</h4><p>TCP的头部大致包括：源端口，目的端口，序号，确认号，偏移位，标志位，校验和等等</p>
<p>UDP的头部则包括：源端口，目的端口，长度，校验和。</p>
<p>IP数据包的头部包括：源IP地址，目的IP地址，协议，校验和，总长度等等</p>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangliangzi/article/details/52554439">https://blog.csdn.net/zhangliangzi/article/details/52554439</a></p>
<h4 id="（8）-网页解析的过程与实现方法"><a href="#（8）-网页解析的过程与实现方法" class="headerlink" title="（8） 网页解析的过程与实现方法"></a>（8） 网页解析的过程与实现方法</h4><p>这里仅展示浏览器解析服务器响应的过程，URL解析和交互的完整过程在(9)</p>
<ul>
<li>首先是html文档解析，浏览器会将html文档生成解析树，也就是DOM树，它由dom元素以及属性节点组成。</li>
<li>然后浏览器加载过程中如果遇到了外部css文件或者图片资源，还会另外发送请求来获取css文件和资源，这个请求通常是异步的，不会影响html文档的加载。</li>
<li>不过如果浏览器在加载时遇到了js文件，则会挂起渲染的线程，等待js文件加载解析完毕才恢复html的渲染线程。</li>
<li>然后是css解析，将css文件解析为样式表对象来渲染DOM树。<h4 id="（9）-在浏览器中输入URL后执行的全部过程（如www-baidu-com）"><a href="#（9）-在浏览器中输入URL后执行的全部过程（如www-baidu-com）" class="headerlink" title="（9）    在浏览器中输入URL后执行的全部过程（如www.baidu.com）"></a>（9）    在浏览器中输入URL后执行的全部过程（如www.baidu.com）</h4></li>
</ul>
<ol>
<li>首先是域名解析，客户端使用DNS协议将URL解析为对应的IP地址；</li>
<li>然后建立TCP连接，客户端与服务器通过三次握手建立TCP连接；</li>
<li>接着是http连接，客户端向服务器发送http连接请求； （http连接无需额外连接，直接通过已经建立的TCP连接发送）</li>
<li>服务器对客户端发来的http请求进行处理，并返回响应；</li>
<li>客户端接收到http响应，将结果渲染展示给用户。<h4 id="（10）-网络层分片的原因与具体实现"><a href="#（10）-网络层分片的原因与具体实现" class="headerlink" title="（10） 网络层分片的原因与具体实现"></a>（10） 网络层分片的原因与具体实现</h4>因为在链路层中帧的大小通常都有限制，比如在以太网中帧的最大大小（MTU）就是1500字节。如果IP数据包加上头部后大小超过1500字节，就需要分片。</li>
</ol>
<p>IP分片和完整IP报文差不多拥有相同的IP头，16位ID域对于每个分片都是一致的，这样才能在重新组装的时候识别出来自同一个IP报文的分片。在IP头里面，16位识别号唯一记录了一个IP包的ID，具有同一个ID的IP分片将会重新组装；而13位片偏移则记录了某IP片相对整个包的位置；而这两个表中间的3位标志则标志着该分片后面是否还有新的分片。这三个标志就组成了IP分片的所有信息(将在后面介绍)，接受方就可以利用这些信息对IP数据进行重新组织。<br>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/gettogetto/article/details/72851734">https://blog.csdn.net/gettogetto/article/details/72851734</a></p>
<h4 id="（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"><a href="#（11）-TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）" class="headerlink" title="（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）"></a>（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）</h4><ul>
<li>三次握手</li>
</ul>
<p>第一次握手：首先client给server发送连接请求报文，在这个报文中，包含了SYN=1，client_seq=任意值i，发送之后处于SYN-SENT状态，这是第一次握手</p>
<p>第二次握手：server端接收到了这个请求，并分配资源，同时给client返回一个ACK报文，这个报文中呢包含了这些字段，标志位SYN和ACK都为1，而小ack为i+1，此时位于SYN-RCVD状态，这是第二次握手</p>
<p>第三次握手：client收到server发来的ACK信息后呢，他会看到server发过来的小ack是i+1，这时他知道了server收到了消息，也给server回一个ACK报文，报文中同样包含了ACK=1这样的消息，同时呢，还包括了client_ack=k+1这样的字段，这样呢三次握手之后，连接就建立了，client进入established（已建立连接）状态<br><img src="fig/三次握手.png" alt="三次握手.png"></p>
<ul>
<li>四次挥手断开连接：</li>
</ul>
<p>TCP断开连接通常是由一方主动，一方被动的，这里我们假设client主动，server被动<br>第一次挥手：当client没有数据要发送给server了，他会给server发送一个FIN报文，告诉server：“我已经没有数据要发给你了，但是你要是还想给我发数据的话，你就接着发，但是你得告诉我你收到我的关闭信息了”，这是第一次挥手，挥手之后client进入FIN_WAIT_1的第一阶段</p>
<p>第二次挥手：当server收到client发来的FIN报文后，告诉client：“我收到你的FIN消息了，但是你等我发完的”此时给client返回一个ACK信息，并且呢ack=seq+1，这是第二次挥手，挥手之后呢server进入CLOSE_WAIT阶段，而client收到之后处于FIN_WAIT_2第二阶段</p>
<p>第三次挥手：当server发完所有数据时，他会给client发送一个FIN报文，告诉client说“我传完数据了，现在要关闭连接了”，然后呢server变成LAST_ACK状态，等着client最后的ACK信息，这是第三次挥手</p>
<p>第四次挥手：当client收到这个FIN报文时，他会对这个消息进行确认，即给server发ACK信息，但是它不相信网络，怕server收不到信息，它会进入TIME_WAIT状态，万一server没收到ACK消息它可以可以重传，而当server收到这个ACK信息后，就正式关闭了tcp连接，处于CLOSED状态，而client等待了2MSL这样长时间后还没等到消息，它知道server已经关闭连接了，于是乎他自己也断开了，这是第四次挥手，这样tcp连接就断开了<br><img src="fig/四次挥手.png" alt="fig/四次挥手.png"></p>
<h4 id="（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态"><a href="#（12）-TCP握手以及每一次握手客户端和服务器端处于哪个状态" class="headerlink" title="（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态"></a>（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态</h4><p>见上</p>
<h4 id="（13）-为什么使用三次握手，两次握手可不可以？"><a href="#（13）-为什么使用三次握手，两次握手可不可以？" class="headerlink" title="（13） 为什么使用三次握手，两次握手可不可以？"></a>（13） 为什么使用三次握手，两次握手可不可以？</h4><p>如果使用两次握手的话，三次握手中的最后一次缺失，服务器不能确认客户端的接收能力。</p>
<p>举两个例子，第一种是黑客会伪造大量SYN请求发送给服务器，服务器立即确认并建立连接，分配资源，但是这一系列连接并不是真实存在的，这大大浪费了服务器的资源并且阻塞了正常用户的连接，这种也叫SYN洪泛攻击。第二种是服务器返回给客户端的ACK数据包可能会在传输的过程中丢失，而客户端没有收到该ACK数据包而拒绝接收服务器接下来发送的数据，于是服务器一直在发送，客户端一直在拒绝，形成死锁。</p>
<h4 id="（14）-TIME-WAIT的意义（为什么要等于2MSL）"><a href="#（14）-TIME-WAIT的意义（为什么要等于2MSL）" class="headerlink" title="（14） TIME_WAIT的意义（为什么要等于2MSL）"></a>（14） TIME_WAIT的意义（为什么要等于2MSL）</h4><p>TIME_WAIT是指四次挥手中客户端接收了服务端的FIN报文并发送ACK报文给服务器后，仍然需要等待2MSL时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。如果客户端发送的ACK发生丢失，服务器会再次发送FIN报文给客户端，所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<h4 id="（15）-超时重传机制（不太高频）"><a href="#（15）-超时重传机制（不太高频）" class="headerlink" title="（15） 超时重传机制（不太高频）"></a>（15） 超时重传机制（不太高频）</h4><h4 id="（16）-TCP怎么保证可靠性？"><a href="#（16）-TCP怎么保证可靠性？" class="headerlink" title="（16） TCP怎么保证可靠性？"></a>（16） TCP怎么保证可靠性？</h4><p><strong>（校序重流拥）</strong></p>
<ul>
<li><p>校验和<br>发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 </p>
</li>
<li><p>确认应答+序列号<br>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 </p>
</li>
<li><p>超时重传<br>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 </p>
</li>
<li><p>流量控制<br>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。<br>接收方有即时窗口（滑动窗口），随ACK报文发送</p>
</li>
<li><p>拥塞控制<br>当网络拥塞时，减少数据的发送。<br>发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小</p>
</li>
</ul>
<p>慢启动、拥塞避免、快速重传、快速恢复 </p>
<h4 id="（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"><a href="#（17）-流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？" class="headerlink" title="（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？"></a>（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？</h4><p>所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用TCP报文段中的窗口大小字段来控制发送方的发送窗口不大于接收方发回的窗口大小就可以实施流量控制。</p>
<p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。</p>
<p>解决这个问题，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。</p>
<h4 id="（18）-tcp滑动窗口协议"><a href="#（18）-tcp滑动窗口协议" class="headerlink" title="（18） tcp滑动窗口协议"></a>（18） tcp滑动窗口协议</h4><p>详见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/wdscq1234/article/details/52444277">TCP-IP详解：滑动窗口SlidingWindow</a>和<a target="_blank" rel="noopener" href="https://www.cnblogs.com/alifpga/p/7675850.html">TCP滑动窗口</a></p>
<p>TCP的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。</p>
<p>接收方会在每个ACK数据包中附带自己当前的接受窗口（滑动窗口）的大小，方便发送方进行控制。</p>
<h4 id="（19）-拥塞控制和流量控制的区别"><a href="#（19）-拥塞控制和流量控制的区别" class="headerlink" title="（19） 拥塞控制和流量控制的区别"></a>（19） 拥塞控制和流量控制的区别</h4><p>拥塞控制是防止过多的数据注入到网络中，导致网络发生拥塞；而流量控制是防止发送方一下子发送过多的数据到接收方，导致接收方缓存放不下。两种算法都是对发送方的行为进行控制的。</p>
<h4 id="（20）-TCP拥塞控制，算法名字？（极其重要）"><a href="#（20）-TCP拥塞控制，算法名字？（极其重要）" class="headerlink" title="（20） TCP拥塞控制，算法名字？（极其重要）"></a>（20） TCP拥塞控制，算法名字？（极其重要）</h4><p><img src="fig/拥塞控制.png" alt="拥塞控制"><br>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载，拥塞控制自然也是控制发送者的流量，拥塞控制有四种算法，<strong>慢启动、拥塞避免，快速重传和快速恢复</strong></p>
<p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口和接受窗口的较小值。</p>
<p>（1）<strong>慢启动</strong>。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即1、2、4、8、16<br>*为了防止拥塞窗口cwnd增长过大引起网络拥塞，还要另外设置一个慢启动阈值ssthresh状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ cwnd &gt; ssthresh 时），停止使用慢开始算法而改用拥塞避免算法</p>
<p>（2）<strong>拥塞避免</strong>。拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。</p>
<p>（3）<strong>快速重传</strong>。当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。此时慢启动阈值ssth变为原来一半，拥塞窗口cwnd变为ssth+3，然后+1+1的发（每一轮rtt+1）</p>
<p>（4）<strong>快速恢复</strong>。当超过设定的时间没有收到某个报文段的ack时，表示网络拥塞，慢启动阈值ssth变为原来一半，拥塞窗口cwnd=1，进入慢启动阶段</p>
<h4 id="（21）-http协议与TCP的区别与联系"><a href="#（21）-http协议与TCP的区别与联系" class="headerlink" title="（21） http协议与TCP的区别与联系"></a>（21） http协议与TCP的区别与联系</h4><p>联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。</p>
<p>区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。<br>建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。</p>
<h4 id="（22）-http-1-0和http-1-1的区别"><a href="#（22）-http-1-0和http-1-1的区别" class="headerlink" title="（22） http/1.0和http/1.1的区别"></a>（22） http/1.0和http/1.1的区别</h4><p>HTTP 协议老的标准是 HTTP/1.0 ，目前最通用的标准是 HTTP/1.1 。<br>HTTP1.0 只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，但是最新的http/1.0加入了长连接，只需要在客户端给服务器发送的http报文头部加入Connection:keep-alive<br>HTTP 1.1 支持持久连接，默认进行持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p>
<h4 id="（23）-http的请求方法有哪些？get和post的区别。"><a href="#（23）-http的请求方法有哪些？get和post的区别。" class="headerlink" title="（23） http的请求方法有哪些？get和post的区别。"></a>（23） http的请求方法有哪些？get和post的区别。</h4><p>HTTP的请求方法包括GET，POST，PUT，DELETE四种基本方法。（四种方法中只有POST不是操作幂等性的）</p>
<p>get和post的区别：</p>
<ol>
<li>get方法不会修改服务器上的资源，它的查询是没有副作用的，而post有可能会修改服务器上的资源</li>
<li>get可以保存为书签，可以用缓存来优化，而post不可以</li>
<li>get把请求附在url上，而post把参数附在http包的包体中</li>
<li>浏览器和服务器一般对get方法所提交的url长度有限制，一般是1k或者2k，而对post方法所传输的参数大小限制为80k到4M不等</li>
<li>post可以传输二进制编码的信息，get的参数一般只支持ASCII<h4 id="（24）-http的状态码-403-201等等是什么意思"><a href="#（24）-http的状态码-403-201等等是什么意思" class="headerlink" title="（24） http的状态码 403 201等等是什么意思"></a>（24） http的状态码 403 201等等是什么意思</h4>详见 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011630575/article/details/46636535">HTTP状态码的含义</a></li>
</ol>
<p>常见的状态码有：</p>
<blockquote>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
<li>400 - 请求无效 </li>
<li>403 - 禁止访问 <h4 id="（25）-http和https的区别，由http升级为https需要做哪些操作"><a href="#（25）-http和https的区别，由http升级为https需要做哪些操作" class="headerlink" title="（25） http和https的区别，由http升级为https需要做哪些操作"></a>（25） http和https的区别，由http升级为https需要做哪些操作</h4>http 是超文本传输协议，信息是明文传输， https 则是具有安全性的 ssl 加密传输协议<br>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 ，后者是 443<br>http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比http 协议安全。<br>https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wqhwe/p/5407468.html">https://www.cnblogs.com/wqhwe/p/5407468.html</a></li>
</ul>
</blockquote>
<h4 id="（26）-https的具体实现，怎么确保安全性"><a href="#（26）-https的具体实现，怎么确保安全性" class="headerlink" title="（26） https的具体实现，怎么确保安全性"></a>（26） https的具体实现，怎么确保安全性</h4><p><strong>SSL是传输层的协议</strong></p>
<p>https包括非对称加密和对称加密两个阶段，在客户端与服务器建立连接的时候使用非对称加密，连接建立以后使用的是对称加密。</p>
<ol>
<li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接</li>
<li>Web服务器收到客户端请求后，会将网站的公钥传送一份给客户端，私钥自己保存。</li>
<li>客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥，称为会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li>
<li>Web服务器利用自己的私钥解密出会话密钥。</li>
<li>Web服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。</li>
</ol>
<p>服务器第一次传给客户端的公钥其实是CA对网站信息进行加密的数字证书</p>
<p>客户端的对称加密密钥其实是三个随机数的哈希（1. 客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3. 客户端收到返回时的随机数）</p>
<h4 id="（27）-TCP三次握手时的第一次的seq序号是怎样产生的"><a href="#（27）-TCP三次握手时的第一次的seq序号是怎样产生的" class="headerlink" title="（27） TCP三次握手时的第一次的seq序号是怎样产生的"></a>（27） TCP三次握手时的第一次的seq序号是怎样产生的</h4><p>第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。</p>
<p>seq = C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）。</p>
<h4 id="（28）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"><a href="#（28）-一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？" class="headerlink" title="（28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？"></a>（28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？</h4><p>65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16=65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。</p>
<p>而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。</p>
<h4 id="（29）-对称密码和非对称密码体系"><a href="#（29）-对称密码和非对称密码体系" class="headerlink" title="（29） 对称密码和非对称密码体系"></a>（29） 对称密码和非对称密码体系</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29689487/article/details/81634057">https://blog.csdn.net/qq_29689487/article/details/81634057</a></p>
<ul>
<li>对称加密：加密和解密使用的密钥是同一个<ul>
<li>优点：计算量小，算法速度快，加密效率高  缺点：密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲</li>
<li>常用算法：DES，3DES，IDEA，CR4，CR5，CR6，AES</li>
</ul>
</li>
<li>非对称加密：需要公钥和私钥，公钥用来加密，私钥用来解密<ul>
<li>优点：安全，不怕泄漏  缺点：速度慢</li>
<li>常用算法：RSA，ECC，DSA<h4 id="（30）-数字证书的了解（高频）"><a href="#（30）-数字证书的了解（高频）" class="headerlink" title="（30） 数字证书的了解（高频）"></a>（30） 数字证书的了解（高频）</h4><img src="fig/数字证书.jpg" alt="fig/数字证书.jpg"></li>
</ul>
</li>
</ul>
<p>权威CA使用私钥将网站A的信息和消息摘要（签名S）进行加密打包形成数字证书。公钥给客户端。</p>
<p>网站A将自己的信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密，得到签名S，与手动将网站的信息进行消息摘要得到的结果S*进行对比，如果签名一致就证明网站A可以信任。</p>
<h4 id="（31）-服务器出现大量close-wait的连接的原因以及解决方法"><a href="#（31）-服务器出现大量close-wait的连接的原因以及解决方法" class="headerlink" title="（31） 服务器出现大量close_wait的连接的原因以及解决方法"></a>（31） 服务器出现大量close_wait的连接的原因以及解决方法</h4><p>close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：</p>
<ul>
<li>服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li>
<li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</li>
</ul>
<p>处理方法：</p>
<ul>
<li>停止应用程序</li>
<li>修改程序里的bug<h4 id="（32）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"><a href="#（32）-消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）" class="headerlink" title="（32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）"></a>（32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）</h4></li>
<li><p>消息摘要算法有MD家族（MD2，MD4，MD5），SHA家族（SHA-1,SHA-256）和CRC家族（CRC8,CRC16,CRC32）等等</p>
</li>
<li><p>MD5算法介绍：<br>MD5以512位分组来处理输入的信息，且每一分组又被划分为若干个小分组（16个32位子分组），经过一些列的处理后，算法输出由四个散列值（32位分组组成的128位散列值。）</p>
</li>
</ul>
<ol>
<li>MD5首先将输入的信息分成若干个512字节长度的分组，如果不够就填充1和若干个0。</li>
<li>对每个512字节的分组进行循环运算。使用四个幻数对第一个分组的数据进行四轮变换，得到四个变量。</li>
<li>接下来对其中三个使用线性函数进行计算，与剩下一个相加，并赋值给其中某个变量，得到新的四个变量，重复16次这个过程，得到的四个变量作为幻数，与下一个分组进行相似的计算。</li>
<li>遍历所有分组后得到的四个变量即为结果。</li>
</ol>
<p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39640298/article/details/84555814">https://blog.csdn.net/weixin_39640298/article/details/84555814</a></p>
<ul>
<li><p>为什么不可逆：因为MD5在进行消息摘要的过程中，数据与原始数据相比发生了丢失，所以不能由结果进行恢复。</p>
</li>
<li><p>加强安全性：加盐（加随机数）</p>
<h4 id="（33）-单条记录高并发访问的优化"><a href="#（33）-单条记录高并发访问的优化" class="headerlink" title="（33） 单条记录高并发访问的优化"></a>（33） 单条记录高并发访问的优化</h4><p>服务器端：</p>
</li>
<li>使用缓存，如redis等</li>
<li>使用分布式架构进行处理</li>
<li>将静态页面和静态资源存储在静态资源服务器，需要处理的数据使用服务器进行计算后返回</li>
<li>将静态资源尽可能在客户端进行缓存</li>
<li>采用ngnix进行负载均衡 （nginx读作恩静埃克斯 = Engine X）</li>
</ul>
<p>数据库端：</p>
<ul>
<li>数据库采用主从赋值，读写分离措施</li>
<li>建立适当的索引</li>
<li>分库分表<h4 id="（34）-介绍一下ping的过程，分别用到了哪些协议"><a href="#（34）-介绍一下ping的过程，分别用到了哪些协议" class="headerlink" title="（34） 介绍一下ping的过程，分别用到了哪些协议"></a>（34） 介绍一下ping的过程，分别用到了哪些协议</h4>详见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html">Ping原理与ICMP协议</a></li>
</ul>
<p>ping是使用ICMP协议来进行工作的。 ICMP:网络控制报文协议</p>
<ul>
<li>首先，ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。</li>
<li>然后IP协议就会构建一个IP数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。</li>
<li>然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。</li>
</ul>
<p>目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把其中的信息提取出来交给IP协议，IP协议就会将其中的信息提取出来交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。</p>
<h4 id="（35）-TCP-IP的粘包与避免介绍一下"><a href="#（35）-TCP-IP的粘包与避免介绍一下" class="headerlink" title="（35） TCP/IP的粘包与避免介绍一下"></a>（35） TCP/IP的粘包与避免介绍一下</h4><p>因为TCP为了减少额外开销，采取的是流式传输，所以接收端在一次接收的时候有可能一次接收多个包。而TCP粘包就是发送方的若干个数据包到达接收方的时候粘成了一个包。多个包首尾相接，无法区分。</p>
<p>导致TCP粘包的原因有三方面：</p>
<ul>
<li>发送端等待缓冲区满才进行发送，造成粘包</li>
<li>接收方来不及接收缓冲区内的数据，造成粘包</li>
<li>由于TCP协议在发送较小的数据包的时候，会将几个包合成一个包后发送</li>
</ul>
<p>避免粘包的措施：</p>
<ul>
<li>通过编程，强制使TCP发生数据传送，不必等到缓冲区满</li>
<li>优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等</li>
<li>设置固定长度的报文或者设置报文头部指示报文的长度。</li>
</ul>
<h4 id="（36）-说一下TCP的封包和拆包"><a href="#（36）-说一下TCP的封包和拆包" class="headerlink" title="（36） 说一下TCP的封包和拆包"></a>（36） 说一下TCP的封包和拆包</h4><p>因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p>
<ul>
<li>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</li>
<li>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。<h4 id="（37）-一个ip配置多个域名，靠什么识别？"><a href="#（37）-一个ip配置多个域名，靠什么识别？" class="headerlink" title="（37） 一个ip配置多个域名，靠什么识别？"></a>（37） 一个ip配置多个域名，靠什么识别？</h4></li>
<li>靠host主机名区分</li>
<li>靠端口号区分<h4 id="（38）-服务器攻击（DDos攻击）"><a href="#（38）-服务器攻击（DDos攻击）" class="headerlink" title="（38） 服务器攻击（DDos攻击）"></a>（38） 服务器攻击（DDos攻击）</h4><h4 id="（39）DNS的工作过程和原理"><a href="#（39）DNS的工作过程和原理" class="headerlink" title="（39）DNS的工作过程和原理"></a>（39）DNS的工作过程和原理</h4><img src="fig/DNS查询图解.png" alt=""><br>DNS解析有两种方式：递归查询和迭代查询</li>
<li>递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。</li>
<li>迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果<h4 id="（41）OSA七层协议和五层协议，分别有哪些"><a href="#（41）OSA七层协议和五层协议，分别有哪些" class="headerlink" title="（41）OSA七层协议和五层协议，分别有哪些"></a>（41）OSA七层协议和五层协议，分别有哪些</h4>OSI七层协议模型主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</li>
</ul>
<p>五层体系结构包括：应用层、传输层、网络层、数据链路层和物理层。</p>
<p><img src="fig/网络协议层.png" alt="(fig/网络协议层.png"></p>
<h4 id="（42）IP寻址和MAC寻址有什么不同，怎么实现的"><a href="#（42）IP寻址和MAC寻址有什么不同，怎么实现的" class="headerlink" title="（42）IP寻址和MAC寻址有什么不同，怎么实现的"></a>（42）IP寻址和MAC寻址有什么不同，怎么实现的</h4><p>通过MAC地址寻找主机是MAC地址寻址，通过IP地址寻找主机叫IP地址寻址。它们适用于不同的协议层，IP寻址是网络层，Mac寻址是数据链路层。</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6388.html">http://c.biancheng.net/view/6388.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wxy_nick/article/details/9190693">https://blog.csdn.net/wxy_nick/article/details/9190693</a></p>
<p>IP寻址的过程（ARP协议）：主机A想通过IP地址寻找到目标主机，首先分析IP地址确定目标主机与自己是否为同一网段。如果是则查看ARP缓存，或者使用ARP协议发送广播。如果不是，则寻找网关发送ARP数据包</p>
<h1 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3. 数据库"></a>3. 数据库</h1><h4 id="（1）-关系型和非关系型数据库的区别（低频）"><a href="#（1）-关系型和非关系型数据库的区别（低频）" class="headerlink" title="（1） 关系型和非关系型数据库的区别（低频）"></a>（1） 关系型和非关系型数据库的区别（低频）</h4><ul>
<li>关系型数据库的优点<ol>
<li>容易理解。因为它采用了关系模型来组织数据。</li>
<li>可以保持数据的一致性。</li>
<li>数据更新的开销比较小。</li>
<li>支持复杂查询（带where子句的查询）</li>
</ol>
</li>
<li>非关系型数据库的优点<ol>
<li>不需要经过sql层的解析，读写效率高。</li>
<li>基于键值对，数据的扩展性很好。</li>
<li>可以支持多种类型数据的存储，如图片，文档等等。<h4 id="（2）-什么是非关系型数据库（低频）"><a href="#（2）-什么是非关系型数据库（低频）" class="headerlink" title="（2） 什么是非关系型数据库（低频）"></a>（2） 什么是非关系型数据库（低频）</h4>非关系型数据库也叫nosql，采用键值对的形式进行存储。它的读写性能很高，易于扩展。例如Redis,Mongodb,hbase等等。</li>
</ol>
</li>
</ul>
<p>适合使用非关系型数据库的场景：</p>
<ul>
<li>日志系统</li>
<li>地理位置存储</li>
<li>数据量巨大</li>
<li>高可用<h4 id="（3）-说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#（3）-说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="（3） 说一下 MySQL 执行一条查询语句的内部执行过程？"></a>（3） 说一下 MySQL 执行一条查询语句的内部执行过程？</h4></li>
<li>连接器：客户端先通过连接器连接到 MySQL 服务器。</li>
<li>缓存：连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</li>
<li>分析器：分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</li>
<li>优化器：优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</li>
<li>执行器：优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。<h4 id="（4）-数据库的索引类型"><a href="#（4）-数据库的索引类型" class="headerlink" title="（4） 数据库的索引类型"></a>（4） 数据库的索引类型</h4>数据库的索引类型分为逻辑分类和物理分类<br><br>逻辑分类：</li>
<li>主键索引 当关系表中定义主键时会自动创建主键索引。每张表中的主键索引只能有一个，要求主键中的每个值都唯一，即不可重复，也不能有空值。</li>
<li>唯一索引 数据列不能有重复，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有一列。如身份证，卡号等。</li>
<li>普通索引 一张表可以有多个普通索引，可以重复可以为空值</li>
<li>全文索引 可以加快模糊查询，不常用</li>
</ul>
<p>物理分类：</p>
<ul>
<li>聚集索引（聚簇索引） 数据在物理存储中的顺序跟索引中数据的逻辑顺序相同，比如以ID建立聚集索引，数据库中id从小到大排列，那么物理存储中该数据的内存地址值也按照从小到大存储。一般是表中的主键索引，如果没有主键索引就会以第一个非空的唯一索引作为聚集索引。一张表只能有一个聚集索引。</li>
<li>非聚集索引 数据在物理存储中的顺序跟索引中数据的逻辑顺序不同。非聚集索引因为无法定位数据所在的行，所以需要扫描两遍索引树。第一遍扫描非聚集索引的索引树，确定该数据的主键ID，然后到主键索引（聚集索引）中寻找相应的数据。<h4 id="（5）-说一下事务是怎么实现的"><a href="#（5）-说一下事务是怎么实现的" class="headerlink" title="（5） 说一下事务是怎么实现的"></a>（5） 说一下事务是怎么实现的</h4><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013256816/article/details/103966510">https://blog.csdn.net/u013256816/article/details/103966510</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/takumicx/p/9998844.html">https://www.cnblogs.com/takumicx/p/9998844.html</a></p>
<p>事务就是一组逻辑操作的集合。实现事务就是要保证可靠性和并发隔离，或者说，能够满足ACID特性的机制。而这些主要是靠日志恢复和并发控制实现的。</p>
<ul>
<li>日志恢复：数据库里有两个日志，一个是redo log，一个是undo log。redo log记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的<strong>持久性</strong>。undo log记录的是事务修改之前的数据信息，用来回滚数据，保证事务的<strong>原子性</strong>。</li>
<li>并发控制：并发控制主要靠读写锁和MVCC（多版本并发控制）来实现。读写锁包括共享锁和排他锁，保证事务的<strong>隔离性</strong>。MVCC通过为数据添加时间戳来实现。</li>
</ul>
<h4 id="（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"><a href="#（6）-MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？" class="headerlink" title="（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？"></a>（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？</h4><p>MySQL建立索引有两种方式：用alter table或者create index。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name add primary key(column_list) #添加一个主键索引</span><br><span class="line">alter table table_name add index (column_list)      #添加一个普通索引</span><br><span class="line">alter table table_name add unique (column_list)     #添加一个唯一索引</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on table_name (column_list)   #创建一个普通索引</span><br><span class="line">create unique index_name on table_name (column_list)  #创建一个唯一索引</span><br></pre></td></tr></table></figure></p>
<p>Mysql删除索引同样也有两种方式：alter table 和 drop index<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name drop index index_name    #删除一个普通索引</span><br><span class="line">alter table table_name drop primary key         #删除一个主键索引</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index index_name on table table_name</span><br></pre></td></tr></table></figure></p>
<h4 id="（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"><a href="#（7）-索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）" class="headerlink" title="（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）"></a>（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wezheng/p/8399305.html">https://www.cnblogs.com/wezheng/p/8399305.html</a></p>
<ul>
<li>经常搜索的列上建索引</li>
<li>作为主键的列上要建索引</li>
<li>经常需要连接（where子句）的列上</li>
<li>经常需要排序的列</li>
<li>经常需要范围查找的列</li>
</ul>
<p>哪些列不适合建索引？</p>
<ul>
<li>很少查询的列</li>
<li>更新很频繁的列</li>
<li>数据值的取值比较少的列（比如性别）<h4 id="（8）-索引的底层实现（重点）"><a href="#（8）-索引的底层实现（重点）" class="headerlink" title="（8） 索引的底层实现（重点）"></a>（8） 索引的底层实现（重点）</h4>数据库的索引是使用B+树来实现的。</li>
</ul>
<p>（为什么要用B+树，为什么不用红黑树和B树）<br><br>B+树是一种特殊的平衡多路树，是B树的优化改进版本，它把所有的数据都存放在叶节点上，中间节点保存的是索引。这样一来相对于B树来说，减少了数据对中间节点的空间占用，使得中间节点可以存放更多的指针，使得树变得更矮，深度更小，从而减少查询的磁盘IO次数，提高查询效率。另一个是由于叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。</p>
<p>而红黑树是二叉的，它的深度相对B+树来说更大，更大的深度意味着查找次数更多，更频繁的磁盘IO，所以红黑树更适合在内存中进行查找。</p>
<h4 id="（9）-B树和B-树的区别（重点）"><a href="#（9）-B树和B-树的区别（重点）" class="headerlink" title="（9） B树和B+树的区别（重点）"></a>（9） B树和B+树的区别（重点）</h4><p><img src="./fig/Bptree.png" alt="./fig/Bptree.png"></p>
<p>这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。</p>
<ol>
<li>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。</li>
<li>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。</li>
<li>分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。</li>
<li>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</li>
</ol>
<p>B+树优点：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。</p>
<h4 id="（10）-索引最左前缀-最左匹配"><a href="#（10）-索引最左前缀-最左匹配" class="headerlink" title="（10） 索引最左前缀/最左匹配"></a>（10） 索引最左前缀/最左匹配</h4><p>假如我们对a b c三个字段建立了联合索引，在联合索引中，从最左边的字段开始，任何连续的索引都能匹配上，当遇到范围查询的时候停止。比如对于联合索引index(a,b,c),能匹配a,ab,abc三组索引。并且对查询时字段的顺序没有限制，也就是a,b,c; b,a,c; c,a,b; c,b,a都可以匹配。</p>
<h4 id="（11）-Mysql的优化（高频，索引优化，性能优化）"><a href="#（11）-Mysql的优化（高频，索引优化，性能优化）" class="headerlink" title="（11） Mysql的优化（高频，索引优化，性能优化）"></a>（11） Mysql的优化（高频，索引优化，性能优化）</h4><p>高频访问：</p>
<ul>
<li>分表分库：将数据库表进行水平拆分，减少表的长度</li>
<li>增加缓存： 在web和DB之间加上一层缓存层</li>
<li>增加数据库的索引：在合适的字段加上索引，解决高频访问的问题</li>
</ul>
<p>并发优化：</p>
<ul>
<li>主从读写分离：只在主服务器上写，从服务器上读</li>
<li>负载均衡集群：通过集群或者分布式的方式解决并发压力<h4 id="（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别"><a href="#（12）-MYSQL数据库引擎介绍，innodb和myisam的特点与区别" class="headerlink" title="（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别"></a>（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别</h4></li>
<li>InnoDB ： InnoDB是mysql的默认引擎，支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表  行级锁</li>
<li>MyISAM ： 插入和查询速度比较高，支持大文件，但是不支持事务，适合在web和数据仓库场景下使用  表级锁</li>
<li>MEMORY ： memory将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景</li>
<li>CSV</li>
<li>blackhole<h4 id="（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"><a href="#（13）-数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）" class="headerlink" title="（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）"></a>（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）</h4>数据库事务是指逻辑上对数据的一种操作，这个事务要么全部成功，要么全部失败。</li>
</ul>
<p><strong>A: atom 原子性</strong><br><br>数据库事务的原子性是指：事务是一个不可分割的工作单位，这组操作要么全部发生，要么全部不发生。</p>
<p><strong>C: consistency 一致性</strong><br><br>数据库事务的一致性是指：在事务开始以前，数据库中的数据有一个一致的状态。在事务完成后，数据库中的事务也应该保持这种一致性。事务应该将数据从一个一致性状态转移到另一个一致性状态。<br>比如在银行转账操作后两个账户的总额应当不变。</p>
<p><strong>I: isolation 隔离性</strong><br><br>数据库事务的隔离性要求数据库中的事务不会受另一个并发执行的事务的影响，对于数据库中同时执行的每个事务来说，其他事务要么还没开始执行，要么已经执行结束，它都感觉不到还有别的事务正在执行。</p>
<p><strong>D：durability 持久性</strong><br><br>数据库事务的持久性要求事务对数据库的改变是永久的，哪怕数据库发生损坏都不会影响到已发生的事务。<br>如果事务没有完成，数据库因故断电了，那么重启后也应该是没有执行事务的状态，如果事务已经完成后数据库断电了，那么重启后就应该是事务执行完成后的状态。</p>
<h4 id="（14）什么是脏读，不可重复读和幻读？"><a href="#（14）什么是脏读，不可重复读和幻读？" class="headerlink" title="（14）什么是脏读，不可重复读和幻读？"></a>（14）什么是脏读，不可重复读和幻读？</h4><p>详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a></p>
<ul>
<li><p>脏读：脏读是指一个事务在处理过程中读取了另一个还没提交的事务的数据。</p>
<blockquote>
<p>比如A向B转账100，A的账户减少了100，而B的账户还没来得及修改，此时一个并发的事务访问到了B的账户，就是脏读</p>
</blockquote>
</li>
<li>不可重复读：不可重复读是对于数据库中的某一个字段，一个事务多次查询却返回了不同的值，这是由于在查询的间隔中，该字段被另一个事务修改并提交了。<blockquote>
<p>比如A第一次查询自己的账户有1000元，此时另一个事务给A的账户增加了1000元，所以A再次读取他的账户得到了2000的结果，跟第一次读取的不一样。<br>不可重复读与脏读的不同之处在于，脏读是读取了另一个事务没有提交的脏数据，不可重复读是读取了已经提交的数据，实际上并不是一个异常现象。</p>
</blockquote>
</li>
<li>幻读：事务多次读取同一个范围的时候，查询结果的记录数不一样，这是由于在查询的间隔中，另一个事务新增或删除了数据。<blockquote>
<p>比如A公司一共有100个人，第一次查询总人数得到100条记录，此时另一个事务新增了一个人，所以下一次查询得到101条记录。<br>不可重复度和幻读的不同之处在于，幻读是多次读取的结果行数不同，不可重复度是读取结果的值不同。</p>
</blockquote>
</li>
</ul>
<p>避免不可重复读需要锁行，避免幻读则需要锁表。</p>
<p>脏读，不可重复读和幻读都是数据库的读一致性问题，是在并行的过程中出现的问题，必须采用一定的隔离级别解决。<br>详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Hakuna-Matata/p/7772794.html">脏读、不可重复读和幻读的区别</a></p>
<h4 id="（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"><a href="#（15）-数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）" class="headerlink" title="（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）"></a>（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）</h4><p>详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a>和<a target="_blank" rel="noopener" href="https://blog.csdn.net/fg2006/article/details/6937413">数据库隔离级别</a></p>
<p>为了保证数据库事务一致性，解决脏读，不可重复读和幻读的问题，数据库的隔离级别一共有四种隔离级别：</p>
<ul>
<li>读未提交 Read Uncommitted: 最低级别的隔离，不能解决以上问题</li>
<li>读已提交 Read committed:   可以避免脏读的发生 </li>
<li>可重复读 Reapeatable read:  确保事务可以多次从一个字段中读取相同的值，在该事务执行期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读。 通过锁行来实现 </li>
<li>串行化 Serializaion  最严格的事务隔离机制，要求所有事务被串行执行，可以避免以上所有问题。 通过锁表来实现</li>
</ul>
<p>Oracle的默认隔离级别是<strong>读已提交</strong>，实现了四种隔离级别中的读已提交和串行化隔离级别</p>
<p>MySQL的默认隔离级别是<strong>可重复读</strong>，并且实现了所有四种隔离级别</p>
<h4 id="（16）-数据库连接池的作用"><a href="#（16）-数据库连接池的作用" class="headerlink" title="（16） 数据库连接池的作用"></a>（16） 数据库连接池的作用</h4><h4 id="（17）-Mysql的表空间方式，各自特点"><a href="#（17）-Mysql的表空间方式，各自特点" class="headerlink" title="（17） Mysql的表空间方式，各自特点"></a>（17） Mysql的表空间方式，各自特点</h4><ul>
<li>共享表空间：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。 </li>
<li><p>独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 优点：当表被删除时这部分空间可以被回收；可以更快的恢复和备份单个表；将单个表复制到另一个实例会很方便； 缺点：mysqld会维持很多文件句柄，表太多会影响性能。如果很多表都增长会导致碎片问题</p>
<h4 id="（18）-分布式事务"><a href="#（18）-分布式事务" class="headerlink" title="（18） 分布式事务"></a>（18） 分布式事务</h4><h4 id="（19）-数据库的范式"><a href="#（19）-数据库的范式" class="headerlink" title="（19） 数据库的范式"></a>（19） 数据库的范式</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html">https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</a></p>
</li>
<li><p><strong>第一范式(确保每列保持原子性)</strong><br><br>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p>
</li>
</ul>
<blockquote>
<p>比如 学生 选课（包括很多课程） 就不符合第一范式</p>
<ul>
<li><strong>第二范式(确保表中的每列都和主键相关)</strong><br><br>在满足第一范式的前提下，（主要针对联合主键而言）第二范式需要确保数据库表中的每一列都和主键的所有成员直接相关，由整个主键才能唯一确定，而不能只与主键的某一部分相关或者不相关。 </li>
</ul>
<p>比如一张学生信息表，由主键（学号）可以唯一确定一个学生的姓名，班级，年龄等信息。但是主键 （学号，班级） 与列 姓名，班主任，教室 就不符合第二范式，因为班主任跟部分主键（班级）是依赖关系</p>
<ul>
<li><strong>第三范式(确保非主键的列没有传递依赖)</strong><br><br>在满足第二范式的前提下，第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。非主键的列不能确定其他列，列与列之间不能出现传递依赖。</li>
</ul>
<p>比如一张学生信息表，主键是（学号）列包括 姓名，班级，班主任 就不符合第三范式，因为非主键的列中 班主任 依赖于 班级</p>
<ul>
<li><strong>BCNF范式（确保主键之间没有传递依赖）</strong><br><br>主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。<h4 id="（20）-数据的锁的种类，加锁的方式"><a href="#（20）-数据的锁的种类，加锁的方式" class="headerlink" title="（20） 数据的锁的种类，加锁的方式"></a>（20） 数据的锁的种类，加锁的方式</h4>以MYSQL为例，</li>
<li>按照类型来分有乐观锁和悲观锁</li>
<li>根据粒度来分有行级锁，页级锁，表级锁（粒度一个比一个大） （仅BDB，Berkeley Database支持页级锁）</li>
<li>根据作用来分有共享锁（读锁）和排他锁（写锁）。<h4 id="（21）-什么是共享锁和排他锁"><a href="#（21）-什么是共享锁和排他锁" class="headerlink" title="（21） 什么是共享锁和排他锁"></a>（21） 什么是共享锁和排他锁</h4></li>
<li>共享锁是读操作的时候创建的锁，一个事务对数据加上共享锁之后，其他事务只能对数据再加共享锁，不能进行写操作直到释放所有共享锁。</li>
<li>排他锁是写操作时创建的锁，事务对数据加上排他锁之后其他任何事务都不能对数据加任何的锁（即其他事务不能再访问该数据）</li>
</ul>
</blockquote>
<p>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42743933/article/details/81236658">https://blog.csdn.net/qq_42743933/article/details/81236658</a></p>
<h4 id="（22）-分库分表的理解和简介"><a href="#（22）-分库分表的理解和简介" class="headerlink" title="（22） 分库分表的理解和简介"></a>（22） 分库分表的理解和简介</h4><h4 id="（23）"><a href="#（23）" class="headerlink" title="（23）"></a>（23）</h4><h4 id="（24）数据库高并发的解决方案"><a href="#（24）数据库高并发的解决方案" class="headerlink" title="（24）数据库高并发的解决方案"></a>（24）数据库高并发的解决方案</h4><ol>
<li>在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li>
<li>增加数据库索引。提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li>
<li>主从读写分离，让主服务器负责写，从服务器负责读。</li>
<li>将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。</li>
<li>使用分布式架构，分散计算压力。<h4 id="（25）乐观锁与悲观锁解释一下"><a href="#（25）乐观锁与悲观锁解释一下" class="headerlink" title="（25）乐观锁与悲观锁解释一下"></a>（25）乐观锁与悲观锁解释一下</h4>一般的数据库都会支持并发操作，在并发操作中为了避免数据冲突，所以需要对数据上锁，乐观锁和悲观锁就是两种不同的上锁方式。</li>
</ol>
<p>悲观锁假设数据在并发操作中一定会发生冲突，所以在数据开始读取的时候就把数据锁住。而乐观锁则假设数据一般情况下不会发生冲突，所以在数据提交更新的时候，才会检测数据是否有冲突。</p>
<h4 id="（26）乐观锁与悲观锁是怎么实现的"><a href="#（26）乐观锁与悲观锁是怎么实现的" class="headerlink" title="（26）乐观锁与悲观锁是怎么实现的"></a>（26）乐观锁与悲观锁是怎么实现的</h4><p>悲观锁有行级锁和页级锁两种形式。行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据，而页级锁则对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务并行访问。</p>
<p>悲观锁要求在整个过程中一直与数据库有一条连接，因为上一个事务完成后才能让下一个事务执行，这个过程是串行的。</p>
<p>乐观锁有三种常用的实现形式：</p>
<ul>
<li>一种是在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一摸一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。</li>
<li>一种是使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。</li>
<li>最后一种采用时间戳对数据最后修改的时间进行标记。与上一种类似。</li>
</ul>
<h1 id="4-Linux"><a href="#4-Linux" class="headerlink" title="4. Linux"></a>4. Linux</h1><h4 id="（1）-Linux的I-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"><a href="#（1）-Linux的I-O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）" class="headerlink" title="（1） Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）"></a>（1） Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sqsltr/article/details/92762279">https://blog.csdn.net/sqsltr/article/details/92762279</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/euphie/p/6376508.html">https://www.cnblogs.com/euphie/p/6376508.html</a></p>
<p>（IO过程包括两个阶段：（1）内核从IO设备读写数据和（2）进程从内核复制数据）</p>
<ul>
<li>阻塞：调用IO操作的时候，如果缓冲区空或者满了，调用的进程或者线程就会处于阻塞状态直到IO可用并完成数据拷贝。</li>
<li>非阻塞：调用IO操作的时候，内核会马上返回结果，如果IO不可用，会返回错误，这种方式下进程需要不断轮询直到IO可用为止，但是当进程从内核拷贝数据时是阻塞的。</li>
<li>IO多路复用就是同时监听多个描述符，一旦某个描述符IO就绪（读就绪或者写就绪），就能够通知进程进行相应的IO操作，否则就将进程阻塞在select或者epoll语句上。</li>
</ul>
<ul>
<li>同步IO：同步IO模型包括阻塞IO，非阻塞IO和IO多路复用。特点就是当进程从内核复制数据的时候都是阻塞的。</li>
<li>异步IO：在检测IO是否可用和进程拷贝数据的两个阶段都是不阻塞的，进程可以做其他事情，当IO完成后内核会给进程发送一个信号。<h4 id="（2）-文件系统的理解（EXT4，XFS，BTRFS）"><a href="#（2）-文件系统的理解（EXT4，XFS，BTRFS）" class="headerlink" title="（2） 文件系统的理解（EXT4，XFS，BTRFS）"></a>（2） 文件系统的理解（EXT4，XFS，BTRFS）</h4></li>
</ul>
<h4 id="（3）-EPOLL的介绍和了解"><a href="#（3）-EPOLL的介绍和了解" class="headerlink" title="（3） EPOLL的介绍和了解"></a>（3） EPOLL的介绍和了解</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56486633">https://zhuanlan.zhihu.com/p/56486633</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/397449cadc9a">https://www.jianshu.com/p/397449cadc9a</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/davidsguo008/article/details/73556811">https://blog.csdn.net/davidsguo008/article/details/73556811</a></p>
<p>Epoll是Linux进行IO多路复用的一种方式，用于在一个线程里监听多个IO源，在IO源可用的时候返回并进行操作。它的特点是基于事件驱动，性能很高。</p>
<p>epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间，由用户程序进行处理。</p>
<p>Epoll有三个系统调用：epoll_create(),epoll_ctl()和epoll_wait()。</p>
<ul>
<li><p>eoll_create()函数在内核中初始化一个eventpoll对象，同时初始化红黑树和就绪链表。</p>
</li>
<li><p>epoll_ctl()用来对监听的文件描述符进行管理。将文件描述符插入红黑树，或者从红黑树中删除，这个过程的时间复杂度是log(N)。同时向内核注册文件描述符的回调函数。</p>
</li>
<li><p>epoll_wait()会将进程放到eventpoll的等待队列中，将进程阻塞，当某个文件描述符IO可用时，内核通过回调函数将该文件描述符放到就绪链表里，epoll_wait()会将就绪链表里的文件描述符返回到用户空间。</p>
<h4 id="（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？"><a href="#（4）-IO复用的三种方法（select-poll-epoll）深入理解，包括三者区别，内部原理实现？" class="headerlink" title="（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？"></a>（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？</h4><p>（1）select的方法介绍：select把所有监听的文件描述符拷贝到内核中，挂起进程。当某个文件描述符可读或可写的时候，中断程序唤起进程，select将监听的文件描述符再次拷贝到用户空间，然select后遍历这些文件描述符找到IO可用的文件。下次监控的时候需要再次拷贝这些文件描述符到内核空间。select支持监听的描述符最大数量是1024.<br><img src="fig/select.png" alt="select"><br>（2）poll使用链表保存文件描述符，其他的跟select没有什么不同。</p>
</li>
</ul>
<p>（3）epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间。<br><img src="fig/epoll.png" alt="epoll"><br>详见 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/3265058.html">https://www.cnblogs.com/Anker/p/3265058.html</a></p>
<h4 id="（5）-Epoll的ET模式和LT模式（ET的非阻塞）"><a href="#（5）-Epoll的ET模式和LT模式（ET的非阻塞）" class="headerlink" title="（5） Epoll的ET模式和LT模式（ET的非阻塞）"></a>（5） Epoll的ET模式和LT模式（ET的非阻塞）</h4><ul>
<li>ET是边缘触发模式，在这种模式下，只有当描述符从未就绪变成就绪时，内核才会通过epoll进行通知。然后直到下一次变成就绪之前，不会再次重复通知。也就是说，如果一次就绪通知之后不对这个描述符进行IO操作导致它变成未就绪，内核也不会再次发送就绪通知。优点就是只通知一次，减少内核资源浪费，效率高。缺点就是不能保证数据的完整，有些数据来不及读可能就会无法取出。</li>
<li>LT是水平触发模式，在这个模式下，如果文件描述符IO就绪，内核就会进行通知，如果不对它进行IO操作，只要还有未操作的数据，内核都会一直进行通知。优点就是可以确保数据可以完整输出。缺点就是由于内核会一直通知，会不停从内核空间切换到用户空间，资源浪费严重。</li>
</ul>
<h4 id="（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"><a href="#（6）-查询进程占用CPU的命令（注意要了解到used，buf，代表意义）" class="headerlink" title="（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）"></a>（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）</h4><p>详见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36357820/article/details/76606113">https://blog.csdn.net/qq_36357820/article/details/76606113</a></p>
<ol>
<li>top命令查看linux负载：</li>
<li>uptime查看linux负载</li>
<li>w查看linux负载：</li>
<li>vmstat查看linux负载<h4 id="（7）-linux的其他常见命令（kill，find，cp等等）"><a href="#（7）-linux的其他常见命令（kill，find，cp等等）" class="headerlink" title="（7） linux的其他常见命令（kill，find，cp等等）"></a>（7） linux的其他常见命令（kill，find，cp等等）</h4><h4 id="（8）-shell脚本用法"><a href="#（8）-shell脚本用法" class="headerlink" title="（8） shell脚本用法"></a>（8） shell脚本用法</h4><h4 id="（9）-硬连接和软连接的区别"><a href="#（9）-硬连接和软连接的区别" class="headerlink" title="（9） 硬连接和软连接的区别"></a>（9） 硬连接和软连接的区别</h4><h4 id="（10）-文件权限怎么看（rwx）"><a href="#（10）-文件权限怎么看（rwx）" class="headerlink" title="（10） 文件权限怎么看（rwx）"></a>（10） 文件权限怎么看（rwx）</h4><h4 id="（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变"><a href="#（11）-文件的三种时间（mtime-atime，ctime），分别在什么时候会改变" class="headerlink" title="（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变"></a>（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变</h4><h4 id="（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"><a href="#（12）-Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令" class="headerlink" title="（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令"></a>（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令</h4><h4 id="（13）Linux中线程的同步方式有哪些？"><a href="#（13）Linux中线程的同步方式有哪些？" class="headerlink" title="（13）Linux中线程的同步方式有哪些？"></a>（13）Linux中线程的同步方式有哪些？</h4><h4 id="（14）怎么修改一个文件的权限"><a href="#（14）怎么修改一个文件的权限" class="headerlink" title="（14）怎么修改一个文件的权限"></a>（14）怎么修改一个文件的权限</h4>chmod 777  (177 277 477 等，权限组合是 1 2 4，分别代表r x w )</li>
</ol>
<h4 id="（15）查看文件内容常用命令"><a href="#（15）查看文件内容常用命令" class="headerlink" title="（15）查看文件内容常用命令"></a>（15）查看文件内容常用命令</h4><p>详见： <a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html">http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html</a></p>
<ol>
<li>cat 与 tac<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat的功能是将文件从第一行开始连续的将内容输出在屏幕上。当文件大，行数比较多时，屏幕无法全部容下时，只能看到一部分内容。所以通常使用重定向的方式，输出满足指定格式的内容</span><br><span class="line"></span><br><span class="line">cat语法：cat [-n]  文件名 （-n ： 显示时，连行号一起输出）</span><br><span class="line"></span><br><span class="line">tac的功能是将文件从最后一行开始倒过来将内容数据输出到屏幕上。我们可以发现，tac实际上是cat反过来写。这个命令不常用。</span><br><span class="line"></span><br><span class="line">tac语法：tac 文件名。</span><br></pre></td></tr></table></figure></li>
<li>more和less（常用）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">more的功能是将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容。当一页无法全部输出时，可以用“回车键”向下翻行，用“空格键”向下翻页。退出查看页面，请按“q”键。另外，more还可以配合管道符“|”（pipe）使用，例如:ls -al | more</span><br><span class="line"></span><br><span class="line">more的语法：more 文件名</span><br><span class="line"></span><br><span class="line">Enter 向下n行，需要定义，默认为1行； </span><br><span class="line"></span><br><span class="line">Ctrl f 向下滚动一屏； </span><br><span class="line"></span><br><span class="line">空格键 向下滚动一屏； </span><br><span class="line"></span><br><span class="line">Ctrl b 返回上一屏； </span><br><span class="line"></span><br><span class="line">= 输出当前行的行号； </span><br><span class="line"></span><br><span class="line">:f 输出文件名和当前行的行号； </span><br><span class="line"></span><br><span class="line">v 调用vi编辑器； </span><br><span class="line"></span><br><span class="line">! 命令 调用Shell，并执行命令； </span><br><span class="line"></span><br><span class="line">q 退出more</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">less的功能和more相似，但是使用more无法向前翻页，只能向后翻。</span><br><span class="line"></span><br><span class="line">less可以使用【pageup】和【pagedown】键进行前翻页和后翻页，这样看起来更方便。</span><br><span class="line"></span><br><span class="line">less的语法：less 文件名</span><br></pre></td></tr></table></figure></li>
<li>head和tail<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">head和tail通常使用在只需要读取文件的前几行或者后几行的情况下使用。head的功能是显示文件的前几行内容</span><br><span class="line"></span><br><span class="line">head的语法：head [n number] 文件名 (number 显示行数)</span><br><span class="line"></span><br><span class="line">tail的功能恰好和head相反，只显示最后几行内容</span><br><span class="line"></span><br><span class="line">tail的语法:tail [-n number] 文件名</span><br></pre></td></tr></table></figure></li>
<li>nl<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nl的功能和cat -n一样，同样是从第一行输出全部内容，并且把行号显示出来</span><br><span class="line"></span><br><span class="line">nl的语法：nl 文件名</span><br></pre></td></tr></table></figure></li>
<li>vim</li>
</ol>
<p>这个用的太普遍了，主要是用于编辑。</p>
<h4 id="（16）怎么找出含有关键字的前后4行"><a href="#（16）怎么找出含有关键字的前后4行" class="headerlink" title="（16）怎么找出含有关键字的前后4行"></a>（16）怎么找出含有关键字的前后4行</h4><h4 id="（17）Linux的GDB调试"><a href="#（17）Linux的GDB调试" class="headerlink" title="（17）Linux的GDB调试"></a>（17）Linux的GDB调试</h4><h4 id="（18）coredump是什么-怎么才能coredump"><a href="#（18）coredump是什么-怎么才能coredump" class="headerlink" title="（18）coredump是什么 怎么才能coredump"></a>（18）coredump是什么 怎么才能coredump</h4><p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p>
<p>coredump产生的条件</p>
<ol>
<li>shell资源控制限制，使用 ulimit -c 命令查看shell执行程序时的资源 ，如果为0，则不会产生coredump。可以用ulimit -c unlimited设置为不限大小。</li>
<li>读写越界，包括：数组访问越界，指针指向错误的内存，字符串读写越界</li>
<li>使用了线程不安全的函数，读写未加锁保护</li>
<li>错误使用指针转换</li>
<li>堆栈溢出<h4 id="（19）tcpdump常用命令"><a href="#（19）tcpdump常用命令" class="headerlink" title="（19）tcpdump常用命令"></a>（19）tcpdump常用命令</h4>用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</li>
</ol>
<p>实用命令实例</p>
<p>将某端口收发的数据包保存到文件<br><br><code>sudo tcpdump -i any port 端口 -w 文件名.cap</code></p>
<p>打印请求到屏幕<br><br><code>sudo tcpdump -i any port 端口 -Xnlps0</code></p>
<p>默认启动<br><br><code>tcpdump</code><br>普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包。<br>监视指定网络接口的数据包<br><br><code>tcpdump -i eth1</code><br>如果不指定网卡，默认tcpdump只会监视第一个网络接口，一般是eth0，下面的例子都没有指定网络接口。　</p>
<h4 id="（20）-crontab命令"><a href="#（20）-crontab命令" class="headerlink" title="（20） crontab命令"></a>（20） crontab命令</h4><p>详见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html">https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html</a></p>
<p>corntab命令是用来指定用户计划任务的。用户将需要定时执行的任务写入crontab文件中，提交给crond进程定期执行。</p>
<ul>
<li><p>crontab命令用来对crontab文件进行管理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1．命令格式：</span><br><span class="line">crontab [-u user] file</span><br><span class="line">crontab [-u user] [ -e | -l | -r ]</span><br><span class="line">2．命令功能：</span><br><span class="line">通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</span><br><span class="line">3．命令参数：</span><br><span class="line">-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。</span><br><span class="line">file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</span><br><span class="line">-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</span><br><span class="line">-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</span><br><span class="line">-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</span><br><span class="line">-i：在删除用户的crontab文件时给确认提示。</span><br></pre></td></tr></table></figure>
</li>
<li><p>crontab文件内容</p>
</li>
</ul>
<p>crond是Linux下的周期性执行系统任务的守护进程，他会根据/etc下的crontab配置文件的内容执行。用户需要将计划任务写入crontab文件中才能执行。</p>
<p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minute   hour   day   month   week   command</span><br></pre></td></tr></table></figure></p>
<p>其中：</p>
<ul>
<li>minute： 表示分钟，可以是从0到59之间的任何整数。</li>
<li>hour：表示小时，可以是从0到23之间的任何整数。</li>
<li>day：表示日期，可以是从1到31之间的任何整数。</li>
<li>month：表示月份，可以是从1到12之间的任何整数。</li>
<li>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</li>
<li>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</li>
</ul>
<p>在以上各个字段中，还可以使用以下特殊字符：</p>
<ul>
<li>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</li>
<li>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</li>
<li>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</li>
<li>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</li>
</ul>
<h4 id="（21）-查看后台进程"><a href="#（21）-查看后台进程" class="headerlink" title="（21） 查看后台进程"></a>（21） 查看后台进程</h4><ul>
<li>jobs</li>
</ul>
<p>查看当前控制台的后台进程</p>
<p>想要停止后台进程，使用jobs命令查看其进程号（比如为num），然后kill %num即可</p>
<ul>
<li>ps</li>
</ul>
<p>查看后台进程</p>
<ul>
<li>top</li>
</ul>
<p>查看所有进程和资源使用情况，类似Windows中的任务管理器</p>
<p>停止进程：界面是交互式的，在窗口输入k 之后输入PID，会提示输入停止进程模式 有SIGTERM和 SIGKILL 如果留空不输入，就是SIGTERM（优雅停止）</p>
<p>退出top：输入q即可</p>
<h1 id="5-操作系统"><a href="#5-操作系统" class="headerlink" title="5. 操作系统"></a>5. 操作系统</h1><h4 id="（1）-进程与线程的区别和联系（重点）"><a href="#（1）-进程与线程的区别和联系（重点）" class="headerlink" title="（1） 进程与线程的区别和联系（重点）"></a>（1） 进程与线程的区别和联系（重点）</h4><ul>
<li>区别</li>
</ul>
<ol>
<li>进程是对运行时程序的封装，是系统进行资源分配和调度的基本单元，而线程是进程的子任务，是CPU分配和调度的基本单元。</li>
<li>一个进程可以有多个线程，但是一个线程只能属于一个进程。</li>
<li>进程的创建需要系统分配内存和CPU，文件句柄等资源，销毁时也要进行相应的回收，所以进程的管理开销很大；但是线程的管理开销则很小。</li>
<li>进程之间不会相互影响；而一个线程崩溃会导致进程崩溃，从而影响同个进程里面的其他线程。</li>
</ol>
<ul>
<li>联系 进程与线程之间的关系：线程是存在进程的内部，一个进程中可以有多个线程，一个线程只能存在一个进程中。<h4 id="（2）-Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关"><a href="#（2）-Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关" class="headerlink" title="（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关"></a>（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关</h4>答：32768. 因为进程的pid是用pid_t来表示的，pid_t的最大值是32768.所以理论上最多有32768个进程。</li>
</ul>
<p>至于线程。进程最多可以创建的线程数是根据分配给调用栈的大小，以及操作系统（32位和64位不同）共同决定的。Linux32位下是300多个。</p>
<h4 id="（3）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"><a href="#（3）-冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）" class="headerlink" title="（3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）"></a>（3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</h4><ul>
<li>存储器：内存</li>
<li>控制器：南桥北桥</li>
<li>运算器：CPU</li>
<li>输入设备：键盘</li>
<li><p>输出设备：显示器、网卡</p>
<h4 id="（4）-进程之间的通信方法有哪几种-（重点）"><a href="#（4）-进程之间的通信方法有哪几种-（重点）" class="headerlink" title="（4） 进程之间的通信方法有哪几种 （重点）"></a>（4） 进程之间的通信方法有哪几种 （重点）</h4><p>进程之间的通信方式主要有六种，包括<strong>管道，信号量，消息队列，信号，共享内存，套接字</strong>。</p>
</li>
<li><p>管道：管道是半双工的，双方需要通信的时候，需要建立两个管道。管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。管道是最容易实现的<br><img src="fig/管道通信.png" alt="fig/管道通信.png"></p>
<p>匿名管道pipe和命名管道除了建立，打开，删除的方式不同外，其余都是一样的。匿名管道只允许有亲缘关系的进程之间通信，也就是父子进程之间的通信，命名管道允许具有非亲缘关系的进程间通信。</p>
<p>管道的底层实现 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009528245">https://segmentfault.com/a/1190000009528245</a></p>
</li>
<li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。信号量只有等待和发送两种操作。等待(P(sv))就是将其值减一或者挂起进程，发送(V(sv))就是将其值加一或者将进程恢复运行。</p>
</li>
<li><p>信号：信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 信号是开销最小的</p>
</li>
<li><p>共享内存：共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，就像由malloc()分配的内存一样使用。一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。共享内存的效率最高，缺点是没有提供同步机制，需要使用锁等其他机制进行同步。</p>
</li>
<li><p>消息队列：消息队列就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。<br>消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。<br>可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。</p>
</li>
<li><p>套接字：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p>
<h4 id="（5）-进程调度方法详细介绍"><a href="#（5）-进程调度方法详细介绍" class="headerlink" title="（5） 进程调度方法详细介绍"></a>（5） 进程调度方法详细介绍</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011080472/article/details/51217754">https://blog.csdn.net/u011080472/article/details/51217754</a></p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/leex_brave/article/details/51638300">https://blog.csdn.net/leex_brave/article/details/51638300</a></p>
<ul>
<li>先来先服务 （FCFS first come first serve）：按照作业到达任务队列的顺序调度  FCFS是非抢占式的，易于实现，效率不高，性能不好，有利于长作业（CPU繁忙性）而不利于短作业（I/O繁忙性）。</li>
<li>短作业优先 （SHF short job first）：每次从队列里选择预计时间最短的作业运行。SJF是非抢占式的，优先照顾短作业，具有很好的性能，降低平均等待时间，提高吞吐量。但是不利于长作业，长作业可能一直处于等待状态，出现饥饿现象；完全未考虑作业的优先紧迫程度，不能用于实时系统。</li>
<li>最短剩余时间优先 该算法首先按照作业的服务时间挑选最短的作业运行，在该作业运行期间，一旦有新作业到达系统，并且该新作业的服务时间比当前运行作业的剩余服务时间短，则发生抢占；否则，当前作业继续运行。该算法确保一旦新的短作业或短进程进入系统，能够很快得到处理。</li>
<li>高响应比优先调度算法（Highest Reponse Ratio First, HRRF）是非抢占式的，主要用于作业调度。基本思想：每次进行作业调度时，先计算后备作业队列中每个作业的响应比，挑选最高的作业投入系统运行。响应比 = （等待时间 + 服务时间） / 服务时间 = 等待时间 / 服务时间 + 1。因为每次都需要计算响应比，所以比较耗费系统资源。</li>
<li>时间片轮转 用于分时系统的进程调度。基本思想：系统将CPU处理时间划分为若干个时间片（q），进程按照到达先后顺序排列。每次调度选择队首的进程，执行完1个时间片q后，计时器发出时钟中断请求，该进程移至队尾。以后每次调度都是如此。该算法能在给定的时间内响应所有用户的而请求，达到分时系统的目的。</li>
<li>多级反馈队列(Multilevel Feedback Queue) <h4 id="（6）-进程的执行过程是什么样的，执行一个进程需要做哪些工作？"><a href="#（6）-进程的执行过程是什么样的，执行一个进程需要做哪些工作？" class="headerlink" title="（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？"></a>（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？</h4>进程的执行需要经过三大步骤：编译，链接和装入。</li>
<li>编译：将源代码编译成若干模块</li>
<li>链接：将编译后的模块和所需要的库函数进行链接。链接包括三种形式：静态链接，装入时动态链接（将编译后的模块在链接时一边链接一边装入），运行时动态链接（在执行时才把需要的模块进行链接）</li>
<li>装入：将模块装入内存运行</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38623623/article/details/78306498">https://blog.csdn.net/qq_38623623/article/details/78306498</a></p>
<p>将进程装入内存时，通常使用分页技术，将内存分成固定大小的页，进程分为固定大小的块，加载时将进程的块装入页中，并使用页表记录。减少外部碎片。</p>
<p>通常操作系统还会使用虚拟内存的技术将磁盘作为内存的扩充。</p>
<h4 id="（6）-操作系统的内存管理说一下"><a href="#（6）-操作系统的内存管理说一下" class="headerlink" title="（6） 操作系统的内存管理说一下"></a>（6） 操作系统的内存管理说一下</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peterYong/p/6556619.html">https://www.cnblogs.com/peterYong/p/6556619.html</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/141602175">https://zhuanlan.zhihu.com/p/141602175</a></p>
<p>操作系统的内存管理包括物理内存管理和虚拟内存管理</p>
<ul>
<li>物理内存管理包括交换与覆盖，分页管理，分段管理和段页式管理等；</li>
<li>虚拟内存管理包括虚拟内存的概念，页面置换算法，页面分配策略等；</li>
</ul>
<p>（面试官这样问的时候，其实是希望你能讲讲虚拟内存）</p>
<h4 id="（7）-实现一个LRU算法"><a href="#（7）-实现一个LRU算法" class="headerlink" title="（7） 实现一个LRU算法"></a>（7） 实现一个LRU算法</h4><p>用到两个数据结构：哈希+双向链表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; &gt; cache ;<span class="comment">// 存放键，迭代器</span></span><br><span class="line">list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; auxlist; <span class="comment">// 存放 &lt;键，值&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; l;<span class="comment">// front:new back:old 存放值 新的放前面，因为前面的可以取得有效的迭代器</span></span><br><span class="line">    map&lt;<span class="type">int</span>,list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;::iterator &gt; cache;<span class="comment">// 存放键，迭代器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        cap=capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> mapitera = cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(mapitera==cache.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// found</span></span><br><span class="line">            list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;::iterator listItera = mapitera-&gt;second;</span><br><span class="line">            <span class="type">int</span> value = (*listItera).second;</span><br><span class="line"></span><br><span class="line">            l.<span class="built_in">erase</span>(listItera);</span><br><span class="line">            l.<span class="built_in">push_front</span>(&#123;key,value&#125;);</span><br><span class="line">            cache[key]=l.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> itera = cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(itera!=cache.<span class="built_in">end</span>())&#123;<span class="comment">// exist</span></span><br><span class="line">            list&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;::iterator listItera = itera-&gt;second;</span><br><span class="line"></span><br><span class="line">            l.<span class="built_in">erase</span>(listItera);</span><br><span class="line">            l.<span class="built_in">push_front</span>(&#123;key,value&#125;);</span><br><span class="line">            cache[key]=l.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// not exist</span></span><br><span class="line">            <span class="keyword">if</span>(cache.<span class="built_in">size</span>()&gt;=cap)&#123;</span><br><span class="line">                pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; oldpair = l.<span class="built_in">back</span>();</span><br><span class="line">                l.<span class="built_in">pop_back</span>();</span><br><span class="line">                cache.<span class="built_in">erase</span>(oldpair.first);</span><br><span class="line">            &#125;</span><br><span class="line">            l.<span class="built_in">push_front</span>(&#123;key,value&#125;);</span><br><span class="line">            cache[key]=l.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="（8）-死锁产生的必要条件（怎么检测死锁，解决死锁问题）"><a href="#（8）-死锁产生的必要条件（怎么检测死锁，解决死锁问题）" class="headerlink" title="（8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）"></a>（8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）</h4><p>（1） 互斥：一个资源每次只能被一个进程使用。<br><br>（2） 占有并请求：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br><br>（3） 不可剥夺:进程已获得的资源，在末使用完之前，不能强行剥夺。<br><br>（4） 循环等待:若干进程之间形成一种头尾相接的循环等待资源关系。<br></p>
<p>产生死锁的原因主要是：<br><br>（1） 因为系统资源不足。<br><br>（2） 进程运行推进的顺序不合适。<br><br>（3） 资源分配不当等。<br></p>
<h4 id="（8）-死锁的恢复"><a href="#（8）-死锁的恢复" class="headerlink" title="（8） 死锁的恢复"></a>（8） 死锁的恢复</h4><ol>
<li>重新启动：是最简单、最常用的死锁消除方法，但代价很大，因为在此之前所有进程已经完成的计算工作都将付之东流，不仅包括死锁的全部进程，也包括未参与死锁的全部进程。</li>
<li>终止进程(process termination)：终止参与死锁的进程并回收它们所占资源。<br> (1) 一次性全部终止；(2) 逐步终止(优先级，代价函数)</li>
<li>剥夺资源(resource preemption):剥夺死锁进程所占有的全部或者部分资源。<br> (1) 逐步剥夺：一次剥夺死锁进程所占有的一个或一组资源，如果死锁尚未解除再继续剥夺，直至死锁解除为止。<br> (2) 一次剥夺：一次性地剥夺死锁进程所占有的全部资源。</li>
<li>进程回退(rollback):让参与死锁的进程回退到以前没有发生死锁的某个点处，并由此点开始继续执行，希望进程交叉执行时不再发生死锁。但是系统开销很大：<br> (1) 要实现“回退”，必须“记住”以前某一点处的现场，而现场随着进程推进而动态变化，需要花费大量时间和空间。<br> (2) 一个回退的进程应当“挽回”它在回退点之间所造成的影响，如修改某一文件，给其它进程发送消息等，这些在实现时是难以做到的</li>
</ol>
<h4 id="（8）什么是饥饿"><a href="#（8）什么是饥饿" class="headerlink" title="（8）什么是饥饿"></a>（8）什么是饥饿</h4><p>饥饿是由于资源分配策略不公引起的，当进程或线程无法访问它所需要的资源而不能继续执行时，就会发生饥饿现象。</p>
<h4 id="（9）-如果要你实现一个mutex互斥锁你要怎么实现？"><a href="#（9）-如果要你实现一个mutex互斥锁你要怎么实现？" class="headerlink" title="（9） 如果要你实现一个mutex互斥锁你要怎么实现？"></a>（9） 如果要你实现一个mutex互斥锁你要怎么实现？</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kid551/article/details/84338619">https://blog.csdn.net/kid551/article/details/84338619</a></p>
<p>实现mutex最重要的就是实现它的lock()方法和unlock()方法。我们保存一个全局变量flag，flag=1表明该锁已经锁住，flag=0表明锁没有锁住。<br>实现lock()时，使用一个while循环不断检测flag是否等于1，如果等于1就一直循环。然后将flag设置为1；unlock()方法就将flag置为0；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(&amp;flag,<span class="number">1</span>)==<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//flag=1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">  flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为while有可能被重入，所以可以用TestandSet()方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> old = *ptr;</span><br><span class="line">    *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="（10）线程之间的通信方式有哪些？-进程之间的同步方式又哪些？"><a href="#（10）线程之间的通信方式有哪些？-进程之间的同步方式又哪些？" class="headerlink" title="（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？"></a>（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？</h4><p>线程之间通信：</p>
<ul>
<li>使用全局变量</li>
<li>使用信号机制</li>
<li>使用事件</li>
</ul>
<p>进程之间同步：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html">https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html</a></p>
<ul>
<li>信号量</li>
<li><p>管程</p>
<h4 id="（13）-什么时候用多进程，什么时候用多线程"><a href="#（13）-什么时候用多进程，什么时候用多线程" class="headerlink" title="（13） 什么时候用多进程，什么时候用多线程"></a>（13） 什么时候用多进程，什么时候用多线程</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yu876876/article/details/82810178">https://blog.csdn.net/yu876876/article/details/82810178</a></p>
</li>
<li><p>频繁修改：需要频繁创建和销毁的优先使用<strong>多线程</strong></p>
</li>
<li>计算量：需要大量计算的优先使用<strong>多线程</strong>  因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</li>
<li>相关性：任务间相关性比较强的用<strong>多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。</li>
<li>多分布：可能要扩展到多机分布的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong>。</li>
</ul>
<p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。</p>
<h4 id="（14）-文件读写使用的系统调用"><a href="#（14）-文件读写使用的系统调用" class="headerlink" title="（14） 文件读写使用的系统调用"></a>（14） 文件读写使用的系统调用</h4><h4 id="（15）-孤儿进程和僵尸进程分别是什么，怎么形成的？"><a href="#（15）-孤儿进程和僵尸进程分别是什么，怎么形成的？" class="headerlink" title="（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？"></a>（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/3271773.html">https://www.cnblogs.com/Anker/p/3271773.html</a></p>
<ul>
<li>孤儿进程是父进程退出后它的子进程还在执行，这时候这些子进程就成为孤儿进程。孤儿进程会被init进程收养并完成状态收集。</li>
<li>僵尸进程是指子进程完成并退出后父进程没有使用wait()或者waitpid()对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就成为僵尸进程。<h4 id="（16）-说一下PCB-说一下进程地址空间"><a href="#（16）-说一下PCB-说一下进程地址空间" class="headerlink" title="（16） 说一下PCB/说一下进程地址空间/"></a>（16） 说一下PCB/说一下进程地址空间/</h4><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38499859/article/details/80057427">https://blog.csdn.net/qq_38499859/article/details/80057427</a></li>
</ul>
<p>PCB就是进程控制块，是操作系统中的一种数据结构，用于表示进程状态，操作系统通过PCB对进程进行管理。</p>
<p>PCB中包含有：进程标识符，处理器状态，进程调度信息，进程控制信息</p>
<p><img src="https://img-blog.csdn.net/20140904215636015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd6aGVianV0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>进程地址空间内有：</p>
<ul>
<li>代码段text：存放程序的二进制代码</li>
<li>初始化的数据Data：已经初始化的变量和数据</li>
<li>未初始化的数据BSS：还没有初始化的数据</li>
<li>栈</li>
<li>堆<h4 id="（17）-内核空间和用户空间是怎样区分的"><a href="#（17）-内核空间和用户空间是怎样区分的" class="headerlink" title="（17） 内核空间和用户空间是怎样区分的"></a>（17） 内核空间和用户空间是怎样区分的</h4>在Linux中虚拟地址空间范围为0到4G，最高的1G地址（0xC0000000到0xFFFFFFFF）供内核使用，称为内核空间，低的3G空间（0x00000000到0xBFFFFFFF）供各个进程使用，就是用户空间。</li>
</ul>
<p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。</p>
<h4 id="（18）-多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"><a href="#（18）-多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）" class="headerlink" title="（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）"></a>（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/s_lisheng/article/details/74278765">https://blog.csdn.net/s_lisheng/article/details/74278765</a></p>
<ul>
<li>临界区</li>
<li>信号量</li>
<li>事件</li>
<li>互斥量<h4 id="（19）-同一个进程内的线程会共享什么资源？"><a href="#（19）-同一个进程内的线程会共享什么资源？" class="headerlink" title="（19） 同一个进程内的线程会共享什么资源？"></a>（19） 同一个进程内的线程会共享什么资源？</h4></li>
<li>该进程的地址空间</li>
<li>全局变量</li>
<li>堆空间</li>
</ul>
<p>线程的栈空间是自己独有的</p>
<h4 id="（20）-异常和中断的区别"><a href="#（20）-异常和中断的区别" class="headerlink" title="（20） 异常和中断的区别"></a>（20） 异常和中断的区别</h4><h4 id="（21）-一般情况下在Linux-windows平台下栈空间的大小"><a href="#（21）-一般情况下在Linux-windows平台下栈空间的大小" class="headerlink" title="（21） 一般情况下在Linux/windows平台下栈空间的大小"></a>（21） 一般情况下在Linux/windows平台下栈空间的大小</h4><p>在Linux下栈空间通常是8M，Windows下是1M</p>
<h4 id="（22）虚拟内存的了解"><a href="#（22）虚拟内存的了解" class="headerlink" title="（22）虚拟内存的了解"></a>（22）虚拟内存的了解</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Przz/p/6876988.html">https://www.cnblogs.com/Przz/p/6876988.html</a></p>
<p>在运行一个进程的时候，它所需要的内存空间可能大于系统的物理内存容量。通常一个进程会有4G的空间，但是物理内存并没有这么大，所以这些空间都是虚拟内存，它的地址都是逻辑地址，每次在访问的时候都需要映射成物理地址。<br>当进程访问某个逻辑地址的时候，会去查看页表，如果页表中没有相应的物理地址，说明内存中没有这页的数据，发生缺页异常，这时候进程需要把数据从磁盘拷贝到物理内存中。如果物理内存已经满了，就需要覆盖已有的页，如果这个页曾经被修改过，那么还要把它写回磁盘。</p>
<h4 id="（23）服务器高并发的解决方案"><a href="#（23）服务器高并发的解决方案" class="headerlink" title="（23）服务器高并发的解决方案"></a>（23）服务器高并发的解决方案</h4><ol>
<li><p>应用数据与静态资源分离<br>将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</p>
</li>
<li><p>客户端缓存<br>因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</p>
</li>
<li><p>集群和分布式<br>（集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）<br><br>（分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）<br><br>可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</p>
</li>
<li><p>反向代理<br>在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</p>
<h4 id="（24）协程了解吗（高频）"><a href="#（24）协程了解吗（高频）" class="headerlink" title="（24）协程了解吗（高频）"></a>（24）协程了解吗（高频）</h4><p>协程和微线程是一个东西。</p>
</li>
</ol>
<p>协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。<br>这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。</p>
<h4 id="（25）那协程的底层是怎么实现的，怎么使用协程？"><a href="#（25）那协程的底层是怎么实现的，怎么使用协程？" class="headerlink" title="（25）那协程的底层是怎么实现的，怎么使用协程？"></a>（25）那协程的底层是怎么实现的，怎么使用协程？</h4><p>协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。</p>
<h4 id="（23）进程的状态以及转换图"><a href="#（23）进程的状态以及转换图" class="headerlink" title="（23）进程的状态以及转换图"></a>（23）进程的状态以及转换图</h4><ul>
<li>三态模型<br>三态模型包括三种状态：<ol>
<li>执行：进程分到CPU时间片，可以执行</li>
<li>就绪：进程已经就绪，只要分配到CPU时间片，随时可以执行</li>
<li>阻塞：有IO事件或者等待其他资源<br><img src="fig/三态模型.png" alt=""></li>
</ol>
</li>
<li><p>五态模型</p>
<ol>
<li>新建态：进程刚刚创建。</li>
<li>就绪态：</li>
<li>运行态：</li>
<li>等待态：出现等待事件</li>
<li>终止态：进程结束<br><img src="fig/五态模型.png" alt=""></li>
</ol>
</li>
<li><p>七态模型</p>
<ol>
<li>新建态</li>
<li>就绪挂起态</li>
<li>就绪态</li>
<li>运行态</li>
<li>等待态</li>
<li>挂起等待态</li>
<li>终止态<br><img src="fig/七态模型.png" alt=""></li>
</ol>
</li>
</ul>
<h4 id="（24）在执行malloc申请内存的时候，操作系统是怎么做的？-内存分配的原理说一下-malloc函数底层是怎么实现的？-进程是怎么分配内存的？"><a href="#（24）在执行malloc申请内存的时候，操作系统是怎么做的？-内存分配的原理说一下-malloc函数底层是怎么实现的？-进程是怎么分配内存的？" class="headerlink" title="（24）在执行malloc申请内存的时候，操作系统是怎么做的？/内存分配的原理说一下/malloc函数底层是怎么实现的？/进程是怎么分配内存的？"></a>（24）在执行malloc申请内存的时候，操作系统是怎么做的？/内存分配的原理说一下/malloc函数底层是怎么实现的？/进程是怎么分配内存的？</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yusiguyuan/article/details/39496057">https://blog.csdn.net/yusiguyuan/article/details/39496057</a></p>
<p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap</p>
<ul>
<li>brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小</li>
<li>mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</li>
</ul>
<p>通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。</p>
<p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</p>
<h4 id="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"><a href="#（25）什么是字节序？怎么判断是大端还是小端？有什么用？" class="headerlink" title="（25）什么是字节序？怎么判断是大端还是小端？有什么用？"></a>（25）什么是字节序？怎么判断是大端还是小端？有什么用？</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/broglie/p/5645200.html">https://www.cnblogs.com/broglie/p/5645200.html</a></p>
<p>字节序是对象在内存中存储的方式，大端即为最高有效位在前面，小端即为最低有效位在前面。<br>判断大小端的方法：使用一个union数据结构<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">  <span class="type">short</span> s;</span><br><span class="line">  <span class="type">char</span> c[<span class="number">2</span>]; <span class="comment">// sizeof(short)=2;</span></span><br><span class="line">&#125;un;</span><br><span class="line">un.s=<span class="number">0x0102</span>;</span><br><span class="line"><span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">1</span> <span class="keyword">and</span> un.c[<span class="number">1</span>]==<span class="number">2</span>) cout&lt;&lt;<span class="string">&quot;大端&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(un.c[<span class="number">0</span>]==<span class="number">2</span> <span class="keyword">and</span> un.c[<span class="number">1</span>]==<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;小端&quot;</span>;</span><br></pre></td></tr></table></figure><br>在网络编程中不同字节序的机器发送和接收的顺序不同。</p>
<h1 id="6-场景题-算法题"><a href="#6-场景题-算法题" class="headerlink" title="6. 场景题/算法题"></a>6. 场景题/算法题</h1><h4 id="（0）-leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！"><a href="#（0）-leetcode-hot100至少刷两遍，剑指offer至少刷两遍-重中之重！！" class="headerlink" title="（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！"></a>（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！</h4><p>面试中90%的算法题都从leetcode hot100和剑指offer中出 刷两遍非常有必要</p>
<h4 id="（1）-介绍熟悉的设计模式（单例，简单工厂模式）"><a href="#（1）-介绍熟悉的设计模式（单例，简单工厂模式）" class="headerlink" title="（1） 介绍熟悉的设计模式（单例，简单工厂模式）"></a>（1） 介绍熟悉的设计模式（单例，简单工厂模式）</h4><h4 id="（2）-写单例模式，线程安全版本"><a href="#（2）-写单例模式，线程安全版本" class="headerlink" title="（2） 写单例模式，线程安全版本"></a>（2） 写单例模式，线程安全版本</h4><figure class="highlight c++"><figcaption><span>version</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;</span><br><span class="line">      <span class="comment">// initialize</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance==<span class="literal">nullptr</span>) instance=<span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="（3）-写三个线程交替打印ABC"><a href="#（3）-写三个线程交替打印ABC" class="headerlink" title="（3） 写三个线程交替打印ABC"></a>（3） 写三个线程交替打印ABC</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mymutex;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count&lt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">0</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 1: a&quot;</span>&lt;&lt;endl;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;my thread 1 finish&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printb</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">1</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 2: b&quot;</span>&lt;&lt;endl;</span><br><span class="line">        flag=<span class="number">2</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;my thread 2 finish&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">2</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 3: c&quot;</span>&lt;&lt;endl;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;my thread 3 finish&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(printa)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th1</span><span class="params">(printb)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th3</span><span class="params">(printc)</span></span>;</span><br><span class="line"></span><br><span class="line">    th1.<span class="built_in">join</span>();</span><br><span class="line">    th2.<span class="built_in">join</span>();</span><br><span class="line">    th3.<span class="built_in">join</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; main thread &quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（4）-二维码登录的实现过程-场景题"><a href="#（4）-二维码登录的实现过程-场景题" class="headerlink" title="（4） 二维码登录的实现过程 场景题"></a>（4） 二维码登录的实现过程 场景题</h4><p><img src="fig/二维码登录流程.png" alt=""></p>
<h4 id="（5）-不使用临时变量实现swap函数"><a href="#（5）-不使用临时变量实现swap函数" class="headerlink" title="（5） 不使用临时变量实现swap函数"></a>（5） 不使用临时变量实现swap函数</h4><ul>
<li>使用异或/加减等方式，下面给出使用异或的实现方法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line">  a=a^b;</span><br><span class="line">  b=a^b;</span><br><span class="line">  a=a^b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（6）-实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"><a href="#（6）-实现一个strcpy函数（或者memcpy），如果内存可能重叠呢" class="headerlink" title="（6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢"></a>（6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢</h4><h4 id="（7）-实现快排"><a href="#（7）-实现快排" class="headerlink" title="（7） 实现快排"></a>（7） 实现快排</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec,<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    vec[a]=vec[a]^vec[b];</span><br><span class="line">    vec[b]=vec[a]^vec[b];</span><br><span class="line">    vec[a]=vec[a]^vec[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot=vec[start+(end-start)/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end <span class="keyword">and</span> vec[start]&lt;pivot) start++;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end <span class="keyword">and</span> vec[end]&gt;pivot) end--;</span><br><span class="line">        <span class="keyword">if</span>(start&lt;end) <span class="built_in">swap</span>(vec,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pivot=<span class="built_in">partition</span>(vec,start,end);</span><br><span class="line">    <span class="built_in">quickSort</span>(vec,start,pivot<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(vec,pivot+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（8）-实现一个堆排序"><a href="#（8）-实现一个堆排序" class="headerlink" title="（8） 实现一个堆排序"></a>（8） 实现一个堆排序</h4>堆排序的基本过程：</li>
<li>将n个元素的序列构建一个大顶堆或小顶堆</li>
<li>将堆顶的元素放到序列末尾</li>
<li>将前n-1个元素重新构建大顶堆或小顶堆，重复这个过程，直到所有元素都已经排序</li>
</ul>
<p>整体时间复杂度为nlogn<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    arr[a]=arr[a]^arr[b];</span><br><span class="line">    arr[b]=arr[a]^arr[b];</span><br><span class="line">    arr[a]=arr[a]^arr[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr,<span class="type">int</span> len,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxid=index;</span><br><span class="line">    <span class="comment">// 计算左右子节点的下标   left=2*i+1  right=2*i+2  parent=(i-1)/2</span></span><br><span class="line">    <span class="type">int</span> left=<span class="number">2</span>*index+<span class="number">1</span>,right=<span class="number">2</span>*index+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找当前以index为根的子树中最大/最小的元素的下标</span></span><br><span class="line">    <span class="keyword">if</span>(left&lt;len <span class="keyword">and</span> arr[left]&lt;arr[maxid]) maxid=left;</span><br><span class="line">    <span class="keyword">if</span>(right&lt;len <span class="keyword">and</span> arr[right]&lt;arr[maxid]) maxid=right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行交换，记得要递归进行adjust,传入的index是maxid</span></span><br><span class="line">    <span class="keyword">if</span>(maxid!=index)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr,maxid,index);</span><br><span class="line">        <span class="built_in">adjust</span>(arr,len,maxid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;arr,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初次构建堆，i要从最后一个非叶子节点开始，所以是(len-1-1)/2，0这个位置要加等号</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(len<span class="number">-1</span><span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">adjust</span>(arr,len,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最后一个元素的下标开始往前遍历，每次将堆顶元素交换至当前位置，并且缩小长度（i为长度），从0处开始adjust</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr,<span class="number">0</span>,i);</span><br><span class="line">        <span class="built_in">adjust</span>(arr,i,<span class="number">0</span>);<span class="comment">// 注意每次adjust是从根往下调整，所以这里index是0！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr=&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;before: &quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> item:arr) cout&lt;&lt;item&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">heapsort</span>(arr,arr.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;after: &quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> item:arr)cout&lt;&lt;item&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="（8）-实现一个插入排序"><a href="#（8）-实现一个插入排序" class="headerlink" title="（8） 实现一个插入排序"></a>（8） 实现一个插入排序</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/left_la/article/details/8656425">https://blog.csdn.net/left_la/article/details/8656425</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> len=nums.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="type">int</span> key=nums[i];</span><br><span class="line">    <span class="type">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[j]&gt;key)&#123;</span><br><span class="line">      nums[j+<span class="number">1</span>]=nums[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j+<span class="number">1</span>]=key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（9）-快排存在的问题，如何优化"><a href="#（9）-快排存在的问题，如何优化" class="headerlink" title="（9） 快排存在的问题，如何优化"></a>（9） 快排存在的问题，如何优化</h4><ul>
<li>3 种快排基准选择方法：</li>
</ul>
<p>随机（rand函数）、固定（队首、队尾）、三数取中（队首、队中和队尾的中间数）</p>
<ul>
<li>4种优化方式：</li>
</ul>
<p>优化1：当待排序序列的长度分割到一定大小后，使用插入排序</p>
<p>优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割</p>
<p>优化3：优化递归操作</p>
<p>优化4：使用并行或多线程处理子序列</p>
<h4 id="（10）-反转一个链表（招银网络二面）"><a href="#（10）-反转一个链表（招银网络二面）" class="headerlink" title="（10） 反转一个链表（招银网络二面）"></a>（10） 反转一个链表（招银网络二面）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* root)</span></span>&#123;</span><br><span class="line">  ListNode* pre=<span class="literal">nullptr</span>,cur=root,nxt;</span><br><span class="line">  <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    nxt=cur-&gt;next;</span><br><span class="line">    cur-&gt;next=pre;</span><br><span class="line">    pre=cur;cur=nxt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（11）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）"><a href="#（11）-Top-K问题（可以采取的方法有哪些，各自优点？）（重点）" class="headerlink" title="（11） Top K问题（可以采取的方法有哪些，各自优点？）（重点）"></a>（11） Top K问题（可以采取的方法有哪些，各自优点？）（重点）</h4><p><em>Top K 问题的常见形式：</em></p>
<blockquote>
<p>给定10000个整数，找第K大（第K小）的数<br><br> 给定10000个整数，找出最大（最小）的前K个数<br><br>给定100000个单词，求前K词频的单词<br></p>
</blockquote>
<p><em>解决Top K问题若干种方法</em></p>
<ul>
<li>使用最大最小堆。求最大的数用最小堆，求最小的数用最大堆。</li>
<li>Quick Select算法。使用类似快排的思路，根据pivot划分数组。</li>
<li>使用排序方法，排序后再寻找top K元素。</li>
<li>使用选择排序的思想，对前K个元素部分排序。</li>
<li>将1000…..个数分成m组，每组寻找top K个数，得到m×K个数，在这m×k个数里面找top K个数。</li>
</ul>
<ol>
<li>使用最大最小堆的思路 （以top K 最大元素为例）<br><br>按顺序扫描这10000个数，先取出K个元素构建一个大小为K的最小堆。每扫描到一个元素，如果这个元素大于堆顶的元素（这个堆最小的一个数），就放入堆中，并删除堆顶的元素，同时整理堆。如果这个元素小于堆顶的元素，就直接pass。最后堆中剩下的元素就是最大的前Top K个元素，最右的叶节点就是Top 第K大的元素。</li>
</ol>
<blockquote>
<p>note：最小堆的插入时间复杂度为log(n)，n为堆中元素个数，在这里是K。最小堆的初始化时间复杂度是nlog(n)</p>
</blockquote>
<p>C++中的最大最小堆要用标准库的priority_queue来实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">int</span> v, <span class="type">int</span> i): <span class="built_in">value</span>(v), <span class="built_in">idx</span>(i) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="keyword">struct</span> Node &amp;n1, <span class="type">const</span> <span class="keyword">struct</span> Node &amp;n2) ; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> <span class="keyword">struct</span> Node &amp;n1, <span class="type">const</span> <span class="keyword">struct</span> Node &amp;n2) &#123;</span><br><span class="line">    <span class="keyword">return</span> n1.value &lt; n2.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; pq; <span class="comment">// 此时pq为最大堆</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>使用Quick Select的思路（以寻找第K大的元素为例）<br><br>Quick Select脱胎于快速排序，提出这两个算法的都是同一个人。算法的过程是这样的：<br>首先选取一个枢轴，然后将数组中小于该枢轴的数放到左边，大于该枢轴的数放到右边。<br>此时，如果左边的数组中的元素个数大于等于K，则第K大的数肯定在左边数组中，继续对左边数组执行相同操作；<br>如果左边的数组元素个数等于K-1，则第K大的数就是pivot；<br>如果左边的数组元素个数小于K，则第K大的数肯定在右边数组中，对右边数组执行相同操作。</li>
</ol>
<p>这个算法与快排最大的区别是，每次划分后只处理左半边或者右半边，而快排在划分后对左右半边都继续排序。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//此为Java实现</span><br><span class="line">public int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">  return quickSelect(nums, k, 0, nums.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// quick select to find the kth-largest element</span><br><span class="line">public int quickSelect(int[] arr, int k, int left, int right) &#123;</span><br><span class="line">  if (left == right) return arr[right];</span><br><span class="line">  int index = partition(arr, left, right);</span><br><span class="line">  if (index - left + 1 &gt; k)</span><br><span class="line">    return quickSelect(arr, k, left, index - 1);</span><br><span class="line">  else if (index - left + 1 == k)</span><br><span class="line">    return arr[index];</span><br><span class="line">  else</span><br><span class="line">    return quickSelect(arr, k - (index - left + 1), index + 1, right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>使用选择排序的思想对前K个元素排序 （ 以寻找前K大个元素为例）<br><br>扫描一遍数组，选出最大的一个元素，然后再扫描一遍数组，找出第二大的元素，再扫描一遍数组，找出第三大的元素。。。。。以此类推，找K个元素，时间复杂度为O(N*K)<h4 id="（12）-8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"><a href="#（12）-8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）" class="headerlink" title="（12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）"></a>（12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）</h4>我们可以使用外部排序来对它进行处理。首先将整个文件分成许多份，比如说m份，划分的依据就是使得每一份的大小都能放到内存里。然后我们用快速排序或者堆排序等方法对每一份数据进行一个内部排序，变成有序子串。接着对这m份有序子串进行m路归并排序。取这m份数据的最小元素，进行排序，输出排序后最小的元素到结果中，同时从该元素所在子串中读入一个元素，直到所有数据都被输出到结果中为止。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ailunlee/article/details/84548950">https://blog.csdn.net/ailunlee/article/details/84548950</a></p>
<h4 id="（13）-自己构建一棵二叉树，使用带有null标记的前序遍历序列"><a href="#（13）-自己构建一棵二叉树，使用带有null标记的前序遍历序列" class="headerlink" title="（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列"></a>（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列</h4><p>在写二叉树相关算法的时候，如果需要自己构造测试用例（自己构造一棵二叉树），往往是一件很麻烦的事情，我们可以用一个带有null标记的前序遍历序列来进行构造。 <strong>需要注意的是vec2tree()参数中的start是引用传递，而不是简单的参数值传递</strong>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">treeNode</span>&#123;</span><br><span class="line">    string val;</span><br><span class="line">    treeNode* left,*right;</span><br><span class="line">    <span class="built_in">treeNode</span>(string val):<span class="built_in">val</span>(val)&#123;</span><br><span class="line">        left=<span class="literal">nullptr</span>;</span><br><span class="line">        right=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">treeNode* <span class="title">vec2tree</span><span class="params">(vector&lt;string&gt;&amp; vec,<span class="type">int</span>&amp; start)</span></span>&#123;</span><br><span class="line">    treeNode* root;</span><br><span class="line">    <span class="keyword">if</span>(vec[start]==<span class="string">&quot;null&quot;</span>)&#123;</span><br><span class="line">        start+=<span class="number">1</span>;</span><br><span class="line">        root=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root=<span class="keyword">new</span> <span class="built_in">treeNode</span>(vec[start]);</span><br><span class="line">        start+=<span class="number">1</span>;</span><br><span class="line">        root-&gt;left=<span class="built_in">vec2tree</span>(vec,start);</span><br><span class="line">        root-&gt;right=<span class="built_in">vec2tree</span>(vec,start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tree2vec</span><span class="params">(treeNode *root,vector&lt;string&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">tree2vec</span>(root-&gt;left,vec);</span><br><span class="line">        <span class="built_in">tree2vec</span>(root-&gt;right,vec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;string&gt; vec=&#123;<span class="string">&quot;2&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;null&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>,&amp;start=index;</span><br><span class="line">    treeNode* root=<span class="built_in">vec2tree</span>(vec,start);</span><br><span class="line">    <span class="comment">//displaytree(root);</span></span><br><span class="line">    vector&lt;string&gt; mvec;</span><br><span class="line">    <span class="built_in">tree2vec</span>(root,mvec);</span><br><span class="line">    <span class="keyword">for</span>(string item:mvec) cout&lt;&lt;item&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="（14）-介绍一下b树和它的应用场景有哪些"><a href="#（14）-介绍一下b树和它的应用场景有哪些" class="headerlink" title="（14） 介绍一下b树和它的应用场景有哪些"></a>（14） 介绍一下b树和它的应用场景有哪些</h4><p>B树也叫做B-树，或者平衡多路树，它是每个节点最多有m个子树的<strong>平衡树</strong>。一个m阶的B树具有如下几个特征：</p>
<ol>
<li>根结点至少有两个子女。</li>
<li>每个中间节点都包含至多m个子树 ， 每个节点包含的元素个数是其子树个数-1（其中 m/2 &lt;= k &lt;= m）</li>
<li>所有的叶子结点都位于同一层。</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个子树包含的元素的值域分划。</li>
</ol>
<p>b树主要应用于文件系统中，在数据库中（mongoDB）也有应用，与B+树相比好处应该是有时不需要访问到叶节点就可以获取数据。</p>
<p>查询时间复杂度是logN</p>
<h4 id="（15）-介绍一下b-树和它的应用场景有哪些"><a href="#（15）-介绍一下b-树和它的应用场景有哪些" class="headerlink" title="（15） 介绍一下b+树和它的应用场景有哪些"></a>（15） 介绍一下b+树和它的应用场景有哪些</h4><p>B+树是一种特殊的B树，它把数据都存储在叶子节点，并且叶节点间有指针连接。内部只存关键字（其中叶子节点的最小值作为索引）和孩子指针，简化了内部节点。</p>
<p>应用场景主要是数据库的索引</p>
<p>查询时间复杂度也是logN<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/110202102">https://zhuanlan.zhihu.com/p/110202102</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hguisu/article/details/7786014">https://blog.csdn.net/hguisu/article/details/7786014</a></p>
<h4 id="（16）-介绍一下红黑树和它的应用场景有哪些"><a href="#（16）-介绍一下红黑树和它的应用场景有哪些" class="headerlink" title="（16） 介绍一下红黑树和它的应用场景有哪些"></a>（16） 介绍一下红黑树和它的应用场景有哪些</h4><p>红黑树是一种特殊的二叉查找树，它在每一个节点上都使用红色或黑色进行标记，通过一些性质确保它是始终平衡的。<br>它的性质是这样的：</p>
<ol>
<li>每个节点不是红色就是黑色。</li>
<li>根节点是黑色的。</li>
<li>叶节点的空节点是黑色的。</li>
<li>如果一个节点是红色的，那么它的两个子节点是黑色的。</li>
<li>对于任意节点，从它到叶节点的每条路径上都有相同数目的黑色节点。</li>
</ol>
<p>红黑树的插入，查询，删除在一般情况和最坏情况下的时间复杂度都是O(log(n))</p>
<p>应用场景主要是STL中map，set的实现，优点在于支持频繁的修改，因为查询删除插入时间复杂度都是logN</p>
<h4 id="（17）-怎么写sql取表的前1000行数据（招银网络二面）"><a href="#（17）-怎么写sql取表的前1000行数据（招银网络二面）" class="headerlink" title="（17） 怎么写sql取表的前1000行数据（招银网络二面）"></a>（17） 怎么写sql取表的前1000行数据（招银网络二面）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> limit <span class="number">1000</span></span><br><span class="line"><span class="keyword">from</span> t1</span><br></pre></td></tr></table></figure>
<h4 id="（18）-N个骰子出现和为m的概率"><a href="#（18）-N个骰子出现和为m的概率" class="headerlink" title="（18） N个骰子出现和为m的概率"></a>（18） N个骰子出现和为m的概率</h4><h4 id="（19）-海量数据问题（可参考左神的书）"><a href="#（19）-海量数据问题（可参考左神的书）" class="headerlink" title="（19） 海量数据问题（可参考左神的书）"></a>（19） 海量数据问题（可参考左神的书）</h4><h4 id="（20）-一致性哈希"><a href="#（20）-一致性哈希" class="headerlink" title="（20） 一致性哈希"></a>（20） 一致性哈希</h4><h4 id="（21）希尔排序说一下-手撕"><a href="#（21）希尔排序说一下-手撕" class="headerlink" title="（21）希尔排序说一下/手撕"></a>（21）希尔排序说一下/手撕</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6104371.html">https://www.cnblogs.com/chengxiao/p/6104371.html</a><br>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h4 id="（22）Dijkstra算法说一下"><a href="#（22）Dijkstra算法说一下" class="headerlink" title="（22）Dijkstra算法说一下"></a>（22）Dijkstra算法说一下</h4><h4 id="（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"><a href="#（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）" class="headerlink" title="（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）"></a>（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）</h4><p>模拟STL中vector的实现即可，去看一下vector的源码。</p>
<h4 id="（24）最小生成树算法说一下"><a href="#（24）最小生成树算法说一下" class="headerlink" title="（24）最小生成树算法说一下"></a>（24）最小生成树算法说一下</h4><h4 id="（25）-海量数据的bitmap使用原理"><a href="#（25）-海量数据的bitmap使用原理" class="headerlink" title="（25） 海量数据的bitmap使用原理"></a>（25） 海量数据的bitmap使用原理</h4><p>bitmap算法就是使用一个比特映射一个值，它可以用在整数排序和数据压缩上，因为使用一个比特位去存储一个数，所以它可以大大节省空间。</p>
<p>它的具体过程是：先根据数组中元素最大的数N计算需要分配多大的空间。<br>如果使用int型数组的形式来保存的话，一个int = 4字节  =4*8比特 = 32比特。也就是一个int数可以映射32个数据（图1），然后需要找到最大的数Max，表示最多需要的位数，所以需要开辟的数组空间为int a[1+Max/32]。<br>然后需要推导一个整数a内如何映射32个数据，方法是将待存储的数据模32，然后将a中相应位置的比特置为1。<br>依此方法映射每一个元素，待读取的时候扫描每个比特位，遇到值为1的就还原该数字。<br><img src="fig/bitmap1.png" alt=""></p>
<p><strong>移位计算公式：</strong><br>N/32就是将N的二进制右移log32（也就是5）位 ： N&gt;&gt;5<br><br>N%32就是求N的后5位：N&amp; 0x1F  (0x1F = 00011111)<br><br>模32然后相应位置置为1： a[i] |= 1&lt;&lt; N &amp; 0x1F<br></p>
<p>所以总的公式为： a[ N&gt;&gt;5 ] |= 1&lt;&lt; N &amp; 0x1F<br></p>
<p><strong>BitMap算法评价</strong></p>
<ul>
<li>优点：<ol>
<li>运算效率高，不进行比较和移位；</li>
<li>占用内存少，比如最大的数MAX=10000000；只需占用内存为MAX/8=1250000Byte=1.25M。</li>
</ol>
</li>
<li>缺点：<ol>
<li>所有的数据不能重复，即不可对重复的数据进行排序。（少量重复数据查找还是可以的，用2-bitmap）。</li>
<li>所需要的空间随着最大元素的增大而增大，当数据类似（1，1000，10万）只有3个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。</li>
</ol>
</li>
</ul>
<h4 id="（26）-布隆过滤器原理与优点"><a href="#（26）-布隆过滤器原理与优点" class="headerlink" title="（26） 布隆过滤器原理与优点"></a>（26） 布隆过滤器原理与优点</h4><p>布隆过滤器是一个比特向量或者比特数组，它本质上是一种概率型数据结构，用来查找一个元素是否在集合中，支持高效插入和查询某条记录。常作为针对超大数据量下高效查找数据的一种方法。</p>
<p><strong>它的具体工作过程是这样子的：</strong><br>假设布隆过滤器的大小为m（比特向量的长度为m），有k个哈希函数，它对每个数据用这k个哈希函数计算哈希，得到k个哈希值，然后将向量中相应的位设为1。在查询某个数据是否存在的时候，对这个数据用k个哈希函数得到k个哈希值，再在比特向量中相应的位查找是否为1，如果某一个相应的位不为1，那这个数据就肯定不存在。但是如果全找到了，则这个数据有可能存在。</p>
<p><strong>为什么说有可能存在呢？</strong><br>因为不同的数据经过哈希后可能有相同的哈希值，在比特向量上某个位置查找到1也可能是由于某个另外的数据映射得到的。</p>
<p><strong>支持删除操作吗</strong><br>目前布隆过滤器只支持插入和查找操作，不支持删除操作，如果要支持删除，就要另外使用一个计数变量，每次将相应的位置为1则计数加一，删除则减一。</p>
<p>布隆过滤器中哈希函数的个数需要选择。如果太多则很快所有位都置为1，如果太少会容易误报。</p>
<p><strong>布隆过滤器的大小以及哈希函数的个数怎么选择？</strong><br>k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率<br><img src="fig/布隆过滤器.png" alt=""></p>
<h4 id="（27）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"><a href="#（27）-布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题" class="headerlink" title="（27） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题"></a>（27） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</h4><h4 id="（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"><a href="#（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）" class="headerlink" title="（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）"></a>（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//评测题目: </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FIFOQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(initCap,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">condition_variable cv;</span><br><span class="line">mutex m;</span><br><span class="line"><span class="type">bool</span> flag=<span class="literal">false</span>;<span class="comment">// isFull</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">enqueue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  	unique_lock&lt;mutex&gt;&lt;/mutex&gt; <span class="built_in">lk</span>(m);</span><br><span class="line">    <span class="keyword">while</span>(flag==<span class="literal">true</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        end=(end+<span class="number">1</span>)%initCap;</span><br><span class="line">        vec[end]=v;</span><br><span class="line">        cv.<span class="built_in">notifyall</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  unique_lock&lt;mutex&gt;&lt;/mutex&gt; <span class="built_in">lk</span>(m);</span><br><span class="line">  	<span class="keyword">if</span>(start!=end)&#123;</span><br><span class="line">    	<span class="type">int</span> val = vec[start];</span><br><span class="line">    	start=(start+<span class="number">1</span>)%initCap;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">    	cv.<span class="built_in">notifyall</span>();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	flag=<span class="literal">false</span>;</span><br><span class="line">    	cv.<span class="built_in">notifyall</span>();</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是面试时写的，并没有运行，也许有错误，请客观参考</p>
<h1 id="在main执行之前和之后执行的代码可能是什么？"><a href="#在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="在main执行之前和之后执行的代码可能是什么？"></a>在main执行之前和之后执行的代码可能是什么？</h1><p>main函数执行之前，主要就是初始化系统相关资源：</p>
<ul>
<li>设置栈指针</li>
<li>初始化静态static变量和global全局变量，即.data段的内容</li>
<li>将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容</li>
<li>全局对象初始化，在main之前调用构造函数，这是可能会执行前的一些代码</li>
<li>将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数</li>
</ul>
<p>main函数执行之后：</p>
<ul>
<li>全局对象的析构函数会在main函数之后执行；</li>
<li>可以用 atexit 注册一个函数，它会在main 之后执行;</li>
</ul>
<h1 id="结构体内存对齐问题？"><a href="#结构体内存对齐问题？" class="headerlink" title="结构体内存对齐问题？"></a>结构体内存对齐问题？</h1><p>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</p>
<p>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</p>
<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><ul>
<li>指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名</li>
<li>指针可以有多级，引用只有一级</li>
<li>指针可以为空，引用不能为NULL且在定义时必须初始化</li>
<li>指针在初始化后可以改变指向，而引用在初始化之后不可再改变</li>
<li>当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。</li>
<li>引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。</li>
<li>引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。</li>
<li>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</li>
<li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li>
</ul>
<p>参考代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">　　p=&amp;a;</span><br><span class="line">　　cout&lt;&lt;p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">test</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;指针p为NULL&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line"><span class="comment">//0x22ff44 1</span></span><br><span class="line"><span class="comment">//指针p为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPTR</span><span class="params">(<span class="type">int</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">    p = &amp;a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testREFF</span><span class="params">(<span class="type">int</span>&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line">    p = a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* b = &amp;a;</span><br><span class="line">    <span class="built_in">testPTR</span>(b);<span class="comment">//改变指针指向，但是没改变指针的所指的内容</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;<span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; *b &lt;&lt; endl;<span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">testREFF</span>(a);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><ul>
<li>申请方式不同：栈由系统自动分配；堆是自己申请和释放的。</li>
<li>申请大小限制不同：栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改；堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。</li>
<li>申请效率不同：栈由系统分配，速度快，不会有碎片；堆由程序员分配，速度慢，且会有碎片。</li>
</ul>
<p>形象的比喻</p>
<p>栈就像我们去饭馆里吃饭，只管点菜（发出申# # 和吃（使用），吃饱了就走，不必理会# 洗菜等准备工作和# 刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p>
<p>堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p>
<h1 id="区别以下指针类型？"><a href="#区别以下指针类型？" class="headerlink" title="区别以下指针类型？"></a>区别以下指针类型？</h1><ul>
<li><code>int *p[10]</code>表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</li>
<li><code>int (*p)[10]</code>表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</li>
<li><code>int *p(int)</code>是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</li>
<li><code>int (*p)(int)</code>是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</li>
</ul>
<h1 id="宏定义和typedef区别？"><a href="#宏定义和typedef区别？" class="headerlink" title="宏定义和typedef区别？"></a>宏定义和typedef区别？</h1><p>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</p>
<p>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</p>
<p>宏不检查类型；typedef会检查数据类型。</p>
<p>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</p>
<p>注意对指针的操作，typedef char <em> p_char和define p_char char </em>区别巨大。</p>
<h1 id="变量声明和定义区别？"><a href="#变量声明和定义区别？" class="headerlink" title="变量声明和定义区别？"></a>变量声明和定义区别？</h1><p>声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。</p>
<p>相同变量可以在多处声明（外部变量extern），但只能在一处定义。</p>
<h1 id="哪几种情况必须用到初始化成员列表？"><a href="#哪几种情况必须用到初始化成员列表？" class="headerlink" title="哪几种情况必须用到初始化成员列表？"></a>哪几种情况必须用到初始化成员列表？</h1><p>初始化一个const成员。</p>
<p>初始化一个reference成员。</p>
<p>调用一个基类的构造函数，而该函数有一组参数。</p>
<p>调用一个数据成员对象的构造函数，而该函数有一组参数。</p>
<h1 id="a和-amp-a有什么区别？"><a href="#a和-amp-a有什么区别？" class="headerlink" title="a和&amp;a有什么区别？"></a>a和&amp;a有什么区别？</h1><p>假设数组<code>int a[10];</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*p)[<span class="number">10</span>] = &amp;a;</span><br></pre></td></tr></table></figure><br>a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。<code>*(a + 1) = a[1]</code>。</p>
<p>&amp;a是数组的指针，其类型为<code>int (*)[10]</code>（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。</p>
<p>若<code>(int *)p</code>，此时输出<code>*p</code>时，其值为<code>a[0]</code>的值，因为被转为<code>int *</code>类型，解引用时按照int类型大小来读取。</p>
<h1 id="迭代器失效的情况"><a href="#迭代器失效的情况" class="headerlink" title="迭代器失效的情况"></a>迭代器失效的情况</h1><p>以vector为例：</p>
<p>插入元素：</p>
<ul>
<li>尾后插入：size &lt; capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。</li>
<li>中间插入：中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。</li>
</ul>
<p>删除元素：</p>
<ul>
<li>尾后删除：只有尾迭代失效。</li>
<li>中间删除：删除位置之后所有迭代失效。</li>
</ul>
<h1 id="C和C-的区别"><a href="#C和C-的区别" class="headerlink" title="C和C++的区别"></a>C和C++的区别</h1><ul>
<li>C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。</li>
<li>标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。</li>
<li>C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。</li>
<li>C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。</li>
<li>在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。</li>
<li>C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C++允许重复定义变量，C语言也是做不到这一点的</li>
<li>在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。</li>
<li>C++相对与C增加了一些关键字，如：bo# usi# dynamic_ca# namespace等等</li>
</ul>
<h1 id="C-中struct和class的区别"><a href="#C-中struct和class的区别" class="headerlink" title="C++中struct和class的区别"></a>C++中struct和class的区别</h1><p>相同点：</p>
<ul>
<li>两者都拥有成员# 公有和私有部分</li>
<li>任何可以使用class完成的工作，同样可以使用struct完成</li>
</ul>
<p>不同点</p>
<ul>
<li>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</li>
<li>class默认是private继承，而struct模式是public继承</li>
<li>class可以作为模板类型，struct不行</li>
</ul>
<p>引申：C++和C的struct区别</p>
<p>C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）</p>
<p>C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数</p>
<p>C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）</p>
<p>struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;C++中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C++中被当作类的一种特例</p>
<h1 id="define宏定义和const的区别"><a href="#define宏定义和const的区别" class="headerlink" title="define宏定义和const的区别"></a>define宏定义和const的区别</h1><p>编译阶段</p>
<p>define是在编译的预处理阶段起作用，而const是在# 运行的时候起作用</p>
<p>安全性</p>
<p>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错</p>
<p>const常量有数据类型，编译器可以对其进行类型安全检查</p>
<p>内存占用</p>
<p>define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表</p>
<p>宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。</p>
<p>宏不检查类型；const会检查数据类型。</p>
<p>宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。</p>
<h1 id="final和override关键字"><a href="#final和override关键字" class="headerlink" title="final和override关键字"></a>final和override关键字</h1><p>override</p>
<p>当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">//OK</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// OK</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果不使用override，当你手一抖，将foo()写成了foo()会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f00</span><span class="params">()</span></span>; <span class="comment">//OK，这个函数是B新增的，不是继承的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f0o</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>final</p>
<p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// foo 被override并且是最后一个override，在其子类中不可以重写</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">final</span> : A <span class="comment">// 指明B是不可以被继承的</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// Error: 在A中已经被final了</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : B <span class="comment">// Error: B is final</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="拷贝初始化和直接初始化"><a href="#拷贝初始化和直接初始化" class="headerlink" title="拷贝初始化和直接初始化"></a>拷贝初始化和直接初始化</h1><p>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下</p>
<ul>
<li><code>string str1(&quot;I am a string&quot;);</code>//语句1 直接初始化</li>
<li><code>string str2(str1);</code>//语句2 直接初始化，str1是已经存在的对象，直接调用构造函数对str2进行初始化</li>
<li><code>string str3 = &quot;I am a string&quot;;</code>//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3</li>
<li><code>string str4 = str1;</code>//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数</li>
</ul>
<p>为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了（语句1和语句3等价）。但是需要辨别两种情况。</p>
<p>当拷贝构造函数为private时：语句3和语句4在编译时会报错</p>
<p>使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错</p>
<h1 id="初始化和赋值的区别"><a href="#初始化和赋值的区别" class="headerlink" title="初始化和赋值的区别"></a>初始化和赋值的区别</h1><p>对于简单类型来说，初始化和赋值没什么区别</p>
<p>对于类和复杂数据类型来说，这两者的区别就大了，举例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num1;</span><br><span class="line">    <span class="type">int</span> num2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>):<span class="built_in">num1</span>(a),<span class="built_in">num2</span>(b)&#123;&#125;;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a)&#123;&#125;;</span><br><span class="line">    <span class="comment">//重载 = 号操作符函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a)&#123;</span><br><span class="line">        num1 = a.num1 + <span class="number">1</span>;</span><br><span class="line">        num2 = a.num2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">    A a1 = a; <span class="comment">//拷贝初始化操作，调用拷贝构造函数</span></span><br><span class="line">    A b;</span><br><span class="line">    b = a;<span class="comment">//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="模板函数和模板类的特例化"><a href="#模板函数和模板类的特例化" class="headerlink" title="模板函数和模板类的特例化"></a>模板函数和模板类的特例化</h1><p>引入原因</p>
<p>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</p>
<p>定义</p>
<p>对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</p>
<p>（1）模板函数特例化</p>
<p>必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对&lt;&gt;，表明将原模板的所有模板参数提供实参，举例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T &amp;v1,<span class="type">const</span> T &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &gt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &gt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;v1,<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本质</p>
<p>特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。</p>
<p>注意</p>
<p>模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</p>
<p>（2）类模板特例化</p>
<p>原理类似函数模板，不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hash</span>&lt;sales_data&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(sales_data&amp; s)</span></span>;</span><br><span class="line">    <span class="comment">//里面所有T都换成特例化类型版本sales_data</span></span><br><span class="line">    <span class="comment">//按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>类模板的部分特例化</p>
<p>不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)</p>
<p>特例化类中的部分成员</p>
<p>可以特例化类中的部分成员函数而不是整个类，举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Barst</span><span class="params">(T a)</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> Foo&lt;<span class="type">int</span>&gt;::<span class="built_in">Bar</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//进行int类型的特例化处理</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我是int型特例化&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo&lt;string&gt; fs;</span><br><span class="line">Foo&lt;<span class="type">int</span>&gt; fi;<span class="comment">//使用特例化</span></span><br><span class="line">fs.<span class="built_in">Bar</span>();<span class="comment">//使用的是普通模板，即Foo&lt;string&gt;::Bar()</span></span><br><span class="line">fi.<span class="built_in">Bar</span>();<span class="comment">//特例化版本，执行Foo&lt;int&gt;::Bar()</span></span><br><span class="line"><span class="comment">//Foo&lt;string&gt;::Bar()和Foo&lt;int&gt;::Bar()功能不同</span></span><br></pre></td></tr></table></figure></p>
<h1 id="C和C-的类型安全"><a href="#C和C-的类型安全" class="headerlink" title="C和C++的类型安全"></a>C和C++的类型安全</h1><p>什么是类型安全？</p>
<p>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制；有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。类型安全的编程语言与类型安全的程序之间，没有必然联系。好的程序员可以使用类型不那么安全的语言写出类型相当安全的程序，相反的，差一点儿的程序员可能使用类型相当安全的语言写出类型不太安全的程序。绝对类型安全的编程语言暂时还没有。</p>
<p>如果C++使用得当，它将远比C更有类型安全性。相比于C语言，C++提供了一些新的机制保障类型安全：</p>
<ul>
<li>操作符new返回的指针类型严格与对象匹配，而不是void*</li>
<li>C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；</li>
<li>引入const关键字代替define constants，它是有类型有作用域的，define constants只是简单的文本替换</li>
</ul>
<p>C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。</p>
<p>例1：不同类型指针之间转换<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child1</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">Child1</span>(<span class="type">int</span> e):<span class="built_in">i</span>(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child2</span> : <span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    <span class="built_in">Child2</span>(<span class="type">double</span> e):<span class="built_in">d</span>(e)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Child1 <span class="title">c1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Child2 <span class="title">c2</span><span class="params">(<span class="number">4.1</span>)</span></span>;</span><br><span class="line">    Parent* pp;</span><br><span class="line">    Child1* pc1;</span><br><span class="line"></span><br><span class="line">    pp=&amp;c1; </span><br><span class="line">    pc1=(Child1*)pp;  <span class="comment">// 类型向下转换 强制转换，由于类型仍然为Child1*，不造成错误</span></span><br><span class="line">    cout&lt;&lt;pc1-&gt;i&lt;&lt;endl; <span class="comment">//输出：5</span></span><br><span class="line"></span><br><span class="line">    pp=&amp;c2;</span><br><span class="line">    pc1=(Child1*)pp;  <span class="comment">//强制转换，且类型发生变化，将造成错误</span></span><br><span class="line">    cout&lt;&lt;pc1-&gt;i&lt;&lt;endl;<span class="comment">// 输出：1717986918</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面两个例子之所以引起类型不安全的问题，是因为程序员使用不得当。第一个例子用到了空类型指针void<em>，第二个例子则是在两个类型指针之间进行强制转换。因此，想保证程序的类型安全性，应尽量避免使用空类型指针void</em>，尽量不对两种类型指针做强制转换。</p>
<h1 id="C-有哪几种的构造函数"><a href="#C-有哪几种的构造函数" class="headerlink" title="C++有哪几种的构造函数"></a>C++有哪几种的构造函数</h1><p>C++中的构造函数可以分为4类：</p>
<ul>
<li>默认构造函数</li>
<li>初始化构造函数（有参数）</li>
<li>拷贝构造函数</li>
<li>移动构造函数（move和右值引用）</li>
<li>委托构造函数</li>
<li>转换构造函数</li>
</ul>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()&#123;<span class="comment">//默认构造函数，没有参数</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = <span class="number">1000</span>;</span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> a, <span class="type">int</span> n):<span class="built_in">age</span>(a), <span class="built_in">num</span>(n)&#123;&#125;; <span class="comment">//初始化构造函数，有参数和参数列表</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student&amp; s)&#123;<span class="comment">//拷贝构造函数，这里与编译器生成的一致</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = s.age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = s.num;</span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> r)&#123;   <span class="comment">//转换构造函数,形参是其他类型变量，且只有一个形参</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = r;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = <span class="number">1002</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Student</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="number">18</span>,<span class="number">1001</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function">Student <span class="title">s3</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s4</span><span class="params">(s3)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1 age:%d, num:%d\n&quot;</span>, s1.age, s1.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2 age:%d, num:%d\n&quot;</span>, s2.age, s2.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s3 age:%d, num:%d\n&quot;</span>, s3.age, s3.num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s2 age:%d, num:%d\n&quot;</span>, s4.age, s4.num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//s1 age:20, num:1000</span></span><br><span class="line"><span class="comment">//s2 age:18, num:1001</span></span><br><span class="line"><span class="comment">//s3 age:10, num:1002</span></span><br><span class="line"><span class="comment">//s2 age:10, num:1002</span></span><br></pre></td></tr></table></figure><br>默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作</p>
<p>复制构造函数用于复制本类的对象</p>
<p>转换构造函数用于将其他类型的变量，隐式转换为本类对象</p>
<h1 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h1><p>浅拷贝</p>
<p>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p>
<p>深拷贝</p>
<p>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>()&#123;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="built_in">char</span>(<span class="number">20</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Student&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Student</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Student &quot;</span> &lt;&lt; &amp;name &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> name;</span><br><span class="line">        name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student &amp;s)&#123;<span class="comment">//拷贝构造函数</span></span><br><span class="line">        <span class="comment">//浅拷贝，当对象的name和传入对象的name指向相同的地址</span></span><br><span class="line">        name = s.name;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        <span class="comment">//name = new char(20);</span></span><br><span class="line">        <span class="comment">//memcpy(name, s.name, strlen(s.name));</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy Student&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;<span class="comment">// 花括号让s1和s2变成局部对象，方便测试</span></span><br><span class="line">        Student s1;</span><br><span class="line">        <span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">// 复制对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//浅拷贝执行结果：</span></span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//copy Student</span></span><br><span class="line"><span class="comment">//~Student 0x7fffed0c3ec0</span></span><br><span class="line"><span class="comment">//~Student 0x7fffed0c3ed0</span></span><br><span class="line"><span class="comment">//*** Error in `/tmp/815453382/a.out&#x27;: double free or corruption (fasttop): 0x0000000001c82c20 ***</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝执行结果：</span></span><br><span class="line"><span class="comment">//Student</span></span><br><span class="line"><span class="comment">//copy Student</span></span><br><span class="line"><span class="comment">//~Student 0x7fffebca9fb0</span></span><br><span class="line"><span class="comment">//~Student 0x7fffebca9fc0</span></span><br></pre></td></tr></table></figure><br>从执行结果可以看出，浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源，深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。</p>
<h1 id="auto-decltype和decltype-auto-的用法"><a href="#auto-decltype和decltype-auto-的用法" class="headerlink" title="auto decltype和decltype(auto)的用法"></a>auto decltype和decltype(auto)的用法</h1><p>（1）auto</p>
<p>C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同，</p>
<p>auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通；类型</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">auto</span> c = a + b;<span class="comment">// c为int型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span> j = i; <span class="comment">// 变量i是顶层const, 会被忽略, 所以j的类型是int</span></span><br><span class="line"><span class="keyword">auto</span> k = &amp;i; <span class="comment">// 变量i是一个常量, 对常量取地址是一种底层const, 所以b的类型是const int*</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> l = i; <span class="comment">//如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用和指针类型</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>&amp; y = x;</span><br><span class="line"><span class="keyword">auto</span> z = y; <span class="comment">//z是int型不是int&amp; 型</span></span><br><span class="line"><span class="keyword">auto</span>&amp; p1 = y; <span class="comment">//p1是int&amp;型</span></span><br><span class="line"><span class="keyword">auto</span> p2 = &amp;x; <span class="comment">//p2是指针类型int*</span></span><br></pre></td></tr></table></figure></p>
<p>（2）decltype</p>
<p>有的时候我们还会遇到这种情况，我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。还有可能是函数的返回类型为某表达式的值类型。在这些时候auto显得就无力了，所以C++11又引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func</span>()) sum = <span class="number">5</span>; <span class="comment">// sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">4</span>; <span class="comment">// a的类型是int, 所以b的类型也是int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不论是顶层const还是底层const, decltype都会保留   </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>(c) d = c; <span class="comment">// d的类型和c是一样的, 都是顶层const</span></span><br><span class="line"><span class="type">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* f = &amp;e; <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(f) g = f; <span class="comment">// g也是底层const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用与指针类型</span></span><br><span class="line"><span class="comment">//1. 如果表达式是引用类型, 那么decltype的类型也是引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">3</span>, &amp;j = i;</span><br><span class="line"><span class="keyword">decltype</span>(j) k = <span class="number">5</span>; <span class="comment">// k的类型是 const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) t = <span class="number">5</span>; <span class="comment">// 此时是int类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 对指针的解引用操作返回的是引用类型</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>, j = <span class="number">6</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c = j; <span class="comment">// c是int&amp;类型, c和j绑定在一起</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) j = i; <span class="comment">// 此时j的类型是int&amp;类型, j和i绑定在了一起</span></span><br></pre></td></tr></table></figure></p>
<p>（3）decltype(auto)</p>
<p>decltype(auto)是C++14新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将“=”号左边的表达式替换掉auto，再根据decltype的语法规则来确定类型。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> e = <span class="number">4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* f = &amp;e; <span class="comment">// f是底层const</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) j = f;<span class="comment">//j的类型是const int* 并且指向的是e</span></span><br></pre></td></tr></table></figure></p>
<h1 id="C-中NULL和nullptr区别"><a href="#C-中NULL和nullptr区别" class="headerlink" title="C++中NULL和nullptr区别"></a>C++中NULL和nullptr区别</h1><p>算是为了与C语言进行兼容而定义的一个问题吧</p>
<p>NULL来自C语言，一般由宏定义实现，而 nullptr 则是C++11的新增关键字。在C语言中，NULL被定义为(void*)0,而在C++语言中，NULL则被定义为整数0。编译器一般对其实际定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><br>在C++中指针必须有明确的类型定义。但是将NULL定义为0带来的另一个问题是无法与整数的0区分。因为C++中允许有函数重载，所以可以试想如下函数定义情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;char*&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：int</span></span><br></pre></td></tr></table></figure><br>那么在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。</p>
<p>nullptr的一种实现方式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">class</span> <span class="title class_">nullptr_t</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;  <span class="keyword">inline</span> <span class="keyword">operator</span> T*() <span class="type">const</span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">C</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">inline</span> <span class="keyword">operator</span> T C::*() <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>&amp;() <span class="type">const</span>;</span><br><span class="line">&#125; <span class="literal">nullptr</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure><br>以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void*)指针带来参数类型不明的问题，另外由于nullptr是明确的指针类型，所以不会与整形变量相混淆。但nullptr仍然存在一定问题，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;char* p&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;int* p&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;int p&quot;</span> &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>((<span class="type">char</span>*)<span class="literal">nullptr</span>);<span class="comment">//语句1</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">nullptr</span>);<span class="comment">//语句2</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">NULL</span>);<span class="comment">//语句3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//语句1：char* p</span></span><br><span class="line"><span class="comment">//语句2:报错，有多个匹配</span></span><br><span class="line"><span class="comment">//3：int p</span></span><br></pre></td></tr></table></figure><br>在这种情况下存在对不同指针类型的函数重载，此时如果传入nullptr指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。</p>
<h1 id="简要说明C-的内存分区"><a href="#简要说明C-的内存分区" class="headerlink" title="简要说明C++的内存分区"></a>简要说明C++的内存分区</h1><p>C++中的内存分区，分别# # 自由存# 全局/静态存# 常量存储区和代码区。如下图所示</p>
<p>图片</p>
<p>栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p>
<p>堆：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</p>
<p>自由存储区：就是那些由malloc等分配的内存块，它和堆是十分相似的，不过它是用free来结束自己的生命的</p>
<p>全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</p>
<p>常量存储区：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改</p>
<p>代码区：存放函数体的二进制代码</p>
<p>《C/C++内存管理详解》：</p>
<p><a target="_blank" rel="noopener" href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/">https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/</a></p>
<h1 id="C-的异常处理的方法"><a href="#C-的异常处理的方法" class="headerlink" title="C++的异常处理的方法"></a>C++的异常处理的方法</h1><p>在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：</p>
<p>数组下标越界</p>
<p>除法计算时除数为0</p>
<p>动态分配空间时空间不足</p>
<p>…</p>
<p>如果不及时对这些异常进行处理，程序多数情况下都会崩溃。</p>
<p>（1）t# throw和catch关键字</p>
<p>C++中的异常处理机制主要使用t# throw和catch三个关键字，其在程序中的用法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> m = <span class="number">1</span>, n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;before dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> - <span class="number">1</span>;  <span class="comment">//抛出int型异常</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> - <span class="number">1.0</span>;  <span class="comment">//拋出 double 型异常</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; m / n &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;after dividing.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">double</span> d) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch (double)&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch (...)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;finished&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//before dividing.</span></span><br><span class="line"><span class="comment">//catch (...)</span></span><br><span class="line"><span class="comment">//finished</span></span><br></pre></td></tr></table></figure><br>代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块。如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。</p>
<p>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）。</p>
<p>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。</p>
<p>（2）函数的异常声明列表</p>
<p>有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：</p>
<p>int fun() throw(int,double,A,B,C){…};<br>这种写法表名函数可能会抛出int,double型或# # C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常</p>
<p>（3）C++标准异常类  exception</p>
<p>bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* a = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          cout &lt;&lt; <span class="built_in">typeid</span>(*a).<span class="built_in">name</span>() &lt;&lt; endl; <span class="comment">// Error condition</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="built_in">catch</span> (bad_typeid)&#123;</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;Object is NULL&quot;</span> &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：bject is NULL</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常</li>
<li>bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常</li>
<li>out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常</li>
</ul>
<h1 id="静态变量什么时候初始化"><a href="#静态变量什么时候初始化" class="headerlink" title="静态变量什么时候初始化"></a>静态变量什么时候初始化</h1><p>1)  初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。</p>
<p>2)  静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。</p>
<p>3)  而在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的。</p>
<h1 id="值传递、指针传递、引用传递的区别和效率"><a href="#值传递、指针传递、引用传递的区别和效率" class="headerlink" title="值传递、指针传递、引用传递的区别和效率"></a>值传递、指针传递、引用传递的区别和效率</h1><ul>
<li>值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象   或是大的结构体对象，将耗费一定的时间和空间。（传值）</li>
<li>指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）</li>
<li>引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）</li>
<li>效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。</li>
</ul>
<h1 id="什么是内存池，如何实现"><a href="#什么是内存池，如何实现" class="headerlink" title="什么是内存池，如何实现"></a>什么是内存池，如何实现</h1><p>内存池（Memory Pool） 是一种内存分配方式。通常我们习惯直接使用new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。</p>
<p>这里简单描述一下《STL源码剖析》中的内存池实现机制：</p>
<p>allocate包装malloc,deallocate包装free</p>
<p>一般是一次20*2个的申请，先用一半，留着一半，为什么也没个说法，侯捷在STL那边书里说好像是C++委员会成员认为20是个比较好的数字，既不大也不小</p>
<p>首先客户端会调用malloc()配置一定数量的区块（固定大小的内存块，通常为8的倍数），假设40个32bytes的区块，其中20个区块（一半）给程序实际使用，1个区块交出，另外19个处于维护状态。剩余20个（一半）留给内存池，此时一共有（20*32byte）</p>
<p>客户端之后有有内存需求，想申请（20<em>64bytes）的空间，这时内存池只有（20</em>32bytes），就先将（10*64bytes)个区块返回，1个区块交出，另外9个处于维护状态，此时内存池空空如也</p>
<p>接下来如果客户端还有内存需求，就必须再调用malloc()配置空间，此时新申请的区块数量会增加一个随着配置次数越来越大的附加量，同样一半提供程序使用，另一半留给内存池。申请内存的时候用永远是先看内存池有无剩余，有的话就用上，然后挂在0-15号某一条链表上，要不然就重新申请。</p>
<p>如果整个堆的空间都不够了，就会在原先已经分配区块中寻找能满足当前需求的区块数量，能满足就返回，不能满足就向客户端报bad_alloc异常</p>
<p>allocator就是用来分配内存的，最重要的两个函数是allocate和deallocate，就是用来申请内存和回收内存的，外部（一般指容器）调用的时候只需要知道这些就够了。内部实现，目前的所有编译器都是直接调用的<code>::operator new()</code>和<code>::operator delete()</code>，说白了就是和直接使用new运算符的效果是一样的，所以老师说它们都没做任何特殊处理。</p>
<p>最开始GC2.9之前：</p>
<p>new和 operator new 的区别：new 是个运算符，编辑器会调用 operator new(0)</p>
<p><code>operator new()</code>里面有调用malloc的操作，那同样的 operator delete()里面有调用的free的操作</p>
<p>GCC2.9的alloc的一个比较好的分配器的实现规则</p>
<p>维护一条0-15号的一共16条链表，其中0表示8 bytes ，1表示 16 bytes,2表示 24bytes。。。。而15 表示 16* 8 = 128bytes，如果在申请时并不是8的倍数，那就找刚好能满足内存大小的那个位置。比如想申请 12，那就是找16了，想申请 20 ，那就找 24 了</p>
<p>但是现在GC4.9及其之后 也还有，变成_pool_alloc这个名字了，不再是默认的了，你需要自己去指定它可以自己指定，比如说<code>vector&lt;string,__gnu_cxx::pool_allocvec;</code>这样来使用它，现在用的又回到以前那种对malloc和free的包装形式了</p>
<h1 id="从汇编层去解释一下引用"><a href="#从汇编层去解释一下引用" class="headerlink" title="从汇编层去解释一下引用"></a>从汇编层去解释一下引用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9:      int x = 1;</span><br><span class="line">00401048  mov     dword ptr [ebp-4],1</span><br><span class="line">10:     int &amp;b = x;</span><br><span class="line">0040104F   lea     eax,[ebp-4]</span><br><span class="line">00401052  mov     dword ptr [ebp-8],eax</span><br></pre></td></tr></table></figure>
<p>x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存是从高往低进行分配的，所以b的地址比x的低。</p>
<p><code>lea eax,[ebp-4]</code> 这条语句将x的地址ebp-4放入eax寄存器</p>
<p><code>mov dword ptr [ebp-8],eax</code>这条语句将eax的值放入b的地址</p>
<p><code>ebp-8</code>中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样的吗？所以从汇编层次来看，的确引用是通过指针来实现的。</p>
<h1 id="C-模板是什么，你知道底层怎么实现的？"><a href="#C-模板是什么，你知道底层怎么实现的？" class="headerlink" title="C++模板是什么，你知道底层怎么实现的？"></a>C++模板是什么，你知道底层怎么实现的？</h1><p>1)  编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</p>
<p>2)  这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</p>
<h1 id="什么是内存泄露，如何检测与避免"><a href="#什么是内存泄露，如何检测与避免" class="headerlink" title="什么是内存泄露，如何检测与避免"></a>什么是内存泄露，如何检测与避免</h1><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p>
<h2 id="避免内存泄露的几种方式"><a href="#避免内存泄露的几种方式" class="headerlink" title="避免内存泄露的几种方式"></a>避免内存泄露的几种方式</h2><ul>
<li>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li>
<li>一定要将基类的析构函数声明为虚函数</li>
<li>对象数组的释放一定要用delete []</li>
<li>有new就有delete，有malloc就有free，保证它们一定成对出现</li>
</ul>
<h1 id="对象复用的了解，零拷贝的了解"><a href="#对象复用的了解，零拷贝的了解" class="headerlink" title="对象复用的了解，零拷贝的了解"></a>对象复用的了解，零拷贝的了解</h1><h2 id="对象复用"><a href="#对象复用" class="headerlink" title="对象复用"></a>对象复用</h2><p>对象复用其本质是一种设计模式：Flyweight享元模式。</p>
<p>通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。</p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。</p>
<p>零拷贝技术可以减少数据拷贝和共享总线操作的次数。</p>
<p>在C++中，vector的一个成员函数emplace_back()很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高。举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//初始构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(string p_name, <span class="type">int</span> p_age): <span class="built_in">name</span>(std::<span class="built_in">move</span>(p_name)), <span class="built_in">age</span>(p_age)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;I have been constructed&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//拷贝构造函数</span></span><br><span class="line">     <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; other): <span class="built_in">name</span>(std::<span class="built_in">move</span>(other.name)), <span class="built_in">age</span>(other.age)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;I have been copy constructed&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//转移构造函数</span></span><br><span class="line">     <span class="built_in">Person</span>(Person&amp;&amp; other): <span class="built_in">name</span>(std::<span class="built_in">move</span>(other.name)), <span class="built_in">age</span>(other.age)</span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;I have been moved&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Person&gt; e;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;emplace_back:&quot;</span> &lt;&lt;endl;</span><br><span class="line">    e.<span class="built_in">emplace_back</span>(<span class="string">&quot;Jane&quot;</span>, <span class="number">23</span>); <span class="comment">//不用构造类对象</span></span><br><span class="line"></span><br><span class="line">    vector&lt;Person&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;push_back:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="string">&quot;Mike&quot;</span>,<span class="number">36</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//emplace_back:</span></span><br><span class="line"><span class="comment">//I have been constructed</span></span><br><span class="line"><span class="comment">//push_back:</span></span><br><span class="line"><span class="comment">//I have been constructed</span></span><br><span class="line"><span class="comment">//I am being moved.</span></span><br></pre></td></tr></table></figure>
<h1 id="解释一下什么是trivial-destructor"><a href="#解释一下什么是trivial-destructor" class="headerlink" title="解释一下什么是trivial destructor"></a>解释一下什么是trivial destructor</h1><p>“trivial destructor”一般是指用户没有自定义析构函数，而由系统生成的，这种析构函数在《STL源码解析》中成为“无关痛痒”的析构函数。</p>
<p>反之，用户自定义了析构函数，则称之为“non-trivial destructor”，这种析构函数如果申请了新的空间一定要显式的释放，否则会造成内存泄露</p>
<p>对于trivial destructor，如果每次都进行调用，显然对效率是一种伤害，如何进行判断呢？《STL源码解析》中给出的说明是：</p>
<p>首先利用<code>value_type()</code>获取所指对象的型别，再利用<strong>type_traits判断该型别的析构函数是否trivial，若是`(</strong>true_type)<code>，则什么也不做，若为</code>(__false_type)`，则去调用destory()函数</p>
<p>也就是说，在实际的应用当中，STL库提供了相关的判断方法__type_traits，感兴趣的读者可以自行查阅使用方式。除了trivial destructor，还有trivial construct、trivial copy construct等，如果能够对是否trivial进行区分，可以采用内存处理函数memcpy()、malloc()等更加高效的完成相关操作，提升效率。</p>
<h1 id="C-中类的数据成员和成员函数内存分布情况"><a href="#C-中类的数据成员和成员函数内存分布情况" class="headerlink" title="C++中类的数据成员和成员函数内存分布情况"></a>C++中类的数据成员和成员函数内存分布情况</h1><p>C++类是由结构体发展得来的，所以他们的成员变量（C语言的结构体只有成员变量）的内存分配机制是一样的。下面我们以类来说明问题，如果类的问题通了，结构体也也就没问题啦。类分为成员变量和成员函数，我们先来讨论成员变量。</p>
<p>一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址。（在定义类对象的同时这些成员变量也就被定义了），举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">23</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;对象地址：&quot;</span>&lt;&lt; &amp;p &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age地址：&quot;</span>&lt;&lt; &amp;(p.age) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;对象大小：&quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age大小：&quot;</span>&lt;&lt; <span class="built_in">sizeof</span>(p.age) &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//对象地址：0x7fffec0f15a8</span></span><br><span class="line"><span class="comment">//age地址：0x7fffec0f15a8</span></span><br><span class="line"><span class="comment">//对象大小：4</span></span><br><span class="line"><span class="comment">//age大小：4</span></span><br></pre></td></tr></table></figure>
<p>从代码运行结果来看，对象的大小和对象中数据成员的大小是一致的，也就是说，成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。要是成员函数占用类的对象空间，那么将是多么可怕的事情：定义一次类对象就有成员函数占用一段空间。我们再来补充一下静态成员函数的存放问题：静态成员函数与一般成员函数的唯一区别就是没有this指针，因此不能访问非静态数据成员，就像我前面提到的，所有函数都存放在代码区，静态函数也不例外。所有有人一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的。</p>
<h1 id="析构函数的作用，如何起作用？"><a href="#析构函数的作用，如何起作用？" class="headerlink" title="析构函数的作用，如何起作用？"></a>析构函数的作用，如何起作用？</h1><p>1)  构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。</p>
<p>规则，只要你一实例化对象，系统自动回调用一个构造函数就是你不写，编译器也自动调用一次。</p>
<p>2)  析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前面加~。</p>
<p>析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。当撤销对象时，编译器也会自动调用析构函数。</p>
<p>每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。</p>
<h1 id="构造函数析构函数可否抛出异常"><a href="#构造函数析构函数可否抛出异常" class="headerlink" title="构造函数析构函数可否抛出异常"></a>构造函数析构函数可否抛出异常</h1><p>1)   C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。</p>
<p>因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。</p>
<p>2)  用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；</p>
<p>3)  如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；</p>
<p>4)  如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。</p>
<h1 id="类什么时候会析构？"><a href="#类什么时候会析构？" class="headerlink" title="类什么时候会析构？"></a>类什么时候会析构？</h1><p>1)  对象生命周期结束，被销毁时；</p>
<p>2)  delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；</p>
<p>3)  对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。</p>
<h1 id="构造函数的几种关键字"><a href="#构造函数的几种关键字" class="headerlink" title="构造函数的几种关键字"></a>构造函数的几种关键字</h1><p>default</p>
<p>default关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CString</span>() = <span class="keyword">default</span>; <span class="comment">//语句1</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">CString</span>(<span class="type">const</span> <span class="type">char</span>* pstr) : _str(pstr)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;<span class="comment">//这样不允许使用new关键字</span></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CString</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     string _str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="built_in">CString</span>(); <span class="comment">//语句2</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//Hello World</span></span><br></pre></td></tr></table></figure>
<p>如果没有加语句1，语句2会报错，表示找不到参数为空的构造函数，将其设置为default可以解决这个问题</p>
<p>delete</p>
<p>delete关键字可以删除构造函数、赋值运算符函数等，这样在使用的时候会得到友善的提示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">()</span> </span>= <span class="keyword">delete</span>;<span class="comment">//这样不允许使用new关键字</span></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">CString</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="built_in">CString</span>(); <span class="comment">//语句1</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行语句1时，会提示new方法已经被删除，如果将new设置为私有方法，则会报惨不忍睹的错误，因此使用delete关键字可以更加人性化的删除一些默认方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>将虚函数定义为纯虚函数（纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，不过函数体必须定义在类的外部）</p>
<h1 id="C-函数调用的压栈过程"><a href="#C-函数调用的压栈过程" class="headerlink" title="C++函数调用的压栈过程"></a>C++函数调用的压栈过程</h1><p>从代码入手，解释这个过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> param1, <span class="type">int</span> param2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> var1 = param1;</span><br><span class="line">    <span class="type">int</span> var2 = param2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;var1=%d,var2=%d&quot;</span>, <span class="built_in">f</span>(var1), <span class="built_in">f</span>(var2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//var1=1,var2=2</span></span><br></pre></td></tr></table></figure>
<p>当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；</p>
<p>当main函数开始调用func()函数时，编译器此时会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；</p>
<p>当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈</p>
<p>从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。</p>
<h1 id="说说移动构造函数"><a href="#说说移动构造函数" class="headerlink" title="说说移动构造函数"></a>说说移动构造函数</h1><p>1)  我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</p>
<p>2)  拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。</p>
<p>所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a-&gt;value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a-&gt;value指向的空间；</p>
<p>3)  移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。</p>
<h1 id="C-中将临时变量作为返回值时的处理过程"><a href="#C-中将临时变量作为返回值时的处理过程" class="headerlink" title="C++中将临时变量作为返回值时的处理过程"></a>C++中将临时变量作为返回值时的处理过程</h1><p>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</p>
<p>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</p>
<p>由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系</p>
<p>如果我们需要返回值，一般使用赋值语句就可以了</p>
<h1 id="关于this指针你知道什么？全说出来"><a href="#关于this指针你知道什么？全说出来" class="headerlink" title="关于this指针你知道什么？全说出来"></a>关于this指针你知道什么？全说出来</h1><p>this指针是类的指针，指向对象的首地址。</p>
<p>this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。</p>
<p>this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。</p>
<h2 id="this指针的用处"><a href="#this指针的用处" class="headerlink" title="this指针的用处"></a>this指针的用处</h2><p>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候（全局函数，静态函数中不能使用this指针），编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行</p>
<h2 id="this指针的使用"><a href="#this指针的使用" class="headerlink" title="this指针的使用"></a>this指针的使用</h2><p>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；</p>
<p>另外一种情况是当形参数与成员变量名相同时用于区分，如this-&gt;n = n （不能写成n = n）</p>
<p>类的this指针有以下特点</p>
<p>(1）this只能在成员函数中使用，全局函数、静态函数都不能使用this。实际上，成员函数默认第一个参数为T * const this</p>
<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">其中，func的原型在编译器看来应该是：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(A * <span class="type">const</span> <span class="keyword">this</span>,<span class="type">int</span> p)</span></span>;</span><br></pre></td></tr></table></figure>
<p>（2）由此可见，this在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//此处，编译器将会编译成：</span></span><br><span class="line">A::<span class="built_in">func</span>(&amp;a,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高，例如VC通常是通过ecx（计数寄存器）传递this参数的。</p>
<h1 id="几个this指针的易混问题"><a href="#几个this指针的易混问题" class="headerlink" title="几个this指针的易混问题"></a>几个this指针的易混问题</h1><h2 id="this指针是什么时候创建的？"><a href="#this指针是什么时候创建的？" class="headerlink" title="this指针是什么时候创建的？"></a>this指针是什么时候创建的？</h2><p>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p>
<p>但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式创建对象的话，在堆里分配内存，new操作符通过eax（累加寄存器）返回分配的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请看上面的回答</p>
<h2 id="this指针存放在何处？堆、栈、全局变量，还是其他？"><a href="#this指针存放在何处？堆、栈、全局变量，还是其他？" class="headerlink" title="this指针存放在何处？堆、栈、全局变量，还是其他？"></a>this指针存放在何处？堆、栈、全局变量，还是其他？</h2><p>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。</p>
<h2 id="this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？"><a href="#this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？" class="headerlink" title="this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？"></a>this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针又是如何找到“类实例后函数的”？</h2><p>大多数编译器通过ecx（寄数寄存器）寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</p>
<p>在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的</p>
<h2 id="this指针是如何访问类中的变量的？"><a href="#this指针是如何访问类中的变量的？" class="headerlink" title="this指针是如何访问类中的变量的？"></a>this指针是如何访问类中的变量的？</h2><p>如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。</p>
<p>在C++中，类和结构是只有一个区别的：类的成员默认是private，而结构是public。</p>
<p>this是类的指针，如果换成结构体，那this就是结构的指针了。</p>
<h2 id="我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？"><a href="#我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？" class="headerlink" title="我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？"></a>我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</h2><p>this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</p>
<h2 id="每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？"><a href="#每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？" class="headerlink" title="每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？"></a>每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</h2><p>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰</p>
<h1 id="构造函数、拷贝构造函数和赋值操作符的区别"><a href="#构造函数、拷贝构造函数和赋值操作符的区别" class="headerlink" title="构造函数、拷贝构造函数和赋值操作符的区别"></a>构造函数、拷贝构造函数和赋值操作符的区别</h1><p>构造函数</p>
<p>对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数</p>
<p>拷贝构造函数</p>
<p>对象不存在，但是使用别的已经存在的对象来进行初始化</p>
<p>赋值运算符</p>
<p>对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span> = (A&amp; a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是赋值操作符&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1; <span class="comment">//调用构造函数</span></span><br><span class="line">    A a2 = a1; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    a2 = a1; <span class="comment">//调用赋值操作符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//我是构造函数</span></span><br><span class="line"><span class="comment">//我是拷贝构造函数</span></span><br><span class="line"><span class="comment">//我是赋值操作符</span></span><br></pre></td></tr></table></figure>
<h1 id="静态类型和动态类型以及静态绑定和动态绑定的总结"><a href="#静态类型和动态类型以及静态绑定和动态绑定的总结" class="headerlink" title="静态类型和动态类型以及静态绑定和动态绑定的总结"></a>静态类型和动态类型以及静态绑定和动态绑定的总结</h1><ul>
<li>静态类型：对象在声明时采用的类型，在编译期既已确定；</li>
<li>动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；</li>
<li>静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；</li>
<li>动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；</li>
</ul>
<p>从上面的定义也可以看出，非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）。</p>
<h1 id="引用是否能实现动态绑定，为什么可以实现？"><a href="#引用是否能实现动态绑定，为什么可以实现？" class="headerlink" title="引用是否能实现动态绑定，为什么可以实现？"></a>引用是否能实现动态绑定，为什么可以实现？</h1><p>可以。</p>
<p>引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>  <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base :: fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>  <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;son :: fun()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;son :: not virtual function&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    Base&amp; b = s; <span class="comment">// 基类类型引用绑定已经存在的Son对象，引用必须初始化</span></span><br><span class="line">    s.<span class="built_in">fun</span>(); <span class="comment">//son::fun()</span></span><br><span class="line">    b.<span class="built_in">fun</span>(); <span class="comment">//son :: fun()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要说明的是虚函数才具有动态绑定，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。</p>
<h1 id="全局变量和局部变量有什么区别？"><a href="#全局变量和局部变量有什么区别？" class="headerlink" title="全局变量和局部变量有什么区别？"></a>全局变量和局部变量有什么区别？</h1><p>生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p>
<p>使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。</p>
<p>操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载，局部变量则分配在堆栈里面 。</p>
<h1 id="指针加减计算要注意什么？"><a href="#指针加减计算要注意什么？" class="headerlink" title="指针加减计算要注意什么？"></a>指针加减计算要注意什么？</h1><p>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *a, *b, c;</span><br><span class="line">    a = (<span class="type">int</span>*)<span class="number">0x500</span>;</span><br><span class="line">    b = (<span class="type">int</span>*)<span class="number">0x520</span>;</span><br><span class="line">    c = b - a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c); <span class="comment">// 8</span></span><br><span class="line">    a += <span class="number">0x020</span>;</span><br><span class="line">    c = b - a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, c); <span class="comment">// -24</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先变量a和b都是以16进制的形式初始化，将它们转成10进制分别是1280（5<em>16\^2=1280）和1312（5</em>16\^2+2*16=1312)， 那么它们的差值为32，也就是说a和b所指向的地址之间间隔32个位，但是考虑到是int类型占4位，所以c的值为32/4=8</p>
<p>a自增16进制0x20之后，其实际地址变为1280 + 2<em>16</em>4 = 1408，（因为一个int占4位，所以要乘4），这样它们的差值就变成了1312 - 1280 = -96，所以c的值就变成了-96/4 = -24</p>
<p>遇到指针的计算，需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果</p>
<h1 id="怎样判断两个浮点数是否相等？"><a href="#怎样判断两个浮点数是否相等？" class="headerlink" title="怎样判断两个浮点数是否相等？"></a>怎样判断两个浮点数是否相等？</h1><p>对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。</p>
<h1 id="方法调用的原理（栈、汇编）"><a href="#方法调用的原理（栈、汇编）" class="headerlink" title="方法调用的原理（栈、汇编）"></a>方法调用的原理（栈、汇编）</h1><p>1)  机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;</p>
<p>2)  由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。</p>
<p>3)  过程实现</p>
<ul>
<li>备份原来的帧指针，调整当前的栈帧指针到栈指针位置；</li>
<li>建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存；</li>
<li>使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。</li>
<li>恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了</li>
<li>恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。</li>
<li>释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理。</li>
<li>恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。</li>
<li>弹出返回地址，跳出当前过程，继续执行调用者的代码。</li>
</ul>
<p>4)  过程调用和返回指令</p>
<ul>
<li>call指令</li>
<li>leave指令</li>
<li>ret指令</li>
</ul>
<h1 id="C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"><a href="#C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？" class="headerlink" title="C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"></a>C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</h1><p>1) 指针参数传递本质上是值传递，它所传递的是一个地址值。</p>
<p>值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。</p>
<p>值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。</p>
<p>2) 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。</p>
<p>被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。</p>
<p>因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。</p>
<p>3) 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。</p>
<p>而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。</p>
<p>4) 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。</p>
<p>指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。</p>
<p>符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p>
<h1 id="类如何实现只能静态分配和只能动态分配"><a href="#类如何实现只能静态分配和只能动态分配" class="headerlink" title="类如何实现只能静态分配和只能动态分配"></a>类如何实现只能静态分配和只能动态分配</h1><p>1)  前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建</p>
<p>2)  建立类的对象有两种方式：</p>
<ul>
<li>静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；</li>
<li>动态建立，A *p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；</li>
</ul>
<p>3)  只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。</p>
<h1 id="如果想将某个类用作基类，为什么该类必须定义而非声明？"><a href="#如果想将某个类用作基类，为什么该类必须定义而非声明？" class="headerlink" title="如果想将某个类用作基类，为什么该类必须定义而非声明？"></a>如果想将某个类用作基类，为什么该类必须定义而非声明？</h1><p>派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。</p>
<h1 id="什么情况会自动生成默认构造函数？"><a href="#什么情况会自动生成默认构造函数？" class="headerlink" title="什么情况会自动生成默认构造函数？"></a>什么情况会自动生成默认构造函数？</h1><ul>
<li>带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。<ul>
<li>不过这个合成操作只有在构造函数真正被需要的时候才会发生；</li>
<li>如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；</li>
</ul>
</li>
<li>带有默认构造函数的基类，如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；</li>
<li>带有一个虚函数的类</li>
<li>带有一个虚基类的类</li>
<li>合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。</li>
</ul>
<h1 id="函数指针？"><a href="#函数指针？" class="headerlink" title="函数指针？"></a>函数指针？</h1><ul>
<li>什么是函数指针?</li>
</ul>
<p>函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数的名称则不是其类型的一部分。</p>
<p>一个具体函数的名字，如果后面不跟调用符号(即括号)，则该名字就是该函数的指针(注意：大部分情况下，可以这么认为，但这种说法并不很严格)。</p>
<ul>
<li>函数指针的声明方法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*pf)(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;); (<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>上面的pf就是一个函数指针，指向所有返回类型为int，并带有两个<code>const int&amp;</code>参数的函数。注意*pf两边的括号是必须的，否则上面的定义就变成了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">pf</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;)</span></span>; (<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>而这声明了一个函数pf，其返回类型为int *， 带有两个<code>const int&amp;</code>参数。</p>
<ul>
<li>为什么有函数指针</li>
</ul>
<p>函数与数据项相似，函数也有地址。我们希望在同一个函数中通过使用相同的形参在不同的时间使用产生不同的效果。</p>
<ul>
<li><p>一个函数名就是一个指针，它指向函数的代码。一个函数地址是该函数的进入点，也就是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数；</p>
</li>
<li><p>两种方法赋值：</p>
</li>
</ul>
<p>指针名 = 函数名； 指针名 = &amp;函数名</p>
<h1 id="函数调用过程栈的变化，返回值和参数变量哪个先入栈？"><a href="#函数调用过程栈的变化，返回值和参数变量哪个先入栈？" class="headerlink" title="函数调用过程栈的变化，返回值和参数变量哪个先入栈？"></a>函数调用过程栈的变化，返回值和参数变量哪个先入栈？</h1><ol>
<li>调用者函数把被调函数所需要的参数按照与被调函数的形参顺序相反的顺序压入栈中,即:从右向左依次把被调函数所需要的参数压入栈;</li>
<li>调用者函数使用call指令调用被调函数,并把call指令的下一条指令的地址当成返回地址压入栈中(这个压栈操作隐含在call指令中);</li>
<li>在被调函数中,被调函数会先保存调用者函数的栈底地址(push ebp),然后再保存调用者函数的栈顶地址,即:当前被调函数的栈底地址(mov ebp,esp);</li>
<li>在被调函数中,从ebp的位置处开始存放被调函数中的局部变量和临时变量,并且这些变量的地址按照定义时的顺序依次减小,即:这些变量的地址是按照栈的延伸方向排列的,先定义的变量先入栈,后定义的变量后入栈;</li>
</ol>
<h1 id="你知道printf函数的实现原理是什么吗？"><a href="#你知道printf函数的实现原理是什么吗？" class="headerlink" title="你知道printf函数的实现原理是什么吗？"></a>你知道printf函数的实现原理是什么吗？</h1><p>在C/C++中，对函数参数的扫描是从后向前的。</p>
<p>C/C++的函数参数是通过压入堆栈的方式来给函数传参数的（堆栈是一种先进后出的数据结构），最先压入的参数最后出来，在计算机的内存中，数据有2块，一块是堆，一块是栈（函数参数及局部变量在这里），而栈是从内存的高地址向低地址生长的，控制生长的就是堆栈指针了，最先压入的参数是在最上面，就是说在所有参数的最后面，最后压入的参数在最下面，结构上看起来是第一个，所以最后压入的参数总是能够被函数找到，因为它就在堆栈指针的上方。</p>
<p>printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来的那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可算出数据需要的堆栈指针的偏移量了，下面给出printf(“%d,%d”,a,b);（其中a、b都是int型的）的汇编代码.</p>
<h1 id="说一说你了解的关于lambda函数的全部知识"><a href="#说一说你了解的关于lambda函数的全部知识" class="headerlink" title="说一说你了解的关于lambda函数的全部知识"></a>说一说你了解的关于lambda函数的全部知识</h1><p>1) 利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；</p>
<p>2) 每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。</p>
<p>3) lambda表达式的语法定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture] （parameters） <span class="keyword">mutable</span> -&gt;<span class="keyword">return</span>-type &#123;statement&#125;;</span><br></pre></td></tr></table></figure>
<p>4) lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；</p>
<h1 id="为什么模板类一般都是放在一个h文件中"><a href="#为什么模板类一般都是放在一个h文件中" class="headerlink" title="为什么模板类一般都是放在一个h文件中"></a>为什么模板类一般都是放在一个h文件中</h1><ul>
<li>模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。</li>
</ul>
<p>所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p>
<ul>
<li>在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。</li>
</ul>
<p>所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。</p>
<p>然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。</p>
<h1 id="cout和printf有什么区别？"><a href="#cout和printf有什么区别？" class="headerlink" title="cout和printf有什么区别？"></a>cout和printf有什么区别？</h1><p>cout&lt;&lt;是一个函数，cout&lt;&lt;后可以跟不同的类型是因为cout&lt;&lt;已存在针对各种类型数据的重载，所以会自动识别数据的类型。输出过程会首先将输出字符放入缓冲区，然后输出到屏幕。</p>
<p>cout是有缓冲输出:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt; &lt; <span class="string">&quot;abc &quot;</span> &lt; &lt;endl;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt; &lt; <span class="string">&quot;abc\n &quot;</span>;cout &lt; &lt;flush; 这两个才是一样的.</span><br></pre></td></tr></table></figure>
<p>flush立即强迫缓冲输出。<br>printf是无缓冲输出。有输出时立即输出</p>
<h1 id="当程序中有函数重载时，函数的匹配原则和顺序是什么？"><a href="#当程序中有函数重载时，函数的匹配原则和顺序是什么？" class="headerlink" title="当程序中有函数重载时，函数的匹配原则和顺序是什么？"></a>当程序中有函数重载时，函数的匹配原则和顺序是什么？</h1><ul>
<li><p>名字查找</p>
</li>
<li><p>确定候选函数</p>
</li>
<li><p>寻找最佳匹配</p>
</li>
</ul>
<h1 id="定义和声明的区别"><a href="#定义和声明的区别" class="headerlink" title="定义和声明的区别"></a>定义和声明的区别</h1><p>如果是指变量的声明和定义<br>从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。</p>
<p>如果是指函数的声明和定义<br>声明：一般在头文件里，对编译器说：这里我有一个函数叫function() 让编译器知道这个函数的存在。<br>定义：一般在源文件里，具体就是函数的实现过程 写明函数体。</p>
<h1 id="说一下你理解的-ifdef-endif代表着什么？"><a href="#说一下你理解的-ifdef-endif代表着什么？" class="headerlink" title="说一下你理解的 ifdef   endif代表着什么？"></a>说一下你理解的 ifdef   endif代表着什么？</h1><ul>
<li><p>一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。</p>
</li>
<li><p>条件编译命令最常见的形式为：</p>
</li>
</ul>
<p>#ifdef 标识符<br> 程序段1<br> #else<br> 程序段2<br> #endif<br>它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。<br>其中#else部分也可以没有，即：</p>
<p> #ifdef<br> 程序段1<br> #denif</p>
<ul>
<li>在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。</li>
</ul>
<p>在头文件中使用#define、#ifndef、#ifdef、#endif能避免头文件重定义。</p>
<h1 id="隐式转换，如何消除隐式转换？"><a href="#隐式转换，如何消除隐式转换？" class="headerlink" title="隐式转换，如何消除隐式转换？"></a>隐式转换，如何消除隐式转换？</h1><p>1、C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换</p>
<p>2、C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。在比如，数值和布尔类型的转换，整数和浮点数的转换等。</p>
<p>某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。C++是一门强类型语言，类型的检查是非常严格的。</p>
<p>3、 基本数据类型 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。隐式转换发生在从小-&gt;大的转换中。比如从char转换为int。从int-&gt;long。自定义对象 子类对象可以隐式的转换为父类对象。</p>
<p>4、 C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</p>
<p>5、如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。</p>
<h1 id="迭代器：-it、it-哪个好，为什么"><a href="#迭代器：-it、it-哪个好，为什么" class="headerlink" title="迭代器：++it、it++哪个好，为什么"></a>迭代器：++it、it++哪个好，为什么</h1><ul>
<li>前置返回一个引用，后置返回一个对象</li>
</ul>
<p>// ++i实现代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>++()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i++实现代码为：                 </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>++(<span class="type">int</span>)                 </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> temp = *<span class="keyword">this</span>;                   </span><br><span class="line"></span><br><span class="line">   ++*<span class="keyword">this</span>;                       </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> temp;                  </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h1 id="C-如何处理多个异常的？"><a href="#C-如何处理多个异常的？" class="headerlink" title="C++如何处理多个异常的？"></a>C++如何处理多个异常的？</h1><ul>
<li><p>C++中的异常情况：<br>  语法错误（编译错误）：比如变量未定义、括号不匹配、关键字拼写错误等等编译器在编译时能发现的错误，这类错误可以及时被编译器发现，而且可以及时知道出错的位置及原因，方便改正。<br>  运行时错误：比如数组下标越界、系统内存不足等等。这类错误不易被程序员发现，它能通过编译且能进入运行，但运行时会出错，导致程序崩溃。为了有效处理程序运行时错误，C++中引入异常处理机制来解决此问题。</p>
</li>
<li><p>C++异常处理机制：<br>  异常处理基本思想：执行一个函数的过程中发现异常，可以不用在本函数内立即进行处理， 而是抛出该异常，让函数的调用者直接或间接处理这个问题。<br>  C++异常处理机制由3个模块组成：try(检查)、throw(抛出)、catch(捕获)<br>  抛出异常的语句格式为：throw 表达式；如果try块中程序段发现了异常则抛出异常。</p>
</li>
</ul>
<p>~cpptry  {  可能抛出异常的语句；（检查）  }  catch（类型名[形参名]）//捕获特定类型的异常  {  //处理1；}  catch（类型名[形参名]）//捕获特定类型的异常  {  //处理2；}  catch（…）//捕获所有类型的异常  {  }~</p>
<h1 id="模板和实现可不可以不写在一个文件里面？为什么？"><a href="#模板和实现可不可以不写在一个文件里面？为什么？" class="headerlink" title="模板和实现可不可以不写在一个文件里面？为什么？"></a>模板和实现可不可以不写在一个文件里面？为什么？</h1><p>因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。</p>
<p>但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。<br>《C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，</p>
<p>它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p>
<h1 id="在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h1><p>1、在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</p>
<p>2、为什么是不可预期的问题？</p>
<p>delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。</p>
<p>此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p>
<p>3、 如果在类的析构函数中调用delete this，会发生什么？</p>
<p>会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p>
<h1 id="如何在不使用额外空间的情况下，交换两个数？你有几种方法"><a href="#如何在不使用额外空间的情况下，交换两个数？你有几种方法" class="headerlink" title="如何在不使用额外空间的情况下，交换两个数？你有几种方法"></a>如何在不使用额外空间的情况下，交换两个数？你有几种方法</h1><ul>
<li>算术</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = x + y;</span><br><span class="line"> y = x - y;</span><br><span class="line"></span><br><span class="line">x = x - y; </span><br></pre></td></tr></table></figure>
<ul>
<li>异或</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = x^y;<span class="comment">// 只能对int,char..</span></span><br><span class="line"> y = x^y;</span><br><span class="line"> x = x^y;</span><br><span class="line"> x ^= y ^= x;</span><br></pre></td></tr></table></figure>
<h1 id="你知道strcpy和memcpy的区别是什么吗？"><a href="#你知道strcpy和memcpy的区别是什么吗？" class="headerlink" title="你知道strcpy和memcpy的区别是什么吗？"></a>你知道strcpy和memcpy的区别是什么吗？</h1><ol>
<li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li>
<li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li>
<li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li>
</ol>
<h1 id="程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？"><a href="#程序在执行int-main-int-argc-char-argv-时的内存结构，你了解吗？" class="headerlink" title="程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？"></a>程序在执行int main(int argc, char *argv[])时的内存结构，你了解吗？</h1><p>参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针</p>
<p>char * 指向的内存中，数组的中元素的个数为 argc 个，第一个参数为程序的名称。</p>
<h1 id="你知道const-char-与string之间的关系是什么吗？"><a href="#你知道const-char-与string之间的关系是什么吗？" class="headerlink" title="你知道const char* 与string之间的关系是什么吗？"></a>你知道const char* 与string之间的关系是什么吗？</h1><ul>
<li><p>string 是c++标准库里面其中一个，封装了对字符串的操作，实际操作过程我们可以用const char*给string类初始化</p>
</li>
<li><p>三者的转化关系如下所示：</p>
</li>
</ul>
<p>a)  string转const char* </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = “abc”; </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = s.<span class="built_in">c_str</span>(); </span><br></pre></td></tr></table></figure>
<p>b)  const char* 转string，直接赋值即可 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* c_s = “abc”; </span><br><span class="line"> <span class="function">string <span class="title">s</span><span class="params">(c_s)</span></span>; </span><br></pre></td></tr></table></figure>
<p>c)  string 转char* </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s = “abc”; </span><br><span class="line"><span class="type">char</span>* c; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = s.<span class="built_in">length</span>(); </span><br><span class="line">c = <span class="keyword">new</span> <span class="type">char</span>[len+<span class="number">1</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(c,s.<span class="built_in">c_str</span>()); </span><br></pre></td></tr></table></figure>
<p>d)  char* 转string </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* c = “abc”; </span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(c)</span></span>; </span><br></pre></td></tr></table></figure>
<p>e)  const char<em> 转char</em> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cpc = “abc”; </span><br><span class="line"><span class="type">char</span>* pc = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cpc)+<span class="number">1</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(pc,cpc);</span><br></pre></td></tr></table></figure>
<p>f)  char<em> 转const char</em>，直接赋值即可 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* pc = “abc”; </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cpc = pc;</span><br></pre></td></tr></table></figure>
<h1 id="为什么拷贝构造函数必须传引用不能传值？"><a href="#为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="为什么拷贝构造函数必须传引用不能传值？"></a>为什么拷贝构造函数必须传引用不能传值？</h1><ul>
<li>拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。</li>
<li>参数传递过程到底发生了什么？<ul>
<li>将地址传递和值传递统一起来，归根结底还是传递的是”值”(地址也是值，只不过通过它可以找到另一个值)！</li>
</ul>
</li>
<li>值传递:<ul>
<li>对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)；</li>
<li>对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)；</li>
</ul>
</li>
</ul>
<p>如void foo(class_type obj_local){}, 如果调用foo(obj); 首先class_type obj_local(obj) ,这样就定义了局部变量obj_local供函数内部使用</p>
<p>ii)引用传递:<br>  无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型).<br>上述1) 2)回答了为什么拷贝构造函数使用值传递会产生无限递归调用，内存溢出。</p>
<p>拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。</p>
<h1 id="你知道空类的大小是多少吗？"><a href="#你知道空类的大小是多少吗？" class="headerlink" title="你知道空类的大小是多少吗？"></a>你知道空类的大小是多少吗？</h1><ul>
<li>C++空类的大小不为0，不同编译器设置不一样，vs设置为1；</li>
<li>C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址；</li>
<li>带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定；</li>
<li>C++中要求对于类的每个实例都必须有独一无二的地址,那么编译器自动为空类分配一个字节大小，这样便保证了每个实例均有独一无二的内存地址。</li>
</ul>
<h1 id="this指针调用成员变量时，堆栈会发生什么变化？"><a href="#this指针调用成员变量时，堆栈会发生什么变化？" class="headerlink" title="this指针调用成员变量时，堆栈会发生什么变化？"></a>this指针调用成员变量时，堆栈会发生什么变化？</h1><p>当在类的非静态成员函数访问类的非静态成员时，编译器会自动将对象的地址传给作为隐含参数传递给函数，这个隐含参数就是this指针。</p>
<p>即使你并没有写this指针，编译器在链接时也会加上this的，对各成员的访问都是通过this的。</p>
<p>例如你建立了类的多个对象时，在调用类的成员函数时，你并不知道具体是哪个对象在调用，此时你可以通过查看this指针来查看具体是哪个对象在调用。This指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈。</p>
<h1 id="你知道静态绑定和动态绑定吗？讲讲？"><a href="#你知道静态绑定和动态绑定吗？讲讲？" class="headerlink" title="你知道静态绑定和动态绑定吗？讲讲？"></a>你知道静态绑定和动态绑定吗？讲讲？</h1><ul>
<li><p>对象的静态类型：对象在声明时采用的类型。是在编译期确定的。</p>
</li>
<li><p>对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。</p>
</li>
<li><p>静态绑定：绑定的是对象的静态类型，某特性（比如函数依赖于对象的静态类型，发生在编译期。</p>
</li>
<li><p>动态绑定：绑定的是对象的动态类型，某特性（比如函数依赖于对象的动态类型，发生在运行期。</p>
</li>
</ul>
<h1 id="如何设计一个类计算子类的个数？"><a href="#如何设计一个类计算子类的个数？" class="headerlink" title="如何设计一个类计算子类的个数？"></a>如何设计一个类计算子类的个数？</h1><ul>
<li>为类设计一个static静态变量count作为计数器；</li>
<li>类定义结束后初始化count;</li>
<li>在构造函数中对count进行+1;</li>
<li>设计拷贝构造函数，在进行拷贝构造函数中进行count +1，操作；</li>
<li>设计复制构造函数，在进行复制函数中对count+1操作；</li>
<li>在析构函数中对count进行-1；</li>
</ul>
<h1 id="怎么快速定位错误出现的地方"><a href="#怎么快速定位错误出现的地方" class="headerlink" title="怎么快速定位错误出现的地方"></a>怎么快速定位错误出现的地方</h1><p>1、如果是简单的错误，可以直接双击错误列表里的错误项或者生成输出的错误信息中带行号的地方就可以让编辑窗口定位到错误的位置上。</p>
<p>2、对于复杂的模板错误，最好使用生成输出窗口。</p>
<p>多数情况下出发错误的位置是最靠后的引用位置。如果这样确定不了错误，就需要先把自己写的代码里的引用位置找出来，然后逐个分析了。</p>
<h1 id="类对象的大小受哪些因素影响？"><a href="#类对象的大小受哪些因素影响？" class="headerlink" title="类对象的大小受哪些因素影响？"></a>类对象的大小受哪些因素影响？</h1><ul>
<li>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</li>
<li>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</li>
<li>虚函数的话，会在类对象插入vptr指针，加上指针大小；</li>
<li>当该该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。</li>
</ul>
<h1 id="移动构造函数听说过吗？说说"><a href="#移动构造函数听说过吗？说说" class="headerlink" title="移动构造函数听说过吗？说说"></a>移动构造函数听说过吗？说说</h1><ul>
<li>有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</li>
<li>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；</li>
<li>C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；</li>
<li>与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。</li>
</ul>
<p>这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作；</p>
<p>5)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Example6</span> (Example6&amp;&amp; x) : <span class="built_in">ptr</span>(x.ptr) </span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    x.ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// move assignment</span></span><br><span class="line"></span><br><span class="line">  Example6&amp; <span class="keyword">operator</span>= (Example6&amp;&amp; x) </span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> ptr; </span><br><span class="line"></span><br><span class="line">   ptr = x.ptr;</span><br><span class="line"></span><br><span class="line">   x.ptr=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="什么时候合成构造函数？都说一说，你知道的都说一下"><a href="#什么时候合成构造函数？都说一说，你知道的都说一下" class="headerlink" title="什么时候合成构造函数？都说一说，你知道的都说一下"></a>什么时候合成构造函数？都说一说，你知道的都说一下</h1><ul>
<li>如果一个类没有任何构造函数，但他含有一个成员对象，该成员对象含有默认构造函数，那么编译器就为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；</li>
<li>没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该派生类合成一个构造函数，只有这样基类的构造函数才能被调用；</li>
<li>带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针是在构造函数中初始化的，所以没有构造函数的话该指针无法被初始化；</li>
<li>带有一个虚基类的类</li>
</ul>
<p>还有一点需要注意的是：</p>
<ul>
<li>并不是任何没有构造函数的类都会合成一个构造函数</li>
<li>编译器合成出来的构造函数并不会显示设定类内的每一个成员变量</li>
</ul>
<h1 id="那什么时候需要合成拷贝构造函数呢？"><a href="#那什么时候需要合成拷贝构造函数呢？" class="headerlink" title="那什么时候需要合成拷贝构造函数呢？"></a>那什么时候需要合成拷贝构造函数呢？</h1><p>有三种情况会以一个对象的内容作为另一个对象的初值：</p>
<ul>
<li>对一个对象做显示的初始化操作，X xx = x;</li>
<li>当对象被当做参数交给某个函数时；</li>
<li><p>当函数传回一个类对象时；</p>
</li>
<li><p>如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型含有拷贝构造函数，此时编译器会为该类合成一个拷贝构造函数；</p>
</li>
<li>如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成一个拷贝构造函数；</li>
<li>如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数；</li>
</ul>
<h1 id="说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>说一说strcpy、sprintf与memcpy这三个函数的不同之处</h1><ul>
<li>操作对象不同<ul>
<li>strcpy的两个操作对象均为字符串</li>
<li>sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串</li>
<li>memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</li>
</ul>
</li>
<li>执行效率不同<ul>
<li>memcpy最高，strcpy次之，sprintf的效率最低。</li>
</ul>
</li>
<li>实现功能不同<ul>
<li>strcpy主要实现字符串变量间的拷贝</li>
<li>sprintf主要实现其他数据类型格式到字符串的转化</li>
<li>memcpy主要是内存块间的拷贝。</li>
</ul>
</li>
</ul>
<h1 id="将引用作为函数参数有哪些好处？"><a href="#将引用作为函数参数有哪些好处？" class="headerlink" title="将引用作为函数参数有哪些好处？"></a>将引用作为函数参数有哪些好处？</h1><ul>
<li>传递引用给函数与传递指针的效果是一样的。</li>
</ul>
<p>这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</p>
<ul>
<li>使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；</li>
</ul>
<p>而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；</p>
<p>如果传递的是对象，还将调用拷贝构造函数。</p>
<p>因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</p>
<ul>
<li>使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；</li>
</ul>
<p>另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p>
<h1 id="如何阻止一个类被实例化？有哪些方法？"><a href="#如何阻止一个类被实例化？有哪些方法？" class="headerlink" title="如何阻止一个类被实例化？有哪些方法？"></a>如何阻止一个类被实例化？有哪些方法？</h1><ul>
<li>将类定义为抽象基类或者将构造函数声明为private；</li>
<li>不允许类外部创建类对象，只能在类内部创建对象</li>
</ul>
<h1 id="strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>strcpy函数和strncpy函数的区别？哪个函数更安全？</h1><ul>
<li>函数原型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* strDest, <span class="type">const</span> <span class="type">char</span>* strSrc)</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strncpy</span><span class="params">(<span class="type">char</span>* strDest, <span class="type">const</span> <span class="type">char</span>* strSrc, <span class="type">int</span> pos)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>strcpy函数: 如果参数 dest 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用strncpy()来取代。<br>  strncpy函数：用来复制源字符串的前n个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。</p>
</li>
<li><p>如果目标长&gt;指定长&gt;源长，则将源长全部拷贝到目标长，自动加上’\0’<br>  如果指定长&lt;源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’  如果指定长&gt;目标长，运行时错误 ；</p>
</li>
</ul>
<h1 id="你知道回调函数吗？它的作用？"><a href="#你知道回调函数吗？它的作用？" class="headerlink" title="你知道回调函数吗？它的作用？"></a>你知道回调函数吗？它的作用？</h1><ul>
<li>当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数；</li>
<li>回调函数就相当于一个中断处理函数，由系统在符合你设定的条件时自动调用。为此，你需要做三件事：1，声明；2，定义；3，设置触发条件，就是在你的函数中把你的回调函数名称转化为地址作为一个参数，以便于系统调用；</li>
<li>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数；</li>
<li>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。</li>
</ul>
<h1 id="动态编译与静态编译"><a href="#动态编译与静态编译" class="headerlink" title="动态编译与静态编译"></a>动态编译与静态编译</h1><ul>
<li><p>静态编译，编译器在编译可执行文件时，把需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库；</p>
</li>
<li><p>动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。</p>
</li>
</ul>
<p>缺点是哪怕是很简单的程序，只用到了链接库的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/05/06/Cannon%E5%92%8CStencil%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/06/Cannon%E5%92%8CStencil%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/" itemprop="url">Cannon算法和Stencil计算</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-06T15:29:39+08:00">
                2022-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>————————————————<br>版权声明：本文为CSDN博主「zongy17」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43614211/article/details/122105195">https://blog.csdn.net/weixin_43614211/article/details/122105195</a><br>————————————————</p>
<h1 id="Cannon和fox算法"><a href="#Cannon和fox算法" class="headerlink" title="Cannon和fox算法"></a>Cannon和fox算法</h1><p>Cannon算法：</p>
<p>输入：两个N ∗ N的矩阵A、 B，P个处理器。</p>
<p>输出：若P是完全平方数且N % P = 0，则计算C = A ∗ B并输出。</p>
<p>算法思想：将N ∗ N的矩阵分割成P块，即每行每列均有✔P个分块矩阵，那么每个分块的行列都等于N / ✔P。将这些分块分给P个处理器，即处理器 Pij 管理分块Aij、Bij，并计算对应分块Cij的结果。初始时将分块Aij循环左移i步，分块Bij循环上移j步。接下来是运算过程，计算Aij ∗ Bij并将结果放置到Cij中，计算完成后Aij循环左移一步，Bij循环上移一步，重复这个过程✔P次即可计算出最终的Cij，然后由根处理器收集结果即可。</p>
<p><img src="/img/20200612124939300.png" alt=""><br><img src="/img/2020061212500491.png" alt=""></p>
<p><img src="/img/20200612125022232.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">5</span>;	<span class="comment">//n是矩阵大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MatrixA[n][n], MatrixB[n][n], MatrixC[n][n];	<span class="comment">//三个矩阵 已知A B 计算C=A*B</span></span><br><span class="line"><span class="type">int</span> block, blocknum;	<span class="comment">//每个分块的大小(一行有多少元素) blocknum=block*block</span></span><br><span class="line"><span class="type">int</span> numprocs, sqrnumprocs;	<span class="comment">//前者为处理器的个数 后者为其根号</span></span><br><span class="line"><span class="type">int</span> move_size;	<span class="comment">//=blocknum*sizeof(int) 用于memcpy memset等函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* blockA, * blockB, * blockC, * tmpa, * tmpb;	<span class="comment">//存储 分块矩阵 以及传输数据所需要的缓冲区</span></span><br><span class="line"><span class="type">int</span> myid, row, col;	<span class="comment">//处理器ID 把整个矩阵划分成若干个分块矩阵分给其它处理器 则该处理器处理第row行 第clo列的分块矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_AB</span><span class="params">()</span><span class="comment">//初始化矩阵 A B</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			MatrixA[i][j] = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">			MatrixB[i][j] = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">send_block_AB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> rowmin, rowmax, colmin, colmax;	<span class="comment">//记录分块矩阵的范围</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numprocs; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		rowmin = (i / sqrnumprocs) * block;</span><br><span class="line">		rowmax = rowmin + block;</span><br><span class="line">		colmin = (i % sqrnumprocs) * block;</span><br><span class="line">		colmax = colmin + block;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = rowmin; j &lt; rowmax; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = colmin; k &lt; colmax; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> idx = (j - rowmin) * block + k - colmin;	<span class="comment">//由于tmp是一维数组 所以要计算当前元素对应的下标</span></span><br><span class="line">				tmpa[idx] = MatrixA[j][k];</span><br><span class="line">				tmpb[idx] = MatrixB[j][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!i)	<span class="comment">//0号处理器</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(blockA, tmpa, move_size);</span><br><span class="line">			<span class="built_in">memcpy</span>(blockB, tmpb, move_size);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;		<span class="comment">//发送分块矩阵 A B</span></span><br><span class="line">			<span class="built_in">MPI_Send</span>(tmpa, blocknum, MPI_INT, i, <span class="number">1</span>, MPI_COMM_WORLD);</span><br><span class="line">			<span class="built_in">MPI_Send</span>(tmpb, blocknum, MPI_INT, i, <span class="number">2</span>, MPI_COMM_WORLD);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getidx</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span>	<span class="comment">//通过 分块矩阵的 行row 列col 得到管理它的 处理器ID</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//row=id/sqrnumprocs col=id%sqrnumprocs</span></span><br><span class="line">	<span class="keyword">return</span> ((row + sqrnumprocs) % sqrnumprocs) * sqrnumprocs + (col + sqrnumprocs) % sqrnumprocs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_move</span><span class="params">()</span>	<span class="comment">//初始时的移动操作 A中分块(i,j)左移i步 B中分块(i,j)上移j步</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MPI_Status s;</span><br><span class="line">	<span class="comment">//发送并接受对应的分块</span></span><br><span class="line">	<span class="built_in">MPI_Sendrecv</span>(blockA, blocknum, MPI_INT, <span class="built_in">getidx</span>(row, col - row), <span class="number">1</span>, tmpa, blocknum, MPI_INT, <span class="built_in">getidx</span>(row, col + row), <span class="number">1</span>, MPI_COMM_WORLD, &amp;s);</span><br><span class="line">	<span class="built_in">MPI_Sendrecv</span>(blockB, blocknum, MPI_INT, <span class="built_in">getidx</span>(row - col, col), <span class="number">2</span>, tmpb, blocknum, MPI_INT, <span class="built_in">getidx</span>(row + col, col), <span class="number">2</span>, MPI_COMM_WORLD, &amp;s);</span><br><span class="line">	<span class="comment">//拷贝</span></span><br><span class="line">	<span class="built_in">memcpy</span>(blockA, tmpa, move_size);</span><br><span class="line">	<span class="built_in">memcpy</span>(blockB, tmpb, move_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cal</span><span class="params">()</span>	<span class="comment">//计算过程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MPI_Status s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> times = <span class="number">0</span>; times &lt; sqrnumprocs; times++)	<span class="comment">//sqrnumprocs次 乘法和累加</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; block; i++)	<span class="comment">//c[i][j]=a[i][k]*b[k][j]</span></span><br><span class="line">		&#123;								<span class="comment">//c[i][j]=blockC[i * block + j]</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; block; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> sum = blockC[i * block + j];</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; block; k++)</span><br><span class="line">					sum += blockA[i * block + k] * blockB[k * block + j];</span><br><span class="line">				blockC[i * block + j] = sum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	<span class="comment">//每个分块计算完毕后</span></span><br><span class="line">		<span class="comment">//A中分块左移1步 B中分块上移1步</span></span><br><span class="line">		<span class="built_in">MPI_Sendrecv</span>(blockA, blocknum, MPI_INT, <span class="built_in">getidx</span>(row, col - <span class="number">1</span>), <span class="number">1</span>, tmpa, blocknum, MPI_INT, <span class="built_in">getidx</span>(row, col + <span class="number">1</span>), <span class="number">1</span>, MPI_COMM_WORLD, &amp;s);</span><br><span class="line">		<span class="built_in">MPI_Sendrecv</span>(blockB, blocknum, MPI_INT, <span class="built_in">getidx</span>(row - <span class="number">1</span>, col), <span class="number">2</span>, tmpb, blocknum, MPI_INT, <span class="built_in">getidx</span>(row + <span class="number">1</span>, col), <span class="number">2</span>, MPI_COMM_WORLD, &amp;s);</span><br><span class="line">		<span class="comment">//拷贝</span></span><br><span class="line">		<span class="built_in">memcpy</span>(blockA, tmpa, move_size);</span><br><span class="line">		<span class="built_in">memcpy</span>(blockB, tmpb, move_size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getans</span><span class="params">()</span>	<span class="comment">//处理器0 从其余处理器处得到分块矩阵的结果并合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MPI_Status s;</span><br><span class="line">	<span class="type">int</span> rowmin, rowmax, colmin, colmax;</span><br><span class="line">	<span class="comment">//处理器0 可直接得到</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; block; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; block; j++)</span><br><span class="line">			MatrixC[i][j] = blockC[i * block + j];</span><br><span class="line">	<span class="comment">//其余的需要 接收</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numprocs; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MPI_Recv</span>(blockC, blocknum, MPI_INT, i, <span class="number">1</span>, MPI_COMM_WORLD, &amp;s);</span><br><span class="line">		rowmin = (i / sqrnumprocs) * block;	<span class="comment">//首行坐标</span></span><br><span class="line">		rowmax = rowmin + block;	<span class="comment">//最后一行的坐标</span></span><br><span class="line">		colmin = (i % sqrnumprocs) * block;	<span class="comment">//首列坐标</span></span><br><span class="line">		colmax = colmin + block;	<span class="comment">//最后一列的坐标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = rowmin; j &lt; rowmax; j++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = colmin; k &lt; colmax; k++)</span><br><span class="line">				MatrixC[j][k] = blockC[(j - rowmin) * block + k - colmin];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print_matrix</span><span class="params">(<span class="type">int</span> ans[][n])</span>	<span class="comment">//输出矩阵</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%-5d&quot;</span>, ans[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">MPI_Init</span>(&amp;argc, &amp;argv);</span><br><span class="line">	<span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;numprocs);	<span class="comment">//个数</span></span><br><span class="line">	<span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;myid);		<span class="comment">//ID</span></span><br><span class="line"></span><br><span class="line">	<span class="type">clock_t</span> start = <span class="built_in">clock</span>();	<span class="comment">//开始时间</span></span><br><span class="line"></span><br><span class="line">	sqrnumprocs = <span class="built_in">sqrt</span>(numprocs);</span><br><span class="line">	<span class="keyword">if</span> (sqrnumprocs * sqrnumprocs != numprocs || n % sqrnumprocs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (myid == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (n % sqrnumprocs == <span class="number">0</span>)</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;处理器个数应该为完全平方数！\n&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;sqrnumprocs必须整除矩阵大小n!\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">MPI_Finalize</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	block = n/sqrnumprocs;	<span class="comment">//分块大小</span></span><br><span class="line">	blocknum = block * block;	<span class="comment">//每个分块的元素总数</span></span><br><span class="line">	move_size = blocknum * <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">	row = myid / sqrnumprocs;		<span class="comment">//计算自己处理的分块矩阵的 坐标</span></span><br><span class="line">	col = myid % sqrnumprocs;</span><br><span class="line">	blockA = <span class="keyword">new</span> <span class="type">int</span>[blocknum];	<span class="comment">//分配空间</span></span><br><span class="line">	blockB = <span class="keyword">new</span> <span class="type">int</span>[blocknum];</span><br><span class="line">	blockC = <span class="keyword">new</span> <span class="type">int</span>[blocknum];</span><br><span class="line">	tmpa = <span class="keyword">new</span> <span class="type">int</span>[blocknum];</span><br><span class="line">	tmpb = <span class="keyword">new</span> <span class="type">int</span>[blocknum];</span><br><span class="line">	<span class="built_in">memset</span>(blockC, <span class="number">0</span>, move_size);	<span class="comment">//初始化c</span></span><br><span class="line">	<span class="keyword">if</span> (!myid)	<span class="comment">//0号处理器</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">init_AB</span>();	<span class="comment">//初始化矩阵A B</span></span><br><span class="line">		<span class="built_in">send_block_AB</span>();	<span class="comment">//计算分块矩阵 并将其发送给其余处理器</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	<span class="comment">//接受0号发过来的 分块矩阵</span></span><br><span class="line">		MPI_Status s;</span><br><span class="line">		<span class="built_in">MPI_Recv</span>(blockA, blocknum, MPI_INT, <span class="number">0</span>, <span class="number">1</span>, MPI_COMM_WORLD, &amp;s);</span><br><span class="line">		<span class="built_in">MPI_Recv</span>(blockB, blocknum, MPI_INT, <span class="number">0</span>, <span class="number">2</span>, MPI_COMM_WORLD, &amp;s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">init_move</span>();	<span class="comment">//初始时分块矩阵的移动</span></span><br><span class="line">	<span class="built_in">cal</span>();	<span class="comment">//计算过程</span></span><br><span class="line">	<span class="keyword">if</span> (myid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">getans</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;矩阵A为:\n&quot;</span>;</span><br><span class="line">		<span class="built_in">print_matrix</span>(MatrixA);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;矩阵B为:\n&quot;</span>;</span><br><span class="line">		<span class="built_in">print_matrix</span>(MatrixB);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;矩阵C=A*B为(cannon乘法):\n&quot;</span>;</span><br><span class="line">		<span class="built_in">print_matrix</span>(MatrixC);</span><br><span class="line">		<span class="type">clock_t</span> end = <span class="built_in">clock</span>();	<span class="comment">//结束时间</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Cannon乘法耗时: &quot;</span> &lt;&lt; end - start &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MPI_Send</span>(blockC, blocknum, MPI_INT, <span class="number">0</span>, <span class="number">1</span>, MPI_COMM_WORLD);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] blockA;</span><br><span class="line">	<span class="keyword">delete</span>[] blockB;</span><br><span class="line">	<span class="keyword">delete</span>[] blockC;</span><br><span class="line">	<span class="keyword">delete</span>[] tmpa;</span><br><span class="line">	<span class="keyword">delete</span>[] tmpb;</span><br><span class="line">	<span class="built_in">MPI_Barrier</span>(MPI_COMM_WORLD);</span><br><span class="line">	<span class="built_in">MPI_Finalize</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「csu_xiji」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/xiji333/article/details/106713440</span></span><br></pre></td></tr></table></figure>
<p>Fox算法：</p>
<p>输入、输出、环境都同Cannon算法。</p>
<p>算法思想：分块部分的处理和Cannon算法是一样的。在分完块后，Aii向所在行的其他处理器进行一到多播送，然后处理器将收到的分块A与自己的B块进行乘加运算，计算完成之后自己的分块A保持不变，分块B循环上移一步，如果Aij是上次第i行播送的块，本次选择A[i, j + 1 % ✔P]向所在行的其它处理器进行一到多播送，然后进行乘加运算……进行✔P次乘加运算后即可得到所有的Cij，由根处理器收集结果即可。</p>
<p><img src="/img/20200612131704898.png" alt=""><br><img src="/img/20200612131724282.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">1e3</span>;	<span class="comment">//n是矩阵大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MatrixA[n][n], MatrixB[n][n], MatrixC[n][n];	<span class="comment">//三个矩阵 已知A B 计算C=A*B</span></span><br><span class="line"><span class="type">int</span> block, blocknum;	<span class="comment">//每个分块的大小(一行有多少元素) blocknum=block*block</span></span><br><span class="line"><span class="type">int</span> numprocs, sqrnumprocs;	<span class="comment">//前者为处理器的个数 后者为其根号</span></span><br><span class="line"><span class="type">int</span> move_size;	<span class="comment">//=blocknum*sizeof(int) 用于memcpy memset等函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* blockA, * blockB, * blockC, * tmpa, * tmpb;	<span class="comment">//存储 分块矩阵 以及传输数据所需要的缓冲区</span></span><br><span class="line"><span class="type">int</span> myid, row, col;	<span class="comment">//处理器ID 把整个矩阵划分成若干个分块矩阵分给其它处理器 则该处理器处理第row行 第clo列的分块矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_AB</span><span class="params">()</span><span class="comment">//初始化矩阵 A B</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			MatrixA[i][j] = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">			MatrixB[i][j] = <span class="built_in">rand</span>() % <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">send_block_AB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> rowmin, rowmax, colmin, colmax;	<span class="comment">//记录分块矩阵的范围</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numprocs; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		rowmin = (i / sqrnumprocs) * block;</span><br><span class="line">		rowmax = rowmin + block;</span><br><span class="line">		colmin = (i % sqrnumprocs) * block;</span><br><span class="line">		colmax = colmin + block;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = rowmin; j &lt; rowmax; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = colmin; k &lt; colmax; k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> idx = (j - rowmin) * block + k - colmin;	<span class="comment">//由于tmp是一维数组 所以要计算当前元素对应的下标</span></span><br><span class="line">				tmpa[idx] = MatrixA[j][k];</span><br><span class="line">				tmpb[idx] = MatrixB[j][k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!i)	<span class="comment">//0号处理器</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(blockA, tmpa, move_size);</span><br><span class="line">			<span class="built_in">memcpy</span>(blockB, tmpb, move_size);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;		<span class="comment">//发送分块矩阵 A B</span></span><br><span class="line">			<span class="built_in">MPI_Send</span>(tmpa, blocknum, MPI_INT, i, <span class="number">1</span>, MPI_COMM_WORLD);</span><br><span class="line">			<span class="built_in">MPI_Send</span>(tmpb, blocknum, MPI_INT, i, <span class="number">2</span>, MPI_COMM_WORLD);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getidx</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col)</span>	<span class="comment">//通过 分块矩阵的 行row 列col 得到管理它的 处理器ID</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//row=id/sqrnumprocs col=id%sqrnumprocs</span></span><br><span class="line">	<span class="keyword">return</span> ((row + sqrnumprocs) % sqrnumprocs) * sqrnumprocs + (col + sqrnumprocs) % sqrnumprocs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cal</span><span class="params">()</span>	<span class="comment">//计算过程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MPI_Status s;</span><br><span class="line">	<span class="type">int</span> send_col_idx = row;	<span class="comment">//在分块矩阵的视图上看 初始时 需要发送分块矩阵(row,send_col_idx)</span></span><br><span class="line">	<span class="type">int</span> idxmin, idxmax;	<span class="comment">//记录 需要接收分块的 处理器的id范围</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> times = <span class="number">0</span>; times &lt; sqrnumprocs; times++)	<span class="comment">//sqrnumprocs次 乘法和累加</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//该处理器处理的分块的坐标为 (row,col)</span></span><br><span class="line">		<span class="comment">//所以需要从 处理器 getidx(row,send_idx[row]) 处得到分块A 然后进行乘法累加</span></span><br><span class="line">		<span class="keyword">if</span> (col == send_col_idx)</span><br><span class="line">		&#123;</span><br><span class="line">			idxmin = <span class="built_in">getidx</span>(row, <span class="number">0</span>);</span><br><span class="line">			idxmax = <span class="built_in">getidx</span>(row, sqrnumprocs - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = idxmin; i &lt;= idxmax; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (i == myid)	<span class="comment">//自己就没必要发送了</span></span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				<span class="built_in">MPI_Send</span>(blockA, blocknum, MPI_INT, i, <span class="number">1</span>, MPI_COMM_WORLD);<span class="comment">//发送</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">memcpy</span>(tmpa, blockA, move_size);	<span class="comment">//直接拷贝到目标位置</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>	<span class="comment">//接收分块</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">MPI_Recv</span>(tmpa, blocknum, MPI_INT, <span class="built_in">getidx</span>(row, send_col_idx), <span class="number">1</span>, MPI_COMM_WORLD, &amp;s);</span><br><span class="line">		&#125;</span><br><span class="line">		send_col_idx = (send_col_idx + <span class="number">1</span>) % sqrnumprocs;	<span class="comment">//递增列号</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; block; i++)	<span class="comment">//c[i][j]=a[i][k]*b[k][j]</span></span><br><span class="line">		&#123;								<span class="comment">//c[i][j]=blockC[i * block + j]</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; block; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> sum = blockC[i * block + j];</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; block; k++)</span><br><span class="line">					sum += tmpa[i * block + k] * blockB[k * block + j];</span><br><span class="line">				blockC[i * block + j] = sum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	<span class="comment">//每个分块计算完毕后</span></span><br><span class="line">		<span class="comment">//A中分块保持不动 B中分块上移1步</span></span><br><span class="line">		<span class="built_in">MPI_Sendrecv</span>(blockB, blocknum, MPI_INT, <span class="built_in">getidx</span>(row - <span class="number">1</span>, col), <span class="number">2</span>, tmpb, blocknum, MPI_INT, <span class="built_in">getidx</span>(row + <span class="number">1</span>, col), <span class="number">2</span>, MPI_COMM_WORLD, &amp;s);</span><br><span class="line">		<span class="comment">//拷贝</span></span><br><span class="line">		<span class="built_in">memcpy</span>(blockB, tmpb, move_size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getans</span><span class="params">()</span>	<span class="comment">//处理器0 从其余处理器处得到分块矩阵的结果并合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MPI_Status s;</span><br><span class="line">	<span class="type">int</span> rowmin, rowmax, colmin, colmax;</span><br><span class="line">	<span class="comment">//处理器0 可直接得到</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; block; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; block; j++)</span><br><span class="line">			MatrixC[i][j] = blockC[i * block + j];</span><br><span class="line">	<span class="comment">//其余的需要 接收</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; numprocs; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MPI_Recv</span>(blockC, blocknum, MPI_INT, i, <span class="number">1</span>, MPI_COMM_WORLD, &amp;s);</span><br><span class="line">		rowmin = (i / sqrnumprocs) * block;	<span class="comment">//首行坐标</span></span><br><span class="line">		rowmax = rowmin + block;	<span class="comment">//最后一行的坐标</span></span><br><span class="line">		colmin = (i % sqrnumprocs) * block;	<span class="comment">//首列坐标</span></span><br><span class="line">		colmax = colmin + block;	<span class="comment">//最后一列的坐标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = rowmin; j &lt; rowmax; j++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = colmin; k &lt; colmax; k++)</span><br><span class="line">				MatrixC[j][k] = blockC[(j - rowmin) * block + k - colmin];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print_matrix</span><span class="params">(<span class="type">int</span> ans[][n])</span>	<span class="comment">//输出矩阵</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%-5d&quot;</span>, ans[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">MPI_Init</span>(&amp;argc, &amp;argv);</span><br><span class="line">	<span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;numprocs);	<span class="comment">//个数</span></span><br><span class="line">	<span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;myid);		<span class="comment">//ID</span></span><br><span class="line"></span><br><span class="line">	<span class="type">clock_t</span> start = <span class="built_in">clock</span>();	<span class="comment">//开始时间</span></span><br><span class="line"></span><br><span class="line">	sqrnumprocs = <span class="built_in">sqrt</span>(numprocs);</span><br><span class="line">	<span class="keyword">if</span> (sqrnumprocs * sqrnumprocs != numprocs || n % sqrnumprocs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (myid == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (n % sqrnumprocs == <span class="number">0</span>)</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;处理器个数应该为完全平方数！\n&quot;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;sqrnumprocs必须整除矩阵大小n!\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">MPI_Finalize</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	block = n/sqrnumprocs;	<span class="comment">//分块大小</span></span><br><span class="line">	blocknum = block * block;	<span class="comment">//每个分块的元素总数</span></span><br><span class="line">	move_size = blocknum * <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">	row = myid / sqrnumprocs;		<span class="comment">//计算自己处理的分块矩阵的 坐标</span></span><br><span class="line">	col = myid % sqrnumprocs;</span><br><span class="line">	blockA = <span class="keyword">new</span> <span class="type">int</span>[blocknum];	<span class="comment">//分配空间</span></span><br><span class="line">	blockB = <span class="keyword">new</span> <span class="type">int</span>[blocknum];</span><br><span class="line">	blockC = <span class="keyword">new</span> <span class="type">int</span>[blocknum];</span><br><span class="line">	tmpa = <span class="keyword">new</span> <span class="type">int</span>[blocknum];</span><br><span class="line">	tmpb = <span class="keyword">new</span> <span class="type">int</span>[blocknum];</span><br><span class="line">	<span class="built_in">memset</span>(blockC, <span class="number">0</span>, move_size);	<span class="comment">//初始化c</span></span><br><span class="line">	<span class="keyword">if</span> (!myid)	<span class="comment">//0号处理器</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">init_AB</span>();	<span class="comment">//初始化矩阵A B</span></span><br><span class="line">		<span class="built_in">send_block_AB</span>();	<span class="comment">//计算分块矩阵 并将其发送给其余处理器</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	<span class="comment">//接受0号发过来的 分块矩阵</span></span><br><span class="line">		MPI_Status s;</span><br><span class="line">		<span class="built_in">MPI_Recv</span>(blockA, blocknum, MPI_INT, <span class="number">0</span>, <span class="number">1</span>, MPI_COMM_WORLD, &amp;s);</span><br><span class="line">		<span class="built_in">MPI_Recv</span>(blockB, blocknum, MPI_INT, <span class="number">0</span>, <span class="number">2</span>, MPI_COMM_WORLD, &amp;s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cal</span>();	<span class="comment">//计算过程</span></span><br><span class="line">	<span class="keyword">if</span> (myid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">getans</span>();</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;矩阵A为:\n&quot;;</span></span><br><span class="line">		<span class="comment">//print_matrix(MatrixA);</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;矩阵B为:\n&quot;;</span></span><br><span class="line">		<span class="comment">//print_matrix(MatrixB);</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;矩阵C=A*B为:\n&quot;;</span></span><br><span class="line">		<span class="comment">//print_matrix(MatrixC);</span></span><br><span class="line">		<span class="type">clock_t</span> end = <span class="built_in">clock</span>();	<span class="comment">//结束时间</span></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Fox乘法耗时: &quot;</span> &lt;&lt; end - start &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MPI_Send</span>(blockC, blocknum, MPI_INT, <span class="number">0</span>, <span class="number">1</span>, MPI_COMM_WORLD);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">delete</span>[] blockA;</span><br><span class="line">	<span class="keyword">delete</span>[] blockB;</span><br><span class="line">	<span class="keyword">delete</span>[] blockC;</span><br><span class="line">	<span class="keyword">delete</span>[] tmpa;</span><br><span class="line">	<span class="keyword">delete</span>[] tmpb;</span><br><span class="line">	<span class="built_in">MPI_Barrier</span>(MPI_COMM_WORLD);</span><br><span class="line">	<span class="built_in">MPI_Finalize</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「csu_xiji」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/xiji333/article/details/106713440</span></span><br></pre></td></tr></table></figure>
<h1 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h1><h2 id="串行优化"><a href="#串行优化" class="headerlink" title="串行优化"></a>串行优化</h2><p>作业提供的稀疏矩阵格式为常见的CSR存储格式。最简单的naive写法，可不做预处理，简单地对每一行进行遍历，如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">spmv</span><span class="params">(<span class="type">dist_matrix_t</span> *mat, <span class="type">const</span> <span class="type">data_t</span>* x, <span class="type">data_t</span>* y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = mat-&gt;global_m;</span><br><span class="line">    <span class="type">index_t</span> *r_pos = mat-&gt;r_pos;</span><br><span class="line">    <span class="type">index_t</span> *c_idx = mat-&gt;c_idx;</span><br><span class="line">    <span class="type">data_t</span> *values = mat-&gt;values;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> p, begin = r_pos[i], end = r_pos[i+<span class="number">1</span>];</span><br><span class="line">        <span class="type">data_t</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(p = begin; p &lt; end; ++p) &#123;</span><br><span class="line">            <span class="type">int</span> j = c_idx[p];</span><br><span class="line">            s += values[p] * x[j];</span><br><span class="line">        &#125;</span><br><span class="line">        y[i] = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="向量化编译选项"><a href="#向量化编译选项" class="headerlink" title="向量化编译选项"></a>向量化编译选项</h2><p>对于大部分代码，都可以首先“无脑”地加上自动向量化的编译选项，看看效果如何。-O3 -fomit-frame-pointer -march=armv8-a -ffast-math的编译选项加上后，效果还是相当明显的。</p>
<h2 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h2><p>对于串行程序优化，循环展开是常用的方法。将最内层的p循环按步长为4展开，这种写法（下图中所有注释对应成一套）实际上跟用intrinsics的向量化指令（下图中没有注释的对应成一套，arm v8架构的neon intrinsics指令）是效果等价的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">spmv</span><span class="params">(<span class="type">dist_matrix_t</span> * mat, <span class="type">const</span> <span class="type">data_t</span> * x, <span class="type">data_t</span>* y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = mat-&gt;global_m;</span><br><span class="line">    <span class="type">index_t</span> *r_pos = mat-&gt;r_pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> cnt = r_pos[i+<span class="number">1</span>] - r_pos[i];</span><br><span class="line">        <span class="comment">// data_t s0 = 0, s1 = 0, s2 = 0, s3 = 0;</span></span><br><span class="line">        <span class="type">float32x4_t</span> temp, matrix, vector; temp = <span class="built_in">vdupq_n_f32</span>(<span class="number">0.0</span>); <span class="type">data_t</span> s0 = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> p, max_4p = cnt &amp; (~<span class="number">3</span>);</span><br><span class="line">        <span class="type">data_t</span> * values = mat-&gt;values + r_pos[i];</span><br><span class="line">        <span class="type">index_t</span> * c_idx = mat-&gt;c_idx + r_pos[i];</span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; max_4p; p += <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">int</span> j0 = c_idx[p  ];</span><br><span class="line">            <span class="type">int</span> j1 = c_idx[p+<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> j2 = c_idx[p+<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> j3 = c_idx[p+<span class="number">3</span>];</span><br><span class="line">            <span class="comment">// s0 += values[p  ] * x[j0];</span></span><br><span class="line">            <span class="comment">// s1 += values[p+1] * x[j1];</span></span><br><span class="line">            <span class="comment">// s2 += values[p+2] * x[j2];</span></span><br><span class="line">            <span class="comment">// s3 += values[p+3] * x[j3];</span></span><br><span class="line">            matrix = <span class="built_in">vld1q_f32</span>(values + p);</span><br><span class="line">            vector = <span class="built_in">vld1q_lane_f32</span>(x + j0, vector, <span class="number">0</span>);</span><br><span class="line">            vector = <span class="built_in">vld1q_lane_f32</span>(x + j1, vector, <span class="number">1</span>);</span><br><span class="line">            vector = <span class="built_in">vld1q_lane_f32</span>(x + j2, vector, <span class="number">2</span>);</span><br><span class="line">            vector = <span class="built_in">vld1q_lane_f32</span>(x + j3, vector, <span class="number">3</span>);</span><br><span class="line">            temp   = <span class="built_in">vmlaq_f32</span>(temp, matrix, vector);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; p &lt; cnt; p++) &#123;</span><br><span class="line">            <span class="type">int</span> j0 = c_idx[p];</span><br><span class="line">            s0 += values[p] * x[j0];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// y[i] = s0 + s1 + s2 + s3;</span></span><br><span class="line">        y[i] = s0 + <span class="built_in">vgetq_lane_f32</span>(temp, <span class="number">0</span>) + <span class="built_in">vgetq_lane_f32</span>(temp, <span class="number">1</span>) + <span class="built_in">vgetq_lane_f32</span>(temp, <span class="number">2</span>) + <span class="built_in">vgetq_lane_f32</span>(temp, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实理论上来说，稀疏矩阵计算应该是memory bound的类型，循环展开这种提高SIMD效率的优化应该是起不到什么作用的。但在这里大部分算例效果有提升，小部分算例没什么效果甚至有一点倒退。除了上述两者，还尝试了内存对齐、消除指针别名等常用方法，但用在此处后发现并没有什么明显的效果。</p>
<h2 id="CSRL格式"><a href="#CSRL格式" class="headerlink" title="CSRL格式"></a>CSRL格式</h2><p>本部分详细介绍可以参见刘芳芳、杨超等的文章。CSRL格式适用于具有局部性特征的矩阵，通过对该格式的SpMV进行向量化，使A和x的访问和计算都可以采用SIMD intrinsics来完成，提高了访问速度，进而提高性能。</p>
<p>CSRL格式相对于CSR格式的主要改进在于：对稀疏矩阵中列下标连续的非零元段，存储首个非零元的列下标及段长度。</p>
<p>因此需要四个数组（ 其中矩阵A是mxn矩阵，有nnz个非零元，有nzseg个非零元段）：</p>
<ul>
<li><code>val[nnz]</code>：记录每个非零元的值</li>
<li><code>jas[nnz]</code>：记录每个非零元段的首个非零元所在的列下标</li>
<li><code>jan[nnz]</code>：记录每个非零元段的段长度</li>
<li><code>ptr[m+1]</code>：记录每行的第一个非零元段的索引，其中ptr[m]=nzseg+1</li>
</ul>
<h2 id="分块COO格式"><a href="#分块COO格式" class="headerlink" title="分块COO格式"></a>分块COO格式</h2><p>COO格式是更为简单直接的格式，对于每个非零元直接存储其行索引、列索引和值，即一个三元组（r_idx, c_idx, values）。虽然看起来比CSR格式要多存许多行索引，但它对于高度稀疏的矩阵而言是有利的。最极端地，对于只有一个非零元的稀疏矩阵，COO格式只需要3个数，而CSR格式需要m+1+2个数（m为矩阵行数）。所以COO格式对于分块后的小矩阵存储较为有利。</p>
<p>更有利的是，当分拆成小矩阵后，小矩阵的维度可能小于65536（uint16_t可覆盖）甚至256（uint8_t可覆盖），则可以使用更低精度的无符号数来存储行索引和列索引（小矩阵内部的索引），需要计算时再加上该小矩阵的偏移量（小矩阵在原矩阵中相对于(0,0)的位置）即可，由此可以节省内存带宽，提高性能。</p>
<h2 id="基于OpenMP并行改写"><a href="#基于OpenMP并行改写" class="headerlink" title="基于OpenMP并行改写"></a>基于OpenMP并行改写</h2><p>OpenMP的并行非常直观，直接在对矩阵行的遍历上按行做任务划分和并行。如下图所示，实验发现dynamic的调度策略会非常慢。这大概是因为每一行的非零元不算很多，每个线程很快完成一行的计算，然后根据work-stealing的策略，又向调度方申请新的任务，如此频繁的询问、调度带来较大开销。因此尽可能放大并行任务的粒度（调整chunk值）。经过简单调试，static的策略性能最好。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">spmv</span><span class="params">(<span class="type">dist_matrix_t</span> *mat, <span class="type">const</span> <span class="type">data_t</span>* x, <span class="type">data_t</span>* y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = mat-&gt;global_m;</span><br><span class="line">    <span class="type">index_t</span> *r_pos = mat-&gt;r_pos;</span><br><span class="line">    <span class="meta">#<span class="keyword">pragma</span> omp parallel for schedule(static)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> cnt = r_pos[i+<span class="number">1</span>] - r_pos[i];</span><br><span class="line">        <span class="type">data_t</span> s0 = <span class="number">0</span>, s1 = <span class="number">0</span>, s2 = <span class="number">0</span>, s3 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p, max_4p = cnt &amp; (~<span class="number">3</span>);</span><br><span class="line">        <span class="type">data_t</span> * values = mat-&gt;values + r_pos[i];</span><br><span class="line">        <span class="type">index_t</span> * c_idx = mat-&gt;c_idx + r_pos[i];</span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; max_4p; p += <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">int</span> j0 = c_idx[p  ];</span><br><span class="line">            <span class="type">int</span> j1 = c_idx[p+<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> j2 = c_idx[p+<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> j3 = c_idx[p+<span class="number">3</span>];</span><br><span class="line">            s0 += values[p  ] * x[j0];</span><br><span class="line">            s1 += values[p+<span class="number">1</span>] * x[j1];</span><br><span class="line">            s2 += values[p+<span class="number">2</span>] * x[j2];</span><br><span class="line">            s3 += values[p+<span class="number">3</span>] * x[j3];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; p &lt; cnt; p++) &#123;</span><br><span class="line">            <span class="type">int</span> j0 = c_idx[p];</span><br><span class="line">            s0 += values[p] * x[j0];</span><br><span class="line">        &#125;</span><br><span class="line">        y[i] = s0 + s1 + s2 + s3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但即使如此，（在后面与MPI的对比中可见）基于OpenMP并行的效果非常差。大概的原因来自两方面：上述的线程在并行区内启动、调度和销毁的开销；以及线程-线程之间的伪共享。虽然对于向量y的伪共享，已经通过尽可能大的任务粒度、先存局部变量s0,s1,s2,s3最后再写y[i]的措施降低了，但总还是有些影响。</p>
<h2 id="基于MPI并行改写"><a href="#基于MPI并行改写" class="headerlink" title="基于MPI并行改写"></a>基于MPI并行改写</h2><p>基于MPI的并行首先要考虑负载均衡的任务划分。由于划分必须要静态的，所以还像OpenMP一样以行来做动态的任务分配（你分几行，我分几行，如此往复）显然是不行的。必须要有合理的负载分配方式。</p>
<p>平均分配矩阵各行显然是不行的，因为可能有的行非零元多，有的行少。因此可用非零元个数来做依据，尽量使每个进程分到的那些行所包括的非零元个数尽可能相近。所以在创建分布式矩阵和向量前，首先要由进程0统计矩阵的非零元信息，做出一个尽可能“公平”的划分。如下图所示。</p>
<p>虽然有一个理论上公平的均摊任务量avg_workload，但实际上不可能总是切得这么精准，使得满足avg_workload的划分刚好落在行与行之间。如果每次总是向下取整（即做得比avg_workload少一点，则最后的那个进程会累积下特别多的任务，导致负载极度不均衡。而如果每次总是向上取整（即做得比avg_workload多一点，则最后的几个进程可能会无任务可做，全程空等，但这总比前者要好得多。为了获得更合理的划分，这里采用均匀随机的方法，即进程按照进程号奇偶，交替地多做一点和少做一点。使得不至于最后有不少的进程无任务可做。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MPI_Bcast</span>(&amp;mat.global_m,   <span class="number">1</span>, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line"><span class="built_in">MPI_Bcast</span>(&amp;mat.global_nnz, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line"><span class="keyword">if</span> (p_id == <span class="number">0</span>) &#123;<span class="comment">// 进程0负责记录和分配各个进程计算的范围</span></span><br><span class="line">    p_ibeg      = (<span class="type">uint32_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">uint32_t</span>) * p_num);</span><br><span class="line">    p_local_m   = (<span class="type">uint32_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">uint32_t</span>) * p_num);</span><br><span class="line">    p_local_nnz = (<span class="type">uint32_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">uint32_t</span>) * p_num);</span><br><span class="line">    <span class="built_in">assert</span>(mat.r_pos[mat.global_m] == mat.global_nnz);</span><br><span class="line">    <span class="type">int</span> avg_workload = mat.global_nnz / p_num;<span class="comment">// 尽可能平均分</span></span><br><span class="line">    <span class="type">int</span> ptr_last, ptr_curr = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> shrink = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; p_num; p++) &#123;</span><br><span class="line">        <span class="comment">// p_ibeg[p] = (p &gt; 0) ? (--ptr_curr) : ptr_curr;</span></span><br><span class="line">        p_ibeg[p] = ptr_curr;</span><br><span class="line">        ptr_last = ptr_curr;</span><br><span class="line">        <span class="keyword">while</span> (ptr_curr &lt;= mat.global_m &amp;&amp;  mat.r_pos[ptr_curr] - mat.r_pos[ptr_last] &lt; avg_workload) </span><br><span class="line">            ptr_curr++;</span><br><span class="line">        <span class="keyword">if</span> (ptr_curr &lt;= mat.global_m) &#123;</span><br><span class="line">            <span class="comment">// 如果ptr_curr还落在有效的范围内</span></span><br><span class="line">            <span class="comment">// 此时ptr_curr减一则会比avg_workload小，但直接用avg_workload就会比avg_workload大</span></span><br><span class="line">            <span class="comment">// 因此均匀随机地取</span></span><br><span class="line">            <span class="keyword">if</span> (shrink == <span class="literal">true</span>)</span><br><span class="line">                ptr_curr--;</span><br><span class="line">            shrink = !shrink;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 后面的进程不再有工作了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> remain_p = p+<span class="number">1</span>; remain_p &lt; p_num; remain_p++) </span><br><span class="line">                p_ibeg[remain_p] = mat.global_m;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; p_num; p++) &#123;<span class="comment">// 确定每个进程负责计算的局部范围local_m，和实际有的</span></span><br><span class="line">        <span class="keyword">if</span> (p != p_num - <span class="number">1</span>) &#123;</span><br><span class="line">            p_local_m[p]   = p_ibeg[p+<span class="number">1</span>]            - p_ibeg[p];</span><br><span class="line">            p_local_nnz[p] = mat.r_pos[p_ibeg[p+<span class="number">1</span>]] - mat.r_pos[p_ibeg[p]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// p_num - 1</span></span><br><span class="line">            p_local_m[p]   = mat.global_m            - p_ibeg[p];</span><br><span class="line">            p_local_nnz[p] = mat.r_pos[mat.global_m] - mat.r_pos[p_ibeg[p]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf(&quot;p_id: %d, row_beg: %d, work_nnz: %d\n&quot;, p, p_ibeg[p], p_local_nnz[p]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0号进程负责计算的区域</span></span><br><span class="line">    mat.local_ibeg = <span class="number">0</span>;</span><br><span class="line">    mat.local_m = p_local_m[<span class="number">0</span>];</span><br><span class="line">    mat.local_nnz = p_local_nnz[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 告诉其它进程负责计算的区域</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt; p_num; p++) &#123;</span><br><span class="line">        <span class="built_in">MPI_Send</span>(&amp;p_ibeg[p]     , <span class="number">1</span>, MPI_INT, p,  <span class="number">10</span>, MPI_COMM_WORLD);<span class="comment">// tag =  10</span></span><br><span class="line">        <span class="built_in">MPI_Send</span>(&amp;p_local_m[p]  , <span class="number">1</span>, MPI_INT, p, <span class="number">110</span>, MPI_COMM_WORLD);<span class="comment">// tag = 110</span></span><br><span class="line">        <span class="built_in">MPI_Send</span>(&amp;p_local_nnz[p], <span class="number">1</span>, MPI_INT, p, <span class="number">210</span>, MPI_COMM_WORLD);<span class="comment">// tag = 210</span></span><br><span class="line">        <span class="built_in">MPI_Send</span>(&amp;mat.global_m  , <span class="number">1</span>, MPI_INT, p, <span class="number">310</span>, MPI_COMM_WORLD);<span class="comment">// tag = 310</span></span><br><span class="line">        <span class="built_in">MPI_Send</span>(&amp;mat.global_nnz, <span class="number">1</span>, MPI_INT, p, <span class="number">410</span>, MPI_COMM_WORLD);<span class="comment">// tag = 410</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>而其它进程接收到0号进程的任务分配后，按照各自的需求来开辟分布式矩阵和向量的内存空间。注意这里向量x仍然是全局的，而向量y可以是局部的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">// 其它进程负责接收</span></span><br><span class="line">    <span class="built_in">MPI_Recv</span>(&amp;mat.local_ibeg, <span class="number">1</span>, MPI_INT, <span class="number">0</span>,  <span class="number">10</span>, MPI_COMM_WORLD, &amp;status);<span class="comment">// tag =  10</span></span><br><span class="line">    <span class="built_in">MPI_Recv</span>(&amp;mat.local_m   , <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">110</span>, MPI_COMM_WORLD, &amp;status);<span class="comment">// tag = 110</span></span><br><span class="line">    <span class="built_in">MPI_Recv</span>(&amp;mat.local_nnz , <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">210</span>, MPI_COMM_WORLD, &amp;status);<span class="comment">// tag = 210</span></span><br><span class="line">    <span class="built_in">MPI_Recv</span>(&amp;mat.global_m  , <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">310</span>, MPI_COMM_WORLD, &amp;status);<span class="comment">// tag = 310</span></span><br><span class="line">    <span class="built_in">MPI_Recv</span>(&amp;mat.global_nnz, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">410</span>, MPI_COMM_WORLD, &amp;status);<span class="comment">// tag = 410</span></span><br><span class="line">    <span class="comment">// 分配矩阵内存空间</span></span><br><span class="line">    mat.r_pos = (<span class="type">index_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">index_t</span>) * (mat.local_m + <span class="number">1</span>));<span class="comment">// 按照行数+1分配正向表的r_pos空间</span></span><br><span class="line">    mat.c_idx = (<span class="type">index_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">index_t</span>) * mat.local_nnz);<span class="comment">// 按照整个矩阵的非零元数目分配非零元的列序号的存储空间</span></span><br><span class="line">    mat.values = (<span class="type">data_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">data_t</span>)  * mat.local_nnz);<span class="comment">// 按照整个矩阵的非零元数目分配非零元的数据的存储空间</span></span><br><span class="line">    <span class="comment">// 分配向量内存空间：注意！右端向量x仍然是全局的！只是结果向量是只开一部分</span></span><br><span class="line">    x = (<span class="type">data_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">data_t</span>) * mat.global_m);</span><br><span class="line">    y = (<span class="type">data_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">data_t</span>) * mat.local_m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开辟好内存空间后，由进程0（因为只有它读入了文件中的数据）向其它进程分发数据。此处需要注意因为对矩阵的行做了划分（前面进程的数据相当于抛弃掉了），各个进程记录每行数据存储位置的r_pos需要做一个偏移。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p_id == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">1</span>; p &lt; p_num; p++) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot; Sending for %d\n&quot;, p);</span></span><br><span class="line">        <span class="built_in">MPI_Send</span>(&amp;mat.r_pos[p_ibeg[p]]            , p_local_m[p]  , MPI_UNSIGNED, p,  <span class="number">10</span>, MPI_COMM_WORLD);</span><br><span class="line">        <span class="built_in">MPI_Send</span>(&amp;mat.c_idx[mat.r_pos[p_ibeg[p]]] , p_local_nnz[p], MPI_UNSIGNED, p, <span class="number">110</span>, MPI_COMM_WORLD);</span><br><span class="line">        <span class="built_in">MPI_Send</span>(&amp;mat.values[mat.r_pos[p_ibeg[p]]], p_local_nnz[p], MPI_DATA,     p, <span class="number">210</span>, MPI_COMM_WORLD);</span><br><span class="line">        <span class="comment">// MPI_Send(&amp;x[p_ibeg[p]]                    , p_local_m[p]  , MPI_DATA,     p, 310, MPI_COMM_WORLD);</span></span><br><span class="line">        <span class="built_in">MPI_Send</span>(&amp;x[<span class="number">0</span>]                            , mat.global_m  , MPI_DATA,     p, <span class="number">310</span>, MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">MPI_Recv</span>(&amp;mat.r_pos[<span class="number">0</span>],  mat.local_m  , MPI_UNSIGNED, <span class="number">0</span>,  <span class="number">10</span>, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">    <span class="built_in">MPI_Recv</span>(&amp;mat.c_idx[<span class="number">0</span>],  mat.local_nnz, MPI_UNSIGNED, <span class="number">0</span>, <span class="number">110</span>, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">    <span class="built_in">MPI_Recv</span>(&amp;mat.values[<span class="number">0</span>], mat.local_nnz, MPI_DATA,     <span class="number">0</span>, <span class="number">210</span>, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">    <span class="built_in">MPI_Recv</span>(&amp;x[<span class="number">0</span>],          mat.global_m , MPI_DATA,     <span class="number">0</span>, <span class="number">310</span>, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">    <span class="comment">// 其他进程的数据得到之后需要做个偏移！！！</span></span><br><span class="line">    <span class="type">uint32_t</span> r_pos_0 = mat.r_pos[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; mat.local_m; i++)</span><br><span class="line">        mat.r_pos[i] -= r_pos_0;</span><br><span class="line">    mat.r_pos[mat.local_m] = mat.local_nnz;<span class="comment">// r_pos的最后一个元素指向末尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSR混合CSRL格式"><a href="#CSR混合CSRL格式" class="headerlink" title="CSR混合CSRL格式"></a>CSR混合CSRL格式</h2><p>如前所述，CSRL格式在nzseg/nnz值很小时，性能远胜于CSR格式。但大部分情况下，CSR仍占优。因此在此采用两者混合的格式。注意到在划分为进行分布式数组后，相当于每一个进程都在做一个local_mxglobal_m的矩阵和global_m的向量的乘法，所以它们可以独立地使用CSRL格式，从预处理到计算都是互不干扰的。</p>
<p>这样的好处的优化更能“包裹”住原问题的一些奇性。比如，某个矩阵某些行很稠密、元素连成一片，很适合于CSRL格式；但也有很多行很稀疏，更适合于CSR格式。如果不做行划分，它最后只有一个nzseg/nnz值，做和不做CSRL格式的优化都是一锤子买卖，总会亏欠另一方。而行划分之后，相当于有了#procs个nzseg/nnz值，可以各自局部地决定是否要做CSRL格式的优化，具备了一点“自适应性”。这也是MPI划分相比OpenMP要更优胜的地方。在这里决定是否做CSRL格式优化的nzseg/nnz阈值为0.3，小于0.3则该进程转换成CSRL格式，否则不动。</p>
<h2 id="GPU版本（单卡）"><a href="#GPU版本（单卡）" class="headerlink" title="GPU版本（单卡）"></a>GPU版本（单卡）</h2><p>GPU版本的SpMV优化的参考资料远比CPU的丰富。作业也只要求做CPU或GPU中一种，因此这里文字介绍较为简单。各种方法的原理是类似的，采用尽可能紧致的存储格式，节省带宽，提高访存效率，然后再考虑SIMD效率。</p>
<p>naive版本的算法非常直接，对矩阵做一维行划分，每一个cuda thread负责矩阵一行的计算。如下图所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">spmv_naive_kernel</span><span class="params">(<span class="type">int</span> m, <span class="type">const</span> <span class="type">uint32_t</span> *r_pos, \</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">uint32_t</span> *c_idx, <span class="type">const</span> <span class="type">data_t</span> *values, <span class="type">const</span> <span class="type">data_t</span> *x, <span class="type">data_t</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; m) &#123;</span><br><span class="line">        <span class="type">int</span> p, begin = r_pos[i], end = r_pos[i+<span class="number">1</span>];</span><br><span class="line">        <span class="type">data_t</span> s = y[i];</span><br><span class="line">        <span class="keyword">for</span>(p = begin; p &lt; end; ++p) &#123;</span><br><span class="line">            <span class="type">int</span> j = c_idx[p];</span><br><span class="line">            s += values[p] * x[j];</span><br><span class="line">        &#125;</span><br><span class="line">        y[i] = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spmv</span><span class="params">(<span class="type">dist_matrix_t</span> *mat, <span class="type">const</span> <span class="type">data_t</span>* x, <span class="type">data_t</span>* y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = mat-&gt;global_m;</span><br><span class="line">    <span class="function">dim3 <span class="title">grid_size</span> <span class="params">(ceiling(m, <span class="number">512</span>), <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">block_size</span> <span class="params">(<span class="number">512</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    spmv_naive_kernel&lt;&lt;&lt;grid_size, block_size&gt;&gt;&gt;(m, \</span><br><span class="line">        mat-&gt;gpu_r_pos, mat-&gt;gpu_c_idx, mat-&gt;gpu_values, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="稠密矩阵"><a href="#稠密矩阵" class="headerlink" title="稠密矩阵"></a>稠密矩阵</h1><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>对于naïve版本的代码，如下所示，不妨先“无脑”地加上-O3 -fomit-frame-pointer -march=armv8-a -ffast-math等编译选项来让编译器尽可能提供些自动向量化的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">square_sgemm</span> <span class="params">(<span class="type">int</span> n, <span class="type">float</span>* A, <span class="type">float</span>* B, <span class="type">float</span>* C)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* For each row i of A */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    <span class="comment">/* For each column j of B */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)  &#123;</span><br><span class="line">      <span class="comment">/* Compute C(i,j) */</span></span><br><span class="line">      <span class="type">float</span> cij = C[i+j*n];</span><br><span class="line">      <span class="keyword">for</span>( <span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++ )</span><br><span class="line">        cij += A[i+k*n] * B[k+j*n];</span><br><span class="line">      C[i+j*n] = cij;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅仅是如此，在不同规模的算例上性能就已经有2~10倍的提升，n每逢4的倍数便有显著的性能下降，这是cache thrashing导致的。可做半定量分析：课程集群L1 cache为64B/line，4路组相联，256个组，可知地址低6位为Offset，中间8位为Index，高位为Tag。N-way set associativity只是提供了conflict miss时的“容错性”，因此不失一般性，假定为direct-mapped来分析。地址每隔2^14B就会拥有相同的Index而被映射到同一个set上，对于单精度浮点数而言就是4096个数，因此当n满足(n*m)%4096==0时（m=1,2,…,n-1），就会在一轮k维的循环中产生cache conflict miss，m就是冲突发生时两个B元素相隔的行数。因此冲突频率随n增大而增大，当n≥4096时，就是每两次相邻的对B元素读取都会造成冲突。</p>
<h2 id="循环变换"><a href="#循环变换" class="headerlink" title="循环变换"></a>循环变换</h2><p>注意到在naïve的代码中，由于矩阵采用列主序的存储方式，因此先行后列的方式来计算C中元素的值，虽然对B元素访存是连续的，但对于C和A矩阵的访存都是不利的。尤其在循环最内维的k维，A[i+k*n]是大跨步跳跃式访存。</p>
<p>因此可以采用对i和j维的循环交换，来发掘数据复用的空间局部性。代码如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">square_sgemm</span> <span class="params">(<span class="type">int</span> n, <span class="type">float</span>* A, <span class="type">float</span>* B, <span class="type">float</span>* C)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      <span class="keyword">register</span> <span class="type">float</span> b = B[j*n + i];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; n; p++)</span><br><span class="line">        C[j*n+p] += A[i*n+p] * b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于按列主序遍历B中元素，对于其中的每个元素b，找到它对应有贡献的C和A中的元素所在的列，进行乘加计算。最内维的p维循环对A和C都是连续的，可以有效利用向量化。由于更改循环后，在整轮最内维的p循环中，b的元素是固定不变的寄存器变量，因此不再出现步骤一中的cache conflict miss，反而是矩阵规模n每逢4的倍数就比相邻的有提升，这是因为n为4的倍数能刚好被向量化指令覆盖，而不会多出额外的数据需要标量运算。</p>
<h2 id="消除指针别名"><a href="#消除指针别名" class="headerlink" title="消除指针别名"></a>消除指针别名</h2><p>消除指针别名告诉编译器修改指针指向的内存内容只能经过该指针之手，使编译器有更大优化空间。主要方法是给函数形参中的指针添加<code>__restrict__</code>关键字。其它局部的指针变量在定义时也可用此修饰。</p>
<h2 id="循环展开-1"><a href="#循环展开-1" class="headerlink" title="循环展开"></a>循环展开</h2><p>将循环展开，同时做多列的乘加操作，即取同行不同列的B矩阵元素b0, b1, b2, b3，均与相同的A列做乘法后加到不同的C列上。代码如下所示，需要注意处理余下不足4的列。。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j, i, p;</span><br><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; ((n)&amp;(~<span class="number">3</span>)); j+=<span class="number">4</span>)<span class="comment">//for each colum j of B</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">//for each row i of B</span></span><br><span class="line">    <span class="keyword">register</span> <span class="type">float</span> b0 = <span class="built_in">B</span>(i,j);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">float</span> b1 = <span class="built_in">B</span>(i,j+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">float</span> b2 = <span class="built_in">B</span>(i,j+<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">float</span> b3 = <span class="built_in">B</span>(i,j+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> ( p = <span class="number">0</span>; p &lt; n; p++)&#123;</span><br><span class="line">      <span class="built_in">C</span>(p,j  ) += <span class="built_in">A</span>(p,i) * b0;</span><br><span class="line">      <span class="built_in">C</span>(p,j+<span class="number">1</span>) += <span class="built_in">A</span>(p,i) * b1;</span><br><span class="line">      <span class="built_in">C</span>(p,j+<span class="number">2</span>) += <span class="built_in">A</span>(p,i) * b2;</span><br><span class="line">      <span class="built_in">C</span>(p,j+<span class="number">3</span>) += <span class="built_in">A</span>(p,i) * b3;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">for</span> ( ; j &lt; n; j++)<span class="comment">//for each remaining colum j of B</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">//for each row i of B</span></span><br><span class="line">    <span class="keyword">register</span> <span class="type">float</span> b0 = <span class="built_in">B</span>(i,j);</span><br><span class="line">    <span class="keyword">for</span> ( p = <span class="number">0</span>; p &lt; n; p++)</span><br><span class="line">      <span class="built_in">C</span>(p,j  ) += <span class="built_in">A</span>(p,i  ) * b0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>实验效果显示选4列为一批做乘加效果较好，而大于4列则效果开始下降。循环展开常见的是对最内层做，优势在于循环开销（如终止条件上的分支和计数器变量的更新）的减少。至于为什么要在最外层循环做展开（而不是最内层循环），需要从访存优化的角度来看。对比上一节《循环变换》中最内层循环只有一句C[j<em>n+p] += A[i</em>n+p] <em> b;，展开后此处最内层循环有四句C(p,j ) += A(p,i) </em> b0;。注意，改写后，A(p,i)只需要载入寄存器一次，就能服务于C(p,j )，C(p,j+1)，C(p,j+2)，C(p,j+3)等的计算；而原来，相同的A[i<em>n+p]值需要为每个C[j</em>n+p]加载一次。因此，外层循环的展开将矩阵A元素加载次数减少了nb倍（nb为循环展开的项数，这里是4）。</p>
<h2 id="内存对齐和简单Blocking"><a href="#内存对齐和简单Blocking" class="headerlink" title="内存对齐和简单Blocking"></a>内存对齐和简单Blocking</h2><p>利用分块技术提高计算访存比获得更高的性能是常用的优化手段。从之前的代码来看，有三层循环（从外到内依次是j -&gt; i -&gt; p），因此可以在这3个维度上采取分块，分别设为SET_J_BLOCK_SIZE, SET_I_BLOCK_SIZE, SET_P_BLOCK_SIZE。越内维访存越连续，因此设的分块大小更大。此处同时配合内存对齐的手段，是因为对于每一个分块矩阵的乘法，单独将A和B拷贝到一块对齐的连续的内存A_local和B_local中，计算结果存到同样对齐的连续的C_local中。一个好处是A_local和B_local矩阵在拷贝时已经预热，放进了CPU的cache里；另一个好处是在真正计算时，读取和存储都是连续的，提高了cache效率。将一块realMxrealN大小的矩阵拷贝到setMxsetN大小的内存中的代码如下所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> C_local[SET_P_BLOCK_SIZE*SET_J_BLOCK_SIZE] __attribute__((<span class="built_in">aligned</span>(<span class="number">64</span>)));</span><br><span class="line"><span class="type">float</span> A_local[SET_P_BLOCK_SIZE*SET_I_BLOCK_SIZE] __attribute__((<span class="built_in">aligned</span>(<span class="number">64</span>)));</span><br><span class="line"><span class="type">float</span> B_local[SET_I_BLOCK_SIZE*SET_J_BLOCK_SIZE] __attribute__((<span class="built_in">aligned</span>(<span class="number">64</span>)));</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">copy_into_MxN_nopadding</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> realM, <span class="type">int</span> realN, <span class="type">int</span> setM, \</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="type">float</span>* __restrict__ array, <span class="type">float</span>* __restrict__ array_local)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> local_col = <span class="number">0</span>; local_col &lt; realN; local_col++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> local_row = <span class="number">0</span>; local_row &lt; realM; local_row++)</span><br><span class="line">      array_local[local_row] = array[local_row];</span><br><span class="line">    array_local += setM;</span><br><span class="line">    array += n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体的计算逻辑如下所示，仅做了一级分块，其中计算部分类似前面步骤四中的j以步长4为单位做循环。区别在于分块后为减低寻址开销，每个分块用局部的指针 xxx_local_ptr指示当前计算的位置。拷贝分块矩阵的函数copy_into_MxN_nopadding与步骤六中的函数copy_PxI_nopadding()几乎一样。为了寻找这组最优的分块，可以通过编一个简单的Shell脚本，设置环境变量来指定各维度的分块，然后在Makefile里根据环境变量定义宏，再编译和运行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">square_sgemm</span> <span class="params">(<span class="type">int</span> n, <span class="type">float</span>* __restrict__ A, <span class="type">float</span>* __restrict__ B, <span class="type">float</span>* __restrict__ C)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j_block = <span class="number">0</span>; j_block &lt; n; j_block += SET_J_BLOCK_SIZE)&#123;<span class="comment">//对于B而言的水平划分</span></span><br><span class="line">    <span class="type">int</span> REAL_J_BLOCK_SIZE = <span class="built_in">min</span>(SET_J_BLOCK_SIZE, n - j_block);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i_block = <span class="number">0</span>; i_block &lt; n; i_block += SET_I_BLOCK_SIZE)&#123;<span class="comment">//对于B而言的垂直划分</span></span><br><span class="line">      <span class="type">int</span> REAL_I_BLOCK_SIZE = <span class="built_in">min</span>(SET_I_BLOCK_SIZE, n - i_block);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">copy_into_MxN_nopadding</span>(n, REAL_I_BLOCK_SIZE, REAL_J_BLOCK_SIZE, SET_I_BLOCK_SIZE,\</span><br><span class="line">                              B + j_block*n + i_block, B_local);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> p_block = <span class="number">0</span>; p_block &lt; n; p_block += SET_P_BLOCK_SIZE) &#123;</span><br><span class="line">        <span class="type">int</span> REAL_P_BLOCK_SIZE = <span class="built_in">min</span>(SET_P_BLOCK_SIZE, n - p_block);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">copy_into_MxN_nopadding</span>(n, REAL_P_BLOCK_SIZE, REAL_I_BLOCK_SIZE, SET_P_BLOCK_SIZE,\</span><br><span class="line">                                A + i_block*n + p_block, A_local);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// local_C清零</span></span><br><span class="line">        <span class="type">float</span> * C_local_ptr = C_local;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; REAL_J_BLOCK_SIZE; j++)&#123;<span class="comment">//拷贝的时候是部分</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; REAL_P_BLOCK_SIZE; p++)</span><br><span class="line">            C_local_ptr[p] = <span class="number">0.0</span>;</span><br><span class="line">          C_local_ptr += SET_P_BLOCK_SIZE;<span class="comment">//而指针前进的时候是全步长！</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算</span></span><br><span class="line">        <span class="type">float</span> * B_local_ptr = B_local;</span><br><span class="line">        <span class="type">float</span> * A_local_ptr = A_local;</span><br><span class="line">        C_local_ptr = C_local;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; ((REAL_J_BLOCK_SIZE)&amp;(~<span class="number">3</span>)); j+=<span class="number">4</span>)&#123;<span class="comment">//计算的时候是部分</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; REAL_I_BLOCK_SIZE; i++)&#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="type">float</span> b0 = B_local_ptr[i];</span><br><span class="line">            <span class="keyword">register</span> <span class="type">float</span> b1 = B_local_ptr[SET_I_BLOCK_SIZE + i];</span><br><span class="line">            <span class="keyword">register</span> <span class="type">float</span> b2 = B_local_ptr[<span class="number">2</span>*SET_I_BLOCK_SIZE + i];</span><br><span class="line">            <span class="keyword">register</span> <span class="type">float</span> b3 = B_local_ptr[<span class="number">3</span>*SET_I_BLOCK_SIZE + i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; REAL_P_BLOCK_SIZE; p++)&#123;</span><br><span class="line">              C_local_ptr[p] += A_local_ptr[p] * b0;</span><br><span class="line">              C_local_ptr[SET_P_BLOCK_SIZE + p] += A_local_ptr[p] * b1;</span><br><span class="line">              C_local_ptr[<span class="number">2</span>*SET_P_BLOCK_SIZE + p] += A_local_ptr[p] * b2;</span><br><span class="line">              C_local_ptr[<span class="number">3</span>*SET_P_BLOCK_SIZE + p] += A_local_ptr[p] * b3;</span><br><span class="line">            &#125;</span><br><span class="line">            A_local_ptr += SET_P_BLOCK_SIZE;<span class="comment">//而指针前进的时候是全步长！</span></span><br><span class="line">          &#125;</span><br><span class="line">          A_local_ptr = A_local;<span class="comment">//A重新归位</span></span><br><span class="line">          B_local_ptr += <span class="number">4</span>*SET_I_BLOCK_SIZE;</span><br><span class="line">          C_local_ptr += <span class="number">4</span>*SET_P_BLOCK_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( ; j &lt; REAL_J_BLOCK_SIZE; j++)&#123;<span class="comment">//计算的时候是部分</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; REAL_I_BLOCK_SIZE; i++)&#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="type">float</span> b0 = B_local_ptr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; REAL_P_BLOCK_SIZE; p++)&#123;</span><br><span class="line">              C_local_ptr[p] += A_local_ptr[p] * b0;</span><br><span class="line">            &#125;</span><br><span class="line">            A_local_ptr += SET_P_BLOCK_SIZE;<span class="comment">//而指针前进的时候是全步长！</span></span><br><span class="line">          &#125;</span><br><span class="line">          A_local_ptr = A_local;<span class="comment">//A重新归位</span></span><br><span class="line">          B_local_ptr += SET_I_BLOCK_SIZE;</span><br><span class="line">          C_local_ptr += SET_P_BLOCK_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算完拷贝回去</span></span><br><span class="line">        C += j_block*n + p_block;</span><br><span class="line">        C_local_ptr = C_local;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; REAL_J_BLOCK_SIZE; j++)&#123;<span class="comment">//拷贝的时候是部分</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt; REAL_P_BLOCK_SIZE; p++)</span><br><span class="line">            C[p] += C_local_ptr[p];</span><br><span class="line">          C += n;</span><br><span class="line">          C_local_ptr += SET_P_BLOCK_SIZE;<span class="comment">//而指针前进的时候是全步长！</span></span><br><span class="line">        &#125;</span><br><span class="line">        C -= (j_block+REAL_J_BLOCK_SIZE)*n + p_block;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两级Blocking-转置重组"><a href="#两级Blocking-转置重组" class="headerlink" title="两级Blocking+转置重组"></a>两级Blocking+转置重组</h2><p>为了更细致的优化，可以做二级分块，在原有基础上，在拷贝出来的对齐且连续的A_local和B_local内做进一步的分块，每次计算一个KERNEL_SIZE_ROW x KERNEL_SIZE_COL大小的矩阵乘法。需要说明的是，此部分二级分块的内容参考了Github上的代码，改写融入到原有一级分块的框架中。由于使用了arm neon的intrinsics，每次一次性对A_local和C_local内的4个浮点数操作，故在此处拷贝A和B时使用padding 0来补齐原矩阵分块无法填满A_local和B_local的地方。下图在一级分块中调用二级分块的矩阵乘法subblock_sgemm()函数。类似地，下图的二级分块的乘法调用最内核的sgemm_kernel()完成固定大小的KERNEL_SIZE的小矩阵乘法。此处设置KERNEL_SIZE_ROW = KERNEL_SIZE_COL=8.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">subblock_sgemm</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> REAL_P_BLOCK_SIZE, <span class="type">int</span> REAL_J_BLOCK_SIZE, \</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">int</span> REAL_I_BLOCK_SIZE, <span class="type">float</span> * C)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> subj = <span class="number">0</span>; subj &lt; REAL_J_BLOCK_SIZE; subj += KERNEL_SIZE_COL) &#123;</span><br><span class="line">    <span class="type">int</span> subj_block_size = <span class="built_in">min</span>(KERNEL_SIZE_COL, REAL_J_BLOCK_SIZE - subj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> subp = <span class="number">0</span>; subp &lt; REAL_P_BLOCK_SIZE; subp += KERNEL_SIZE_ROW) &#123;</span><br><span class="line">      <span class="type">int</span> subp_block_size = <span class="built_in">min</span>(KERNEL_SIZE_ROW, REAL_P_BLOCK_SIZE - subp);</span><br><span class="line"></span><br><span class="line">      <span class="type">float</span> * <span class="type">const</span> restrict C_ptr = C + subj*n + subp;</span><br><span class="line">      <span class="keyword">if</span> (subp_block_size==KERNEL_SIZE_ROW &amp;&amp; subj_block_size==KERNEL_SIZE_COL)</span><br><span class="line">        <span class="built_in">sgemm_kernel</span>(REAL_I_BLOCK_SIZE, A_local + subp*REAL_I_BLOCK_SIZE, \</span><br><span class="line">                     B_local + subj*REAL_I_BLOCK_SIZE, C_ptr, <span class="number">1</span>, n);</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">sgemm_kernel</span>(REAL_I_BLOCK_SIZE, A_local + subp*REAL_I_BLOCK_SIZE, \</span><br><span class="line">                     B_local + subj*REAL_I_BLOCK_SIZE, C_buffer, <span class="number">0</span>, KERNEL_SIZE_ROW);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; subj_block_size; j++)</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; subp_block_size; i++)</span><br><span class="line">            C_ptr[n*j + i] += C_buffer[j*KERNEL_SIZE_ROW + i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">square_sgemm</span><span class="params">(<span class="type">int</span> n, <span class="type">float</span>* __restrict__ A, <span class="type">float</span>* __restrict__ B, <span class="type">float</span>* __restrict__ C)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j_block = <span class="number">0</span>; j_block &lt; n; j_block += SET_J_BLOCK_SIZE)&#123;<span class="comment">//对于B而言的水平划分</span></span><br><span class="line">    <span class="type">int</span> REAL_J_BLOCK_SIZE = <span class="built_in">min</span>(SET_J_BLOCK_SIZE, n - j_block);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i_block = <span class="number">0</span>; i_block &lt; n; i_block += SET_I_BLOCK_SIZE)&#123;<span class="comment">//对于B而言的垂直划分</span></span><br><span class="line">      <span class="type">int</span> REAL_I_BLOCK_SIZE = <span class="built_in">min</span>(SET_I_BLOCK_SIZE, n - i_block);</span><br><span class="line">      <span class="comment">// 拷贝并转置B的子块到local_B</span></span><br><span class="line">      <span class="built_in">copy_transpose_B_into_IxJ</span>(n, REAL_I_BLOCK_SIZE, REAL_J_BLOCK_SIZE,\</span><br><span class="line">                                B + j_block*n + i_block, B_local);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> p_block = <span class="number">0</span>; p_block &lt; n; p_block += SET_P_BLOCK_SIZE) &#123;</span><br><span class="line">        <span class="type">int</span> REAL_P_BLOCK_SIZE = <span class="built_in">min</span>(SET_P_BLOCK_SIZE, n - p_block);</span><br><span class="line">        <span class="comment">// 拷贝A的子块到local_A</span></span><br><span class="line">        <span class="built_in">copy_A_into_PxI</span>(n, REAL_P_BLOCK_SIZE, REAL_I_BLOCK_SIZE, A + i_block*n + p_block, A_local);</span><br><span class="line">        <span class="comment">// 子块的乘法</span></span><br><span class="line">        <span class="built_in">subblock_sgemm</span>(n, REAL_P_BLOCK_SIZE, REAL_J_BLOCK_SIZE, REAL_I_BLOCK_SIZE, &amp;<span class="built_in">C</span>(p_block, j_block));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内核函数sgemm_kernel中，利用CPU提供的128bits定长寄存器，通过intrinsics指令完成SIMD操作。基本逻辑是</p>
<ul>
<li>从小分块内存加载到定长寄存器</li>
<li>乘加操作得到结果</li>
<li>结果从寄存器存储回小分块内存</li>
<li>拷回C矩阵或为补齐而设的缓冲区中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sgemm_kernel</span><span class="params">(<span class="type">int</span> REAL_I_BLOCK_SIZE, <span class="type">const</span> <span class="type">float</span>* __restrict__ a, <span class="type">const</span> <span class="type">float</span>* \</span></span></span><br><span class="line"><span class="params"><span class="function">    __restrict__ b, <span class="type">float</span>* __restrict__ CorCBuffer, <span class="type">int</span> C_direct, <span class="type">int</span> row_CorCBuffer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">float32x4_t</span> c00 = &#123;<span class="number">0</span>&#125;, c01 = &#123;<span class="number">0</span>&#125;, c02 = &#123;<span class="number">0</span>&#125;, c03 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">float32x4_t</span> c04 = &#123;<span class="number">0</span>&#125;, c05 = &#123;<span class="number">0</span>&#125;, c06 = &#123;<span class="number">0</span>&#125;, c07 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">float32x4_t</span> c40 = &#123;<span class="number">0</span>&#125;, c41 = &#123;<span class="number">0</span>&#125;, c42 = &#123;<span class="number">0</span>&#125;, c43 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">float32x4_t</span> c44 = &#123;<span class="number">0</span>&#125;, c45 = &#123;<span class="number">0</span>&#125;, c46 = &#123;<span class="number">0</span>&#125;, c47 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; REAL_I_BLOCK_SIZE; l++) &#123;</span><br><span class="line">    <span class="type">float32x4_t</span> value_a0 = <span class="built_in">vld1q_f32</span>(a + KERNEL_SIZE_ROW*l    );</span><br><span class="line">    <span class="type">float32x4_t</span> value_a4 = <span class="built_in">vld1q_f32</span>(a + KERNEL_SIZE_ROW*l + <span class="number">4</span>);</span><br><span class="line">    <span class="type">float32x4_t</span> value_b0 = <span class="built_in">vld1q_f32</span>(b + KERNEL_SIZE_COL*l    );</span><br><span class="line">    <span class="type">float32x4_t</span> value_b4 = <span class="built_in">vld1q_f32</span>(b + KERNEL_SIZE_COL*l + <span class="number">4</span>);</span><br><span class="line">    c00 = <span class="built_in">vmlaq_laneq_f32</span>(c00, value_a0, value_b0, <span class="number">0</span>);</span><br><span class="line">    c01 = <span class="built_in">vmlaq_laneq_f32</span>(c01, value_a0, value_b0, <span class="number">1</span>);</span><br><span class="line">    c02 = <span class="built_in">vmlaq_laneq_f32</span>(c02, value_a0, value_b0, <span class="number">2</span>);</span><br><span class="line">    c03 = <span class="built_in">vmlaq_laneq_f32</span>(c03, value_a0, value_b0, <span class="number">3</span>);</span><br><span class="line">    c04 = <span class="built_in">vmlaq_laneq_f32</span>(c04, value_a0, value_b4, <span class="number">0</span>);</span><br><span class="line">    c05 = <span class="built_in">vmlaq_laneq_f32</span>(c05, value_a0, value_b4, <span class="number">1</span>);</span><br><span class="line">    c06 = <span class="built_in">vmlaq_laneq_f32</span>(c06, value_a0, value_b4, <span class="number">2</span>);</span><br><span class="line">    c07 = <span class="built_in">vmlaq_laneq_f32</span>(c07, value_a0, value_b4, <span class="number">3</span>);</span><br><span class="line">    c40 = <span class="built_in">vmlaq_laneq_f32</span>(c40, value_a4, value_b0, <span class="number">0</span>);</span><br><span class="line">    c41 = <span class="built_in">vmlaq_laneq_f32</span>(c41, value_a4, value_b0, <span class="number">1</span>);</span><br><span class="line">    c42 = <span class="built_in">vmlaq_laneq_f32</span>(c42, value_a4, value_b0, <span class="number">2</span>);</span><br><span class="line">    c43 = <span class="built_in">vmlaq_laneq_f32</span>(c43, value_a4, value_b0, <span class="number">3</span>);</span><br><span class="line">    c44 = <span class="built_in">vmlaq_laneq_f32</span>(c44, value_a4, value_b4, <span class="number">0</span>);</span><br><span class="line">    c45 = <span class="built_in">vmlaq_laneq_f32</span>(c45, value_a4, value_b4, <span class="number">1</span>);</span><br><span class="line">    c46 = <span class="built_in">vmlaq_laneq_f32</span>(c46, value_a4, value_b4, <span class="number">2</span>);</span><br><span class="line">    c47 = <span class="built_in">vmlaq_laneq_f32</span>(c47, value_a4, value_b4, <span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 存到临时变量</span></span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp     , c00);</span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp + <span class="number">4</span> , c40);</span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp + <span class="number">8</span> , c01);</span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp + <span class="number">12</span>, c41);</span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp + <span class="number">16</span>, c02);</span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp + <span class="number">20</span>, c42);</span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp + <span class="number">24</span>, c03);</span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp + <span class="number">28</span>, c43);</span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp + <span class="number">32</span>, c04);</span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp + <span class="number">36</span>, c44);</span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp + <span class="number">40</span>, c05);</span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp + <span class="number">44</span>, c45);</span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp + <span class="number">48</span>, c06);</span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp + <span class="number">52</span>, c46);</span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp + <span class="number">56</span>, c07);</span><br><span class="line">  <span class="built_in">vst1q_f32</span>(tmp + <span class="number">60</span>, c47);</span><br><span class="line">  <span class="comment">// 拷贝回矩阵C或缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> (C_direct == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; KERNEL_SIZE_COL; j++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KERNEL_SIZE_ROW; i++)</span><br><span class="line">        CorCBuffer[j*row_CorCBuffer + i] = <span class="number">0.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; KERNEL_SIZE_COL; j++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KERNEL_SIZE_ROW; i++)</span><br><span class="line">      CorCBuffer[j*row_CorCBuffer + i] += tmp[j*KERNEL_SIZE_ROW + i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，原作者在这里拷贝A和B矩阵时，使元素位置重组，设计得很精妙，使得后续计算时对B_local的访存与A_local保持一致的pattern，连续高效。这部分较为难懂，按个人理解，计算逻辑的示意图如下。下图中setX即为上文提到的SET_X_BLOCK_SIZE，realX即为REAL_X_BLOCK_SIZE，而KernelRow和KernelCol分别为KERNEL_SIZE_ROW和KERNEL_SIZE_COL。</p>
<p><img src="/img/ea8dc9d59c4e446db98396f10fc56540.png" alt=""></p>
<p>拷贝并重组存储顺序的代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">copy_PxI_nopadding</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> REAL_I_BLOCK_SIZE, \</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> <span class="type">float</span>* __restrict__ A, <span class="type">float</span>* __restrict__ A_local)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> local_col = <span class="number">0</span>; local_col &lt; REAL_I_BLOCK_SIZE; local_col++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> local_row = <span class="number">0</span>; local_row &lt; KERNEL_SIZE_ROW; local_row++)</span><br><span class="line">      A_local[local_row] = <span class="built_in">A</span>(local_row, <span class="number">0</span>);<span class="comment">//相当于把原A中一个块在内存中离散的数据拷贝成A_local中连续的一大片</span></span><br><span class="line">    A_local += KERNEL_SIZE_ROW;</span><br><span class="line">    A += n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">copy_A_into_PxI</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> REAL_P_BLOCK_SIZE, <span class="type">int</span> REAL_I_BLOCK_SIZE, \</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> <span class="type">float</span>* __restrict__ A, <span class="type">float</span>* __restrict__ A_local)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> part = REAL_P_BLOCK_SIZE / KERNEL_SIZE_ROW;</span><br><span class="line">  <span class="type">int</span> remain_rows = REAL_P_BLOCK_SIZE % KERNEL_SIZE_ROW;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> pa = <span class="number">0</span>; pa &lt; part; pa++)&#123;</span><br><span class="line">    <span class="built_in">copy_PxI_nopadding</span>(n, REAL_I_BLOCK_SIZE, A, A_local);</span><br><span class="line">    A_local += KERNEL_SIZE_ROW * REAL_I_BLOCK_SIZE;</span><br><span class="line">    A += KERNEL_SIZE_ROW;<span class="comment">//指针指向下一个块</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (remain_rows &gt; <span class="number">0</span>) &#123;<span class="comment">//余下还有</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> local_col = <span class="number">0</span>; local_col &lt; REAL_I_BLOCK_SIZE; local_col++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> local_row = <span class="number">0</span>; local_row &lt; remain_rows; local_row++)</span><br><span class="line">        A_local[local_row] = <span class="built_in">A</span>(local_row, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> local_row = remain_rows; local_row &lt; KERNEL_SIZE_ROW; local_row++)</span><br><span class="line">        A_local[local_row] = <span class="number">0.0</span>;</span><br><span class="line">      A_local += KERNEL_SIZE_ROW;</span><br><span class="line">      A += n;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">copy_transpose_IxJ_nopadding</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> REAL_I_BLOCK_SIZE, \</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> <span class="type">float</span>* __restrict__ B, <span class="type">float</span>* __restrict__ B_local)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> local_col = <span class="number">0</span>; local_col &lt; REAL_I_BLOCK_SIZE; local_col++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> local_row = <span class="number">0</span>; local_row &lt; KERNEL_SIZE_COL; local_row++)</span><br><span class="line">      B_local[local_row] = <span class="built_in">B</span>(<span class="number">0</span>, local_row);</span><br><span class="line">    B_local += KERNEL_SIZE_COL;</span><br><span class="line">    B += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">copy_transpose_B_into_IxJ</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> REAL_I_BLOCK_SIZE, <span class="type">int</span> REAL_J_BLOCK_SIZE,\</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> <span class="type">float</span>* __restrict__ B, <span class="type">float</span>* __restrict__ B_local)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> part = REAL_J_BLOCK_SIZE / KERNEL_SIZE_COL;</span><br><span class="line">  <span class="type">int</span> remain_cols = REAL_J_BLOCK_SIZE % KERNEL_SIZE_COL;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> pa = <span class="number">0</span>; pa &lt; part; pa++)&#123;</span><br><span class="line">    <span class="built_in">copy_transpose_IxJ_nopadding</span>(n, REAL_I_BLOCK_SIZE, B, B_local);</span><br><span class="line">    B_local += KERNEL_SIZE_COL * REAL_I_BLOCK_SIZE;</span><br><span class="line">    B += KERNEL_SIZE_COL * n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (remain_cols &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> local_col = <span class="number">0</span>; local_col &lt; REAL_I_BLOCK_SIZE; local_col++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> local_row = <span class="number">0</span>; local_row &lt; remain_cols; local_row++)</span><br><span class="line">        B_local[local_row] = <span class="built_in">B</span>(<span class="number">0</span>, local_row);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> local_row = remain_cols; local_row &lt; KERNEL_SIZE_COL; local_row++)</span><br><span class="line">        B_local[local_row] = <span class="number">0.0</span>;</span><br><span class="line">      B_local += KERNEL_SIZE_COL;</span><br><span class="line">      B += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/zongy17/sgemm-serial">https://github.com/zongy17/sgemm-serial</a></p>
<h1 id="Cannon算法"><a href="#Cannon算法" class="headerlink" title="Cannon算法"></a>Cannon算法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="/img/20180618234922517.png" alt=""></p>
<h2 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h2><p><img src="/img/20180618234934866.png" alt=""></p>
<h2 id="算法设计方法和模式"><a href="#算法设计方法和模式" class="headerlink" title="算法设计方法和模式"></a>算法设计方法和模式</h2><h3 id="任务划分"><a href="#任务划分" class="headerlink" title="任务划分"></a>任务划分</h3><p>根据矩阵乘法公式中的累加计算的可分离性，将参与计算的两个矩阵分解成p个小矩阵块(共有p个计算节点)，每个节点只进行局部的小矩阵乘法，最终计算结束后将局部的小结果矩阵发送回Master节点。<br><img src="/img/20180618234956932.png" alt=""></p>
<h3 id="通讯分析"><a href="#通讯分析" class="headerlink" title="通讯分析"></a>通讯分析</h3><p>由于算法在下发任务和收集结果的时候采用了主从模式，所以使用了Master-Worker的全局通讯，该部分通讯由于发送方只有一个0号线程，所以无法并行执行，只能串行执行。同时，在迭代进行小矩阵运算时，各计算节点之间也需要交换矩阵，进行了结构化通讯。该部分通讯由于通讯的局部特性，可以并行执行，能够提高效率。</p>
<h3 id="任务组合"><a href="#任务组合" class="headerlink" title="任务组合"></a>任务组合</h3><p>每个节点负责一个小矩阵的串行计算，同时负责小矩阵之间的通讯传递。</p>
<h3 id="处理器映射"><a href="#处理器映射" class="headerlink" title="处理器映射"></a>处理器映射</h3><p>由于任务的划分个数等于处理器个数，所以在组合任务的同时完成了处理器映射。</p>
<p>Cannon算法采用了主从模式的同时也采用了分而治之的模式。一方面，0号线程作为Master，负责矩阵A和矩阵B以及矩阵C的I/O，也负责小矩阵的分发和结果的聚集。而其他节点作为Worker进行本地的小矩阵串行乘法计算。另一方面，Cannon算法将两个大矩阵的乘法运算分解为若干各小矩阵的乘法运算，最终计算结束后，将计算结果聚集回来，也采用了分而治之的思想。cannon算法不仅实现了矩阵乘法运算的并行化，也减少了分块矩阵乘法的局部存储量，节省了节点的内存开销。 </p>
<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>设计算的是一个<code>n*n</code>的矩阵乘一个<code>n*n</code>的矩阵，共有p个节点，那么Cannon算法的时间复杂度计算如下：</p>
<p>矩阵乘加的时间由于采用了并行化，所以所需时间为： <code>n^3 / p</code></p>
<p>若不考虑节点延迟时间，设节点之间通讯的启动时间为ti，传输每个数字的时间为tw，则在两个节点间传输一个子矩阵的时间是：<code>ti + n^2*tw / p</code></p>
<p>所以节点之间传输子矩阵所需的时间为：<code>2*sqrt(p)*(ti + n^2*tw / p)</code></p>
<p>综上，cannon算法总的所需时间为：<code>2*sqrt(p)*(ti + n^2*tw / p) + n^3 / p</code></p>
<p>时间复杂度：<code>O(n^3 / p)</code><br>空间复杂度：<code>O(n^2)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;mpi.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">int myrank, p;</span><br><span class="line"></span><br><span class="line">// Compute C = A*B. A is a n1*n2 matrix. B is a n2*n3 matrix.</span><br><span class="line">void matmul(double* A, double* B, double* C, int n1, int n2, int n3)//做矩阵乘法，结果累加到C矩阵中(需要保证C矩阵初始化过)</span><br><span class="line">&#123;</span><br><span class="line">  int i,j,k;</span><br><span class="line">  //简单的串行矩阵乘法</span><br><span class="line">  for (i = 0; i &lt; n1; i++) &#123;</span><br><span class="line">    for (j = 0; j &lt; n3; j++) &#123;</span><br><span class="line">      for (k = 0; k &lt; n2; k++) &#123;</span><br><span class="line">        C[i*n3+j]+=A[i*n2+k]*B[k*n3+j];</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int setup(int argc,char**argv,double** fstreama,double** fstreamb,int* dim)</span><br><span class="line">&#123;</span><br><span class="line">	FILE* fha;</span><br><span class="line">	FILE* fhb;</span><br><span class="line">	int n1,n2,n3;</span><br><span class="line">	int re=1;</span><br><span class="line">	if (!(fha = fopen(argv[1], &quot;r&quot;))) //打开存储A矩阵的文件</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Can&#x27;t open file %s, Errno=%d\n&quot;, argv[1], 1);//打开失败输出信息</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(fread(&amp;n1,sizeof(int),1,fha)==0)//读取矩阵的行数</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;fread error1!\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(fread(&amp;n2,sizeof(int),1,fha)==0)//读取矩阵的列数</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;fread error2!\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	*fstreama = (double *) malloc (n1*n2*sizeof(double));//为矩阵申请内存</span><br><span class="line">	if(fread(*fstreama,sizeof(double),n1*n2,fha)==0)//读取矩阵内容</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;fread error3!\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fclose(fha);//关闭矩阵文件</span><br><span class="line">	</span><br><span class="line">	if (!(fhb = fopen(argv[2], &quot;r&quot;))) //打开存储A矩阵的文件</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Can&#x27;t open file %s, Errno=%d\n&quot;, argv[2], 2);//打开失败输出信息</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(fread(&amp;n2,sizeof(int),1,fhb)==0)//读取矩阵的行数</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;fread error4!\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(fread(&amp;n3,sizeof(int),1,fhb)==0)//读取矩阵的列数</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;fread error5!\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	*fstreamb = (double *) malloc (n2*n3*sizeof(double));//为矩阵申请内存</span><br><span class="line">	if(fread(*fstreamb,sizeof(double),n2*n3,fhb)==0)//读取矩阵内容</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;fread error6!\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fclose(fhb);//关闭矩阵文件	</span><br><span class="line">	dim[0] = n1;//返回矩阵的大小参数</span><br><span class="line">	dim[1] = n2;//返回矩阵的大小参数</span><br><span class="line">	dim[2] = n3;//返回矩阵的大小参数</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void scatter_matrix(double* matrixbuf, int rows, int cols, double* local_matrix, int rootp)//将矩阵划分为小矩阵块并分发到各个节点</span><br><span class="line">&#123;</span><br><span class="line">	int row, column, i, j, count;</span><br><span class="line">	int maxrows_block = (rows + rootp - 1)/rootp;//小A矩阵块行数的最大值</span><br><span class="line">	int maxcols_block = (cols + rootp - 1)/rootp;//小矩阵块列数的最大值</span><br><span class="line">	double * matrixbuf2 = NULL;//用来格式化原矩阵的缓冲区</span><br><span class="line">	MPI_Status status;//返回通信的状态</span><br><span class="line">	</span><br><span class="line">	if(myrank == 0)//0号线程</span><br><span class="line">	&#123;</span><br><span class="line">		if(!(matrixbuf2 = (double *)malloc(maxcols_block*maxrows_block*rootp*rootp*sizeof(double))))//为缓冲区申请内存</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;Memory allocation failed\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		//将矩阵转化为按块连续存放的形式，方便分发每块小矩阵，同时对于边界没有对齐的小矩阵，补零对齐，方便计算</span><br><span class="line">		count = 0;</span><br><span class="line">		for (i = 0; i &lt; rootp; i++)&#123;</span><br><span class="line">			for (j = 0; j &lt; rootp; j++)&#123;</span><br><span class="line">				if(i!=(rootp-1)&amp;&amp;j==(rootp-1))//特殊处理除了最后一行以外的最后一列</span><br><span class="line">				&#123;</span><br><span class="line">					for (row = 0; row &lt; maxrows_block; row++)&#123;</span><br><span class="line">						for (column = 0; column &lt; maxcols_block; column++)&#123;</span><br><span class="line">							if((j * maxcols_block + column)&gt;=cols)//补零对齐</span><br><span class="line">							&#123;</span><br><span class="line">								matrixbuf2[count] = 0;</span><br><span class="line">							&#125;else&#123;</span><br><span class="line">								matrixbuf2[count] = matrixbuf[(i * maxrows_block + row ) * cols +j * maxcols_block + column];</span><br><span class="line">							&#125;</span><br><span class="line">							count++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;else if(i==(rootp-1)&amp;&amp;j!=(rootp-1))//特殊处理除了最后一列以外的最后一行</span><br><span class="line">				&#123;</span><br><span class="line">					for (row = 0; row &lt; maxrows_block; row++)&#123;</span><br><span class="line">						for (column = 0; column &lt; maxcols_block; column++)&#123;</span><br><span class="line">							if((i * maxrows_block + row)&gt;=rows)//补零对齐</span><br><span class="line">							&#123;</span><br><span class="line">								matrixbuf2[count] = 0;</span><br><span class="line">							&#125;else&#123;</span><br><span class="line">								matrixbuf2[count] = matrixbuf[(i * maxrows_block + row)*cols + j * maxcols_block + column];</span><br><span class="line">							&#125;</span><br><span class="line">							count++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;else if(i==(rootp-1)&amp;&amp;j==(rootp-1))//特殊处理最后一列最后一行的那个块</span><br><span class="line">				&#123;</span><br><span class="line">					for (row = 0; row &lt; maxrows_block; row++)&#123;</span><br><span class="line">						for (column = 0; column &lt; maxcols_block; column++)&#123;</span><br><span class="line">							if(((j * maxcols_block + column)&gt;=cols) || ((i * maxrows_block + row)&gt;=rows))//补零对齐</span><br><span class="line">							&#123;</span><br><span class="line">								matrixbuf2[count] = 0;</span><br><span class="line">							&#125;else&#123;</span><br><span class="line">								matrixbuf2[count] = matrixbuf[(i * maxrows_block + row) * cols + j * maxcols_block + column];</span><br><span class="line">							&#125;</span><br><span class="line">							count++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;else&#123;//普通的块</span><br><span class="line">					for (row = 0; row &lt; maxrows_block; row++)&#123;</span><br><span class="line">						for (column = 0; column &lt; maxcols_block; column++)&#123;</span><br><span class="line">							matrixbuf2[count] = matrixbuf[(i * maxrows_block + row)*cols + j * maxcols_block + column];</span><br><span class="line">							count++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(count!=maxcols_block*maxrows_block*rootp*rootp)//检查是否出错</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;scatter_matrix error!\n&quot;);</span><br><span class="line">			return ;</span><br><span class="line">		&#125;</span><br><span class="line">		//将属于本地的那个块留下来</span><br><span class="line">		for(i = 0; i &lt; maxrows_block*maxcols_block; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			local_matrix[i] = matrixbuf2[i];</span><br><span class="line">		&#125;</span><br><span class="line">		//分发其他块到对应的线程</span><br><span class="line">		for(i = 1; i &lt; rootp*rootp; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			MPI_Send((matrixbuf2 + (i * maxcols_block * maxrows_block)), maxcols_block * maxrows_block, MPI_DOUBLE, i, 0, MPI_COMM_WORLD);</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125; else &#123;//非0号线程</span><br><span class="line">		MPI_Recv(local_matrix, maxcols_block * maxrows_block , MPI_DOUBLE, 0, 0, MPI_COMM_WORLD, &amp;status);//非零线程接受0线程发送的小矩阵块</span><br><span class="line">	&#125;</span><br><span class="line">	if(matrixbuf2!=NULL)&#123;//释放缓冲区</span><br><span class="line">		free(matrixbuf2);</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">//A and bufA : n1_block*n2_block;  B and bufB : n2_block*n3_block</span><br><span class="line">//进行cannon算法，各个节点在本地进行矩阵乘法，并交换矩阵块，进行循环，直到计算完毕</span><br><span class="line">void cannon(double* A, double* bufA, double* B, double* bufB, double* C, int n1_block, int n2_block, int n3_block, int rootp)</span><br><span class="line">&#123;</span><br><span class="line">	MPI_Request send_a_req, send_b_req;</span><br><span class="line">	MPI_Status send_a_status, send_b_status, recv_a_status, recv_b_status;</span><br><span class="line">	int cycle_count;</span><br><span class="line">	int rank_next_a,rank_next_b;</span><br><span class="line">	int rank_last_a,rank_last_b;</span><br><span class="line">	int curRowP,curColP,i,j;</span><br><span class="line">	int tag=0;//表示当前正确数据再A中还是bufA中，0表示在A中，1表示在bufA中</span><br><span class="line">	//先初始化各个块，即A_ij循环左移i步，B_ij循环上移j步，C_ij初始化为零</span><br><span class="line">	</span><br><span class="line">	//初始化矩阵C，值全部设为0</span><br><span class="line">	for(i=0;i&lt;n1_block;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		for(j=0;j&lt;n3_block;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			C[i*n3_block+j] = 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//循环传播小矩阵</span><br><span class="line">	curRowP = myrank/rootp;//当前节点所在行</span><br><span class="line">	curColP = myrank%rootp;//当前节点所在列</span><br><span class="line">	</span><br><span class="line">	//获得左移i步后的节点号</span><br><span class="line">	if((curColP-curRowP)&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		rank_next_a = myrank+rootp-curRowP;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		rank_next_a = myrank-curRowP;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//获得上移j步后的节点号</span><br><span class="line">	if((curRowP-curColP)&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		rank_next_b = myrank -curColP*rootp + rootp*rootp;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		rank_next_b = myrank -curColP*rootp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//获得接受左移i步的节点号</span><br><span class="line">	if((curColP+curRowP)&gt;=rootp)</span><br><span class="line">	&#123;</span><br><span class="line">		rank_last_a = myrank+curRowP-rootp;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		rank_last_a = myrank+curRowP;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//获得接受上移j步的节点号</span><br><span class="line">	if((curRowP+curColP)&gt;=rootp)</span><br><span class="line">	&#123;</span><br><span class="line">		rank_last_b = myrank + curColP*rootp - rootp*rootp;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		rank_last_b = myrank + curColP*rootp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//非阻塞发送矩阵，如果不需要移动，则直接本地memcpy</span><br><span class="line">	if(rank_next_a!=myrank)</span><br><span class="line">	&#123;</span><br><span class="line">		MPI_Isend(A, n1_block*n2_block, MPI_DOUBLE, rank_next_a, 0, MPI_COMM_WORLD, &amp;send_a_req);//非阻塞发送矩阵A，避免死锁</span><br><span class="line">	&#125;else</span><br><span class="line">	&#123;</span><br><span class="line">		memcpy(bufA, A, n1_block*n2_block*sizeof(double));//本地直接memcpy</span><br><span class="line">	&#125;</span><br><span class="line">	if(rank_next_b!=myrank)</span><br><span class="line">	&#123;</span><br><span class="line">		MPI_Isend(B, n2_block*n3_block, MPI_DOUBLE, rank_next_b, 0, MPI_COMM_WORLD, &amp;send_b_req);//非阻塞发送矩阵B，避免死锁</span><br><span class="line">	&#125;else</span><br><span class="line">	&#123;</span><br><span class="line">		memcpy(bufB, B, n2_block*n3_block*sizeof(double));//本地直接memcpy</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//阻塞接受矩阵</span><br><span class="line">	if(rank_last_a!=myrank)</span><br><span class="line">	&#123;</span><br><span class="line">		MPI_Recv(bufA, n1_block*n2_block, MPI_DOUBLE, rank_last_a, 0, MPI_COMM_WORLD, &amp;recv_a_status);//阻塞接受矩阵A</span><br><span class="line">	&#125;</span><br><span class="line">	if(rank_last_b!=myrank)</span><br><span class="line">	&#123;</span><br><span class="line">		MPI_Recv(bufB, n2_block*n3_block, MPI_DOUBLE, rank_last_b, 0, MPI_COMM_WORLD, &amp;recv_b_status);//阻塞接受矩阵B</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//阻塞等待发送矩阵结束</span><br><span class="line">	if(rank_next_a!=myrank)</span><br><span class="line">	&#123;</span><br><span class="line">		MPI_Wait(&amp;send_a_req, &amp;send_a_status);//阻塞发送矩阵A到结束</span><br><span class="line">	&#125;</span><br><span class="line">	if(rank_next_b!=myrank)</span><br><span class="line">	&#123;</span><br><span class="line">		MPI_Wait(&amp;send_b_req, &amp;send_b_status);//阻塞发送矩阵B到结束</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	MPI_Barrier(MPI_COMM_WORLD);//同步</span><br><span class="line">	tag=1;</span><br><span class="line">	if(myrank%rootp==0)//第一列的节点</span><br><span class="line">	&#123;</span><br><span class="line">		rank_next_a = myrank+rootp-1;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		rank_next_a = myrank-1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if(myrank/rootp==0)//第一行的节点</span><br><span class="line">	&#123;</span><br><span class="line">		rank_next_b = myrank+rootp*(rootp-1);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		rank_next_b = myrank - rootp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if(myrank%rootp==(rootp-1))//最后一列的节点</span><br><span class="line">	&#123;</span><br><span class="line">		rank_last_a = myrank-rootp+1;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		rank_last_a = myrank+1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if(myrank/rootp==(rootp-1))//最后一行的节点</span><br><span class="line">	&#123;</span><br><span class="line">		rank_last_b = myrank-rootp*(rootp-1);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		rank_last_b = myrank + rootp;</span><br><span class="line">	&#125;</span><br><span class="line">	//循环，每次做当前块的乘加运算，并使得A_ij循环左移1步，B_ij循环上移1步</span><br><span class="line">	for(cycle_count = 0; cycle_count &lt; rootp; cycle_count++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(tag==1)//数据在bufA中</span><br><span class="line">		&#123;</span><br><span class="line">			matmul(bufA, bufB, C, n1_block, n2_block, n3_block);//做当前节点的矩阵乘法</span><br><span class="line">			//循环传播小矩阵</span><br><span class="line">			MPI_Isend(bufA, n1_block*n2_block, MPI_DOUBLE, rank_next_a, 0, MPI_COMM_WORLD, &amp;send_a_req);//非阻塞发送矩阵A，避免死锁</span><br><span class="line">            		MPI_Isend(bufB, n2_block*n3_block, MPI_DOUBLE, rank_next_b, 0, MPI_COMM_WORLD, &amp;send_b_req);//非阻塞发送矩阵B，避免死锁</span><br><span class="line"></span><br><span class="line">            		MPI_Recv(A, n1_block*n2_block, MPI_DOUBLE, rank_last_a, 0, MPI_COMM_WORLD, &amp;recv_a_status);//阻塞接受矩阵A</span><br><span class="line">            		MPI_Recv(B, n2_block*n3_block, MPI_DOUBLE, rank_last_b, 0, MPI_COMM_WORLD, &amp;recv_b_status);//阻塞接受矩阵B</span><br><span class="line"></span><br><span class="line">            		MPI_Wait(&amp;send_a_req, &amp;send_a_status);//阻塞发送矩阵A到结束</span><br><span class="line">            		MPI_Wait(&amp;send_b_req, &amp;send_b_status);//阻塞发送矩阵B到结束</span><br><span class="line">			tag = 0;</span><br><span class="line">		&#125;else&#123;//数据在A中</span><br><span class="line">			matmul(A, B, C, n1_block, n2_block, n3_block);//做当前节点的矩阵乘法</span><br><span class="line">			//循环传播小矩阵</span><br><span class="line">			MPI_Isend(A, n1_block*n2_block, MPI_DOUBLE, rank_next_a, 0, MPI_COMM_WORLD, &amp;send_a_req);//非阻塞发送矩阵A，避免死锁</span><br><span class="line">            		MPI_Isend(B, n2_block*n3_block, MPI_DOUBLE, rank_next_b, 0, MPI_COMM_WORLD, &amp;send_b_req);//非阻塞发送矩阵B，避免死锁</span><br><span class="line"></span><br><span class="line">            		MPI_Recv(bufA, n1_block*n2_block, MPI_DOUBLE, rank_last_a, 0, MPI_COMM_WORLD, &amp;recv_a_status);//阻塞接受矩阵A</span><br><span class="line">            		MPI_Recv(bufB, n2_block*n3_block, MPI_DOUBLE, rank_last_b, 0, MPI_COMM_WORLD, &amp;recv_b_status);//阻塞接受矩阵B</span><br><span class="line"></span><br><span class="line">            		MPI_Wait(&amp;send_a_req, &amp;send_a_status);//阻塞发送矩阵A到结束</span><br><span class="line">            		MPI_Wait(&amp;send_b_req, &amp;send_b_status);//阻塞发送矩阵B到结束</span><br><span class="line">			tag = 1;</span><br><span class="line">		&#125;</span><br><span class="line">		MPI_Barrier(MPI_COMM_WORLD);//同步</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//gather_matrix((double*)(fstreamc + sizeof(int)*2), n1, n3, C, rootp);</span><br><span class="line">//将各个节点的小矩阵C收集到0号节点</span><br><span class="line">void gather_matrix(double* matrixCbuf, int rows, int cols, double* local_C, int rootp, int rows_block_pad, int cols_block_pad)</span><br><span class="line">&#123;</span><br><span class="line">	int curRow, curCol, i, j, curP;</span><br><span class="line">	MPI_Status status;</span><br><span class="line">	double * matrixC_pad = NULL;//有零填充的矩阵C</span><br><span class="line">	if(myrank == 0) &#123;//0号线程 </span><br><span class="line">		if(!(matrixC_pad = (double *)malloc(rows_block_pad*cols_block_pad*rootp*rootp*sizeof(double))))//为缓冲区申请内存</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;Memory allocation failed\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		//将本地计算结果直接复制过来</span><br><span class="line">		for(i = 0; i &lt; rows_block_pad * cols_block_pad; i++)&#123;</span><br><span class="line">			matrixC_pad[i] = local_C[i];</span><br><span class="line">		&#125;</span><br><span class="line">		//接受其他非0线程的计算结果</span><br><span class="line">		for(i = 1; i &lt; rootp*rootp; i++)&#123;</span><br><span class="line">			MPI_Recv(matrixC_pad + (i * rows_block_pad * cols_block_pad), rows_block_pad * cols_block_pad, MPI_DOUBLE, i, 0,MPI_COMM_WORLD, &amp;status);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		//重新整理矩阵C，除去零填充，并且重新整理顺序</span><br><span class="line">		for(i=0;i&lt;rows;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			for(j=0;j&lt;cols;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				curP = (i/rows_block_pad)*rootp+(j/cols_block_pad);//属于第几个节点，从0开始</span><br><span class="line">				curRow = i%rows_block_pad;//属于小矩阵的第几行</span><br><span class="line">				curCol = j%cols_block_pad;//属于小矩真的第几列</span><br><span class="line">				matrixCbuf[i * cols + j] = matrixC_pad[curP * rows_block_pad * cols_block_pad +curRow*cols_block_pad+curCol];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125; else &#123;//非0号线程</span><br><span class="line">		MPI_Send(local_C,rows_block_pad * cols_block_pad, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);//给0号线程发送计算结果</span><br><span class="line">	&#125;</span><br><span class="line">	if(matrixC_pad!=NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		free(matrixC_pad);//释放缓冲区</span><br><span class="line">	&#125;</span><br><span class="line">	return ;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">	double elapsed_time;</span><br><span class="line">	// Suppose A:n1xn2, B:n2xn3. n1~n3 are read from input files</span><br><span class="line">	int n1, n2, n3,rootp;</span><br><span class="line">	// Buffers for matrix A, B, C. Because A, B will be shifted, so they each have two buffers</span><br><span class="line">	double *A, *B, *C, *bufA, *bufB;</span><br><span class="line">	// On proc 0, buffers to cache matrix files of A, B and C</span><br><span class="line">	double *fstreama, *fstreamb;</span><br><span class="line">	char *fstreamc;</span><br><span class="line">	MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">	MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank);</span><br><span class="line">	MPI_Comm_size(MPI_COMM_WORLD, &amp;p);</span><br><span class="line">	rootp = sqrt(p);</span><br><span class="line">	if (p != rootp*rootp) &#123;</span><br><span class="line">		printf(&quot;Processor number must be a square!\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	// On proc 0, preprocess the command line, read in files for A, B and</span><br><span class="line">	// put their sizes in dim[].</span><br><span class="line">	int dim[3];</span><br><span class="line">	if (myrank == 0) &#123;//0号线程负责从文件中读取矩阵A和B以及他们的大小信息</span><br><span class="line">		if (setup(argc, argv, &amp;fstreama, &amp;fstreamb, dim)!=0) &#123;</span><br><span class="line">			MPI_Finalize(); // Something error during preprocessing</span><br><span class="line">			exit(-1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	MPI_Bcast(dim, 3, MPI_INT, 0, MPI_COMM_WORLD);//0号线程将A和B矩阵的size广播给所有线程</span><br><span class="line">	n1 = dim[0];//A： n1*n2</span><br><span class="line">	n2 = dim[1];//B:  n2*n3</span><br><span class="line">	n3 = dim[2];</span><br><span class="line"></span><br><span class="line">	// Allocate memories for A, B, C, bufA and bufB.</span><br><span class="line">	// Suppose an m*n matrix is 2D block-distributed on a rootp*rootp processor grid.</span><br><span class="line">	// If rootp doesn&#x27;t divide m or n, then submatrixes won&#x27;t have the same size.</span><br><span class="line">	// Because we will shift A, B, so we allocate memories according to the max</span><br><span class="line">	// rows and cols of A and B.</span><br><span class="line">	//因为有可能rootp不能整除n1,n2,n3,所以在申请内存的时候考虑最大的块的大小</span><br><span class="line">	int maxrows_a = (n1 + rootp - 1)/rootp;//A矩阵块行数的最大值</span><br><span class="line">	int maxcols_a = (n2 + rootp - 1)/rootp;//A矩阵块列数的最大值</span><br><span class="line">	int maxrows_b = maxcols_a;//B矩阵块行数的最大值</span><br><span class="line">	int maxcols_b = (n3 + rootp - 1)/rootp;//B矩阵块列数的最大值</span><br><span class="line">	int bufA_size = sizeof(double)*maxrows_a*maxcols_a;//大小为一个A矩阵块的大小</span><br><span class="line">	int bufB_size = sizeof(double)*maxrows_b*maxcols_b;//大小为一个B矩阵块的大小</span><br><span class="line">	int bufC_size = sizeof(double)*maxrows_a*maxcols_b;//大小为一个C矩阵块的大小</span><br><span class="line">	char* buf;</span><br><span class="line">	int i;</span><br><span class="line">	if(!(buf = (char *)malloc(bufA_size*2 + bufB_size*2 + bufC_size)))//申请两个A矩阵块，两个B矩阵块，和一个C矩阵块</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Memory allocation failed\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	//或者以下4个缓存区的指针位置</span><br><span class="line">	A = (double*)buf;</span><br><span class="line">	bufA = (double*) (buf + bufA_size);</span><br><span class="line">	B = (double*) (buf + bufA_size*2);</span><br><span class="line">	bufB = (double*) (buf + bufA_size*2 + bufB_size);</span><br><span class="line">	C = (double*) (buf + bufA_size*2 + bufB_size*2);</span><br><span class="line">	// Proc 0 scatters A, B to other procs in a 2D block distribution fashion</span><br><span class="line">	scatter_matrix((double*)fstreama, n1, n2, A, rootp);//0号线程分发A矩阵块到各个线程</span><br><span class="line">	MPI_Barrier(MPI_COMM_WORLD);//同步</span><br><span class="line">	scatter_matrix((double*)fstreamb, n2, n3, B, rootp);//0号线程分发B矩阵块到各个线程</span><br><span class="line">	MPI_Barrier(MPI_COMM_WORLD);//同步</span><br><span class="line">	elapsed_time = MPI_Wtime();//记录计算开始的时间戳</span><br><span class="line">	// Compute C=A*B by Cannon algorithm</span><br><span class="line">	cannon(A, bufA, B, bufB, C, maxrows_a,maxcols_a,maxcols_b, rootp);</span><br><span class="line">	MPI_Barrier(MPI_COMM_WORLD);//同步</span><br><span class="line">	elapsed_time = MPI_Wtime() - elapsed_time;//记录计算所用的时间</span><br><span class="line">	// Proc 0 gathers C from other procs and write it out</span><br><span class="line">	FILE* fhc;</span><br><span class="line">	int fsizec = sizeof(int)*2 + sizeof(double)*n1*n3;//存储C矩阵以及两个大小参数的空间大小</span><br><span class="line">	if(myrank == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!(fhc = fopen(argv[3], &quot;w&quot;))) //打开输出C矩阵的文件</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;Can&#x27;t open file %s, Errno=%d\n&quot;, argv[3], 3);//打开失败输出信息</span><br><span class="line">			MPI_Finalize();</span><br><span class="line">		&#125;</span><br><span class="line">		fstreamc = (char *)malloc(fsizec);//申请存储矩阵C的内存空间</span><br><span class="line">		((int*)fstreamc)[0] = n1;//记录矩阵C的行数</span><br><span class="line">		((int*)fstreamc)[1] = n3;//记录矩阵C的列数</span><br><span class="line">	&#125;</span><br><span class="line">	gather_matrix((double*)(fstreamc + sizeof(int)*2), n1, n3, C, rootp, maxrows_a, maxcols_b);//聚集计算结果，其他线程将自己的C矩阵块发送给线程0</span><br><span class="line">	MPI_Barrier(MPI_COMM_WORLD); // Make sure proc 0 read all it needs</span><br><span class="line">	if(myrank == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Cannon algrithm: multiply a %dx%d with a %dx%d, use %.2f(s)\n&quot;,n1, n2, n2, n3, elapsed_time);</span><br><span class="line">		fwrite(fstreamc, sizeof(char), fsizec, fhc);//线程0将矩阵C写入文件</span><br><span class="line">		fclose(fhc);//关闭文件</span><br><span class="line">		free(fstreama);//释放内存</span><br><span class="line">		free(fstreamb);//释放内存</span><br><span class="line">		free(fstreamc);//释放内存</span><br><span class="line">	&#125;</span><br><span class="line">	free(buf);//释放存储小矩阵块的内存空间</span><br><span class="line">	MPI_Finalize();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Stencil计算"><a href="#Stencil计算" class="headerlink" title="Stencil计算"></a>Stencil计算</h1><h2 id="串行程序优化"><a href="#串行程序优化" class="headerlink" title="串行程序优化"></a>串行程序优化</h2><p>对于naïve版本的代码，不妨先“无脑”地加上-O3 -fomit-frame-pointer -march=armv8-a -ffast-math等编译选项来让编译器尽可能提供些自动向量化的效果。仅仅是如此，在不同规模的算例上性能就已经有3~5倍的提升，如下图中的VEC图例所示。</p>
<p>再修改benchmark.c内容对开辟的内存加上内存对齐的声明，如下图中ALIGNED图例所示，并无什么变化。从StackOverflow上了解到分配内存时使用的MPI_Alloc_mem函数（在一些实现中）可能已经做了内存对齐，故效果没有提升也合理。</p>
<p>进一步根据Gabriel Rivera等人写的Tiling Optimizations for 3D Scientiﬁc Computations，实行分块策略。按照Tiling的方法，逻辑和伪代码如左图所示，在固定的的x-y分区上逐层向上计算，每次先将该x-y分区内的Stencil计算完毕，再移动至下一个x-y分区，目的是每次换层的时候只需将3层a0中的一层替换出L1 cache，在有限的cache容量内尽量提高数据的可复用性。经过简单实验，得到最优的分块大小为X XX=256, Y YY=8。</p>
<p>除此以外，还可利用指针定位读写的位置，避免计算指标INDEX(…)时相互类似的大量计算。如下图所示</p>
<p><img src="/img/418b9872601d4f96af048ccc94e4ff82.png" alt=""><br><img src="/img/d3e1937a057f4aac9efc31366fe44f96.png" alt=""></p>
<h2 id="MPI并行"><a href="#MPI并行" class="headerlink" title="MPI并行"></a>MPI并行</h2><p>MPI并行模型使用分离的地址空间，因此每个进程做的计算互不干扰，主要需考虑通信带来的开销。由于有3个维度，对进程进行计算任务划分时有多种选择，因此首先从一维划分开始考虑。综合考虑实现复杂性和性能表现，使用MPI的Subarray type来组织和管理halo区的通信。说明，为使负载均衡，以下所有的划分都力求每个进程负责计算的区域大小相等，因此不能整除算例规模的划分方式不予考虑。在跨节点测试时，性能有一定波动，结果取多次测试中的最高值。此部分测试文件见mpi-benchmark.sh和mpi-test.sh文件。</p>
<h3 id="一维z轴划分"><a href="#一维z轴划分" class="headerlink" title="一维z轴划分"></a>一维z轴划分</h3><p>将z轴等距划分给n p npnp个进程，每个进程负责n x ∗ n y ∗ ( n z / n p ) nx<em>ny</em>(nz/np)nx∗ny∗(nz/np)的任务量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* version_name = <span class="string">&quot;A mpi version with 1D partition in z&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SET_Y_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_Y_SIZE 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SET_X_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_X_SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line">MPI_Comm cart_comm;</span><br><span class="line"><span class="type">int</span> up_ngb, down_ngb;<span class="comment">// z小的为down</span></span><br><span class="line">MPI_Datatype up_send_subarray, up_recv_subarray;</span><br><span class="line">MPI_Datatype down_send_subarray, down_recv_subarray;</span><br><span class="line">MPI_Status status;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define useINDEX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建分布式网格：可以根据7点或27点类型做不同的划分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_dist_grid</span><span class="params">(<span class="type">dist_grid_info_t</span> *grid_info, <span class="type">int</span> stencil_type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一维划分 沿z轴切</span></span><br><span class="line">    <span class="keyword">if</span> (grid_info-&gt;p_id == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 1D partition: num_proc_z: %d\n&quot;</span>, grid_info-&gt;p_num);</span><br><span class="line">    grid_info-&gt;local_size_x = grid_info-&gt;global_size_x;</span><br><span class="line">    grid_info-&gt;local_size_y = grid_info-&gt;global_size_y;</span><br><span class="line">    <span class="keyword">if</span>(grid_info-&gt;global_size_z % grid_info-&gt;p_num != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid_info-&gt;p_id == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; Error: %d cannot divide %d!\n&quot;</span>, grid_info-&gt;global_size_z, grid_info-&gt;p_num);</span><br><span class="line">        <span class="built_in">MPI_Abort</span>(MPI_COMM_WORLD, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    grid_info-&gt;local_size_z = grid_info-&gt;global_size_z / grid_info-&gt;p_num;</span><br><span class="line"></span><br><span class="line">    grid_info-&gt;offset_x = <span class="number">0</span>;</span><br><span class="line">    grid_info-&gt;offset_y = <span class="number">0</span>;</span><br><span class="line">    grid_info-&gt;offset_z = grid_info-&gt;local_size_z * grid_info-&gt;p_id;</span><br><span class="line">    grid_info-&gt;halo_size_x = <span class="number">1</span>;</span><br><span class="line">    grid_info-&gt;halo_size_y = <span class="number">1</span>;</span><br><span class="line">    grid_info-&gt;halo_size_z = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    global: %d %d %d    local : %d %d %d    offset: %d %d %d\n&quot;, grid_info-&gt;p_id,\</span></span><br><span class="line"><span class="comment">    //     grid_info-&gt;global_size_z, grid_info-&gt;global_size_y, grid_info-&gt;global_size_x,\</span></span><br><span class="line"><span class="comment">    //     grid_info-&gt;local_size_z, grid_info-&gt;local_size_y, grid_info-&gt;local_size_x,\</span></span><br><span class="line"><span class="comment">    //     grid_info-&gt;offset_z, grid_info-&gt;offset_y, grid_info-&gt;offset_x);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建通信的拓扑</span></span><br><span class="line">    <span class="type">int</span> dims[<span class="number">1</span>] = &#123;grid_info-&gt;p_num&#125;;</span><br><span class="line">    <span class="type">int</span> periods = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MPI_Cart_create</span>(MPI_COMM_WORLD, <span class="number">1</span>, dims, &amp;periods, <span class="number">0</span>, &amp;cart_comm);</span><br><span class="line">    <span class="built_in">MPI_Cart_shift</span>(cart_comm, <span class="number">0</span>, <span class="number">1</span>, &amp;down_ngb, &amp;up_ngb);</span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    down: %d    up: %d\n&quot;, grid_info-&gt;p_id, down_ngb, up_ngb);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建subarray</span></span><br><span class="line">    <span class="type">int</span> size[<span class="number">3</span>] = &#123; grid_info-&gt;local_size_z + <span class="number">2</span>*grid_info-&gt;halo_size_z,\</span><br><span class="line">                    grid_info-&gt;local_size_y + <span class="number">2</span>*grid_info-&gt;halo_size_y,\</span><br><span class="line">                    grid_info-&gt;local_size_x + <span class="number">2</span>*grid_info-&gt;halo_size_x&#125;;</span><br><span class="line">    <span class="type">int</span> subsize[<span class="number">3</span>] = &#123;  grid_info-&gt;halo_size_z, \</span><br><span class="line">                        grid_info-&gt;local_size_y + <span class="number">2</span>*grid_info-&gt;halo_size_y,\</span><br><span class="line">                        grid_info-&gt;local_size_x + <span class="number">2</span>*grid_info-&gt;halo_size_x&#125;; </span><br><span class="line">    <span class="type">int</span> start[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// send to down_ngb</span></span><br><span class="line">    start[<span class="number">0</span>] = grid_info-&gt;halo_size_z; start[<span class="number">1</span>] = <span class="number">0</span>; start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, start, MPI_ORDER_C, DATA_TYPE, &amp;down_send_subarray);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(&amp;down_send_subarray);</span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    down_send start: %d %d %d\n&quot;, grid_info-&gt;p_id, start[0], start[1], start[2]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// recv from down_ngb</span></span><br><span class="line">    start[<span class="number">0</span>] = <span class="number">0</span>; start[<span class="number">1</span>] = <span class="number">0</span>; start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, start, MPI_ORDER_C, DATA_TYPE, &amp;down_recv_subarray);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(&amp;down_recv_subarray);</span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    down_recv start: %d %d %d\n&quot;, grid_info-&gt;p_id, start[0], start[1], start[2]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// send to up_ngb</span></span><br><span class="line">    start[<span class="number">0</span>] = grid_info-&gt;local_size_z; start[<span class="number">1</span>] = <span class="number">0</span>; start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, start, MPI_ORDER_C, DATA_TYPE, &amp;up_send_subarray);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(&amp;up_send_subarray);</span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d      up_send start: %d %d %d\n&quot;, grid_info-&gt;p_id, start[0], start[1], start[2]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// recv from up_ngb</span></span><br><span class="line">    start[<span class="number">0</span>] = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z; start[<span class="number">1</span>] = <span class="number">0</span>; start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, start, MPI_ORDER_C, DATA_TYPE, &amp;up_recv_subarray);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(&amp;up_recv_subarray);</span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d      up_recv start: %d %d %d\n&quot;, grid_info-&gt;p_id, start[0], start[1], start[2]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy_dist_grid</span><span class="params">(<span class="type">dist_grid_info_t</span> *grid_info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (send_subarray[i] != MPI_DATATYPE_NULL) </span><br><span class="line">            <span class="built_in">MPI_Type_free</span>(&amp;send_subarray[i]);</span><br><span class="line">        <span class="keyword">if</span> (recv_subarray[i] != MPI_DATATYPE_NULL)</span><br><span class="line">            <span class="built_in">MPI_Type_free</span>(&amp;recv_subarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ptr_t</span> <span class="title">stencil_7</span><span class="params">(<span class="type">ptr_t</span> grid, <span class="type">ptr_t</span> aux, <span class="type">const</span> <span class="type">dist_grid_info_t</span> *grid_info, <span class="type">int</span> nt, <span class="type">double</span> * calc_time, <span class="type">double</span> * comm_time)</span> </span>&#123;</span><br><span class="line">    <span class="type">ptr_t</span> buffer[<span class="number">2</span>] = &#123;grid, aux&#125;;</span><br><span class="line">    <span class="type">int</span> x_start = grid_info-&gt;halo_size_x, x_end = grid_info-&gt;local_size_x + grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> y_start = grid_info-&gt;halo_size_y, y_end = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> z_start = grid_info-&gt;halo_size_z, z_end = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">int</span> ldx = grid_info-&gt;local_size_x + <span class="number">2</span> * grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> ldy = grid_info-&gt;local_size_y + <span class="number">2</span> * grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> ldz = grid_info-&gt;local_size_z + <span class="number">2</span> * grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">double</span> t_last, t_curr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; nt; ++t) &#123;</span><br><span class="line">        <span class="type">cptr_t</span> a0 = buffer[t % <span class="number">2</span>];</span><br><span class="line">        <span class="type">ptr_t</span> a1 = buffer[(t + <span class="number">1</span>) % <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通信同步(要让a0的边界是对的值！)</span></span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(a0, <span class="number">1</span>, down_send_subarray, down_ngb, grid_info-&gt;p_id ^ down_ngb,\</span><br><span class="line">                     a0, <span class="number">1</span>,   up_recv_subarray,   up_ngb, grid_info-&gt;p_id ^ up_ngb  , cart_comm, &amp;status);</span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(a0, <span class="number">1</span>,   up_send_subarray,   up_ngb, grid_info-&gt;p_id ^ up_ngb  ,\</span><br><span class="line">                     a0, <span class="number">1</span>, down_recv_subarray, down_ngb, grid_info-&gt;p_id ^ down_ngb, cart_comm, &amp;status);</span><br><span class="line">        <span class="comment">// MPI_Sendrecv(a0, 1, down_send_subarray, down_ngb, 10,\</span></span><br><span class="line"><span class="comment">        //              a0, 1,   up_recv_subarray,   up_ngb, 10, cart_comm, &amp;status);</span></span><br><span class="line">        <span class="comment">// MPI_Sendrecv(a0, 1,   up_send_subarray,   up_ngb, 11,\</span></span><br><span class="line"><span class="comment">        //              a0, 1, down_recv_subarray, down_ngb, 11, cart_comm, &amp;status);</span></span><br><span class="line">        t_last = t_curr;</span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        *comm_time += t_curr - t_last;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> JJ = y_start; JJ &lt; y_end; JJ += SET_Y_SIZE) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> II = x_start; II &lt; x_end; II += SET_X_SIZE)&#123;</span><br><span class="line">                <span class="type">int</span> REAL_Y_SIZE = <span class="built_in">MIN</span>(SET_Y_SIZE, y_end - JJ);</span><br><span class="line">                <span class="type">int</span> REAL_X_SIZE = <span class="built_in">MIN</span>(SET_X_SIZE, x_end - II);</span><br><span class="line">    </span><br><span class="line">                <span class="type">ptr_t</span> a1_local = a1 + z_start*ldx*ldy + JJ*ldx + II;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_Z = a0 + (a1_local - a1);</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_P = a0_local_Z + ldy*ldx;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_N = a0_local_Z - ldy*ldx;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> z = z_start; z &lt; z_end; ++z) &#123;  </span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; REAL_Y_SIZE; y++) &#123;</span><br><span class="line">                        <span class="meta">#<span class="keyword">pragma</span> unroll</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; REAL_X_SIZE; x++) &#123;</span><br><span class="line">                            a1_local[y*ldx+x] \</span><br><span class="line">                                = ALPHA_ZZZ * a0_local_Z[y*ldx+x]\</span><br><span class="line">                                + ALPHA_NZZ * a0_local_Z[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZZ * a0_local_Z[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_ZNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZN * a0_local_N[y*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZP * a0_local_P[y*ldx+x];</span><br><span class="line"></span><br><span class="line">                        &#125;<span class="comment">// x loop</span></span><br><span class="line">                    &#125;<span class="comment">// y loop</span></span><br><span class="line">                    a1_local = a1_local + ldx*ldy;</span><br><span class="line">                    a0_local_N = a0_local_Z;</span><br><span class="line">                    a0_local_Z = a0_local_P;</span><br><span class="line">                    a0_local_P = a0_local_P + ldx*ldy;</span><br><span class="line">                &#125;<span class="comment">// z loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t_last = t_curr;</span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        *calc_time += t_curr - t_last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer[nt % <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ptr_t</span> <span class="title">stencil_27</span><span class="params">(<span class="type">ptr_t</span> grid, <span class="type">ptr_t</span> aux, <span class="type">const</span> <span class="type">dist_grid_info_t</span> *grid_info, <span class="type">int</span> nt, <span class="type">double</span> * calc_time, <span class="type">double</span> * comm_time)</span> </span>&#123;</span><br><span class="line">    <span class="type">ptr_t</span> buffer[<span class="number">2</span>] = &#123;grid, aux&#125;;</span><br><span class="line">    <span class="type">int</span> x_start = grid_info-&gt;halo_size_x, x_end = grid_info-&gt;local_size_x + grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> y_start = grid_info-&gt;halo_size_y, y_end = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> z_start = grid_info-&gt;halo_size_z, z_end = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">int</span> ldx = grid_info-&gt;local_size_x + <span class="number">2</span> * grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> ldy = grid_info-&gt;local_size_y + <span class="number">2</span> * grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> ldz = grid_info-&gt;local_size_z + <span class="number">2</span> * grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">double</span> t_last, t_curr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; nt; ++t) &#123;</span><br><span class="line">        <span class="type">cptr_t</span> restrict a0 = buffer[t % <span class="number">2</span>];</span><br><span class="line">        <span class="type">ptr_t</span> restrict a1 = buffer[(t + <span class="number">1</span>) % <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通信同步(要让a0的边界是对的值！)</span></span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(a0, <span class="number">1</span>, down_send_subarray, down_ngb, grid_info-&gt;p_id ^ down_ngb,\</span><br><span class="line">                     a0, <span class="number">1</span>,   up_recv_subarray,   up_ngb, grid_info-&gt;p_id ^ up_ngb  , cart_comm, &amp;status);</span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(a0, <span class="number">1</span>,   up_send_subarray,   up_ngb, grid_info-&gt;p_id ^ up_ngb  ,\</span><br><span class="line">                     a0, <span class="number">1</span>, down_recv_subarray, down_ngb, grid_info-&gt;p_id ^ down_ngb, cart_comm, &amp;status);</span><br><span class="line">        <span class="comment">// MPI_Sendrecv(a0, 1, down_send_subarray, down_ngb, 10,\</span></span><br><span class="line"><span class="comment">        //              a0, 1,   up_recv_subarray,   up_ngb, 10, cart_comm, &amp;status);</span></span><br><span class="line">        <span class="comment">// MPI_Sendrecv(a0, 1,   up_send_subarray,   up_ngb, 11,\</span></span><br><span class="line"><span class="comment">        //              a0, 1, down_recv_subarray, down_ngb, 11, cart_comm, &amp;status);</span></span><br><span class="line">        t_last = t_curr;</span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        *comm_time += t_curr - t_last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> JJ = y_start; JJ &lt; y_end; JJ += SET_Y_SIZE) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> II = x_start; II &lt; x_end; II += SET_X_SIZE)&#123;</span><br><span class="line">                <span class="type">int</span> REAL_Y_SIZE = <span class="built_in">MIN</span>(SET_Y_SIZE, y_end - JJ);</span><br><span class="line">                <span class="type">int</span> REAL_X_SIZE = <span class="built_in">MIN</span>(SET_X_SIZE, x_end - II);</span><br><span class="line"></span><br><span class="line">                <span class="type">ptr_t</span> a1_local = a1 + z_start*ldx*ldy + JJ*ldx + II;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_Z = a0 + (a1_local - a1);</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_P = a0_local_Z + ldy*ldx;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_N = a0_local_Z - ldy*ldx;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> z = z_start; z &lt; z_end; ++z) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; REAL_Y_SIZE; y++) &#123;</span><br><span class="line">                        <span class="meta">#<span class="keyword">pragma</span> unroll</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; REAL_X_SIZE; x++) &#123;</span><br><span class="line">                            a1_local[y*ldx+x] \</span><br><span class="line">                                = ALPHA_ZZZ * a0_local_Z[y*ldx+x] \</span><br><span class="line">                                + ALPHA_NZZ * a0_local_Z[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZZ * a0_local_Z[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_ZNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZN * a0_local_N[y*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZP * a0_local_P[y*ldx+x] \</span><br><span class="line">                                + ALPHA_NNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NZN * a0_local_N[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZN * a0_local_N[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NZP * a0_local_P[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZP * a0_local_P[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_ZNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_NNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>];</span><br><span class="line">                        &#125;<span class="comment">// x</span></span><br><span class="line">                    &#125;<span class="comment">// y</span></span><br><span class="line">                    a1_local = a1_local + ldx*ldy;</span><br><span class="line">                    a0_local_N = a0_local_Z;</span><br><span class="line">                    a0_local_Z = a0_local_P;</span><br><span class="line">                    a0_local_P = a0_local_P + ldx*ldy;</span><br><span class="line">                &#125;<span class="comment">// z</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t_last = t_curr;</span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        *calc_time += t_curr - t_last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer[nt % <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一维y轴划分"><a href="#一维y轴划分" class="headerlink" title="一维y轴划分"></a>一维y轴划分</h3><p>将y轴等距划分给n p npnp个进程，每个进程负责n x ∗ ( n y / n p ) ∗ n z nx<em>(ny/np)</em>nznx∗(ny/np)∗nz的任务量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* version_name = <span class="string">&quot;A mpi version with 1D partition in y&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SET_Y_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_Y_SIZE 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SET_X_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_X_SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line">MPI_Comm cart_comm;</span><br><span class="line"><span class="type">int</span> up_ngb, down_ngb;<span class="comment">// y小的为down</span></span><br><span class="line">MPI_Datatype up_send_subarray, up_recv_subarray;</span><br><span class="line">MPI_Datatype down_send_subarray, down_recv_subarray;</span><br><span class="line">MPI_Status status;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define useINDEX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建分布式网格：可以根据7点或27点类型做不同的划分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_dist_grid</span><span class="params">(<span class="type">dist_grid_info_t</span> *grid_info, <span class="type">int</span> stencil_type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一维划分 沿y轴切</span></span><br><span class="line">    <span class="keyword">if</span> (grid_info-&gt;p_id == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 1D partition: num_proc_y: %d\n&quot;</span>, grid_info-&gt;p_num);</span><br><span class="line">    grid_info-&gt;local_size_x = grid_info-&gt;global_size_x;</span><br><span class="line">    <span class="keyword">if</span>(grid_info-&gt;global_size_y % grid_info-&gt;p_num != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid_info-&gt;p_id == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; Error: %d cannot divide %d!\n&quot;</span>, grid_info-&gt;global_size_y, grid_info-&gt;p_num);</span><br><span class="line">        <span class="built_in">MPI_Abort</span>(MPI_COMM_WORLD, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    grid_info-&gt;local_size_y = grid_info-&gt;global_size_y / grid_info-&gt;p_num;</span><br><span class="line">    grid_info-&gt;local_size_z = grid_info-&gt;global_size_z;</span><br><span class="line"></span><br><span class="line">    grid_info-&gt;offset_x = <span class="number">0</span>;</span><br><span class="line">    grid_info-&gt;offset_y = grid_info-&gt;local_size_y * grid_info-&gt;p_id;</span><br><span class="line">    grid_info-&gt;offset_z = <span class="number">0</span>;</span><br><span class="line">    grid_info-&gt;halo_size_x = <span class="number">1</span>;</span><br><span class="line">    grid_info-&gt;halo_size_y = <span class="number">1</span>;</span><br><span class="line">    grid_info-&gt;halo_size_z = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    global: %d %d %d    local : %d %d %d    offset: %d %d %d\n&quot;, grid_info-&gt;p_id,\</span></span><br><span class="line"><span class="comment">    //     grid_info-&gt;global_size_z, grid_info-&gt;global_size_y, grid_info-&gt;global_size_x,\</span></span><br><span class="line"><span class="comment">    //     grid_info-&gt;local_size_z, grid_info-&gt;local_size_y, grid_info-&gt;local_size_x,\</span></span><br><span class="line"><span class="comment">    //     grid_info-&gt;offset_z, grid_info-&gt;offset_y, grid_info-&gt;offset_x);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建通信的拓扑</span></span><br><span class="line">    <span class="type">int</span> dims[<span class="number">1</span>] = &#123;grid_info-&gt;p_num&#125;;</span><br><span class="line">    <span class="type">int</span> periods = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MPI_Cart_create</span>(MPI_COMM_WORLD, <span class="number">1</span>, dims, &amp;periods, <span class="number">0</span>, &amp;cart_comm);</span><br><span class="line">    <span class="built_in">MPI_Cart_shift</span>(cart_comm, <span class="number">0</span>, <span class="number">1</span>, &amp;down_ngb, &amp;up_ngb);</span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    down: %d    up: %d\n&quot;, grid_info-&gt;p_id, down_ngb, up_ngb);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建subarray</span></span><br><span class="line">    <span class="type">int</span> size[<span class="number">3</span>] = &#123; grid_info-&gt;local_size_z + <span class="number">2</span>*grid_info-&gt;halo_size_z,\</span><br><span class="line">                    grid_info-&gt;local_size_y + <span class="number">2</span>*grid_info-&gt;halo_size_y,\</span><br><span class="line">                    grid_info-&gt;local_size_x + <span class="number">2</span>*grid_info-&gt;halo_size_x&#125;;</span><br><span class="line">    <span class="type">int</span> subsize[<span class="number">3</span>] = &#123;  grid_info-&gt;local_size_z + <span class="number">2</span>*grid_info-&gt;halo_size_z,\</span><br><span class="line">                        grid_info-&gt;halo_size_y, \</span><br><span class="line">                        grid_info-&gt;local_size_x + <span class="number">2</span>*grid_info-&gt;halo_size_x&#125;; </span><br><span class="line">    <span class="type">int</span> start[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// send to down_ngb</span></span><br><span class="line">    start[<span class="number">0</span>] = <span class="number">0</span>; start[<span class="number">1</span>] = grid_info-&gt;halo_size_y; start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, start, MPI_ORDER_C, DATA_TYPE, &amp;down_send_subarray);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(&amp;down_send_subarray);</span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    down_send start: %d %d %d\n&quot;, grid_info-&gt;p_id, start[0], start[1], start[2]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// recv from down_ngb</span></span><br><span class="line">    start[<span class="number">0</span>] = <span class="number">0</span>; start[<span class="number">1</span>] = <span class="number">0</span>; start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, start, MPI_ORDER_C, DATA_TYPE, &amp;down_recv_subarray);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(&amp;down_recv_subarray);</span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    down_recv start: %d %d %d\n&quot;, grid_info-&gt;p_id, start[0], start[1], start[2]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// send to up_ngb</span></span><br><span class="line">    start[<span class="number">0</span>] = <span class="number">0</span>; start[<span class="number">1</span>] = grid_info-&gt;local_size_y; start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, start, MPI_ORDER_C, DATA_TYPE, &amp;up_send_subarray);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(&amp;up_send_subarray);</span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d      up_send start: %d %d %d\n&quot;, grid_info-&gt;p_id, start[0], start[1], start[2]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// recv from up_ngb</span></span><br><span class="line">    start[<span class="number">0</span>] = <span class="number">0</span>; start[<span class="number">1</span>] = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y; start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, start, MPI_ORDER_C, DATA_TYPE, &amp;up_recv_subarray);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(&amp;up_recv_subarray);</span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d      up_recv start: %d %d %d\n&quot;, grid_info-&gt;p_id, start[0], start[1], start[2]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy_dist_grid</span><span class="params">(<span class="type">dist_grid_info_t</span> *grid_info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (send_subarray[i] != MPI_DATATYPE_NULL) </span><br><span class="line">            <span class="built_in">MPI_Type_free</span>(&amp;send_subarray[i]);</span><br><span class="line">        <span class="keyword">if</span> (recv_subarray[i] != MPI_DATATYPE_NULL)</span><br><span class="line">            <span class="built_in">MPI_Type_free</span>(&amp;recv_subarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ptr_t</span> <span class="title">stencil_7</span><span class="params">(<span class="type">ptr_t</span> grid, <span class="type">ptr_t</span> aux, <span class="type">const</span> <span class="type">dist_grid_info_t</span> *grid_info, <span class="type">int</span> nt, <span class="type">double</span> * calc_time, <span class="type">double</span> * comm_time)</span> </span>&#123;</span><br><span class="line">    <span class="type">ptr_t</span> buffer[<span class="number">2</span>] = &#123;grid, aux&#125;;</span><br><span class="line">    <span class="type">int</span> x_start = grid_info-&gt;halo_size_x, x_end = grid_info-&gt;local_size_x + grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> y_start = grid_info-&gt;halo_size_y, y_end = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> z_start = grid_info-&gt;halo_size_z, z_end = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">int</span> ldx = grid_info-&gt;local_size_x + <span class="number">2</span> * grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> ldy = grid_info-&gt;local_size_y + <span class="number">2</span> * grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> ldz = grid_info-&gt;local_size_z + <span class="number">2</span> * grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">double</span> t_last, t_curr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; nt; ++t) &#123;</span><br><span class="line">        <span class="type">cptr_t</span> a0 = buffer[t % <span class="number">2</span>];</span><br><span class="line">        <span class="type">ptr_t</span> a1 = buffer[(t + <span class="number">1</span>) % <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通信同步(要让a0的边界是对的值！)</span></span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(a0, <span class="number">1</span>, down_send_subarray, down_ngb, grid_info-&gt;p_id ^ down_ngb,\</span><br><span class="line">                     a0, <span class="number">1</span>,   up_recv_subarray,   up_ngb, grid_info-&gt;p_id ^ up_ngb  , cart_comm, &amp;status);</span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(a0, <span class="number">1</span>,   up_send_subarray,   up_ngb, grid_info-&gt;p_id ^ up_ngb  ,\</span><br><span class="line">                     a0, <span class="number">1</span>, down_recv_subarray, down_ngb, grid_info-&gt;p_id ^ down_ngb, cart_comm, &amp;status);</span><br><span class="line">        <span class="comment">// MPI_Sendrecv(a0, 1, down_send_subarray, down_ngb, 10,\</span></span><br><span class="line"><span class="comment">        //              a0, 1,   up_recv_subarray,   up_ngb, 10, cart_comm, &amp;status);</span></span><br><span class="line">        <span class="comment">// MPI_Sendrecv(a0, 1,   up_send_subarray,   up_ngb, 11,\</span></span><br><span class="line"><span class="comment">        //              a0, 1, down_recv_subarray, down_ngb, 11, cart_comm, &amp;status);</span></span><br><span class="line">        t_last = t_curr;</span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        *comm_time += t_curr - t_last;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> JJ = y_start; JJ &lt; y_end; JJ += SET_Y_SIZE) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> II = x_start; II &lt; x_end; II += SET_X_SIZE)&#123;</span><br><span class="line">                <span class="type">int</span> REAL_Y_SIZE = <span class="built_in">MIN</span>(SET_Y_SIZE, y_end - JJ);</span><br><span class="line">                <span class="type">int</span> REAL_X_SIZE = <span class="built_in">MIN</span>(SET_X_SIZE, x_end - II);</span><br><span class="line">    </span><br><span class="line">                <span class="type">ptr_t</span> a1_local = a1 + z_start*ldx*ldy + JJ*ldx + II;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_Z = a0 + (a1_local - a1);</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_P = a0_local_Z + ldy*ldx;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_N = a0_local_Z - ldy*ldx;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> z = z_start; z &lt; z_end; ++z) &#123;  </span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; REAL_Y_SIZE; y++) &#123;</span><br><span class="line">                        <span class="meta">#<span class="keyword">pragma</span> unroll</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; REAL_X_SIZE; x++) &#123;</span><br><span class="line">                            a1_local[y*ldx+x] \</span><br><span class="line">                                = ALPHA_ZZZ * a0_local_Z[y*ldx+x]\</span><br><span class="line">                                + ALPHA_NZZ * a0_local_Z[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZZ * a0_local_Z[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_ZNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZN * a0_local_N[y*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZP * a0_local_P[y*ldx+x];</span><br><span class="line"></span><br><span class="line">                        &#125;<span class="comment">// x loop</span></span><br><span class="line">                    &#125;<span class="comment">// y loop</span></span><br><span class="line">                    a1_local = a1_local + ldx*ldy;</span><br><span class="line">                    a0_local_N = a0_local_Z;</span><br><span class="line">                    a0_local_Z = a0_local_P;</span><br><span class="line">                    a0_local_P = a0_local_P + ldx*ldy;</span><br><span class="line">                &#125;<span class="comment">// z loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t_last = t_curr;</span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        *calc_time += t_curr - t_last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer[nt % <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ptr_t</span> <span class="title">stencil_27</span><span class="params">(<span class="type">ptr_t</span> grid, <span class="type">ptr_t</span> aux, <span class="type">const</span> <span class="type">dist_grid_info_t</span> *grid_info, <span class="type">int</span> nt, <span class="type">double</span> * calc_time, <span class="type">double</span> * comm_time)</span> </span>&#123;</span><br><span class="line">    <span class="type">ptr_t</span> buffer[<span class="number">2</span>] = &#123;grid, aux&#125;;</span><br><span class="line">    <span class="type">int</span> x_start = grid_info-&gt;halo_size_x, x_end = grid_info-&gt;local_size_x + grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> y_start = grid_info-&gt;halo_size_y, y_end = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> z_start = grid_info-&gt;halo_size_z, z_end = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">int</span> ldx = grid_info-&gt;local_size_x + <span class="number">2</span> * grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> ldy = grid_info-&gt;local_size_y + <span class="number">2</span> * grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> ldz = grid_info-&gt;local_size_z + <span class="number">2</span> * grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">double</span> t_last, t_curr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; nt; ++t) &#123;</span><br><span class="line">        <span class="type">cptr_t</span> restrict a0 = buffer[t % <span class="number">2</span>];</span><br><span class="line">        <span class="type">ptr_t</span> restrict a1 = buffer[(t + <span class="number">1</span>) % <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通信同步(要让a0的边界是对的值！)</span></span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(a0, <span class="number">1</span>, down_send_subarray, down_ngb, grid_info-&gt;p_id ^ down_ngb,\</span><br><span class="line">                     a0, <span class="number">1</span>,   up_recv_subarray,   up_ngb, grid_info-&gt;p_id ^ up_ngb  , cart_comm, &amp;status);</span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(a0, <span class="number">1</span>,   up_send_subarray,   up_ngb, grid_info-&gt;p_id ^ up_ngb  ,\</span><br><span class="line">                     a0, <span class="number">1</span>, down_recv_subarray, down_ngb, grid_info-&gt;p_id ^ down_ngb, cart_comm, &amp;status);</span><br><span class="line">        <span class="comment">// MPI_Sendrecv(a0, 1, down_send_subarray, down_ngb, 10,\</span></span><br><span class="line"><span class="comment">        //              a0, 1,   up_recv_subarray,   up_ngb, 10, cart_comm, &amp;status);</span></span><br><span class="line">        <span class="comment">// MPI_Sendrecv(a0, 1,   up_send_subarray,   up_ngb, 11,\</span></span><br><span class="line"><span class="comment">        //              a0, 1, down_recv_subarray, down_ngb, 11, cart_comm, &amp;status);</span></span><br><span class="line">        t_last = t_curr;</span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        *comm_time += t_curr - t_last;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> JJ = y_start; JJ &lt; y_end; JJ += SET_Y_SIZE) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> II = x_start; II &lt; x_end; II += SET_X_SIZE)&#123;</span><br><span class="line">                <span class="type">int</span> REAL_Y_SIZE = <span class="built_in">MIN</span>(SET_Y_SIZE, y_end - JJ);</span><br><span class="line">                <span class="type">int</span> REAL_X_SIZE = <span class="built_in">MIN</span>(SET_X_SIZE, x_end - II);</span><br><span class="line"></span><br><span class="line">                <span class="type">ptr_t</span> a1_local = a1 + z_start*ldx*ldy + JJ*ldx + II;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_Z = a0 + (a1_local - a1);</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_P = a0_local_Z + ldy*ldx;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_N = a0_local_Z - ldy*ldx;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> z = z_start; z &lt; z_end; ++z) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; REAL_Y_SIZE; y++) &#123;</span><br><span class="line">                        <span class="meta">#<span class="keyword">pragma</span> unroll</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; REAL_X_SIZE; x++) &#123;</span><br><span class="line">                            a1_local[y*ldx+x] \</span><br><span class="line">                                = ALPHA_ZZZ * a0_local_Z[y*ldx+x] \</span><br><span class="line">                                + ALPHA_NZZ * a0_local_Z[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZZ * a0_local_Z[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_ZNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZN * a0_local_N[y*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZP * a0_local_P[y*ldx+x] \</span><br><span class="line">                                + ALPHA_NNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NZN * a0_local_N[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZN * a0_local_N[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NZP * a0_local_P[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZP * a0_local_P[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_ZNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_NNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>];</span><br><span class="line">                        &#125;<span class="comment">// x</span></span><br><span class="line">                    &#125;<span class="comment">// y</span></span><br><span class="line">                    a1_local = a1_local + ldx*ldy;</span><br><span class="line">                    a0_local_N = a0_local_Z;</span><br><span class="line">                    a0_local_Z = a0_local_P;</span><br><span class="line">                    a0_local_P = a0_local_P + ldx*ldy;</span><br><span class="line">                &#125;<span class="comment">// z</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t_last = t_curr;</span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        *calc_time += t_curr - t_last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer[nt % <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一维x轴划分"><a href="#一维x轴划分" class="headerlink" title="一维x轴划分"></a>一维x轴划分</h3><p>将x轴等距划分给n p npnp个进程，每个进程负责( n x / n p ) ∗ n y ∗ n z (nx/np)<em>ny</em>nz(nx/np)∗ny∗nz的任务量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* version_name =<span class="string">&quot;A mpi version with 1D partition in x&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SET_Y_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_Y_SIZE 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SET_X_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_X_SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line">MPI_Comm cart_comm;</span><br><span class="line"><span class="type">int</span> up_ngb, down_ngb;<span class="comment">// y小的为down</span></span><br><span class="line">MPI_Datatype up_send_subarray, up_recv_subarray;</span><br><span class="line">MPI_Datatype down_send_subarray, down_recv_subarray;</span><br><span class="line">MPI_Status status;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #define useINDEX</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建分布式网格：可以根据7点或27点类型做不同的划分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_dist_grid</span><span class="params">(<span class="type">dist_grid_info_t</span> *grid_info, <span class="type">int</span> stencil_type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一维划分 沿x轴切</span></span><br><span class="line">    <span class="keyword">if</span>(grid_info-&gt;global_size_x % grid_info-&gt;p_num != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid_info-&gt;p_id == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; Error: %d cannot divide %d!\n&quot;</span>, grid_info-&gt;global_size_x, grid_info-&gt;p_num);</span><br><span class="line">        <span class="built_in">MPI_Abort</span>(MPI_COMM_WORLD, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    grid_info-&gt;local_size_x = grid_info-&gt;global_size_x / grid_info-&gt;p_num;</span><br><span class="line">    grid_info-&gt;local_size_y = grid_info-&gt;global_size_y;</span><br><span class="line">    grid_info-&gt;local_size_z = grid_info-&gt;global_size_z;</span><br><span class="line"></span><br><span class="line">    grid_info-&gt;offset_x = grid_info-&gt;local_size_x * grid_info-&gt;p_id;</span><br><span class="line">    grid_info-&gt;offset_y = <span class="number">0</span>;</span><br><span class="line">    grid_info-&gt;offset_z = <span class="number">0</span>;</span><br><span class="line">    grid_info-&gt;halo_size_x = <span class="number">1</span>;</span><br><span class="line">    grid_info-&gt;halo_size_y = <span class="number">1</span>;</span><br><span class="line">    grid_info-&gt;halo_size_z = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    global: %d %d %d    local : %d %d %d    offset: %d %d %d\n&quot;, grid_info-&gt;p_id,\</span></span><br><span class="line"><span class="comment">    //     grid_info-&gt;global_size_z, grid_info-&gt;global_size_y, grid_info-&gt;global_size_x,\</span></span><br><span class="line"><span class="comment">    //     grid_info-&gt;local_size_z, grid_info-&gt;local_size_y, grid_info-&gt;local_size_x,\</span></span><br><span class="line"><span class="comment">    //     grid_info-&gt;offset_z, grid_info-&gt;offset_y, grid_info-&gt;offset_x);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建通信的拓扑</span></span><br><span class="line">    <span class="type">int</span> dims[<span class="number">1</span>] = &#123;grid_info-&gt;p_num&#125;;</span><br><span class="line">    <span class="type">int</span> periods = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MPI_Cart_create</span>(MPI_COMM_WORLD, <span class="number">1</span>, dims, &amp;periods, <span class="number">0</span>, &amp;cart_comm);</span><br><span class="line">    <span class="built_in">MPI_Cart_shift</span>(cart_comm, <span class="number">0</span>, <span class="number">1</span>, &amp;down_ngb, &amp;up_ngb);</span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    down: %d    up: %d\n&quot;, grid_info-&gt;p_id, down_ngb, up_ngb);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建subarray</span></span><br><span class="line">    <span class="type">int</span> size[<span class="number">3</span>] = &#123; grid_info-&gt;local_size_z + <span class="number">2</span>*grid_info-&gt;halo_size_z,\</span><br><span class="line">                    grid_info-&gt;local_size_y + <span class="number">2</span>*grid_info-&gt;halo_size_y,\</span><br><span class="line">                    grid_info-&gt;local_size_x + <span class="number">2</span>*grid_info-&gt;halo_size_x&#125;;</span><br><span class="line">    <span class="type">int</span> subsize[<span class="number">3</span>] = &#123;  grid_info-&gt;local_size_z + <span class="number">2</span>*grid_info-&gt;halo_size_z,\</span><br><span class="line">                        grid_info-&gt;local_size_y + <span class="number">2</span>*grid_info-&gt;halo_size_y,\</span><br><span class="line">                        grid_info-&gt;halo_size_x&#125;; </span><br><span class="line">    <span class="type">int</span> start[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// send to down_ngb</span></span><br><span class="line">    start[<span class="number">0</span>] = <span class="number">0</span>; start[<span class="number">1</span>] = <span class="number">0</span>; start[<span class="number">2</span>] = grid_info-&gt;halo_size_x; </span><br><span class="line">    <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, start, MPI_ORDER_C, DATA_TYPE, &amp;down_send_subarray);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(&amp;down_send_subarray);</span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    down_send start: %d %d %d\n&quot;, grid_info-&gt;p_id, start[0], start[1], start[2]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// recv from down_ngb</span></span><br><span class="line">    start[<span class="number">0</span>] = <span class="number">0</span>; start[<span class="number">1</span>] = <span class="number">0</span>; start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, start, MPI_ORDER_C, DATA_TYPE, &amp;down_recv_subarray);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(&amp;down_recv_subarray);</span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    down_recv start: %d %d %d\n&quot;, grid_info-&gt;p_id, start[0], start[1], start[2]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// send to up_ngb</span></span><br><span class="line">    start[<span class="number">0</span>] = <span class="number">0</span>; start[<span class="number">1</span>] = <span class="number">0</span>; start[<span class="number">2</span>] = grid_info-&gt;local_size_x; </span><br><span class="line">    <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, start, MPI_ORDER_C, DATA_TYPE, &amp;up_send_subarray);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(&amp;up_send_subarray);</span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d      up_send start: %d %d %d\n&quot;, grid_info-&gt;p_id, start[0], start[1], start[2]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// recv from up_ngb</span></span><br><span class="line">    start[<span class="number">0</span>] = <span class="number">0</span>; start[<span class="number">1</span>] = <span class="number">0</span>; start[<span class="number">2</span>] = grid_info-&gt;local_size_x + grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, start, MPI_ORDER_C, DATA_TYPE, &amp;up_recv_subarray);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(&amp;up_recv_subarray);</span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d      up_recv start: %d %d %d\n&quot;, grid_info-&gt;p_id, start[0], start[1], start[2]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy_dist_grid</span><span class="params">(<span class="type">dist_grid_info_t</span> *grid_info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (send_subarray[i] != MPI_DATATYPE_NULL) </span><br><span class="line">            <span class="built_in">MPI_Type_free</span>(&amp;send_subarray[i]);</span><br><span class="line">        <span class="keyword">if</span> (recv_subarray[i] != MPI_DATATYPE_NULL)</span><br><span class="line">            <span class="built_in">MPI_Type_free</span>(&amp;recv_subarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ptr_t</span> <span class="title">stencil_7</span><span class="params">(<span class="type">ptr_t</span> grid, <span class="type">ptr_t</span> aux, <span class="type">const</span> <span class="type">dist_grid_info_t</span> *grid_info, <span class="type">int</span> nt)</span> </span>&#123;</span><br><span class="line">    <span class="type">ptr_t</span> buffer[<span class="number">2</span>] = &#123;grid, aux&#125;;</span><br><span class="line">    <span class="type">int</span> x_start = grid_info-&gt;halo_size_x, x_end = grid_info-&gt;local_size_x + grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> y_start = grid_info-&gt;halo_size_y, y_end = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> z_start = grid_info-&gt;halo_size_z, z_end = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">int</span> ldx = grid_info-&gt;local_size_x + <span class="number">2</span> * grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> ldy = grid_info-&gt;local_size_y + <span class="number">2</span> * grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> ldz = grid_info-&gt;local_size_z + <span class="number">2</span> * grid_info-&gt;halo_size_z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; nt; ++t) &#123;</span><br><span class="line">        <span class="type">cptr_t</span> a0 = buffer[t % <span class="number">2</span>];</span><br><span class="line">        <span class="type">ptr_t</span> a1 = buffer[(t + <span class="number">1</span>) % <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通信同步(要让a0的边界是对的值！)</span></span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(a0, <span class="number">1</span>, down_send_subarray, down_ngb, grid_info-&gt;p_id ^ down_ngb,\</span><br><span class="line">                     a0, <span class="number">1</span>,   up_recv_subarray,   up_ngb, grid_info-&gt;p_id ^ up_ngb  , cart_comm, &amp;status);</span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(a0, <span class="number">1</span>,   up_send_subarray,   up_ngb, grid_info-&gt;p_id ^ up_ngb  ,\</span><br><span class="line">                     a0, <span class="number">1</span>, down_recv_subarray, down_ngb, grid_info-&gt;p_id ^ down_ngb, cart_comm, &amp;status);</span><br><span class="line">        <span class="comment">// MPI_Sendrecv(a0, 1, down_send_subarray, down_ngb, 10,\</span></span><br><span class="line"><span class="comment">        //              a0, 1,   up_recv_subarray,   up_ngb, 10, cart_comm, &amp;status);</span></span><br><span class="line">        <span class="comment">// MPI_Sendrecv(a0, 1,   up_send_subarray,   up_ngb, 11,\</span></span><br><span class="line"><span class="comment">        //              a0, 1, down_recv_subarray, down_ngb, 11, cart_comm, &amp;status);</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> JJ = y_start; JJ &lt; y_end; JJ += SET_Y_SIZE) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> II = x_start; II &lt; x_end; II += SET_X_SIZE)&#123;</span><br><span class="line">                <span class="type">int</span> REAL_Y_SIZE = <span class="built_in">MIN</span>(SET_Y_SIZE, y_end - JJ);</span><br><span class="line">                <span class="type">int</span> REAL_X_SIZE = <span class="built_in">MIN</span>(SET_X_SIZE, x_end - II);</span><br><span class="line">    </span><br><span class="line">                <span class="type">ptr_t</span> a1_local = a1 + z_start*ldx*ldy + JJ*ldx + II;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_Z = a0 + (a1_local - a1);</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_P = a0_local_Z + ldy*ldx;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_N = a0_local_Z - ldy*ldx;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> z = z_start; z &lt; z_end; ++z) &#123;  </span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; REAL_Y_SIZE; y++) &#123;</span><br><span class="line">                        <span class="meta">#<span class="keyword">pragma</span> unroll</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; REAL_X_SIZE; x++) &#123;</span><br><span class="line">                            a1_local[y*ldx+x] \</span><br><span class="line">                                = ALPHA_ZZZ * a0_local_Z[y*ldx+x]\</span><br><span class="line">                                + ALPHA_NZZ * a0_local_Z[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZZ * a0_local_Z[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_ZNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZN * a0_local_N[y*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZP * a0_local_P[y*ldx+x];</span><br><span class="line"></span><br><span class="line">                        &#125;<span class="comment">// x loop</span></span><br><span class="line">                    &#125;<span class="comment">// y loop</span></span><br><span class="line">                    a1_local = a1_local + ldx*ldy;</span><br><span class="line">                    a0_local_N = a0_local_Z;</span><br><span class="line">                    a0_local_Z = a0_local_P;</span><br><span class="line">                    a0_local_P = a0_local_P + ldx*ldy;</span><br><span class="line">                &#125;<span class="comment">// z loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer[nt % <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ptr_t</span> <span class="title">stencil_27</span><span class="params">(<span class="type">ptr_t</span> grid, <span class="type">ptr_t</span> aux, <span class="type">const</span> <span class="type">dist_grid_info_t</span> *grid_info, <span class="type">int</span> nt)</span> </span>&#123;</span><br><span class="line">    <span class="type">ptr_t</span> buffer[<span class="number">2</span>] = &#123;grid, aux&#125;;</span><br><span class="line">    <span class="type">int</span> x_start = grid_info-&gt;halo_size_x, x_end = grid_info-&gt;local_size_x + grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> y_start = grid_info-&gt;halo_size_y, y_end = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> z_start = grid_info-&gt;halo_size_z, z_end = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">int</span> ldx = grid_info-&gt;local_size_x + <span class="number">2</span> * grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> ldy = grid_info-&gt;local_size_y + <span class="number">2</span> * grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> ldz = grid_info-&gt;local_size_z + <span class="number">2</span> * grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; nt; ++t) &#123;</span><br><span class="line">        <span class="type">cptr_t</span> restrict a0 = buffer[t % <span class="number">2</span>];</span><br><span class="line">        <span class="type">ptr_t</span> restrict a1 = buffer[(t + <span class="number">1</span>) % <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通信同步(要让a0的边界是对的值！)</span></span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(a0, <span class="number">1</span>, down_send_subarray, down_ngb, grid_info-&gt;p_id ^ down_ngb,\</span><br><span class="line">                     a0, <span class="number">1</span>,   up_recv_subarray,   up_ngb, grid_info-&gt;p_id ^ up_ngb  , cart_comm, &amp;status);</span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(a0, <span class="number">1</span>,   up_send_subarray,   up_ngb, grid_info-&gt;p_id ^ up_ngb  ,\</span><br><span class="line">                     a0, <span class="number">1</span>, down_recv_subarray, down_ngb, grid_info-&gt;p_id ^ down_ngb, cart_comm, &amp;status);</span><br><span class="line">        <span class="comment">// MPI_Sendrecv(a0, 1, down_send_subarray, down_ngb, 10,\</span></span><br><span class="line"><span class="comment">        //              a0, 1,   up_recv_subarray,   up_ngb, 10, cart_comm, &amp;status);</span></span><br><span class="line">        <span class="comment">// MPI_Sendrecv(a0, 1,   up_send_subarray,   up_ngb, 11,\</span></span><br><span class="line"><span class="comment">        //              a0, 1, down_recv_subarray, down_ngb, 11, cart_comm, &amp;status);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> JJ = y_start; JJ &lt; y_end; JJ += SET_Y_SIZE) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> II = x_start; II &lt; x_end; II += SET_X_SIZE)&#123;</span><br><span class="line">                <span class="type">int</span> REAL_Y_SIZE = <span class="built_in">MIN</span>(SET_Y_SIZE, y_end - JJ);</span><br><span class="line">                <span class="type">int</span> REAL_X_SIZE = <span class="built_in">MIN</span>(SET_X_SIZE, x_end - II);</span><br><span class="line"></span><br><span class="line">                <span class="type">ptr_t</span> a1_local = a1 + z_start*ldx*ldy + JJ*ldx + II;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_Z = a0 + (a1_local - a1);</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_P = a0_local_Z + ldy*ldx;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_N = a0_local_Z - ldy*ldx;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> z = z_start; z &lt; z_end; ++z) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; REAL_Y_SIZE; y++) &#123;</span><br><span class="line">                        <span class="meta">#<span class="keyword">pragma</span> unroll</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; REAL_X_SIZE; x++) &#123;</span><br><span class="line">                            a1_local[y*ldx+x] \</span><br><span class="line">                                = ALPHA_ZZZ * a0_local_Z[y*ldx+x] \</span><br><span class="line">                                + ALPHA_NZZ * a0_local_Z[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZZ * a0_local_Z[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_ZNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZN * a0_local_N[y*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZP * a0_local_P[y*ldx+x] \</span><br><span class="line">                                + ALPHA_NNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NZN * a0_local_N[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZN * a0_local_N[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NZP * a0_local_P[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZP * a0_local_P[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_ZNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_NNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>];</span><br><span class="line">                        &#125;<span class="comment">// x</span></span><br><span class="line">                    &#125;<span class="comment">// y</span></span><br><span class="line">                    a1_local = a1_local + ldx*ldy;</span><br><span class="line">                    a0_local_N = a0_local_Z;</span><br><span class="line">                    a0_local_Z = a0_local_P;</span><br><span class="line">                    a0_local_P = a0_local_P + ldx*ldy;</span><br><span class="line">                &#125;<span class="comment">// z</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer[nt % <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维zy轴划分"><a href="#二维zy轴划分" class="headerlink" title="二维zy轴划分"></a>二维zy轴划分</h3><p>综合上述一维划分的结果，在二维划分时考虑采用z和y轴联合划分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* version_name = <span class="string">&quot;A mpi version with 2D partition in z &amp; y&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SET_Y_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_Y_SIZE 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SET_X_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_X_SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line">MPI_Comm cart_comm;</span><br><span class="line"><span class="type">int</span> cart_ids[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//     6      2      5</span></span><br><span class="line"><span class="comment">// y(1)</span></span><br><span class="line"><span class="comment">//  ^  3      0      1</span></span><br><span class="line"><span class="comment">//  |</span></span><br><span class="line"><span class="comment">//  |  7      4      8</span></span><br><span class="line"><span class="comment">//  ------&gt; z (0)</span></span><br><span class="line"><span class="type">int</span> oppo_idx[<span class="number">9</span>] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> ngbs[<span class="number">9</span>];</span><br><span class="line">MPI_Datatype send_subarray[<span class="number">9</span>], recv_subarray[<span class="number">9</span>];</span><br><span class="line">MPI_Status status;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建分布式网格：可以根据7点或27点类型做不同的划分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_dist_grid</span><span class="params">(<span class="type">dist_grid_info_t</span> *grid_info, <span class="type">int</span> stencil_type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二维划分 沿zy轴切</span></span><br><span class="line">    <span class="type">int</span> sqr_root = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num_proc_y, num_proc_z;</span><br><span class="line">    <span class="keyword">while</span> (sqr_root*sqr_root &lt; grid_info-&gt;p_num) sqr_root++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sqr_root*sqr_root == grid_info-&gt;p_num) &#123;</span><br><span class="line">        num_proc_z = num_proc_y = sqr_root;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (grid_info-&gt;p_num%tmp==<span class="number">0</span> &amp;&amp; grid_info-&gt;p_num/tmp&gt;tmp) tmp *= <span class="number">2</span>;</span><br><span class="line">        num_proc_z = grid_info-&gt;p_num / tmp;<span class="comment">//跳出while时tmp&gt;sqrt(p_num)</span></span><br><span class="line">        num_proc_y = tmp;</span><br><span class="line">        <span class="comment">// num_proc_z = tmp;</span></span><br><span class="line">        <span class="comment">// num_proc_y = grid_info-&gt;p_num / tmp;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid_info-&gt;p_id == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 2D partition: num_proc_y: %d, num_proc_z:%d\n&quot;</span>, num_proc_y, num_proc_z);</span><br><span class="line">    <span class="comment">// x轴不切</span></span><br><span class="line">    grid_info-&gt;local_size_x = grid_info-&gt;global_size_x;</span><br><span class="line">    <span class="comment">// y轴</span></span><br><span class="line">    <span class="keyword">if</span> (grid_info-&gt;global_size_y % num_proc_y != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid_info-&gt;p_id == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; Error: %d cannot divide %d!\n&quot;</span>, grid_info-&gt;global_size_y, num_proc_y);</span><br><span class="line">        <span class="built_in">MPI_Abort</span>(MPI_COMM_WORLD, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    grid_info-&gt;local_size_y = grid_info-&gt;global_size_y / num_proc_y;</span><br><span class="line">    <span class="comment">// z轴</span></span><br><span class="line">    <span class="keyword">if</span> (grid_info-&gt;global_size_z % num_proc_z != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid_info-&gt;p_id == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; Error: %d cannot divide %d!\n&quot;</span>, grid_info-&gt;global_size_z, num_proc_z);</span><br><span class="line">        <span class="built_in">MPI_Abort</span>(MPI_COMM_WORLD, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    grid_info-&gt;local_size_z = grid_info-&gt;global_size_z / num_proc_z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    global: %d %d %d    local : %d %d %d    offset: %d %d %d\n&quot;, grid_info-&gt;p_id,\</span></span><br><span class="line"><span class="comment">    //     grid_info-&gt;global_size_z, grid_info-&gt;global_size_y, grid_info-&gt;global_size_x,\</span></span><br><span class="line"><span class="comment">    //     grid_info-&gt;local_size_z, grid_info-&gt;local_size_y, grid_info-&gt;local_size_x,\</span></span><br><span class="line"><span class="comment">    //     grid_info-&gt;offset_z, grid_info-&gt;offset_y, grid_info-&gt;offset_x);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建通信的拓扑</span></span><br><span class="line">    ngbs[<span class="number">0</span>] = grid_info-&gt;p_id;</span><br><span class="line">    <span class="type">int</span> dims[<span class="number">2</span>] = &#123;num_proc_z, num_proc_y&#125;;</span><br><span class="line">    <span class="type">int</span> periods[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">MPI_Cart_create</span>(MPI_COMM_WORLD, <span class="number">2</span>, dims, &amp;periods, <span class="number">0</span>, &amp;cart_comm);</span><br><span class="line">    <span class="built_in">MPI_Cart_shift</span>(cart_comm, <span class="number">0</span>, <span class="number">1</span>, &amp;ngbs[<span class="number">3</span>], &amp;ngbs[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">MPI_Cart_shift</span>(cart_comm, <span class="number">1</span>, <span class="number">1</span>, &amp;ngbs[<span class="number">4</span>], &amp;ngbs[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dist_y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ngbs[<span class="number">1</span>]==MPI_PROC_NULL || ngbs[<span class="number">2</span>]==MPI_PROC_NULL) ngbs[<span class="number">5</span>] = MPI_PROC_NULL;</span><br><span class="line">    <span class="keyword">else</span> ngbs[<span class="number">5</span>] = ngbs[<span class="number">1</span>] + dist_y; </span><br><span class="line">    <span class="keyword">if</span> (ngbs[<span class="number">1</span>]==MPI_PROC_NULL || ngbs[<span class="number">4</span>]==MPI_PROC_NULL) ngbs[<span class="number">8</span>] = MPI_PROC_NULL;</span><br><span class="line">    <span class="keyword">else</span> ngbs[<span class="number">8</span>] = ngbs[<span class="number">1</span>] - dist_y; </span><br><span class="line">    <span class="keyword">if</span> (ngbs[<span class="number">2</span>]==MPI_PROC_NULL || ngbs[<span class="number">3</span>]==MPI_PROC_NULL) ngbs[<span class="number">6</span>] = MPI_PROC_NULL;</span><br><span class="line">    <span class="keyword">else</span> ngbs[<span class="number">6</span>] = ngbs[<span class="number">3</span>] + dist_y;</span><br><span class="line">    <span class="keyword">if</span> (ngbs[<span class="number">3</span>]==MPI_PROC_NULL || ngbs[<span class="number">4</span>]==MPI_PROC_NULL) ngbs[<span class="number">7</span>] = MPI_PROC_NULL;</span><br><span class="line">    <span class="keyword">else</span> ngbs[<span class="number">7</span>] = ngbs[<span class="number">3</span>] - dist_y; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Cart_coords</span>(cart_comm, grid_info-&gt;p_id, <span class="number">2</span>, &amp;cart_ids);</span><br><span class="line"></span><br><span class="line">    grid_info-&gt;offset_x = <span class="number">0</span>;</span><br><span class="line">    grid_info-&gt;offset_y = grid_info-&gt;local_size_y * cart_ids[<span class="number">1</span>];</span><br><span class="line">    grid_info-&gt;offset_z = grid_info-&gt;local_size_z * cart_ids[<span class="number">0</span>];</span><br><span class="line">    grid_info-&gt;halo_size_x = <span class="number">1</span>;</span><br><span class="line">    grid_info-&gt;halo_size_y = <span class="number">1</span>;</span><br><span class="line">    grid_info-&gt;halo_size_z = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    cart_id[0]: %d    cart_id[1]: %d\n %d %d %d %d %d %d %d %d %d\n offset_y:%d    offset_z:%d\n&quot;, grid_info-&gt;p_id, cart_ids[0], cart_ids[1],\</span></span><br><span class="line"><span class="comment">    //     ngbs[0],ngbs[1],ngbs[2],ngbs[3],ngbs[4],ngbs[5],ngbs[6],ngbs[7],ngbs[8], grid_info-&gt;offset_y, grid_info-&gt;offset_z);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建subarray</span></span><br><span class="line">    <span class="type">int</span> size[<span class="number">3</span>] = &#123; grid_info-&gt;local_size_z + <span class="number">2</span>*grid_info-&gt;halo_size_z,\</span><br><span class="line">                    grid_info-&gt;local_size_y + <span class="number">2</span>*grid_info-&gt;halo_size_y,\</span><br><span class="line">                    grid_info-&gt;local_size_x + <span class="number">2</span>*grid_info-&gt;halo_size_x&#125;;</span><br><span class="line">    <span class="type">int</span> subsize[<span class="number">3</span>], send_start[<span class="number">3</span>], recv_start[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            subsize[<span class="number">0</span>] = grid_info-&gt;halo_size_z;</span><br><span class="line">            subsize[<span class="number">1</span>] = grid_info-&gt;local_size_y;<span class="comment">// 注意是local_size 不带halo_width</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            subsize[<span class="number">0</span>] = grid_info-&gt;local_size_z;</span><br><span class="line">            subsize[<span class="number">1</span>] = grid_info-&gt;halo_size_y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            subsize[<span class="number">0</span>] = grid_info-&gt;halo_size_z;</span><br><span class="line">            subsize[<span class="number">1</span>] = grid_info-&gt;local_size_y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            subsize[<span class="number">0</span>] = grid_info-&gt;local_size_z;</span><br><span class="line">            subsize[<span class="number">1</span>] = grid_info-&gt;halo_size_y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="comment">// 5,6,7,8</span></span><br><span class="line">            subsize[<span class="number">0</span>] = grid_info-&gt;halo_size_z;</span><br><span class="line">            subsize[<span class="number">1</span>] = grid_info-&gt;halo_size_y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        subsize[<span class="number">2</span>] = grid_info-&gt;local_size_x + <span class="number">2</span>*grid_info-&gt;halo_size_x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">// up_z</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;local_size_z;                          send_start[<span class="number">1</span>] = grid_info-&gt;halo_size_y; send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z; recv_start[<span class="number">1</span>] = grid_info-&gt;halo_size_y; recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">// down_z</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;halo_size_z; send_start[<span class="number">1</span>] = grid_info-&gt;halo_size_y; send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = <span class="number">0</span>;                      recv_start[<span class="number">1</span>] = grid_info-&gt;halo_size_y; recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">// up_y</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;halo_size_z; send_start[<span class="number">1</span>] = grid_info-&gt;local_size_y;                          send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = grid_info-&gt;halo_size_z; recv_start[<span class="number">1</span>] = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y; recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">// down_y</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;halo_size_z; send_start[<span class="number">1</span>] = grid_info-&gt;halo_size_y; send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = grid_info-&gt;halo_size_z; recv_start[<span class="number">1</span>] = <span class="number">0</span>;                      recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:<span class="comment">// up_z_up_y</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;local_size_z;                          send_start[<span class="number">1</span>] = grid_info-&gt;local_size_y;                          send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z; recv_start[<span class="number">1</span>] = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y; recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:<span class="comment">// down_z_up_y</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;halo_size_z; send_start[<span class="number">1</span>] = grid_info-&gt;local_size_y;                          send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = <span class="number">0</span>;                      recv_start[<span class="number">1</span>] = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y; recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:<span class="comment">// down_z_down_y</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;halo_size_z; send_start[<span class="number">1</span>] = grid_info-&gt;halo_size_y; send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = <span class="number">0</span>;                      recv_start[<span class="number">1</span>] = <span class="number">0</span>;                      recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:<span class="comment">// up_z_down_y</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;local_size_z;                          send_start[<span class="number">1</span>] = grid_info-&gt;halo_size_y; send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z; recv_start[<span class="number">1</span>] = <span class="number">0</span>;                      recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, send_start, MPI_ORDER_C, DATA_TYPE, &amp;send_subarray[i]);</span><br><span class="line">        <span class="built_in">MPI_Type_commit</span>(&amp;send_subarray[i]);</span><br><span class="line">        <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, recv_start, MPI_ORDER_C, DATA_TYPE, &amp;recv_subarray[i]);</span><br><span class="line">        <span class="built_in">MPI_Type_commit</span>(&amp;recv_subarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy_dist_grid</span><span class="params">(<span class="type">dist_grid_info_t</span> *grid_info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (send_subarray[i] != MPI_DATATYPE_NULL) </span><br><span class="line">            <span class="built_in">MPI_Type_free</span>(&amp;send_subarray[i]);</span><br><span class="line">        <span class="keyword">if</span> (recv_subarray[i] != MPI_DATATYPE_NULL)</span><br><span class="line">            <span class="built_in">MPI_Type_free</span>(&amp;recv_subarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ptr_t</span> <span class="title">stencil_7</span><span class="params">(<span class="type">ptr_t</span> grid, <span class="type">ptr_t</span> aux, <span class="type">const</span> <span class="type">dist_grid_info_t</span> *grid_info, <span class="type">int</span> nt, <span class="type">double</span> * calc_time, <span class="type">double</span> * comm_time)</span> </span>&#123;</span><br><span class="line">    <span class="type">ptr_t</span> buffer[<span class="number">2</span>] = &#123;grid, aux&#125;;</span><br><span class="line">    <span class="type">int</span> x_start = grid_info-&gt;halo_size_x, x_end = grid_info-&gt;local_size_x + grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> y_start = grid_info-&gt;halo_size_y, y_end = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> z_start = grid_info-&gt;halo_size_z, z_end = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">int</span> ldx = grid_info-&gt;local_size_x + <span class="number">2</span> * grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> ldy = grid_info-&gt;local_size_y + <span class="number">2</span> * grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> ldz = grid_info-&gt;local_size_z + <span class="number">2</span> * grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">double</span> t_last, t_curr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; nt; ++t) &#123;</span><br><span class="line">        <span class="type">cptr_t</span> a0 = buffer[t % <span class="number">2</span>];</span><br><span class="line">        <span class="type">ptr_t</span> a1 = buffer[(t + <span class="number">1</span>) % <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通信同步(要让a0的边界是对的值！)</span></span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;<span class="comment">// 7点stencil只需要通信4个</span></span><br><span class="line">            <span class="type">int</span> oppo = oppo_idx[i];</span><br><span class="line">            <span class="built_in">MPI_Sendrecv</span>(a0, <span class="number">1</span>, send_subarray[i]   , ngbs[i]   , grid_info-&gt;p_id ^ ngbs[i]   ,\</span><br><span class="line">                         a0, <span class="number">1</span>, recv_subarray[oppo], ngbs[oppo], grid_info-&gt;p_id ^ ngbs[oppo], cart_comm, &amp;status);</span><br><span class="line">        &#125;</span><br><span class="line">        t_last = t_curr;</span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        *comm_time += t_curr - t_last;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> JJ = y_start; JJ &lt; y_end; JJ += SET_Y_SIZE) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> II = x_start; II &lt; x_end; II += SET_X_SIZE)&#123;</span><br><span class="line">                <span class="type">int</span> REAL_Y_SIZE = <span class="built_in">MIN</span>(SET_Y_SIZE, y_end - JJ);</span><br><span class="line">                <span class="type">int</span> REAL_X_SIZE = <span class="built_in">MIN</span>(SET_X_SIZE, x_end - II);</span><br><span class="line">    </span><br><span class="line">                <span class="type">ptr_t</span> a1_local = a1 + z_start*ldx*ldy + JJ*ldx + II;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_Z = a0 + (a1_local - a1);</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_P = a0_local_Z + ldy*ldx;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_N = a0_local_Z - ldy*ldx;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> z = z_start; z &lt; z_end; ++z) &#123;  </span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; REAL_Y_SIZE; y++) &#123;</span><br><span class="line">                        <span class="meta">#<span class="keyword">pragma</span> unroll</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; REAL_X_SIZE; x++) &#123;</span><br><span class="line">                            a1_local[y*ldx+x] \</span><br><span class="line">                                = ALPHA_ZZZ * a0_local_Z[y*ldx+x]\</span><br><span class="line">                                + ALPHA_NZZ * a0_local_Z[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZZ * a0_local_Z[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_ZNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZN * a0_local_N[y*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZP * a0_local_P[y*ldx+x];</span><br><span class="line"></span><br><span class="line">                        &#125;<span class="comment">// x loop</span></span><br><span class="line">                    &#125;<span class="comment">// y loop</span></span><br><span class="line">                    a1_local = a1_local + ldx*ldy;</span><br><span class="line">                    a0_local_N = a0_local_Z;</span><br><span class="line">                    a0_local_Z = a0_local_P;</span><br><span class="line">                    a0_local_P = a0_local_P + ldx*ldy;</span><br><span class="line">                &#125;<span class="comment">// z loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t_last = t_curr;</span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        *calc_time += t_curr - t_last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer[nt % <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ptr_t</span> <span class="title">stencil_27</span><span class="params">(<span class="type">ptr_t</span> grid, <span class="type">ptr_t</span> aux, <span class="type">const</span> <span class="type">dist_grid_info_t</span> *grid_info, <span class="type">int</span> nt, <span class="type">double</span> * calc_time, <span class="type">double</span> * comm_time)</span> </span>&#123;</span><br><span class="line">    <span class="type">ptr_t</span> buffer[<span class="number">2</span>] = &#123;grid, aux&#125;;</span><br><span class="line">    <span class="type">int</span> x_start = grid_info-&gt;halo_size_x, x_end = grid_info-&gt;local_size_x + grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> y_start = grid_info-&gt;halo_size_y, y_end = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> z_start = grid_info-&gt;halo_size_z, z_end = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">int</span> ldx = grid_info-&gt;local_size_x + <span class="number">2</span> * grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> ldy = grid_info-&gt;local_size_y + <span class="number">2</span> * grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> ldz = grid_info-&gt;local_size_z + <span class="number">2</span> * grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">double</span> t_last, t_curr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; nt; ++t) &#123;</span><br><span class="line">        <span class="type">cptr_t</span> restrict a0 = buffer[t % <span class="number">2</span>];</span><br><span class="line">        <span class="type">ptr_t</span> restrict a1 = buffer[(t + <span class="number">1</span>) % <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通信同步(要让a0的边界是对的值！)</span></span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;<span class="comment">// 27点stencil需要通信8个</span></span><br><span class="line">            <span class="type">int</span> oppo = oppo_idx[i];</span><br><span class="line">            <span class="built_in">MPI_Sendrecv</span>(a0, <span class="number">1</span>, send_subarray[i]   , ngbs[i]   , grid_info-&gt;p_id ^ ngbs[i]   ,\</span><br><span class="line">                         a0, <span class="number">1</span>, recv_subarray[oppo], ngbs[oppo], grid_info-&gt;p_id ^ ngbs[oppo], cart_comm, &amp;status);</span><br><span class="line">        &#125;</span><br><span class="line">        t_last = t_curr;</span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        *comm_time += t_curr - t_last;</span><br><span class="line"></span><br><span class="line">        t_last = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> JJ = y_start; JJ &lt; y_end; JJ += SET_Y_SIZE) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> II = x_start; II &lt; x_end; II += SET_X_SIZE)&#123;</span><br><span class="line">                <span class="type">int</span> REAL_Y_SIZE = <span class="built_in">MIN</span>(SET_Y_SIZE, y_end - JJ);</span><br><span class="line">                <span class="type">int</span> REAL_X_SIZE = <span class="built_in">MIN</span>(SET_X_SIZE, x_end - II);</span><br><span class="line"></span><br><span class="line">                <span class="type">ptr_t</span> a1_local = a1 + z_start*ldx*ldy + JJ*ldx + II;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_Z = a0 + (a1_local - a1);</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_P = a0_local_Z + ldy*ldx;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_N = a0_local_Z - ldy*ldx;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> z = z_start; z &lt; z_end; ++z) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; REAL_Y_SIZE; y++) &#123;</span><br><span class="line">                        <span class="meta">#<span class="keyword">pragma</span> unroll</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; REAL_X_SIZE; x++) &#123;</span><br><span class="line">                            a1_local[y*ldx+x] \</span><br><span class="line">                                = ALPHA_ZZZ * a0_local_Z[y*ldx+x] \</span><br><span class="line">                                + ALPHA_NZZ * a0_local_Z[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZZ * a0_local_Z[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_ZNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZN * a0_local_N[y*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZP * a0_local_P[y*ldx+x] \</span><br><span class="line">                                + ALPHA_NNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NZN * a0_local_N[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZN * a0_local_N[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NZP * a0_local_P[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZP * a0_local_P[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_ZNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_NNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>];</span><br><span class="line">                        &#125;<span class="comment">// x</span></span><br><span class="line">                    &#125;<span class="comment">// y</span></span><br><span class="line">                    a1_local = a1_local + ldx*ldy;</span><br><span class="line">                    a0_local_N = a0_local_Z;</span><br><span class="line">                    a0_local_Z = a0_local_P;</span><br><span class="line">                    a0_local_P = a0_local_P + ldx*ldy;</span><br><span class="line">                &#125;<span class="comment">// z</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t_last = t_curr;</span><br><span class="line">        t_curr = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">        *calc_time += t_curr - t_last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer[nt % <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算通信重叠和非阻塞通信"><a href="#计算通信重叠和非阻塞通信" class="headerlink" title="计算通信重叠和非阻塞通信"></a>计算通信重叠和非阻塞通信</h3><p>基于上一节的二维zy轴划分，考虑计算通信重叠的实现，即每个进程先算自己的内halo区（邻居进程的外halo区），然后用非阻塞通信将内halo区数据通信。在此通信过程中，各进程计算自己真正的内部区域（不与其他进程有依赖关系的区域）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* version_name = <span class="string">&quot;A mpi comp-comm overlapped&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SET_Y_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_Y_SIZE 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SET_X_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_X_SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line">MPI_Comm cart_comm;</span><br><span class="line"><span class="type">int</span> cart_ids[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//     6      2      5</span></span><br><span class="line"><span class="comment">// y(1)</span></span><br><span class="line"><span class="comment">//  ^  3      0      1</span></span><br><span class="line"><span class="comment">//  |</span></span><br><span class="line"><span class="comment">//  |  7      4      8</span></span><br><span class="line"><span class="comment">//  ------&gt; z (0)</span></span><br><span class="line"><span class="type">int</span> oppo_idx[<span class="number">9</span>] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> ngbs[<span class="number">9</span>];</span><br><span class="line">MPI_Datatype send_subarray[<span class="number">9</span>], recv_subarray[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> ih_z_beg[<span class="number">9</span>], ih_z_end[<span class="number">9</span>], ih_y_beg[<span class="number">9</span>], ih_y_end[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建分布式网格：可以根据7点或27点类型做不同的划分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">create_dist_grid</span><span class="params">(<span class="type">dist_grid_info_t</span> *grid_info, <span class="type">int</span> stencil_type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二维划分 沿zy轴切</span></span><br><span class="line">    <span class="type">int</span> sqr_root = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num_proc_y, num_proc_z;</span><br><span class="line">    <span class="keyword">while</span> (sqr_root*sqr_root &lt; grid_info-&gt;p_num) sqr_root++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sqr_root*sqr_root == grid_info-&gt;p_num) &#123;</span><br><span class="line">        num_proc_z = num_proc_y = sqr_root;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (grid_info-&gt;p_num%tmp==<span class="number">0</span> &amp;&amp; grid_info-&gt;p_num/tmp&gt;tmp) tmp *= <span class="number">2</span>;</span><br><span class="line">        num_proc_z = grid_info-&gt;p_num / tmp;<span class="comment">//跳出while时tmp&gt;sqrt(p_num)</span></span><br><span class="line">        num_proc_y = tmp;</span><br><span class="line">        <span class="comment">// num_proc_z = tmp;</span></span><br><span class="line">        <span class="comment">// num_proc_y = grid_info-&gt;p_num / tmp;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid_info-&gt;p_id == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 2D partition: num_proc_y: %d, num_proc_z:%d\n&quot;</span>, num_proc_y, num_proc_z);</span><br><span class="line">    <span class="comment">// x轴不切</span></span><br><span class="line">    grid_info-&gt;local_size_x = grid_info-&gt;global_size_x;</span><br><span class="line">    <span class="comment">// y轴</span></span><br><span class="line">    <span class="keyword">if</span> (grid_info-&gt;global_size_y % num_proc_y != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid_info-&gt;p_id == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; Error: %d cannot divide %d!\n&quot;</span>, grid_info-&gt;global_size_y, num_proc_y);</span><br><span class="line">        <span class="built_in">MPI_Abort</span>(MPI_COMM_WORLD, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    grid_info-&gt;local_size_y = grid_info-&gt;global_size_y / num_proc_y;</span><br><span class="line">    <span class="comment">// z轴</span></span><br><span class="line">    <span class="keyword">if</span> (grid_info-&gt;global_size_z % num_proc_z != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid_info-&gt;p_id == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; Error: %d cannot divide %d!\n&quot;</span>, grid_info-&gt;global_size_z, num_proc_z);</span><br><span class="line">        <span class="built_in">MPI_Abort</span>(MPI_COMM_WORLD, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    grid_info-&gt;local_size_z = grid_info-&gt;global_size_z / num_proc_z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    global: %d %d %d    local : %d %d %d    offset: %d %d %d\n&quot;, grid_info-&gt;p_id,\</span></span><br><span class="line"><span class="comment">    //     grid_info-&gt;global_size_z, grid_info-&gt;global_size_y, grid_info-&gt;global_size_x,\</span></span><br><span class="line"><span class="comment">    //     grid_info-&gt;local_size_z, grid_info-&gt;local_size_y, grid_info-&gt;local_size_x,\</span></span><br><span class="line"><span class="comment">    //     grid_info-&gt;offset_z, grid_info-&gt;offset_y, grid_info-&gt;offset_x);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建通信的拓扑</span></span><br><span class="line">    ngbs[<span class="number">0</span>] = grid_info-&gt;p_id;</span><br><span class="line">    <span class="type">int</span> dims[<span class="number">2</span>] = &#123;num_proc_z, num_proc_y&#125;;</span><br><span class="line">    <span class="type">int</span> periods[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">MPI_Cart_create</span>(MPI_COMM_WORLD, <span class="number">2</span>, dims, &amp;periods, <span class="number">0</span>, &amp;cart_comm);</span><br><span class="line">    <span class="built_in">MPI_Cart_shift</span>(cart_comm, <span class="number">0</span>, <span class="number">1</span>, &amp;ngbs[<span class="number">3</span>], &amp;ngbs[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">MPI_Cart_shift</span>(cart_comm, <span class="number">1</span>, <span class="number">1</span>, &amp;ngbs[<span class="number">4</span>], &amp;ngbs[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dist_y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ngbs[<span class="number">1</span>]==MPI_PROC_NULL || ngbs[<span class="number">2</span>]==MPI_PROC_NULL) ngbs[<span class="number">5</span>] = MPI_PROC_NULL;</span><br><span class="line">    <span class="keyword">else</span> ngbs[<span class="number">5</span>] = ngbs[<span class="number">1</span>] + dist_y; </span><br><span class="line">    <span class="keyword">if</span> (ngbs[<span class="number">1</span>]==MPI_PROC_NULL || ngbs[<span class="number">4</span>]==MPI_PROC_NULL) ngbs[<span class="number">8</span>] = MPI_PROC_NULL;</span><br><span class="line">    <span class="keyword">else</span> ngbs[<span class="number">8</span>] = ngbs[<span class="number">1</span>] - dist_y; </span><br><span class="line">    <span class="keyword">if</span> (ngbs[<span class="number">2</span>]==MPI_PROC_NULL || ngbs[<span class="number">3</span>]==MPI_PROC_NULL) ngbs[<span class="number">6</span>] = MPI_PROC_NULL;</span><br><span class="line">    <span class="keyword">else</span> ngbs[<span class="number">6</span>] = ngbs[<span class="number">3</span>] + dist_y;</span><br><span class="line">    <span class="keyword">if</span> (ngbs[<span class="number">3</span>]==MPI_PROC_NULL || ngbs[<span class="number">4</span>]==MPI_PROC_NULL) ngbs[<span class="number">7</span>] = MPI_PROC_NULL;</span><br><span class="line">    <span class="keyword">else</span> ngbs[<span class="number">7</span>] = ngbs[<span class="number">3</span>] - dist_y; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Cart_coords</span>(cart_comm, grid_info-&gt;p_id, <span class="number">2</span>, &amp;cart_ids);</span><br><span class="line"></span><br><span class="line">    grid_info-&gt;offset_x = <span class="number">0</span>;</span><br><span class="line">    grid_info-&gt;offset_y = grid_info-&gt;local_size_y * cart_ids[<span class="number">1</span>];</span><br><span class="line">    grid_info-&gt;offset_z = grid_info-&gt;local_size_z * cart_ids[<span class="number">0</span>];</span><br><span class="line">    grid_info-&gt;halo_size_x = <span class="number">1</span>;</span><br><span class="line">    grid_info-&gt;halo_size_y = <span class="number">1</span>;</span><br><span class="line">    grid_info-&gt;halo_size_z = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;pid: %d    cart_id[0]: %d    cart_id[1]: %d\n %d %d %d %d %d %d %d %d %d\n offset_y:%d    offset_z:%d\n&quot;, grid_info-&gt;p_id, cart_ids[0], cart_ids[1],\</span></span><br><span class="line"><span class="comment">    //     ngbs[0],ngbs[1],ngbs[2],ngbs[3],ngbs[4],ngbs[5],ngbs[6],ngbs[7],ngbs[8], grid_info-&gt;offset_y, grid_info-&gt;offset_z);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建subarray</span></span><br><span class="line">    <span class="type">int</span> size[<span class="number">3</span>] = &#123; grid_info-&gt;local_size_z + <span class="number">2</span>*grid_info-&gt;halo_size_z,\</span><br><span class="line">                    grid_info-&gt;local_size_y + <span class="number">2</span>*grid_info-&gt;halo_size_y,\</span><br><span class="line">                    grid_info-&gt;local_size_x + <span class="number">2</span>*grid_info-&gt;halo_size_x&#125;;</span><br><span class="line">    <span class="type">int</span> subsize[<span class="number">3</span>], send_start[<span class="number">3</span>], recv_start[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            subsize[<span class="number">0</span>] = grid_info-&gt;halo_size_z;</span><br><span class="line">            subsize[<span class="number">1</span>] = grid_info-&gt;local_size_y;<span class="comment">// 注意是local_size 不带halo_width</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            subsize[<span class="number">0</span>] = grid_info-&gt;local_size_z;</span><br><span class="line">            subsize[<span class="number">1</span>] = grid_info-&gt;halo_size_y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            subsize[<span class="number">0</span>] = grid_info-&gt;halo_size_z;</span><br><span class="line">            subsize[<span class="number">1</span>] = grid_info-&gt;local_size_y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            subsize[<span class="number">0</span>] = grid_info-&gt;local_size_z;</span><br><span class="line">            subsize[<span class="number">1</span>] = grid_info-&gt;halo_size_y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="comment">// 5,6,7,8</span></span><br><span class="line">            subsize[<span class="number">0</span>] = grid_info-&gt;halo_size_z;</span><br><span class="line">            subsize[<span class="number">1</span>] = grid_info-&gt;halo_size_y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        subsize[<span class="number">2</span>] = grid_info-&gt;local_size_x + <span class="number">2</span>*grid_info-&gt;halo_size_x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">// up_z</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;local_size_z;                          send_start[<span class="number">1</span>] = grid_info-&gt;halo_size_y; send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z; recv_start[<span class="number">1</span>] = grid_info-&gt;halo_size_y; recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:<span class="comment">// down_z</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;halo_size_z; send_start[<span class="number">1</span>] = grid_info-&gt;halo_size_y; send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = <span class="number">0</span>;                      recv_start[<span class="number">1</span>] = grid_info-&gt;halo_size_y; recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:<span class="comment">// up_y</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;halo_size_z; send_start[<span class="number">1</span>] = grid_info-&gt;local_size_y;                          send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = grid_info-&gt;halo_size_z; recv_start[<span class="number">1</span>] = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y; recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">// down_y</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;halo_size_z; send_start[<span class="number">1</span>] = grid_info-&gt;halo_size_y; send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = grid_info-&gt;halo_size_z; recv_start[<span class="number">1</span>] = <span class="number">0</span>;                      recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:<span class="comment">// up_z_up_y</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;local_size_z;                          send_start[<span class="number">1</span>] = grid_info-&gt;local_size_y;                          send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z; recv_start[<span class="number">1</span>] = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y; recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:<span class="comment">// down_z_up_y</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;halo_size_z; send_start[<span class="number">1</span>] = grid_info-&gt;local_size_y;                          send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = <span class="number">0</span>;                      recv_start[<span class="number">1</span>] = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y; recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:<span class="comment">// down_z_down_y</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;halo_size_z; send_start[<span class="number">1</span>] = grid_info-&gt;halo_size_y; send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = <span class="number">0</span>;                      recv_start[<span class="number">1</span>] = <span class="number">0</span>;                      recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:<span class="comment">// up_z_down_y</span></span><br><span class="line">            send_start[<span class="number">0</span>] = grid_info-&gt;local_size_z;                          send_start[<span class="number">1</span>] = grid_info-&gt;halo_size_y; send_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            recv_start[<span class="number">0</span>] = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z; recv_start[<span class="number">1</span>] = <span class="number">0</span>;                      recv_start[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, send_start, MPI_ORDER_C, DATA_TYPE, &amp;send_subarray[i]);</span><br><span class="line">        <span class="built_in">MPI_Type_commit</span>(&amp;send_subarray[i]);</span><br><span class="line">        <span class="built_in">MPI_Type_create_subarray</span>(<span class="number">3</span>, size, subsize, recv_start, MPI_ORDER_C, DATA_TYPE, &amp;recv_subarray[i]);</span><br><span class="line">        <span class="built_in">MPI_Type_commit</span>(&amp;recv_subarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录计算通信重叠部分的内halo区(注意这是内halo！)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> dir = <span class="number">1</span>; dir &lt;= <span class="number">4</span>; dir++) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//   ----------------------------</span></span><br><span class="line">        <span class="comment">//   |         2          |     |</span></span><br><span class="line">        <span class="comment">//   |--------------------|     |</span></span><br><span class="line">        <span class="comment">//   |     |              |     |</span></span><br><span class="line">        <span class="comment">//   |     |              |  1  |</span></span><br><span class="line">        <span class="comment">//   |     |              |     |</span></span><br><span class="line">        <span class="comment">// y |  3  |              |     |</span></span><br><span class="line">        <span class="comment">// ^ |     |              |     |</span></span><br><span class="line">        <span class="comment">// | |     |--------------------|</span></span><br><span class="line">        <span class="comment">// | |     |          4         |</span></span><br><span class="line">        <span class="comment">// | ----------------------------</span></span><br><span class="line">        <span class="comment">// O----&gt; z</span></span><br><span class="line">        <span class="keyword">switch</span> (dir) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ih_z_beg[dir] = grid_info-&gt;local_size_z;</span><br><span class="line">            ih_z_end[dir] = grid_info-&gt;halo_size_z + grid_info-&gt;local_size_z;</span><br><span class="line">            ih_y_beg[dir] = grid_info-&gt;halo_size_y * <span class="number">2</span>;</span><br><span class="line">            ih_y_end[dir] = grid_info-&gt;halo_size_y + grid_info-&gt;local_size_y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            ih_z_beg[dir] = grid_info-&gt;halo_size_z;</span><br><span class="line">            ih_z_end[dir] = grid_info-&gt;local_size_z;</span><br><span class="line">            ih_y_beg[dir] = grid_info-&gt;local_size_y;</span><br><span class="line">            ih_y_end[dir] = ih_y_beg[dir] + grid_info-&gt;halo_size_y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            ih_z_beg[dir] = grid_info-&gt;halo_size_z;</span><br><span class="line">            ih_z_end[dir] = grid_info-&gt;halo_size_z * <span class="number">2</span>;</span><br><span class="line">            ih_y_beg[dir] = grid_info-&gt;halo_size_y;</span><br><span class="line">            ih_y_end[dir] = grid_info-&gt;local_size_y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            ih_z_beg[dir] = grid_info-&gt;halo_size_z * <span class="number">2</span>;</span><br><span class="line">            ih_z_end[dir] = grid_info-&gt;halo_size_z + grid_info-&gt;local_size_z;</span><br><span class="line">            ih_y_beg[dir] = grid_info-&gt;halo_size_y;</span><br><span class="line">            ih_y_end[dir] = grid_info-&gt;halo_size_y * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf(&quot;pid %d, dir %d, %d %d %d %d\n&quot;, grid_info-&gt;p_id, dir, ih_z_beg[dir], ih_z_end[dir], ih_y_beg[dir], ih_y_end[dir]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy_dist_grid</span><span class="params">(<span class="type">dist_grid_info_t</span> *grid_info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (send_subarray[i] != MPI_DATATYPE_NULL) </span><br><span class="line">            <span class="built_in">MPI_Type_free</span>(&amp;send_subarray[i]);</span><br><span class="line">        <span class="keyword">if</span> (recv_subarray[i] != MPI_DATATYPE_NULL)</span><br><span class="line">            <span class="built_in">MPI_Type_free</span>(&amp;recv_subarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ptr_t</span> <span class="title">stencil_7</span><span class="params">(<span class="type">ptr_t</span> grid, <span class="type">ptr_t</span> aux, <span class="type">const</span> <span class="type">dist_grid_info_t</span> *grid_info, <span class="type">int</span> nt, <span class="type">double</span> * calc_time, <span class="type">double</span> * comm_time)</span> </span>&#123;</span><br><span class="line">    <span class="type">ptr_t</span> buffer[<span class="number">2</span>] = &#123;grid, aux&#125;;</span><br><span class="line">    <span class="type">int</span> x_start = grid_info-&gt;halo_size_x, x_end = grid_info-&gt;local_size_x + grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> y_start = grid_info-&gt;halo_size_y, y_end = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> z_start = grid_info-&gt;halo_size_z, z_end = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">int</span> ldx = grid_info-&gt;local_size_x + <span class="number">2</span> * grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> ldy = grid_info-&gt;local_size_y + <span class="number">2</span> * grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> ldz = grid_info-&gt;local_size_z + <span class="number">2</span> * grid_info-&gt;halo_size_z;</span><br><span class="line">    MPI_Request req_send[<span class="number">4</span>], req_recv[<span class="number">4</span>];</span><br><span class="line">    MPI_Status status[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for boundary conditions</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;<span class="comment">// 7点stencil只需要通信4个</span></span><br><span class="line">        <span class="type">int</span> oppo = oppo_idx[i];</span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(buffer[<span class="number">0</span>], <span class="number">1</span>, send_subarray[i]   , ngbs[i]   , grid_info-&gt;p_id ^ ngbs[i]   ,\</span><br><span class="line">                     buffer[<span class="number">0</span>], <span class="number">1</span>, recv_subarray[oppo], ngbs[oppo], grid_info-&gt;p_id ^ ngbs[oppo], cart_comm, &amp;status[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// y_start += grid_info-&gt;halo_size_y; y_end -= grid_info-&gt;halo_size_y;</span></span><br><span class="line">    <span class="comment">// z_start += grid_info-&gt;halo_size_z; z_end -= grid_info-&gt;halo_size_z;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; nt; ++t) &#123;</span><br><span class="line">        <span class="type">cptr_t</span> a0 = buffer[t % <span class="number">2</span>];</span><br><span class="line">        <span class="type">ptr_t</span> a1 = buffer[(t + <span class="number">1</span>) % <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先计算内halo区</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dir = <span class="number">1</span>; dir &lt;= <span class="number">4</span>; dir++) &#123;</span><br><span class="line">            <span class="type">ptr_t</span> a1_local = a1 + ih_z_beg[dir]*ldx*ldy + ih_y_beg[dir]*ldx;</span><br><span class="line">            <span class="type">cptr_t</span> a0_local_Z = a0 + (a1_local - a1);</span><br><span class="line">            <span class="type">cptr_t</span> a0_local_P = a0_local_Z + ldy*ldx;</span><br><span class="line">            <span class="type">cptr_t</span> a0_local_N = a0_local_Z - ldy*ldx;</span><br><span class="line">            <span class="type">int</span> yy_end = ih_y_end[dir]-ih_y_beg[dir];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> z = ih_z_beg[dir]; z &lt; ih_z_end[dir]; z++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; yy_end; y++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> x = x_start; x &lt; x_end; x++)</span><br><span class="line">                        a1_local[y*ldx+x] \</span><br><span class="line">                            = ALPHA_ZZZ * a0_local_Z[y*ldx+x]\</span><br><span class="line">                            + ALPHA_NZZ * a0_local_Z[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                            + ALPHA_PZZ * a0_local_Z[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                            + ALPHA_ZNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                            + ALPHA_ZPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                            + ALPHA_ZZN * a0_local_N[y*ldx+x] \</span><br><span class="line">                            + ALPHA_ZZP * a0_local_P[y*ldx+x];</span><br><span class="line">                a1_local = a1_local + ldx*ldy;</span><br><span class="line">                a0_local_N = a0_local_Z;</span><br><span class="line">                a0_local_Z = a0_local_P;</span><br><span class="line">                a0_local_P = a0_local_P + ldx*ldy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 隐藏非阻塞通信</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dir = <span class="number">1</span>; dir &lt;= <span class="number">4</span>; dir++) &#123;</span><br><span class="line">            <span class="type">int</span> oppo = oppo_idx[dir];</span><br><span class="line">            <span class="built_in">MPI_Isend</span>(a1, <span class="number">1</span>, send_subarray[dir],  ngbs[dir],  grid_info-&gt;p_id ^ ngbs[dir],  cart_comm, &amp;req_send[dir<span class="number">-1</span>]);</span><br><span class="line">            <span class="built_in">MPI_Irecv</span>(a1, <span class="number">1</span>, recv_subarray[oppo], ngbs[oppo], grid_info-&gt;p_id ^ ngbs[oppo], cart_comm, &amp;req_recv[oppo<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> JJ = y_start; JJ &lt; y_end; JJ += SET_Y_SIZE) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> II = x_start; II &lt; x_end; II += SET_X_SIZE)&#123;</span><br><span class="line">                <span class="type">int</span> REAL_Y_SIZE = <span class="built_in">MIN</span>(SET_Y_SIZE, y_end - JJ);</span><br><span class="line">                <span class="type">int</span> REAL_X_SIZE = <span class="built_in">MIN</span>(SET_X_SIZE, x_end - II);</span><br><span class="line"></span><br><span class="line">                <span class="type">ptr_t</span> a1_local = a1 + z_start*ldx*ldy + JJ*ldx + II;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_Z = a0 + (a1_local - a1);</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_P = a0_local_Z + ldy*ldx;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_N = a0_local_Z - ldy*ldx;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> z = z_start; z &lt; z_end; ++z) &#123;  </span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; REAL_Y_SIZE; y++) &#123;</span><br><span class="line">                        <span class="meta">#<span class="keyword">pragma</span> unroll</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; REAL_X_SIZE; x++) &#123;</span><br><span class="line">                            a1_local[y*ldx+x] \</span><br><span class="line">                                = ALPHA_ZZZ * a0_local_Z[y*ldx+x]\</span><br><span class="line">                                + ALPHA_NZZ * a0_local_Z[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZZ * a0_local_Z[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_ZNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZN * a0_local_N[y*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZP * a0_local_P[y*ldx+x];</span><br><span class="line"></span><br><span class="line">                        &#125;<span class="comment">// x loop</span></span><br><span class="line">                    &#125;<span class="comment">// y loop</span></span><br><span class="line">                    a1_local = a1_local + ldx*ldy;</span><br><span class="line">                    a0_local_N = a0_local_Z;</span><br><span class="line">                    a0_local_Z = a0_local_P;</span><br><span class="line">                    a0_local_P = a0_local_P + ldx*ldy;</span><br><span class="line">                &#125;<span class="comment">// z loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">MPI_Waitall</span>(<span class="number">4</span>, req_recv, status);</span><br><span class="line">        <span class="built_in">MPI_Waitall</span>(<span class="number">4</span>, req_send, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buffer[nt % <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ptr_t</span> <span class="title">stencil_27</span><span class="params">(<span class="type">ptr_t</span> grid, <span class="type">ptr_t</span> aux, <span class="type">const</span> <span class="type">dist_grid_info_t</span> *grid_info, <span class="type">int</span> nt, <span class="type">double</span> * calc_time, <span class="type">double</span> * comm_time)</span> </span>&#123;</span><br><span class="line">    <span class="type">ptr_t</span> buffer[<span class="number">2</span>] = &#123;grid, aux&#125;;</span><br><span class="line">    <span class="type">int</span> x_start = grid_info-&gt;halo_size_x, x_end = grid_info-&gt;local_size_x + grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> y_start = grid_info-&gt;halo_size_y, y_end = grid_info-&gt;local_size_y + grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> z_start = grid_info-&gt;halo_size_z, z_end = grid_info-&gt;local_size_z + grid_info-&gt;halo_size_z;</span><br><span class="line">    <span class="type">int</span> ldx = grid_info-&gt;local_size_x + <span class="number">2</span> * grid_info-&gt;halo_size_x;</span><br><span class="line">    <span class="type">int</span> ldy = grid_info-&gt;local_size_y + <span class="number">2</span> * grid_info-&gt;halo_size_y;</span><br><span class="line">    <span class="type">int</span> ldz = grid_info-&gt;local_size_z + <span class="number">2</span> * grid_info-&gt;halo_size_z;</span><br><span class="line">    MPI_Request req_send[<span class="number">8</span>], req_recv[<span class="number">8</span>];</span><br><span class="line">    MPI_Status status[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for boundary conditions</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;<span class="comment">// 27点stencil需要通信8个</span></span><br><span class="line">        <span class="type">int</span> oppo = oppo_idx[i];</span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(buffer[<span class="number">0</span>], <span class="number">1</span>, send_subarray[i]   , ngbs[i]   , grid_info-&gt;p_id ^ ngbs[i]   ,\</span><br><span class="line">                     buffer[<span class="number">0</span>], <span class="number">1</span>, recv_subarray[oppo], ngbs[oppo], grid_info-&gt;p_id ^ ngbs[oppo], cart_comm, &amp;status[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刨去外周一圈，导致对不齐（或者别的原因？），速度骤降，比重新再多算一遍外周还慢得多！！！</span></span><br><span class="line">    <span class="comment">// y_start += grid_info-&gt;halo_size_y; y_end -= grid_info-&gt;halo_size_y;</span></span><br><span class="line">    <span class="comment">// z_start += grid_info-&gt;halo_size_z; z_end -= grid_info-&gt;halo_size_z;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; nt; ++t) &#123;</span><br><span class="line">        <span class="type">cptr_t</span> a0 = buffer[t % <span class="number">2</span>];</span><br><span class="line">        <span class="type">ptr_t</span> a1 = buffer[(t + <span class="number">1</span>) % <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先计算内halo区</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dir = <span class="number">1</span>; dir &lt;= <span class="number">4</span>; dir++) &#123;</span><br><span class="line">            <span class="type">ptr_t</span> a1_local = a1 + ih_z_beg[dir]*ldx*ldy + ih_y_beg[dir]*ldx;</span><br><span class="line">            <span class="type">cptr_t</span> a0_local_Z = a0 + (a1_local - a1);</span><br><span class="line">            <span class="type">cptr_t</span> a0_local_P = a0_local_Z + ldy*ldx;</span><br><span class="line">            <span class="type">cptr_t</span> a0_local_N = a0_local_Z - ldy*ldx;</span><br><span class="line">            <span class="type">int</span> yy_end = ih_y_end[dir]-ih_y_beg[dir];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> z = ih_z_beg[dir]; z &lt; ih_z_end[dir]; z++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; yy_end; y++)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> x = x_start; x &lt; x_end; x++)</span><br><span class="line">                        a1_local[y*ldx+x] \</span><br><span class="line">                            = ALPHA_ZZZ * a0_local_Z[y*ldx+x] \</span><br><span class="line">                            + ALPHA_NZZ * a0_local_Z[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                            + ALPHA_PZZ * a0_local_Z[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                            + ALPHA_ZNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                            + ALPHA_ZPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                            + ALPHA_ZZN * a0_local_N[y*ldx+x] \</span><br><span class="line">                            + ALPHA_ZZP * a0_local_P[y*ldx+x] \</span><br><span class="line">                            + ALPHA_NNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                            + ALPHA_PNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                            + ALPHA_NPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                            + ALPHA_PPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                            + ALPHA_NZN * a0_local_N[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                            + ALPHA_PZN * a0_local_N[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                            + ALPHA_NZP * a0_local_P[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                            + ALPHA_PZP * a0_local_P[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                            + ALPHA_ZNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                            + ALPHA_ZPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                            + ALPHA_ZNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                            + ALPHA_ZPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                            + ALPHA_NNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                            + ALPHA_PNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                            + ALPHA_NPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                            + ALPHA_PPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                            + ALPHA_NNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                            + ALPHA_PNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                            + ALPHA_NPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                            + ALPHA_PPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>];</span><br><span class="line">                a1_local = a1_local + ldx*ldy;</span><br><span class="line">                a0_local_N = a0_local_Z;</span><br><span class="line">                a0_local_Z = a0_local_P;</span><br><span class="line">                a0_local_P = a0_local_P + ldx*ldy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 隐藏非阻塞通信</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dir = <span class="number">1</span>; dir &lt;= <span class="number">8</span>; dir++) &#123;</span><br><span class="line">            <span class="type">int</span> oppo = oppo_idx[dir];</span><br><span class="line">            <span class="built_in">MPI_Isend</span>(a1, <span class="number">1</span>, send_subarray[dir],  ngbs[dir],  grid_info-&gt;p_id ^ ngbs[dir],  cart_comm, &amp;req_send[dir<span class="number">-1</span>]);</span><br><span class="line">            <span class="built_in">MPI_Irecv</span>(a1, <span class="number">1</span>, recv_subarray[oppo], ngbs[oppo], grid_info-&gt;p_id ^ ngbs[oppo], cart_comm, &amp;req_recv[oppo<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> JJ = y_start; JJ &lt; y_end; JJ += SET_Y_SIZE) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> II = x_start; II &lt; x_end; II += SET_X_SIZE)&#123;</span><br><span class="line">                <span class="type">int</span> REAL_Y_SIZE = <span class="built_in">MIN</span>(SET_Y_SIZE, y_end - JJ);</span><br><span class="line">                <span class="type">int</span> REAL_X_SIZE = <span class="built_in">MIN</span>(SET_X_SIZE, x_end - II);</span><br><span class="line"></span><br><span class="line">                <span class="type">ptr_t</span> a1_local = a1 + z_start*ldx*ldy + JJ*ldx + II;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_Z = a0 + (a1_local - a1);</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_P = a0_local_Z + ldy*ldx;</span><br><span class="line">                <span class="type">cptr_t</span> a0_local_N = a0_local_Z - ldy*ldx;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> z = z_start; z &lt; z_end; ++z) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; REAL_Y_SIZE; y++) &#123;</span><br><span class="line">                        <span class="meta">#<span class="keyword">pragma</span> unroll</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; REAL_X_SIZE; x++) &#123;</span><br><span class="line">                            a1_local[y*ldx+x] \</span><br><span class="line">                                = ALPHA_ZZZ * a0_local_Z[y*ldx+x] \</span><br><span class="line">                                + ALPHA_NZZ * a0_local_Z[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZZ * a0_local_Z[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_ZNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZN * a0_local_N[y*ldx+x] \</span><br><span class="line">                                + ALPHA_ZZP * a0_local_P[y*ldx+x] \</span><br><span class="line">                                + ALPHA_NNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PNZ * a0_local_Z[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PPZ * a0_local_Z[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NZN * a0_local_N[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZN * a0_local_N[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NZP * a0_local_P[y*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PZP * a0_local_P[y*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_ZNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_ZPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x] \</span><br><span class="line">                                + ALPHA_NNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PNN * a0_local_N[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PPN * a0_local_N[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PNP * a0_local_P[(y<span class="number">-1</span>)*ldx+x+<span class="number">1</span>] \</span><br><span class="line">                                + ALPHA_NPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x<span class="number">-1</span>] \</span><br><span class="line">                                + ALPHA_PPP * a0_local_P[(y+<span class="number">1</span>)*ldx+x+<span class="number">1</span>];</span><br><span class="line">                        &#125;<span class="comment">// x</span></span><br><span class="line">                    &#125;<span class="comment">// y</span></span><br><span class="line">                    a1_local = a1_local + ldx*ldy;</span><br><span class="line">                    a0_local_N = a0_local_Z;</span><br><span class="line">                    a0_local_Z = a0_local_P;</span><br><span class="line">                    a0_local_P = a0_local_P + ldx*ldy;</span><br><span class="line">                &#125;<span class="comment">// z</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">MPI_Waitall</span>(<span class="number">8</span>, req_recv, status);</span><br><span class="line">        <span class="built_in">MPI_Waitall</span>(<span class="number">8</span>, req_send, status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer[nt % <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，当使用8个节点（1024核）时，会出现执行程序非常慢，甚至有时提交任务太久没执行完而被作业系统杀掉的情况。但执行后输出的结果却显示时间仍然只是零点几秒，这大概是由于MPI-IO读取数据时非常耗时。具体原因我没有深究，但由于等待时间实在太久，所以只进行了test.sh中的测试，即跑了16个时间步的循环。而跨节点时本来性能就会有较大波动。</p>
<p>实际上，应用计算通信重叠会导致在某些并行度下性能有较明显的下降。这可能是因为刨去内halo区剩下的区域并不能对齐，导致后续在计算真正的内部区域时，会有更长的计算时间。所以在此只是尝试了一下，后续的优化没有应用计算通信重叠。</p>
<h3 id="节点内进程映射优化"><a href="#节点内进程映射优化" class="headerlink" title="节点内进程映射优化"></a>节点内进程映射优化</h3><p>经过进程映射的优化（进程尽可能均匀散布于整个节点，核与核之间距离尽可能远）可以得到单节点内（进程数较小时）更高的可扩展性！这有两个原因。</p>
<p>一方面是L1和L2 cache是各个cpu独有的，而L3 cache整个numa-region内的32个核共享。MPI程序是分离的地址空间，一个进程计算时所需访存的地址肯定与别的进程不一样，不怕伪共享，反而是多个进程共用一个numa-region内的核时会导致L3 cache共用而产生的capacity miss或conflict miss增多！所以应尽量让进程分布距离远一些，避免过度聚集而致共享的L3 cache过热（在进程数较少时可以独享或尽可能多占L3 cache），使整个节点的负载均衡。</p>
<p>另一方面，我认为更重要的是，内存总线一般是几个核共用一条的（具体的排线方式不同机器有差异，只是一般情况），比如在该节点128核内，0-3核（核组0），4-7核（核组1）等是以核组为单位共享内存总线的。所以当进程分布得更散落时，有利于提高机器的内存带宽利用率。这对于stencil这种memory-bounded、严重吃带宽的程序而言，应该是相比于cache更重要的因素。</p>
<p>该映射优化可以通过计算给定进程数np时均匀分布于整个节点的步长stride，和mpirun的命令行参数<code>--map-by slot:PE=$stride --bind-to core</code>来实现，可见mpi-benchmark.sh文件和mpi-test.sh文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment">#SBATCH --nodes=1</span></span><br><span class="line"><span class="comment">#BATCH --ntasks-per-node=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -ne 3 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> &lt;executable&gt; &lt;number of nodes&gt; &lt;number of processes per node&gt; &quot;</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> DAPL_DBG_TYPE=0</span><br><span class="line">stride=$[128 / <span class="variable">$3</span>]</span><br><span class="line"></span><br><span class="line">DATAPATH=/storage/readonly/stencil_data</span><br><span class="line"></span><br><span class="line">salloc -N <span class="variable">$2</span> --exclusive --ntasks-per-node <span class="variable">$3</span> mpirun --map-by slot:PE=<span class="variable">$stride</span> --bind-to core --report-bindings <span class="variable">$1</span> 7 256 256 256 16 <span class="variable">$&#123;DATAPATH&#125;</span>/stencil_data_256x256x256 <span class="variable">$&#123;DATAPATH&#125;</span>/stencil_answer_7_256x256x256_16steps</span><br><span class="line">salloc -N <span class="variable">$2</span> --exclusive --ntasks-per-node <span class="variable">$3</span> mpirun --map-by slot:PE=<span class="variable">$stride</span> --bind-to core --report-bindings <span class="variable">$1</span> 7 384 384 384 16  <span class="variable">$&#123;DATAPATH&#125;</span>/stencil_data_384x384x384 <span class="variable">$&#123;DATAPATH&#125;</span>/stencil_answer_7_384x384x384_16steps</span><br><span class="line">salloc -N <span class="variable">$2</span> --exclusive --ntasks-per-node <span class="variable">$3</span> mpirun --map-by slot:PE=<span class="variable">$stride</span> --bind-to core --report-bindings <span class="variable">$1</span> 7 512 512 512 16  <span class="variable">$&#123;DATAPATH&#125;</span>/stencil_data_512x512x512 <span class="variable">$&#123;DATAPATH&#125;</span>/stencil_answer_7_512x512x512_16steps</span><br><span class="line">salloc -N <span class="variable">$2</span> --exclusive --ntasks-per-node <span class="variable">$3</span> mpirun --map-by slot:PE=<span class="variable">$stride</span> --bind-to core --report-bindings <span class="variable">$1</span> 27 256 256 256 16  <span class="variable">$&#123;DATAPATH&#125;</span>/stencil_data_256x256x256 <span class="variable">$&#123;DATAPATH&#125;</span>/stencil_answer_27_256x256x256_16steps</span><br><span class="line">salloc -N <span class="variable">$2</span> --exclusive --ntasks-per-node <span class="variable">$3</span> mpirun --map-by slot:PE=<span class="variable">$stride</span> --bind-to core --report-bindings <span class="variable">$1</span> 27 384 384 384 16  <span class="variable">$&#123;DATAPATH&#125;</span>/stencil_data_384x384x384 <span class="variable">$&#123;DATAPATH&#125;</span>/stencil_answer_27_384x384x384_16steps</span><br><span class="line">salloc -N <span class="variable">$2</span> --exclusive --ntasks-per-node <span class="variable">$3</span> mpirun --map-by slot:PE=<span class="variable">$stride</span> --bind-to core --report-bindings <span class="variable">$1</span> 27 512 512 512 16  <span class="variable">$&#123;DATAPATH&#125;</span>/stencil_data_512x512x512 <span class="variable">$&#123;DATAPATH&#125;</span>/stencil_answer_27_512x512x512_16steps</span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/05/04/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/04/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url">Linux 网络编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-04T19:00:00+08:00">
                2022-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="LINUX网络编程基础知识"><a href="#LINUX网络编程基础知识" class="headerlink" title="LINUX网络编程基础知识"></a>LINUX网络编程基础知识</h1><h2 id="TCP-IP协议概述"><a href="#TCP-IP协议概述" class="headerlink" title="TCP/IP协议概述"></a>TCP/IP协议概述</h2><p>协议protocol：通信双方必须遵循的规矩 由iso规定，</p>
<p>osi参考模型：（应-表-会-传-网-数-物）</p>
<ul>
<li>应用层 表示层 会话层 传输层 网络层 数据链路层 物理层</li>
</ul>
<p>tcp/ip模型4层:</p>
<ul>
<li>应用层{http超文本传输协议   ftp文件传输协议  telnet远程登录   ssh安全外壳协议  stmp简单邮件发送   pop3收邮件}</li>
<li>传输层{tcp传输控制协议,udp用户数据包协议}</li>
<li>网络层{ip网际互联协议 icmp网络控制消息协议 igmp网络组管理协议}</li>
<li>链路层{arp地址转换协议,rarp反向地址转换协议，mpls多协议标签交换}</li>
</ul>
<p>TCP协议：传输控制协议 面向连接的协议 能保证传输安全可靠 速度慢（有3次握手）</p>
<p>UDP协议：用户数据包协议 非面向连接  速度快 不可靠</p>
<p>通常是ip地址后面跟上端口号：ip用来定位主机  port区别应用（进程）</p>
<p>http的端口号80  ssh—&gt;22  telnet—&gt;23  ftp—&gt;21  用户自己定义的通常要大于1024</p>
<h2 id="OSI参考模型及TCP-IP参考模型"><a href="#OSI参考模型及TCP-IP参考模型" class="headerlink" title="OSI参考模型及TCP/IP参考模型"></a>OSI参考模型及TCP/IP参考模型</h2><p>TCP/IP协议族的每一层的作用：</p>
<ul>
<li>链路层：负责将二进制流转换为数据帧，并进行数据帧的发送和接收。要注意的是数据帧是独立的网络信息传输单元。</li>
<li>网络层：负责将数据帧封装成IP数据报，并运行必要的路由算法。</li>
<li>传输层：负责端对端之间的通信会话连接和建立。传输协议的选择根据数据传输方式而定。</li>
<li>应用层：负责应用程序的网络访问，这里通过端口号来识别各个不同的进程。</li>
</ul>
<p>TCP/IP协议族的每一层协议的相关注解：</p>
<ul>
<li>ARP：（地址转换协议）用于获得同一物理网络中的硬件主机地址。</li>
<li>MPLS：（多协议标签交换）很有发展前景的下一代网络协议。</li>
<li>IP：（网际互联协议）负责在主机和网络之间寻址和路由数据包。</li>
<li>ICMP：（网络控制消息协议）用于发送报告有关数据包的传送错误的协议。</li>
<li>IGMP：（网络组管理协议）被IP主机用来向本地多路广播路由器报告主机组成员的协议。</li>
<li>TCP：（传输控制协议）为应用程序提供可靠的通信连接。适合于一次传输大批数据的情况。并适用于要求得到相应的应用程序。</li>
<li>UDP：（用户数据包协议）提供了无连接通信，且不对传送包进行可靠的保证。适合于一次传输少量数据。</li>
</ul>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>TCP是TCP/IP体系中面向连接的运输层协议，它提供全双工和可靠交付的服务。它采用许多机制来确保端到端结点之间的可靠数据传输，如采用序列号、确认重传、滑动窗口等。</p>
<p>首先，TCP要为所发送的每一个报文段加上序列号，保证每一个报文段能被接收方接收，并只被正确的接收一次。</p>
<p>其次，TCP采用具有重传功能的积极确认技术作为可靠数据流传输服务的基础。这里“确认”是指接收端在正确收到报文段之后向发送端回送一个确认（ACK）信息。发送方将每个已发送的报文段备份在自己的缓冲区里，而且在收到相应的确认之前是不会丢弃所保存的报文段的。“积极”是指发送发在每一个报文段发送完毕的同时启动一个定时器，加入定时器的定时期满而关于报文段的确认信息还没有达到，则发送发认为该报文段已经丢失并主动重发。为了避免由于网络延时引起迟到的确认和重复的确认，TCP规定在确认信息中捎带一个报文段的序号，使接收方能正确的将报文段与确认联系起来。</p>
<p>最后，采用可变长的滑动窗口协议进行流量控制，以防止由于发送端与接收端之间的不匹配而引起的数据丢失。这里所采用的滑动窗口协议与数据链路层的滑动窗口协议在工作原理上完全相同，唯一的区别在于滑动窗口协议用于传输层是为了在端对端节点之间实现流量控制，而用于数据链路层是为了在相邻节点之间实现流量控制。TCP采用可变长的滑动窗口，使得发送端与接收端可根据自己的CPU和数据缓存资源对数据发送和接收能力来进行动态调整，从而灵活性更强，也更合理。</p>
<h3 id="三次握手协议"><a href="#三次握手协议" class="headerlink" title="三次握手协议"></a>三次握手协议</h3><p>在利用TCP实现源主机和目的主机通信时，目的主机必须同意，否则TCP连接无法建立。为了确保TCP连接的成功建立，TCP采用了一种称为三次握手的方式，三次握手方式使得“序号/确认号”系统能够正常工作，从而使它们的序号达成同步。如果三次握手成功，则连接建立成功，可以开始传送数据信息。</p>
<p>其三次握手分别为：</p>
<ol>
<li>源主机A的TCP向主机B发送连接请求报文段，其首部中的SYN（同步）标志位应置为1，表示想跟目标主机B建立连接，进行通信，并发送一个同步序列号X（例：SEQ=100）进行同步，表明在后面传送数据时的第一个数据字节的序号为X+1（即101）。</li>
<li>目标主机B的TCP收到连接请求报文段后，如同意，则发回确认。再确认报中应将ACK位和SYN位置为1.确认号为X+1，同时也为自己选择一个序号Y。</li>
<li>源主机A的TCP收到目标主机B的确认后要想目标主机B给出确认。其ACK置为1，确认号为Y+1，而自己的序号为X+1。TCP的标准规定，SYN置1的报文段要消耗掉一个序号。</li>
</ol>
<p>运行客户进程的源主机A的TCP通知上层应用进程，连接已经建立。当源主机A向目标主机B发送第一个数据报文段时，其序号仍为X+1，因为前一个确认报文段并不消耗序号。</p>
<p>当运行服务进程的目标主机B的TCP收到源主机A的确认后，也通知其上层应用进程，连接已经建立。至此建立了一个全双工的连接。</p>
<p>三次握手：为应用程序提供可靠的通信连接。适合于一次传输大批数据的情况。并适用于要求得到响应的应用程序。 </p>
<h3 id="TCP数据报头"><a href="#TCP数据报头" class="headerlink" title="TCP数据报头"></a>TCP数据报头</h3><p>TCP头信息</p>
<ul>
<li>源端口、目的端口：16位长。标识出远端和本地的端口号。</li>
<li>序号：32位长。标识发送的数据报的顺序。</li>
<li>确认号：32位长。希望收到的下一个数据报的序列号。</li>
<li>TCP头长：4位长。表明TCP头中包含多少个32位字。</li>
<li>6位未用。</li>
<li>ACK：ACK位置1表明确认号是合法的。如果ACK为0，那么数据报不包含确认信息，确认字段被省略。</li>
<li>PSH：表示是带有PUSH标志的数据。接收方因此请求数据报一到便可送往应用程序而不必等到缓冲区装满时才发送。</li>
<li>RST：用于复位由于主机崩溃或其他原因而出现的错误的连接。还可以用于拒绝非法的数据报或拒绝连接请求。</li>
<li>SYN：用于建立连接。</li>
<li>FIN：用于释放连接。</li>
<li>窗口大小：16位长。窗口大小字段表示在确认了字节之后还可以发送多少个字节。</li>
<li>校验和：16位长。是为了确保高可靠性而设置的。它校验头部、数据和伪TCP头部之和。</li>
<li>可选项：0个或多个32位字。包括最大TCP载荷，窗口比例、选择重复数据报等选项。</li>
</ul>
<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>UDP即用户数据报协议，它是一种无连接协议，因此不需要像TCP那样通过三次握手来建立一个连接。同时，一个UDP应用可同时作为应用的客户或服务器方。由于UDP协议并不需要建立一个明确的连接，因此建立UDP应用要比建立TCP应用简单得多。</p>
<p>它比TCP协议更为高效，也能更好地解决实时性的问题。如今，包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都使用UDP协议。 </p>
<h2 id="协议的选择"><a href="#协议的选择" class="headerlink" title="协议的选择"></a>协议的选择</h2><h3 id="对数据可靠性的要求"><a href="#对数据可靠性的要求" class="headerlink" title="对数据可靠性的要求"></a>对数据可靠性的要求</h3><p>对数据要求高可靠性的应用需选择TCP协议，如验证、密码字段的传送都是不允许出错的，而对数据的可靠性要求不那么高的应用可选择UDP传送。</p>
<h3 id="应用的实时性"><a href="#应用的实时性" class="headerlink" title="应用的实时性"></a>应用的实时性</h3><p>TCP协议在传送过程中要使用三次握手、重传确认等手段来保证数据传输的可靠性。使用TCP协议会有较大的时延，因此不适合对实时性要求较高的应用，如VOIP、视频监控等。相反，UDP协议则在这些应用中能发挥很好的作用。</p>
<h3 id="网络的可靠性"><a href="#网络的可靠性" class="headerlink" title="网络的可靠性"></a>网络的可靠性</h3><p>由于TCP协议的提出主要是解决网络的可靠性问题，它通过各种机制来减少错误发生的概率。因此，在网络状况不是很好的情况下需选用TCP协议（如在广域网等情况），但是若在网络状况很好的情况下（如局域网等）就不需要再采用TCP协议，而建议选择UDP协议来减少网络负荷。 </p>
<h1 id="网络相关概念"><a href="#网络相关概念" class="headerlink" title="网络相关概念"></a>网络相关概念</h1><h2 id="套接口的概念："><a href="#套接口的概念：" class="headerlink" title="套接口的概念："></a>套接口的概念：</h2><p>套接口，也叫“套接字”。是操作系统内核中的一个数据结构，它是网络中的节点进行相互通信的门户。它是网络进程的ID。网络通信，归根到底还是进程间的通信（不同计算机上的进程间通信）。在网络中，每一个节点（计算机或路由）都有一个网络地址，也就是IP地址。两个进程通信时，首先要确定各自所在的网络节点的网络地址。但是，网络地址只能确定进程所在的计算机，而一台计算机上很可能同时运行着多个进程，所以仅凭网络地址还不能确定到底是和网络中的哪一个进程进行通信，因此套接口中还需要包括其他的信息，也就是端口号（PORT）。在一台计算机中，一个端口号一次只能分配给一个进程，也就是说，在一台计算机中，端口号和进程之间是一一对应关系。所以，使用端口号和网络地址的组合可以唯一的确定整个网络中的一个网络进程。</p>
<p>例如，如网络中某一台计算机的IP为10.92.20.160，操作系统分配给计算机中某一应用程序进程的端口号为1500，则此时 10.92.20.160  1500就构成了一个套接口。</p>
<h2 id="端口号的概念："><a href="#端口号的概念：" class="headerlink" title="端口号的概念："></a>端口号的概念：</h2><p>在网络技术中，端口大致有两种意思：一是物理意义上的端口，如集线器、交换机、路由器等用于连接其他网络设备的接口。二是指TCP/IP协议中的端口，端口号的范围从0~65535，一类是由互联网指派名字和号码公司ICANN负责分配给一些常用的应用程序固定使用的“周知的端口”，其值一般为0~1023.例如http的端口号是80，ftp为21，ssh为22，telnet为23等。还有一类是用户自己定义的，通常是大于1024的整型值。</p>
<h2 id="ip地址的表示："><a href="#ip地址的表示：" class="headerlink" title="ip地址的表示："></a>ip地址的表示：</h2><p>通常用户在表达IP地址时采用的是点分十进制表示的数值（或者是为冒号分开的十进制Ipv6地址），而在通常使用的socket编程中使用的则是二进制值，这就需要将这两个数值进行转换。</p>
<p>ipv4地址：32bit, 4字节，通常采用点分十进制记法。</p>
<p>例如对于：10000000 00001011 00000011 00011111</p>
<p>点分十进制表示为：128.11.3.31</p>
<h2 id="socket概念"><a href="#socket概念" class="headerlink" title="socket概念"></a>socket概念</h2><p>Linux中的网络编程是通过socket接口来进行的。socket是一种特殊的I/O接口，它也是一种文件描述符。它是一种常用的进程之间通信机制，通过它不仅能实现本地机器上的进程之间的通信，而且通过网络能够在不同机器上的进程之间进行通信。</p>
<p>每一个socket都用一个半相关描述{协议、本地地址、本地端口}来表示；一个完整的套接字则用一个相关描述{协议、本地地址、本地端口、远程地址、远程端口}来表示。socket也有一个类似于打开文件的函数调用，该函数返回一个整型的socket描述符，随后的连接建立、数据传输等操作都是通过socket来实现的；</p>
<h2 id="socket类型"><a href="#socket类型" class="headerlink" title="socket类型"></a>socket类型</h2><p>（1）流式socket（SOCK_STREAM） 用于TCP通信</p>
<p>流式套接字提供可靠的、面向连接的通信流；它使用TCP协议，从而保证了数据传输的正确性和顺序性。</p>
<p>（2）数据报socket（SOCK_DGRAM） 用于UDP通信</p>
<p>数据报套接字定义了一种无连接的服务，数据通过相互独立的报文进行传输，是无序的，并且不保证是可靠、无差错的。它使用数据报协议UDP。</p>
<p>（3）原始socket （SOCK_RAW）  用于新的网络协议实现的测试等</p>
<p>原始套接字允许对底层协议如IP或ICMP进行直接访问，它功能强大但使用较为不便，主要用于一些协议的开发。 </p>
<h2 id="socket信息数据结构"><a href="#socket信息数据结构" class="headerlink" title="socket信息数据结构"></a>socket信息数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sa_family; <span class="comment">/*地址族*/</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>]; <span class="comment">/*14字节的协议地址，包含该socket的IP地址和端口号。*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> sa_family; <span class="comment">/*地址族*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sin_port; <span class="comment">/*端口号*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/*IP地址*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">/*填充0 以保持与struct sockaddr同样大小*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>  s_addr; <span class="comment">/* 32位IPv4地址，网络字节序 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>头文件<netinet/in.h></p>
<h2 id="数据存储优先顺序的转换"><a href="#数据存储优先顺序的转换" class="headerlink" title="数据存储优先顺序的转换"></a>数据存储优先顺序的转换</h2><p>计算机数据存储有两种字节优先顺序：高位字节优先（称为大端模式）和低位字节优先（称为小端模式）。内存的低地址存储数据的低字节，高地址存储数据的高字节的方式叫小端模式。内存的高地址存储数据的低字节，低地址存储数据高字节的方式称为大端模式。</p>
<p>eg:对于内存中存放的数0x12345678来说</p>
<ul>
<li>如果是采用大端模式存放的，则其真实的数是：0x12345678</li>
<li>如果是采用小端模式存放的，则其真实的数是：0x78563412</li>
</ul>
<p>如果称某个系统所采用的字节序为主机字节序，则它可能是小端模式的，也可能是大端模式的。而端口号和IP地址都是以网络字节序存储的，不是主机字节序，网络字节序都是大端模式。要把主机字节序和网络字节序相互对应起来，需要对这两个字节存储优先顺序进行相互转化。这里用到四个函数：htons(),ntohs(),htonl()和ntohl().这四个地址分别实现网络字节序和主机字节序的转化，这里的h代表host,n代表network，s代表short，l代表long。通常16位的IP端口号用s代表，而IP地址用l来代表。</p>
<h2 id="地址格式转化"><a href="#地址格式转化" class="headerlink" title="地址格式转化"></a>地址格式转化</h2><p>通常用户在表达地址时采用的是点分十进制表示的数值（或者是为冒号分开的十进制Ipv6地址），而在通常使用的socket编程中使用的则是32位的网络字节序的二进制值，这就需要将这两个数值进行转换。这里在Ipv4中用到的函数有<code>inet_aton()</code>、<code>inet_addr()</code>和<code>inet_ntoa()</code>，而IPV4和Ipv6兼容的函数有<code>inet_pton()</code>和<code>inet_ntop()</code>。</p>
<p>IPv4的函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *straddr, <span class="keyword">struct</span> in_addr *addrptr)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr inaddr)</span>;</span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *straddr)</span>;</span><br></pre></td></tr></table></figure></p>
<p>函数inet_aton()：将点分十进制数的IP地址转换成为网络字节序的32位二进制数值。返回值：成功，则返回1，不成功返回0.</p>
<pre><code>- 参数straddr：存放输入的点分十进制数IP地址字符串。
- 参数addrptr：传出参数，保存网络字节序的32位二进制数值。
</code></pre><p>函数inet_ntoa()：将网络字节序的32位二进制数值转换为点分十进制的IP地址。</p>
<p>函数inet_addr()：功能与inet_aton相同，但是结果传递的方式不同。inet_addr()若成功则返回32位二进制的网络字节序地址。</p>
<p>IPv4和IPv6的函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> family, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> family, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> len)</span>;</span><br></pre></td></tr></table></figure></p>
<p>函数inet_pton跟inet_aton实现的功能类似，只是多了family参数，该参数指定为AF_INET，表示是IPv4协议，如果是AF_INET6，表示IPv6协议。</p>
<p>函数inet_ntop跟inet_ntoa类似，其中len表示表示转换之后的长度（字符串的长度）。</p>
<p>Example：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ip[] = <span class="string">&quot;192.168.0.101&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">myaddr</span>;</span></span><br><span class="line">    <span class="comment">/* inet_aton */</span></span><br><span class="line">    <span class="type">int</span> iRet = inet_aton(ip, &amp;myaddr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, myaddr.s_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* inet_addr */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, inet_addr(ip));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* inet_pton */</span></span><br><span class="line">    iRet = inet_pton(AF_INET, ip, &amp;myaddr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, myaddr.s_addr);</span><br><span class="line">    </span><br><span class="line">    myaddr.s_addr = <span class="number">0xac100ac4</span>;</span><br><span class="line">    <span class="comment">/* inet_ntoa */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, inet_ntoa(myaddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* inet_ntop */</span></span><br><span class="line">    inet_ntop(AF_INET, &amp;myaddr, ip, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">puts</span>(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="名字地址转化"><a href="#名字地址转化" class="headerlink" title="名字地址转化"></a>名字地址转化</h2><p>通常，人们在使用过程中都不愿意记忆冗长的IP地址，尤其到Ipv6时，地址长度多达128位，那时就更加不可能一次性记忆那么长的IP地址了。因此，使用主机名或域名将会是很好的选择。主机名与域名的区别：主机名通常在局域网里面使用，通过/etc/hosts文件，主机名可以解析到对应的ip；域名通常是再internet上使用。</p>
<p>众所周知，百度的域名为：www.baidu.com，而这个域名其实对应了一个百度公司的IP地址，那么百度公司的IP地址是多少呢？我们可以利用ping www.baidu.com来得到百度公司的ip地址，如图。那么，系统是如何将www.baidu.com 这个域名转化为IP地址220.181.111.148的呢？</p>
<p>在linux中，有一些函数可以实现主机名和地址的转化，最常见的有<code>gethostbyname()</code>、<code>gethostbyaddr()</code>等，它们都可以实现IPv4和IPv6的地址和主机名之间的转化。其中<code>gethostbyname()</code>是将主机名转化为IP地址，<code>gethostbyaddr()</code>则是逆操作，是将IP地址转化为主机名。</p>
<p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent* <span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* hostname)</span>;</span><br><span class="line"><span class="keyword">struct</span> hostent* <span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* addr, <span class="type">size_t</span> len, <span class="type">int</span> family)</span>;</span><br></pre></td></tr></table></figure></p>
<p>结构体：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="type">char</span> *h_name; <span class="comment">/*正式主机名*/</span>    </span><br><span class="line">    <span class="type">char</span> **h_aliases; <span class="comment">/*主机别名*/</span>  </span><br><span class="line">    <span class="type">int</span> h_addrtype; <span class="comment">/*主机IP地址类型 IPv4为AF_INET*/</span>    </span><br><span class="line">    <span class="type">int</span> h_length; <span class="comment">/*主机IP地址字节长度，对于IPv4是4字节，即32位*/</span>   </span><br><span class="line">    <span class="type">char</span> **h_addr_list; <span class="comment">/*主机的IP地址列表*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  h_addr  h_addr_list[0] <span class="comment">/*保存的是ip地址*/</span></span></span><br></pre></td></tr></table></figure></p>
<p>函数<code>gethostbyname()</code>：用于将域名（www.baidu.com）或主机名转换为IP地址。参数hostname指向存放域名或主机名的字符串。</p>
<p>函数<code>gethostbyaddr()</code>：用于将IP地址转换为域名或主机名。参数addr是一个IP地址，此时这个ip地址不是普通的字符串，而是要通过函数inet_aton()转换。len为IP地址的长度，AF_INET为4。family可用AF_INET：Ipv4或AF_INET6：Ipv6。</p>
<p>Example1：将百度的www.baidu.com 转换为ip地址<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *ptr, **pptr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hostent</span> *hptr;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">32</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">/* 取得命令后第一个参数，即要解析的域名或主机名 */</span></span><br><span class="line">    ptr = argv[<span class="number">1</span>];  <span class="comment">//如www.baidu.com</span></span><br><span class="line"><span class="comment">/* 调用gethostbyname()。结果存在hptr结构中 */</span></span><br><span class="line">    <span class="keyword">if</span>((hptr = <span class="built_in">gethostbyname</span>(ptr)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; gethostbyname error for host:%s\n&quot;</span>, ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* 将主机的规范名打出来 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;official hostname:%s\n&quot;</span>, hptr-&gt;h_name);</span><br><span class="line"><span class="comment">/* 主机可能有多个别名，将所有别名分别打出来 */</span></span><br><span class="line">    <span class="keyword">for</span>(pptr = hptr-&gt;h_aliases; *pptr != <span class="literal">NULL</span>; pptr++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; alias:%s\n&quot;</span>, *pptr);</span><br><span class="line"><span class="comment">/* 根据地址类型，将地址打出来 */</span></span><br><span class="line">    <span class="keyword">switch</span>(hptr-&gt;h_addrtype)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> AF_INET:</span><br><span class="line">        <span class="keyword">case</span> AF_INET6:</span><br><span class="line">            pptr = hptr-&gt;h_addr_list;</span><br><span class="line">            <span class="comment">/* 将刚才得到的所有地址都打出来。其中调用了inet_ntop()函数 */</span></span><br><span class="line">            <span class="keyword">for</span>(; *pptr!=<span class="literal">NULL</span>; pptr++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; address:%s\n&quot;</span>, <span class="built_in">inet_ntop</span>(hptr-&gt;h_addrtype, *pptr, str, <span class="built_in">sizeof</span>(str)));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; first address: %s\n&quot;</span>, <span class="built_in">inet_ntop</span>(hptr-&gt;h_addrtype, hptr-&gt;h_addr, str, <span class="built_in">sizeof</span>(str)));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;unknown address type\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#gcc test.c</span><br><span class="line"></span><br><span class="line">#./a.out www.baidu.com</span><br><span class="line"></span><br><span class="line">official hostname:www.a.shifen.com</span><br><span class="line"></span><br><span class="line">alias:www.baidu.com</span><br><span class="line"></span><br><span class="line">address: 220.181.111.148</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">first address: 220.181.111.148</span><br></pre></td></tr></table></figure></p>
<h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><h2 id="使用TCP协议的流程图"><a href="#使用TCP协议的流程图" class="headerlink" title="使用TCP协议的流程图"></a>使用TCP协议的流程图</h2><p>TCP通信的基本步骤如下：</p>
<p>服务端：socket—-bind—-listen—-while(1){—-accept—-recv—-send—-close—-}—-close</p>
<p>客户端：socket——————————————connect—-send—-recv————————-close</p>
<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>头文件包含：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h3><p>生成一个套接口描述符。</p>
<p>原型：<code>int socket(int domain,int type,int protocol);</code></p>
<ul>
<li>domain { AF_INET：Ipv4网络协议   AF_INET6：IPv6网络协议}</li>
<li>type { tcp：SOCK_STREAM   udp：SOCK_DGRAM}</li>
<li>protocol 指定socket所使用的传输协议编号。通常为0.</li>
</ul>
<p>返回值：成功则返回套接口描述符，失败返回-1。</p>
<p>常用实例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(sfd == <span class="number">-1</span>)&#123;perror(<span class="string">&quot;socket&quot;</span>);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><p>用来绑定一个端口号和IP地址，使套接口与指定的端口号和IP地址相关联。</p>
<p>原型：<code>int bind(int sockfd,struct sockaddr * my_addr,int addrlen);</code></p>
<p>参数：</p>
<ul>
<li>sockfd 为前面socket的返回值。</li>
<li>my_addr 为结构体指针变量</li>
</ul>
<p>对于不同的socket domain定义了一个通用的数据结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>  //此结构体不常用 </span></span><br><span class="line"><span class="class">&#123;</span>     </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sa_family;  <span class="comment">//调用socket()时的domain参数，即AF_INET值。     </span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];  <span class="comment">//最多使用14个字符长度 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>此sockaddr结构会因使用不同的socket domain而有不同结构定义， 例如使用AF_INET domain，其<code>socketaddr</code>结构定义便为<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>  <span class="comment">//常用的结构体</span></span><br><span class="line">&#123;     </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> sin_family;  <span class="comment">//即为sa_family AF_INET     </span></span><br><span class="line">    <span class="type">uint16_t</span> sin_port;  <span class="comment">//为使用的port编号     </span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;  <span class="comment">//为IP 地址     </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="number">8</span>];  <span class="comment">//未使用 </span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123; <span class="type">uint32_t</span> s_addr; &#125;; <span class="comment">// addrlen sockaddr的结构体长度。通常是计算sizeof(struct sockaddr);</span></span><br></pre></td></tr></table></figure></p>
<p>返回值：成功则返回0，失败返回-1</p>
<p>常用实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> my_addr;  <span class="comment">//定义结构体变量</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;my_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr)); <span class="comment">//将结构体清空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或bzero(&amp;my_addr, sizeof(struct sockaddr));</span></span><br><span class="line"></span><br><span class="line">my_addr.sin_family = AF_INET;  <span class="comment">//表示采用Ipv4网络协议</span></span><br><span class="line">my_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);  <span class="comment">//表示端口号为8888，通常是大于1024的一个值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//htons()用来将参数指定的16位hostshort转换成网络字符顺序</span></span><br><span class="line"></span><br><span class="line">my_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.0.101&quot;</span>); <span class="comment">// inet_addr()用来将IP地址字符串转换成网络所使用的二进制数字，如果为INADDR_ANY，这表示服务器自动填充本机IP地址。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">bind</span>(sfd, (<span class="keyword">struct</span> sockaddr*)&amp;my_str, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> socketaddr)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(sfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>（注：通过将my_addr.sin_port置为0，函数会自动为你选择一个未占用的端口来使用。同样，通过将my_addr.sin_addr.s_addr置为INADDR_ANY，系统会自动填入本机IP地址。）</p>
<h3 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h3><p>使服务器的这个端口和IP处于监听状态，等待网络中某一客户机的连接请求。如果客户端有连接请求，端口就会接受这个连接。</p>
<p>原型：<code>int listen(int sockfd, int backlog);</code></p>
<p>参数：</p>
<ul>
<li>sockfd 为前面socket的返回值.即sfd</li>
<li>backlog 指定同时能处理的最大连接要求，通常为10或者5。 最大值可设至128</li>
</ul>
<p>返回值：成功则返回0，失败返回-1</p>
<p>常用实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">listen</span>(sfd, <span class="number">10</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123; <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);<span class="built_in">close</span>(sfd);<span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h3><p>接受远程计算机的连接请求，建立起与客户机之间的通信连接。服务器处于监听状态时，如果某时刻获得客户机的连接请求，此时并不是立即处理这个请求，而是将这个请求放在等待队列中，当系统空闲时再处理客户机的连接请求。当accept函数接受一个连接时，会返回一个新的socket标识符，以后的数据传输和读取就要通过这个新的socket编号来处理，原来参数中的socket也可以继续使用，继续监听其它客户机的连接请求。（也就是说，类似于移动营业厅，如果有客户打电话给10086，此时服务器就会请求连接，处理一些事务之后，就通知一个话务员接听客户的电话，也就是说，后面的所有操作，此时已经于服务器没有关系，而是话务员跟客户的交流。对应过来，客户请求连接我们的服务器，我们服务器先做了一些绑定和监听等等操作之后，如果允许连接，则调用accept函数产生一个新的套接字，然后用这个新的套接字跟我们的客户进行收发数据。也就是说，服务器跟一个客户端连接成功，会有两个套接字。）</p>
<p>原型：<code>int accept(int s,struct sockaddr * addr,int * addrlen);</code></p>
<p>参数：</p>
<ul>
<li>s 为前面socket的返回值.即sfd</li>
<li>addr 为结构体指针变量，和bind的结构体是同种类型的，系统会把远程主机的信息（远程主机的地址和端口号信息）保存到这个指针所指的结构体中。</li>
<li>addrlen 表示结构体的长度，为整型指针</li>
</ul>
<p>返回值：成功则返回新的socket处理代码new_fd，失败返回-1</p>
<p>常用实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;clientaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line"><span class="type">int</span> addrlen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line"><span class="type">int</span> new_fd = <span class="built_in">accept</span>(sfd, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;addrlen);</span><br><span class="line"><span class="keyword">if</span>(new_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);<span class="built_in">close</span>(sfd);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %d success connect\n&quot;</span>,<span class="built_in">inet_ntoa</span>(clientaddr.sin_addr),<span class="built_in">ntohs</span>(clientaddr.sin_port));</span><br></pre></td></tr></table></figure></p>
<h3 id="recv函数"><a href="#recv函数" class="headerlink" title="recv函数"></a>recv函数</h3><p>用新的套接字来接收远端主机传来的数据，并把数据存到由参数buf 指向的内存空间</p>
<p>原型：<code>int recv(int sockfd,void *buf,int len,unsigned int flags);</code></p>
<p>参数：</p>
<ul>
<li>sockfd 为前面accept的返回值.即new_fd，也就是新的套接字。</li>
<li>buf 表示缓冲区</li>
<li>len 表示缓冲区的长度</li>
<li>flags 通常为0</li>
</ul>
<p>返回值：成功则返回实际接收到的字符数，可能会少于你所指定的接收长度。失败返回-1</p>
<p>常用实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">recv</span>(new_fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);<span class="built_in">close</span>(new_fd);<span class="built_in">close</span>(sfd);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="built_in">puts</span>(buf);</span><br></pre></td></tr></table></figure></p>
<h3 id="send函数"><a href="#send函数" class="headerlink" title="send函数"></a>send函数</h3><p>用新的套接字发送数据给指定的远端主机</p>
<p>原型：<code>int send(int s,const void * msg,int len,unsigned int flags);</code></p>
<p>参数：</p>
<ul>
<li>s 为前面accept的返回值.即new_fd</li>
<li>msg 一般为常量字符串</li>
<li>len 表示长度</li>
<li>flags 通常为0</li>
</ul>
<p>返回值：成功则返回实际传送出去的字符数，可能会少于你所指定的发送长度。失败返回-1</p>
<p>常用实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">send</span>(new_fd, <span class="string">&quot;hello&quot;</span>, <span class="number">6</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>);<span class="built_in">close</span>(new_fd);<span class="built_in">close</span>(sfd);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h3><p>当使用完文件后若已不再需要则可使用close()关闭该文件，并且close()会让数据写回磁盘，并释放该文件所占用的资源</p>
<p>原型：<code>int close(int fd);</code></p>
<p>参数：</p>
<ul>
<li>fd 为前面的sfd,new_fd</li>
</ul>
<p>返回值：若文件顺利关闭则返回0，发生错误时返回-1</p>
<p>常用实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(new_fd);</span><br></pre></td></tr></table></figure></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><p>用来请求连接远程服务器，将参数sockfd 的<code>socket</code> 连至参数<code>serv_addr</code> 指定的服务器IP和端口号上去。</p>
<p>原型：<code>int connect (int sockfd,struct sockaddr * serv_addr,int addrlen);</code></p>
<p>参数：</p>
<ul>
<li>sockfd 为前面socket的返回值，即sfd</li>
<li>serv_addr 为结构体指针变量，存储着远程服务器的IP与端口号信息。</li>
<li>addrlen 表示结构体变量的长度</li>
</ul>
<p>返回值：成功则返回0，失败返回-1</p>
<p>常用实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> seraddr;<span class="comment">//请求连接服务器</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;seraddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">seraddr.sin_family = AF_INET;</span><br><span class="line">seraddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>); <span class="comment">//服务器的端口号</span></span><br><span class="line">seraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.0.101&quot;</span>);  <span class="comment">//服务器的ip</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">connect</span>(sfd, (<span class="keyword">struct</span> sockaddr*)&amp;seraddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;<span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);<span class="built_in">close</span>(sfd);<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br></pre></td></tr></table></figure></p>
<p>还可以不写客户端程序，使用telnet远程登录来检测我们的服务器端程序。比如我们的服务器程序在监听8888端口，我们可以用telnet 192.168.0.101 8888来查看服务端的状况。</p>
<p>Example：将一些通用的代码全部封装起来，以后要用直接调用函数即可。如下：</p>
<p>通用网络封装代码头文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tcp_net_socket.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TCP__NET__SOCKET__H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TCP__NET__SOCKET__H</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">tcp_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">int</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">tcp_accept</span><span class="params">(<span class="type">int</span> sfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">tcp_connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip,<span class="type">int</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">signalhandler</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>具体的通用函数封装如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">tcp_net_socket.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_net_socket.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tcp_init</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip, <span class="type">int</span> port)</span>   <span class="comment">//用于初始化操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//首先创建一个socket，向系统申请</span></span><br><span class="line">    <span class="keyword">if</span>(sfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serveraddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    serveraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);<span class="comment">//或INADDR_ANY</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sfd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr)) == <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">//将新的socket与制定的ip、port绑定</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(sfd, <span class="number">10</span>) == <span class="number">-1</span>)<span class="comment">//监听它，并设置其允许最大的连接数为10个</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sfd;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tcp_accept</span><span class="params">(<span class="type">int</span> sfd)</span>   <span class="comment">//用于服务端的接收</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;clientaddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    <span class="type">int</span> addrlen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">    <span class="type">int</span> new_fd = <span class="built_in">accept</span>(sfd, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;addrlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sfd接受客户端连接，并创建新的socket为new_fd，将请求连接的客户端的ip、port保存在结构体clientaddr中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(new_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d success connect...\n&quot;</span>,<span class="built_in">inet_ntoa</span>(clientaddr.sin_addr),<span class="built_in">ntohs</span>(clientaddr.sin_port));</span><br><span class="line">    <span class="keyword">return</span> new_fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tcp_connect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip, <span class="type">int</span> port)</span>   <span class="comment">//用于客户端的连接</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//向系统注册申请新的socket</span></span><br><span class="line">    <span class="keyword">if</span>(sfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serveraddr, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    serveraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sfd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr)) == <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">//将sfd连接至制定的服务器网络地址serveraddr</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sfd;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signalhandler</span><span class="params">(<span class="type">void</span>)</span>   <span class="comment">//用于信号处理，让服务端在按下Ctrl+c或Ctrl+\的时候不会退出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">sigset_t</span> sigSet;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;sigSet);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;sigSet,SIGINT);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;sigSet,SIGQUIT);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK,&amp;sigSet,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务器端：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">tcp_net_server.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_net_socket.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage:./servertcp  ip  port\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">signalhandler</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sfd = <span class="built_in">tcp_init</span>(argv[<span class="number">1</span>], <span class="built_in">atoi</span>(argv[<span class="number">2</span>]));  <span class="comment">//或int sfd = tcp_init(&quot;192.168.0.164&quot;, 8888);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) <span class="comment">//用while循环表示可以与多个客户端接收和发送，但仍是阻塞模式的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cfd = <span class="built_in">tcp_accept</span>(sfd);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">recv</span>(cfd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>) == <span class="number">-1</span>)<span class="comment">//从cfd客户端接收数据存于buf中</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">close</span>(cfd);</span><br><span class="line">            <span class="built_in">close</span>(sfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">send</span>(cfd, <span class="string">&quot;hello world&quot;</span>, <span class="number">12</span>, <span class="number">0</span>) == <span class="number">-1</span>)<span class="comment">//从buf中取向cfd客户端发送数据</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(cfd);</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(cfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">tcp_net_client.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_net_socket.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage:./clienttcp  ip  port\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sfd = <span class="built_in">tcp_connect</span>(argv[<span class="number">1</span>],<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">send</span>(sfd, <span class="string">&quot;hello&quot;</span>, <span class="number">6</span>, <span class="number">0</span>);     <span class="comment">//向sfd服务端发送数据</span></span><br><span class="line">    <span class="built_in">recv</span>(sfd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>); <span class="comment">//从sfd服务端接收数据</span></span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">    <span class="built_in">close</span>(sfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gcc –o tcp_net_server tcp_net_server.c tcp_net_socket.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gcc –o tcp_net_client tcp_net_client.c tcp_net_socket.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#./tcp_net_server 192.168.0.164 8888</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#./tcp_net_client 192.168.0.164 8888</span></span><br></pre></td></tr></table></figure>
<p>上面的虽然可以实现多个客户端访问，但是仍然是阻塞模式（即一个客户访问的时候会阻塞不让另外的客户访问）。解决办法有：</p>
<p>多进程（因为开销比较大，所以不常用）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tcp_net_socket.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sfd = <span class="built_in">tcp_init</span>(<span class="string">&quot;192.168.0.101&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cfd = <span class="built_in">tcp_accept</span>(sfd);</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">send</span>(cfd, <span class="string">&quot;hello&quot;</span>, <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">            <span class="built_in">close</span>(cfd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(cfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多线程<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tcp_net_socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">pthfunc</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cfd = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="built_in">send</span>(cfd, <span class="string">&quot;hello&quot;</span>, <span class="number">6</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sfd = <span class="built_in">tcp_init</span>(<span class="string">&quot;192.168.0.101&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">    <span class="type">pthread_t</span> pthid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cfd = <span class="built_in">tcp_accept</span>(sfd);</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;pthid, <span class="literal">NULL</span>, pthfunc, (<span class="type">void</span>*)cfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备注 读写大容量的文件时，通过下面的方法效率很高</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf, <span class="type">int</span> size)</span><span class="comment">//读大量内容</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *pbuf = buf;</span><br><span class="line">    <span class="type">int</span> total ,nread;</span><br><span class="line">    <span class="keyword">for</span>(total = <span class="number">0</span>; total &lt; size; )</span><br><span class="line">    &#123;</span><br><span class="line">        nread=<span class="built_in">read</span>(fd,pbuf,size-total);</span><br><span class="line">        <span class="keyword">if</span>(nread==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        <span class="keyword">if</span>(nread == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        total += nread;</span><br><span class="line">        pbuf += nread;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf, <span class="type">int</span> size)</span><span class="comment">//写大量内容</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *pbuf=buf;</span><br><span class="line">    <span class="type">int</span> total ,nwrite;</span><br><span class="line">    <span class="keyword">for</span>(total = <span class="number">0</span>; total &lt; size; )</span><br><span class="line">    &#123;</span><br><span class="line">        nwrite=<span class="built_in">write</span>(fd,pbuf,size-total);</span><br><span class="line">        <span class="keyword">if</span>( nwrite &lt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nwrite == <span class="number">-1</span> &amp;&amp; errno == EINTR )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        total += nwrite;</span><br><span class="line">        pbuf += nwrite;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用fcntl将sockfd设置为非阻塞模式。（不常见）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line">sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">iflags = <span class="built_in">fcntl</span>(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">fcntl</span>(sockfd,F_SETFL,O_NONBLOCK | iflags);</span><br><span class="line">……</span><br></pre></td></tr></table></figure></p>
<p>多路选择select<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tcp_net_socket.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXCLIENT 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sfd = <span class="built_in">tcp_init</span>(<span class="string">&quot;192.168.0.164&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fd_set rdset;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FD_ZERO</span>(&amp;rdset);</span><br><span class="line">        <span class="built_in">FD_SET</span>(sfd,&amp;rdset);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">select</span>(MAXCLIENT + <span class="number">1</span>, &amp;rdset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; MAXCLIENT; fd++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">FD_ISSET</span>(fd,&amp;rdset))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(fd == sfd)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> cfd = <span class="built_in">tcp_accept</span>(sfd);</span><br><span class="line">                    <span class="built_in">FD_SET</span>(cfd,&amp;rdset);</span><br><span class="line">                    <span class="comment">//……</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">bzero</span>(buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                    <span class="built_in">recv</span>(fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">puts</span>(buf);</span><br><span class="line">                    <span class="built_in">send</span>(fd, <span class="string">&quot;java&quot;</span>, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="comment">//FD_CLR(fd, &amp;rdset);</span></span><br><span class="line">                    <span class="built_in">close</span>(fd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用UDP协议的流程图"><a href="#使用UDP协议的流程图" class="headerlink" title="使用UDP协议的流程图"></a>使用UDP协议的流程图</h2><p>UDP通信流程图如下：</p>
<p>服务端：socket—-bind—-recvfrom—-sendto—-close</p>
<p>客户端：socket—————sendto—-recvfrom—-close</p>
<p><code>sendto()</code>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *msg,<span class="type">int</span> len,<span class="type">unsigned</span> <span class="type">int</span> flags,<span class="type">const</span> <span class="keyword">struct</span> sockaddr *to, <span class="type">int</span> tolen)</span>;</span><br></pre></td></tr></table></figure></p>
<p>该函数比send()函数多了两个参数，to表示目地机的IP地址和端口号信息，而tolen常常被赋值为sizeof (struct sockaddr)。sendto 函数也返回实际发送的数据字节长度或在出现发送错误时返回-1。</p>
<p><code>recvfrom()</code>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd,<span class="type">void</span> *buf,<span class="type">int</span> len,<span class="type">unsigned</span> <span class="type">int</span> flags,<span class="keyword">struct</span> sockaddr *from,<span class="type">int</span> *fromlen)</span>;</span><br></pre></td></tr></table></figure></p>
<p>from是一个struct sockaddr类型的变量，该变量保存连接机的IP地址及端口号。fromlen常置为sizeof (struct sockaddr)。当recvfrom()返回时，fromlen包含实际存入from中的数据字节数。Recvfrom()函数返回接收到的字节数或 当出现错误时返回-1，并置相应的errno。</p>
<p>Example:UDP的基本操作</p>
<p>服务器端：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> fromaddr;</span><br><span class="line">        <span class="built_in">bzero</span>(&amp;fromaddr, <span class="built_in">sizeof</span>(fromaddr));</span><br><span class="line">        <span class="type">int</span> fromaddrlen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">recvfrom</span>(sfd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;fromaddr, &amp;fromaddrlen) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">            <span class="built_in">close</span>(sfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;receive from %s %d,the message is:%s\n&quot;</span>, <span class="built_in">inet_ntoa</span>(fromaddr.sin_addr), <span class="built_in">ntohs</span>(fromaddr.sin_port), buf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sendto</span>(sfd, <span class="string">&quot;world&quot;</span>, <span class="number">6</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;fromaddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> toaddr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;toaddr, <span class="built_in">sizeof</span>(toaddr));</span><br><span class="line">    toaddr.sin_family = AF_INET;</span><br><span class="line">    toaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>])); <span class="comment">//此处的端口号要跟服务器一样</span></span><br><span class="line">    toaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]); <span class="comment">//此处为服务器的ip</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sendto</span>(sfd, <span class="string">&quot;hello&quot;</span>, <span class="number">6</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;toaddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> fromaddr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;fromaddr, <span class="built_in">sizeof</span>(fromaddr));</span><br><span class="line">    <span class="type">int</span> fromaddrlen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">recvfrom</span>(sfd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;fromaddr, &amp;fromaddrlen) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;receive from %s %d,the message is:%s\n&quot;</span>, <span class="built_in">inet_ntoa</span>(fromaddr.sin_addr), <span class="built_in">ntohs</span>(fromaddr.sin_port), buf);</span><br><span class="line">    <span class="built_in">close</span>(sfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Example：UDP发送文件  先发文件大小  再发文件内容</p>
<p>服务器端：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(sfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> fromaddr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;fromaddr, <span class="built_in">sizeof</span>(fromaddr));</span><br><span class="line">    <span class="type">int</span> fromaddrlen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">recvfrom</span>(sfd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;fromaddr, &amp;fromaddrlen) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;recvfrom&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;receive from %s %d,the message is:%s\n&quot;</span>, <span class="built_in">inet_ntoa</span>(fromaddr.sin_addr), <span class="built_in">ntohs</span>(fromaddr.sin_port), buf);</span><br><span class="line">    </span><br><span class="line">    FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;  <span class="comment">//用于获取文件内容的大小</span></span><br><span class="line">    <span class="built_in">stat</span>(<span class="string">&quot;1.txt&quot;</span>, &amp;st);</span><br><span class="line">    <span class="type">int</span> filelen = st.st_size;</span><br><span class="line">    <span class="built_in">sendto</span>(sfd, (<span class="type">void</span>*)&amp;filelen, <span class="built_in">sizeof</span>(<span class="type">int</span>), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;fromaddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(fp))   <span class="comment">//表示没有到文件尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">fread</span>(buf,<span class="number">1</span>,<span class="built_in">sizeof</span>(buf),fp);</span><br><span class="line">        <span class="built_in">sendto</span>(sfd, buf, len, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;fromaddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">close</span>(sfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 512</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> toaddr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;toaddr, <span class="built_in">sizeof</span>(toaddr));</span><br><span class="line">    toaddr.sin_family = AF_INET;</span><br><span class="line">    toaddr.sin_port = <span class="built_in">htons</span>(<span class="built_in">atoi</span>(argv[<span class="number">2</span>]));</span><br><span class="line">    toaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">sendto</span>(sfd, <span class="string">&quot;hello&quot;</span>, <span class="number">6</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;toaddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> fromaddr;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;fromaddr, <span class="built_in">sizeof</span>(fromaddr));</span><br><span class="line">    <span class="type">int</span> fromaddrlen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">    <span class="type">int</span> filelen = <span class="number">0</span>;   <span class="comment">//用于保存文件长度</span></span><br><span class="line">    FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;2.txt&quot;</span>,<span class="string">&quot;w+b&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//接收文件的长度</span></span><br><span class="line">    <span class="built_in">recvfrom</span>(sfd, (<span class="type">void</span>*)&amp;filelen, <span class="built_in">sizeof</span>(<span class="type">int</span>), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;fromaddr, &amp;fromaddrlen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the length of file is %d\n&quot;</span>,filelen);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Create a new file!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin to reveive file content!\n&quot;</span>);</span><br><span class="line">    <span class="comment">//接收文件的内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">recvfrom</span>(sfd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;fromaddr, &amp;fromaddrlen);</span><br><span class="line">        <span class="keyword">if</span>(len &lt; BUFSIZE)</span><br><span class="line">        <span class="comment">//如果接收的长度小于BUFSIZE，则表示最后一次接收，此时要用break退出循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fwrite</span>(buf,<span class="built_in">sizeof</span>(<span class="type">char</span>),len,fp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fwrite</span>(buf,<span class="built_in">sizeof</span>(<span class="type">char</span>),len,fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;receive file finished!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">close</span>(sfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="设置套接口的选项setsockopt的用法"><a href="#设置套接口的选项setsockopt的用法" class="headerlink" title="设置套接口的选项setsockopt的用法"></a>设置套接口的选项setsockopt的用法</h2><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h &gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>sockfd：标识一个套接口的描述字</li>
<li>level：选项定义的层次；支持SOL_SOCKET、IPPROTO_TCP、IPPROTO_IP和IPPROTO_IPV6</li>
<li>optname：需设置的选项</li>
<li>optval：指针，指向存放选项值的缓冲区</li>
<li>optlen：optval缓冲区长度</li>
</ul>
<p>全部都必须要放在bind之前，另外通常是用于UDP的。</p>
<p>如果在已经处于 ESTABLISHED状态下的socket(一般由端口号和标志符区分）调用closesocket（一般不会立即关闭而经历TIME_WAIT的过程）后想继续重用该socket：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> reuse=<span class="number">1</span>;</span><br><span class="line">setsockopt(s,SOL_SOCKET ,SO_REUSEADDR,(<span class="type">const</span> <span class="type">char</span>*)&amp; reuse,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure></p>
<p>如果要已经处于连接状态的soket在调用closesocket后强制关闭，不经历TIME_WAIT的过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> reuse=<span class="number">0</span>;</span><br><span class="line">setsockopt(s,SOL_SOCKET ,SO_REUSEADDR,(<span class="type">const</span> <span class="type">char</span>*)&amp; reuse,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure></p>
<p>在send(),recv()过程中有时由于网络状况等原因，发收不能预期进行,而设置收发时限：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nNetTimeout=<span class="number">1000</span>; <span class="comment">// 1秒</span></span><br><span class="line"><span class="comment">// 发送时限</span></span><br><span class="line">setsockopt(socket，SOL_S0CKET,SO_SNDTIMEO，(<span class="type">char</span> *)&amp;nNetTimeout,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">// 接收时限</span></span><br><span class="line">setsockopt(socket，SOL_S0CKET,SO_RCVTIMEO，(<span class="type">char</span> *)&amp;nNetTimeout,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure></p>
<p>在send()的时候，返回的是实际发送出去的字节(同步)或发送到socket缓冲区的字节(异步),系统默认的状态发送和接收一次为8688字节(约为8.5K)；在实际的过程中发送数据和接收数据量比较大，可以设置socket缓冲区，而避免了send(),recv()不断的循环收发：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收缓冲区</span></span><br><span class="line"><span class="type">int</span> nRecvBuf=<span class="number">32</span>*<span class="number">1024</span>;    <span class="comment">// 设置为32K</span></span><br><span class="line">setsockopt(s,SOL_SOCKET,SO_RCVBUF,(<span class="type">const</span> <span class="type">char</span>*)&amp;nRecvBuf,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">// 发送缓冲区</span></span><br><span class="line"><span class="type">int</span> nSendBuf=<span class="number">32</span>*<span class="number">1024</span>;    <span class="comment">// 设置为32K</span></span><br><span class="line">setsockopt(s,SOL_SOCKET,SO_SNDBUF,(<span class="type">const</span> <span class="type">char</span>*)&amp;nSendBuf,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure></p>
<p>如果在发送数据时，希望不经历由系统缓冲区到socket缓冲区的拷贝而影响程序的性能：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nZero=<span class="number">0</span>;</span><br><span class="line">setsockopt(socket，SOL_SOCKET,SO_SNDBUF，(<span class="type">char</span> *)&amp;nZero,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure></p>
<p>同上在recv()完成上述功能(默认情况是将socket缓冲区的内容拷贝到系统缓冲区)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nZero=<span class="number">0</span>;</span><br><span class="line">setsockopt(socket，SOL_SOCKET,SO_RCVBUF，(<span class="type">char</span> *)&amp;nZero,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure></p>
<p>一般在发送UDP数据报的时候，希望该socket发送的数据具有广播特性：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int bBroadcast = 1;</span><br><span class="line">setsockopt(s,SOL_SOCKET,SO_BROADCAST,(const char*)&amp;bBroadcast,sizeof(int));</span><br></pre></td></tr></table></figure></p>
<h2 id="单播、广播、组播（多播）"><a href="#单播、广播、组播（多播）" class="headerlink" title="单播、广播、组播（多播）"></a>单播、广播、组播（多播）</h2><p>多播广播是用于建立分步式系统：例如网络游戏、ICQ聊天构建、远程视频会议系统的重要工具。使用多播广播的程序和UDP的单播程序相似。区别在于多播广播程序使用特殊的IP地址。</p>
<p>对于单播而言，单播用于两个主机之间的端对端通信。</p>
<p>对于广播而言，广播用于一个主机对整个局域网上所有主机上的数据通信。广播只能用于客户机向服务器广播，因为客户机要指明广播的IP地址“192.168.0.255”和广播的端口号。服务器端bing的时候，绑定的端口号要跟广播的端口号是同一个。这样才能收到广播消息。实例请参考《udp_广播》。</p>
<p>对于多播而言，也称为“组播”，将网络中同一业务类型主机进行了逻辑上的分组，进行数据收发的时候其数据仅仅在同一分组中进行，其他的主机没有加入此分组不能收发对应的数据。单播和广播是两个极端，要么对一个主机进行通信，要么对整个局域网上的主机进行通信。实际情况下，经常需要对一组特定的主机进行通信，而不是整个局域网上的所有主机，这就是多播的用途。例如，我们通常所说的讨论组。IPv4多播地址采用D类IP地址确定多播的组。在Internet中，多播地址范围是从224.0.0.0到234.255.255.255。</p>
<p>多播的程序设计也要使用setsockopt()函数和getsockopt()函数来实现。其中对于setsockopt的第二个参数level不再是SOL_SOCKET，而是IPPROTO_IP；而且第三个参数optname常见的选项有：</p>
<ul>
<li><code>IP_ADD_MEMBERSHIP</code>：在指定接口上加入组播组</li>
<li><code>IP_DROP_MEMBERSHIP</code>：退出组播组</li>
</ul>
<p>选项IP_ADD_MEMBERSHIP和IP_DROP_MEMBERSHIP加入或者退出一个组播组，通过选项IP_ADD_MEMBERSHIP和IP_DROP_MEMBERSHIP，对一个结构struct ip_mreq类型的变量进行控制。</p>
<p><code>struct ip_mreq</code>原型如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ip_mreq</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span>    imr_multiaddr; <span class="comment">/*加入或者退出的多播组IP地址*/</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span>    imr_interface; <span class="comment">/*加入或者退出的网络接口IP地址，本机IP*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>选项IP_ADD_MEMBERSHIP用于加入某个多播组，之后就可以向这个多播组发送数据或者从多播组接收数据。此选项的值为mreq结构，成员imr_multiaddr是需要加入的多播组IP地址，成员imr_interface是本机需要加入多播组的网络接口IP地址。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">mreq</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;mreq, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_mreq));</span><br><span class="line">mreq.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line">mreq.imr_multiaddr.s_addr = inet_addr(<span class="string">&quot;224.1.1.1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == setsockopt(sfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_mreq)))</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来再绑定组播的port号（如65000），就可以接收组播消息了。</p>
<p>选项IP_ADD_MEMBERSHIP每次只能加入一个网络接口的IP地址到多播组，但并不是一个多播组仅允许一个主机IP地址加入，可以多次调用IP_ADD_MEMBERSHIP选项来实现多个IP地址加入同一个广播组，或者同一个IP地址加入多个广播组。</p>
<p>选项IP_DROP_MEMBERSHIP用于从一个多播组中退出。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">-1</span> == setsockopt(sfd, IPPROTP_IP, IP_DROP_MEMBERSHIP, &amp;mreq, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip_mreq)))</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="100个网络基础知识"><a href="#100个网络基础知识" class="headerlink" title="100个网络基础知识"></a>100个网络基础知识</h1><p><img src="/img/20200311150400.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/27/OpenMPI%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/27/OpenMPI%E6%BA%90%E7%A0%81/" itemprop="url">OpenMPI源码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-27T11:23:00+08:00">
                2022-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="OpenMPI结构"><a href="#OpenMPI结构" class="headerlink" title="OpenMPI结构"></a>OpenMPI结构</h1><p>Open MPI 联合了四种MPI的不同实现：</p>
<ul>
<li>LAM/MPI,</li>
<li>LA/MPI (Los Alamos MPI)</li>
<li>FT-MPI (Fault-Tolerant MPI)</li>
<li>PACX-MPI</li>
</ul>
<h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p>Open MPI使用C语言编写，是一个非常庞大、复杂的代码库。2003的MPI 标准——MPI-2.0，定义了超过300个API接口。</p>
<p>之前的4个项目，每个项目都非常庞大。例如，LAM/MPI由超过1900个源码文件，代码量超过30W行。希望Open MPI尽可能的支持更多的特性、环境以及网络类型。因此Open MPI花了大量时间设计架构，主要专注于三件事情：</p>
<ul>
<li>将相近的功能划分在不同的抽象层</li>
<li>使用运行时可加载的插件以及运行时参数，来选择相同接口的不同实现</li>
<li>不允许抽象影响性能</li>
</ul>
<h2 id="Abstraction-Layer-Architecture"><a href="#Abstraction-Layer-Architecture" class="headerlink" title="Abstraction Layer Architecture"></a>Abstraction Layer Architecture</h2><p>Open MPi 可以分为三个主要的抽象层，自顶向下依次为：</p>
<ul>
<li>OMPI (Open MPI) (pronounced: oom-pee):<ul>
<li>由 MPI standard 所定义</li>
<li>暴露给上层应用的 API，由外部应用调用</li>
</ul>
</li>
<li>ORTE (Open MPI Run-Time Environment) (pronounced “or-tay”):<ul>
<li>MPI 的 run-time system<ul>
<li>launch, monitor, kill individual processes</li>
<li>Group individual processes into “jobs”</li>
</ul>
</li>
<li>重定向stdin、stdout、stderr</li>
<li>ORTE 进程管理方式：在简单的环境中，通过rsh或ssh 来launch 进程。而复杂环境(HPC专用)会有shceduler、resource manager等管理组件，面向多个用户进行公平的调度以及资源分配，ORTE支持多种管理环境，例如，orque/PBS Pro, SLURM, Oracle Grid Engine, and LSF.<ul>
<li>注意 ORTE 在 5.x 版本中被移除，进程管理模块被替换成了<a href="openpmix/prrte: PMIx Reference RunTime Environment (PRRTE">prrte</a> (github.com))</li>
</ul>
</li>
</ul>
</li>
<li>OPAL (Open, Portable Access Layer) (pronounced: o-pull): OPAL 是xOmpi的最底层<ul>
<li>只作用于单个进程</li>
<li>负责不同环境的可移植性</li>
<li>包含了一些通用功能（例如链表、字符串操作、debug控制等等）</li>
</ul>
</li>
</ul>
<p><img src="/img/ea15ad9d6b754529839246ccd79d44a3.awebp" alt=""></p>
<p>在代码目录中是以project的形式存在，也就是<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ompi/</span><br><span class="line">├── ompi</span><br><span class="line">├── opal</span><br><span class="line">└── orte</span><br></pre></td></tr></table></figure></p>
<p>需要注意的时，考虑到性能因素，Open MPI 有中“旁路”机制（bypass），ORTE以及OMPI层，可以绕过OPAL，直接与操作系统（甚至是硬件）进行交互。例如OMPI会直接与网卡进行交互，从而达到最大的网络性能。</p>
<h2 id="Plugin-Architecture"><a href="#Plugin-Architecture" class="headerlink" title="Plugin Architecture"></a>Plugin Architecture</h2><p>为了在 Open MPI 中使用类似但是不同效果的功能，Open MPI 设计一套被称为<strong>Modular Component Architecture (MCA)</strong>的架构。在MCA架构中，为每一个抽象层（也就是OMPI、ORTE、OPAL）定义了多个framework，这里的framework类似于其他语言语境中的接口（interface），framework对于一个功能进行了抽象，而plugin就是对于一个framework的不同实现。每个 Plugin 都是以动态链接库（DSO，dynamic shared object）的形式存在。因此run time 能够动态的加载不同的plugin。</p>
<p>例如下图中 btl 是一个功能传输bytes的framework，它属于OMPI层，btl framework之下又包含针对不同网络类型的实现，例如 tcp、openib (InfiniBand)、sm (shared memory)、sm-cuda (shared memory for CUDA)<br><img src="/img/cddc2d92b0fa44eeb642d16b0a1a3c32.awebp" alt=""></p>
<h1 id="PML"><a href="#PML" class="headerlink" title="PML"></a>PML</h1><p>PML即P2P Management Layer，MPI基于这一层，基本所有的通信都是通过这一层实现的，它提供 MPI 层所需的 P2P 接口功能的 MCA 组件类型。 PML 是一个相对较薄的层，主要用于通过多种传输（字节传输层 (BTL) MCA 组件类型的实例）对消息进行分段和调度，如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------</span><br><span class="line">|                MPI               |</span><br><span class="line">------------------------------------</span><br><span class="line">|                PML               |</span><br><span class="line">------------------------------------</span><br><span class="line">| BTL (TCP) | BTL (SM) | BTL (...) |</span><br><span class="line">------------------------------------</span><br></pre></td></tr></table></figure></p>
<p>MCA 框架在库初始化期间选择单个 PML 组件。 最初，所有可用的 PML 都被加载（可能作为共享库）并调用它们的组件打开和初始化函数。 MCA 框架选择返回最高优先级的组件并关闭/卸载可能已打开的任何其他 PML 组件。</p>
<p>在初始化所有 MCA 组件之后，MPI/RTE 将对 PML 进行向下调用，以提供进程的初始列表（ompi_proc_t 实例）和更改通知（添加/删除）。PML 模块必须选择一组用于达到给定目的地的 BTL 组件。这些应缓存在挂在 ompi_proc_t 之外的 PML 特定数据结构上，也就是说PML层应该给它定义的一系列通信函数指针赋值，让PML层知道该调用哪些函数。然后，PML 应该应用调度算法（循环、加权分布等）来调度可用 BTL 上的消息传递。</p>
<h1 id="MTL"><a href="#MTL" class="headerlink" title="MTL"></a>MTL</h1><p>Matching Transport Layer匹配传输层 (MTL) 为通过支持硬件/库消息匹配的设备传输 MPI 点对点消息提供设备层支持。该层与 MTL PML 组件一起使用，以在给定架构上提供最低延迟和最高带宽。 上层不提供其他 PML 接口中的功能，例如消息分段、多设备支持和 NIC 故障转移。 通常，此接口不应用于传输层支持。 相反，应该使用 BTL 接口。 BTL 接口允许在多个用户之间进行多路复用（点对点、单面等），并提供了该接口中没有的许多功能（来自任意缓冲区的 RDMA、主动消息传递、合理的固定内存缓存等）</p>
<p>这应该是一个接口层，负责调用底层真正通信的函数。</p>
<p>阻塞发送（调用不应该返回，直到用户缓冲区可以再次使用）。此调用必须满足标准 MPI 语义，如 mode 参数中所要求的。有一个特殊的模式参数，MCA_PML_BASE_SEND_COMPLETE，它需要在函数返回之前本地完成。这是对集体惯例的优化，否则会导致基于广播的集体的性能退化。</p>
<p>Open MPI 是围绕非阻塞操作构建的。此功能适用于在不定期触发进度功能的情况下可能发生点对点之外的进展事件（例如，集体、I/O、单面）的网络。</p>
<p>虽然 MPI 不允许用户指定否定标签，但它们在 Open MPI 内部用于为集体操作提供独特的渠道。因此，如果使用否定标签，MTL <em>不会</em>导致错误。</p>
<p>非阻塞发送到对等方。此调用必须满足标准 MPI 语义，如 mode 参数中所要求的。有一个特殊的模式参数，MCA_PML_BASE_SEND_COMPLETE，它需要在请求被标记为完成之前本地完成。</p>
<p>PML 将处理请求的创建，将模块结构中请求的字节数直接放在 ompi_request_t 结构之后可用于 MTL。一旦可以安全地销毁请求（它已通过调用 REQUEST_FReE 或 TEST/WAIT 完成并释放），PML 将处理请求的适当销毁。当请求被标记为已完成时，MTL 应删除与请求关联的所有资源。</p>
<p>虽然 MPI 不允许用户指定否定标签，但它们在 Open MPI 内部用于为集体操作提供独特的渠道。因此，如果使用否定标签，MTL <em>不会</em>导致错误。</p>
<h1 id="OSC"><a href="#OSC" class="headerlink" title="OSC"></a>OSC</h1><p>One-sided Communication(OSC) 用于实现 MPI-2 标准的单向通信章节的接口。 在范围上类似于来自 MPI-1 的点对点通信的 PML。有以下几个主要函数：</p>
<ul>
<li>OSC component initialization：初始化给定的单边组件。 此函数应初始化任何组件级数据。组件框架不会延迟打开，因此应尽量减少在此功能期间分配的内存量。</li>
<li>OSC component finalization：结束给定的单边组件。 此函数应清除在 component_init() 期间分配的任何组件级数据。 它还应该清理在组件生命周期内创建的任何数据，包括任何未完成的模块。</li>
<li>OSC component query：查询给定info和comm，组件是否可以用于单边通信。 能够将组件用于窗口并不意味着该组件将被选中。 在此调用期间不应修改 win 参数，并且不应分配与此窗口关联的内存。</li>
<li>OSC component select：已选择此组件来为给定窗口提供单方面的服务。 win-&gt;w_osc_module 字段可以更新，内存可以与此窗口相关联。 该模块应在此函数返回后立即准备好使用，并且该模块负责在调用结束之前提供任何所需的集体同步。comm 是用户指定的通信器，因此适用正常的内部使用规则。 换句话说，如果您需要在窗口的生命周期内进行通信，则应在此函数期间调用 comm_dup()。</li>
</ul>
<h1 id="MPI-Init"><a href="#MPI-Init" class="headerlink" title="MPI_Init"></a>MPI_Init</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> FUNC_NAME[] = <span class="string">&quot;MPI_Init&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Init</span><span class="params">(<span class="type">int</span> *argc, <span class="type">char</span> ***argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">int</span> provided;</span><br><span class="line">    <span class="type">char</span> *env;</span><br><span class="line">    <span class="type">int</span> required = MPI_THREAD_SINGLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for environment overrides for required thread level.  If</span></span><br><span class="line"><span class="comment">       there is, check to see that it is a valid/supported thread level.</span></span><br><span class="line"><span class="comment">       If not, default to MPI_THREAD_MULTIPLE. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != (env = <span class="built_in">getenv</span>(<span class="string">&quot;OMPI_MPI_THREAD_LEVEL&quot;</span>))) &#123;</span><br><span class="line">        required = <span class="built_in">atoi</span>(env);</span><br><span class="line">        <span class="keyword">if</span> (required &lt; MPI_THREAD_SINGLE || required &gt; MPI_THREAD_MULTIPLE) &#123;</span><br><span class="line">            required = MPI_THREAD_MULTIPLE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查多线程相关的命令行参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call the back-end initialization function (we need to put as</span></span><br><span class="line"><span class="comment">       little in this function as possible so that if it&#x27;s profiled, we</span></span><br><span class="line"><span class="comment">       don&#x27;t lose anything) 这个函数在下边了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != argc &amp;&amp; <span class="literal">NULL</span> != argv) &#123;</span><br><span class="line">        err = <span class="built_in">ompi_mpi_init</span>(*argc, *argv, required, &amp;provided, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = <span class="built_in">ompi_mpi_init</span>(<span class="number">0</span>, <span class="literal">NULL</span>, required, &amp;provided, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Since we don&#x27;t have a communicator to invoke an errorhandler on</span></span><br><span class="line"><span class="comment">       here, don&#x27;t use the fancy-schmancy ERRHANDLER macros; they&#x27;re</span></span><br><span class="line"><span class="comment">       really designed for real communicator objects.  Just use the</span></span><br><span class="line"><span class="comment">       back-end function directly. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MPI_SUCCESS != err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ompi_errhandler_invoke</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">                                      OMPI_ERRHANDLER_TYPE_COMM,</span><br><span class="line">                                      err &lt;</span><br><span class="line">                                      <span class="number">0</span> ? <span class="built_in">ompi_errcode_get_mpi_code</span>(err) :</span><br><span class="line">                                      err, FUNC_NAME);</span><br><span class="line">    &#125; <span class="comment">// 如果初始化函数返回的不是 MPI_SUCCESS， 就返回错误码</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">SPC_INIT</span>(); <span class="comment">// 初始化调用函数的计时器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ompi_mpi_init</code>是真正mpi初始化的函数。内部设计的很精细，因为要考虑很多多线程同时操作的情况，在各个地方都加了锁。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_mpi_init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">int</span> requested, <span class="type">int</span> *provided,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">bool</span> reinit_ok)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">char</span> *error = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_USING_INTERNAL_PMIX</span></span><br><span class="line">    <span class="type">char</span> *evar;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">bool</span> active;</span><br><span class="line">    <span class="type">bool</span> background_fence = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">pmix_info_t</span> info[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pmix_status_t</span> rc;</span><br><span class="line">    <span class="built_in">OMPI_TIMING_INIT</span>(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ompi_hook_base_mpi_init_top</span>(argc, argv, requested, provided);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ensure that we were not already initialized or finalized. */</span></span><br><span class="line">    <span class="type">int32_t</span> expected = OMPI_MPI_STATE_NOT_INITIALIZED;</span><br><span class="line">    <span class="type">int32_t</span> desired  = OMPI_MPI_STATE_INIT_STARTED;</span><br><span class="line">    <span class="built_in">opal_atomic_wmb</span>(); <span class="comment">// 内存同步？</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">opal_atomic_compare_exchange_strong_32</span>(&amp;ompi_mpi_state, &amp;expected,</span><br><span class="line">                                                desired)) &#123;</span><br><span class="line">        <span class="comment">// 此内置函数实现了原子比较和交换操作。这会将 ompi_mpi_state 的内容与 expected 的内容进行比较。</span></span><br><span class="line">        <span class="comment">// 如果相等，则该操作是将 desired 写入 ompi_mpi_state。</span></span><br><span class="line">        <span class="comment">// 如果它们不相等，操作是读取和 ompi_mpi_state 写入 expected。 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免多个进程/线程同时修改当前MPI状态</span></span><br><span class="line">        <span class="comment">// If we failed to atomically transition ompi_mpi_state from</span></span><br><span class="line">        <span class="comment">// NOT_INITIALIZED to INIT_STARTED, then someone else already</span></span><br><span class="line">        <span class="comment">// did that, and we should return.</span></span><br><span class="line">        <span class="keyword">if</span> (expected &gt;= OMPI_MPI_STATE_FINALIZE_STARTED) &#123;</span><br><span class="line">            <span class="built_in">opal_show_help</span>(<span class="string">&quot;help-mpi-runtime.txt&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;mpi_init: already finalized&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> MPI_ERR_OTHER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expected &gt;= OMPI_MPI_STATE_INIT_STARTED) &#123;</span><br><span class="line">            <span class="comment">// In some cases (e.g., oshmem_shmem_init()), we may call</span></span><br><span class="line">            <span class="comment">// ompi_mpi_init() multiple times.  In such cases, just</span></span><br><span class="line">            <span class="comment">// silently return successfully once the initializing</span></span><br><span class="line">            <span class="comment">// thread has completed.</span></span><br><span class="line">            <span class="keyword">if</span> (reinit_ok) &#123;</span><br><span class="line">                <span class="keyword">while</span> (ompi_mpi_state &lt; OMPI_MPI_STATE_INIT_COMPLETED) &#123;</span><br><span class="line">                    <span class="built_in">usleep</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">opal_show_help</span>(<span class="string">&quot;help-mpi-runtime.txt&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;mpi_init: invoked multiple times&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> MPI_ERR_OTHER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* deal with OPAL_PREFIX to ensure that an internal PMIx installation</span></span><br><span class="line"><span class="comment">     * is also relocated if necessary */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_USING_INTERNAL_PMIX</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != (evar = <span class="built_in">getenv</span>(<span class="string">&quot;OPAL_PREFIX&quot;</span>))) &#123;</span><br><span class="line">        <span class="built_in">opal_setenv</span>(<span class="string">&quot;PMIX_PREFIX&quot;</span>, evar, <span class="literal">true</span>, &amp;environ);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ompi_mpi_thread_level</span>(requested, provided); <span class="comment">// 设置线程级别</span></span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">ompi_mpi_instance_init</span> (*provided, &amp;ompi_mpi_info_null.info.super, MPI_ERRORS_ARE_FATAL, &amp;ompi_mpi_instance_default);</span><br><span class="line">    <span class="comment">// 创建一个新的MPI实例，</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_UNLIKELY</span>(OMPI_SUCCESS != ret)) &#123;</span><br><span class="line">        error = <span class="string">&quot;ompi_mpi_init: ompi_mpi_instance_init failed&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ompi_hook_base_mpi_init_top_post_opal</span>(argc, argv, requested, provided);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize communicator subsystem,</span></span><br><span class="line"><span class="comment">    communicator MPI_COMM_WORLD and MPI_COMM_SELF</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    构建通信域结构体，保存进程数信息</span></span><br><span class="line"><span class="comment">    通过ompi_group_translate_ranks函数得到rank</span></span><br><span class="line"><span class="comment">    通过遍历找到通信域内与本进程对应的rank么</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (OMPI_SUCCESS != (ret = <span class="built_in">ompi_comm_init_mpi3</span> ())) &#123;</span><br><span class="line">        error = <span class="string">&quot;ompi_mpi_init: ompi_comm_init_mpi3 failed&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bozo argument check */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == argv &amp;&amp; argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        ret = OMPI_ERR_BAD_PARAM;</span><br><span class="line">        error = <span class="string">&quot;argc &gt; 1, but argv == NULL&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if we were not externally started, then we need to setup</span></span><br><span class="line"><span class="comment">     * some envars so the MPI_INFO_ENV can get the cmd name</span></span><br><span class="line"><span class="comment">     * and argv (but only if the user supplied a non-NULL argv!), and</span></span><br><span class="line"><span class="comment">     * the requested thread level</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">getenv</span>(<span class="string">&quot;OMPI_COMMAND&quot;</span>) &amp;&amp; <span class="literal">NULL</span> != argv &amp;&amp; <span class="literal">NULL</span> != argv[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="built_in">opal_setenv</span>(<span class="string">&quot;OMPI_COMMAND&quot;</span>, argv[<span class="number">0</span>], <span class="literal">true</span>, &amp;environ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">getenv</span>(<span class="string">&quot;OMPI_ARGV&quot;</span>) &amp;&amp; <span class="number">1</span> &lt; argc) &#123;</span><br><span class="line">        <span class="type">char</span> *tmp;</span><br><span class="line">        tmp = <span class="built_in">opal_argv_join</span>(&amp;argv[<span class="number">1</span>], <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="built_in">opal_setenv</span>(<span class="string">&quot;OMPI_ARGV&quot;</span>, tmp, <span class="literal">true</span>, &amp;environ);</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (OPAL_ENABLE_TIMING)</span></span><br><span class="line">    <span class="keyword">if</span> (OMPI_TIMING_ENABLED &amp;&amp; !opal_pmix_base_async_modex &amp;&amp;</span><br><span class="line">            opal_pmix_collect_all_data &amp;&amp; !ompi_singleton) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PMIX_SUCCESS != (rc = <span class="built_in">PMIx_Fence</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>))) &#123;</span><br><span class="line">            ret = <span class="built_in">opal_pmix_convert_status</span>(rc);</span><br><span class="line">            error = <span class="string">&quot;timing: pmix-barrier-1 failed&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">OMPI_TIMING_NEXT</span>(<span class="string">&quot;pmix-barrier-1&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (PMIX_SUCCESS != (rc = <span class="built_in">PMIx_Fence</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>))) &#123;</span><br><span class="line">            ret = <span class="built_in">opal_pmix_convert_status</span>(rc);</span><br><span class="line">            error = <span class="string">&quot;timing: pmix-barrier-2 failed&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">OMPI_TIMING_NEXT</span>(<span class="string">&quot;pmix-barrier-2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ompi_singleton) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opal_pmix_base_async_modex) &#123;</span><br><span class="line">            <span class="comment">/* if we are doing an async modex, but we are collecting all</span></span><br><span class="line"><span class="comment">             * data, then execute the non-blocking modex in the background.</span></span><br><span class="line"><span class="comment">             * All calls to modex_recv will be cached until the background</span></span><br><span class="line"><span class="comment">             * modex completes. If collect_all_data is false, then we skip</span></span><br><span class="line"><span class="comment">             * the fence completely and retrieve data on-demand from the</span></span><br><span class="line"><span class="comment">             * source node.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (opal_pmix_collect_all_data) &#123;</span><br><span class="line">                <span class="comment">/* execute the fence_nb in the background to collect</span></span><br><span class="line"><span class="comment">                 * the data */</span></span><br><span class="line">                background_fence = <span class="literal">true</span>;</span><br><span class="line">                active = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">OPAL_POST_OBJECT</span>(&amp;active);</span><br><span class="line">                <span class="built_in">PMIX_INFO_LOAD</span>(&amp;info[<span class="number">0</span>], PMIX_COLLECT_DATA, &amp;opal_pmix_collect_all_data, PMIX_BOOL);</span><br><span class="line">                <span class="keyword">if</span>( PMIX_SUCCESS != (rc = <span class="built_in">PMIx_Fence_nb</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">                                                        fence_release,</span><br><span class="line">                                                        (<span class="type">void</span>*)&amp;active))) &#123;</span><br><span class="line">                    ret = <span class="built_in">opal_pmix_convert_status</span>(rc);</span><br><span class="line">                    error = <span class="string">&quot;PMIx_Fence_nb() failed&quot;</span>;</span><br><span class="line">                    <span class="keyword">goto</span> error;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* we want to do the modex - we block at this point, but we must</span></span><br><span class="line"><span class="comment">             * do so in a manner that allows us to call opal_progress so our</span></span><br><span class="line"><span class="comment">             * event library can be cycled as we have tied PMIx to that</span></span><br><span class="line"><span class="comment">             * event base */</span></span><br><span class="line">            active = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">OPAL_POST_OBJECT</span>(&amp;active);</span><br><span class="line">            <span class="built_in">PMIX_INFO_LOAD</span>(&amp;info[<span class="number">0</span>], PMIX_COLLECT_DATA, &amp;opal_pmix_collect_all_data, PMIX_BOOL);</span><br><span class="line">            rc = <span class="built_in">PMIx_Fence_nb</span>(<span class="literal">NULL</span>, <span class="number">0</span>, info, <span class="number">1</span>, fence_release, (<span class="type">void</span>*)&amp;active);</span><br><span class="line">            <span class="keyword">if</span>( PMIX_SUCCESS != rc) &#123;</span><br><span class="line">                ret = <span class="built_in">opal_pmix_convert_status</span>(rc);</span><br><span class="line">                error = <span class="string">&quot;PMIx_Fence() failed&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* cannot just wait on thread as we need to call opal_progress */</span></span><br><span class="line">            <span class="built_in">OMPI_LAZY_WAIT_FOR_COMPLETION</span>(active);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OMPI_TIMING_NEXT</span>(<span class="string">&quot;modex&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把当前这两个通信域加进来</span></span><br><span class="line">    <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">add_comm</span>(&amp;ompi_mpi_comm_world.comm));</span><br><span class="line">    <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">add_comm</span>(&amp;ompi_mpi_comm_self.comm));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是fault tolerant相关的结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_ENABLE_FT_MPI</span></span><br><span class="line">    <span class="comment">/* initialize the fault tolerant infrastructure (revoke, detector,</span></span><br><span class="line"><span class="comment">     * propagator) */</span></span><br><span class="line">    <span class="keyword">if</span>( ompi_ftmpi_enabled ) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *evmethod;</span><br><span class="line">        rc = <span class="built_in">ompi_comm_rbcast_init</span>();</span><br><span class="line">        <span class="keyword">if</span>( OMPI_SUCCESS != rc ) <span class="keyword">return</span> rc;</span><br><span class="line">        rc = <span class="built_in">ompi_comm_revoke_init</span>();</span><br><span class="line">        <span class="keyword">if</span>( OMPI_SUCCESS != rc ) <span class="keyword">return</span> rc;</span><br><span class="line">        rc = <span class="built_in">ompi_comm_failure_propagator_init</span>();</span><br><span class="line">        <span class="keyword">if</span>( OMPI_SUCCESS != rc ) <span class="keyword">return</span> rc;</span><br><span class="line">        rc = <span class="built_in">ompi_comm_failure_detector_init</span>();</span><br><span class="line">        <span class="keyword">if</span>( OMPI_SUCCESS != rc ) <span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">        evmethod = <span class="built_in">event_base_get_method</span>(opal_sync_event_base);</span><br><span class="line">        <span class="keyword">if</span>( <span class="number">0</span> == <span class="built_in">strcmp</span>(<span class="string">&quot;select&quot;</span>, evmethod) ) &#123;</span><br><span class="line">            <span class="built_in">opal_show_help</span>(<span class="string">&quot;help-mpi-ft.txt&quot;</span>, <span class="string">&quot;module:event:selectbug&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Dump all MCA parameters if requested</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ompi_mpi_show_mca_params) &#123;</span><br><span class="line">        <span class="built_in">ompi_show_all_mca_params</span>(ompi_mpi_comm_world.comm.c_my_rank,</span><br><span class="line">                                 ompi_process_info.num_procs,</span><br><span class="line">                                 ompi_process_info.nodename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do we need to wait for a debugger? */</span></span><br><span class="line">    <span class="built_in">ompi_rte_wait_for_debugger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Next timing measurement */</span></span><br><span class="line">    <span class="built_in">OMPI_TIMING_NEXT</span>(<span class="string">&quot;modex-barrier&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ompi_singleton) &#123;</span><br><span class="line">        <span class="comment">/* if we executed the above fence in the background, then</span></span><br><span class="line"><span class="comment">         * we have to wait here for it to complete. However, there</span></span><br><span class="line"><span class="comment">         * is no reason to do two barriers! */</span></span><br><span class="line">        <span class="keyword">if</span> (background_fence) &#123;</span><br><span class="line">            <span class="built_in">OMPI_LAZY_WAIT_FOR_COMPLETION</span>(active);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ompi_async_mpi_init) &#123;</span><br><span class="line">            <span class="comment">/* wait for everyone to reach this point - this is a hard</span></span><br><span class="line"><span class="comment">             * barrier requirement at this time, though we hope to relax</span></span><br><span class="line"><span class="comment">             * it at a later point */</span></span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            active = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">OPAL_POST_OBJECT</span>(&amp;active);</span><br><span class="line">            <span class="built_in">PMIX_INFO_LOAD</span>(&amp;info[<span class="number">0</span>], PMIX_COLLECT_DATA, &amp;flag, PMIX_BOOL);</span><br><span class="line">            <span class="keyword">if</span> (PMIX_SUCCESS != (rc = <span class="built_in">PMIx_Fence_nb</span>(<span class="literal">NULL</span>, <span class="number">0</span>, info, <span class="number">1</span>,</span><br><span class="line">                                                    fence_release, (<span class="type">void</span>*)&amp;active))) &#123;</span><br><span class="line">                ret = <span class="built_in">opal_pmix_convert_status</span>(rc);</span><br><span class="line">                error = <span class="string">&quot;PMIx_Fence_nb() failed&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">OMPI_LAZY_WAIT_FOR_COMPLETION</span>(active);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for timing request - get stop time and report elapsed</span></span><br><span class="line"><span class="comment">       time if so, then start the clock again */</span></span><br><span class="line">    <span class="built_in">OMPI_TIMING_NEXT</span>(<span class="string">&quot;barrier&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_ENABLE_PROGRESS_THREADS == 0</span></span><br><span class="line">    <span class="comment">/* Start setting up the event engine for MPI operations.  Don&#x27;t</span></span><br><span class="line"><span class="comment">       block in the event library, so that communications don&#x27;t take</span></span><br><span class="line"><span class="comment">       forever between procs in the dynamic code.  This will increase</span></span><br><span class="line"><span class="comment">       CPU utilization for the remainder of MPI_INIT when we are</span></span><br><span class="line"><span class="comment">       blocking on RTE-level events, but may greatly reduce non-TCP</span></span><br><span class="line"><span class="comment">       latency. */</span></span><br><span class="line">    <span class="type">int</span> old_event_flags = <span class="built_in">opal_progress_set_event_flag</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">opal_progress_set_event_flag</span>(old_event_flags | OPAL_EVLOOP_NONBLOCK);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wire up the mpi interface, if requested.  Do this after the</span></span><br><span class="line"><span class="comment">       non-block switch for non-TCP performance.  Do before the</span></span><br><span class="line"><span class="comment">       polling change as anyone with a complex wire-up is going to be</span></span><br><span class="line"><span class="comment">       using the oob. </span></span><br><span class="line"><span class="comment">        预先执行一些MPI send recv，建立连接？</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (OMPI_SUCCESS != (ret = <span class="built_in">ompi_init_preconnect_mpi</span>())) &#123;</span><br><span class="line">        error = <span class="string">&quot;ompi_mpi_do_preconnect_all() failed&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Init coll for the comms. This has to be after dpm_base_select,</span></span><br><span class="line"><span class="comment">       (since dpm.mark_dyncomm is not set in the communicator creation</span></span><br><span class="line"><span class="comment">       function else), but before dpm.dyncom_init, since this function</span></span><br><span class="line"><span class="comment">       might require collective for the CID allocation. </span></span><br><span class="line"><span class="comment">       设置集合通信相关的函数指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (OMPI_SUCCESS !=</span><br><span class="line">        (ret = <span class="built_in">mca_coll_base_comm_select</span>(MPI_COMM_WORLD))) &#123;</span><br><span class="line">        error = <span class="string">&quot;mca_coll_base_comm_select(MPI_COMM_WORLD) failed&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OMPI_SUCCESS !=</span><br><span class="line">        (ret = <span class="built_in">mca_coll_base_comm_select</span>(MPI_COMM_SELF))) &#123;</span><br><span class="line">        error = <span class="string">&quot;mca_coll_base_comm_select(MPI_COMM_SELF) failed&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_ENABLE_FT_MPI</span></span><br><span class="line">    <span class="comment">/* start the failure detector */</span></span><br><span class="line">    <span class="keyword">if</span>( ompi_ftmpi_enabled ) &#123;</span><br><span class="line">        rc = <span class="built_in">ompi_comm_failure_detector_start</span>();</span><br><span class="line">        <span class="keyword">if</span>( OMPI_SUCCESS != rc ) <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check whether we have been spawned or not.  We introduce that</span></span><br><span class="line"><span class="comment">       at the very end, since we need collectives, datatypes, ptls</span></span><br><span class="line"><span class="comment">       etc. up and running here.... </span></span><br><span class="line"><span class="comment">        此例程检查应用程序是否已由另一个 MPI 应用程序生成，或者是否已独立启动。</span></span><br><span class="line"><span class="comment">        如果它已经产生，它建立父通信器。</span></span><br><span class="line"><span class="comment">        由于例程必须进行通信，因此它应该是 MPI_Init 的最后一步，以确保一切都已设置好。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (OMPI_SUCCESS != (ret = <span class="built_in">ompi_dpm_dyn_init</span>())) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fall through */</span></span><br><span class="line"> error:</span><br><span class="line">    <span class="keyword">if</span> (ret != OMPI_SUCCESS) &#123;</span><br><span class="line">        <span class="comment">/* Only print a message if one was not already printed */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != error &amp;&amp; OMPI_ERR_SILENT != ret) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *err_msg = <span class="built_in">opal_strerror</span>(ret);</span><br><span class="line">            <span class="built_in">opal_show_help</span>(<span class="string">&quot;help-mpi-runtime.txt&quot;</span>,</span><br><span class="line">                           <span class="string">&quot;mpi_init:startup:internal-failure&quot;</span>, <span class="literal">true</span>,</span><br><span class="line">                           <span class="string">&quot;MPI_INIT&quot;</span>, <span class="string">&quot;MPI_INIT&quot;</span>, error, err_msg, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ompi_hook_base_mpi_init_error</span>(argc, argv, requested, provided);</span><br><span class="line">        OMPI_TIMING_FINALIZE;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All done.  Wasn&#x27;t that simple? */</span></span><br><span class="line">    <span class="built_in">opal_atomic_wmb</span>();</span><br><span class="line">    <span class="built_in">opal_atomic_swap_32</span>(&amp;ompi_mpi_state, OMPI_MPI_STATE_INIT_COMPLETED);</span><br><span class="line">    <span class="comment">// 原子性地设置标志位为已完成初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finish last measurement, output results</span></span><br><span class="line"><span class="comment">     * and clear timing structure */</span></span><br><span class="line">    <span class="built_in">OMPI_TIMING_NEXT</span>(<span class="string">&quot;barrier-finish&quot;</span>);</span><br><span class="line">    OMPI_TIMING_OUT;</span><br><span class="line">    OMPI_TIMING_FINALIZE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ompi_hook_base_mpi_init_bottom</span>(argc, argv, requested, provided);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里分别搞了两个communicator，分别是word和self，communicator有以下的状态，看英文就能看出来意思，通过位运算设置状态。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_COMM_INTER        0x00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_COMM_NAMEISSET    0x00000002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_COMM_INTRINSIC    0x00000004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_COMM_DYNAMIC      0x00000008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_COMM_ISFREED      0x00000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_COMM_INVALID      0x00000020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_COMM_CART         0x00000100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_COMM_GRAPH        0x00000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_COMM_DIST_GRAPH   0x00000400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_COMM_PML_ADDED    0x00001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_COMM_EXTRA_RETAIN 0x00004000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_COMM_MAPBY_NODE   0x00008000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_COMM_GLOBAL_INDEX 0x00010000</span></span><br></pre></td></tr></table></figure></p>
<h1 id="MPI-Comm-rank"><a href="#MPI-Comm-rank" class="headerlink" title="MPI_Comm_rank"></a>MPI_Comm_rank</h1><p>MPI_Comm_rank是获得进程在通信域的rank。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Comm_rank</span><span class="params">(MPI_Comm comm, <span class="type">int</span> *rank)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MEMCHECKER</span>(</span><br><span class="line">        <span class="built_in">memchecker_comm</span>(comm);</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( MPI_PARAM_CHECK ) &#123;</span><br><span class="line">        <span class="built_in">OMPI_ERR_INIT_FINALIZE</span>(FUNC_NAME);</span><br><span class="line">        <span class="comment">// 需要检查MPI是否已经初始化完成了，MPI通信域是不是合法的通信域，rank指针是否是空指针。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// MPI-2:4.12.4 明确指出 MPI_*_C2F 和 MPI_*_F2C 函数应将 MPI_COMM_NULL 视为有效的通信器</span></span><br><span class="line">        <span class="comment">// openmpi将 ompi_comm_invalid() 保留为原始编码——根据 MPI-1 定义，其中 MPI_COMM_NULL 是无效的通信域。</span></span><br><span class="line">        <span class="comment">// 因此，MPI_Comm_c2f() 函数调用 ompi_comm_invalid() 但也显式检查句柄是否为 MPI_COMM_NULL。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ompi_comm_invalid</span> (comm))</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">OMPI_ERRHANDLER_NOHANDLE_INVOKE</span>(MPI_ERR_COMM,</span><br><span class="line">                                          FUNC_NAME);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( <span class="literal">NULL</span> == rank )</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">OMPI_ERRHANDLER_INVOKE</span>(comm, MPI_ERR_ARG,</span><br><span class="line">                                          FUNC_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *rank = <span class="built_in">ompi_comm_rank</span>((<span class="type">ompi_communicator_t</span>*)comm);</span><br><span class="line">    <span class="keyword">return</span> MPI_SUCCESS;</span><br></pre></td></tr></table></figure></p>
<p><code>ompi_comm_rank</code>这个函数主要是返回结构体<code>ompi_communicator_t</code>的变量，结构体<code>ompi_communicator_t</code>如下，包括了集合通信，笛卡尔结构相关的数据结构<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ompi_communicator_t</span> &#123;</span><br><span class="line">    <span class="type">opal_infosubscriber_t</span>      super;</span><br><span class="line">    <span class="type">opal_mutex_t</span>               c_lock; <span class="comment">/* 互斥锁，为了修改变量用的可能 */</span></span><br><span class="line">    <span class="type">char</span>  c_name[MPI_MAX_OBJECT_NAME]; <span class="comment">/* 比如MPI_COMM_WORLD之类的 */</span></span><br><span class="line">    <span class="type">ompi_comm_extended_cid_t</span>      c_contextid;</span><br><span class="line">    <span class="type">ompi_comm_extended_cid_block_t</span> c_contextidb;</span><br><span class="line">    <span class="type">uint32_t</span>                      c_index;</span><br><span class="line">    <span class="type">int</span>                           c_my_rank;</span><br><span class="line">    <span class="type">uint32_t</span>                      c_flags; <span class="comment">/* flags, e.g. intercomm,</span></span><br><span class="line"><span class="comment">                                              topology, etc. */</span></span><br><span class="line">    <span class="type">uint32_t</span>                      c_assertions; <span class="comment">/* info assertions */</span></span><br><span class="line">    <span class="type">int</span> c_id_available; <span class="comment">/* the currently available Cid for allocation</span></span><br><span class="line"><span class="comment">               to a child*/</span></span><br><span class="line">    <span class="type">int</span> c_id_start_index; <span class="comment">/* the starting index of the block of cids</span></span><br><span class="line"><span class="comment">                 allocated to this communicator*/</span></span><br><span class="line">    <span class="type">uint32_t</span> c_epoch;  <span class="comment">/* Identifier used to differenciate between two communicators</span></span><br><span class="line"><span class="comment">                          using the same c_contextid (not at the same time, obviously) */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ompi_group_t</span>        *c_local_group;</span><br><span class="line">    <span class="type">ompi_group_t</span>       *c_remote_group;  <span class="comment">// 应该是存储了属于这个通信组的proc？</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ompi_communicator_t</span> *c_local_comm; <span class="comment">/* a duplicate of the</span></span><br><span class="line"><span class="comment">                                                 local communicator in</span></span><br><span class="line"><span class="comment">                                                 case the comm is an</span></span><br><span class="line"><span class="comment">                                                 inter-comm*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attributes */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">opal_hash_table_t</span>       *c_keyhash;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些应该是笛卡尔结构相关的</span></span><br><span class="line">    <span class="comment">/**&lt; inscribing cube dimension */</span></span><br><span class="line">    <span class="type">int</span> c_cube_dim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Standard information about the selected topology module (or NULL</span></span><br><span class="line"><span class="comment">       if this is not a cart, graph or dist graph communicator) */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mca_topo_base_module_t</span>* c_topo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* index in Fortran &lt;-&gt; C translation array */</span></span><br><span class="line">    <span class="type">int</span> c_f_to_c_index;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> OMPI_WANT_PERUSE</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Place holder for the PERUSE events.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ompi_peruse_handle_t</span>** c_peruse_handles;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Error handling.  This field does not have the &quot;c_&quot; prefix so</span></span><br><span class="line"><span class="comment">       that the OMPI_ERRHDL_* macros can find it, regardless of whether</span></span><br><span class="line"><span class="comment">       it&#x27;s a comm, window, or file. */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ompi_errhandler_t</span>                  *error_handler;</span><br><span class="line">    <span class="type">ompi_errhandler_type_t</span>             errhandler_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hooks for PML to hang things */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mca_pml_comm_t</span>  *c_pml_comm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hooks for MTL to hang things */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mca_mtl_comm_t</span>  *c_mtl_comm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Collectives module interface and data */</span></span><br><span class="line">    <span class="type">mca_coll_base_comm_coll_t</span> *c_coll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Non-blocking collective tag. These tags might be shared between</span></span><br><span class="line"><span class="comment">     * all non-blocking collective modules (to avoid message collision</span></span><br><span class="line"><span class="comment">     * between them in the case where multiple outstanding non-blocking</span></span><br><span class="line"><span class="comment">     * collective coexists using multiple backends).</span></span><br><span class="line"><span class="comment">     * 非阻塞的集合通信</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">opal_atomic_int32_t</span> c_nbc_tag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* instance that this comm belongs to */</span></span><br><span class="line">    <span class="type">ompi_instance_t</span>* instance;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_ENABLE_FT_MPI</span></span><br><span class="line">    <span class="comment">/** MPI_ANY_SOURCE Failed Group Offset - OMPI_Comm_failure_get_acked */</span></span><br><span class="line">    <span class="type">int</span>                      any_source_offset;</span><br><span class="line">    <span class="comment">/** agreement caching info for topology and previous returned decisions */</span></span><br><span class="line">    <span class="type">opal_object_t</span>           *agreement_specific;</span><br><span class="line">    <span class="comment">/** Are MPI_ANY_SOURCE operations enabled? - OMPI_Comm_failure_ack */</span></span><br><span class="line">    <span class="type">bool</span>                     any_source_enabled;</span><br><span class="line">    <span class="comment">/** Has this communicator been revoked - OMPI_Comm_revoke() */</span></span><br><span class="line">    <span class="type">bool</span>                     comm_revoked;</span><br><span class="line">    <span class="comment">/** Force errors to collective pt2pt operations? */</span></span><br><span class="line">    <span class="type">bool</span>                     coll_revoked;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* OPAL_ENABLE_FT_MPI */</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ompi_communicator_t</span> <span class="type">ompi_communicator_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>保存属于这个通信组的进程，有四种方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Group structure</span></span><br><span class="line"><span class="comment"> * Currently we have four formats for storing the process pointers that are members</span></span><br><span class="line"><span class="comment"> * of the group.</span></span><br><span class="line"><span class="comment"> * PList: a dense format that stores all the process pointers of the group.</span></span><br><span class="line"><span class="comment"> * Sporadic: a sparse format that stores the ranges of the ranks from the parent group,</span></span><br><span class="line"><span class="comment"> *           that are included in the current group.</span></span><br><span class="line"><span class="comment"> * Strided: a sparse format that stores three integers that describe a red-black pattern</span></span><br><span class="line"><span class="comment"> *          that the current group is formed from its parent group.</span></span><br><span class="line"><span class="comment"> * Bitmap: a sparse format that maintains a bitmap of the included processes from the</span></span><br><span class="line"><span class="comment"> *         parent group. For each process that is included from the parent group</span></span><br><span class="line"><span class="comment"> *         its corresponding rank is set in the bitmap array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ompi_group_t</span> &#123;</span><br><span class="line">    <span class="type">opal_object_t</span> super;    <span class="comment">/**&lt; base class */</span></span><br><span class="line">    <span class="type">int</span> grp_proc_count;     <span class="comment">/**&lt; number of processes in group */</span></span><br><span class="line">    <span class="type">int</span> grp_my_rank;        <span class="comment">/**&lt; rank in group */</span></span><br><span class="line">    <span class="type">int</span> grp_f_to_c_index;   <span class="comment">/**&lt; index in Fortran &lt;-&gt; C translation array */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ompi_proc_t</span> **grp_proc_pointers;</span><br><span class="line">                            <span class="comment">/**&lt; list of pointers to ompi_proc_t structures</span></span><br><span class="line"><span class="comment">                                 for each process in the group */</span></span><br><span class="line">    <span class="type">uint32_t</span> grp_flags;     <span class="comment">/**&lt; flags, e.g. freed, cannot be freed etc.*/</span></span><br><span class="line">    <span class="comment">/** pointer to the original group when using sparse storage */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ompi_group_t</span> *grp_parent_group_ptr;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">ompi_group_sporadic_data_t</span> grp_sporadic;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">ompi_group_strided_data_t</span>  grp_strided;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">ompi_group_bitmap_data_t</span>   grp_bitmap;</span><br><span class="line">    &#125; sparse_data;</span><br><span class="line"></span><br><span class="line">    <span class="type">ompi_instance_t</span> *grp_instance; <span class="comment">/**&lt; instance this group was allocated within */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="MPI-Abort"><a href="#MPI-Abort" class="headerlink" title="MPI_Abort"></a>MPI_Abort</h1><p><code>MPI_Abort</code>主要是打印错误信息后等待退出所有进程<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">ompi_mpi_abort</span><span class="params">(<span class="keyword">struct</span> <span class="type">ompi_communicator_t</span>* comm,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">int</span> errcode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *host;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protection for recursive invocation */</span></span><br><span class="line">    <span class="keyword">if</span> (have_been_invoked) &#123;</span><br><span class="line">        <span class="keyword">return</span> OMPI_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    have_been_invoked = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If MPI is initialized, we know we have a runtime nodename, so</span></span><br><span class="line"><span class="comment">       use that.  Otherwise, call opal_gethostname. */</span></span><br><span class="line">    <span class="keyword">if</span> (ompi_rte_initialized) &#123;</span><br><span class="line">        host = ompi_process_info.nodename;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        host = <span class="built_in">opal_gethostname</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    pid = <span class="built_in">getpid</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Should we print a stack trace?  Not aggregated because they</span></span><br><span class="line"><span class="comment">       might be different on all processes. */</span></span><br><span class="line">    <span class="keyword">if</span> (opal_abort_print_stack) &#123;</span><br><span class="line">        <span class="type">char</span> **messages;</span><br><span class="line">        <span class="type">int</span> len, i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (OPAL_SUCCESS == <span class="built_in">opal_backtrace_buffer</span>(&amp;messages, &amp;len)) &#123;</span><br><span class="line">            <span class="comment">// 调用了linux内部的backtrace函数打印调用栈，需要#include &lt;execinfo.h&gt;</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[%s:%05d] [%d] func:%s\n&quot;</span>, host, (<span class="type">int</span>) pid,</span><br><span class="line">                        i, messages[i]);</span><br><span class="line">                <span class="built_in">fflush</span>(stderr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(messages);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* This will print an message if it&#x27;s unable to print the</span></span><br><span class="line"><span class="comment">               backtrace, so we don&#x27;t need an additional &quot;else&quot; clause</span></span><br><span class="line"><span class="comment">               if opal_backtrace_print() is not supported. */</span></span><br><span class="line">            <span class="built_in">opal_backtrace_print</span>(stderr, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for a while before aborting */</span></span><br><span class="line">    <span class="built_in">opal_delay_abort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the RTE isn&#x27;t setup yet/any more, then don&#x27;t even try</span></span><br><span class="line"><span class="comment">       killing everyone.  Sorry, Charlie... */</span></span><br><span class="line">    <span class="type">int32_t</span> state = ompi_mpi_state;</span><br><span class="line">    <span class="keyword">if</span> (!ompi_rte_initialized) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[%s:%05d] Local abort %s completed successfully, but am not able to aggregate error messages, and not able to guarantee that all other processes were killed!\n&quot;</span>,</span><br><span class="line">                host, (<span class="type">int</span>) pid,</span><br><span class="line">                state &gt;= OMPI_MPI_STATE_FINALIZE_STARTED ?</span><br><span class="line">                <span class="string">&quot;after MPI_FINALIZE started&quot;</span> : <span class="string">&quot;before MPI_INIT completed&quot;</span>);</span><br><span class="line">        _exit(errcode == <span class="number">0</span> ? <span class="number">1</span> : errcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If OMPI is initialized and we have a non-NULL communicator,</span></span><br><span class="line"><span class="comment">       then try to kill just that set of processes */</span></span><br><span class="line">    <span class="keyword">if</span> (state &gt;= OMPI_MPI_STATE_INIT_COMPLETED &amp;&amp;</span><br><span class="line">        state &lt; OMPI_MPI_STATE_FINALIZE_PAST_COMM_SELF_DESTRUCT &amp;&amp;</span><br><span class="line">        <span class="literal">NULL</span> != comm) &#123;</span><br><span class="line">        <span class="built_in">try_kill_peers</span>(comm, errcode); <span class="comment">/* kill only the specified groups, no return if it worked. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We can fall through to here in a few cases:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       1. The attempt to kill just a subset of peers via</span></span><br><span class="line"><span class="comment">          try_kill_peers() failed.</span></span><br><span class="line"><span class="comment">       2. MPI wasn&#x27;t initialized, was already finalized, or we got a</span></span><br><span class="line"><span class="comment">          NULL communicator.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In all of these cases, the only sensible thing left to do is to</span></span><br><span class="line"><span class="comment">       kill the entire job.  Wah wah. */</span></span><br><span class="line">    <span class="built_in">ompi_rte_abort</span>(errcode, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Does not return - but we add a return to keep compiler warnings at bay*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="MPI-Barrier"><a href="#MPI-Barrier" class="headerlink" title="MPI_Barrier"></a>MPI_Barrier</h1><p><code>MPI_Barrier</code>主要是检查参数之后调用<code>coll_barrier</code>。在两个进程的特例中，只有一个send-recv。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Barrier</span><span class="params">(MPI_Comm comm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> err = MPI_SUCCESS;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SPC_RECORD</span>(OMPI_SPC_BARRIER, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">MEMCHECKER</span>(</span><br><span class="line">    <span class="built_in">memchecker_comm</span>(comm);</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Error checking */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (MPI_PARAM_CHECK) &#123;</span><br><span class="line">    <span class="built_in">OMPI_ERR_INIT_FINALIZE</span>(FUNC_NAME);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ompi_comm_invalid</span>(comm)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">OMPI_ERRHANDLER_NOHANDLE_INVOKE</span>(MPI_ERR_COMM, FUNC_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Intracommunicators: Only invoke the back-end coll module barrier</span></span><br><span class="line"><span class="comment">     function if there&#x27;s more than one process in the communicator */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">OMPI_COMM_IS_INTRA</span>(comm)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ompi_comm_size</span>(comm) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      err = comm-&gt;c_coll-&gt;<span class="built_in">coll_barrier</span>(comm, comm-&gt;c_coll-&gt;coll_barrier_module);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Intercommunicators -- always invoke, because, by definition,</span></span><br><span class="line"><span class="comment">     there&#x27;s always at least 2 processes in an intercommunicator. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      err = comm-&gt;c_coll-&gt;<span class="built_in">coll_barrier</span>(comm, comm-&gt;c_coll-&gt;coll_barrier_module);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* All done */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">OMPI_ERRHANDLER_RETURN</span>(err, comm, err, FUNC_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>coll_barrier</code>应该是函数指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="type">mca_coll_base_module_barrier_fn_t</span>)</span></span></span><br><span class="line"><span class="function">  <span class="params">(<span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm, <span class="keyword">struct</span> <span class="type">mca_coll_base_module_2_4_0_t</span> *<span class="keyword">module</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>函数指针可能的值有：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mca_coll_basic_barrier_inter_lin</span><br><span class="line">ompi_coll_base_barrier_intra_basic_linear</span><br><span class="line">mca_coll_basic_barrier_intra_log</span><br><span class="line"></span><br><span class="line">mca_scoll_basic_barrier</span><br><span class="line">mca_scoll_mpi_barrier</span><br><span class="line">scoll_null_barrier</span><br></pre></td></tr></table></figure></p>
<p>前三个是O(log(N))的，以<code>mca_coll_basic_barrier_intra_log</code>为例。这应该是将进程组织成树的形式，以位运算隐掉某一位来计算孩子进程号，通过send/recv空消息实现barrier。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">mca_coll_basic_barrier_intra_log</span><span class="params">(<span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">int</span> peer;</span><br><span class="line">    <span class="type">int</span> dim;</span><br><span class="line">    <span class="type">int</span> hibit;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    <span class="type">int</span> rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send null-messages up and down the tree.  Synchronization at the</span></span><br><span class="line"><span class="comment">     * root (rank 0). */</span></span><br><span class="line"></span><br><span class="line">    dim = comm-&gt;c_cube_dim;</span><br><span class="line">    hibit = <span class="built_in">opal_hibit</span>(rank, dim);</span><br><span class="line">    --dim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Receive from children. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = dim, mask = <span class="number">1</span> &lt;&lt; i; i &gt; hibit; --i, mask &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        peer = rank | mask;</span><br><span class="line">        <span class="keyword">if</span> (peer &lt; size) &#123;</span><br><span class="line">            err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>(<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, peer,</span><br><span class="line">                                    MCA_COLL_BASE_TAG_BARRIER,</span><br><span class="line">                                    comm, MPI_STATUS_IGNORE));</span><br><span class="line">            <span class="keyword">if</span> (MPI_SUCCESS != err) &#123;</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// children就是比我大的或者等于我的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send to and receive from parent. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        peer = rank &amp; ~(<span class="number">1</span> &lt;&lt; hibit);</span><br><span class="line">        err =</span><br><span class="line">            <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span></span><br><span class="line">                         (<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, peer,</span><br><span class="line">                          MCA_COLL_BASE_TAG_BARRIER,</span><br><span class="line">                          MCA_PML_BASE_SEND_STANDARD, comm));</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>(<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, peer,</span><br><span class="line">                                MCA_COLL_BASE_TAG_BARRIER,</span><br><span class="line">                                comm, MPI_STATUS_IGNORE));</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// parent就是比自己小的，所以要把某一位变成0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send to children. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = hibit + <span class="number">1</span>, mask = <span class="number">1</span> &lt;&lt; i; i &lt;= dim; ++i, mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        peer = rank | mask;</span><br><span class="line">        <span class="keyword">if</span> (peer &lt; size) &#123;</span><br><span class="line">            err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span>(<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, peer,</span><br><span class="line">                                    MCA_COLL_BASE_TAG_BARRIER,</span><br><span class="line">                                    MCA_PML_BASE_SEND_STANDARD, comm));</span><br><span class="line">            <span class="keyword">if</span> (MPI_SUCCESS != err) &#123;</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All done */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个直接是调用的allreduce，可省事了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	barrier_inter_lin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Function:	- barrier using O(log(N)) algorithm</span></span><br><span class="line"><span class="comment"> *	Accepts:	- same as MPI_Barrier()</span></span><br><span class="line"><span class="comment"> *	Returns:	- MPI_SUCCESS or error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">mca_coll_basic_barrier_inter_lin</span><span class="params">(<span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rank;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line">    <span class="keyword">return</span> comm-&gt;c_coll-&gt;<span class="built_in">coll_allreduce</span>(&amp;rank, &amp;result, <span class="number">1</span>, MPI_INT, MPI_MAX,</span><br><span class="line">                                       comm, comm-&gt;c_coll-&gt;coll_allreduce_module);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><code>ompi_coll_base_barrier_intra_basic_linear</code>函数是从 BASIC coll 模块复制的，它不分割消息并且是简单的实现，但是对于一些少量节点和/或小数据大小，它们与基于树的分割操作一样快，因此可以选择这个。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_base_barrier_intra_basic_linear</span><span class="params">(<span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, err, rank, size, line;</span><br><span class="line">    <span class="type">ompi_request_t</span>** requests = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">1</span> == size )</span><br><span class="line">        <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">    rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All non-root send &amp; receive zero-length message to root. */</span></span><br><span class="line">    <span class="keyword">if</span> (rank &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span> (<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, <span class="number">0</span>,</span><br><span class="line">                                 MCA_COLL_BASE_TAG_BARRIER,</span><br><span class="line">                                 MCA_PML_BASE_SEND_STANDARD, comm));</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span> (<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, <span class="number">0</span>,</span><br><span class="line">                                 MCA_COLL_BASE_TAG_BARRIER,</span><br><span class="line">                                 comm, MPI_STATUS_IGNORE));</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The root collects and broadcasts the messages from all other process. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        requests = <span class="built_in">ompi_coll_base_comm_get_reqs</span>(<span class="keyword">module</span>-&gt;base_data, size);</span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">NULL</span> == requests ) &#123; err = OMPI_ERR_OUT_OF_RESOURCE; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">irecv</span>(<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, MPI_ANY_SOURCE,</span><br><span class="line">                                     MCA_COLL_BASE_TAG_BARRIER, comm,</span><br><span class="line">                                     &amp;(requests[i])));</span><br><span class="line">            <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        err = <span class="built_in">ompi_request_wait_all</span>( size<span class="number">-1</span>, requests+<span class="number">1</span>, MPI_STATUSES_IGNORE );</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line">        requests = <span class="literal">NULL</span>;  <span class="comment">/* we&#x27;re done the requests array is clean */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span>(<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, i,</span><br><span class="line">                                    MCA_COLL_BASE_TAG_BARRIER,</span><br><span class="line">                                    MCA_PML_BASE_SEND_STANDARD, comm));</span><br><span class="line">            <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All done */</span></span><br><span class="line">    <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>double ring方法在很多MPI算法里都有，barrier里也有double ring的实现。向左右的进程发送和接收数据。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_base_barrier_intra_doublering</span><span class="params">(<span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rank, size, err = <span class="number">0</span>, line = <span class="number">0</span>, left, right;</span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">1</span> == size )</span><br><span class="line">        <span class="keyword">return</span> OMPI_SUCCESS;</span><br><span class="line">    rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OPAL_OUTPUT</span>((ompi_coll_base_framework.framework_output,<span class="string">&quot;ompi_coll_base_barrier_intra_doublering rank %d&quot;</span>, rank));</span><br><span class="line"></span><br><span class="line">    left = ((size+rank<span class="number">-1</span>)%size);</span><br><span class="line">    right = ((rank+<span class="number">1</span>)%size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank &gt; <span class="number">0</span>) <span class="comment">/* receive message from the left */</span></span><br><span class="line">        err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>((<span class="type">void</span>*)<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, left, MCA_COLL_BASE_TAG_BARRIER, comm, MPI_STATUS_IGNORE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send message to the right */</span></span><br><span class="line">    err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span>((<span class="type">void</span>*)<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, right, MCA_COLL_BASE_TAG_BARRIER, MCA_PML_BASE_SEND_STANDARD, comm));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* root needs to receive from the last node */</span></span><br><span class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>)</span><br><span class="line">        err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>((<span class="type">void</span>*)<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, left, MCA_COLL_BASE_TAG_BARRIER, comm, MPI_STATUS_IGNORE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allow nodes to exit */</span></span><br><span class="line">    <span class="keyword">if</span> (rank &gt; <span class="number">0</span>) <span class="comment">/* post Receive from left */</span></span><br><span class="line">        err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>((<span class="type">void</span>*)<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, left, MCA_COLL_BASE_TAG_BARRIER, comm, MPI_STATUS_IGNORE));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* send message to the right one */</span></span><br><span class="line">    err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span>((<span class="type">void</span>*)<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, right, MCA_COLL_BASE_TAG_BARRIER, MCA_PML_BASE_SEND_SYNCHRONOUS, comm));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* rank 0 post receive from the last node */</span></span><br><span class="line">    <span class="keyword">if</span> (rank == <span class="number">0</span>)</span><br><span class="line">        err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>((<span class="type">void</span>*)<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, left, MCA_COLL_BASE_TAG_BARRIER, comm, MPI_STATUS_IGNORE));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有一种先是把进程数调整到2的n次方，对于多余的进程先进行一次同步，再在进程之间两两交换通信，同样是根据位运算来的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * To make synchronous, uses sync sends and sync sendrecvs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_base_barrier_intra_recursivedoubling</span><span class="params">(<span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rank, size, adjsize, err, line, mask, remote;</span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">1</span> == size )</span><br><span class="line">        <span class="keyword">return</span> OMPI_SUCCESS;</span><br><span class="line">    rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line">    <span class="built_in">OPAL_OUTPUT</span>((ompi_coll_base_framework.framework_output,</span><br><span class="line">                 <span class="string">&quot;ompi_coll_base_barrier_intra_recursivedoubling rank %d&quot;</span>,</span><br><span class="line">                 rank));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nearest power of 2 less than size calc */</span></span><br><span class="line">    adjsize = <span class="built_in">opal_next_poweroftwo</span>(size);</span><br><span class="line">    adjsize &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if size is not exact power of two, perform an extra step */</span></span><br><span class="line">    <span class="keyword">if</span> (adjsize != size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rank &gt;= adjsize) &#123;</span><br><span class="line">            <span class="comment">/* send message to lower ranked node */</span></span><br><span class="line">            remote = rank - adjsize;</span><br><span class="line">            err = <span class="built_in">ompi_coll_base_sendrecv_zero</span>(remote, MCA_COLL_BASE_TAG_BARRIER,</span><br><span class="line">                                               remote, MCA_COLL_BASE_TAG_BARRIER,</span><br><span class="line">                                               comm);</span><br><span class="line">            <span class="keyword">if</span> (err != MPI_SUCCESS) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl;&#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank &lt; (size - adjsize)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* receive message from high level rank */</span></span><br><span class="line">            err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>((<span class="type">void</span>*)<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, rank+adjsize,</span><br><span class="line">                                    MCA_COLL_BASE_TAG_BARRIER, comm,</span><br><span class="line">                                    MPI_STATUS_IGNORE));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (err != MPI_SUCCESS) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* exchange messages */</span></span><br><span class="line">    <span class="keyword">if</span> ( rank &lt; adjsize ) &#123;</span><br><span class="line">        mask = <span class="number">0x1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( mask &lt; adjsize ) &#123;</span><br><span class="line">            remote = rank ^ mask;</span><br><span class="line">            mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (remote &gt;= adjsize) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* post receive from the remote node */</span></span><br><span class="line">            err = <span class="built_in">ompi_coll_base_sendrecv_zero</span>(remote, MCA_COLL_BASE_TAG_BARRIER,</span><br><span class="line">                                               remote, MCA_COLL_BASE_TAG_BARRIER,</span><br><span class="line">                                               comm);</span><br><span class="line">            <span class="keyword">if</span> (err != MPI_SUCCESS) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* non-power of 2 case */</span></span><br><span class="line">    <span class="keyword">if</span> (adjsize != size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rank &lt; (size - adjsize)) &#123;</span><br><span class="line">            <span class="comment">/* send enter message to higher ranked node */</span></span><br><span class="line">            remote = rank + adjsize;</span><br><span class="line">            err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span>((<span class="type">void</span>*)<span class="literal">NULL</span>, <span class="number">0</span>, MPI_BYTE, remote,</span><br><span class="line">                                    MCA_COLL_BASE_TAG_BARRIER,</span><br><span class="line">                                    MCA_PML_BASE_SEND_SYNCHRONOUS, comm));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (err != MPI_SUCCESS) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在不同间隔的进程之间进行交换，真的能实现barrier。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_base_barrier_intra_bruck</span><span class="params">(<span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rank, size, distance, to, from, err, line = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">1</span> == size )</span><br><span class="line">        <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">    rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line">    <span class="built_in">OPAL_OUTPUT</span>((ompi_coll_base_framework.framework_output,</span><br><span class="line">                 <span class="string">&quot;ompi_coll_base_barrier_intra_bruck rank %d&quot;</span>, rank));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* exchange data with rank-2^k and rank+2^k */</span></span><br><span class="line">    <span class="keyword">for</span> (distance = <span class="number">1</span>; distance &lt; size; distance &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        from = (rank + size - distance) % size;</span><br><span class="line">        to   = (rank + distance) % size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* send message to lower ranked node */</span></span><br><span class="line">        err = <span class="built_in">ompi_coll_base_sendrecv_zero</span>(to, MCA_COLL_BASE_TAG_BARRIER,</span><br><span class="line">                                           from, MCA_COLL_BASE_TAG_BARRIER,</span><br><span class="line">                                           comm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="MPI-Bcast"><a href="#MPI-Bcast" class="headerlink" title="MPI_Bcast"></a>MPI_Bcast</h1><p>bcast首先检查内存区是否不是空，再调用<code>coll_bcast</code>，同样是函数指针。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Bcast</span><span class="params">(<span class="type">void</span> *buffer, <span class="type">int</span> count, MPI_Datatype datatype,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">int</span> root, MPI_Comm comm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* .... 主要是检查通信域和buffer是否合法，略*/</span></span><br><span class="line">    err = comm-&gt;c_coll-&gt;<span class="built_in">coll_bcast</span>(buffer, count, datatype, root, comm,</span><br><span class="line">                                  comm-&gt;c_coll-&gt;coll_bcast_module);</span><br><span class="line">    <span class="built_in">OMPI_ERRHANDLER_RETURN</span>(err, comm, err, FUNC_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="type">mca_coll_base_module_bcast_init_fn_t</span>)</span></span></span><br><span class="line"><span class="function">  <span class="params">(<span class="type">void</span> *buff, </span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">int</span> count, </span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *datatype, </span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">int</span> root,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm, </span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">struct</span> <span class="type">ompi_info_t</span> *info, </span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">ompi_request_t</span> ** request,</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="keyword">struct</span> <span class="type">mca_coll_base_module_2_4_0_t</span> *<span class="keyword">module</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>bcast主要以下几种：bcast相关的算法应该有：0: tuned, 1: binomial, 2: in_order_binomial, 3: binary, 4: pipeline, 5: chain, 6: linear<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_adapt_bcast</span><span class="params">(BCAST_ARGS)</span></span>;</span><br><span class="line">调用</span><br><span class="line"><span class="type">int</span> ompi_coll_adapt_ibcast</span><br><span class="line">调用</span><br><span class="line"><span class="type">int</span> ompi_coll_adapt_ibcast_generic</span><br></pre></td></tr></table></figure></p>
<p><code>ompi_coll_adapt_ibcast_generic</code>是底层的调用，首先创建temp_request，标明source，tag等。计算要bcast的数据的segment数，有个宏提供了一种计算段的最佳计数的通用方法（即可以适合指定 SEGSIZE 的完整数据类型的数量）。并在堆上给分配空间，以便其他函数访问。如果是根进程，则向所有子进程发送，否则向根进程接收。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_adapt_ibcast_generic</span><span class="params">(<span class="type">void</span> *buff, <span class="type">int</span> count, <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *datatype, <span class="type">int</span> root,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm, <span class="type">ompi_request_t</span> ** request,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">mca_coll_base_module_t</span> * <span class="keyword">module</span>, <span class="type">ompi_coll_tree_t</span> * tree,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">size_t</span> seg_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, rank, err;</span><br><span class="line">    <span class="comment">/* The min of num_segs and SEND_NUM or RECV_NUM, in case the num_segs is less than SEND_NUM or RECV_NUM */</span></span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of datatype in a segment */</span></span><br><span class="line">    <span class="type">int</span> seg_count = count;</span><br><span class="line">    <span class="comment">/* Size of a datatype */</span></span><br><span class="line">    <span class="type">size_t</span> type_size;</span><br><span class="line">    <span class="comment">/* Real size of a segment */</span></span><br><span class="line">    <span class="type">size_t</span> real_seg_size;</span><br><span class="line">    <span class="type">ptrdiff_t</span> extent, lb;</span><br><span class="line">    <span class="comment">/* Number of segments */</span></span><br><span class="line">    <span class="type">int</span> num_segs;</span><br><span class="line"></span><br><span class="line">    <span class="type">mca_pml_base_send_mode_t</span> sendmode = (mca_coll_adapt_component.adapt_ibcast_synchronous_send)</span><br><span class="line">                                        ? MCA_PML_BASE_SEND_SYNCHRONOUS : MCA_PML_BASE_SEND_STANDARD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The request passed outside */</span></span><br><span class="line">    <span class="type">ompi_coll_base_nbc_request_t</span> *temp_request = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">opal_mutex_t</span> *mutex;</span><br><span class="line">    <span class="comment">/* Store the segments which are received */</span></span><br><span class="line">    <span class="type">int</span> *recv_array = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* Record how many isends have been issued for every child */</span></span><br><span class="line">    <span class="type">int</span> *send_array = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically set up free list */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == mca_coll_adapt_component.adapt_ibcast_context_free_list) &#123;</span><br><span class="line">        <span class="type">opal_free_list_t</span>* fl = <span class="built_in">OBJ_NEW</span>(<span class="type">opal_free_list_t</span>);</span><br><span class="line">        <span class="built_in">opal_free_list_init</span>(fl,</span><br><span class="line">                            <span class="built_in">sizeof</span>(<span class="type">ompi_coll_adapt_bcast_context_t</span>),</span><br><span class="line">                            opal_cache_line_size,</span><br><span class="line">                            <span class="built_in">OBJ_CLASS</span>(<span class="type">ompi_coll_adapt_bcast_context_t</span>),</span><br><span class="line">                            <span class="number">0</span>, opal_cache_line_size,</span><br><span class="line">                            mca_coll_adapt_component.adapt_context_free_list_min,</span><br><span class="line">                            mca_coll_adapt_component.adapt_context_free_list_max,</span><br><span class="line">                            mca_coll_adapt_component.adapt_context_free_list_inc,</span><br><span class="line">                            <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>( !<span class="built_in">OPAL_ATOMIC_COMPARE_EXCHANGE_STRONG_PTR</span>((<span class="type">opal_atomic_intptr_t</span> *)&amp;mca_coll_adapt_component.adapt_ibcast_context_free_list,</span><br><span class="line">                                                     &amp;(<span class="type">intptr_t</span>)&#123;<span class="number">0</span>&#125;, fl) ) &#123;</span><br><span class="line">            <span class="built_in">OBJ_RELEASE</span>(fl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up request */</span></span><br><span class="line">    temp_request = <span class="built_in">OBJ_NEW</span>(<span class="type">ompi_coll_base_nbc_request_t</span>);</span><br><span class="line">    <span class="built_in">OMPI_REQUEST_INIT</span>(&amp;temp_request-&gt;super, <span class="literal">false</span>);</span><br><span class="line">    temp_request-&gt;super.req_state = OMPI_REQUEST_ACTIVE;</span><br><span class="line">    temp_request-&gt;super.req_type = OMPI_REQUEST_COLL;</span><br><span class="line">    temp_request-&gt;super.req_free = ompi_coll_adapt_request_free;</span><br><span class="line">    temp_request-&gt;super.req_status.MPI_SOURCE = <span class="number">0</span>;</span><br><span class="line">    temp_request-&gt;super.req_status.MPI_TAG = <span class="number">0</span>;</span><br><span class="line">    temp_request-&gt;super.req_status.MPI_ERROR = <span class="number">0</span>;</span><br><span class="line">    temp_request-&gt;super.req_status._cancelled = <span class="number">0</span>;</span><br><span class="line">    temp_request-&gt;super.req_status._ucount = <span class="number">0</span>;</span><br><span class="line">    *request = (<span class="type">ompi_request_t</span>*)temp_request;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up mutex */</span></span><br><span class="line">    mutex = <span class="built_in">OBJ_NEW</span>(<span class="type">opal_mutex_t</span>);</span><br><span class="line"></span><br><span class="line">    rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Determine number of elements sent per operation */</span></span><br><span class="line">    <span class="built_in">ompi_datatype_type_size</span>(datatype, &amp;type_size);</span><br><span class="line">    <span class="built_in">COLL_BASE_COMPUTED_SEGCOUNT</span>(seg_size, type_size, seg_count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ompi_datatype_get_extent</span>(datatype, &amp;lb, &amp;extent);</span><br><span class="line">    num_segs = (count + seg_count - <span class="number">1</span>) / seg_count;</span><br><span class="line">    real_seg_size = (<span class="type">ptrdiff_t</span>) seg_count *extent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set memory for recv_array and send_array, created on heap becasue they are needed to be accessed by other functions (callback functions) */</span></span><br><span class="line">    <span class="keyword">if</span> (num_segs != <span class="number">0</span>) &#123;</span><br><span class="line">        recv_array = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * num_segs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;tree_nextsize != <span class="number">0</span>) &#123;</span><br><span class="line">        send_array = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * tree-&gt;tree_nextsize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set constant context for send and recv call back */</span></span><br><span class="line">    <span class="type">ompi_coll_adapt_constant_bcast_context_t</span> *con = <span class="built_in">OBJ_NEW</span>(<span class="type">ompi_coll_adapt_constant_bcast_context_t</span>);</span><br><span class="line">    con-&gt;root = root;</span><br><span class="line">    con-&gt;count = count;</span><br><span class="line">    con-&gt;seg_count = seg_count;</span><br><span class="line">    con-&gt;datatype = datatype;</span><br><span class="line">    con-&gt;comm = comm;</span><br><span class="line">    con-&gt;real_seg_size = real_seg_size;</span><br><span class="line">    con-&gt;num_segs = num_segs;</span><br><span class="line">    con-&gt;recv_array = recv_array;</span><br><span class="line">    con-&gt;num_recv_segs = <span class="number">0</span>;</span><br><span class="line">    con-&gt;num_recv_fini = <span class="number">0</span>;</span><br><span class="line">    con-&gt;send_array = send_array;</span><br><span class="line">    con-&gt;num_sent_segs = <span class="number">0</span>;</span><br><span class="line">    con-&gt;mutex = mutex;</span><br><span class="line">    con-&gt;request = (<span class="type">ompi_request_t</span>*)temp_request;</span><br><span class="line">    con-&gt;tree = tree;</span><br><span class="line">    con-&gt;ibcast_tag = <span class="built_in">ompi_coll_base_nbc_reserve_tags</span>(comm, num_segs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OPAL_OUTPUT_VERBOSE</span>((<span class="number">30</span>, mca_coll_adapt_component.adapt_output,</span><br><span class="line">                         <span class="string">&quot;[%d]: Ibcast, root %d, tag %d\n&quot;</span>, rank, root,</span><br><span class="line">                         con-&gt;ibcast_tag));</span><br><span class="line">    <span class="built_in">OPAL_OUTPUT_VERBOSE</span>((<span class="number">30</span>, mca_coll_adapt_component.adapt_output,</span><br><span class="line">                         <span class="string">&quot;[%d]: con-&gt;mutex = %p, num_children = %d, num_segs = %d, real_seg_size = %d, seg_count = %d, tree_adreess = %p\n&quot;</span>,</span><br><span class="line">                         rank, (<span class="type">void</span> *) con-&gt;mutex, tree-&gt;tree_nextsize, num_segs,</span><br><span class="line">                         (<span class="type">int</span>) real_seg_size, seg_count, (<span class="type">void</span> *) con-&gt;tree));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OPAL_THREAD_LOCK</span>(mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the current process is root, it sends segment to every children */</span></span><br><span class="line">    <span class="keyword">if</span> (rank == root) &#123;</span><br><span class="line">        <span class="comment">/* Handle the situation when num_segs &lt; SEND_NUM */</span></span><br><span class="line">        <span class="keyword">if</span> (num_segs &lt;= mca_coll_adapt_component.adapt_ibcast_max_send_requests) &#123;</span><br><span class="line">            min = num_segs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min = mca_coll_adapt_component.adapt_ibcast_max_send_requests;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set recv_array, root has already had all the segments */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_segs; i++) &#123;</span><br><span class="line">            recv_array[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        con-&gt;num_recv_segs = num_segs;</span><br><span class="line">        <span class="comment">/* Set send_array, will send ompi_coll_adapt_ibcast_max_send_requests segments */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tree-&gt;tree_nextsize; i++) &#123;</span><br><span class="line">            send_array[i] = mca_coll_adapt_component.adapt_ibcast_max_send_requests;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ompi_request_t</span> *send_req;</span><br><span class="line">        <span class="comment">/* Number of datatypes in each send */</span></span><br><span class="line">        <span class="type">int</span> send_count = seg_count;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == (num_segs - <span class="number">1</span>)) &#123;</span><br><span class="line">                send_count = count - i * seg_count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; tree-&gt;tree_nextsize; j++) &#123;</span><br><span class="line">                <span class="type">ompi_coll_adapt_bcast_context_t</span> *context =</span><br><span class="line">                    (<span class="type">ompi_coll_adapt_bcast_context_t</span> *) <span class="built_in">opal_free_list_wait</span>(mca_coll_adapt_component.</span><br><span class="line">                                                                           adapt_ibcast_context_free_list);</span><br><span class="line">                context-&gt;buff = (<span class="type">char</span> *) buff + i * real_seg_size;</span><br><span class="line">                context-&gt;frag_id = i;</span><br><span class="line">                <span class="comment">/* The id of peer in in children_list */</span></span><br><span class="line">                context-&gt;child_id = j;</span><br><span class="line">                <span class="comment">/* Actural rank of the peer */</span></span><br><span class="line">                context-&gt;peer = tree-&gt;tree_next[j];</span><br><span class="line">                context-&gt;con = con;</span><br><span class="line">                <span class="built_in">OBJ_RETAIN</span>(con);</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> *send_buff = context-&gt;buff;</span><br><span class="line">                <span class="built_in">OPAL_OUTPUT_VERBOSE</span>((<span class="number">30</span>, mca_coll_adapt_component.adapt_output,</span><br><span class="line">                                     <span class="string">&quot;[%d]: Send(start in main): segment %d to %d at buff %p send_count %d tag %d\n&quot;</span>,</span><br><span class="line">                                     rank, context-&gt;frag_id, context-&gt;peer,</span><br><span class="line">                                     (<span class="type">void</span> *) send_buff, send_count, con-&gt;ibcast_tag - i));</span><br><span class="line">                err =</span><br><span class="line">                    <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">isend</span></span><br><span class="line">                                 (send_buff, send_count, datatype, context-&gt;peer,</span><br><span class="line">                                  con-&gt;ibcast_tag - i, sendmode, comm,</span><br><span class="line">                                  &amp;send_req));</span><br><span class="line">                <span class="keyword">if</span> (MPI_SUCCESS != err) &#123;</span><br><span class="line">                    <span class="keyword">return</span> err;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* Set send callback */</span></span><br><span class="line">                <span class="built_in">OPAL_THREAD_UNLOCK</span>(mutex);</span><br><span class="line">                <span class="built_in">ompi_request_set_callback</span>(send_req, send_cb, context);</span><br><span class="line">                <span class="built_in">OPAL_THREAD_LOCK</span>(mutex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the current process is not root, it receives data from parent in the tree. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Handle the situation when num_segs &lt; RECV_NUM */</span></span><br><span class="line">        <span class="keyword">if</span> (num_segs &lt;= mca_coll_adapt_component.adapt_ibcast_max_recv_requests) &#123;</span><br><span class="line">            min = num_segs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min = mca_coll_adapt_component.adapt_ibcast_max_recv_requests;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set recv_array, recv_array is empty */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_segs; i++) &#123;</span><br><span class="line">            recv_array[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Set send_array to empty */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; tree-&gt;tree_nextsize; i++) &#123;</span><br><span class="line">            send_array[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Create a recv request */</span></span><br><span class="line">        <span class="type">ompi_request_t</span> *recv_req;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Recevice some segments from its parent */</span></span><br><span class="line">        <span class="type">int</span> recv_count = seg_count;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == (num_segs - <span class="number">1</span>)) &#123;</span><br><span class="line">                recv_count = count - i * seg_count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ompi_coll_adapt_bcast_context_t</span> *context =</span><br><span class="line">                (<span class="type">ompi_coll_adapt_bcast_context_t</span> *) <span class="built_in">opal_free_list_wait</span>(mca_coll_adapt_component.</span><br><span class="line">                                                                       adapt_ibcast_context_free_list);</span><br><span class="line">            context-&gt;buff = (<span class="type">char</span> *) buff + i * real_seg_size;</span><br><span class="line">            context-&gt;frag_id = i;</span><br><span class="line">            context-&gt;peer = tree-&gt;tree_prev;</span><br><span class="line">            context-&gt;con = con;</span><br><span class="line">            <span class="built_in">OBJ_RETAIN</span>(con);</span><br><span class="line">            <span class="type">char</span> *recv_buff = context-&gt;buff;</span><br><span class="line">            <span class="built_in">OPAL_OUTPUT_VERBOSE</span>((<span class="number">30</span>, mca_coll_adapt_component.adapt_output,</span><br><span class="line">                                 <span class="string">&quot;[%d]: Recv(start in main): segment %d from %d at buff %p recv_count %d tag %d\n&quot;</span>,</span><br><span class="line">                                 <span class="built_in">ompi_comm_rank</span>(context-&gt;con-&gt;comm), context-&gt;frag_id,</span><br><span class="line">                                 context-&gt;peer, (<span class="type">void</span> *) recv_buff, recv_count,</span><br><span class="line">                                 con-&gt;ibcast_tag - i));</span><br><span class="line">            err =</span><br><span class="line">                <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">irecv</span></span><br><span class="line">                             (recv_buff, recv_count, datatype, context-&gt;peer,</span><br><span class="line">                              con-&gt;ibcast_tag - i, comm, &amp;recv_req));</span><br><span class="line">            <span class="keyword">if</span> (MPI_SUCCESS != err) &#123;</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Set receive callback */</span></span><br><span class="line">            <span class="built_in">OPAL_THREAD_UNLOCK</span>(mutex);</span><br><span class="line">            <span class="built_in">ompi_request_set_callback</span>(recv_req, recv_cb, context);</span><br><span class="line">            <span class="built_in">OPAL_THREAD_LOCK</span>(mutex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OPAL_THREAD_UNLOCK</span>(mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OPAL_OUTPUT_VERBOSE</span>((<span class="number">30</span>, mca_coll_adapt_component.adapt_output,</span><br><span class="line">                         <span class="string">&quot;[%d]: End of Ibcast\n&quot;</span>, rank));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此外还找到了如下几个：</p>
<ul>
<li>ompi_coll_base_bcast_intra_basic_linear：root发送给所有其他进程</li>
<li>mca_coll_basic_bcast_log_intra：log复杂度的树形通信</li>
<li>ompi_coll_base_bcast_intra_generic：树形发送，根节点发送给中间节点，中间节点从根节点中接收，再发送给自己的子节点，叶子节点只负责接收</li>
<li>mca_coll_sm_bcast_intra：共享内存的bcast<ul>
<li>找到标志，memcpy，子进程感觉到完成了，再发送给子子进程</li>
<li>对于根，一般算法是等待一组段变得可用。一旦它可用，根通过将当前操作号和使用该集合的进程数写入标志来声明该集合。</li>
<li>然后根在这组段上循环；对于每个段，它将用户缓冲区的一个片段复制到共享数据段中，然后将数据大小写入其子控制缓冲区。</li>
<li>重复该过程，直到已写入所有片段。</li>
<li>对于非根，对于每组缓冲区，它们等待直到当前操作号出现在使用标志中（即，由根写入）。</li>
<li>然后对于每个段，它们等待一个非零值出现在它们的控制缓冲区中。如果他们有孩子，他们将数据从他们父母的共享数据段复制到他们的共享数据段，并将数据大小写入他们的每个孩子的控制缓冲区。</li>
<li>然后，他们将共享的数据段中的数据复制到用户的输出缓冲区中。</li>
<li>重复该过程，直到已接收到所有片段。如果他们没有孩子，他们直接将数据从父母的共享数据段复制到用户的输出缓冲区。</li>
</ul>
</li>
<li>mca_coll_sync_bcast<ul>
<li>加上了一些barrier</li>
</ul>
</li>
<li>ompi_coll_tuned_bcast_intra_dec_fixed<ul>
<li>根据消息大小，进程数选择算法执行bcast</li>
</ul>
</li>
<li>ompi_coll_base_bcast_intra_bintree：跟ompi_coll_base_bcast_intra_generic一样，树不一样</li>
<li>ompi_coll_base_bcast_intra_binomial：跟ompi_coll_base_bcast_intra_generic一样</li>
<li>ompi_coll_base_bcast_intra_knomial：树的子节点数不同，如果radix=2，子节点有1，2，4，8；radix=3，子节点有3，6，9这样。</li>
</ul>
<p>ompi_coll_base_bcast_intra_scatter_allgather：借助allgather实现bcast，例如，0和1一组，2和3一组，4和5一组，6和7一组，这样第一次就能实现每个进程里两个数据，第二次就是0，1，2，3一组，4，5，6，7一组，每个进程里4个，最后一次就每个进程里8个了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Time complexity: O(\alpha\log(p) + \beta*m((p-1)/p))</span></span><br><span class="line"><span class="comment"> *   Binomial tree scatter: \alpha\log(p) + \beta*m((p-1)/p)</span></span><br><span class="line"><span class="comment"> *   Recursive doubling allgather: \alpha\log(p) + \beta*m((p-1)/p)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example, p=8, count=8, root=0</span></span><br><span class="line"><span class="comment"> *    Binomial tree scatter      Recursive doubling allgather</span></span><br><span class="line"><span class="comment"> * 0: --+  --+  --+  [0*******]  &lt;-+ [01******]  &lt;--+   [0123****] &lt;--+</span></span><br><span class="line"><span class="comment"> * 1:   |   2|  &lt;-+  [*1******]  &lt;-+ [01******]  &lt;--|-+ [0123****] &lt;--+-+</span></span><br><span class="line"><span class="comment"> * 2:  4|  &lt;-+  --+  [**2*****]  &lt;-+ [**23****]  &lt;--+ | [0123****] &lt;--+-+-+</span></span><br><span class="line"><span class="comment"> * 3:   |       &lt;-+  [***3****]  &lt;-+ [**23****]  &lt;----+ [0123****] &lt;--+-+-+-+</span></span><br><span class="line"><span class="comment"> * 4: &lt;-+  --+  --+  [****4***]  &lt;-+ [****45**]  &lt;--+   [****4567] &lt;--+ | | |</span></span><br><span class="line"><span class="comment"> * 5:       2|  &lt;-+  [*****5**]  &lt;-+ [****45**]  &lt;--|-+ [****4567] &lt;----+ | |</span></span><br><span class="line"><span class="comment"> * 6:      &lt;-+  --+  [******6*]  &lt;-+ [******67]  &lt;--+ | [****4567] &lt;------+ |</span></span><br><span class="line"><span class="comment"> * 7:           &lt;-+  [*******7]  &lt;-+ [******67]  &lt;--|-+ [****4567] &lt;--------+</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_base_bcast_intra_scatter_allgather</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *buf, <span class="type">int</span> count, <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *datatype, <span class="type">int</span> root,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm, <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> segsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err = MPI_SUCCESS;</span><br><span class="line">    <span class="type">ptrdiff_t</span> lb, extent;</span><br><span class="line">    <span class="type">size_t</span> datatype_size;</span><br><span class="line">    MPI_Status status;</span><br><span class="line">    <span class="built_in">ompi_datatype_get_extent</span>(datatype, &amp;lb, &amp;extent);</span><br><span class="line">    <span class="built_in">ompi_datatype_type_size</span>(datatype, &amp;datatype_size);</span><br><span class="line">    <span class="type">int</span> comm_size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    <span class="type">int</span> rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> vrank = (rank - root + comm_size) % comm_size;</span><br><span class="line">    <span class="type">int</span> recv_count = <span class="number">0</span>, send_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> scatter_count = (count + comm_size - <span class="number">1</span>) / comm_size; <span class="comment">/* ceil(count / comm_size) */</span></span><br><span class="line">    <span class="type">int</span> curr_count = (rank == root) ? count : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Scatter by binomial tree: receive data from parent */</span></span><br><span class="line">    <span class="type">int</span> mask = <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">while</span> (mask &lt; comm_size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vrank &amp; mask) &#123;</span><br><span class="line">            <span class="type">int</span> parent = (rank - mask + comm_size) % comm_size;</span><br><span class="line">            <span class="comment">/* Compute an upper bound on recv block size */</span></span><br><span class="line">            recv_count = count - vrank * scatter_count;</span><br><span class="line">            <span class="keyword">if</span> (recv_count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                curr_count = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Recv data from parent */</span></span><br><span class="line">                err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>((<span class="type">char</span> *)buf + (<span class="type">ptrdiff_t</span>)vrank * scatter_count * extent,</span><br><span class="line">                                        recv_count, datatype, parent,</span><br><span class="line">                                        MCA_COLL_BASE_TAG_BCAST, comm, &amp;status));</span><br><span class="line">                <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; <span class="keyword">goto</span> cleanup_and_return; &#125;</span><br><span class="line">                <span class="comment">/* Get received count */</span></span><br><span class="line">                curr_count = (<span class="type">int</span>)(status._ucount / datatype_size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Scatter by binomial tree: send data to child processes */</span></span><br><span class="line">    mask &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (mask &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vrank + mask &lt; comm_size) &#123;</span><br><span class="line">            send_count = curr_count - scatter_count * mask;</span><br><span class="line">            <span class="keyword">if</span> (send_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> child = (rank + mask) % comm_size;</span><br><span class="line">                err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span>((<span class="type">char</span> *)buf + (<span class="type">ptrdiff_t</span>)scatter_count * (vrank + mask) * extent,</span><br><span class="line">                                        send_count, datatype, child,</span><br><span class="line">                                        MCA_COLL_BASE_TAG_BCAST,</span><br><span class="line">                                        MCA_PML_BASE_SEND_STANDARD, comm));</span><br><span class="line">                <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; <span class="keyword">goto</span> cleanup_and_return; &#125;</span><br><span class="line">                curr_count -= send_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Allgather by recursive doubling</span></span><br><span class="line"><span class="comment">     * Each process has the curr_count elems in the buf[vrank * scatter_count, ...]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> rem_count = count - vrank * scatter_count;</span><br><span class="line">    curr_count = (scatter_count &lt; rem_count) ? scatter_count : rem_count;</span><br><span class="line">    <span class="keyword">if</span> (curr_count &lt; <span class="number">0</span>)</span><br><span class="line">        curr_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mask = <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">while</span> (mask &lt; comm_size) &#123;</span><br><span class="line">        <span class="type">int</span> vremote = vrank ^ mask;</span><br><span class="line">        <span class="type">int</span> remote = (vremote + root) % comm_size;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> vrank_tree_root = <span class="built_in">ompi_rounddown</span>(vrank, mask);</span><br><span class="line">        <span class="type">int</span> vremote_tree_root = <span class="built_in">ompi_rounddown</span>(vremote, mask);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vremote &lt; comm_size) &#123;</span><br><span class="line">            <span class="type">ptrdiff_t</span> send_offset = vrank_tree_root * scatter_count * extent;</span><br><span class="line">            <span class="type">ptrdiff_t</span> recv_offset = vremote_tree_root * scatter_count * extent;</span><br><span class="line">            recv_count = count - vremote_tree_root * scatter_count;</span><br><span class="line">            <span class="keyword">if</span> (recv_count &lt; <span class="number">0</span>)</span><br><span class="line">                recv_count = <span class="number">0</span>;</span><br><span class="line">            err = <span class="built_in">ompi_coll_base_sendrecv</span>((<span class="type">char</span> *)buf + send_offset,</span><br><span class="line">                                          curr_count, datatype, remote,</span><br><span class="line">                                          MCA_COLL_BASE_TAG_BCAST,</span><br><span class="line">                                          (<span class="type">char</span> *)buf + recv_offset,</span><br><span class="line">                                          recv_count, datatype, remote,</span><br><span class="line">                                          MCA_COLL_BASE_TAG_BCAST,</span><br><span class="line">                                          comm, &amp;status, rank);</span><br><span class="line">            <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; <span class="keyword">goto</span> cleanup_and_return; &#125;</span><br><span class="line">            recv_count = (<span class="type">int</span>)(status._ucount / datatype_size);</span><br><span class="line">            curr_count += recv_count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Non-power-of-two case: if process did not have destination process</span></span><br><span class="line"><span class="comment">         * to communicate with, we need to send him the current result.</span></span><br><span class="line"><span class="comment">         * Recursive halving algorithm is used for search of process.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (vremote_tree_root + mask &gt; comm_size) &#123;</span><br><span class="line">            <span class="type">int</span> nprocs_alldata = comm_size - vrank_tree_root - mask;</span><br><span class="line">            <span class="type">int</span> offset = scatter_count * (vrank_tree_root + mask);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> rhalving_mask = mask &gt;&gt; <span class="number">1</span>; rhalving_mask &gt; <span class="number">0</span>; rhalving_mask &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                vremote = vrank ^ rhalving_mask;</span><br><span class="line">                remote = (vremote + root) % comm_size;</span><br><span class="line">                <span class="type">int</span> tree_root = <span class="built_in">ompi_rounddown</span>(vrank, rhalving_mask &lt;&lt; <span class="number">1</span>);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Send only if:</span></span><br><span class="line"><span class="comment">                 * 1) current process has data: (vremote &gt; vrank) &amp;&amp; (vrank &lt; tree_root + nprocs_alldata)</span></span><br><span class="line"><span class="comment">                 * 2) remote process does not have data at any step: vremote &gt;= tree_root + nprocs_alldata</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> ((vremote &gt; vrank) &amp;&amp; (vrank &lt; tree_root + nprocs_alldata)</span><br><span class="line">                    &amp;&amp; (vremote &gt;= tree_root + nprocs_alldata)) &#123;</span><br><span class="line">                    err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span>((<span class="type">char</span> *)buf + (<span class="type">ptrdiff_t</span>)offset * extent,</span><br><span class="line">                                            recv_count, datatype, remote,</span><br><span class="line">                                            MCA_COLL_BASE_TAG_BCAST,</span><br><span class="line">                                            MCA_PML_BASE_SEND_STANDARD, comm));</span><br><span class="line">                    <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; <span class="keyword">goto</span> cleanup_and_return; &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((vremote &lt; vrank) &amp;&amp; (vremote &lt; tree_root + nprocs_alldata)</span><br><span class="line">                           &amp;&amp; (vrank &gt;= tree_root + nprocs_alldata)) &#123;</span><br><span class="line">                    err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>((<span class="type">char</span> *)buf + (<span class="type">ptrdiff_t</span>)offset * extent,</span><br><span class="line">                                            count, datatype, remote,</span><br><span class="line">                                            MCA_COLL_BASE_TAG_BCAST,</span><br><span class="line">                                            comm, &amp;status));</span><br><span class="line">                    <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; <span class="keyword">goto</span> cleanup_and_return; &#125;</span><br><span class="line">                    recv_count = (<span class="type">int</span>)(status._ucount / datatype_size);</span><br><span class="line">                    curr_count += recv_count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cleanup_and_return:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ompi_coll_base_bcast_intra_scatter_allgather_ring：跟上边的一样，不过每个进程都是跟之前的进程交换<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Time complexity: O(\alpha(\log(p) + p) + \beta*m((p-1)/p))</span></span><br><span class="line"><span class="comment"> *   Binomial tree scatter: \alpha\log(p) + \beta*m((p-1)/p)</span></span><br><span class="line"><span class="comment"> *   Ring allgather: 2(p-1)(\alpha + m/p\beta)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example, p=8, count=8, root=0</span></span><br><span class="line"><span class="comment"> *    Binomial tree scatter      Ring allgather: p - 1 steps</span></span><br><span class="line"><span class="comment"> * 0: --+  --+  --+  [0*******]  [0******7] [0*****67] [0****567] ... [01234567]</span></span><br><span class="line"><span class="comment"> * 1:   |   2|  &lt;-+  [*1******]  [01******] [01*****7] [01****67] ... [01234567]</span></span><br><span class="line"><span class="comment"> * 2:  4|  &lt;-+  --+  [**2*****]  [*12*****] [012*****] [012****7] ... [01234567]</span></span><br><span class="line"><span class="comment"> * 3:   |       &lt;-+  [***3****]  [**23****] [*123****] [0123****] ... [01234567]</span></span><br><span class="line"><span class="comment"> * 4: &lt;-+  --+  --+  [****4***]  [***34***] [**234***] [*1234***] ... [01234567]</span></span><br><span class="line"><span class="comment"> * 5:       2|  &lt;-+  [*****5**]  [****45**] [***345**] [**2345**] ... [01234567]</span></span><br><span class="line"><span class="comment"> * 6:      &lt;-+  --+  [******6*]  [*****56*] [****456*] [***3456*] ... [01234567]</span></span><br><span class="line"><span class="comment"> * 7:           &lt;-+  [*******7]  [******67] [*****567] [****4567] ... [01234567]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_base_bcast_intra_scatter_allgather_ring</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> *buf, <span class="type">int</span> count, <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *datatype, <span class="type">int</span> root,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm, <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint32_t</span> segsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err = MPI_SUCCESS;</span><br><span class="line">    <span class="type">ptrdiff_t</span> lb, extent;</span><br><span class="line">    <span class="type">size_t</span> datatype_size;</span><br><span class="line">    MPI_Status status;</span><br><span class="line">    <span class="built_in">ompi_datatype_get_extent</span>(datatype, &amp;lb, &amp;extent);</span><br><span class="line">    <span class="built_in">ompi_datatype_type_size</span>(datatype, &amp;datatype_size);</span><br><span class="line">    <span class="type">int</span> comm_size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    <span class="type">int</span> rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> vrank = (rank - root + comm_size) % comm_size;</span><br><span class="line">    <span class="type">int</span> recv_count = <span class="number">0</span>, send_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> scatter_count = (count + comm_size - <span class="number">1</span>) / comm_size; <span class="comment">/* ceil(count / comm_size) */</span></span><br><span class="line">    <span class="type">int</span> curr_count = (rank == root) ? count : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Scatter by binomial tree: receive data from parent */</span></span><br><span class="line">    <span class="type">int</span> mask = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (mask &lt; comm_size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vrank &amp; mask) &#123;</span><br><span class="line">            <span class="type">int</span> parent = (rank - mask + comm_size) % comm_size;</span><br><span class="line">            <span class="comment">/* Compute an upper bound on recv block size */</span></span><br><span class="line">            recv_count = count - vrank * scatter_count;</span><br><span class="line">            <span class="keyword">if</span> (recv_count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                curr_count = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Recv data from parent */</span></span><br><span class="line">                err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>((<span class="type">char</span> *)buf + (<span class="type">ptrdiff_t</span>)vrank * scatter_count * extent,</span><br><span class="line">                                        recv_count, datatype, parent,</span><br><span class="line">                                        MCA_COLL_BASE_TAG_BCAST, comm, &amp;status));</span><br><span class="line">                <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; <span class="keyword">goto</span> cleanup_and_return; &#125;</span><br><span class="line">                <span class="comment">/* Get received count */</span></span><br><span class="line">                curr_count = (<span class="type">int</span>)(status._ucount / datatype_size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Scatter by binomial tree: send data to child processes */</span></span><br><span class="line">    mask &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (mask &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vrank + mask &lt; comm_size) &#123;</span><br><span class="line">            send_count = curr_count - scatter_count * mask;</span><br><span class="line">            <span class="keyword">if</span> (send_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> child = (rank + mask) % comm_size;</span><br><span class="line">                err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span>((<span class="type">char</span> *)buf + (<span class="type">ptrdiff_t</span>)scatter_count * (vrank + mask) * extent,</span><br><span class="line">                                        send_count, datatype, child,</span><br><span class="line">                                        MCA_COLL_BASE_TAG_BCAST,</span><br><span class="line">                                        MCA_PML_BASE_SEND_STANDARD, comm));</span><br><span class="line">                <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; <span class="keyword">goto</span> cleanup_and_return; &#125;</span><br><span class="line">                curr_count -= send_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mask &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allgather by a ring algorithm */</span></span><br><span class="line">    <span class="type">int</span> left = (rank - <span class="number">1</span> + comm_size) % comm_size;</span><br><span class="line">    <span class="type">int</span> right = (rank + <span class="number">1</span>) % comm_size;</span><br><span class="line">    <span class="type">int</span> send_block = vrank;</span><br><span class="line">    <span class="type">int</span> recv_block = (vrank - <span class="number">1</span> + comm_size) % comm_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; comm_size; i++) &#123;</span><br><span class="line">        recv_count = (scatter_count &lt; count - recv_block * scatter_count) ?</span><br><span class="line">                      scatter_count : count - recv_block * scatter_count;</span><br><span class="line">        <span class="keyword">if</span> (recv_count &lt; <span class="number">0</span>)</span><br><span class="line">            recv_count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ptrdiff_t</span> recv_offset = recv_block * scatter_count * extent;</span><br><span class="line"></span><br><span class="line">        send_count = (scatter_count &lt; count - send_block * scatter_count) ?</span><br><span class="line">                      scatter_count : count - send_block * scatter_count;</span><br><span class="line">        <span class="keyword">if</span> (send_count &lt; <span class="number">0</span>)</span><br><span class="line">            send_count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">ptrdiff_t</span> send_offset = send_block * scatter_count * extent;</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">ompi_coll_base_sendrecv</span>((<span class="type">char</span> *)buf + send_offset, send_count,</span><br><span class="line">                                      datatype, right, MCA_COLL_BASE_TAG_BCAST,</span><br><span class="line">                                      (<span class="type">char</span> *)buf + recv_offset, recv_count,</span><br><span class="line">                                      datatype, left, MCA_COLL_BASE_TAG_BCAST,</span><br><span class="line">                                      comm, MPI_STATUS_IGNORE, rank);</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; <span class="keyword">goto</span> cleanup_and_return; &#125;</span><br><span class="line">        send_block = recv_block;</span><br><span class="line">        recv_block = (recv_block - <span class="number">1</span> + comm_size) % comm_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cleanup_and_return:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="MPI-Send"><a href="#MPI-Send" class="headerlink" title="MPI_Send"></a>MPI_Send</h1><p>经过了一系列错误检查之后，主要是<code>mca_pml.pml_send</code>这个函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">int</span> count, MPI_Datatype type, <span class="type">int</span> dest,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> tag, MPI_Comm comm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rc = MPI_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SPC_RECORD</span>(OMPI_SPC_SEND, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MEMCHECKER</span>(</span><br><span class="line">        <span class="built_in">memchecker_datatype</span>(type);</span><br><span class="line">        <span class="built_in">memchecker_call</span>(&amp;opal_memchecker_base_isdefined, buf, count, type);</span><br><span class="line">        <span class="built_in">memchecker_comm</span>(comm);</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( MPI_PARAM_CHECK ) &#123;</span><br><span class="line">        <span class="built_in">OMPI_ERR_INIT_FINALIZE</span>(FUNC_NAME);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ompi_comm_invalid</span>(comm)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">OMPI_ERRHANDLER_NOHANDLE_INVOKE</span>(MPI_ERR_COMM, FUNC_NAME);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            rc = MPI_ERR_COUNT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag &lt; <span class="number">0</span> || tag &gt; mca_pml.pml_max_tag) &#123;</span><br><span class="line">            rc = MPI_ERR_TAG;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ompi_comm_peer_invalid</span>(comm, dest) &amp;&amp;</span><br><span class="line">                   (MPI_PROC_NULL != dest)) &#123;</span><br><span class="line">            rc = MPI_ERR_RANK;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">OMPI_CHECK_DATATYPE_FOR_SEND</span>(rc, type, count);</span><br><span class="line">            <span class="built_in">OMPI_CHECK_USER_BUFFER</span>(rc, buf, type, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">OMPI_ERRHANDLER_CHECK</span>(rc, comm, rc, FUNC_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_ENABLE_FT_MPI</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * An early check, so as to return early if we are communicating with</span></span><br><span class="line"><span class="comment">     * a failed process. This is not absolutely necessary since we will</span></span><br><span class="line"><span class="comment">     * check for this, and other, error conditions during the completion</span></span><br><span class="line"><span class="comment">     * call in the PML.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">OPAL_UNLIKELY</span>(!<span class="built_in">ompi_comm_iface_p2p_check_proc</span>(comm, dest, &amp;rc)) ) &#123;</span><br><span class="line">        <span class="built_in">OMPI_ERRHANDLER_RETURN</span>(rc, comm, rc, FUNC_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MPI_PROC_NULL == dest) &#123;</span><br><span class="line">        <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span>(buf, count, type, dest, tag, MCA_PML_BASE_SEND_STANDARD, comm));</span><br><span class="line">    <span class="built_in">OMPI_ERRHANDLER_RETURN</span>(rc, comm, rc, FUNC_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>pml_send</code>函数主要有以下几个赋值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mca_pml_cm_send</span><br><span class="line">mca_pml_monitoring_send</span><br><span class="line">mca_pml_ob1_send</span><br><span class="line">mca_pml_ucx_send</span><br><span class="line">mca_spml_ucx_send</span><br></pre></td></tr></table></figure></p>
<p>以第一个为例，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__opal_attribute_always_inline__ <span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">mca_pml_cm_send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">ompi_datatype_t</span>* datatype,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> dst,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> tag,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">mca_pml_base_send_mode_t</span> sendmode,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">ompi_communicator_t</span>* comm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = OMPI_ERROR;</span><br><span class="line">    <span class="type">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ompi_proc_t</span> * ompi_proc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sendmode == MCA_PML_BASE_SEND_BUFFERED) &#123;</span><br><span class="line">        <span class="type">mca_pml_cm_hvy_send_request_t</span> *sendreq;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">MCA_PML_CM_HVY_SEND_REQUEST_ALLOC</span>(sendreq, comm, dst, ompi_proc);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">OPAL_UNLIKELY</span>(<span class="literal">NULL</span> == sendreq)) <span class="keyword">return</span> OMPI_ERR_OUT_OF_RESOURCE;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">MCA_PML_CM_HVY_SEND_REQUEST_INIT</span>(sendreq, ompi_proc, comm, tag, dst, datatype, sendmode, <span class="literal">false</span>, <span class="literal">false</span>, buf, count, flags);</span><br><span class="line">        <span class="built_in">MCA_PML_CM_HVY_SEND_REQUEST_START</span>(sendreq, ret);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">OPAL_UNLIKELY</span>(OMPI_SUCCESS != ret)) &#123;</span><br><span class="line">            <span class="built_in">MCA_PML_CM_HVY_SEND_REQUEST_RETURN</span>(sendreq);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ompi_request_free</span>( (<span class="type">ompi_request_t</span>**)&amp;sendreq );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">opal_convertor_t</span> convertor;</span><br><span class="line">	<span class="built_in">OBJ_CONSTRUCT</span>(&amp;convertor, <span class="type">opal_convertor_t</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(OPAL_ENABLE_HETEROGENEOUS_SUPPORT)</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">opal_datatype_is_contiguous_memory_layout</span>(&amp;datatype-&gt;super, count)) &#123;</span><br><span class="line"></span><br><span class="line">		convertor.remoteArch = ompi_mpi_local_convertor-&gt;remoteArch;</span><br><span class="line">		convertor.flags      = ompi_mpi_local_convertor-&gt;flags;</span><br><span class="line">		convertor.master     = ompi_mpi_local_convertor-&gt;master;</span><br><span class="line"></span><br><span class="line">		convertor.local_size = count * datatype-&gt;super.size;</span><br><span class="line">		convertor.pBaseBuf   = (<span class="type">unsigned</span> <span class="type">char</span>*)buf + datatype-&gt;super.true_lb;</span><br><span class="line">		convertor.count      = count;</span><br><span class="line">		convertor.pDesc      = &amp;datatype-&gt;super;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_CUDA_SUPPORT</span></span><br><span class="line">        <span class="comment">/* Switches off CUDA detection if</span></span><br><span class="line"><span class="comment">           MTL set MCA_MTL_BASE_FLAG_CUDA_INIT_DISABLE during init */</span></span><br><span class="line">        <span class="built_in">MCA_PML_CM_SWITCH_CUDA_CONVERTOR_OFF</span>(flags, datatype, count);</span><br><span class="line">        convertor.flags      |= flags;</span><br><span class="line">        <span class="comment">/* Sets CONVERTOR_CUDA flag if CUDA buffer */</span></span><br><span class="line">        <span class="built_in">opal_convertor_prepare_for_send</span>( &amp;convertor, &amp;datatype-&gt;super, count, buf );</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		ompi_proc = <span class="built_in">ompi_comm_peer_lookup</span>(comm, dst);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">MCA_PML_CM_SWITCH_CUDA_CONVERTOR_OFF</span>(flags, datatype, count);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">opal_convertor_copy_and_prepare_for_send</span>(</span><br><span class="line">		ompi_proc-&gt;super.proc_convertor,</span><br><span class="line">			&amp;datatype-&gt;super, count, buf, flags,</span><br><span class="line">			&amp;convertor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">OMPI_MTL_CALL</span>(<span class="built_in">send</span>(ompi_mtl,</span><br><span class="line">                                 comm,</span><br><span class="line">                                 dst,</span><br><span class="line">                                 tag,</span><br><span class="line">                                 &amp;convertor,</span><br><span class="line">                                 sendmode));</span><br><span class="line">	<span class="built_in">OBJ_DESTRUCT</span>(&amp;convertor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为这是简单的send，所以分为两种情况，第一种是有buffer，先分配request，初始化之后等待返回。<code>MCA_PML_CM_HVY_SEND_REQUEST_ALLOC</code>是分配一个request，request应该是<code>opal_free_list_wait</code>（只包括了有多线程情况下的<code>opal_free_list_wait_mt(fl);</code>和无多线程情况下的<code>opal_free_list_wait_st(fl)</code>的调用）函数分配的，并规定了完成后的回调函数<code>mca_pml_cm_send_request_completion</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MCA_PML_CM_HVY_SEND_REQUEST_ALLOC(sendreq, comm, dst,           \</span></span><br><span class="line"><span class="meta">                                          ompi_proc)                    \</span></span><br><span class="line"><span class="meta">&#123;                                                                       \</span></span><br><span class="line"><span class="meta">    sendreq = (mca_pml_cm_hvy_send_request_t*)                          \</span></span><br><span class="line"><span class="meta">        opal_free_list_wait (&amp;mca_pml_base_send_requests);              \</span></span><br><span class="line"><span class="meta">    sendreq-&gt;req_send.req_base.req_pml_type = MCA_PML_CM_REQUEST_SEND_HEAVY; \</span></span><br><span class="line"><span class="meta">    sendreq-&gt;req_mtl.ompi_req = (ompi_request_t*) sendreq;              \</span></span><br><span class="line"><span class="meta">    sendreq-&gt;req_mtl.completion_callback = mca_pml_cm_send_request_completion; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>从一个栈结构里取出来一个proc<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">opal_free_list_item_t</span> *<span class="title">opal_free_list_wait_st</span><span class="params">(<span class="type">opal_free_list_t</span> *fl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">opal_free_list_item_t</span> *item = (<span class="type">opal_free_list_item_t</span> *) <span class="built_in">opal_lifo_pop</span>(&amp;fl-&gt;super);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> == item) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fl-&gt;fl_max_to_alloc &lt;= fl-&gt;fl_num_allocated</span><br><span class="line">            || OPAL_SUCCESS != <span class="built_in">opal_free_list_grow_st</span>(fl, fl-&gt;fl_num_per_alloc, &amp;item)) &#123;</span><br><span class="line">            <span class="comment">/* try to make progress */</span></span><br><span class="line">            <span class="built_in">opal_progress</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == item) &#123;</span><br><span class="line">            item = (<span class="type">opal_free_list_item_t</span> *) <span class="built_in">opal_lifo_pop</span>(&amp;fl-&gt;super);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Blocking call to obtain an item from a free list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">opal_free_list_item_t</span> *<span class="title">opal_free_list_wait_mt</span><span class="params">(<span class="type">opal_free_list_t</span> *fl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">opal_free_list_item_t</span> *item = (<span class="type">opal_free_list_item_t</span> *) <span class="built_in">opal_lifo_pop_atomic</span>(&amp;fl-&gt;super);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> == item) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">opal_mutex_trylock</span>(&amp;fl-&gt;fl_lock)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fl-&gt;fl_max_to_alloc &lt;= fl-&gt;fl_num_allocated</span><br><span class="line">                || OPAL_SUCCESS != <span class="built_in">opal_free_list_grow_st</span>(fl, fl-&gt;fl_num_per_alloc, &amp;item)) &#123;</span><br><span class="line">                fl-&gt;fl_num_waiting++;</span><br><span class="line">                <span class="built_in">opal_condition_wait</span>(&amp;fl-&gt;fl_condition, &amp;fl-&gt;fl_lock);</span><br><span class="line">                fl-&gt;fl_num_waiting--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt; fl-&gt;fl_num_waiting) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> == fl-&gt;fl_num_waiting) &#123;</span><br><span class="line">                        <span class="built_in">opal_condition_signal</span>(&amp;fl-&gt;fl_condition);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="built_in">opal_condition_broadcast</span>(&amp;fl-&gt;fl_condition);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* If I wasn&#x27;t able to get the lock in the begining when I finaly grab it</span></span><br><span class="line"><span class="comment">             * the one holding the lock in the begining already grow the list. I will</span></span><br><span class="line"><span class="comment">             * release the lock and try to get a new element until I succeed.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">opal_mutex_lock</span>(&amp;fl-&gt;fl_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">opal_mutex_unlock</span>(&amp;fl-&gt;fl_lock);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == item) &#123;</span><br><span class="line">            item = (<span class="type">opal_free_list_item_t</span> *) <span class="built_in">opal_lifo_pop_atomic</span>(&amp;fl-&gt;super);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回调函数<code>mca_pml_cm_send_request_completion</code>，主要是为了调用<code>MCA_PML_CM_THIN_SEND_REQUEST_PML_COMPLETE</code>的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">mca_pml_cm_send_request_completion</span><span class="params">(<span class="keyword">struct</span> <span class="type">mca_mtl_request_t</span> *mtl_request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">mca_pml_cm_send_request_t</span> *base_request =</span><br><span class="line">        (<span class="type">mca_pml_cm_send_request_t</span>*) mtl_request-&gt;ompi_req;</span><br><span class="line">    <span class="keyword">if</span>( MCA_PML_CM_REQUEST_SEND_THIN == base_request-&gt;req_base.req_pml_type ) &#123;</span><br><span class="line">        <span class="built_in">MCA_PML_CM_THIN_SEND_REQUEST_PML_COMPLETE</span>(((<span class="type">mca_pml_cm_thin_send_request_t</span>*) base_request));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">MCA_PML_CM_HVY_SEND_REQUEST_PML_COMPLETE</span>(((<span class="type">mca_pml_cm_hvy_send_request_t</span>*) base_request));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The PML has completed a send request. Note that this request</span></span><br><span class="line"><span class="comment"> * may have been orphaned by the user or have already completed</span></span><br><span class="line"><span class="comment"> * at the MPI level.</span></span><br><span class="line"><span class="comment"> * This macro will never be called directly from the upper level, as it should</span></span><br><span class="line"><span class="comment"> * only be an internal call to the PML.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MCA_PML_CM_THIN_SEND_REQUEST_PML_COMPLETE(sendreq)                   \</span></span><br><span class="line"><span class="meta">do &#123;                                                                         \</span></span><br><span class="line"><span class="meta">    assert( false == sendreq-&gt;req_send.req_base.req_pml_complete );          \</span></span><br><span class="line"><span class="meta">                                                                             \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>( !REQUEST_COMPLETE(&amp;sendreq-&gt;req_send.req_base.req_ompi)) &#123;           \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* Should only be called for long messages (maybe synchronous) */</span>    \</span></span><br><span class="line"><span class="meta">        ompi_request_complete(&amp;(sendreq-&gt;req_send.req_base.req_ompi), true); \</span></span><br><span class="line"><span class="meta">    &#125;                                                                        \</span></span><br><span class="line"><span class="meta">    sendreq-&gt;req_send.req_base.req_pml_complete = true;                      \</span></span><br><span class="line"><span class="meta">                                                                             \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>( sendreq-&gt;req_send.req_base.req_free_called ) &#123;                       \</span></span><br><span class="line"><span class="meta">        MCA_PML_CM_THIN_SEND_REQUEST_RETURN( sendreq );                      \</span></span><br><span class="line"><span class="meta">    &#125;                                                                        \</span></span><br><span class="line"><span class="meta"> &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The PML has completed a send request. Note that this request</span></span><br><span class="line"><span class="comment"> * may have been orphaned by the user or have already completed</span></span><br><span class="line"><span class="comment"> * at the MPI level.</span></span><br><span class="line"><span class="comment"> * This macro will never be called directly from the upper level, as it should</span></span><br><span class="line"><span class="comment"> * only be an internal call to the PML.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MCA_PML_CM_HVY_SEND_REQUEST_PML_COMPLETE(sendreq)                          \</span></span><br><span class="line"><span class="meta">do &#123;                                                                               \</span></span><br><span class="line"><span class="meta">    assert( false == sendreq-&gt;req_send.req_base.req_pml_complete );                \</span></span><br><span class="line"><span class="meta">                                                                                   \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (sendreq-&gt;req_send.req_send_mode == MCA_PML_BASE_SEND_BUFFERED &amp;&amp;           \</span></span><br><span class="line"><span class="meta">        sendreq-&gt;req_count &gt; 0 ) &#123;                                                 \</span></span><br><span class="line"><span class="meta">        mca_pml_base_bsend_request_free(sendreq-&gt;req_buff);                        \</span></span><br><span class="line"><span class="meta">    &#125;                                                                              \</span></span><br><span class="line"><span class="meta">                                                                                   \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>( !REQUEST_COMPLETE(&amp;sendreq-&gt;req_send.req_base.req_ompi)) &#123;                 \</span></span><br><span class="line"><span class="meta">        <span class="comment">/* the request may have already been marked complete by the MTL */</span>         \</span></span><br><span class="line"><span class="meta">        ompi_request_complete(&amp;(sendreq-&gt;req_send.req_base.req_ompi), true);       \</span></span><br><span class="line"><span class="meta">    &#125;                                                                              \</span></span><br><span class="line"><span class="meta">    sendreq-&gt;req_send.req_base.req_pml_complete = true;                            \</span></span><br><span class="line"><span class="meta">                                                                                   \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>( sendreq-&gt;req_send.req_base.req_free_called ) &#123;                             \</span></span><br><span class="line"><span class="meta">        MCA_PML_CM_HVY_SEND_REQUEST_RETURN( sendreq );                             \</span></span><br><span class="line"><span class="meta">    &#125; <span class="keyword">else</span> &#123;                                                                       \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span>(sendreq-&gt;req_send.req_base.req_ompi.req_persistent) &#123;                   \</span></span><br><span class="line"><span class="meta">            <span class="comment">/* rewind convertor */</span>                                                 \</span></span><br><span class="line"><span class="meta">            size_t offset = 0;                                                     \</span></span><br><span class="line"><span class="meta">            opal_convertor_set_position(&amp;sendreq-&gt;req_send.req_base.req_convertor, \</span></span><br><span class="line"><span class="meta">                                        &amp;offset);                                  \</span></span><br><span class="line"><span class="meta">        &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    &#125;                                                                              \</span></span><br><span class="line"><span class="meta"> &#125; while (0)</span></span><br></pre></td></tr></table></figure></p>
<p>分配完之后调用<code>MCA_PML_CM_HVY_SEND_REQUEST_INIT</code>进行初始化，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MCA_PML_CM_HVY_SEND_REQUEST_INIT( sendreq,                      \</span></span><br><span class="line"><span class="meta">                                          ompi_proc,                    \</span></span><br><span class="line"><span class="meta">                                          comm,                         \</span></span><br><span class="line"><span class="meta">                                          tag,                          \</span></span><br><span class="line"><span class="meta">                                          dst,                          \</span></span><br><span class="line"><span class="meta">                                          datatype,                     \</span></span><br><span class="line"><span class="meta">                                          sendmode,                     \</span></span><br><span class="line"><span class="meta">                                          persistent,                   \</span></span><br><span class="line"><span class="meta">                                          blocking,                     \</span></span><br><span class="line"><span class="meta">                                          buf,                          \</span></span><br><span class="line"><span class="meta">                                          count,                        \</span></span><br><span class="line"><span class="meta">                                          flags )                       \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                \</span></span><br><span class="line"><span class="meta">        OMPI_REQUEST_INIT(&amp;(sendreq-&gt;req_send.req_base.req_ompi),       \</span></span><br><span class="line"><span class="meta">                          persistent);                                  \</span></span><br><span class="line"><span class="meta">        sendreq-&gt;req_tag = tag;                                         \</span></span><br><span class="line"><span class="meta">        sendreq-&gt;req_peer = dst;                                        \</span></span><br><span class="line"><span class="meta">        sendreq-&gt;req_addr = buf;                                        \</span></span><br><span class="line"><span class="meta">        sendreq-&gt;req_count = count;                                     \</span></span><br><span class="line"><span class="meta">        MCA_PML_CM_HVY_SEND_REQUEST_INIT_COMMON( (&amp;sendreq-&gt;req_send),  \</span></span><br><span class="line"><span class="meta">                                             ompi_proc,                 \</span></span><br><span class="line"><span class="meta">                                             comm,                      \</span></span><br><span class="line"><span class="meta">                                             tag,                       \</span></span><br><span class="line"><span class="meta">                                             datatype,                  \</span></span><br><span class="line"><span class="meta">                                             sendmode,                  \</span></span><br><span class="line"><span class="meta">                                             buf,                       \</span></span><br><span class="line"><span class="meta">                                             count,                     \</span></span><br><span class="line"><span class="meta">                                             flags )                    \</span></span><br><span class="line"><span class="meta">        opal_convertor_get_packed_size(                                 \</span></span><br><span class="line"><span class="meta">                             &amp;sendreq-&gt;req_send.req_base.req_convertor, \</span></span><br><span class="line"><span class="meta">                                       &amp;sendreq-&gt;req_count );           \</span></span><br><span class="line"><span class="meta">                                                                        \</span></span><br><span class="line"><span class="meta">        sendreq-&gt;req_blocking = blocking;                               \</span></span><br><span class="line"><span class="meta">        sendreq-&gt;req_send.req_base.req_pml_complete =                   \</span></span><br><span class="line"><span class="meta">            (persistent ? true:false);                                  \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MCA_PML_CM_THIN_SEND_REQUEST_INIT( sendreq,                     \</span></span><br><span class="line"><span class="meta">                                           ompi_proc,                   \</span></span><br><span class="line"><span class="meta">                                           comm,                        \</span></span><br><span class="line"><span class="meta">                                           tag,                         \</span></span><br><span class="line"><span class="meta">                                           dst,                         \</span></span><br><span class="line"><span class="meta">                                           datatype,                    \</span></span><br><span class="line"><span class="meta">                                           sendmode,                    \</span></span><br><span class="line"><span class="meta">                                           buf,                         \</span></span><br><span class="line"><span class="meta">                                           count,                       \</span></span><br><span class="line"><span class="meta">                                           flags )                      \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                \</span></span><br><span class="line"><span class="meta">        OMPI_REQUEST_INIT(&amp;(sendreq-&gt;req_send.req_base.req_ompi),       \</span></span><br><span class="line"><span class="meta">                          false);                                       \</span></span><br><span class="line"><span class="meta">        MCA_PML_CM_SEND_REQUEST_INIT_COMMON( (&amp;sendreq-&gt;req_send),      \</span></span><br><span class="line"><span class="meta">                                             ompi_proc,                 \</span></span><br><span class="line"><span class="meta">                                             comm,                      \</span></span><br><span class="line"><span class="meta">                                             tag,                       \</span></span><br><span class="line"><span class="meta">                                             datatype,                  \</span></span><br><span class="line"><span class="meta">                                             sendmode,                  \</span></span><br><span class="line"><span class="meta">                                             buf,                       \</span></span><br><span class="line"><span class="meta">                                             count,                     \</span></span><br><span class="line"><span class="meta">                                             flags);                    \</span></span><br><span class="line"><span class="meta">        sendreq-&gt;req_send.req_base.req_pml_complete = false;            \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br></pre></td></tr></table></figure></p>
<p>初始化完成之后开始执行send-request，并释放。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MCA_PML_CM_HVY_SEND_REQUEST_START(sendreq, ret)                              \</span></span><br><span class="line"><span class="meta">do &#123;                                                                                 \</span></span><br><span class="line"><span class="meta">    ret = OMPI_SUCCESS;                                                              \</span></span><br><span class="line"><span class="meta">    MCA_PML_CM_SEND_REQUEST_START_SETUP(&amp;(sendreq)-&gt;req_send);                       \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (sendreq-&gt;req_send.req_send_mode == MCA_PML_BASE_SEND_BUFFERED) &#123;             \</span></span><br><span class="line"><span class="meta">        MCA_PML_CM_HVY_SEND_REQUEST_BSEND_ALLOC(sendreq, ret);                       \</span></span><br><span class="line"><span class="meta">    &#125;                                                                                \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (OMPI_SUCCESS == ret) &#123;                                                       \</span></span><br><span class="line"><span class="meta">        ret = OMPI_MTL_CALL(isend(ompi_mtl,                                          \</span></span><br><span class="line"><span class="meta">                                  sendreq-&gt;req_send.req_base.req_comm,               \</span></span><br><span class="line"><span class="meta">                                  sendreq-&gt;req_peer,                                 \</span></span><br><span class="line"><span class="meta">                                  sendreq-&gt;req_tag,                                  \</span></span><br><span class="line"><span class="meta">                                  &amp;sendreq-&gt;req_send.req_base.req_convertor,         \</span></span><br><span class="line"><span class="meta">                                  sendreq-&gt;req_send.req_send_mode,                   \</span></span><br><span class="line"><span class="meta">                                  sendreq-&gt;req_blocking,                             \</span></span><br><span class="line"><span class="meta">                                  &amp;sendreq-&gt;req_mtl));                               \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span>(OMPI_SUCCESS == ret &amp;&amp;                                                    \</span></span><br><span class="line"><span class="meta">           sendreq-&gt;req_send.req_send_mode == MCA_PML_BASE_SEND_BUFFERED) &#123;          \</span></span><br><span class="line"><span class="meta">            sendreq-&gt;req_send.req_base.req_ompi.req_status.MPI_ERROR = 0;            \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span>(!REQUEST_COMPLETE(&amp;sendreq-&gt;req_send.req_base.req_ompi)) &#123;            \</span></span><br><span class="line"><span class="meta">                <span class="comment">/* request may have already been marked complete by the MTL */</span>       \</span></span><br><span class="line"><span class="meta">                ompi_request_complete(&amp;(sendreq)-&gt;req_send.req_base.req_ompi, true); \</span></span><br><span class="line"><span class="meta">            &#125;                                                                        \</span></span><br><span class="line"><span class="meta">        &#125;                                                                            \</span></span><br><span class="line"><span class="meta">    &#125;                                                                                \</span></span><br><span class="line"><span class="meta"> &#125; while (0)</span></span><br></pre></td></tr></table></figure></p>
<p>否则，如果不是buffer类型的send，首先创建一个convertor（后边看，可能是在不同架构下进行通信的转换器），如果没有异构的支持，需要考虑传输的数据是不是连续的，支持异构的话就不需要额外考虑内存连续性。<code>OPAL_CUDA_SUPPORT</code>考虑了cuda的特点。</p>
<p><code>ompi_comm_peer_lookup</code>用于找到通信对方进程<code>ompi_proc_t</code>结构，原来找一个对方通信进程还需要加锁。它最终是调用了这个函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Helper function for retreiving the proc of a group member in a dense group</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function exists to handle the translation of sentinel group members to real</span></span><br><span class="line"><span class="comment"> * ompi_proc_t&#x27;s. If a sentinel value is found and allocate is true then this function</span></span><br><span class="line"><span class="comment"> * looks for an existing ompi_proc_t using ompi_proc_for_name which will allocate a</span></span><br><span class="line"><span class="comment"> * ompi_proc_t if one does not exist. If allocate is false then sentinel values translate</span></span><br><span class="line"><span class="comment"> * to NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> <span class="title class_">ompi_proc_t</span> *<span class="built_in">ompi_group_dense_lookup</span> (<span class="type">ompi_group_t</span> *group, <span class="type">const</span> <span class="type">int</span> peer_id, <span class="type">const</span> <span class="type">bool</span> allocate)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ompi_proc_t</span> *proc;</span><br><span class="line"></span><br><span class="line">    proc = group-&gt;grp_proc_pointers[peer_id];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_UNLIKELY</span>(<span class="built_in">ompi_proc_is_sentinel</span> (proc))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!allocate) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* replace sentinel value with an actual ompi_proc_t */</span></span><br><span class="line">        <span class="type">ompi_proc_t</span> *real_proc =</span><br><span class="line">            (<span class="type">ompi_proc_t</span> *) <span class="built_in">ompi_proc_for_name</span> (<span class="built_in">ompi_proc_sentinel_to_name</span> ((<span class="type">uintptr_t</span>) proc));</span><br><span class="line">            <span class="comment">// 在hash table里找proc</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">opal_atomic_compare_exchange_strong_ptr</span> ((<span class="type">opal_atomic_intptr_t</span> *)(group-&gt;grp_proc_pointers + peer_id),</span><br><span class="line">                                                     (<span class="type">intptr_t</span> *) &amp;proc, (<span class="type">intptr_t</span>) real_proc)) &#123;</span><br><span class="line">            <span class="built_in">OBJ_RETAIN</span>(real_proc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        proc = real_proc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后这样就可以调用<code>ompi_mtl-&gt;mtl_send</code>，主要是这个函数<code>ompi_mtl_psm2_send</code>，到了MTL层。send还有一种实现是调用了fabric库的操作，这个先不看了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">ompi_mtl_psm2_send</span><span class="params">(<span class="keyword">struct</span> <span class="type">mca_mtl_base_module_t</span>* mtl,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span>* comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">int</span> dest,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">int</span> tag,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="keyword">struct</span> <span class="type">opal_convertor_t</span> *convertor,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">mca_pml_base_send_mode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">psm2_error_t</span> err;</span><br><span class="line">    <span class="type">mca_mtl_psm2_request_t</span> mtl_psm2_request;</span><br><span class="line">    <span class="type">psm2_mq_tag_t</span> mqtag;</span><br><span class="line">    <span class="type">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">size_t</span> length;</span><br><span class="line">    <span class="type">ompi_proc_t</span>* ompi_proc = <span class="built_in">ompi_comm_peer_lookup</span>( comm, dest );</span><br><span class="line">    <span class="type">mca_mtl_psm2_endpoint_t</span>* psm2_endpoint = <span class="built_in">ompi_mtl_psm2_get_endpoint</span> (mtl, ompi_proc);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(mtl == &amp;ompi_mtl_psm2.super);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PSM2_MAKE_MQTAG</span>(comm-&gt;c_index, comm-&gt;c_my_rank, tag, mqtag);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">ompi_mtl_datatype_pack</span>(convertor,</span><br><span class="line">                                 &amp;mtl_psm2_request.buf,</span><br><span class="line">                                 &amp;length,</span><br><span class="line">                                 &amp;mtl_psm2_request.free_after);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length &gt;= <span class="number">1ULL</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>) * <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="built_in">opal_show_help</span>(<span class="string">&quot;help-mtl-psm2.txt&quot;</span>,</span><br><span class="line">		    <span class="string">&quot;message too big&quot;</span>, <span class="literal">false</span>,</span><br><span class="line">		    length, <span class="number">1ULL</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>) * <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">return</span> OMPI_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前边是pack</span></span><br><span class="line">    mtl_psm2_request.length = length;</span><br><span class="line">    mtl_psm2_request.convertor = convertor;</span><br><span class="line">    mtl_psm2_request.type = OMPI_mtl_psm2_ISEND;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (OMPI_SUCCESS != ret) <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == MCA_PML_BASE_SEND_SYNCHRONOUS)</span><br><span class="line">	flags |= PSM2_MQ_FLAG_SENDSYNC;</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">psm2_mq_send2</span>(ompi_mtl_psm2.mq,</span><br><span class="line">		      psm2_endpoint-&gt;peer_addr,</span><br><span class="line">		      flags,</span><br><span class="line">		      &amp;mqtag,</span><br><span class="line">		      mtl_psm2_request.buf,</span><br><span class="line">		      length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mtl_psm2_request.free_after) &#123;</span><br><span class="line">	<span class="built_in">free</span>(mtl_psm2_request.buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err == PSM2_OK ? OMPI_SUCCESS : OMPI_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到了这里就没法继续追了，<code>psm2_mq_send2</code>是Performance Scaled Messaging 2里的函数，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psm2_error_t psm2_mq_send2 (psm2_mq_t mq, psm2_epaddr_t dest,</span><br><span class="line">    uint32_t flags, psm2_mq_tag_t *stag, const void *buf, uint32_t len)</span><br></pre></td></tr></table></figure></p>
<p>发送阻塞 MQ 消息。 发送阻塞 MQ 消息的函数，该消息在本地完成，并且可以在返回时修改源数据。</p>
<p>Parameters:</p>
<ul>
<li>mq: Matched Queue handle.</li>
<li>dest: Destination EP address.</li>
<li>flags: Message flags, currently:<ul>
<li>PSM2_MQ_FLAG_SENDSYNC tells PSM2 to send the message synchronously, meaning that the message is not sent until the receiver acknowledges that it has matched the send with a receive buffer.</li>
</ul>
</li>
<li>stag: Message Send Tag pointer.</li>
<li>buf: Source buffer pointer.</li>
<li>len: Length of message starting at buf.</li>
</ul>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>看代码里有tcp和rdma的实现，但是没找到怎么到tcp这块的，看到注释说是动态加载模块，可能是通过配置实现选择TCP或者RDMA的？以下缕一下TCP的执行过程。</p>
<p>从<code>btl_tcp_component.c</code>开始，这个结构保存了网络通信的信息，同时支持IPv4和IPv6，可以看到TCP通信时数据是以帧frag为单位的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">mca_btl_tcp_component_t</span> &#123;</span><br><span class="line">    <span class="type">mca_btl_base_component_3_0_0_t</span> super; <span class="comment">/**&lt; base BTL component */</span></span><br><span class="line">    <span class="type">uint32_t</span> tcp_addr_count;              <span class="comment">/**&lt; total number of addresses */</span></span><br><span class="line">    <span class="type">uint32_t</span> tcp_num_btls;      <span class="comment">/**&lt; number of interfaces available to the TCP component */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tcp_num_links; <span class="comment">/**&lt; number of logical links per physical device */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mca_btl_tcp_module_t</span> **tcp_btls; <span class="comment">/**&lt; array of available BTL modules */</span></span><br><span class="line">    <span class="type">opal_list_t</span> local_ifs;                  <span class="comment">/**&lt; opal list of local opal_if_t interfaces */</span></span><br><span class="line">    <span class="type">int</span> tcp_free_list_num;                  <span class="comment">/**&lt; initial size of free lists */</span></span><br><span class="line">    <span class="type">int</span> tcp_free_list_max;                  <span class="comment">/**&lt; maximum size of free lists */</span></span><br><span class="line">    <span class="type">int</span> tcp_free_list_inc;       <span class="comment">/**&lt; number of elements to alloc when growing free lists */</span></span><br><span class="line">    <span class="type">int</span> tcp_endpoint_cache;      <span class="comment">/**&lt; amount of cache on each endpoint */</span></span><br><span class="line">    <span class="type">opal_proc_table_t</span> tcp_procs; <span class="comment">/**&lt; hash table of tcp proc structures */</span></span><br><span class="line">    <span class="type">opal_mutex_t</span> tcp_lock;       <span class="comment">/**&lt; lock for accessing module state */</span></span><br><span class="line">    <span class="type">opal_list_t</span> tcp_events;</span><br><span class="line"></span><br><span class="line">    <span class="type">opal_event_t</span> tcp_recv_event;    <span class="comment">/**&lt; recv event for IPv4 listen socket */</span></span><br><span class="line">    <span class="type">int</span> tcp_listen_sd;              <span class="comment">/**&lt; IPv4 listen socket for incoming connection requests */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> tcp_listen_port; <span class="comment">/**&lt; IPv4 listen port */</span></span><br><span class="line">    <span class="type">int</span> tcp_port_min;               <span class="comment">/**&lt; IPv4 minimum port */</span></span><br><span class="line">    <span class="type">int</span> tcp_port_range;             <span class="comment">/**&lt; IPv4 port range */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_ENABLE_IPV6</span></span><br><span class="line">    <span class="type">opal_event_t</span> tcp6_recv_event;    <span class="comment">/**&lt; recv event for IPv6 listen socket */</span></span><br><span class="line">    <span class="type">int</span> tcp6_listen_sd;              <span class="comment">/**&lt; IPv6 listen socket for incoming connection requests */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> tcp6_listen_port; <span class="comment">/**&lt; IPv6 listen port */</span></span><br><span class="line">    <span class="type">int</span> tcp6_port_min;               <span class="comment">/**&lt; IPv4 minimum port */</span></span><br><span class="line">    <span class="type">int</span> tcp6_port_range;             <span class="comment">/**&lt; IPv4 port range */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Port range restriction */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *tcp_if_include;   <span class="comment">/**&lt; comma seperated list of interface to include */</span></span><br><span class="line">    <span class="type">char</span> *tcp_if_exclude;   <span class="comment">/**&lt; comma seperated list of interface to exclude */</span></span><br><span class="line">    <span class="type">int</span> tcp_sndbuf;         <span class="comment">/**&lt; socket sndbuf size */</span></span><br><span class="line">    <span class="type">int</span> tcp_rcvbuf;         <span class="comment">/**&lt; socket rcvbuf size */</span></span><br><span class="line">    <span class="type">int</span> tcp_disable_family; <span class="comment">/**&lt; disabled AF_family */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free list of fragment descriptors */</span></span><br><span class="line">    <span class="type">opal_free_list_t</span> tcp_frag_eager;</span><br><span class="line">    <span class="type">opal_free_list_t</span> tcp_frag_max;</span><br><span class="line">    <span class="type">opal_free_list_t</span> tcp_frag_user;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tcp_enable_progress_thread; <span class="comment">/** Support for tcp progress thread flag */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">opal_event_t</span> tcp_recv_thread_async_event;</span><br><span class="line">    <span class="type">opal_mutex_t</span> tcp_frag_eager_mutex;</span><br><span class="line">    <span class="type">opal_mutex_t</span> tcp_frag_max_mutex;</span><br><span class="line">    <span class="type">opal_mutex_t</span> tcp_frag_user_mutex;</span><br><span class="line">    <span class="comment">/* Do we want to use TCP_NODELAY? */</span></span><br><span class="line">    <span class="type">int</span> tcp_not_use_nodelay;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do we want to warn on all excluded interfaces</span></span><br><span class="line"><span class="comment">     * that are not found?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> report_all_unfound_interfaces;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>mca_btl_tcp_module_t</code>是一个中间层，保存了tcp通信的每步需要调用的函数指针。以<code>mca_btl_tcp_send</code>为例记录调用历程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mca_btl_tcp_module_t</span> mca_btl_tcp_module =</span><br><span class="line">    &#123;.super =</span><br><span class="line">         &#123;</span><br><span class="line">             .btl_component = &amp;mca_btl_tcp_component.super,</span><br><span class="line">             .btl_add_procs = mca_btl_tcp_add_procs,</span><br><span class="line">             .btl_del_procs = mca_btl_tcp_del_procs,</span><br><span class="line">             .btl_finalize = mca_btl_tcp_finalize,</span><br><span class="line">             .btl_alloc = mca_btl_tcp_alloc,</span><br><span class="line">             .btl_free = mca_btl_tcp_free,</span><br><span class="line">             .btl_prepare_src = mca_btl_tcp_prepare_src,</span><br><span class="line">             .btl_send = mca_btl_tcp_send,</span><br><span class="line">             .btl_put = mca_btl_tcp_put,</span><br><span class="line">             .btl_dump = mca_btl_base_dump,</span><br><span class="line">             .btl_register_error = mca_btl_tcp_register_error_cb, <span class="comment">/* register error */</span></span><br><span class="line">         &#125;,</span><br><span class="line">     .tcp_endpoints_mutex = OPAL_MUTEX_STATIC_INIT&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>mca_btl_tcp_send</code>首先开启一个异步的发送过程，新建一个fragment，记录下每一个segment。put和get都是跟它差不多，最终都是调用的<code>mca_btl_tcp_endpoint_send</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initiate an asynchronous send.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param btl (IN)         BTL module</span></span><br><span class="line"><span class="comment"> * @param endpoint (IN)    BTL addressing information</span></span><br><span class="line"><span class="comment"> * @param descriptor (IN)  Description of the data to be transfered</span></span><br><span class="line"><span class="comment"> * @param tag (IN)         The tag value used to notify the peer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mca_btl_tcp_send</span><span class="params">(<span class="keyword">struct</span> <span class="type">mca_btl_base_module_t</span> *btl, <span class="keyword">struct</span> <span class="type">mca_btl_base_endpoint_t</span> *endpoint,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">struct</span> <span class="type">mca_btl_base_descriptor_t</span> *descriptor, <span class="type">mca_btl_base_tag_t</span> tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">mca_btl_tcp_module_t</span> *tcp_btl = (<span class="type">mca_btl_tcp_module_t</span> *) btl;</span><br><span class="line">    <span class="type">mca_btl_tcp_frag_t</span> *frag = (<span class="type">mca_btl_tcp_frag_t</span> *) descriptor;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    frag-&gt;btl = tcp_btl;</span><br><span class="line">    frag-&gt;endpoint = endpoint;</span><br><span class="line">    frag-&gt;rc = <span class="number">0</span>;</span><br><span class="line">    frag-&gt;iov_idx = <span class="number">0</span>;</span><br><span class="line">    frag-&gt;iov_cnt = <span class="number">1</span>;</span><br><span class="line">    frag-&gt;iov_ptr = frag-&gt;iov;</span><br><span class="line">    frag-&gt;iov[<span class="number">0</span>].iov_base = (IOVBASE_TYPE *) &amp;frag-&gt;hdr;</span><br><span class="line">    frag-&gt;iov[<span class="number">0</span>].iov_len = <span class="built_in">sizeof</span>(frag-&gt;hdr);</span><br><span class="line">    frag-&gt;hdr.size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) frag-&gt;base.des_segment_count; i++) &#123;</span><br><span class="line">        frag-&gt;hdr.size += frag-&gt;segments[i].seg_len;</span><br><span class="line">        frag-&gt;iov[i + <span class="number">1</span>].iov_len = frag-&gt;segments[i].seg_len;</span><br><span class="line">        frag-&gt;iov[i + <span class="number">1</span>].iov_base = (IOVBASE_TYPE *) frag-&gt;segments[i].seg_addr.pval;</span><br><span class="line">        frag-&gt;iov_cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    frag-&gt;hdr.base.tag = tag;</span><br><span class="line">    frag-&gt;hdr.type = MCA_BTL_TCP_HDR_TYPE_SEND;</span><br><span class="line">    frag-&gt;hdr.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (endpoint-&gt;endpoint_nbo) &#123;</span><br><span class="line">        <span class="built_in">MCA_BTL_TCP_HDR_HTON</span>(frag-&gt;hdr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mca_btl_tcp_endpoint_send</span>(endpoint, frag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>mca_btl_tcp_endpoint_send</code>尝试发送一个fragment，使用的是endpoint，看起来是一个tcp连接的抽象。如果TCP处于正在连接或者没连接的状态，就发起连接，同时把当前的frag放到list中，因为正在连接，所以没法进行通信。如果已经连接了，调用<code>mca_btl_tcp_frag_send</code>发送frag。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mca_btl_tcp_endpoint_send</span><span class="params">(<span class="type">mca_btl_base_endpoint_t</span> *btl_endpoint, <span class="type">mca_btl_tcp_frag_t</span> *frag)</span></span></span><br><span class="line"><span class="function">    <span class="type">int</span> rc </span>= OPAL_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OPAL_THREAD_LOCK</span>(&amp;btl_endpoint-&gt;endpoint_send_lock);</span><br><span class="line">    <span class="keyword">switch</span> (btl_endpoint-&gt;endpoint_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> MCA_BTL_TCP_CONNECTING:</span><br><span class="line">    <span class="keyword">case</span> MCA_BTL_TCP_CONNECT_ACK:</span><br><span class="line">    <span class="keyword">case</span> MCA_BTL_TCP_CLOSED:</span><br><span class="line">        <span class="built_in">opal_list_append</span>(&amp;btl_endpoint-&gt;endpoint_frags, (<span class="type">opal_list_item_t</span> *) frag);</span><br><span class="line">        frag-&gt;base.des_flags |= MCA_BTL_DES_SEND_ALWAYS_CALLBACK;</span><br><span class="line">        <span class="keyword">if</span> (btl_endpoint-&gt;endpoint_state == MCA_BTL_TCP_CLOSED) &#123;</span><br><span class="line">            rc = <span class="built_in">mca_btl_tcp_endpoint_start_connect</span>(btl_endpoint);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MCA_BTL_TCP_FAILED:</span><br><span class="line">        rc = OPAL_ERR_UNREACH;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MCA_BTL_TCP_CONNECTED:</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == btl_endpoint-&gt;endpoint_send_frag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (frag-&gt;base.des_flags &amp; MCA_BTL_DES_FLAGS_PRIORITY</span><br><span class="line">                &amp;&amp; <span class="built_in">mca_btl_tcp_frag_send</span>(frag, btl_endpoint-&gt;endpoint_sd)) &#123;</span><br><span class="line">                <span class="comment">// 发送成功了应该</span></span><br><span class="line">                <span class="type">int</span> btl_ownership = (frag-&gt;base.des_flags &amp; MCA_BTL_DES_FLAGS_BTL_OWNERSHIP);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">OPAL_THREAD_UNLOCK</span>(&amp;btl_endpoint-&gt;endpoint_send_lock);</span><br><span class="line">                <span class="keyword">if</span> (frag-&gt;base.des_flags &amp; MCA_BTL_DES_SEND_ALWAYS_CALLBACK) &#123;</span><br><span class="line">                    frag-&gt;base.<span class="built_in">des_cbfunc</span>(&amp;frag-&gt;btl-&gt;super, frag-&gt;endpoint, &amp;frag-&gt;base, frag-&gt;rc);</span><br><span class="line">                &#125;<span class="comment">// 回调函数</span></span><br><span class="line">                <span class="keyword">if</span> (btl_ownership) &#123;</span><br><span class="line">                    <span class="built_in">MCA_BTL_TCP_FRAG_RETURN</span>(frag);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">MCA_BTL_TCP_ENDPOINT_DUMP</span>(<span class="number">50</span>, btl_endpoint, <span class="literal">true</span>,</span><br><span class="line">                                          <span class="string">&quot;complete send fragment [endpoint_send]&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                btl_endpoint-&gt;endpoint_send_frag = frag;</span><br><span class="line">                <span class="built_in">MCA_BTL_TCP_ENDPOINT_DUMP</span>(<span class="number">10</span>, btl_endpoint, <span class="literal">true</span>,</span><br><span class="line">                                          <span class="string">&quot;event_add(send) [endpoint_send]&quot;</span>);</span><br><span class="line">                frag-&gt;base.des_flags |= MCA_BTL_DES_SEND_ALWAYS_CALLBACK;</span><br><span class="line">                <span class="built_in">MCA_BTL_TCP_ACTIVATE_EVENT</span>(&amp;btl_endpoint-&gt;endpoint_send_event, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">MCA_BTL_TCP_ENDPOINT_DUMP</span>(<span class="number">10</span>, btl_endpoint, <span class="literal">true</span>,</span><br><span class="line">                                      <span class="string">&quot;send fragment enqueued [endpoint_send]&quot;</span>);</span><br><span class="line">            frag-&gt;base.des_flags |= MCA_BTL_DES_SEND_ALWAYS_CALLBACK;</span><br><span class="line">            <span class="built_in">opal_list_append</span>(&amp;btl_endpoint-&gt;endpoint_frags, (<span class="type">opal_list_item_t</span> *) frag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">OPAL_THREAD_UNLOCK</span>(&amp;btl_endpoint-&gt;endpoint_send_lock);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>建立TCP连接的函数，首先调用<code>socket</code>建立一个socket，并设置socket的buffer等属性。其次设置这个endpoint的回调函数，一般是设置<code>mca_btl_tcp_endpoint_recv_handler</code>和<code>mca_btl_tcp_endpoint_send_handler</code>，应该是在这个socket的某个行为已经完成后的回调。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mca_btl_tcp_endpoint_start_connect</span><span class="params">(<span class="type">mca_btl_base_endpoint_t</span> *btl_endpoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rc, flags;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span> endpoint_addr;</span><br><span class="line">    <span class="comment">/* By default consider a IPv4 connection */</span></span><br><span class="line">    <span class="type">uint16_t</span> af_family = AF_INET;</span><br><span class="line">    <span class="type">opal_socklen_t</span> addrlen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_ENABLE_IPV6</span></span><br><span class="line">    <span class="keyword">if</span> (AF_INET6 == btl_endpoint-&gt;endpoint_addr-&gt;addr_family) &#123;</span><br><span class="line">        af_family = AF_INET6;</span><br><span class="line">        addrlen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">assert</span>(btl_endpoint-&gt;endpoint_sd &lt; <span class="number">0</span>);</span><br><span class="line">    btl_endpoint-&gt;endpoint_sd = <span class="built_in">socket</span>(af_family, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (btl_endpoint-&gt;endpoint_sd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        btl_endpoint-&gt;endpoint_retries++;</span><br><span class="line">        <span class="keyword">return</span> OPAL_ERR_UNREACH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup socket buffer sizes */</span></span><br><span class="line">    <span class="built_in">mca_btl_tcp_set_socket_options</span>(btl_endpoint-&gt;endpoint_sd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup event callbacks </span></span><br><span class="line"><span class="comment">       只是使用了event_assign，把给定的event类型对象的每一个成员赋予一个指定的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">mca_btl_tcp_endpoint_event_init</span>(btl_endpoint);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* setup the socket as non-blocking </span></span><br><span class="line"><span class="comment">       正如注释所言，只是调用了ioctlsocket设置socket的模式</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((flags = <span class="built_in">fcntl</span>(btl_endpoint-&gt;endpoint_sd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">opal_show_help</span>(<span class="string">&quot;help-mpi-btl-tcp.txt&quot;</span>, <span class="string">&quot;socket flag fail&quot;</span>, <span class="literal">true</span>, opal_process_info.nodename,</span><br><span class="line">                       <span class="built_in">getpid</span>(), <span class="string">&quot;fcntl(sd, F_GETFL, 0)&quot;</span>, <span class="built_in">strerror</span>(opal_socket_errno),</span><br><span class="line">                       opal_socket_errno);</span><br><span class="line">        <span class="comment">/* Upper layer will handler the error */</span></span><br><span class="line">        <span class="keyword">return</span> OPAL_ERR_UNREACH;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags |= O_NONBLOCK;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fcntl</span>(btl_endpoint-&gt;endpoint_sd, F_SETFL, flags) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">opal_show_help</span>(<span class="string">&quot;help-mpi-btl-tcp.txt&quot;</span>, <span class="string">&quot;socket flag fail&quot;</span>, <span class="literal">true</span>,</span><br><span class="line">                           opal_process_info.nodename, <span class="built_in">getpid</span>(),</span><br><span class="line">                           <span class="string">&quot;fcntl(sd, F_SETFL, flags &amp; O_NONBLOCK)&quot;</span>, <span class="built_in">strerror</span>(opal_socket_errno),</span><br><span class="line">                           opal_socket_errno);</span><br><span class="line">            <span class="comment">/* Upper layer will handler the error */</span></span><br><span class="line">            <span class="keyword">return</span> OPAL_ERR_UNREACH;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把endpoint_address，可能是地址，转换成sockaddr_storage */</span></span><br><span class="line">    <span class="built_in">mca_btl_tcp_proc_tosocks</span>(btl_endpoint-&gt;endpoint_addr, &amp;endpoint_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将套接字绑定到与此 btl 模块关联的地址之一。 这会将源 IP 设置为在 modex 中共享的地址之一，以便目标 rank 可以正确配对 btl 模块，即使在 Linux 可能对路由做一些意外的情况下 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (endpoint_addr.ss_family == AF_INET) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="literal">NULL</span> != &amp;btl_endpoint-&gt;endpoint_btl-&gt;tcp_ifaddr);</span><br><span class="line">        <span class="comment">// 将指定了通信协议的套接字文件与自己的IP和端口绑定起来，sd是socket的编号，tcp_ifaddr是之前转换的ip</span></span><br><span class="line">        <span class="comment">// int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(btl_endpoint-&gt;endpoint_sd, (<span class="keyword">struct</span> sockaddr *) &amp;btl_endpoint-&gt;endpoint_btl-&gt;tcp_ifaddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">BTL_ERROR</span>(............);</span><br><span class="line">            <span class="built_in">CLOSE_THE_SOCKET</span>(btl_endpoint-&gt;endpoint_sd);</span><br><span class="line">            <span class="keyword">return</span> OPAL_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_ENABLE_IPV6</span></span><br><span class="line">    <span class="keyword">if</span> (endpoint_addr.ss_family == AF_INET6) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="literal">NULL</span> != &amp;btl_endpoint-&gt;endpoint_btl-&gt;tcp_ifaddr);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bind</span>(btl_endpoint-&gt;endpoint_sd, (<span class="keyword">struct</span> sockaddr *) &amp;btl_endpoint-&gt;endpoint_btl-&gt;tcp_ifaddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">BTL_ERROR</span>(............);</span><br><span class="line">            <span class="built_in">CLOSE_THE_SOCKET</span>(btl_endpoint-&gt;endpoint_sd);</span><br><span class="line">            <span class="keyword">return</span> OPAL_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">connect</span>(btl_endpoint-&gt;endpoint_sd, (<span class="keyword">struct</span> sockaddr *) &amp;endpoint_addr, addrlen)) &#123;</span><br><span class="line">        <span class="comment">// 连接socket</span></span><br><span class="line">        <span class="comment">// int connect (int sockfd, struct sockaddr * serv_addr, int addrlen)</span></span><br><span class="line">        <span class="comment">/* send our globally unique process identifier to the endpoint */</span></span><br><span class="line">        <span class="keyword">if</span> ((rc = <span class="built_in">mca_btl_tcp_endpoint_send_connect_ack</span>(btl_endpoint)) == OPAL_SUCCESS) &#123;</span><br><span class="line">            <span class="comment">// 最终是调用了send函数进行发送magic id的操作</span></span><br><span class="line">            btl_endpoint-&gt;endpoint_state = MCA_BTL_TCP_CONNECT_ACK;</span><br><span class="line">            <span class="built_in">MCA_BTL_TCP_ENDPOINT_DUMP</span>(<span class="number">10</span>, btl_endpoint, <span class="literal">true</span>, <span class="string">&quot;event_add(recv) [start_connect]&quot;</span>);</span><br><span class="line">            <span class="built_in">opal_event_add</span>(&amp;btl_endpoint-&gt;endpoint_recv_event, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (mca_btl_tcp_event_base == opal_sync_event_base) &#123;</span><br><span class="line">                <span class="comment">/* If no progress thread then raise the awarness of the default progress engine */</span></span><br><span class="line">                <span class="built_in">opal_progress_event_users_increment</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> OPAL_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* We connected to the peer, but he close the socket before we got a chance to send our guid</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">MCA_BTL_TCP_ENDPOINT_DUMP</span>(<span class="number">1</span>, btl_endpoint, <span class="literal">true</span>, <span class="string">&quot;dropped connection [start_connect]&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* non-blocking so wait for completion */</span></span><br><span class="line">        <span class="keyword">if</span> (opal_socket_errno == EINPROGRESS || opal_socket_errno == EWOULDBLOCK) &#123;</span><br><span class="line">            btl_endpoint-&gt;endpoint_state = MCA_BTL_TCP_CONNECTING;</span><br><span class="line">            <span class="built_in">MCA_BTL_TCP_ENDPOINT_DUMP</span>(<span class="number">10</span>, btl_endpoint, <span class="literal">true</span>, <span class="string">&quot;event_add(send) [start_connect]&quot;</span>);</span><br><span class="line">            <span class="built_in">MCA_BTL_TCP_ACTIVATE_EVENT</span>(&amp;btl_endpoint-&gt;endpoint_send_event, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">opal_output_verbose</span>(<span class="number">30</span>, opal_btl_base_framework.framework_output,</span><br><span class="line">                                <span class="string">&quot;btl:tcp: would block, so allowing background progress&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> OPAL_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *address;</span><br><span class="line">        address = <span class="built_in">opal_net_get_hostname</span>((<span class="keyword">struct</span> sockaddr *) &amp;endpoint_addr);</span><br><span class="line">        <span class="built_in">BTL_PEER_ERROR</span>(btl_endpoint-&gt;endpoint_proc-&gt;proc_opal,</span><br><span class="line">                       (<span class="string">&quot;Unable to connect to the peer %s on port %d: %s\n&quot;</span>, address,</span><br><span class="line">                        <span class="built_in">ntohs</span>(btl_endpoint-&gt;endpoint_addr-&gt;addr_port),</span><br><span class="line">                        <span class="built_in">strerror</span>(opal_socket_errno)));</span><br><span class="line">    &#125;</span><br><span class="line">    btl_endpoint-&gt;endpoint_state = MCA_BTL_TCP_FAILED;</span><br><span class="line">    <span class="built_in">mca_btl_tcp_endpoint_close</span>(btl_endpoint);</span><br><span class="line">    <span class="keyword">return</span> OPAL_ERR_UNREACH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个回调函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A file descriptor is available/ready for recv. Check the state</span></span><br><span class="line"><span class="comment"> * of the socket and take the appropriate action.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mca_btl_tcp_endpoint_recv_handler</span><span class="params">(<span class="type">int</span> sd, <span class="type">short</span> flags, <span class="type">void</span> *user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">mca_btl_base_endpoint_t</span> *btl_endpoint = (<span class="type">mca_btl_base_endpoint_t</span> *) user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure we don&#x27;t have a race between a thread that remove the</span></span><br><span class="line"><span class="comment">     * recv event, and one event already scheduled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (sd != btl_endpoint-&gt;endpoint_sd) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里有一个极其罕见的竞争条件，只能在初始化期间触发。</span></span><br><span class="line"><span class="comment">     * 如果两个进程同时启动它们的连接，则其中一个进程将不得不关闭它的前一个endpoint（从本地发送打开的那个）。</span></span><br><span class="line"><span class="comment">     * 结果它可能会进入 btl_endpoint_close 并尝试删除 recv_event。 </span></span><br><span class="line"><span class="comment">     * 此调用将返回 libevent，并且在多线程情况下将尝试锁定事件。 </span></span><br><span class="line"><span class="comment">     * 如果另一个线程注意到活动事件（这是可能的，因为在初始化期间将有 2 个套接字），</span></span><br><span class="line"><span class="comment">     * 一个线程可能会卡住试图锁定 endpoint_recv_lock（同时持有 event_base 锁），</span></span><br><span class="line"><span class="comment">     * 而另一个线程将尝试锁定 event_base 锁（同时持有 endpoint_recv 锁）。</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">      如果我们不能锁定这个互斥体，取消接收操作是可以的，它最终会很快再次触发。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_THREAD_TRYLOCK</span>(&amp;btl_endpoint-&gt;endpoint_recv_lock)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (btl_endpoint-&gt;endpoint_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> MCA_BTL_TCP_CONNECT_ACK: &#123;</span><br><span class="line">        <span class="type">int</span> rc = <span class="built_in">mca_btl_tcp_endpoint_recv_connect_ack</span>(btl_endpoint);</span><br><span class="line">        <span class="comment">// 如果还是MCA_BTL_TCP_CONNECT_ACK，说明可能还不用真的接收真实数据</span></span><br><span class="line">        <span class="comment">// 最终调用的是recv函数，接收标识符确认已经完成了连接</span></span><br><span class="line">        <span class="comment">// 把这个endpoint设置为MCA_BTL_TCP_CONNECTED</span></span><br><span class="line">        <span class="keyword">if</span> (OPAL_SUCCESS == rc) &#123;</span><br><span class="line">            <span class="comment">/* we are now connected. Start sending the data */</span></span><br><span class="line">            <span class="built_in">OPAL_THREAD_LOCK</span>(&amp;btl_endpoint-&gt;endpoint_send_lock);</span><br><span class="line">            <span class="built_in">mca_btl_tcp_endpoint_connected</span>(btl_endpoint);</span><br><span class="line">            <span class="built_in">OPAL_THREAD_UNLOCK</span>(&amp;btl_endpoint-&gt;endpoint_send_lock);</span><br><span class="line">            <span class="built_in">MCA_BTL_TCP_ENDPOINT_DUMP</span>(<span class="number">10</span>, btl_endpoint, <span class="literal">true</span>, <span class="string">&quot;connected&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (OPAL_ERR_BAD_PARAM == rc || OPAL_ERROR == rc) &#123;</span><br><span class="line">            <span class="comment">/* If we get a BAD_PARAM, it means that it probably wasn&#x27;t</span></span><br><span class="line"><span class="comment">               an OMPI process on the other end of the socket (e.g.,</span></span><br><span class="line"><span class="comment">               the magic string ID failed). recv_connect_ack already cleaned</span></span><br><span class="line"><span class="comment">               up the socket. */</span></span><br><span class="line">            <span class="comment">/* If we get OPAL_ERROR, the other end closed the connection</span></span><br><span class="line"><span class="comment">             * because it has initiated a symetrical connexion on its end.</span></span><br><span class="line"><span class="comment">             * recv_connect_ack already cleaned up the socket. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Otherwise, it probably *was* an OMPI peer process on</span></span><br><span class="line"><span class="comment">               the other end, and something bad has probably</span></span><br><span class="line"><span class="comment">               happened.  */</span></span><br><span class="line">            <span class="type">mca_btl_tcp_module_t</span> *m = btl_endpoint-&gt;endpoint_btl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Fail up to the PML */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> != m-&gt;tcp_error_cb) &#123;</span><br><span class="line">                m-&gt;<span class="built_in">tcp_error_cb</span>(</span><br><span class="line">                    (<span class="type">mca_btl_base_module_t</span> *) m, MCA_BTL_ERROR_FLAGS_FATAL,</span><br><span class="line">                    btl_endpoint-&gt;endpoint_proc-&gt;proc_opal,</span><br><span class="line">                    <span class="string">&quot;TCP ACK is neither SUCCESS nor ERR (something bad has probably happened)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">OPAL_THREAD_UNLOCK</span>(&amp;btl_endpoint-&gt;endpoint_recv_lock);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> MCA_BTL_TCP_CONNECTED: &#123;</span><br><span class="line">        <span class="comment">// 如果已经是MCA_BTL_TCP_CONNECTED状态了，执行接收</span></span><br><span class="line">        <span class="type">mca_btl_tcp_frag_t</span> *frag;</span><br><span class="line"></span><br><span class="line">        frag = btl_endpoint-&gt;endpoint_recv_frag;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == frag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mca_btl_tcp_module.super.btl_max_send_size</span><br><span class="line">                &gt; mca_btl_tcp_module.super.btl_eager_limit) &#123;</span><br><span class="line">                <span class="built_in">MCA_BTL_TCP_FRAG_ALLOC_MAX</span>(frag);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">MCA_BTL_TCP_FRAG_ALLOC_EAGER</span>(frag);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从opal_free_list_item_t表里找到一个需要接收的，之前好像有把消息加入到这里</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> == frag) &#123;</span><br><span class="line">                <span class="built_in">OPAL_THREAD_UNLOCK</span>(&amp;btl_endpoint-&gt;endpoint_recv_lock);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">MCA_BTL_TCP_FRAG_INIT_DST</span>(frag, btl_endpoint);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MCA_BTL_TCP_ENDPOINT_CACHE</span></span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span> == btl_endpoint-&gt;endpoint_cache_length);</span><br><span class="line">    data_still_pending_on_endpoint:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* MCA_BTL_TCP_ENDPOINT_CACHE */</span></span></span><br><span class="line">        <span class="comment">/* check for completion of non-blocking recv on the current fragment */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">mca_btl_tcp_frag_recv</span>(frag, btl_endpoint-&gt;endpoint_sd) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// 这个函数关键是readv，与之前的sendv对应，其他很多代码是处理接收了一部分frag或者接收失败的情况。</span></span><br><span class="line">            btl_endpoint-&gt;endpoint_recv_frag = frag;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            btl_endpoint-&gt;endpoint_recv_frag = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (MCA_BTL_TCP_HDR_TYPE_SEND == frag-&gt;hdr.type) &#123;</span><br><span class="line">                <span class="type">mca_btl_active_message_callback_t</span> *reg = mca_btl_base_active_message_trigger</span><br><span class="line">                                                         + frag-&gt;hdr.base.tag;</span><br><span class="line">                <span class="type">const</span> <span class="type">mca_btl_base_receive_descriptor_t</span> desc</span><br><span class="line">                    = &#123;.endpoint = btl_endpoint,</span><br><span class="line">                       .des_segments = frag-&gt;base.des_segments,</span><br><span class="line">                       .des_segment_count = frag-&gt;base.des_segment_count,</span><br><span class="line">                       .tag = frag-&gt;hdr.base.tag,</span><br><span class="line">                       .cbdata = reg-&gt;cbdata&#125;;</span><br><span class="line">                reg-&gt;<span class="built_in">cbfunc</span>(&amp;frag-&gt;btl-&gt;super, &amp;desc);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MCA_BTL_TCP_ENDPOINT_CACHE</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != btl_endpoint-&gt;endpoint_cache_length) &#123;</span><br><span class="line">                <span class="comment">/* 如果还有数据在frag里的话，重用它</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="built_in">MCA_BTL_TCP_FRAG_INIT_DST</span>(frag, btl_endpoint);</span><br><span class="line">                <span class="keyword">goto</span> data_still_pending_on_endpoint;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* MCA_BTL_TCP_ENDPOINT_CACHE */</span></span></span><br><span class="line">            <span class="built_in">MCA_BTL_TCP_FRAG_RETURN</span>(frag);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MCA_BTL_TCP_ENDPOINT_CACHE</span></span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">0</span> == btl_endpoint-&gt;endpoint_cache_length);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* MCA_BTL_TCP_ENDPOINT_CACHE */</span></span></span><br><span class="line">        <span class="built_in">OPAL_THREAD_UNLOCK</span>(&amp;btl_endpoint-&gt;endpoint_recv_lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> MCA_BTL_TCP_CLOSED:</span><br><span class="line">        <span class="comment">/* 这是一个线程安全问题。 </span></span><br><span class="line"><span class="comment">         * 由于允许多个线程生成事件，</span></span><br><span class="line"><span class="comment">         * 当我们到达 MPI_Finalize 的末尾时，</span></span><br><span class="line"><span class="comment">         * 我们最终会有多个线程执行接收回调。</span></span><br><span class="line"><span class="comment">         * 第一个将关闭连接，所有其他人都会抱怨。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">OPAL_THREAD_UNLOCK</span>(&amp;btl_endpoint-&gt;endpoint_recv_lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">OPAL_THREAD_UNLOCK</span>(&amp;btl_endpoint-&gt;endpoint_recv_lock);</span><br><span class="line">        <span class="built_in">BTL_ERROR</span>((<span class="string">&quot;invalid socket state(%d)&quot;</span>, btl_endpoint-&gt;endpoint_state));</span><br><span class="line">        btl_endpoint-&gt;endpoint_state = MCA_BTL_TCP_FAILED;</span><br><span class="line">        <span class="built_in">mca_btl_tcp_endpoint_close</span>(btl_endpoint);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A file descriptor is available/ready for send. Check the state</span></span><br><span class="line"><span class="comment"> * of the socket and take the appropriate action.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mca_btl_tcp_endpoint_send_handler</span><span class="params">(<span class="type">int</span> sd, <span class="type">short</span> flags, <span class="type">void</span> *user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">mca_btl_tcp_endpoint_t</span> *btl_endpoint = (<span class="type">mca_btl_tcp_endpoint_t</span> *) user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if another thread is already here, give up */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_THREAD_TRYLOCK</span>(&amp;btl_endpoint-&gt;endpoint_send_lock)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (btl_endpoint-&gt;endpoint_state) &#123;</span><br><span class="line">    <span class="keyword">case</span> MCA_BTL_TCP_CONNECTING:</span><br><span class="line">        <span class="built_in">mca_btl_tcp_endpoint_complete_connect</span>(btl_endpoint);</span><br><span class="line">        <span class="comment">// 检查是否已经连接了socket，如果连上了，就发送进程标识符</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MCA_BTL_TCP_CONNECTED:</span><br><span class="line">        <span class="comment">/* complete the current send */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">NULL</span> != btl_endpoint-&gt;endpoint_send_frag) &#123;</span><br><span class="line">            <span class="comment">// 如果一直有frag需要发送</span></span><br><span class="line">            <span class="type">mca_btl_tcp_frag_t</span> *frag = btl_endpoint-&gt;endpoint_send_frag;</span><br><span class="line">            <span class="type">int</span> btl_ownership = (frag-&gt;base.des_flags &amp; MCA_BTL_DES_FLAGS_BTL_OWNERSHIP);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">assert</span>(btl_endpoint-&gt;endpoint_state == MCA_BTL_TCP_CONNECTED);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">mca_btl_tcp_frag_send</span>(frag, btl_endpoint-&gt;endpoint_sd) == <span class="literal">false</span>) &#123; </span><br><span class="line">                <span class="comment">// 发送，如果失败的话直接跳出去</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* progress any pending sends 找到其他需要发送的frag 尝试发送*/</span></span><br><span class="line">            btl_endpoint-&gt;endpoint_send_frag = (<span class="type">mca_btl_tcp_frag_t</span> *) <span class="built_in">opal_list_remove_first</span>(</span><br><span class="line">                &amp;btl_endpoint-&gt;endpoint_frags);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* if required - update request status and release fragment */</span></span><br><span class="line">            <span class="built_in">OPAL_THREAD_UNLOCK</span>(&amp;btl_endpoint-&gt;endpoint_send_lock);</span><br><span class="line">            <span class="built_in">assert</span>(frag-&gt;base.des_flags &amp; MCA_BTL_DES_SEND_ALWAYS_CALLBACK);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> != frag-&gt;base.des_cbfunc) &#123;</span><br><span class="line">                frag-&gt;base.<span class="built_in">des_cbfunc</span>(&amp;frag-&gt;btl-&gt;super, frag-&gt;endpoint, &amp;frag-&gt;base, frag-&gt;rc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (btl_ownership) &#123;</span><br><span class="line">                <span class="built_in">MCA_BTL_TCP_FRAG_RETURN</span>(frag);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* if we fail to take the lock simply return. In the worst case the</span></span><br><span class="line"><span class="comment">             * send_handler will be triggered once more, and as there will be</span></span><br><span class="line"><span class="comment">             * nothing to send the handler will be deleted.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">OPAL_THREAD_TRYLOCK</span>(&amp;btl_endpoint-&gt;endpoint_send_lock)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* if nothing else to do unregister for send event notifications */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == btl_endpoint-&gt;endpoint_send_frag) &#123;</span><br><span class="line">            <span class="built_in">MCA_BTL_TCP_ENDPOINT_DUMP</span>(<span class="number">10</span>, btl_endpoint, <span class="literal">false</span>,</span><br><span class="line">                                      <span class="string">&quot;event_del(send) [endpoint_send_handler]&quot;</span>);</span><br><span class="line">            <span class="built_in">opal_event_del</span>(&amp;btl_endpoint-&gt;endpoint_send_event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> MCA_BTL_TCP_FAILED:</span><br><span class="line">        <span class="built_in">MCA_BTL_TCP_ENDPOINT_DUMP</span>(<span class="number">1</span>, btl_endpoint, <span class="literal">true</span>,</span><br><span class="line">                                  <span class="string">&quot;event_del(send) [endpoint_send_handler:error]&quot;</span>);</span><br><span class="line">        <span class="built_in">opal_event_del</span>(&amp;btl_endpoint-&gt;endpoint_send_event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">BTL_ERROR</span>((<span class="string">&quot;invalid connection state (%d)&quot;</span>, btl_endpoint-&gt;endpoint_state));</span><br><span class="line">        <span class="built_in">MCA_BTL_TCP_ENDPOINT_DUMP</span>(<span class="number">1</span>, btl_endpoint, <span class="literal">true</span>,</span><br><span class="line">                                  <span class="string">&quot;event_del(send) [endpoint_send_handler:error]&quot;</span>);</span><br><span class="line">        <span class="built_in">opal_event_del</span>(&amp;btl_endpoint-&gt;endpoint_send_event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">OPAL_THREAD_UNLOCK</span>(&amp;btl_endpoint-&gt;endpoint_send_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是检查socket是否连接的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查连接状态。 如果连接失败，稍后将重试。 否则，将此进程标识符发送到新连接的套接字上的端点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mca_btl_tcp_endpoint_complete_connect</span><span class="params">(<span class="type">mca_btl_base_endpoint_t</span> *btl_endpoint)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> so_error = <span class="number">0</span>;</span><br><span class="line">    <span class="type">opal_socklen_t</span> so_length = <span class="built_in">sizeof</span>(so_error);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span> endpoint_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete the send event notification, as the next step is waiting for the ack</span></span><br><span class="line"><span class="comment">     * from the peer. Once this ack is received we will deal with the send notification</span></span><br><span class="line"><span class="comment">     * accordingly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">opal_event_del</span>(&amp;btl_endpoint-&gt;endpoint_send_event);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mca_btl_tcp_proc_tosocks</span>(btl_endpoint-&gt;endpoint_addr, &amp;endpoint_addr);</span><br><span class="line">    <span class="comment">// 把内部的proc_addr-&gt;addr_union.addr_inet转成socket用的类型addr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check connect completion status */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getsockopt</span>(btl_endpoint-&gt;endpoint_sd, SOL_SOCKET, SO_ERROR, (<span class="type">char</span> *) &amp;so_error, &amp;so_length) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取socket的属性</span></span><br><span class="line">        btl_endpoint-&gt;endpoint_state = MCA_BTL_TCP_FAILED;</span><br><span class="line">        <span class="built_in">mca_btl_tcp_endpoint_close</span>(btl_endpoint);</span><br><span class="line">        <span class="keyword">return</span> OPAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (so_error == EINPROGRESS || so_error == EWOULDBLOCK) &#123;</span><br><span class="line">        <span class="keyword">return</span> OPAL_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (so_error != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mca_btl_base_warn_peer_error || mca_btl_base_verbose &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span> *msg;</span><br><span class="line">            <span class="built_in">free</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        btl_endpoint-&gt;endpoint_state = MCA_BTL_TCP_FAILED;</span><br><span class="line">        <span class="built_in">mca_btl_tcp_endpoint_close</span>(btl_endpoint);</span><br><span class="line">        <span class="keyword">return</span> OPAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mca_btl_tcp_endpoint_send_connect_ack</span>(btl_endpoint) == OPAL_SUCCESS) &#123;</span><br><span class="line">        <span class="comment">// 最终调用了send函数发送出去</span></span><br><span class="line">        btl_endpoint-&gt;endpoint_state = MCA_BTL_TCP_CONNECT_ACK;</span><br><span class="line">        <span class="built_in">opal_event_add</span>(&amp;btl_endpoint-&gt;endpoint_recv_event, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mca_btl_tcp_event_base == opal_sync_event_base) &#123;</span><br><span class="line">            <span class="comment">/* If no progress thread then raise the awarness of the default progress engine */</span></span><br><span class="line">            <span class="built_in">opal_progress_event_users_increment</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">MCA_BTL_TCP_ENDPOINT_DUMP</span>(<span class="number">10</span>, btl_endpoint, <span class="literal">false</span>, <span class="string">&quot;event_add(recv) [complete_connect]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> OPAL_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MCA_BTL_TCP_ENDPOINT_DUMP</span>(<span class="number">1</span>, btl_endpoint, <span class="literal">false</span>, <span class="string">&quot; [complete_connect]&quot;</span>);</span><br><span class="line">    btl_endpoint-&gt;endpoint_state = MCA_BTL_TCP_FAILED;</span><br><span class="line">    <span class="built_in">mca_btl_tcp_endpoint_close</span>(btl_endpoint);</span><br><span class="line">    <span class="keyword">return</span> OPAL_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过了这么长一块总算建立好了连接，接下来是执行发送的函数，<code>writev</code>是将不连续的内存块写入地址中，这里的参数sd是socket的编号。可能出现没写完的情况，这时更新frag的iov_cnt。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mca_btl_tcp_frag_send</span><span class="params">(<span class="type">mca_btl_tcp_frag_t</span> *frag, <span class="type">int</span> sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> cnt;</span><br><span class="line">    <span class="type">size_t</span> i, num_vecs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* non-blocking write, but continue if interrupted */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cnt = <span class="built_in">writev</span>(sd, frag-&gt;iov_ptr, frag-&gt;iov_cnt);</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (opal_socket_errno) &#123;</span><br><span class="line">            <span class="keyword">case</span> EINTR:</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> EWOULDBLOCK:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">case</span> EFAULT:</span><br><span class="line">                <span class="built_in">BTL_ERROR</span>((<span class="string">&quot;mca_btl_tcp_frag_send: writev error (%p, %lu)\n\t%s(%lu)\n&quot;</span>,</span><br><span class="line">                           frag-&gt;iov_ptr[<span class="number">0</span>].iov_base, (<span class="type">unsigned</span> <span class="type">long</span>) frag-&gt;iov_ptr[<span class="number">0</span>].iov_len,</span><br><span class="line">                           <span class="built_in">strerror</span>(opal_socket_errno), (<span class="type">unsigned</span> <span class="type">long</span>) frag-&gt;iov_cnt));</span><br><span class="line">                <span class="comment">/* send_lock held by caller */</span></span><br><span class="line">                frag-&gt;endpoint-&gt;endpoint_state = MCA_BTL_TCP_FAILED;</span><br><span class="line">                <span class="built_in">mca_btl_tcp_endpoint_close</span>(frag-&gt;endpoint);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">BTL_PEER_ERROR</span>(frag-&gt;endpoint-&gt;endpoint_proc-&gt;proc_opal,</span><br><span class="line">                               (<span class="string">&quot;mca_btl_tcp_frag_send: writev failed: %s (%d)&quot;</span>,</span><br><span class="line">                                <span class="built_in">strerror</span>(opal_socket_errno), opal_socket_errno));</span><br><span class="line">                <span class="comment">/* send_lock held by caller */</span></span><br><span class="line">                frag-&gt;endpoint-&gt;endpoint_state = MCA_BTL_TCP_FAILED;</span><br><span class="line">                <span class="built_in">mca_btl_tcp_endpoint_close</span>(frag-&gt;endpoint);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cnt &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if the write didn&#x27;t complete - update the iovec state */</span></span><br><span class="line">    num_vecs = frag-&gt;iov_cnt;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_vecs; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= (<span class="type">ssize_t</span>) frag-&gt;iov_ptr-&gt;iov_len) &#123;</span><br><span class="line">            cnt -= frag-&gt;iov_ptr-&gt;iov_len;</span><br><span class="line">            frag-&gt;iov_ptr++;</span><br><span class="line">            frag-&gt;iov_idx++;</span><br><span class="line">            frag-&gt;iov_cnt--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            frag-&gt;iov_ptr-&gt;iov_base = (<span class="type">opal_iov_base_ptr_t</span>)(</span><br><span class="line">                ((<span class="type">unsigned</span> <span class="type">char</span> *) frag-&gt;iov_ptr-&gt;iov_base) + cnt);</span><br><span class="line">            frag-&gt;iov_ptr-&gt;iov_len -= cnt;</span><br><span class="line">            <span class="built_in">OPAL_OUTPUT_VERBOSE</span>((<span class="number">100</span>, opal_btl_base_framework.framework_output,</span><br><span class="line">                                 <span class="string">&quot;%s:%d write %ld bytes on socket %d\n&quot;</span>, __FILE__, __LINE__, cnt,</span><br><span class="line">                                 sd));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (frag-&gt;iov_cnt == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>mca_btl_tcp_create</code>在给定设备（即 kindex）上查找未被 disable_family 选项禁用的地址。 如果没有，请跳过为此接口创建模块。 我们将地址存储在模块上，既可以在 modex 中发布，也可以用作该模块发送的所有数据包的源地址。 最好将 split_and_resolve 分开并将用于选择设备的地址传递给<code>mca_btl_tcp_create()</code>。 这是对多年来一直使用的逻辑的清理，但它没有涵盖的情况是（例如）仅在接口具有 10.0.0.1 和 10.1.0.1 的地址时指定 mca_btl_if_include 10.0.0.0/16； 绝对没有什么可以阻止此代码选择 10.1.0.1 作为在 modex 中发布并用于连接的代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Create a btl instance and add to modules list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">mca_btl_tcp_create</span><span class="params">(<span class="type">const</span> <span class="type">int</span> if_kindex, <span class="type">const</span> <span class="type">char</span> *if_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mca_btl_tcp_module_t</span> *btl;</span><br><span class="line">    <span class="type">opal_if_t</span> *copied_interface, *selected_interface;</span><br><span class="line">    <span class="type">char</span> param[<span class="number">256</span>];</span><br><span class="line">    <span class="type">int</span> i, if_index;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span> addr;</span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OPAL_LIST_FOREACH</span> (selected_interface, &amp;opal_if_list, <span class="type">opal_if_t</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (if_kindex != selected_interface-&gt;if_kernel_index) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if_index = selected_interface-&gt;if_index;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">struct</span> sockaddr *) &amp;addr, &amp;selected_interface-&gt;if_addr,</span><br><span class="line">               <span class="built_in">MIN</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage), <span class="built_in">sizeof</span>(selected_interface-&gt;if_addr)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (addr.ss_family == AF_INET &amp;&amp; <span class="number">4</span> != mca_btl_tcp_component.tcp_disable_family) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (addr.ss_family == AF_INET6 &amp;&amp; <span class="number">6</span> != mca_btl_tcp_component.tcp_disable_family) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果没找到就返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">        <span class="keyword">return</span> OPAL_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="type">int</span>) mca_btl_tcp_component.tcp_num_links; i++) &#123;</span><br><span class="line">        btl = (<span class="keyword">struct</span> <span class="type">mca_btl_tcp_module_t</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">mca_btl_tcp_module_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == btl) &#123;</span><br><span class="line">            <span class="keyword">return</span> OPAL_ERR_OUT_OF_RESOURCE;</span><br><span class="line">        &#125;</span><br><span class="line">        copied_interface = <span class="built_in">OBJ_NEW</span>(<span class="type">opal_if_t</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == copied_interface) &#123;</span><br><span class="line">            <span class="built_in">free</span>(btl);</span><br><span class="line">            <span class="keyword">return</span> OPAL_ERR_OUT_OF_RESOURCE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(btl, &amp;mca_btl_tcp_module, <span class="built_in">sizeof</span>(mca_btl_tcp_module));</span><br><span class="line">        <span class="built_in">OBJ_CONSTRUCT</span>(&amp;btl-&gt;tcp_endpoints, <span class="type">opal_list_t</span>);</span><br><span class="line">        <span class="built_in">OBJ_CONSTRUCT</span>(&amp;btl-&gt;tcp_endpoints_mutex, <span class="type">opal_mutex_t</span>);</span><br><span class="line">        mca_btl_tcp_component.tcp_btls[mca_btl_tcp_component.tcp_num_btls++] = btl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* initialize the btl */</span></span><br><span class="line">        <span class="comment">/* This index is used as a key for a hash table used for interface matching. */</span></span><br><span class="line">        btl-&gt;btl_index = mca_btl_tcp_component.tcp_num_btls - <span class="number">1</span>;</span><br><span class="line">        btl-&gt;tcp_ifkindex = (<span class="type">uint16_t</span>) if_kindex;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MCA_BTL_TCP_STATISTICS</span></span><br><span class="line">        btl-&gt;tcp_bytes_recv = <span class="number">0</span>;</span><br><span class="line">        btl-&gt;tcp_bytes_sent = <span class="number">0</span>;</span><br><span class="line">        btl-&gt;tcp_send_handler = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;btl-&gt;tcp_ifaddr, &amp;addr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage));</span><br><span class="line">        btl-&gt;tcp_ifmask = selected_interface-&gt;if_mask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* allow user to specify interface bandwidth */</span></span><br><span class="line">        <span class="built_in">sprintf</span>(param, <span class="string">&quot;bandwidth_%s&quot;</span>, if_name);</span><br><span class="line">        <span class="built_in">mca_btl_tcp_param_register_uint</span>(param, <span class="literal">NULL</span>, btl-&gt;super.btl_bandwidth, OPAL_INFO_LVL_5,</span><br><span class="line">                                        &amp;btl-&gt;super.btl_bandwidth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* allow user to override/specify latency ranking */</span></span><br><span class="line">        <span class="built_in">sprintf</span>(param, <span class="string">&quot;latency_%s&quot;</span>, if_name);</span><br><span class="line">        <span class="built_in">mca_btl_tcp_param_register_uint</span>(param, <span class="literal">NULL</span>, btl-&gt;super.btl_latency, OPAL_INFO_LVL_5,</span><br><span class="line">                                        &amp;btl-&gt;super.btl_latency);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            btl-&gt;super.btl_bandwidth &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            btl-&gt;super.btl_latency &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 注册一些参数 */</span></span><br><span class="line">        <span class="built_in">sprintf</span>(param, <span class="string">&quot;bandwidth_%s:%d&quot;</span>, if_name, i);</span><br><span class="line">        <span class="built_in">mca_btl_tcp_param_register_uint</span>(param, <span class="literal">NULL</span>, btl-&gt;super.btl_bandwidth, OPAL_INFO_LVL_5,</span><br><span class="line">                                        &amp;btl-&gt;super.btl_bandwidth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* allow user to override/specify latency ranking */</span></span><br><span class="line">        <span class="built_in">sprintf</span>(param, <span class="string">&quot;latency_%s:%d&quot;</span>, if_name, i);</span><br><span class="line">        <span class="built_in">mca_btl_tcp_param_register_uint</span>(param, <span class="literal">NULL</span>, btl-&gt;super.btl_latency, OPAL_INFO_LVL_5,</span><br><span class="line">                                        &amp;btl-&gt;super.btl_latency);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Only attempt to auto-detect bandwidth and/or latency if it is 0.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If detection fails to return anything other than 0, set a default</span></span><br><span class="line"><span class="comment">         * bandwidth and latency.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == btl-&gt;super.btl_bandwidth) &#123;</span><br><span class="line">            <span class="comment">// 如果能用ethtool 的话使用这个工具自动监测带宽</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> speed = <span class="built_in">opal_ethtool_get_speed</span>(if_name);</span><br><span class="line">            btl-&gt;super.btl_bandwidth = (speed == <span class="number">0</span>) ? MCA_BTL_TCP_BTL_BANDWIDTH : speed;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                btl-&gt;super.btl_bandwidth &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* We have no runtime btl latency detection mechanism. Just set a default. */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == btl-&gt;super.btl_latency) &#123;</span><br><span class="line">            btl-&gt;super.btl_latency = MCA_BTL_TCP_BTL_LATENCY;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                btl-&gt;super.btl_latency &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Add another entry to the local interface list */</span></span><br><span class="line">        <span class="built_in">opal_string_copy</span>(copied_interface-&gt;if_name, if_name, OPAL_IF_NAMESIZE);</span><br><span class="line">        copied_interface-&gt;if_index = if_index;</span><br><span class="line">        copied_interface-&gt;if_kernel_index = btl-&gt;tcp_ifkindex;</span><br><span class="line">        copied_interface-&gt;af_family = btl-&gt;tcp_ifaddr.ss_family;</span><br><span class="line">        copied_interface-&gt;if_flags = selected_interface-&gt;if_flags;</span><br><span class="line">        copied_interface-&gt;if_speed = selected_interface-&gt;if_speed;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;copied_interface-&gt;if_addr, &amp;btl-&gt;tcp_ifaddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr_storage));</span><br><span class="line">        copied_interface-&gt;if_mask = selected_interface-&gt;if_mask;</span><br><span class="line">        copied_interface-&gt;if_bandwidth = btl-&gt;super.btl_bandwidth;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;copied_interface-&gt;if_mac, &amp;selected_interface-&gt;if_mac,</span><br><span class="line">               <span class="built_in">sizeof</span>(copied_interface-&gt;if_mac));</span><br><span class="line">        copied_interface-&gt;ifmtu = selected_interface-&gt;ifmtu;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">opal_list_append</span>(&amp;mca_btl_tcp_component.local_ifs, &amp;(copied_interface-&gt;super));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OPAL_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当引擎发现socket有连接事件是，调用这个函数进行accept，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">int accept ( int s , struct sockaddr *addr , socklen_t *addrlen ) ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参数</span></span><br><span class="line"><span class="comment"> 1. s : 是服务器端通过调用正确调用socket -&gt; bind -&gt; listen 函数之后的用于指向存放多个客户端缓冲</span></span><br><span class="line"><span class="comment">        队列缓冲区的套接字描述符</span></span><br><span class="line"><span class="comment"> 2. addr : 是用来保存发起连接请求的主机的地址与端口的结构体变量，就是存放服务器接收请求</span></span><br><span class="line"><span class="comment">        的客户端的网络地址与端口的结构体变量</span></span><br><span class="line"><span class="comment">3.  addrlen: 用来传入第二个参数类型长度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">  如果函数执行正确的话，将会返回新的套接字描述符，用于指向与当前通信的客户端交换数据的缓冲区的套接字描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mca_btl_tcp_component_accept_handler</span><span class="params">(<span class="type">int</span> incoming_sd, <span class="type">short</span> ignored, <span class="type">void</span> *unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_ENABLE_IPV6</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> addr;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="type">opal_socklen_t</span> addrlen = <span class="built_in">sizeof</span>(addr);</span><br><span class="line"></span><br><span class="line">        <span class="type">mca_btl_tcp_event_t</span> *event;</span><br><span class="line">        <span class="type">int</span> sd = <span class="built_in">accept</span>(incoming_sd, (<span class="keyword">struct</span> sockaddr *) &amp;addr, &amp;addrlen);</span><br><span class="line">        <span class="keyword">if</span> (sd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (opal_socket_errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (opal_socket_errno != EAGAIN &amp;&amp; opal_socket_errno != EWOULDBLOCK) &#123;</span><br><span class="line">                <span class="built_in">opal_show_help</span>(<span class="string">&quot;help-mpi-btl-tcp.txt&quot;</span>, <span class="string">&quot;accept failed&quot;</span>, <span class="literal">true</span>,</span><br><span class="line">                               opal_process_info.nodename, <span class="built_in">getpid</span>(), opal_socket_errno,</span><br><span class="line">                               <span class="built_in">strerror</span>(opal_socket_errno));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">mca_btl_tcp_set_socket_options</span>(sd);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>(<span class="literal">NULL</span> != mca_btl_tcp_event_base);</span><br><span class="line">        <span class="comment">/* wait for receipt of peers process identifier to complete this connection */</span></span><br><span class="line">        event = <span class="built_in">OBJ_NEW</span>(<span class="type">mca_btl_tcp_event_t</span>);</span><br><span class="line">        <span class="built_in">opal_event_set</span>(mca_btl_tcp_event_base, &amp;(event-&gt;event), sd, OPAL_EV_READ,</span><br><span class="line">                       mca_btl_tcp_component_recv_handler, event);</span><br><span class="line">        <span class="built_in">opal_event_add</span>(&amp;event-&gt;event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Event callback when there is data available on the registered</span></span><br><span class="line"><span class="comment"> * socket to recv. This callback is triggered only once per lifetime</span></span><br><span class="line"><span class="comment"> * for any socket, in the beginning when we setup the handshake</span></span><br><span class="line"><span class="comment"> * protocol.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mca_btl_tcp_component_recv_handler</span><span class="params">(<span class="type">int</span> sd, <span class="type">short</span> flags, <span class="type">void</span> *user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">mca_btl_tcp_event_t</span> *event = (<span class="type">mca_btl_tcp_event_t</span> *) user;</span><br><span class="line">    <span class="type">opal_process_name_t</span> guid;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span> addr;</span><br><span class="line">    <span class="type">opal_socklen_t</span> addr_len = <span class="built_in">sizeof</span>(addr);</span><br><span class="line">    <span class="type">mca_btl_tcp_proc_t</span> *btl_proc;</span><br><span class="line">    <span class="type">bool</span> sockopt = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">size_t</span> retval, len = <span class="built_in">strlen</span>(mca_btl_tcp_magic_id_string);</span><br><span class="line">    <span class="type">mca_btl_tcp_endpoint_hs_msg_t</span> hs_msg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> save, tv;</span><br><span class="line">    <span class="type">socklen_t</span> rcvtimeo_save_len = <span class="built_in">sizeof</span>(save);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note, Socket will be in blocking mode during intial handshake</span></span><br><span class="line"><span class="comment">     * hence setting SO_RCVTIMEO to say 2 seconds here to avoid waiting</span></span><br><span class="line"><span class="comment">     * forever when connecting to older versions (that reply to the</span></span><br><span class="line"><span class="comment">     * handshake with only the guid) or when the remote side isn&#x27;t OMPI</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get the current timeout value so we can reset to it */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">getsockopt</span>(sd, SOL_SOCKET, SO_RCVTIMEO, (<span class="type">void</span> *) &amp;save, &amp;rcvtimeo_save_len)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ENOPROTOOPT == errno || EOPNOTSUPP == errno) &#123;</span><br><span class="line">            sockopt = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">opal_show_help</span>(<span class="string">&quot;help-mpi-btl-tcp.txt&quot;</span>, <span class="string">&quot;socket flag fail&quot;</span>, <span class="literal">true</span>,</span><br><span class="line">                           opal_process_info.nodename, <span class="built_in">getpid</span>(),</span><br><span class="line">                           <span class="string">&quot;getsockopt(sd, SOL_SOCKET, SO_RCVTIMEO, ...)&quot;</span>,</span><br><span class="line">                           <span class="built_in">strerror</span>(opal_socket_errno), opal_socket_errno);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tv.tv_sec = <span class="number">2</span>;</span><br><span class="line">        tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">setsockopt</span>(sd, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, <span class="built_in">sizeof</span>(tv))) &#123;</span><br><span class="line">            <span class="built_in">opal_show_help</span>(<span class="string">&quot;help-mpi-btl-tcp.txt&quot;</span>, <span class="string">&quot;socket flag fail&quot;</span>, <span class="literal">true</span>,</span><br><span class="line">                           opal_process_info.nodename, <span class="built_in">getpid</span>(),</span><br><span class="line">                           <span class="string">&quot;setsockopt(sd, SOL_SOCKET, SO_RCVTIMEO, ...)&quot;</span>,</span><br><span class="line">                           <span class="built_in">strerror</span>(opal_socket_errno), opal_socket_errno);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OBJ_RELEASE</span>(event);</span><br><span class="line">    retval = <span class="built_in">mca_btl_tcp_recv_blocking</span>(sd, (<span class="type">void</span> *) &amp;hs_msg, <span class="built_in">sizeof</span>(hs_msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 如果我们收到一条长度为零的消息，很可能我们同时连接到 Open MPI 对等进程 X，而对等方关闭了与我们的连接（有利于我们与它们的连接）。</span></span><br><span class="line"><span class="comment">     * 这不是错误 - 只需将其关闭并继续。</span></span><br><span class="line"><span class="comment">     * 同样，如果我们得到的字节数少于 sizeof(hs_msg)，它可能不是 Open MPI 对等体。</span></span><br><span class="line"><span class="comment">     * 但我们并不在意，因为对等方关闭了套接字。 所以只需关闭它并继续前进。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="built_in">sizeof</span>(hs_msg)) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *peer = <span class="built_in">opal_fd_get_peer_name</span>(sd);</span><br><span class="line">        <span class="built_in">opal_output_verbose</span>(</span><br><span class="line">            <span class="number">20</span>, opal_btl_base_framework.framework_output,</span><br><span class="line">            <span class="string">&quot;Peer %s closed socket without sending BTL TCP magic ID handshake (we received %d &quot;</span></span><br><span class="line">            <span class="string">&quot;bytes out of the expected %d) -- closing/ignoring this connection&quot;</span>,</span><br><span class="line">            peer, (<span class="type">int</span>) retval, (<span class="type">int</span>) <span class="built_in">sizeof</span>(hs_msg));</span><br><span class="line">        <span class="built_in">free</span>((<span class="type">char</span> *) peer);</span><br><span class="line">        <span class="built_in">CLOSE_THE_SOCKET</span>(sd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确认这个字符串是不是magic，来确认是不是openmpi的进程 */</span></span><br><span class="line">    guid = hs_msg.guid;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">strncmp</span>(hs_msg.magic_id, mca_btl_tcp_magic_id_string, len)) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *peer = <span class="built_in">opal_fd_get_peer_name</span>(sd);</span><br><span class="line">        <span class="built_in">opal_output_verbose</span>(</span><br><span class="line">            <span class="number">20</span>, opal_btl_base_framework.framework_output,</span><br><span class="line">            <span class="string">&quot;Peer %s send us an incorrect Open MPI magic ID string (i.e., this was not a &quot;</span></span><br><span class="line">            <span class="string">&quot;connection from the same version of Open MPI; expected \&quot;%s\&quot;, received \&quot;%s\&quot;)&quot;</span>,</span><br><span class="line">            peer, mca_btl_tcp_magic_id_string, hs_msg.magic_id);</span><br><span class="line">        <span class="built_in">free</span>((<span class="type">char</span> *) peer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The other side probably isn&#x27;t OMPI, so just hang up */</span></span><br><span class="line">        <span class="built_in">CLOSE_THE_SOCKET</span>(sd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sockopt) &#123;</span><br><span class="line">        <span class="comment">/* reset RECVTIMEO option to its original state */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != <span class="built_in">setsockopt</span>(sd, SOL_SOCKET, SO_RCVTIMEO, &amp;save, <span class="built_in">sizeof</span>(save))) &#123;</span><br><span class="line">            <span class="built_in">opal_show_help</span>(<span class="string">&quot;help-mpi-btl-tcp.txt&quot;</span>, <span class="string">&quot;socket flag fail&quot;</span>, <span class="literal">true</span>,</span><br><span class="line">                           opal_process_info.nodename, <span class="built_in">getpid</span>(),</span><br><span class="line">                           <span class="string">&quot;setsockopt(sd, SOL_SOCKET, SO_RCVTIMEO, ...)&quot;</span>,</span><br><span class="line">                           <span class="built_in">strerror</span>(opal_socket_errno), opal_socket_errno);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OPAL_PROCESS_NAME_NTOH</span>(guid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now set socket up to be non-blocking */</span></span><br><span class="line">    <span class="keyword">if</span> ((flags = <span class="built_in">fcntl</span>(sd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">opal_show_help</span>(<span class="string">&quot;help-mpi-btl-tcp.txt&quot;</span>, <span class="string">&quot;socket flag fail&quot;</span>, <span class="literal">true</span>, opal_process_info.nodename,</span><br><span class="line">                       <span class="built_in">getpid</span>(), <span class="string">&quot;fcntl(sd, F_GETFL, 0)&quot;</span>, <span class="built_in">strerror</span>(opal_socket_errno),</span><br><span class="line">                       opal_socket_errno);</span><br><span class="line">        <span class="built_in">CLOSE_THE_SOCKET</span>(sd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags |= O_NONBLOCK;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fcntl</span>(sd, F_SETFL, flags) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">opal_show_help</span>(<span class="string">&quot;help-mpi-btl-tcp.txt&quot;</span>, <span class="string">&quot;socket flag fail&quot;</span>, <span class="literal">true</span>,</span><br><span class="line">                           opal_process_info.nodename, <span class="built_in">getpid</span>(),</span><br><span class="line">                           <span class="string">&quot;fcntl(sd, F_SETFL, flags &amp; O_NONBLOCK)&quot;</span>, <span class="built_in">strerror</span>(opal_socket_errno),</span><br><span class="line">                           opal_socket_errno);</span><br><span class="line">            <span class="built_in">CLOSE_THE_SOCKET</span>(sd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lookup the corresponding process */</span></span><br><span class="line">    btl_proc = <span class="built_in">mca_btl_tcp_proc_lookup</span>(&amp;guid);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == btl_proc) &#123;</span><br><span class="line">        <span class="built_in">opal_show_help</span>(<span class="string">&quot;help-mpi-btl-tcp.txt&quot;</span>, <span class="string">&quot;server accept cannot find guid&quot;</span>, <span class="literal">true</span>,</span><br><span class="line">                       opal_process_info.nodename, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">CLOSE_THE_SOCKET</span>(sd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* lookup peer address */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getpeername</span>(sd, (<span class="keyword">struct</span> sockaddr *) &amp;addr, &amp;addr_len) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ENOTCONN != opal_socket_errno) &#123;</span><br><span class="line">            <span class="built_in">opal_show_help</span>(<span class="string">&quot;help-mpi-btl-tcp.txt&quot;</span>, <span class="string">&quot;server getpeername failed&quot;</span>, <span class="literal">true</span>,</span><br><span class="line">                           opal_process_info.nodename, <span class="built_in">getpid</span>(), <span class="built_in">strerror</span>(opal_socket_errno),</span><br><span class="line">                           opal_socket_errno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CLOSE_THE_SOCKET</span>(sd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* are there any existing peer instances willing to accept this connection */</span></span><br><span class="line">    (<span class="type">void</span>) <span class="built_in">mca_btl_tcp_proc_accept</span>(btl_proc, (<span class="keyword">struct</span> sockaddr *) &amp;addr, sd);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="built_in">opal_fd_get_peer_name</span>(sd);</span><br><span class="line">    <span class="built_in">opal_output_verbose</span>(<span class="number">10</span>, opal_btl_base_framework.framework_output,</span><br><span class="line">                        <span class="string">&quot;btl:tcp: now connected to %s, process %s&quot;</span>, str,</span><br><span class="line">                        <span class="built_in">OPAL_NAME_PRINT</span>(btl_proc-&gt;proc_opal-&gt;proc_name));</span><br><span class="line">    <span class="built_in">free</span>((<span class="type">char</span> *) str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="RDMA"><a href="#RDMA" class="headerlink" title="RDMA"></a>RDMA</h1><p>以下缕一下RDMA的执行过程。支持RDMA的数据结构如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief osc rdma component structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ompi_osc_rdma_component_t</span> &#123;</span><br><span class="line">    <span class="comment">/** Extend the basic osc component interface */</span></span><br><span class="line">    <span class="type">ompi_osc_base_component_t</span> super;</span><br><span class="line">    <span class="comment">/** lock access to modules */</span></span><br><span class="line">    <span class="type">opal_mutex_t</span> lock;</span><br><span class="line">    <span class="comment">/** cid -&gt; module mapping */</span></span><br><span class="line">    <span class="type">opal_hash_table_t</span> modules;</span><br><span class="line">    <span class="comment">/** free list of ompi_osc_rdma_frag_t structures */</span></span><br><span class="line">    <span class="type">opal_free_list_t</span> frags;</span><br><span class="line">    <span class="comment">/** Free list of requests */</span></span><br><span class="line">    <span class="type">opal_free_list_t</span> requests;</span><br><span class="line">    <span class="comment">/** RDMA component buffer size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> buffer_size;</span><br><span class="line">    <span class="comment">/** List of requests that need to be freed */</span></span><br><span class="line">    <span class="type">opal_list_t</span> request_gc;</span><br><span class="line">    <span class="comment">/** List of buffers that need to be freed */</span></span><br><span class="line">    <span class="type">opal_list_t</span> buffer_gc;</span><br><span class="line">    <span class="comment">/** Maximum number of segments that can be attached to a dynamic window */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_attach;</span><br><span class="line">    <span class="comment">/** Default value of the no_locks info key for new windows */</span></span><br><span class="line">    <span class="type">bool</span> no_locks;</span><br><span class="line">    <span class="comment">/** Locking mode to use as the default for all windows */</span></span><br><span class="line">    <span class="type">int</span> locking_mode;</span><br><span class="line">    <span class="comment">/** Accumulate operations will only operate on a single intrinsic datatype */</span></span><br><span class="line">    <span class="type">bool</span> acc_single_intrinsic;</span><br><span class="line">    <span class="comment">/** Use network AMOs when available */</span></span><br><span class="line">    <span class="type">bool</span> acc_use_amo;</span><br><span class="line">    <span class="comment">/** Priority of the osc/rdma component */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> priority;</span><br><span class="line">    <span class="comment">/** directory where to place backing files */</span></span><br><span class="line">    <span class="type">char</span> *backing_directory;</span><br><span class="line">    <span class="comment">/** maximum count for network AMO usage */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> network_amo_max_count;</span><br><span class="line">    <span class="comment">/** memory alignmen to be used for new windows */</span></span><br><span class="line">    <span class="type">size_t</span> memory_alignment;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ompi_osc_rdma_component_t</span> <span class="type">ompi_osc_rdma_component_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>每个 MPI 窗口都与单个 osc 模块相关联。 该结构存储与 osc/rdma 组件相关的数据。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ompi_osc_rdma_module_t</span> &#123;</span><br><span class="line">    <span class="comment">/** Extend the basic osc module interface */</span></span><br><span class="line">    <span class="type">ompi_osc_base_module_t</span> super;</span><br><span class="line">    <span class="comment">/** pointer back to MPI window */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ompi_win_t</span> *win;</span><br><span class="line">    <span class="comment">/** Mutex lock protecting module data */</span></span><br><span class="line">    <span class="type">opal_mutex_t</span> lock;</span><br><span class="line">    <span class="comment">/** locking mode to use */</span></span><br><span class="line">    <span class="type">int</span> locking_mode;</span><br><span class="line">    <span class="comment">/* window configuration */</span></span><br><span class="line">    <span class="comment">/** value of same_disp_unit info key for this window */</span></span><br><span class="line">    <span class="type">bool</span> same_disp_unit;</span><br><span class="line">    <span class="comment">/** value of same_size info key for this window */</span></span><br><span class="line">    <span class="type">bool</span> same_size;</span><br><span class="line">    <span class="comment">/** passive-target synchronization will not be used in this window */</span></span><br><span class="line">    <span class="type">bool</span> no_locks;</span><br><span class="line">    <span class="type">bool</span> acc_single_intrinsic;</span><br><span class="line">    <span class="type">bool</span> acc_use_amo;</span><br><span class="line">    <span class="comment">/** whether the group is located on a single node */</span></span><br><span class="line">    <span class="type">bool</span> single_node;</span><br><span class="line">    <span class="comment">/** flavor of this window */</span></span><br><span class="line">    <span class="type">int</span> flavor;</span><br><span class="line">    <span class="comment">/** size of local window */</span></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="comment">/** Local displacement unit. */</span></span><br><span class="line">    <span class="type">int</span> disp_unit;</span><br><span class="line">    <span class="comment">/** maximum count for network AMO usage */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> network_amo_max_count;</span><br><span class="line">    <span class="comment">/** global leader */</span></span><br><span class="line">    <span class="type">ompi_osc_rdma_peer_t</span> *leader;</span><br><span class="line">    <span class="comment">/** my peer structure */</span></span><br><span class="line">    <span class="type">ompi_osc_rdma_peer_t</span> *my_peer;</span><br><span class="line">    <span class="comment">/** pointer to free on cleanup (may be NULL) */</span></span><br><span class="line">    <span class="type">void</span> *free_after;</span><br><span class="line">    <span class="comment">/** local state structure (shared memory) */</span></span><br><span class="line">    <span class="type">ompi_osc_rdma_state_t</span> *state;</span><br><span class="line">    <span class="comment">/** node-level communication data (shared memory) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *node_comm_info;</span><br><span class="line">    <span class="comment">/* only relevant on the lowest rank on each node (shared memory) */</span></span><br><span class="line">    <span class="type">ompi_osc_rdma_rank_data_t</span> *rank_array;</span><br><span class="line">    <span class="comment">/** communicator created with this window.  This is the cid used</span></span><br><span class="line"><span class="comment">     * in the component&#x27;s modules mapping. */</span></span><br><span class="line">    <span class="type">ompi_communicator_t</span> *comm;</span><br><span class="line">    <span class="comment">/* temporary communicators for window initialization */</span></span><br><span class="line">    <span class="type">ompi_communicator_t</span> *local_leaders;</span><br><span class="line">    <span class="type">ompi_communicator_t</span> *shared_comm;</span><br><span class="line">    <span class="comment">/** node id of this rank */</span></span><br><span class="line">    <span class="type">int</span> node_id;</span><br><span class="line">    <span class="comment">/** number of nodes */</span></span><br><span class="line">    <span class="type">int</span> node_count;</span><br><span class="line">    <span class="comment">/** handle valid for local state (valid for local data for MPI_Win_allocate) */</span></span><br><span class="line">    <span class="type">mca_btl_base_registration_handle_t</span> *state_handle;</span><br><span class="line">    <span class="comment">/** registration handle for the window base (only used for MPI_Win_create) */</span></span><br><span class="line">    <span class="type">mca_btl_base_registration_handle_t</span> *base_handle;</span><br><span class="line">    <span class="comment">/** size of a region */</span></span><br><span class="line">    <span class="type">size_t</span> region_size;</span><br><span class="line">    <span class="comment">/** size of the state structure */</span></span><br><span class="line">    <span class="type">size_t</span> state_size;</span><br><span class="line">    <span class="comment">/** offset in the shared memory segment where the state array starts */</span></span><br><span class="line">    <span class="type">size_t</span> state_offset;</span><br><span class="line">    <span class="comment">/** memory alignmen to be used for new windows */</span></span><br><span class="line">    <span class="type">size_t</span> memory_alignment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ********************* sync data ************************ */</span></span><br><span class="line">    <span class="comment">/** global sync object (PSCW, fence, lock all) */</span></span><br><span class="line">    <span class="type">ompi_osc_rdma_sync_t</span> all_sync;</span><br><span class="line">    <span class="comment">/** current group associate with pscw exposure epoch */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ompi_group_t</span> *pw_group;</span><br><span class="line">    <span class="comment">/** list of unmatched post messages */</span></span><br><span class="line">    <span class="type">opal_list_t</span>        pending_posts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ********************* LOCK data ************************ */</span></span><br><span class="line">    <span class="comment">/** number of outstanding locks */</span></span><br><span class="line">    <span class="type">osc_rdma_counter_t</span> passive_target_access_epoch;</span><br><span class="line">    <span class="comment">/** origin side list of locks currently outstanding */</span></span><br><span class="line">    <span class="type">opal_hash_table_t</span> outstanding_locks;</span><br><span class="line">    <span class="comment">/** array of locks (small jobs) */</span></span><br><span class="line">    <span class="type">ompi_osc_rdma_sync_t</span> **outstanding_lock_array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ******************* peer storage *********************** */</span></span><br><span class="line">    <span class="comment">/** hash table of allocated peers */</span></span><br><span class="line">    <span class="type">opal_hash_table_t</span> peer_hash;</span><br><span class="line">    <span class="comment">/** array of allocated peers (small jobs) */</span></span><br><span class="line">    <span class="type">ompi_osc_rdma_peer_t</span> **peer_array;</span><br><span class="line">    <span class="comment">/** lock for peer hash table/array */</span></span><br><span class="line">    <span class="type">opal_mutex_t</span> peer_lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ******************* communication *********************** */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 我们目前支持两种操作模式，一个加速 btl（可以使用内存注册，可以使用 btl_flush() 和一个或多个备用 btl，</span></span><br><span class="line"><span class="comment">     * 它不能使用 flush() 或依赖内存注册。因为它是一个非此即彼的 情况下，我们使用联合来简化代码。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> use_accelerated_btl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="type">mca_btl_base_module_t</span> *accelerated_btl;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="type">mca_btl_base_am_rdma_module_t</span> **alternate_am_rdmas;</span><br><span class="line">            <span class="type">uint8_t</span> alternate_btl_count;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 选择的 BTL 是否需要内存注册？ 使用备用 BTL 时该字段为 false，使用加速 BTL 时的值取决于底层 BTL 的注册要求。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span> use_memory_registration;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> put_alignment;</span><br><span class="line">    <span class="type">size_t</span> get_alignment;</span><br><span class="line">    <span class="type">size_t</span> put_limit;</span><br><span class="line">    <span class="type">size_t</span> get_limit;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> atomic_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** registered fragment used for locally buffered RDMA transfers */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ompi_osc_rdma_frag_t</span> *rdma_frag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** registration handles for dynamically attached regions. These are not stored</span></span><br><span class="line"><span class="comment">     * in the state structure as it is entirely local. */</span></span><br><span class="line">    <span class="type">ompi_osc_rdma_handle_t</span> **dynamic_handles;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 共享内存段。 </span></span><br><span class="line"><span class="comment">     * 此段包含此节点的排名部分 -&gt; 节点映射数组、节点通信数据 (node_comm_info)、</span></span><br><span class="line"><span class="comment">     * 所有本地排名的状态和所有本地排名的数据（仅限 MPI_Win_allocate）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span> *segment_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** opal shared memory structure for the shared memory segment */</span></span><br><span class="line">    <span class="type">opal_shmem_ds_t</span> seg_ds;</span><br><span class="line">    <span class="comment">/* performance values */</span></span><br><span class="line">    <span class="comment">/** number of times a put had to be retried */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> put_retry_count;</span><br><span class="line">    <span class="comment">/** number of time a get had to be retried */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> get_retry_count;</span><br><span class="line">    <span class="comment">/** outstanding atomic operations */</span></span><br><span class="line">    <span class="type">opal_atomic_int32_t</span> pending_ops;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这是rdma相关的一些函数，主要看<code>ompi_osc_rdma_get</code>和<code>ompi_osc_rdma_put</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ompi_osc_base_module_t</span> ompi_osc_rdma_module_rdma_template = &#123;</span><br><span class="line">    .osc_win_attach = ompi_osc_rdma_attach,</span><br><span class="line">    .osc_win_detach  = ompi_osc_rdma_detach,</span><br><span class="line">    .osc_free = ompi_osc_rdma_free,</span><br><span class="line"></span><br><span class="line">    .osc_put = ompi_osc_rdma_put,</span><br><span class="line">    .osc_get = ompi_osc_rdma_get,</span><br><span class="line">    .osc_accumulate = ompi_osc_rdma_accumulate,</span><br><span class="line">    .osc_compare_and_swap = ompi_osc_rdma_compare_and_swap,</span><br><span class="line">    .osc_fetch_and_op = ompi_osc_rdma_fetch_and_op,</span><br><span class="line">    .osc_get_accumulate = ompi_osc_rdma_get_accumulate,</span><br><span class="line"></span><br><span class="line">    .osc_rput = ompi_osc_rdma_rput,</span><br><span class="line">    .osc_rget = ompi_osc_rdma_rget,</span><br><span class="line">    .osc_raccumulate = ompi_osc_rdma_raccumulate,</span><br><span class="line">    .osc_rget_accumulate = ompi_osc_rdma_rget_accumulate,</span><br><span class="line"></span><br><span class="line">    .osc_fence = ompi_osc_rdma_fence_atomic,</span><br><span class="line"></span><br><span class="line">    .osc_start = ompi_osc_rdma_start_atomic,</span><br><span class="line">    .osc_complete = ompi_osc_rdma_complete_atomic,</span><br><span class="line">    .osc_post = ompi_osc_rdma_post_atomic,</span><br><span class="line">    .osc_wait = ompi_osc_rdma_wait_atomic,</span><br><span class="line">    .osc_test = ompi_osc_rdma_test_atomic,</span><br><span class="line"></span><br><span class="line">    .osc_lock = ompi_osc_rdma_lock_atomic,</span><br><span class="line">    .osc_unlock = ompi_osc_rdma_unlock_atomic,</span><br><span class="line">    .osc_lock_all = ompi_osc_rdma_lock_all_atomic,</span><br><span class="line">    .osc_unlock_all = ompi_osc_rdma_unlock_all_atomic,</span><br><span class="line"></span><br><span class="line">    .osc_sync = ompi_osc_rdma_sync,</span><br><span class="line">    .osc_flush = ompi_osc_rdma_flush,</span><br><span class="line">    .osc_flush_all = ompi_osc_rdma_flush_all,</span><br><span class="line">    .osc_flush_local = ompi_osc_rdma_flush_local,</span><br><span class="line">    .osc_flush_local_all = ompi_osc_rdma_flush_local_all,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>ompi_osc_rdma_get</code>输出一些log后，查找跟当前的source_rank相关的结构，之后的数据从source_rank里拿。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_osc_rdma_get</span> <span class="params">(<span class="type">void</span> *origin_addr, <span class="type">int</span> origin_count, <span class="type">ompi_datatype_t</span> *origin_datatype,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">int</span> source_rank, <span class="type">ptrdiff_t</span> source_disp, <span class="type">int</span> source_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">ompi_datatype_t</span> *source_datatype, <span class="type">ompi_win_t</span> *win)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ompi_osc_rdma_module_t</span> *<span class="keyword">module</span> = <span class="built_in">GET_MODULE</span>(win);</span><br><span class="line">    <span class="type">ompi_osc_rdma_peer_t</span> *peer;</span><br><span class="line">    <span class="type">ompi_osc_rdma_sync_t</span> *sync;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OSC_RDMA_VERBOSE</span>(MCA_BASE_VERBOSE_TRACE, <span class="string">&quot;get: 0x%lx, %d, %s, %d, %d, %d, %s, %s&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>) origin_addr,</span><br><span class="line">                     origin_count, origin_datatype-&gt;name, source_rank, (<span class="type">int</span>) source_disp, source_count,</span><br><span class="line">                     source_datatype-&gt;name, win-&gt;w_name);</span><br><span class="line"></span><br><span class="line">    sync = <span class="built_in">ompi_osc_rdma_module_sync_lookup</span> (<span class="keyword">module</span>, source_rank, &amp;peer);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_UNLIKELY</span>(<span class="literal">NULL</span> == sync)) &#123;</span><br><span class="line">        <span class="keyword">return</span> OMPI_ERR_RMA_SYNC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ompi_osc_rdma_get_w_req</span> (sync, origin_addr, origin_count, origin_datatype, peer,</span><br><span class="line">                                    source_disp, source_count, source_datatype, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">ompi_osc_rdma_get_w_req</span> <span class="params">(<span class="type">ompi_osc_rdma_sync_t</span> *sync, <span class="type">void</span> *origin_addr, <span class="type">int</span> origin_count, <span class="type">ompi_datatype_t</span> *origin_datatype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">ompi_osc_rdma_peer_t</span> *peer, <span class="type">ptrdiff_t</span> source_disp, <span class="type">int</span> source_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">ompi_datatype_t</span> *source_datatype, <span class="type">ompi_osc_rdma_request_t</span> *request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ompi_osc_rdma_module_t</span> *<span class="keyword">module</span> = sync-&gt;<span class="keyword">module</span>;</span><br><span class="line">    <span class="type">mca_btl_base_registration_handle_t</span> *source_handle;</span><br><span class="line">    <span class="type">uint64_t</span> source_address;</span><br><span class="line">    <span class="type">ptrdiff_t</span> source_span, source_lb;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* short-circuit case */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == origin_count || <span class="number">0</span> == source_count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (request) &#123;</span><br><span class="line">            <span class="comment">// 释放结构，直接返回</span></span><br><span class="line">            <span class="built_in">ompi_osc_rdma_request_complete</span> (request, MPI_SUCCESS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> OMPI_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算 count 个数据类型在内存中的跨度。</span></span><br><span class="line"><span class="comment">     * 此函数有助于为接收已键入的数据（例如用于 reduce 操作的数据）分配临时内存。</span></span><br><span class="line"><span class="comment">     * 这个跨度是 count 数据类型的内存布局中最小和最大字节之间的距离，</span></span><br><span class="line"><span class="comment">     * 换句话说，分配 count 所需的内存乘以数据类型，在开始和结束时没有间隙。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    source_span = <span class="built_in">opal_datatype_span</span>(&amp;source_datatype-&gt;super, source_count, &amp;source_lb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到与内存区域关联的远程段，返回的是远端地址</span></span><br><span class="line">    ret = <span class="built_in">osc_rdma_get_remote_segment</span> (<span class="keyword">module</span>, peer, source_disp, source_span+source_lb,</span><br><span class="line">                                       &amp;source_address, &amp;source_handle);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_UNLIKELY</span>(OMPI_SUCCESS != ret)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* optimize self/local communication */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ompi_osc_rdma_peer_local_base</span> (peer)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ompi_osc_rdma_copy_local</span> ((<span class="type">void</span> *) (<span class="type">intptr_t</span>) source_address, source_count, source_datatype,</span><br><span class="line">                                         origin_addr, origin_count, origin_datatype, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ompi_osc_rdma_master</span> (sync, origin_addr, origin_count, origin_datatype, peer, source_address,</span><br><span class="line">                                 source_handle, source_count, source_datatype, request,</span><br><span class="line">                                 <span class="keyword">module</span>-&gt;get_limit, ompi_osc_rdma_get_contig, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">osc_rdma_get_remote_segment</span> <span class="params">(<span class="type">ompi_osc_rdma_module_t</span> *<span class="keyword">module</span>, <span class="type">ompi_osc_rdma_peer_t</span> *peer, <span class="type">ptrdiff_t</span> target_disp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">size_t</span> length, <span class="type">uint64_t</span> *remote_address, <span class="type">mca_btl_base_registration_handle_t</span> **remote_handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ompi_osc_rdma_region_t</span> *region;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MPI_WIN_FLAVOR_DYNAMIC == <span class="keyword">module</span>-&gt;flavor) &#123;</span><br><span class="line">        ret = <span class="built_in">ompi_osc_rdma_find_dynamic_region</span> (<span class="keyword">module</span>, peer, (<span class="type">uint64_t</span>) target_disp, length, &amp;region);</span><br><span class="line">        <span class="keyword">if</span> (OMPI_SUCCESS != ret) &#123;</span><br><span class="line">            <span class="built_in">OSC_RDMA_VERBOSE</span>(MCA_BASE_VERBOSE_INFO, <span class="string">&quot;could not retrieve region for %&quot;</span> PRIx64 <span class="string">&quot; from window rank %d&quot;</span>,</span><br><span class="line">                             (<span class="type">uint64_t</span>) target_disp, peer-&gt;rank);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *remote_address = (<span class="type">uint64_t</span>) target_disp;</span><br><span class="line">        *remote_handle = (<span class="type">mca_btl_base_registration_handle_t</span> *) region-&gt;btl_handle_data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">ompi_osc_rdma_peer_extended_t</span> *ex_peer = (<span class="type">ompi_osc_rdma_peer_extended_t</span> *) peer;</span><br><span class="line">        <span class="type">int</span> disp_unit = (<span class="keyword">module</span>-&gt;same_disp_unit) ? <span class="keyword">module</span>-&gt;disp_unit : ex_peer-&gt;disp_unit;</span><br><span class="line">        <span class="type">size_t</span> size = (<span class="keyword">module</span>-&gt;same_size) ? <span class="keyword">module</span>-&gt;size : (<span class="type">size_t</span>) ex_peer-&gt;size;</span><br><span class="line"></span><br><span class="line">        *remote_address = ex_peer-&gt;super.base + disp_unit * target_disp;</span><br><span class="line">        *remote_handle = ex_peer-&gt;super.base_handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OMPI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_osc_rdma_find_dynamic_region</span> <span class="params">(<span class="type">ompi_osc_rdma_module_t</span> *<span class="keyword">module</span>, <span class="type">ompi_osc_rdma_peer_t</span> *peer, <span class="type">uint64_t</span> base, <span class="type">size_t</span> len,</span></span></span><br><span class="line"><span class="params"><span class="function">				       <span class="type">ompi_osc_rdma_region_t</span> **region)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ompi_osc_rdma_peer_dynamic_t</span> *dy_peer = (<span class="type">ompi_osc_rdma_peer_dynamic_t</span> *) peer;</span><br><span class="line">    <span class="type">intptr_t</span> bound = (<span class="type">intptr_t</span>) base + len;</span><br><span class="line">    <span class="type">ompi_osc_rdma_region_t</span> *regions;</span><br><span class="line">    <span class="type">int</span> ret = OMPI_SUCCESS, region_count;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OSC_RDMA_VERBOSE</span>(MCA_BASE_VERBOSE_TRACE, <span class="string">&quot;locating dynamic memory region matching: &#123;%&quot;</span> PRIx64 <span class="string">&quot;, %&quot;</span> PRIx64 <span class="string">&quot;&#125;&quot;</span></span><br><span class="line">                     <span class="string">&quot; (len %lu)&quot;</span>, base, base + len, (<span class="type">unsigned</span> <span class="type">long</span>) len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OPAL_THREAD_LOCK</span>(&amp;<span class="keyword">module</span>-&gt;lock);</span><br><span class="line">    <span class="comment">// 需要看一些这个区域没有被加锁，获得一个排他锁，如果拿不到就一直循环等着</span></span><br><span class="line">    <span class="built_in">ompi_osc_rdma_lock_acquire_exclusive</span> (<span class="keyword">module</span>, peer, <span class="built_in">offsetof</span> (<span class="type">ompi_osc_rdma_state_t</span>, regions_lock));</span><br><span class="line">    <span class="comment">// 这个区域不是本地的区域</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ompi_osc_rdma_peer_local_state</span> (peer)) &#123;</span><br><span class="line">        ret = <span class="built_in">ompi_osc_rdma_refresh_dynamic_region</span> (<span class="keyword">module</span>, dy_peer);</span><br><span class="line">            <span class="comment">/* 此函数的作用是本地的远程进程视图与远程窗口的内容保持同步。</span></span><br><span class="line"><span class="comment">             * 每次地址转换都会调用它，因为（当前）无法检测到附加区域是否已更改。</span></span><br><span class="line"><span class="comment">             * 为了减少读取的数据量，我们首先读取区域计数（其中包含一个 id）。</span></span><br><span class="line"><span class="comment">             * 如果这没有改变，则区域数据不会更新。</span></span><br><span class="line"><span class="comment">             * 如果附加区域列表已更改，则从对等方读取所有有效区域，同时保持其区域锁定。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (OMPI_SUCCESS != ret) &#123;</span><br><span class="line">            <span class="built_in">ompi_osc_rdma_lock_release_exclusive</span> (<span class="keyword">module</span>, peer, <span class="built_in">offsetof</span> (<span class="type">ompi_osc_rdma_state_t</span>, regions_lock));</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        regions = dy_peer-&gt;regions;</span><br><span class="line">        region_count = dy_peer-&gt;region_count;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">ompi_osc_rdma_state_t</span> *peer_state = (<span class="type">ompi_osc_rdma_state_t</span> *) peer-&gt;state;</span><br><span class="line">        regions = (<span class="type">ompi_osc_rdma_region_t</span> *) peer_state-&gt;regions;</span><br><span class="line">        region_count = peer_state-&gt;region_count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从排好序的regions里找到一个符合base地址+bound范围的块</span></span><br><span class="line">    <span class="comment">// 使用二分法在0到region_count-1范围内找</span></span><br><span class="line">    *region = <span class="built_in">ompi_osc_rdma_find_region_containing</span> (regions, <span class="number">0</span>, region_count - <span class="number">1</span>, (<span class="type">intptr_t</span>) base, bound, <span class="keyword">module</span>-&gt;region_size, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!*region) &#123;</span><br><span class="line">        ret = OMPI_ERR_RMA_RANGE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">OPAL_THREAD_UNLOCK</span>(&amp;<span class="keyword">module</span>-&gt;lock);</span><br><span class="line">    <span class="built_in">ompi_osc_rdma_lock_release_exclusive</span> (<span class="keyword">module</span>, peer, <span class="built_in">offsetof</span> (<span class="type">ompi_osc_rdma_state_t</span>, regions_lock));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* round a matching region */</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>根据这个要获得的区域在本地或者远端，分别调用两个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ompi_osc_rdma_copy_local</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *source, <span class="type">int</span> source_count, <span class="type">ompi_datatype_t</span> *source_datatype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">void</span> *target, <span class="type">int</span> target_count, <span class="type">ompi_datatype_t</span> *target_datatype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="type">ompi_osc_rdma_request_t</span> *request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OSC_RDMA_VERBOSE</span>(MCA_BASE_VERBOSE_TRACE, <span class="string">&quot;performing local copy from %p -&gt; %p&quot;</span>, source, target);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">opal_atomic_mb</span> ();</span><br><span class="line">    ret = <span class="built_in">ompi_datatype_sndrcv</span> (source, source_count, source_datatype, target, target_count, target_datatype);</span><br><span class="line">    <span class="comment">// 处理pack和unpack，或者直接复制</span></span><br><span class="line">    <span class="keyword">if</span> (request) &#123;</span><br><span class="line">        <span class="built_in">ompi_osc_rdma_request_complete</span> (request, ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">ompi_osc_rdma_master</span> <span class="params">(<span class="type">ompi_osc_rdma_sync_t</span> *sync, <span class="type">void</span> *local_address, <span class="type">int</span> local_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">ompi_datatype_t</span> *local_datatype, <span class="type">ompi_osc_rdma_peer_t</span> *peer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint64_t</span> remote_address, <span class="type">mca_btl_base_registration_handle_t</span> *remote_handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">int</span> remote_count, <span class="type">ompi_datatype_t</span> *remote_datatype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">ompi_osc_rdma_request_t</span> *request, <span class="type">const</span> <span class="type">size_t</span> max_rdma_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> <span class="type">ompi_osc_rdma_fn_t</span> rdma_fn, <span class="type">const</span> <span class="type">bool</span> alloc_reqs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> rdma_len;</span><br><span class="line">    <span class="type">ptrdiff_t</span> lb, extent;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    rdma_len = local_datatype-&gt;super.size * local_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fast path for contiguous rdma */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_LIKELY</span>(<span class="built_in">ompi_datatype_is_contiguous_memory_layout</span> (local_datatype, local_count) &amp;&amp;</span><br><span class="line">                    <span class="built_in">ompi_datatype_is_contiguous_memory_layout</span> (remote_datatype, remote_count) &amp;&amp;</span><br><span class="line">                    rdma_len &lt;= max_rdma_len)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == request &amp;&amp; alloc_reqs) &#123;</span><br><span class="line">            <span class="type">ompi_osc_rdma_module_t</span> *<span class="keyword">module</span> = sync-&gt;<span class="keyword">module</span>;</span><br><span class="line">            <span class="built_in">OMPI_OSC_RDMA_REQUEST_ALLOC</span>(<span class="keyword">module</span>, peer, request);</span><br><span class="line">            request-&gt;internal = <span class="literal">true</span>;</span><br><span class="line">            request-&gt;type = OMPI_OSC_RDMA_TYPE_RDMA;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ignore failure here */</span></span><br><span class="line">        (<span class="type">void</span>) <span class="built_in">ompi_datatype_get_true_extent</span> (local_datatype, &amp;lb, &amp;extent);</span><br><span class="line">        local_address = (<span class="type">void</span> *)((<span class="type">intptr_t</span>) local_address + lb);</span><br><span class="line"></span><br><span class="line">        (<span class="type">void</span>) <span class="built_in">ompi_datatype_get_true_extent</span> (remote_datatype, &amp;lb, &amp;extent);</span><br><span class="line">        remote_address += lb;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">OSC_RDMA_VERBOSE</span>(MCA_BASE_VERBOSE_TRACE, <span class="string">&quot;performing rdma on contiguous region. local: %p, &quot;</span></span><br><span class="line">                         <span class="string">&quot;remote: 0x%lx, length: %lu&quot;</span>, local_address, (<span class="type">unsigned</span> <span class="type">long</span>) remote_address,</span><br><span class="line">                         rdma_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ret = <span class="built_in">rdma_fn</span> (sync, peer, remote_address, remote_handle, local_address, rdma_len, request);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">OPAL_LIKELY</span>(OPAL_SUCCESS == ret)) &#123;</span><br><span class="line">                <span class="keyword">return</span> OMPI_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">ompi_osc_rdma_progress</span> (sync-&gt;<span class="keyword">module</span>);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ompi_osc_rdma_master_noncontig</span> (sync, local_address, local_count, local_datatype, peer, remote_address,</span><br><span class="line">                                           remote_handle, remote_count, remote_datatype, request,</span><br><span class="line">                                           max_rdma_len, rdma_fn, alloc_reqs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将 rdma 事务分解为连续区域</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[in] local_address    base of local region (source for put, destination for get)</span></span><br><span class="line"><span class="comment"> * @param[in] local_count      number of elements in local region</span></span><br><span class="line"><span class="comment"> * @param[in] local_datatype   datatype of local region</span></span><br><span class="line"><span class="comment"> * @param[in] peer             peer object for remote peer</span></span><br><span class="line"><span class="comment"> * @param[in] remote_address   base of remote region (destination for put, source for get)</span></span><br><span class="line"><span class="comment"> * @param[in] remote_handle    btl registration handle for remote region (must be valid for the entire region)</span></span><br><span class="line"><span class="comment"> * @param[in] remote_count     number of elements in remote region</span></span><br><span class="line"><span class="comment"> * @param[in] remote_datatype  datatype of remote region</span></span><br><span class="line"><span class="comment"> * @param[in] module           osc rdma module</span></span><br><span class="line"><span class="comment"> * @param[in] request          osc rdma request if used (can be NULL)</span></span><br><span class="line"><span class="comment"> * @param[in] max_rdma_len     maximum length of an rdma request (usually btl limitation)</span></span><br><span class="line"><span class="comment"> * @param[in] rdma_fn          function to use for contiguous rdma operations</span></span><br><span class="line"><span class="comment"> * @param[in] alloc_reqs       true if rdma_fn requires a valid request object (any allocated objects will be marked internal)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function does the work of breaking a non-contiguous rdma transfer into contiguous components. It will</span></span><br><span class="line"><span class="comment"> * continue to submit rdma transfers until the entire region is transferred or a fatal error occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ompi_osc_rdma_master_noncontig</span> <span class="params">(<span class="type">ompi_osc_rdma_sync_t</span> *sync, <span class="type">void</span> *local_address, <span class="type">int</span> local_count, <span class="type">ompi_datatype_t</span> *local_datatype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">ompi_osc_rdma_peer_t</span> *peer, <span class="type">uint64_t</span> remote_address,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">mca_btl_base_registration_handle_t</span> *remote_handle, <span class="type">int</span> remote_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">ompi_datatype_t</span> *remote_datatype, <span class="type">ompi_osc_rdma_request_t</span> *request, <span class="type">const</span> <span class="type">size_t</span> max_rdma_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">const</span> <span class="type">ompi_osc_rdma_fn_t</span> rdma_fn, <span class="type">const</span> <span class="type">bool</span> alloc_reqs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ompi_osc_rdma_module_t</span> *<span class="keyword">module</span> = sync-&gt;<span class="keyword">module</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> local_iovec[OMPI_OSC_RDMA_DECODE_MAX], remote_iovec[OMPI_OSC_RDMA_DECODE_MAX];</span><br><span class="line">    <span class="type">opal_convertor_t</span> local_convertor, remote_convertor;</span><br><span class="line">    <span class="type">uint32_t</span> local_iov_count, remote_iov_count;</span><br><span class="line">    <span class="type">uint32_t</span> local_iov_index, remote_iov_index;</span><br><span class="line">    <span class="comment">/* needed for opal_convertor_raw but not used */</span></span><br><span class="line">    <span class="type">size_t</span> local_size, remote_size, rdma_len;</span><br><span class="line">    <span class="type">ompi_osc_rdma_request_t</span> *subreq;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">bool</span> done;</span><br><span class="line"></span><br><span class="line">    subreq = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OSC_RDMA_VERBOSE</span>(MCA_BASE_VERBOSE_TRACE, <span class="string">&quot;scheduling rdma on non-contiguous datatype(s) or large region&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* prepare convertors for the source and target. these convertors will be used to determine the</span></span><br><span class="line"><span class="comment">     * contiguous segments within the source and target. */</span></span><br><span class="line">    <span class="built_in">OBJ_CONSTRUCT</span>(&amp;remote_convertor, <span class="type">opal_convertor_t</span>);</span><br><span class="line">    ret = <span class="built_in">opal_convertor_copy_and_prepare_for_send</span> (ompi_mpi_local_convertor, &amp;remote_datatype-&gt;super, remote_count,</span><br><span class="line">                                                    (<span class="type">void</span> *) (<span class="type">intptr_t</span>) remote_address, <span class="number">0</span>, &amp;remote_convertor);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_UNLIKELY</span>(OMPI_SUCCESS != ret)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OBJ_CONSTRUCT</span>(&amp;local_convertor, <span class="type">opal_convertor_t</span>);</span><br><span class="line">    ret = <span class="built_in">opal_convertor_copy_and_prepare_for_send</span> (ompi_mpi_local_convertor, &amp;local_datatype-&gt;super, local_count,</span><br><span class="line">                                                    local_address, <span class="number">0</span>, &amp;local_convertor);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_UNLIKELY</span>(OMPI_SUCCESS != ret)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以上是转换器转换压缩</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request) &#123;</span><br><span class="line">        <span class="comment">/* keep the request from completing until all the transfers have started */</span></span><br><span class="line">        request-&gt;outstanding_requests = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    local_iov_index = <span class="number">0</span>;</span><br><span class="line">    local_iov_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* decode segments of the remote data */</span></span><br><span class="line">        remote_iov_count = OMPI_OSC_RDMA_DECODE_MAX;</span><br><span class="line">        remote_iov_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* opal_convertor_raw returns true when it has reached the end of the data */</span></span><br><span class="line">        done = <span class="built_in">opal_convertor_raw</span> (&amp;remote_convertor, remote_iovec, &amp;remote_iov_count, &amp;remote_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* loop on the target segments until we have exhaused the decoded source data */</span></span><br><span class="line">        <span class="keyword">while</span> (remote_iov_index != remote_iov_count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (local_iov_index == local_iov_count) &#123;</span><br><span class="line">                <span class="comment">/* decode segments of the target buffer */</span></span><br><span class="line">                local_iov_count = OMPI_OSC_RDMA_DECODE_MAX;</span><br><span class="line">                local_iov_index = <span class="number">0</span>;</span><br><span class="line">                (<span class="type">void</span>) <span class="built_in">opal_convertor_raw</span> (&amp;local_convertor, local_iovec, &amp;local_iov_count, &amp;local_size);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* we already checked that the target was large enough. this should be impossible */</span></span><br><span class="line">            <span class="built_in">assert</span> (<span class="number">0</span> != local_iov_count);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* determine how much to transfer in this operation */</span></span><br><span class="line">            rdma_len = <span class="built_in">opal_min</span>(<span class="built_in">opal_min</span>(local_iovec[local_iov_index].iov_len, remote_iovec[remote_iov_index].iov_len), max_rdma_len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* execute the get */</span></span><br><span class="line">            <span class="keyword">if</span> (!subreq &amp;&amp; alloc_reqs) &#123;</span><br><span class="line">                <span class="built_in">OMPI_OSC_RDMA_REQUEST_ALLOC</span>(<span class="keyword">module</span>, peer, subreq);</span><br><span class="line">                subreq-&gt;internal = <span class="literal">true</span>;</span><br><span class="line">                subreq-&gt;type = OMPI_OSC_RDMA_TYPE_RDMA;</span><br><span class="line">                subreq-&gt;parent_request = request;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (request) &#123;</span><br><span class="line">                    (<span class="type">void</span>) <span class="built_in">OPAL_THREAD_ADD_FETCH32</span> (&amp;request-&gt;outstanding_requests, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!alloc_reqs) &#123;</span><br><span class="line">                subreq = request;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret = <span class="built_in">rdma_fn</span> (sync, peer, (<span class="type">uint64_t</span>) (<span class="type">intptr_t</span>) remote_iovec[remote_iov_index].iov_base, remote_handle,</span><br><span class="line">                           local_iovec[local_iov_index].iov_base, rdma_len, subreq);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">OPAL_UNLIKELY</span>(OMPI_SUCCESS != ret)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">OPAL_UNLIKELY</span>(OMPI_ERR_OUT_OF_RESOURCE != ret)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (request) &#123;</span><br><span class="line">                        <span class="built_in">ompi_osc_rdma_request_deref</span> (request);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (alloc_reqs) &#123;</span><br><span class="line">                        <span class="built_in">OMPI_OSC_RDMA_REQUEST_RETURN</span>(subreq);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* something bad happened. need to figure out best way to handle rma errors */</span></span><br><span class="line">                    <span class="keyword">return</span> ret;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* progress and try again */</span></span><br><span class="line">                <span class="built_in">ompi_osc_rdma_progress</span> (<span class="keyword">module</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            subreq = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* adjust io vectors */</span></span><br><span class="line">            local_iovec[local_iov_index].iov_len -= rdma_len;</span><br><span class="line">            remote_iovec[remote_iov_index].iov_len -= rdma_len;</span><br><span class="line">            local_iovec[local_iov_index].iov_base = (<span class="type">void</span> *)((<span class="type">intptr_t</span>) local_iovec[local_iov_index].iov_base + rdma_len);</span><br><span class="line">            remote_iovec[remote_iov_index].iov_base = (<span class="type">void</span> *)((<span class="type">intptr_t</span>) remote_iovec[remote_iov_index].iov_base + rdma_len);</span><br><span class="line"></span><br><span class="line">            local_iov_index += (<span class="number">0</span> == local_iovec[local_iov_index].iov_len);</span><br><span class="line">            remote_iov_index += (<span class="number">0</span> == remote_iovec[remote_iov_index].iov_len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!done);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request) &#123;</span><br><span class="line">        <span class="comment">/* release our reference so the request can complete */</span></span><br><span class="line">        <span class="built_in">ompi_osc_rdma_request_deref</span> (request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OSC_RDMA_VERBOSE</span>(MCA_BASE_VERBOSE_TRACE, <span class="string">&quot;finished scheduling rdma on non-contiguous datatype(s)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* clean up convertors */</span></span><br><span class="line">    <span class="built_in">opal_convertor_cleanup</span> (&amp;local_convertor);</span><br><span class="line">    <span class="built_in">OBJ_DESTRUCT</span>(&amp;local_convertor);</span><br><span class="line">    <span class="built_in">opal_convertor_cleanup</span> (&amp;remote_convertor);</span><br><span class="line">    <span class="built_in">OBJ_DESTRUCT</span>(&amp;remote_convertor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OMPI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="UCX"><a href="#UCX" class="headerlink" title="UCX"></a>UCX</h1><p>因为在之前的报错里看到过UCX的字样，所以跟了一下<code>mca_pml_ucx_send</code>函数，底层是用了Unified Communication X库。先是找到代表dst进程的endpoint，再用两个函数实现send。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mca_pml_ucx_send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">ompi_datatype_t</span> *datatype, <span class="type">int</span> dst,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> tag, <span class="type">mca_pml_base_send_mode_t</span> mode,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span>* comm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ucp_ep_h ep;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PML_UCX_TRACE_SEND</span>(<span class="string">&quot;%s&quot;</span>, buf, count, datatype, dst, tag, mode, comm,</span><br><span class="line">                       mode == MCA_PML_BASE_SEND_BUFFERED ? <span class="string">&quot;bsend&quot;</span> : <span class="string">&quot;send&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ep = <span class="built_in">mca_pml_ucx_get_ep</span>(comm, dst);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_UNLIKELY</span>(<span class="literal">NULL</span> == ep)) &#123;</span><br><span class="line">        <span class="keyword">return</span> OMPI_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SPC_ENABLE == 1</span></span><br><span class="line">    <span class="type">size_t</span> dt_size;</span><br><span class="line">    <span class="built_in">ompi_datatype_type_size</span>(datatype, &amp;dt_size);</span><br><span class="line">    <span class="built_in">SPC_USER_OR_MPI</span>(tag, dt_size*count,</span><br><span class="line">                    OMPI_SPC_BYTES_SENT_USER, OMPI_SPC_BYTES_SENT_MPI);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_DECL_UCP_TAG_SEND_NBR</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_LIKELY</span>((MCA_PML_BASE_SEND_BUFFERED != mode) &amp;&amp;</span><br><span class="line">                    (MCA_PML_BASE_SEND_SYNCHRONOUS != mode))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mca_pml_ucx_send_nbr</span>(ep, buf, count, datatype,</span><br><span class="line">                                    <span class="built_in">PML_UCX_MAKE_SEND_TAG</span>(tag, comm));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mca_pml_ucx_send_nb</span>(ep, buf, count, datatype,</span><br><span class="line">                               <span class="built_in">mca_pml_ucx_get_datatype</span>(datatype),</span><br><span class="line">                               <span class="built_in">PML_UCX_MAKE_SEND_TAG</span>(tag, comm), mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现send的其中一个非阻塞函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_DECL_UCP_TAG_SEND_NBR</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> __opal_attribute_always_inline__ <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">mca_pml_ucx_send_nbr</span><span class="params">(ucp_ep_h ep, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">ompi_datatype_t</span> *datatype, <span class="type">ucp_tag_t</span> tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* coverity[bad_alloc_arithmetic] */</span></span><br><span class="line">    <span class="type">ucs_status_ptr_t</span> req = <span class="built_in">PML_UCX_REQ_ALLOCA</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_DECL_UCP_TAG_SEND_NBX</span></span><br><span class="line">    <span class="type">pml_ucx_datatype_t</span> *op_data = <span class="built_in">mca_pml_ucx_get_op_data</span>(datatype);</span><br><span class="line">    <span class="type">ucp_request_param_t</span> param   = &#123;</span><br><span class="line">        .op_attr_mask = UCP_OP_ATTR_FIELD_REQUEST |</span><br><span class="line">                        (op_data-&gt;op_param.send.op_attr_mask &amp; UCP_OP_ATTR_FIELD_DATATYPE) |</span><br><span class="line">                        UCP_OP_ATTR_FLAG_FAST_CMPL,</span><br><span class="line">        .datatype     = op_data-&gt;op_param.send.datatype,</span><br><span class="line">        .request      = req</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ucp_tag_send_nb和ucp_tag_send_nbx可能是一样的，因为手册里没有找到ucp_tag_send_nbx，所以可能是不同版本</span></span><br><span class="line">    <span class="comment">// 此例程将由本地地址缓冲区、大小计数和数据类型对象描述的消息发送到目标端点 ep。</span></span><br><span class="line">    <span class="comment">// 每条消息都与一个标签值相关联，该标签值用于在接收器上进行消息匹配。 </span></span><br><span class="line">    <span class="comment">// 该例程是非阻塞的，因此会立即返回，但是实际的发送操作可能会延迟。 当可以安全地重用源缓冲区时，发送操作被认为已完成。</span></span><br><span class="line">    <span class="comment">// 如果发送操作立即完成，则例程返回 UCS_OK 并且不调用回调函数 cb。</span></span><br><span class="line">    <span class="comment">// 如果操作没有立即完成并且没有报告错误，那么 UCP 库将安排在发送操作完成时调用回调 cb。</span></span><br><span class="line">    <span class="comment">// 所以这里没有wait，而且检测到错误就返回了</span></span><br><span class="line"></span><br><span class="line">    req = <span class="built_in">ucp_tag_send_nbx</span>(ep, buf,</span><br><span class="line">                           <span class="built_in">mca_pml_ucx_get_data_size</span>(op_data, count),</span><br><span class="line">                           tag, &amp;param);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_LIKELY</span>(req == UCS_OK)) &#123;</span><br><span class="line">        <span class="keyword">return</span> OMPI_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">UCS_PTR_IS_ERR</span>(req)) &#123;</span><br><span class="line">        <span class="built_in">PML_UCX_ERROR</span>(<span class="string">&quot;%s failed: %d, %s&quot;</span>, __func__, <span class="built_in">UCS_PTR_STATUS</span>(req),</span><br><span class="line">                      <span class="built_in">ucs_status_string</span>(<span class="built_in">UCS_PTR_STATUS</span>(req)));</span><br><span class="line">        <span class="keyword">return</span> OPAL_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">ucs_status_t</span> status;</span><br><span class="line">    status = <span class="built_in">ucp_tag_send_nbr</span>(ep, buf, count,</span><br><span class="line">                              <span class="built_in">mca_pml_ucx_get_datatype</span>(datatype), tag, req);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_LIKELY</span>(status == UCS_OK)) &#123;</span><br><span class="line">        <span class="keyword">return</span> OMPI_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 此例程提供了一种方便且有效的方式来实现阻塞发送模式。它还比 ucp_tag_send_nbr() 更快地完成请求，因为：</span></span><br><span class="line"><span class="comment">     * 它总是使用 uct_ep_am_bcopy() 将数据发送到集合阈值。</span></span><br><span class="line"><span class="comment">     * 它的集合阈值高于 ucp_tag_send_nb() 使用的阈值。阈值由 UCX_SEND_NBR_RNDV_THRESH 环境变量控制。</span></span><br><span class="line"><span class="comment">     * 它的请求处理更简单。没有回调，也不需要分配和释放请求。事实上，请求可以由调用者在堆栈上分配。</span></span><br><span class="line"><span class="comment">     * 此例程将由本地地址缓冲区、大小计数和数据类型对象描述的消息发送到目标端点 ep。每条消息都与一个标签值相关联，该标签值用于在接收器上进行消息匹配。</span></span><br><span class="line"><span class="comment">     * 该例程是非阻塞的，因此会立即返回，但是实际的发送操作可能会延迟。当可以安全地重用源缓冲区时，发送操作被认为已完成。如果发送操作立即完成，则例程返回 UCS_OK。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 如果操作没有立即完成并且没有报告错误，那么 UCP 库将填充用户提供的请求并返回 UCS_INPROGRESS 状态。为了监控操作的完成，应该使用 ucp_request_check_status()。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MCA_COMMON_UCX_WAIT_LOOP</span>(req, ompi_pml_ucx.ucp_worker, <span class="string">&quot;ucx send nbr&quot;</span>, (<span class="type">void</span>)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>实现send的其中一个阻塞函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> __opal_attribute_always_inline__ <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">mca_pml_ucx_send_nb</span><span class="params">(ucp_ep_h ep, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">ompi_datatype_t</span> *datatype, <span class="type">ucp_datatype_t</span> ucx_datatype,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">ucp_tag_t</span> tag, <span class="type">mca_pml_base_send_mode_t</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ompi_request_t</span> *req;</span><br><span class="line"></span><br><span class="line">    req = (<span class="type">ompi_request_t</span>*)<span class="built_in">mca_pml_ucx_common_send</span>(ep, buf, count, datatype,</span><br><span class="line">                                                   <span class="built_in">mca_pml_ucx_get_datatype</span>(datatype),</span><br><span class="line">                                                   tag, mode,</span><br><span class="line">                                                   mca_pml_ucx_send_completion_empty);</span><br><span class="line">    <span class="comment">// 应该是发送完之后一直等待，直到结束，因为有wait loop</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_LIKELY</span>(req == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> OMPI_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">UCS_PTR_IS_ERR</span>(req)) &#123;</span><br><span class="line">        <span class="built_in">PML_UCX_VERBOSE</span>(<span class="number">8</span>, <span class="string">&quot;got request %p&quot;</span>, (<span class="type">void</span>*)req);</span><br><span class="line">        <span class="built_in">MCA_COMMON_UCX_WAIT_LOOP</span>(req, ompi_pml_ucx.ucp_worker, <span class="string">&quot;ucx send&quot;</span>, <span class="built_in">ucp_request_free</span>(req));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">PML_UCX_ERROR</span>(<span class="string">&quot;ucx send failed: %s&quot;</span>, <span class="built_in">ucs_status_string</span>(<span class="built_in">UCS_PTR_STATUS</span>(req)));</span><br><span class="line">        <span class="keyword">return</span> OMPI_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mca_pml_ucx_common_send根据mode调用三种函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">ucs_status_ptr_t</span> <span class="title">mca_pml_ucx_common_send</span><span class="params">(ucp_ep_h ep, <span class="type">const</span> <span class="type">void</span> *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="type">size_t</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="type">ompi_datatype_t</span> *datatype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="type">ucp_datatype_t</span> ucx_datatype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="type">ucp_tag_t</span> tag,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="type">mca_pml_base_send_mode_t</span> mode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="type">ucp_send_callback_t</span> cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_UNLIKELY</span>(MCA_PML_BASE_SEND_BUFFERED == mode)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mca_pml_ucx_bsend</span>(ep, buf, count, datatype, tag);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">OPAL_UNLIKELY</span>(MCA_PML_BASE_SEND_SYNCHRONOUS == mode)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ucp_tag_send_sync_nb</span>(ep, buf, count, ucx_datatype, tag, cb);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ucp_tag_send_nb</span>(ep, buf, count, ucx_datatype, tag, cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ucp_tag_send_nb将由本地地址缓冲区、大小计数和数据类型对象描述的消息发送到目标端点 ep。 </span></span><br><span class="line">    <span class="comment">// 每条消息都与一个标签值相关联，该标签值用于在接收器上进行消息匹配。</span></span><br><span class="line">    <span class="comment">// 该例程是非阻塞的，因此会立即返回，但是实际的发送操作可能会延迟。</span></span><br><span class="line">    <span class="comment">// 当可以安全地重用源缓冲区时，发送操作被认为已完成。 如果发送操作立即完成，则例程返回 UCS_OK 并且不调用回调函数 cb。</span></span><br><span class="line">    <span class="comment">// 如果操作没有立即完成并且没有报告错误，那么 UCP 库将安排在发送操作完成时调用回调 cb。 换句话说，消息的完成可以通过返回码或回调来表示。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ucp_tag_send_sync_nb 与 ucp_tag_send_nb 相同，除了请求仅在消息上存在远程标记匹配后完成（这并不总是意味着远程接收已完成）。</span></span><br><span class="line">    <span class="comment">// 这个函数永远不会“就地”完成，并且总是返回一个请求句柄。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">ucs_status_ptr_t</span></span></span><br><span class="line"><span class="function"><span class="title">mca_pml_ucx_bsend</span><span class="params">(ucp_ep_h ep, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">ompi_datatype_t</span> *datatype, <span class="type">uint64_t</span> pml_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ompi_request_t</span> *req;</span><br><span class="line">    <span class="type">void</span> *packed_data;</span><br><span class="line">    <span class="type">size_t</span> packed_length;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line">    <span class="type">uint32_t</span> iov_count;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov;</span><br><span class="line">    <span class="type">opal_convertor_t</span> opal_conv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OBJ_CONSTRUCT</span>(&amp;opal_conv, <span class="type">opal_convertor_t</span>);</span><br><span class="line">    <span class="built_in">opal_convertor_copy_and_prepare_for_send</span>(ompi_proc_local_proc-&gt;super.proc_convertor,</span><br><span class="line">                                             &amp;datatype-&gt;super, count, buf, <span class="number">0</span>,</span><br><span class="line">                                             &amp;opal_conv);</span><br><span class="line">    <span class="comment">// 设置convertor的fAdvance</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">opal_convertor_get_packed_size</span>(&amp;opal_conv, &amp;packed_length);</span><br><span class="line"></span><br><span class="line">    packed_data = <span class="built_in">mca_pml_base_bsend_request_alloc_buf</span>(packed_length);</span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_UNLIKELY</span>(<span class="literal">NULL</span> == packed_data)) &#123;</span><br><span class="line">        <span class="built_in">OBJ_DESTRUCT</span>(&amp;opal_conv);</span><br><span class="line">        <span class="built_in">PML_UCX_ERROR</span>(<span class="string">&quot;bsend: failed to allocate buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UCS_STATUS_PTR</span>(OMPI_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iov_count    = <span class="number">1</span>;</span><br><span class="line">    iov.iov_base = packed_data;</span><br><span class="line">    iov.iov_len  = packed_length;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PML_UCX_VERBOSE</span>(<span class="number">8</span>, <span class="string">&quot;bsend of packed buffer %p len %zu&quot;</span>, packed_data, packed_length);</span><br><span class="line">    offset = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">opal_convertor_set_position</span>(&amp;opal_conv, &amp;offset);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &gt; <span class="built_in">opal_convertor_pack</span>(&amp;opal_conv, &amp;iov, &amp;iov_count, &amp;packed_length)) &#123;</span><br><span class="line">        <span class="comment">// 获取到指针后使用memcpy</span></span><br><span class="line">        <span class="built_in">mca_pml_base_bsend_request_free</span>(packed_data); <span class="comment">// 释放request</span></span><br><span class="line">        <span class="built_in">OBJ_DESTRUCT</span>(&amp;opal_conv);</span><br><span class="line">        <span class="built_in">PML_UCX_ERROR</span>(<span class="string">&quot;bsend: failed to pack user datatype&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UCS_STATUS_PTR</span>(OMPI_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OBJ_DESTRUCT</span>(&amp;opal_conv);</span><br><span class="line"></span><br><span class="line">    req = (<span class="type">ompi_request_t</span>*)<span class="built_in">ucp_tag_send_nb</span>(ep, packed_data, packed_length,</span><br><span class="line">                                           <span class="built_in">ucp_dt_make_contig</span>(<span class="number">1</span>), pml_tag,</span><br><span class="line">                                           mca_pml_ucx_bsend_completion);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == req) &#123;</span><br><span class="line">        <span class="comment">/* request was completed in place */</span></span><br><span class="line">        <span class="built_in">mca_pml_base_bsend_request_free</span>(packed_data);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_UNLIKELY</span>(<span class="built_in">UCS_PTR_IS_ERR</span>(req))) &#123;</span><br><span class="line">        <span class="built_in">mca_pml_base_bsend_request_free</span>(packed_data);</span><br><span class="line">        <span class="built_in">PML_UCX_ERROR</span>(<span class="string">&quot;ucx bsend failed: %s&quot;</span>, <span class="built_in">ucs_status_string</span>(<span class="built_in">UCS_PTR_STATUS</span>(req)));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UCS_STATUS_PTR</span>(OMPI_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req-&gt;req_complete_cb_data = packed_data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="convertor"><a href="#convertor" class="headerlink" title="convertor"></a>convertor</h1><p>多次看到，可能是在不同架构下进行传输的转换器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">opal_convertor_t</span> &#123;</span><br><span class="line">    <span class="type">opal_object_t</span> super; <span class="comment">/**&lt; basic superclass */</span></span><br><span class="line">    <span class="type">uint32_t</span> remoteArch; <span class="comment">/**&lt; the remote architecture */</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;      <span class="comment">/**&lt; the properties of this convertor */</span></span><br><span class="line">    <span class="type">size_t</span> local_size;   <span class="comment">/**&lt; overall length data on local machine, compared to bConverted */</span></span><br><span class="line">    <span class="type">size_t</span> remote_size;  <span class="comment">/**&lt; overall length data on remote machine, compared to bConverted */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">opal_datatype_t</span> *pDesc;   <span class="comment">/**&lt; the datatype description associated with the convertor */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">dt_type_desc_t</span> *use_desc; <span class="comment">/**&lt; the version used by the convertor (normal or optimized) */</span></span><br><span class="line">    <span class="type">opal_datatype_count_t</span> count;    <span class="comment">/**&lt; the total number of full datatype elements */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --- cacheline boundary (64 bytes - if 64bits arch and !OPAL_ENABLE_DEBUG) --- */</span></span><br><span class="line">    <span class="type">uint32_t</span> stack_size;              <span class="comment">/**&lt; size of the allocated stack */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pBaseBuf;          <span class="comment">/**&lt; initial buffer as supplied by the user */</span></span><br><span class="line">    <span class="type">dt_stack_t</span> *pStack;               <span class="comment">/**&lt; the local stack for the actual conversion */</span></span><br><span class="line">    <span class="type">convertor_advance_fct_t</span> fAdvance; <span class="comment">/**&lt; pointer to the pack/unpack functions */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --- cacheline boundary (96 bytes - if 64bits arch and !OPAL_ENABLE_DEBUG) --- */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">opal_convertor_master_t</span> *master; <span class="comment">/**&lt; the master convertor */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All others fields get modified for every call to pack/unpack functions */</span></span><br><span class="line">    <span class="type">uint32_t</span> stack_pos;    <span class="comment">/**&lt; the actual position on the stack */</span></span><br><span class="line">    <span class="type">size_t</span> partial_length; <span class="comment">/**&lt; amount of data left over from the last unpack */</span></span><br><span class="line">    <span class="type">size_t</span> bConverted;     <span class="comment">/**&lt; # of bytes already converted */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --- cacheline boundary (128 bytes - if 64bits arch and !OPAL_ENABLE_DEBUG) --- */</span></span><br><span class="line">    <span class="type">uint32_t</span> checksum; <span class="comment">/**&lt; checksum computed by pack/unpack operation */</span></span><br><span class="line">    <span class="type">uint32_t</span> csum_ui1; <span class="comment">/**&lt; partial checksum computed by pack/unpack operation */</span></span><br><span class="line">    <span class="type">size_t</span> csum_ui2;   <span class="comment">/**&lt; partial checksum computed by pack/unpack operation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* --- fields are no more aligned on cacheline --- */</span></span><br><span class="line">    <span class="type">dt_stack_t</span> static_stack[DT_STATIC_STACK_SIZE]; <span class="comment">/**&lt; local stack for small datatypes */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_CUDA_SUPPORT</span></span><br><span class="line">    <span class="type">memcpy_fct_t</span> cbmemcpy; <span class="comment">/**&lt; memcpy or cuMemcpy */</span></span><br><span class="line">    <span class="type">void</span> *stream;          <span class="comment">/**&lt; CUstream for async copy */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是pack和unpack，应该是用于通信的时候数据压缩的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return 0 if everything went OK and if there is still room before the complete</span></span><br><span class="line"><span class="comment"> *          conversion of the data (need additional call with others input buffers )</span></span><br><span class="line"><span class="comment"> *        1 if everything went fine and the data was completly converted</span></span><br><span class="line"><span class="comment"> *       -1 something wrong occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">opal_convertor_pack</span><span class="params">(<span class="type">opal_convertor_t</span> *pConv, <span class="keyword">struct</span> iovec *iov, <span class="type">uint32_t</span> *out_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">size_t</span> *max_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">OPAL_CONVERTOR_SET_STATUS_BEFORE_PACK_UNPACK</span>(pConv, iov, out_size, max_data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_LIKELY</span>(pConv-&gt;flags &amp; CONVERTOR_NO_OP)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * We are doing conversion on a contiguous datatype on a homogeneous</span></span><br><span class="line"><span class="comment">         * environment. The convertor contain minimal information, we only</span></span><br><span class="line"><span class="comment">         * use the bConverted to manage the conversion.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">uint32_t</span> i;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *base_pointer;</span><br><span class="line">        <span class="type">size_t</span> pending_length = pConv-&gt;local_size - pConv-&gt;bConverted;</span><br><span class="line"></span><br><span class="line">        *max_data = pending_length;</span><br><span class="line">        <span class="built_in">opal_convertor_get_current_pointer</span>(pConv, (<span class="type">void</span> **) &amp;base_pointer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; *out_size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iov[i].iov_len &gt;= pending_length) &#123;</span><br><span class="line">                <span class="keyword">goto</span> complete_contiguous_data_pack;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">OPAL_LIKELY</span>(<span class="literal">NULL</span> == iov[i].iov_base)) &#123;</span><br><span class="line">                iov[i].iov_base = (IOVBASE_TYPE *) base_pointer;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_CUDA_SUPPORT</span></span><br><span class="line">                <span class="built_in">MEMCPY_CUDA</span>(iov[i].iov_base, base_pointer, iov[i].iov_len, pConv);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                <span class="built_in">MEMCPY</span>(iov[i].iov_base, base_pointer, iov[i].iov_len);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            pending_length -= iov[i].iov_len;</span><br><span class="line">            base_pointer += iov[i].iov_len;</span><br><span class="line">        &#125;</span><br><span class="line">        *max_data -= pending_length;</span><br><span class="line">        pConv-&gt;bConverted += (*max_data);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">complete_contiguous_data_pack:</span><br><span class="line">        iov[i].iov_len = pending_length;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">OPAL_LIKELY</span>(<span class="literal">NULL</span> == iov[i].iov_base)) &#123;</span><br><span class="line">            iov[i].iov_base = (IOVBASE_TYPE *) base_pointer;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_CUDA_SUPPORT</span></span><br><span class="line">            <span class="built_in">MEMCPY_CUDA</span>(iov[i].iov_base, base_pointer, iov[i].iov_len, pConv);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="built_in">MEMCPY</span>(iov[i].iov_base, base_pointer, iov[i].iov_len);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        pConv-&gt;bConverted = pConv-&gt;local_size;</span><br><span class="line">        *out_size = i + <span class="number">1</span>;</span><br><span class="line">        pConv-&gt;flags |= CONVERTOR_COMPLETED;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pConv-&gt;<span class="built_in">fAdvance</span>(pConv, iov, out_size, max_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">opal_convertor_unpack</span><span class="params">(<span class="type">opal_convertor_t</span> *pConv, <span class="keyword">struct</span> iovec *iov, <span class="type">uint32_t</span> *out_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">size_t</span> *max_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">OPAL_CONVERTOR_SET_STATUS_BEFORE_PACK_UNPACK</span>(pConv, iov, out_size, max_data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">OPAL_LIKELY</span>(pConv-&gt;flags &amp; CONVERTOR_NO_OP)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 我们正在同构环境中对连续数据类型进行转换。 转换器包含最少的信息，我们只使用 bConverted 来管理转换。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">uint32_t</span> i;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *base_pointer;</span><br><span class="line">        <span class="type">size_t</span> pending_length = pConv-&gt;local_size - pConv-&gt;bConverted;</span><br><span class="line"></span><br><span class="line">        *max_data = pending_length;</span><br><span class="line">        <span class="built_in">opal_convertor_get_current_pointer</span>(pConv, (<span class="type">void</span> **) &amp;base_pointer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; *out_size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iov[i].iov_len &gt;= pending_length) &#123;</span><br><span class="line">                <span class="keyword">goto</span> complete_contiguous_data_unpack;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_CUDA_SUPPORT</span></span><br><span class="line">            <span class="built_in">MEMCPY_CUDA</span>(base_pointer, iov[i].iov_base, iov[i].iov_len, pConv);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="built_in">MEMCPY</span>(base_pointer, iov[i].iov_base, iov[i].iov_len);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            pending_length -= iov[i].iov_len;</span><br><span class="line">            base_pointer += iov[i].iov_len;</span><br><span class="line">        &#125;</span><br><span class="line">        *max_data -= pending_length;</span><br><span class="line">        pConv-&gt;bConverted += (*max_data);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    complete_contiguous_data_unpack:</span><br><span class="line">        iov[i].iov_len = pending_length;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_CUDA_SUPPORT</span></span><br><span class="line">        <span class="built_in">MEMCPY_CUDA</span>(base_pointer, iov[i].iov_base, iov[i].iov_len, pConv);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">MEMCPY</span>(base_pointer, iov[i].iov_base, iov[i].iov_len);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        pConv-&gt;bConverted = pConv-&gt;local_size;</span><br><span class="line">        *out_size = i + <span class="number">1</span>;</span><br><span class="line">        pConv-&gt;flags |= CONVERTOR_COMPLETED;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pConv-&gt;<span class="built_in">fAdvance</span>(pConv, iov, out_size, max_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用于在执行通信的时候进行准备，主要是设置fAdvance这个函数，用在上边的pack和unpack里：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">opal_convertor_prepare_for_send</span><span class="params">(<span class="type">opal_convertor_t</span> *convertor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> <span class="keyword">struct</span> <span class="type">opal_datatype_t</span> *datatype, <span class="type">size_t</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> <span class="type">void</span> *pUserBuf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    convertor-&gt;flags |= CONVERTOR_SEND;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_CUDA_SUPPORT</span></span><br><span class="line">    <span class="keyword">if</span> (!(convertor-&gt;flags &amp; CONVERTOR_SKIP_CUDA_INIT)) &#123;</span><br><span class="line">        <span class="built_in">mca_cuda_convertor_init</span>(convertor, pUserBuf);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">OPAL_CONVERTOR_PREPARE</span>(convertor, datatype, count, pUserBuf);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CHECKSUM)</span></span><br><span class="line">    <span class="keyword">if</span> (convertor-&gt;flags &amp; CONVERTOR_WITH_CHECKSUM) &#123;</span><br><span class="line">        <span class="keyword">if</span> (CONVERTOR_SEND_CONVERSION</span><br><span class="line">            == (convertor-&gt;flags &amp; (CONVERTOR_SEND_CONVERSION | CONVERTOR_HOMOGENEOUS))) &#123;</span><br><span class="line">            convertor-&gt;fAdvance = opal_pack_general_checksum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (datatype-&gt;flags &amp; OPAL_DATATYPE_FLAG_CONTIGUOUS) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((datatype-&gt;ub - datatype-&gt;lb) == (<span class="type">ptrdiff_t</span>) datatype-&gt;size)</span><br><span class="line">                    || (<span class="number">1</span> &gt;= convertor-&gt;count)) &#123;</span><br><span class="line">                    convertor-&gt;fAdvance = opal_pack_homogeneous_contig_checksum; <span class="comment">// 都是计算checksum的函数，例如crc码</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    convertor-&gt;fAdvance = opal_pack_homogeneous_contig_with_gaps_checksum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                convertor-&gt;fAdvance = opal_generic_simple_pack_checksum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* defined(CHECKSUM) */</span></span></span><br><span class="line">        <span class="keyword">if</span> (CONVERTOR_SEND_CONVERSION</span><br><span class="line">            == (convertor-&gt;flags &amp; (CONVERTOR_SEND_CONVERSION | CONVERTOR_HOMOGENEOUS))) &#123;</span><br><span class="line">            convertor-&gt;fAdvance = opal_pack_general;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (datatype-&gt;flags &amp; OPAL_DATATYPE_FLAG_CONTIGUOUS) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((datatype-&gt;ub - datatype-&gt;lb) == (<span class="type">ptrdiff_t</span>) datatype-&gt;size)</span><br><span class="line">                    || (<span class="number">1</span> &gt;= convertor-&gt;count)) &#123;</span><br><span class="line">                    convertor-&gt;fAdvance = opal_pack_homogeneous_contig;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    convertor-&gt;fAdvance = opal_pack_homogeneous_contig_with_gaps;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                convertor-&gt;fAdvance = opal_generic_simple_pack;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CHECKSUM)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> OPAL_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="MPI-Recv"><a href="#MPI-Recv" class="headerlink" title="MPI_Recv"></a>MPI_Recv</h1><p>recv和send类似，最后都是调用<code>pml_recv</code>，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Recv</span><span class="params">(<span class="type">void</span> *buf, <span class="type">int</span> count, MPI_Datatype type, <span class="type">int</span> source,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> tag, MPI_Comm comm, MPI_Status *status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rc = MPI_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SPC_RECORD</span>(OMPI_SPC_RECV, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MEMCHECKER</span>(</span><br><span class="line">        <span class="built_in">memchecker_datatype</span>(type);</span><br><span class="line">        <span class="built_in">memchecker_call</span>(&amp;opal_memchecker_base_isaddressable, buf, count, type);</span><br><span class="line">        <span class="built_in">memchecker_comm</span>(comm);</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( MPI_PARAM_CHECK ) &#123;</span><br><span class="line">        <span class="built_in">OMPI_ERR_INIT_FINALIZE</span>(FUNC_NAME);</span><br><span class="line">        <span class="built_in">OMPI_CHECK_DATATYPE_FOR_RECV</span>(rc, type, count);</span><br><span class="line">        <span class="built_in">OMPI_CHECK_USER_BUFFER</span>(rc, buf, type, count);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ompi_comm_invalid</span>(comm)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">OMPI_ERRHANDLER_NOHANDLE_INVOKE</span>(MPI_ERR_COMM, FUNC_NAME);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((tag &lt; <span class="number">0</span>) &amp;&amp; (tag != MPI_ANY_TAG)) || (tag &gt; mca_pml.pml_max_tag)) &#123;</span><br><span class="line">            rc = MPI_ERR_TAG;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((source != MPI_ANY_SOURCE) &amp;&amp;</span><br><span class="line">                   (MPI_PROC_NULL != source) &amp;&amp;</span><br><span class="line">                   <span class="built_in">ompi_comm_peer_invalid</span>(comm, source)) &#123;</span><br><span class="line">            rc = MPI_ERR_RANK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">OMPI_ERRHANDLER_CHECK</span>(rc, comm, rc, FUNC_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fault tolerance ......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MPI_PROC_NULL == source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (MPI_STATUS_IGNORE != status) &#123;</span><br><span class="line">            <span class="built_in">OMPI_COPY_STATUS</span>(status, ompi_request_empty.req_status, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>(buf, count, type, source, tag, comm, status));</span><br><span class="line">    <span class="built_in">OMPI_ERRHANDLER_RETURN</span>(rc, comm, rc, FUNC_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>pml_recv</code>主要有以下几个：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mca_pml_cm_recv</span><br><span class="line">mca_pml_ob1_recv</span><br><span class="line">mca_pml_ucx_recv</span><br><span class="line">mca_spml_ucx_recv</span><br><span class="line">mca_pml_monitoring_recv</span><br></pre></td></tr></table></figure></p>
<p>主要还是跟<code>mca_pml_cm_recv</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__opal_attribute_always_inline__ <span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">mca_pml_cm_recv</span><span class="params">(<span class="type">void</span> *addr,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">size_t</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">ompi_datatype_t</span> * datatype,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> src,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> tag,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">ompi_status_public_t</span> * status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_ENABLE_HETEROGENEOUS_SUPPORT</span></span><br><span class="line">    <span class="type">ompi_proc_t</span> *ompi_proc;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">opal_convertor_t</span> convertor;</span><br><span class="line">    <span class="type">mca_pml_cm_request_t</span> req;</span><br><span class="line">    <span class="type">mca_mtl_request_t</span> *req_mtl = <span class="built_in">alloca</span>(<span class="built_in">sizeof</span>(<span class="type">mca_mtl_request_t</span>) + ompi_mtl-&gt;mtl_request_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OBJ_CONSTRUCT</span>(&amp;convertor, <span class="type">opal_convertor_t</span>);</span><br><span class="line">    req_mtl-&gt;ompi_req = &amp;req.req_ompi;</span><br><span class="line">    req_mtl-&gt;completion_callback = mca_pml_cm_recv_fast_completion;</span><br><span class="line"></span><br><span class="line">    req.req_pml_type = MCA_PML_CM_REQUEST_RECV_THIN;</span><br><span class="line">    req.req_free_called = <span class="literal">false</span>;</span><br><span class="line">    req.req_ompi.req_complete = <span class="literal">false</span>;</span><br><span class="line">    req.req_ompi.req_complete_cb = <span class="literal">NULL</span>;</span><br><span class="line">    req.req_ompi.req_state = OMPI_REQUEST_ACTIVE;</span><br><span class="line">    req.req_ompi.req_status.MPI_TAG = OMPI_ANY_TAG;</span><br><span class="line">    req.req_ompi.req_status.MPI_ERROR = OMPI_SUCCESS;</span><br><span class="line">    req.req_ompi.req_status._cancelled = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPAL_ENABLE_HETEROGENEOUS_SUPPORT</span></span><br><span class="line">    <span class="keyword">if</span>( MPI_ANY_SOURCE == src ) &#123;</span><br><span class="line">        ompi_proc = ompi_proc_local_proc;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ompi_proc = <span class="built_in">ompi_comm_peer_lookup</span>( comm, src );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MCA_PML_CM_SWITCH_CUDA_CONVERTOR_OFF</span>(flags, datatype, count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">opal_convertor_copy_and_prepare_for_recv</span>(</span><br><span class="line">	ompi_proc-&gt;super.proc_convertor,</span><br><span class="line">		&amp;(datatype-&gt;super),</span><br><span class="line">		count,</span><br><span class="line">		addr,</span><br><span class="line">                flags,</span><br><span class="line">		&amp;convertor );</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">MCA_PML_CM_SWITCH_CUDA_CONVERTOR_OFF</span>(flags, datatype, count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">opal_convertor_copy_and_prepare_for_recv</span>(</span><br><span class="line">	ompi_mpi_local_convertor,</span><br><span class="line">		&amp;(datatype-&gt;super),</span><br><span class="line">		count,</span><br><span class="line">		addr,</span><br><span class="line">                flags,</span><br><span class="line">		&amp;convertor );</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">OMPI_MTL_CALL</span>(<span class="built_in">irecv</span>(ompi_mtl,</span><br><span class="line">                              comm,</span><br><span class="line">                              src,</span><br><span class="line">                              tag,</span><br><span class="line">                              &amp;convertor,</span><br><span class="line">                              req_mtl));</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">OPAL_UNLIKELY</span>(OMPI_SUCCESS != ret) ) &#123;</span><br><span class="line">	<span class="built_in">OBJ_DESTRUCT</span>(&amp;convertor);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ompi_request_wait_completion</span>(&amp;req.req_ompi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MPI_STATUS_IGNORE != status) &#123;</span><br><span class="line">        <span class="built_in">OMPI_COPY_STATUS</span>(status, req.req_ompi.req_status, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = req.req_ompi.req_status.MPI_ERROR;</span><br><span class="line">    <span class="built_in">OBJ_DESTRUCT</span>(&amp;convertor);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="MPI-Allgather"><a href="#MPI-Allgather" class="headerlink" title="MPI_Allgather"></a>MPI_Allgather</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MPI_Allgather</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sendbuf, <span class="type">int</span> sendcount, MPI_Datatype sendtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">void</span> *recvbuf, <span class="type">int</span> recvcount, MPI_Datatype recvtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                  MPI_Comm comm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SPC_RECORD</span>(OMPI_SPC_ALLGATHER, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MEMCHECKER</span>(</span><br><span class="line">        <span class="type">int</span> rank;</span><br><span class="line">        <span class="type">ptrdiff_t</span> ext;</span><br><span class="line"></span><br><span class="line">        rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line">        <span class="built_in">ompi_datatype_type_extent</span>(recvtype, &amp;ext);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memchecker_datatype</span>(recvtype);</span><br><span class="line">        <span class="built_in">memchecker_comm</span>(comm);</span><br><span class="line">        <span class="comment">/* 检查发送缓冲区是否合法. */</span></span><br><span class="line">        <span class="keyword">if</span> (MPI_IN_PLACE == sendbuf) &#123;</span><br><span class="line">            <span class="built_in">memchecker_call</span>(&amp;opal_memchecker_base_isdefined,</span><br><span class="line">                            (<span class="type">char</span> *)(recvbuf)+rank*recvcount*ext,</span><br><span class="line">                            recvcount, recvtype);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memchecker_datatype</span>(sendtype);</span><br><span class="line">            <span class="built_in">memchecker_call</span>(&amp;opal_memchecker_base_isdefined, sendbuf, sendcount, sendtype);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* check whether the receive buffer is addressable. */</span></span><br><span class="line">        <span class="built_in">memchecker_call</span>(&amp;opal_memchecker_base_isaddressable, recvbuf, recvcount, recvtype);</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MPI_PARAM_CHECK) &#123;</span><br><span class="line">        err = MPI_SUCCESS;</span><br><span class="line">        <span class="built_in">OMPI_ERR_INIT_FINALIZE</span>(FUNC_NAME);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ompi_comm_invalid</span>(comm)) &#123;</span><br><span class="line">          <span class="built_in">OMPI_ERRHANDLER_NOHANDLE_INVOKE</span>(MPI_ERR_COMM, FUNC_NAME);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MPI_DATATYPE_NULL == recvtype || <span class="literal">NULL</span> == recvtype) &#123;</span><br><span class="line">          err = MPI_ERR_TYPE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (recvcount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          err = MPI_ERR_COUNT;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((MPI_IN_PLACE == sendbuf &amp;&amp; <span class="built_in">OMPI_COMM_IS_INTER</span>(comm)) ||</span><br><span class="line">                   MPI_IN_PLACE == recvbuf) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">OMPI_ERRHANDLER_INVOKE</span>(comm, MPI_ERR_ARG, FUNC_NAME);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MPI_IN_PLACE != sendbuf) &#123;</span><br><span class="line">            <span class="built_in">OMPI_CHECK_DATATYPE_FOR_SEND</span>(err, sendtype, sendcount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">OMPI_ERRHANDLER_CHECK</span>(err, comm, err, FUNC_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 每个进程都必须给出相同的发送签名，这意味着如果有任何东西要发送用于内部通信器案例，每个人都必须给出一个 sendcount &gt; 0。</span></span><br><span class="line"><span class="comment">     * 但是，如果我们正在执行 IN_PLACE，请检查 recvcount，而不是 sendcount。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">OMPI_COMM_IS_INTRA</span>(comm) ) &#123;</span><br><span class="line">       <span class="keyword">if</span> ((MPI_IN_PLACE != sendbuf &amp;&amp; <span class="number">0</span> == sendcount) ||</span><br><span class="line">            (<span class="number">0</span> == recvcount)) &#123;</span><br><span class="line">            <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">	   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( <span class="built_in">OMPI_COMM_IS_INTER</span>(comm) )&#123;</span><br><span class="line">        <span class="comment">/* 对于inter的通信器，通信模式不必是对称的。 具体来说，一组允许 sendcount=0，而另一组有一个有效的 sendcount。 因此，不做任何事情的唯一方法是如果 sendcount 和 recvcount 都为零 */</span></span><br><span class="line">	    <span class="keyword">if</span> ( <span class="number">0</span> == sendcount &amp;&amp; <span class="number">0</span> == recvcount ) &#123;</span><br><span class="line">	        <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invoke the coll component to perform the back-end operation */</span></span><br><span class="line"></span><br><span class="line">    err = comm-&gt;c_coll-&gt;<span class="built_in">coll_allgather</span>(sendbuf, sendcount, sendtype,</span><br><span class="line">                                      recvbuf, recvcount, recvtype, comm,</span><br><span class="line">                                      comm-&gt;c_coll-&gt;coll_allgather_module);</span><br><span class="line">    <span class="built_in">OMPI_ERRHANDLER_RETURN</span>(err, comm, err, FUNC_NAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>coll_allgather</code>有如下几个实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mca_coll_basic_allgather_inter</span><br><span class="line">ompi_coll_base_allgather_intra_basic_linear</span><br><span class="line">mca_coll_demo_allgather_intra</span><br><span class="line">mca_coll_demo_allgather_inter</span><br><span class="line">mca_coll_self_allgather_intra</span><br></pre></td></tr></table></figure></p>
<p><code>mca_coll_basic_allgather_inter</code>实现，应该是在两个域之间实现的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mca_coll_basic_allgather_inter</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sbuf, <span class="type">int</span> scount,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *sdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">void</span> *rbuf, <span class="type">int</span> rcount,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *rdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rank, root = <span class="number">0</span>, size, rsize, err, i, line;</span><br><span class="line">    <span class="type">char</span> *tmpbuf_free = <span class="literal">NULL</span>, *tmpbuf, *ptmp;</span><br><span class="line">    <span class="type">ptrdiff_t</span> rlb, rextent, incr;</span><br><span class="line">    <span class="type">ptrdiff_t</span> gap, span;</span><br><span class="line">    <span class="type">ompi_request_t</span> *req;</span><br><span class="line">    <span class="type">ompi_request_t</span> **reqs = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line">    size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    rsize = <span class="built_in">ompi_comm_remote_size</span>(comm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Algorithm:</span></span><br><span class="line"><span class="comment">     * - gather操作，聚集到远程组中的根（同时执行，这就是我们不能使用 coll_gather 的原因）。</span></span><br><span class="line"><span class="comment">     * - 在两个根之间交换温度结果</span></span><br><span class="line"><span class="comment">     * - 进程间广播（再次同时）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step one: gather operations: */</span></span><br><span class="line">    <span class="keyword">if</span> (rank != root) &#123;</span><br><span class="line">        <span class="comment">/* 把自己的数据发送给根进程 */</span></span><br><span class="line">        err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span>(sbuf, scount, sdtype, root,</span><br><span class="line">                                MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                MCA_PML_BASE_SEND_STANDARD, comm));</span><br><span class="line">        <span class="keyword">if</span> (OMPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> exit; &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* receive a msg. from all other procs. */</span></span><br><span class="line">        err = <span class="built_in">ompi_datatype_get_extent</span>(rdtype, &amp;rlb, &amp;rextent);</span><br><span class="line">        <span class="keyword">if</span> (OMPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> exit; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化request数组 */</span></span><br><span class="line">        reqs = <span class="built_in">ompi_coll_base_comm_get_reqs</span>(<span class="keyword">module</span>-&gt;base_data, rsize + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">NULL</span> == reqs ) &#123; line = __LINE__; err = OMPI_ERR_OUT_OF_RESOURCE; <span class="keyword">goto</span> exit; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 使用非阻塞通信实现两个根进程之间的交换 */</span></span><br><span class="line">        err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">isend</span>(sbuf, scount, sdtype, <span class="number">0</span>,</span><br><span class="line">                                 MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                 MCA_PML_BASE_SEND_STANDARD,</span><br><span class="line">                                 comm, &amp;reqs[rsize]));</span><br><span class="line">        <span class="keyword">if</span> (OMPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> exit; &#125;</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">irecv</span>(rbuf, rcount, rdtype, <span class="number">0</span>,</span><br><span class="line">                                 MCA_COLL_BASE_TAG_ALLGATHER, comm,</span><br><span class="line">                                 &amp;reqs[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">if</span> (OMPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> exit; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 接收非根节点的信息 */</span></span><br><span class="line">        incr = rextent * rcount;</span><br><span class="line">        ptmp = (<span class="type">char</span> *) rbuf + incr;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; rsize; ++i, ptmp += incr) &#123;</span><br><span class="line">            err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">irecv</span>(ptmp, rcount, rdtype, i,</span><br><span class="line">                                     MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                     comm, &amp;reqs[i]));</span><br><span class="line">            <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> exit; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wait，直到这个request结束，也是用while做</span></span><br><span class="line">        err = <span class="built_in">ompi_request_wait_all</span>(rsize + <span class="number">1</span>, reqs, MPI_STATUSES_IGNORE);</span><br><span class="line">        <span class="keyword">if</span> (OMPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> exit; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Step 2: exchange the resuts between the root processes */</span></span><br><span class="line">        span = <span class="built_in">opal_datatype_span</span>(&amp;sdtype-&gt;super, (<span class="type">int64_t</span>)scount * (<span class="type">int64_t</span>)size, &amp;gap);</span><br><span class="line">        tmpbuf_free = (<span class="type">char</span> *) <span class="built_in">malloc</span>(span);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == tmpbuf_free) &#123; line = __LINE__; err = OMPI_ERR_OUT_OF_RESOURCE; <span class="keyword">goto</span> exit; &#125;</span><br><span class="line">        tmpbuf = tmpbuf_free - gap;</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">isend</span>(rbuf, rsize * rcount, rdtype, <span class="number">0</span>,</span><br><span class="line">                                 MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                 MCA_PML_BASE_SEND_STANDARD, comm, &amp;req));</span><br><span class="line">        <span class="keyword">if</span> (OMPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> exit; &#125;</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>(tmpbuf, size * scount, sdtype, <span class="number">0</span>,</span><br><span class="line">                                MCA_COLL_BASE_TAG_ALLGATHER, comm,</span><br><span class="line">                                MPI_STATUS_IGNORE));</span><br><span class="line">        <span class="keyword">if</span> (OMPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> exit; &#125;</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">ompi_request_wait</span>( &amp;req, MPI_STATUS_IGNORE);</span><br><span class="line">        <span class="keyword">if</span> (OMPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> exit; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: 广播数据到远程组。 这在两个组中同时发生，因此我们不能使用 coll_bcast（这会死锁）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (rank != root) &#123;</span><br><span class="line">        <span class="comment">/* post the recv */</span></span><br><span class="line">        err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>(rbuf, rsize * rcount, rdtype, <span class="number">0</span>,</span><br><span class="line">                                MCA_COLL_BASE_TAG_ALLGATHER, comm,</span><br><span class="line">                                MPI_STATUS_IGNORE));</span><br><span class="line">        <span class="keyword">if</span> (OMPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> exit; &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Send the data to every other process in the remote group except to rank zero. which has it already. */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; rsize; i++) &#123;</span><br><span class="line">            err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">isend</span>(tmpbuf, size * scount, sdtype, i,</span><br><span class="line">                                     MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                     MCA_PML_BASE_SEND_STANDARD,</span><br><span class="line">                                     comm, &amp;reqs[i - <span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">if</span> (OMPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> exit; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = <span class="built_in">ompi_request_wait_all</span>(rsize - <span class="number">1</span>, reqs, MPI_STATUSES_IGNORE);</span><br><span class="line">        <span class="keyword">if</span> (OMPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> exit; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  exit:</span><br><span class="line">    <span class="keyword">if</span>( MPI_SUCCESS != err ) &#123;</span><br><span class="line">        <span class="built_in">OPAL_OUTPUT</span>( (ompi_coll_base_framework.framework_output,<span class="string">&quot;%s:%4d\tError occurred %d, rank %2d&quot;</span>,</span><br><span class="line">                      __FILE__, line, err, rank) );</span><br><span class="line">        (<span class="type">void</span>)line;  <span class="comment">// silence compiler warning</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="literal">NULL</span> != reqs ) <span class="built_in">ompi_coll_base_free_reqs</span>(reqs, rsize+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != tmpbuf_free) &#123;</span><br><span class="line">        <span class="built_in">free</span>(tmpbuf_free);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是几种allgather算法实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">allgather using O(log(N)) steps.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Bruck et al., &quot;Efficient Algorithms for All-to-all Communications in Multiport Message-Passing Systems&quot;</span></span><br><span class="line"><span class="comment"> * Memory requirements:  non-zero ranks require shift buffer to perform final</span></span><br><span class="line"><span class="comment"> *               step in the algorithm.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example on 6 nodes:</span></span><br><span class="line"><span class="comment"> *   Initialization: 每个进程在 rbuf 的位置 0 处都有自己的缓冲区。 </span></span><br><span class="line"><span class="comment"> *                   这意味着如果用户为 sendbuf 指定了 MPI_IN_PLACE，</span></span><br><span class="line"><span class="comment"> *                   我们必须将我们的块从 recvbuf 复制到开始！</span></span><br><span class="line"><span class="comment"> *    #     0      1      2      3      4      5</span></span><br><span class="line"><span class="comment"> *         [0]    [1]    [2]    [3]    [4]    [5]</span></span><br><span class="line"><span class="comment"> *   Step 0: 发给 (rank - 2^0), 从 (rank + 2^0) 接收</span></span><br><span class="line"><span class="comment"> *    #     0      1      2      3      4      5</span></span><br><span class="line"><span class="comment"> *         [0]    [1]    [2]    [3]    [4]    [5]</span></span><br><span class="line"><span class="comment"> *         [1]    [2]    [3]    [4]    [5]    [0]</span></span><br><span class="line"><span class="comment"> *   Step 1: 发给 (rank - 2^1), 从 (rank + 2^1) 接收</span></span><br><span class="line"><span class="comment"> *           消息长度是从 0 到 2^1*block size，就是2倍的第一步</span></span><br><span class="line"><span class="comment"> *    #     0      1      2      3      4      5</span></span><br><span class="line"><span class="comment"> *         [0]    [1]    [2]    [3]    [4]    [5]</span></span><br><span class="line"><span class="comment"> *         [1]    [2]    [3]    [4]    [5]    [0]</span></span><br><span class="line"><span class="comment"> *         [2]    [3]    [4]    [5]    [0]    [1]</span></span><br><span class="line"><span class="comment"> *         [3]    [4]    [5]    [0]    [1]    [2]</span></span><br><span class="line"><span class="comment"> *   Step 2: 发给 (rank - 2^2), 从 (rank + 2^2) 接收</span></span><br><span class="line"><span class="comment"> *           消息长度是剩下的所有块</span></span><br><span class="line"><span class="comment"> *    #     0      1      2      3      4      5</span></span><br><span class="line"><span class="comment"> *         [0]    [1]    [2]    [3]    [4]    [5]</span></span><br><span class="line"><span class="comment"> *         [1]    [2]    [3]    [4]    [5]    [0]</span></span><br><span class="line"><span class="comment"> *         [2]    [3]    [4]    [5]    [0]    [1]</span></span><br><span class="line"><span class="comment"> *         [3]    [4]    [5]    [0]    [1]    [2]</span></span><br><span class="line"><span class="comment"> *         [4]    [5]    [0]    [1]    [2]    [3]</span></span><br><span class="line"><span class="comment"> *         [5]    [0]    [1]    [2]    [3]    [4]</span></span><br><span class="line"><span class="comment"> *    Finalization: 进行本地转移以在正确的位置获取数据</span></span><br><span class="line"><span class="comment"> *    #     0      1      2      3      4      5</span></span><br><span class="line"><span class="comment"> *         [0]    [0]    [0]    [0]    [0]    [0]</span></span><br><span class="line"><span class="comment"> *         [1]    [1]    [1]    [1]    [1]    [1]</span></span><br><span class="line"><span class="comment"> *         [2]    [2]    [2]    [2]    [2]    [2]</span></span><br><span class="line"><span class="comment"> *         [3]    [3]    [3]    [3]    [3]    [3]</span></span><br><span class="line"><span class="comment"> *         [4]    [4]    [4]    [4]    [4]    [4]</span></span><br><span class="line"><span class="comment"> *         [5]    [5]    [5]    [5]    [5]    [5]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_base_allgather_intra_bruck</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sbuf, <span class="type">int</span> scount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *sdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">void</span>* rbuf, <span class="type">int</span> rcount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *rdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> line = <span class="number">-1</span>, rank, size, sendto, recvfrom, distance, blockcount, err = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ptrdiff_t</span> rlb, rext;</span><br><span class="line">    <span class="type">char</span> *tmpsend = <span class="literal">NULL</span>, *tmprecv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OPAL_OUTPUT</span>((ompi_coll_base_framework.framework_output,</span><br><span class="line">                 <span class="string">&quot;coll:base:allgather_intra_bruck rank %d&quot;</span>, rank));</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">ompi_datatype_get_extent</span> (rdtype, &amp;rlb, &amp;rext);</span><br><span class="line">    <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialization step:</span></span><br><span class="line"><span class="comment">       - if send buffer is not MPI_IN_PLACE, copy send buffer to block 0 of</span></span><br><span class="line"><span class="comment">       receive buffer, else</span></span><br><span class="line"><span class="comment">       - if rank r != 0, copy r^th block from receive buffer to block 0.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    tmprecv = (<span class="type">char</span>*) rbuf;</span><br><span class="line">    <span class="keyword">if</span> (MPI_IN_PLACE != sbuf) &#123;</span><br><span class="line">        tmpsend = (<span class="type">char</span>*) sbuf;</span><br><span class="line">        err = <span class="built_in">ompi_datatype_sndrcv</span>(tmpsend, scount, sdtype, tmprecv, rcount, rdtype);</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl;  &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> != rank) &#123;  <span class="comment">/* non root with MPI_IN_PLACE */</span></span><br><span class="line">        tmpsend = ((<span class="type">char</span>*)rbuf) + (<span class="type">ptrdiff_t</span>)rank * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line">        err = <span class="built_in">ompi_datatype_copy_content_same_ddt</span>(rdtype, rcount, tmprecv, tmpsend);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Communication step:</span></span><br><span class="line"><span class="comment">       At every step i, rank r:</span></span><br><span class="line"><span class="comment">       - doubles the distance</span></span><br><span class="line"><span class="comment">       - sends message which starts at begining of rbuf and has size</span></span><br><span class="line"><span class="comment">       (blockcount * rcount) to rank (r - distance)</span></span><br><span class="line"><span class="comment">       - receives message of size blockcount * rcount from rank (r + distance)</span></span><br><span class="line"><span class="comment">       at location (rbuf + distance * rcount * rext)</span></span><br><span class="line"><span class="comment">       - blockcount doubles until last step when only the remaining data is</span></span><br><span class="line"><span class="comment">       exchanged.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    blockcount = <span class="number">1</span>;</span><br><span class="line">    tmpsend = (<span class="type">char</span>*) rbuf;</span><br><span class="line">    <span class="keyword">for</span> (distance = <span class="number">1</span>; distance &lt; size; distance&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        recvfrom = (rank + distance) % size;</span><br><span class="line">        sendto = (rank - distance + size) % size;</span><br><span class="line"></span><br><span class="line">        tmprecv = tmpsend + (<span class="type">ptrdiff_t</span>)distance * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (distance &lt;= (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            blockcount = distance;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            blockcount = size - distance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Sendreceive</span></span><br><span class="line"><span class="comment">         * 如果是同一进程的话就是直接拷贝，否则执行recv-send-wait</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        err = <span class="built_in">ompi_coll_base_sendrecv</span>(tmpsend, blockcount * rcount, rdtype,</span><br><span class="line">                                       sendto, MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                       tmprecv, blockcount * rcount, rdtype,</span><br><span class="line">                                       recvfrom, MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                       comm, MPI_STATUS_IGNORE, rank);</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finalization step:</span></span><br><span class="line"><span class="comment">       除了0号进程, 重排数据:</span></span><br><span class="line"><span class="comment">       - 创建临时数组</span></span><br><span class="line"><span class="comment">       - copy blocks [0 .. (size - rank - 1)] from rbuf to shift buffer</span></span><br><span class="line"><span class="comment">       - move blocks [(size - rank) .. size] from rbuf to begining of rbuf</span></span><br><span class="line"><span class="comment">       - copy blocks from shift buffer starting at block [rank] in rbuf.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != rank) &#123;</span><br><span class="line">        <span class="type">char</span> *free_buf = <span class="literal">NULL</span>, *shift_buf = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">ptrdiff_t</span> span, gap = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        span = <span class="built_in">opal_datatype_span</span>(&amp;rdtype-&gt;super, (<span class="type">int64_t</span>)(size - rank) * rcount, &amp;gap);</span><br><span class="line"></span><br><span class="line">        free_buf = (<span class="type">char</span>*)<span class="built_in">calloc</span>(span, <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == free_buf) &#123;</span><br><span class="line">            line = __LINE__; err = OMPI_ERR_OUT_OF_RESOURCE; <span class="keyword">goto</span> err_hndl;</span><br><span class="line">        &#125;</span><br><span class="line">        shift_buf = free_buf - gap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1. copy blocks [0 .. (size - rank - 1)] from rbuf to shift buffer */</span></span><br><span class="line">        err = <span class="built_in">ompi_datatype_copy_content_same_ddt</span>(rdtype, ((<span class="type">ptrdiff_t</span>)(size - rank) * (<span class="type">ptrdiff_t</span>)rcount),</span><br><span class="line">                                                  shift_buf, rbuf);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123; line = __LINE__; <span class="built_in">free</span>(free_buf); <span class="keyword">goto</span> err_hndl;  &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2. move blocks [(size - rank) .. size] from rbuf to the begining of rbuf */</span></span><br><span class="line">        tmpsend = (<span class="type">char</span>*) rbuf + (<span class="type">ptrdiff_t</span>)(size - rank) * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line">        err = <span class="built_in">ompi_datatype_copy_content_same_ddt</span>(rdtype, (<span class="type">ptrdiff_t</span>)rank * (<span class="type">ptrdiff_t</span>)rcount,</span><br><span class="line">                                                  rbuf, tmpsend);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123; line = __LINE__; <span class="built_in">free</span>(free_buf); <span class="keyword">goto</span> err_hndl;  &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 3. copy blocks from shift buffer back to rbuf starting at block [rank]. */</span></span><br><span class="line">        tmprecv = (<span class="type">char</span>*) rbuf + (<span class="type">ptrdiff_t</span>)rank * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line">        err = <span class="built_in">ompi_datatype_copy_content_same_ddt</span>(rdtype, (<span class="type">ptrdiff_t</span>)(size - rank) * (<span class="type">ptrdiff_t</span>)rcount,</span><br><span class="line">                                                  tmprecv, shift_buf);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123; line = __LINE__; <span class="built_in">free</span>(free_buf); <span class="keyword">goto</span> err_hndl;  &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(free_buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OMPI_SUCCESS;</span><br><span class="line"></span><br><span class="line"> err_hndl:</span><br><span class="line">    <span class="built_in">OPAL_OUTPUT</span>((ompi_coll_base_framework.framework_output,  <span class="string">&quot;%s:%4d\tError occurred %d, rank %2d&quot;</span>,</span><br><span class="line">                 __FILE__, line, err, rank));</span><br><span class="line">    (<span class="type">void</span>)line;  <span class="comment">// silence compiler warning</span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">allgather using O(log(N)) steps.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Recursive doubling algorithm for MPI_Allgather implementation. This algorithm is used in MPICH-2 for small- and medium-sized messages on power-of-two processes.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当前的实现仅适用于二次幂个进程。 如果在非二次幂进程上调用此算法，则将调用布鲁克算法。这是蝶形的方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Example on 4 nodes:</span></span><br><span class="line"><span class="comment"> *   Initialization: everyone has its own buffer at location rank in rbuf</span></span><br><span class="line"><span class="comment"> *    #     0      1      2      3</span></span><br><span class="line"><span class="comment"> *         [0]    [ ]    [ ]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [1]    [ ]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [ ]    [2]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [ ]    [ ]    [3]</span></span><br><span class="line"><span class="comment"> *   Step 0: exchange data with (rank ^ 2^0)</span></span><br><span class="line"><span class="comment"> *    #     0      1      2      3</span></span><br><span class="line"><span class="comment"> *         [0]    [0]    [ ]    [ ]</span></span><br><span class="line"><span class="comment"> *         [1]    [1]    [ ]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [ ]    [2]    [2]</span></span><br><span class="line"><span class="comment"> *         [ ]    [ ]    [3]    [3]</span></span><br><span class="line"><span class="comment"> *   Step 1: exchange data with (rank ^ 2^1) (if you can)</span></span><br><span class="line"><span class="comment"> *    #     0      1      2      3</span></span><br><span class="line"><span class="comment"> *         [0]    [0]    [0]    [0]</span></span><br><span class="line"><span class="comment"> *         [1]    [1]    [1]    [1]</span></span><br><span class="line"><span class="comment"> *         [2]    [2]    [2]    [2]</span></span><br><span class="line"><span class="comment"> *         [3]    [3]    [3]    [3]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       我们可以修改代码以使用与 MPICH-2 相同的实现：</span></span><br><span class="line"><span class="comment"> *        - 使用递归减半算法，在每一步结束时，确定是否有节点在该步骤中没有交换数据，并向它们发送适当的消息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">ompi_coll_base_allgather_intra_recursivedoubling</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sbuf, <span class="type">int</span> scount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *sdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">void</span>* rbuf, <span class="type">int</span> rcount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *rdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> line = <span class="number">-1</span>, rank, size, pow2size, err;</span><br><span class="line">    <span class="type">int</span> remote, distance, sendblocklocation;</span><br><span class="line">    <span class="type">ptrdiff_t</span> rlb, rext;</span><br><span class="line">    <span class="type">char</span> *tmpsend = <span class="literal">NULL</span>, *tmprecv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line"></span><br><span class="line">    pow2size = <span class="built_in">opal_next_poweroftwo</span> (size);</span><br><span class="line">    pow2size &gt;&gt;=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当前的实现只处理进程的二次幂。 如果该函数在非二次幂的进程数上调用，</span></span><br><span class="line"><span class="comment">     * 则打印警告并使用相同的参数调用 bruck allgather 算法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (pow2size != size) &#123;</span><br><span class="line">        <span class="built_in">OPAL_OUTPUT</span>((ompi_coll_base_framework.framework_output,</span><br><span class="line">                     <span class="string">&quot;coll:base:allgather_intra_recursivedoubling WARNING: non-pow-2 size %d, switching to bruck algorithm&quot;</span>,</span><br><span class="line">                     size));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ompi_coll_base_allgather_intra_bruck</span>(sbuf, scount, sdtype,</span><br><span class="line">                                                     rbuf, rcount, rdtype,</span><br><span class="line">                                                     comm, <span class="keyword">module</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OPAL_OUTPUT</span>((ompi_coll_base_framework.framework_output,</span><br><span class="line">                 <span class="string">&quot;coll:base:allgather_intra_recursivedoubling rank %d, size %d&quot;</span>,</span><br><span class="line">                 rank, size));</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">ompi_datatype_get_extent</span> (rdtype, &amp;rlb, &amp;rext);</span><br><span class="line">    <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialization step:</span></span><br><span class="line"><span class="comment">       - if send buffer is not MPI_IN_PLACE, copy send buffer to block 0 of</span></span><br><span class="line"><span class="comment">       receive buffer</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (MPI_IN_PLACE != sbuf) &#123;</span><br><span class="line">        tmpsend = (<span class="type">char</span>*) sbuf;</span><br><span class="line">        tmprecv = (<span class="type">char</span>*) rbuf + (<span class="type">ptrdiff_t</span>)rank * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line">        err = <span class="built_in">ompi_datatype_sndrcv</span>(tmpsend, scount, sdtype, tmprecv, rcount, rdtype);</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl;  &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Communication step:</span></span><br><span class="line"><span class="comment">       At every step i, rank r:</span></span><br><span class="line"><span class="comment">       - exchanges message with rank remote = (r ^ 2^i).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sendblocklocation = rank;</span><br><span class="line">    <span class="keyword">for</span> (distance = <span class="number">0x1</span>; distance &lt; size; distance&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        remote = rank ^ distance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rank &lt; remote) &#123;</span><br><span class="line">            tmpsend = (<span class="type">char</span>*)rbuf + (<span class="type">ptrdiff_t</span>)sendblocklocation * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line">            tmprecv = (<span class="type">char</span>*)rbuf + (<span class="type">ptrdiff_t</span>)(sendblocklocation + distance) * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmpsend = (<span class="type">char</span>*)rbuf + (<span class="type">ptrdiff_t</span>)sendblocklocation * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line">            tmprecv = (<span class="type">char</span>*)rbuf + (<span class="type">ptrdiff_t</span>)(sendblocklocation - distance) * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line">            sendblocklocation -= distance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Sendreceive */</span></span><br><span class="line">        err = <span class="built_in">ompi_coll_base_sendrecv</span>(tmpsend, (<span class="type">ptrdiff_t</span>)distance * (<span class="type">ptrdiff_t</span>)rcount, rdtype,</span><br><span class="line">                                       remote, MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                       tmprecv, (<span class="type">ptrdiff_t</span>)distance * (<span class="type">ptrdiff_t</span>)rcount, rdtype,</span><br><span class="line">                                       remote, MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                       comm, MPI_STATUS_IGNORE, rank);</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OMPI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">allgather using O(log(N)) steps.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Description: 一种类似于 Bruck 的 allgather 算法的提议，但具有倒置的距离和不递减的交换数据大小.</span></span><br><span class="line"><span class="comment"> * Described in &quot;Sparbit: a new logarithmic-cost and data locality-aware MPI Allgather algorithm&quot;.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Example on 6 nodes, with l representing the highest power of two smaller than N, in this case l =</span></span><br><span class="line"><span class="comment"> * 4 (more details can be found on the paper):</span></span><br><span class="line"><span class="comment"> *  Initial state</span></span><br><span class="line"><span class="comment"> *    #     0      1      2      3      4      5</span></span><br><span class="line"><span class="comment"> *         [0]    [ ]    [ ]    [ ]    [ ]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [1]    [ ]    [ ]    [ ]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [ ]    [2]    [ ]    [ ]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [ ]    [ ]    [3]    [ ]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [ ]    [ ]    [ ]    [4]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [ ]    [ ]    [ ]    [ ]    [5]</span></span><br><span class="line"><span class="comment"> *   Step 0: 每个进程将自己的块发送到进程 r + l 并从 r - l 接收另一个块。</span></span><br><span class="line"><span class="comment"> *    #     0      1      2      3      4      5</span></span><br><span class="line"><span class="comment"> *         [0]    [ ]    [ ]    [ ]    [0]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [1]    [ ]    [ ]    [ ]    [1]</span></span><br><span class="line"><span class="comment"> *         [2]    [ ]    [2]    [ ]    [ ]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [3]    [ ]    [3]    [ ]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [ ]    [4]    [ ]    [4]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [ ]    [ ]    [5]    [ ]    [5]</span></span><br><span class="line"><span class="comment"> *   Step 1: 每个进程将自己的块发送到进程 r + l/2 并从 r - l/2 接收另一个块。</span></span><br><span class="line"><span class="comment"> *   上一步接收到的块被忽略以避免未来的双重写入。</span></span><br><span class="line"><span class="comment"> *    #     0      1      2      3      4      5</span></span><br><span class="line"><span class="comment"> *         [0]    [ ]    [0]    [ ]    [0]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [1]    [ ]    [1]    [ ]    [1]</span></span><br><span class="line"><span class="comment"> *         [2]    [ ]    [2]    [ ]    [2]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [3]    [ ]    [3]    [ ]    [3]</span></span><br><span class="line"><span class="comment"> *         [4]    [ ]    [4]    [ ]    [4]    [ ]</span></span><br><span class="line"><span class="comment"> *         [ ]    [5]    [ ]    [5]    [ ]    [5]</span></span><br><span class="line"><span class="comment"> *   Step 1: 每个进程将其拥有的所有数据（3 个块）发送到进程 r + l/4，</span></span><br><span class="line"><span class="comment"> *           并类似地从进程 r - l/4 接收所有数据。</span></span><br><span class="line"><span class="comment"> *    #     0      1      2      3      4      5</span></span><br><span class="line"><span class="comment"> *         [0]    [0]    [0]    [0]    [0]    [0]</span></span><br><span class="line"><span class="comment"> *         [1]    [1]    [1]    [1]    [1]    [1]</span></span><br><span class="line"><span class="comment"> *         [2]    [2]    [2]    [2]    [2]    [2]</span></span><br><span class="line"><span class="comment"> *         [3]    [3]    [3]    [3]    [3]    [3]</span></span><br><span class="line"><span class="comment"> *         [4]    [4]    [4]    [4]    [4]    [4]</span></span><br><span class="line"><span class="comment"> *         [5]    [5]    [5]    [5]    [5]    [5]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_base_allgather_intra_sparbit</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sbuf, <span class="type">int</span> scount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *sdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">void</span>* rbuf, <span class="type">int</span> rcount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *rdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                  <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* list of variable declaration */</span></span><br><span class="line">    <span class="type">int</span> rank = <span class="number">0</span>, comm_size = <span class="number">0</span>, comm_log = <span class="number">0</span>, exclusion = <span class="number">0</span>, data_expected = <span class="number">1</span>, transfer_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sendto, recvfrom, send_disp, recv_disp;</span><br><span class="line">    <span class="type">uint32_t</span> last_ignore, ignore_steps, distance = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> line = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ptrdiff_t</span> rlb, rext;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *tmpsend = <span class="literal">NULL</span>, *tmprecv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    MPI_Request *requests = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    comm_size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">ompi_datatype_get_extent</span>(rdtype, &amp;rlb, &amp;rext);</span><br><span class="line">    <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果未设置 MPI_IN_PLACE 条件，则将发送缓冲区复制到接收缓冲区以执行发送（所有数据都从 recv 缓冲区中提取和转发）</span></span><br><span class="line"><span class="comment">    /* tmprecv 和 tmpsend 用作抽象指针以简化发送和接收缓冲区的选择</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tmprecv = (<span class="type">char</span> *) rbuf;</span><br><span class="line">    <span class="keyword">if</span>(MPI_IN_PLACE != sbuf)&#123;</span><br><span class="line">        tmpsend = (<span class="type">char</span> *) sbuf; </span><br><span class="line">        err = <span class="built_in">ompi_datatype_sndrcv</span>(tmpsend, scount, sdtype, tmprecv + (<span class="type">ptrdiff_t</span>) rank * rcount * rext, rcount, rdtype);</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl;  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tmpsend = tmprecv;</span><br><span class="line"></span><br><span class="line">    requests = (MPI_Request *) <span class="built_in">malloc</span>(comm_size * <span class="built_in">sizeof</span>(MPI_Request));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* calculate log2 of the total process count */</span></span><br><span class="line">    comm_log = <span class="built_in">ceil</span>(<span class="built_in">log</span>(comm_size)/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">    distance &lt;&lt;= comm_log - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    last_ignore = __builtin_ctz(comm_size);</span><br><span class="line">    ignore_steps = (~((<span class="type">uint32_t</span>) comm_size &gt;&gt; last_ignore) | <span class="number">1</span>) &lt;&lt; last_ignore;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* perform the parallel binomial tree distribution steps */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; comm_log; ++i) &#123;</span><br><span class="line">       sendto = (rank + distance) % comm_size;  </span><br><span class="line">       recvfrom = (rank - distance + comm_size) % comm_size;  </span><br><span class="line">       exclusion = (distance &amp; ignore_steps) == distance;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (transfer_count = <span class="number">0</span>; transfer_count &lt; data_expected - exclusion; transfer_count++) &#123;</span><br><span class="line">           send_disp = (rank - <span class="number">2</span> * transfer_count * distance + comm_size) % comm_size;</span><br><span class="line">           recv_disp = (rank - (<span class="number">2</span> * transfer_count + <span class="number">1</span>) * distance + comm_size) % comm_size;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* 由于每个进程发送几个不连续的数据块，因此发送的每个块（因此每个发送和接收调用）都需要不同的标签。 */</span></span><br><span class="line">           <span class="comment">/* 由于基本 OpenMPI 只为 allgather 提供一个标签，我们被迫在 send 和 recv 调用中使用来自其他组件的标签空间 */</span></span><br><span class="line">           <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">isend</span>(tmpsend + (<span class="type">ptrdiff_t</span>) send_disp * scount * rext, scount, rdtype, sendto, MCA_COLL_BASE_TAG_HCOLL_BASE - send_disp, MCA_PML_BASE_SEND_STANDARD, comm, requests + transfer_count));</span><br><span class="line">           <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">irecv</span>(tmprecv + (<span class="type">ptrdiff_t</span>) recv_disp * rcount * rext, rcount, rdtype, recvfrom, MCA_COLL_BASE_TAG_HCOLL_BASE - recv_disp, comm, requests + data_expected - exclusion + transfer_count));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">ompi_request_wait_all</span>(transfer_count * <span class="number">2</span>, requests, MPI_STATUSES_IGNORE);</span><br><span class="line"></span><br><span class="line">       distance &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">       <span class="comment">/* calculates the data expected for the next step, based on the current number of blocks and eventual exclusions */</span></span><br><span class="line">       data_expected = (data_expected &lt;&lt; <span class="number">1</span>) - exclusion;</span><br><span class="line">       exclusion = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(requests);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OMPI_SUCCESS;</span><br><span class="line"></span><br><span class="line">err_hndl:</span><br><span class="line">    <span class="built_in">OPAL_OUTPUT</span>((ompi_coll_base_framework.framework_output,  <span class="string">&quot;%s:%4d\tError occurred %d, rank %2d&quot;</span>,</span><br><span class="line">                 __FILE__, line, err, rank));</span><br><span class="line">    (<span class="type">void</span>)line;  <span class="comment">// silence compiler warning</span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">allgather using O(N) steps.</span></span><br><span class="line"><span class="comment">allgather的环形算法。 在i步 ，rank r 接收来自 rank (r - 1) 的消息，其中包含来自 rank (r - i - 1) 的数据，并将包含来自 rank (r - i) 的数据的消息发送到 rank (r + 1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_base_allgather_intra_ring</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sbuf, <span class="type">int</span> scount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *sdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">void</span>* rbuf, <span class="type">int</span> rcount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *rdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> line = <span class="number">-1</span>, rank, size, err, sendto, recvfrom, i, recvdatafrom, senddatafrom;</span><br><span class="line">    <span class="type">ptrdiff_t</span> rlb, rext;</span><br><span class="line">    <span class="type">char</span> *tmpsend = <span class="literal">NULL</span>, *tmprecv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OPAL_OUTPUT</span>((ompi_coll_base_framework.framework_output,</span><br><span class="line">                 <span class="string">&quot;coll:base:allgather_intra_ring rank %d&quot;</span>, rank));</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">ompi_datatype_get_extent</span> (rdtype, &amp;rlb, &amp;rext);</span><br><span class="line">    <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialization step:</span></span><br><span class="line"><span class="comment">       - if send buffer is not MPI_IN_PLACE, copy send buffer to appropriate block</span></span><br><span class="line"><span class="comment">       of receive buffer</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    tmprecv = (<span class="type">char</span>*) rbuf + (<span class="type">ptrdiff_t</span>)rank * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line">    <span class="keyword">if</span> (MPI_IN_PLACE != sbuf) &#123;</span><br><span class="line">        tmpsend = (<span class="type">char</span>*) sbuf;</span><br><span class="line">        err = <span class="built_in">ompi_datatype_sndrcv</span>(tmpsend, scount, sdtype, tmprecv, rcount, rdtype);</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl;  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Communication step:</span></span><br><span class="line"><span class="comment">       At every step i: 0 .. (P-1), rank r:</span></span><br><span class="line"><span class="comment">       - 从 [(r - 1 + size) % size] 接收数据，其中包含 [(r - i - 1 + size) % size] 的数据</span></span><br><span class="line"><span class="comment">       - 发送给下一个进程[(r + 1) % size]，其中包含 [(r - i + size) % size]的数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sendto = (rank + <span class="number">1</span>) % size;</span><br><span class="line">    recvfrom  = (rank - <span class="number">1</span> + size) % size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        recvdatafrom = (rank - i - <span class="number">1</span> + size) % size;</span><br><span class="line">        senddatafrom = (rank - i + size) % size;</span><br><span class="line"></span><br><span class="line">        tmprecv = (<span class="type">char</span>*)rbuf + (<span class="type">ptrdiff_t</span>)recvdatafrom * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line">        tmpsend = (<span class="type">char</span>*)rbuf + (<span class="type">ptrdiff_t</span>)senddatafrom * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Sendreceive */</span></span><br><span class="line">        err = <span class="built_in">ompi_coll_base_sendrecv</span>(tmpsend, rcount, rdtype, sendto,</span><br><span class="line">                                       MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                       tmprecv, rcount, rdtype, recvfrom,</span><br><span class="line">                                       MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                       comm, MPI_STATUS_IGNORE, rank);</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OMPI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">allgather using N/2 steps (O(N))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Neighbor Exchange algorithm for allgather. Described by Chen et.al. in </span></span><br><span class="line"><span class="comment">&quot;Performance Evaluation of Allgather Algorithms on  Terascale Linux Cluster with Fast Ethernet&quot;,</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Rank r 与其中一个邻居交换消息，并在下一步进一步转发数据。算法仅适用于偶数进程。 对于奇数个进程，我们切换到环形算法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Example on 6 nodes:</span></span><br><span class="line"><span class="comment">Initial state</span></span><br><span class="line"><span class="comment">  #     0      1      2      3      4      5</span></span><br><span class="line"><span class="comment">       [0]    [ ]    [ ]    [ ]    [ ]    [ ]</span></span><br><span class="line"><span class="comment">       [ ]    [1]    [ ]    [ ]    [ ]    [ ]</span></span><br><span class="line"><span class="comment">       [ ]    [ ]    [2]    [ ]    [ ]    [ ]</span></span><br><span class="line"><span class="comment">       [ ]    [ ]    [ ]    [3]    [ ]    [ ]</span></span><br><span class="line"><span class="comment">       [ ]    [ ]    [ ]    [ ]    [4]    [ ]</span></span><br><span class="line"><span class="comment">       [ ]    [ ]    [ ]    [ ]    [ ]    [5]</span></span><br><span class="line"><span class="comment"> Step 0:</span></span><br><span class="line"><span class="comment">  #     0      1      2      3      4      5</span></span><br><span class="line"><span class="comment">       [0]    [0]    [ ]    [ ]    [ ]    [ ]</span></span><br><span class="line"><span class="comment">       [1]    [1]    [ ]    [ ]    [ ]    [ ]</span></span><br><span class="line"><span class="comment">       [ ]    [ ]    [2]    [2]    [ ]    [ ]</span></span><br><span class="line"><span class="comment">       [ ]    [ ]    [3]    [3]    [ ]    [ ]</span></span><br><span class="line"><span class="comment">       [ ]    [ ]    [ ]    [ ]    [4]    [4]</span></span><br><span class="line"><span class="comment">       [ ]    [ ]    [ ]    [ ]    [5]    [5]</span></span><br><span class="line"><span class="comment"> Step 1:</span></span><br><span class="line"><span class="comment">  #     0      1      2      3      4      5</span></span><br><span class="line"><span class="comment">       [0]    [0]    [0]    [ ]    [ ]    [0]</span></span><br><span class="line"><span class="comment">       [1]    [1]    [1]    [ ]    [ ]    [1]</span></span><br><span class="line"><span class="comment">       [ ]    [2]    [2]    [2]    [2]    [ ]</span></span><br><span class="line"><span class="comment">       [ ]    [3]    [3]    [3]    [3]    [ ]</span></span><br><span class="line"><span class="comment">       [4]    [ ]    [ ]    [4]    [4]    [4]</span></span><br><span class="line"><span class="comment">       [5]    [ ]    [ ]    [5]    [5]    [5]</span></span><br><span class="line"><span class="comment"> Step 2:</span></span><br><span class="line"><span class="comment">  #     0      1      2      3      4      5</span></span><br><span class="line"><span class="comment">       [0]    [0]    [0]    [0]    [0]    [0]</span></span><br><span class="line"><span class="comment">       [1]    [1]    [1]    [1]    [1]    [1]</span></span><br><span class="line"><span class="comment">       [2]    [2]    [2]    [2]    [2]    [2]</span></span><br><span class="line"><span class="comment">       [3]    [3]    [3]    [3]    [3]    [3]</span></span><br><span class="line"><span class="comment">       [4]    [4]    [4]    [4]    [4]    [4]</span></span><br><span class="line"><span class="comment">       [5]    [5]    [5]    [5]    [5]    [5]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">ompi_coll_base_allgather_intra_neighborexchange</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sbuf, <span class="type">int</span> scount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *sdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">void</span>* rbuf, <span class="type">int</span> rcount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *rdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> line = <span class="number">-1</span>, rank, size, i, even_rank, err;</span><br><span class="line">    <span class="type">int</span> neighbor[<span class="number">2</span>], offset_at_step[<span class="number">2</span>], recv_data_from[<span class="number">2</span>], send_data_from;</span><br><span class="line">    <span class="type">ptrdiff_t</span> rlb, rext;</span><br><span class="line">    <span class="type">char</span> *tmpsend = <span class="literal">NULL</span>, *tmprecv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">    rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size % <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">OPAL_OUTPUT</span>((ompi_coll_base_framework.framework_output, <span class="string">&quot;coll:base:allgather_intra_neighborexchange WARNING: odd size %d, switching to ring algorithm&quot;</span>, size));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ompi_coll_base_allgather_intra_ring</span>(sbuf, scount, sdtype, rbuf, rcount, rdtype, comm, <span class="keyword">module</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">ompi_datatype_get_extent</span> (rdtype, &amp;rlb, &amp;rext);</span><br><span class="line">    <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialization step:</span></span><br><span class="line"><span class="comment">       - if send buffer is not MPI_IN_PLACE, copy send buffer to appropriate block</span></span><br><span class="line"><span class="comment">       of receive buffer</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    tmprecv = (<span class="type">char</span>*) rbuf + (<span class="type">ptrdiff_t</span>)rank *(<span class="type">ptrdiff_t</span>) rcount * rext;</span><br><span class="line">    <span class="keyword">if</span> (MPI_IN_PLACE != sbuf) &#123;</span><br><span class="line">        tmpsend = (<span class="type">char</span>*) sbuf;</span><br><span class="line">        err = <span class="built_in">ompi_datatype_sndrcv</span>(tmpsend, scount, sdtype, tmprecv, rcount, rdtype);</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl;  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Determine neighbors, order in which blocks will arrive, etc. */</span></span><br><span class="line">    even_rank = !(rank % <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (even_rank) &#123;</span><br><span class="line">        neighbor[<span class="number">0</span>] = (rank + <span class="number">1</span>) % size;</span><br><span class="line">        neighbor[<span class="number">1</span>] = (rank - <span class="number">1</span> + size) % size;</span><br><span class="line">        recv_data_from[<span class="number">0</span>] = rank;</span><br><span class="line">        recv_data_from[<span class="number">1</span>] = rank;</span><br><span class="line">        offset_at_step[<span class="number">0</span>] = (+<span class="number">2</span>);</span><br><span class="line">        offset_at_step[<span class="number">1</span>] = (<span class="number">-2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        neighbor[<span class="number">0</span>] = (rank - <span class="number">1</span> + size) % size;</span><br><span class="line">        neighbor[<span class="number">1</span>] = (rank + <span class="number">1</span>) % size;</span><br><span class="line">        recv_data_from[<span class="number">0</span>] = neighbor[<span class="number">0</span>];</span><br><span class="line">        recv_data_from[<span class="number">1</span>] = neighbor[<span class="number">0</span>];</span><br><span class="line">        offset_at_step[<span class="number">0</span>] = (<span class="number">-2</span>);</span><br><span class="line">        offset_at_step[<span class="number">1</span>] = (+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Communication loop:</span></span><br><span class="line"><span class="comment">       - First step is special: exchange a single block with neighbor[0].</span></span><br><span class="line"><span class="comment">       - Rest of the steps:</span></span><br><span class="line"><span class="comment">       根据偏移量更新recv_data_from，以及</span></span><br><span class="line"><span class="comment">       与适当的邻居交换两个块。</span></span><br><span class="line"><span class="comment">       发送位置成为先前的接收位置。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    tmprecv = (<span class="type">char</span>*)rbuf + (<span class="type">ptrdiff_t</span>)neighbor[<span class="number">0</span>] * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line">    tmpsend = (<span class="type">char</span>*)rbuf + (<span class="type">ptrdiff_t</span>)rank * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line">    <span class="comment">/* Sendreceive */</span></span><br><span class="line">    err = <span class="built_in">ompi_coll_base_sendrecv</span>(tmpsend, rcount, rdtype, neighbor[<span class="number">0</span>],</span><br><span class="line">                                   MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                   tmprecv, rcount, rdtype, neighbor[<span class="number">0</span>],</span><br><span class="line">                                   MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                   comm, MPI_STATUS_IGNORE, rank);</span><br><span class="line">    <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Determine initial sending location */</span></span><br><span class="line">    <span class="keyword">if</span> (even_rank) &#123;</span><br><span class="line">        send_data_from = rank;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        send_data_from = recv_data_from[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; (size / <span class="number">2</span>); i++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> i_parity = i % <span class="number">2</span>;</span><br><span class="line">        recv_data_from[i_parity] =</span><br><span class="line">            (recv_data_from[i_parity] + offset_at_step[i_parity] + size) % size;</span><br><span class="line"></span><br><span class="line">        tmprecv = (<span class="type">char</span>*)rbuf + (<span class="type">ptrdiff_t</span>)recv_data_from[i_parity] * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line">        tmpsend = (<span class="type">char</span>*)rbuf + (<span class="type">ptrdiff_t</span>)send_data_from * rcount * rext;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Sendreceive */</span></span><br><span class="line">        err = <span class="built_in">ompi_coll_base_sendrecv</span>(tmpsend, (<span class="type">ptrdiff_t</span>)<span class="number">2</span> * (<span class="type">ptrdiff_t</span>)rcount, rdtype,</span><br><span class="line">                                       neighbor[i_parity],</span><br><span class="line">                                       MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                       tmprecv, (<span class="type">ptrdiff_t</span>)<span class="number">2</span> * (<span class="type">ptrdiff_t</span>)rcount, rdtype,</span><br><span class="line">                                       neighbor[i_parity],</span><br><span class="line">                                       MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                       comm, MPI_STATUS_IGNORE, rank);</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line"></span><br><span class="line">        send_data_from = recv_data_from[i_parity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OMPI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ompi_coll_base_allgather_intra_two_procs</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sbuf, <span class="type">int</span> scount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *sdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">void</span>* rbuf, <span class="type">int</span> rcount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *rdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                              <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> line = <span class="number">-1</span>, err, rank, remote;</span><br><span class="line">    <span class="type">char</span> *tmpsend = <span class="literal">NULL</span>, *tmprecv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">ptrdiff_t</span> rext, lb;</span><br><span class="line"></span><br><span class="line">    rank = <span class="built_in">ompi_comm_rank</span>(comm);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OPAL_OUTPUT</span>((ompi_coll_base_framework.framework_output,</span><br><span class="line">                 <span class="string">&quot;ompi_coll_base_allgather_intra_two_procs rank %d&quot;</span>, rank));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> != <span class="built_in">ompi_comm_size</span>(comm)) &#123;</span><br><span class="line">        <span class="keyword">return</span> MPI_ERR_UNSUPPORTED_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">ompi_datatype_get_extent</span> (rdtype, &amp;lb, &amp;rext);</span><br><span class="line">    <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exchange data:</span></span><br><span class="line"><span class="comment">       - compute source and destinations</span></span><br><span class="line"><span class="comment">       - send receive data</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    remote  = rank ^ <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">    tmpsend = (<span class="type">char</span>*)sbuf;</span><br><span class="line">    <span class="keyword">if</span> (MPI_IN_PLACE == sbuf) &#123;</span><br><span class="line">        tmpsend = (<span class="type">char</span>*)rbuf + (<span class="type">ptrdiff_t</span>)rank * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line">        scount = rcount;</span><br><span class="line">        sdtype = rdtype;</span><br><span class="line">    &#125;</span><br><span class="line">    tmprecv = (<span class="type">char</span>*)rbuf + (<span class="type">ptrdiff_t</span>)remote * (<span class="type">ptrdiff_t</span>)rcount * rext;</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">ompi_coll_base_sendrecv</span>(tmpsend, scount, sdtype, remote,</span><br><span class="line">                                   MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                   tmprecv, rcount, rdtype, remote,</span><br><span class="line">                                   MCA_COLL_BASE_TAG_ALLGATHER,</span><br><span class="line">                                   comm, MPI_STATUS_IGNORE, rank);</span><br><span class="line">    <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Place your data in correct location if necessary */</span></span><br><span class="line">    <span class="keyword">if</span> (MPI_IN_PLACE != sbuf) &#123;</span><br><span class="line">        err = <span class="built_in">ompi_datatype_sndrcv</span>((<span class="type">char</span>*)sbuf, scount, sdtype,</span><br><span class="line">                                   (<span class="type">char</span>*)rbuf + (<span class="type">ptrdiff_t</span>)rank * (<span class="type">ptrdiff_t</span>)rcount * rext, rcount, rdtype);</span><br><span class="line">        <span class="keyword">if</span> (MPI_SUCCESS != err) &#123; line = __LINE__; <span class="keyword">goto</span> err_hndl;  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MPI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线性函数是从 BASIC coll 模块复制的，它们不会对消息进行分段并且是简单的实现，</span></span><br><span class="line"><span class="comment"> * 但对于一些少量节点和/或小数据大小，它们与基于基/树的分段操作一样快</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    Function:    - allgather using other MPI collections</span></span><br><span class="line"><span class="comment"> *    Accepts:    - same as MPI_Allgather()</span></span><br><span class="line"><span class="comment"> *    Returns:    - MPI_SUCCESS or error code</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">ompi_coll_base_allgather_intra_basic_linear</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sbuf, <span class="type">int</span> scount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *sdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">void</span> *rbuf,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">int</span> rcount,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *rdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">ptrdiff_t</span> lb, extent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle MPI_IN_PLACE  -- note that rank 0 can use IN_PLACE</span></span><br><span class="line"><span class="comment">       natively, and we can just alias the right position in rbuf</span></span><br><span class="line"><span class="comment">       as sbuf and avoid using a temporary buffer if gather is</span></span><br><span class="line"><span class="comment">       implemented correctly */</span></span><br><span class="line">    <span class="keyword">if</span> (MPI_IN_PLACE == sbuf &amp;&amp; <span class="number">0</span> != <span class="built_in">ompi_comm_rank</span>(comm)) &#123;</span><br><span class="line">        <span class="built_in">ompi_datatype_get_extent</span>(rdtype, &amp;lb, &amp;extent);</span><br><span class="line">        sbuf = ((<span class="type">char</span>*) rbuf) + (<span class="built_in">ompi_comm_rank</span>(comm) * extent * rcount);</span><br><span class="line">        sdtype = rdtype;</span><br><span class="line">        scount = rcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Gather and broadcast. */</span></span><br><span class="line"></span><br><span class="line">    err = comm-&gt;c_coll-&gt;<span class="built_in">coll_gather</span>(sbuf, scount, sdtype,</span><br><span class="line">                                   rbuf, rcount, rdtype,</span><br><span class="line">                                   <span class="number">0</span>, comm, comm-&gt;c_coll-&gt;coll_gather_module);</span><br><span class="line">    <span class="keyword">if</span> (MPI_SUCCESS == err) &#123;</span><br><span class="line">        <span class="type">size_t</span> length = (<span class="type">ptrdiff_t</span>)rcount * <span class="built_in">ompi_comm_size</span>(comm);</span><br><span class="line">        <span class="keyword">if</span>( length &lt; (<span class="type">size_t</span>)INT_MAX ) &#123;</span><br><span class="line">            err = comm-&gt;c_coll-&gt;<span class="built_in">coll_bcast</span>(rbuf, (<span class="type">ptrdiff_t</span>)rcount * <span class="built_in">ompi_comm_size</span>(comm), rdtype,</span><br><span class="line">                                          <span class="number">0</span>, comm, comm-&gt;c_coll-&gt;coll_bcast_module);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">ompi_datatype_t</span>* temptype;</span><br><span class="line">            <span class="built_in">ompi_datatype_create_contiguous</span>(<span class="built_in">ompi_comm_size</span>(comm), rdtype, &amp;temptype);</span><br><span class="line">            <span class="built_in">ompi_datatype_commit</span>(&amp;temptype);</span><br><span class="line">            err = comm-&gt;c_coll-&gt;<span class="built_in">coll_bcast</span>(rbuf, rcount, temptype,</span><br><span class="line">                                          <span class="number">0</span>, comm, comm-&gt;c_coll-&gt;coll_bcast_module);</span><br><span class="line">            <span class="built_in">ompi_datatype_destroy</span>(&amp;temptype);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="MPI-Gather"><a href="#MPI-Gather" class="headerlink" title="MPI_Gather"></a>MPI_Gather</h1><p>首先检查缓冲区是否正确，通信域是否正确，是否跨通信域，如果没问题直接调用<code>coll_gather</code>，有如下几个实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mca_coll_basic_gather_inter</span><br><span class="line">ompi_coll_base_gather_intra_basic_linear</span><br><span class="line">mca_coll_self_gather_intra</span><br></pre></td></tr></table></figure></p>
<p>以下几个实现很简单：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">mca_coll_basic_gather_inter</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *sbuf, <span class="type">int</span> scount,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *sdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">void</span> *rbuf, <span class="type">int</span> rcount,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="keyword">struct</span> <span class="type">ompi_datatype_t</span> *rdtype,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">int</span> root, <span class="keyword">struct</span> <span class="type">ompi_communicator_t</span> *comm,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">mca_coll_base_module_t</span> *<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">char</span> *ptmp;</span><br><span class="line">    MPI_Aint incr;</span><br><span class="line">    MPI_Aint extent;</span><br><span class="line">    MPI_Aint lb;</span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">ompi_comm_remote_size</span>(comm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (MPI_PROC_NULL == root) &#123;</span><br><span class="line">        <span class="comment">/* do nothing */</span></span><br><span class="line">        err = OMPI_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MPI_ROOT != root) &#123;</span><br><span class="line">        <span class="comment">/* Everyone but root sends data and returns. */</span></span><br><span class="line">        err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">send</span>(sbuf, scount, sdtype, root,</span><br><span class="line">                                MCA_COLL_BASE_TAG_GATHER,</span><br><span class="line">                                MCA_PML_BASE_SEND_STANDARD, comm));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* I am the root, loop receiving the data. */</span></span><br><span class="line">        err = <span class="built_in">ompi_datatype_get_extent</span>(rdtype, &amp;lb, &amp;extent);</span><br><span class="line">        <span class="keyword">if</span> (OMPI_SUCCESS != err) &#123;</span><br><span class="line">            <span class="keyword">return</span> OMPI_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        incr = extent * rcount;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>, ptmp = (<span class="type">char</span> *) rbuf; i &lt; size; ++i, ptmp += incr) &#123;</span><br><span class="line">            err = <span class="built_in">MCA_PML_CALL</span>(<span class="built_in">recv</span>(ptmp, rcount, rdtype, i,</span><br><span class="line">                                    MCA_COLL_BASE_TAG_GATHER,</span><br><span class="line">                                    comm, MPI_STATUS_IGNORE));</span><br><span class="line">            <span class="keyword">if</span> (MPI_SUCCESS != err) &#123;</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Request结构"><a href="#Request结构" class="headerlink" title="Request结构"></a>Request结构</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main top-level request struct definition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ompi_request_t</span> &#123;</span><br><span class="line">    <span class="type">opal_free_list_item_t</span> super;                <span class="comment">/**&lt; Base type */</span></span><br><span class="line">    <span class="type">ompi_request_type_t</span> req_type;               <span class="comment">/**&lt; Enum indicating the type of the request */</span></span><br><span class="line">    <span class="type">ompi_status_public_t</span> req_status;            <span class="comment">/**&lt; Completion status */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">void</span> *req_complete;                <span class="comment">/**&lt; Flag indicating wether request has completed */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">ompi_request_state_t</span> req_state;    <span class="comment">/**&lt; enum indicate state of the request */</span></span><br><span class="line">    <span class="type">bool</span> req_persistent;                        <span class="comment">/**&lt; flag indicating if the this is a persistent request */</span></span><br><span class="line">    <span class="type">int</span> req_f_to_c_index;                       <span class="comment">/**&lt; Index in Fortran &lt;-&gt; C translation array */</span></span><br><span class="line">    <span class="type">ompi_request_start_fn_t</span> req_start;          <span class="comment">/**&lt; Called by MPI_START and MPI_STARTALL */</span></span><br><span class="line">    <span class="type">ompi_request_free_fn_t</span> req_free;            <span class="comment">/**&lt; Called by free */</span></span><br><span class="line">    <span class="type">ompi_request_cancel_fn_t</span> req_cancel;        <span class="comment">/**&lt; Optional function to cancel the request */</span></span><br><span class="line">    <span class="type">ompi_request_complete_fn_t</span> req_complete_cb; <span class="comment">/**&lt; Called when the request is MPI completed */</span></span><br><span class="line">    <span class="type">void</span> *req_complete_cb_data;</span><br><span class="line">    <span class="type">ompi_mpi_object_t</span> req_mpi_object;           <span class="comment">/**&lt; Pointer to MPI object that created this request */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ompi_predefined_request_t</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ompi_request_t</span> request;</span><br><span class="line">    <span class="type">char</span> padding[PREDEFINED_REQUEST_PAD - <span class="built_in">sizeof</span>(<span class="type">ompi_request_t</span>)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ompi_predefined_request_t</span> <span class="type">ompi_predefined_request_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化一个请求。 这是一个避免函数调用开销的宏，因为它通常在关键性能路径中调用（因为请求可能被重用，我们可能必须多次初始化请求）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_REQUEST_INIT(request, persistent)                  \</span></span><br><span class="line"><span class="meta">    do &#123;                                                        \</span></span><br><span class="line"><span class="meta">        (request)-&gt;req_complete =                               \</span></span><br><span class="line"><span class="meta">            (persistent) ? REQUEST_COMPLETED : REQUEST_PENDING; \</span></span><br><span class="line"><span class="meta">        (request)-&gt;req_state = OMPI_REQUEST_INACTIVE;           \</span></span><br><span class="line"><span class="meta">        (request)-&gt;req_persistent = (persistent);               \</span></span><br><span class="line"><span class="meta">        (request)-&gt;req_complete_cb  = NULL;                     \</span></span><br><span class="line"><span class="meta">        (request)-&gt;req_complete_cb_data = NULL;                 \</span></span><br><span class="line"><span class="meta">    &#125; while (0);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_COMPLETE(req)        (REQUEST_COMPLETED == (req)-&gt;req_complete)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成请求。 这是一个避免函数调用开销的宏，因为它通常在关键性能路径中调用（因为请求可能被重用，我们可能不得不多次完成一个请求）。</span></span><br><span class="line"><span class="comment"> * 当最终确定一个请求时，如果之前对该请求调用了 MPI_Request_f2c()，则该请求已添加到 f2c 表中，我们需要将其删除</span></span><br><span class="line"><span class="comment"> * 该函数只能从 MPI 层调用。 永远不要从 PML 调用它。</span></span><br><span class="line"><span class="comment"> * 它负责上层清理工作。 当用户调用 MPI_Request_free 时，我们应该释放所有 MPI 级别的资源，所以我们也必须调用这个函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_REQUEST_FINI(request)                                      \</span></span><br><span class="line"><span class="meta">do &#123;                                                                    \</span></span><br><span class="line"><span class="meta">    (request)-&gt;req_state = OMPI_REQUEST_INVALID;                        \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (MPI_UNDEFINED != (request)-&gt;req_f_to_c_index) &#123;                 \</span></span><br><span class="line"><span class="meta">        opal_pointer_array_set_item(&amp;ompi_request_f_to_c_table,         \</span></span><br><span class="line"><span class="meta">                                    (request)-&gt;req_f_to_c_index, NULL); \</span></span><br><span class="line"><span class="meta">        (request)-&gt;req_f_to_c_index = MPI_UNDEFINED;                    \</span></span><br><span class="line"><span class="meta">    &#125;                                                                   \</span></span><br><span class="line"><span class="meta">&#125; while (0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 除了在返回 MPI_ERR_IN_STATUS 的过程中，状态对象的 MPI_ERROR 字段永远不会被修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OMPI_COPY_STATUS(pdst, src, is_err_in_status)                   \</span></span><br><span class="line"><span class="meta">do &#123;                                                                    \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (is_err_in_status) &#123;                                             \</span></span><br><span class="line"><span class="meta">        *(pdst) = (src);                                                \</span></span><br><span class="line"><span class="meta">    &#125;                                                                   \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;                                                              \</span></span><br><span class="line"><span class="meta">        (pdst)-&gt;MPI_TAG = (src).MPI_TAG;                                \</span></span><br><span class="line"><span class="meta">        (pdst)-&gt;MPI_SOURCE = (src).MPI_SOURCE;                          \</span></span><br><span class="line"><span class="meta">        (pdst)-&gt;_ucount = (src)._ucount;                                \</span></span><br><span class="line"><span class="meta">        (pdst)-&gt;_cancelled = (src)._cancelled;                          \</span></span><br><span class="line"><span class="meta">    &#125;                                                                   \</span></span><br><span class="line"><span class="meta">&#125; while(0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request相关的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ompi_request_fns_t</span> &#123;</span><br><span class="line">    <span class="type">ompi_request_test_fn_t</span>      req_test;</span><br><span class="line">    <span class="type">ompi_request_test_any_fn_t</span>  req_test_any;</span><br><span class="line">    <span class="type">ompi_request_test_all_fn_t</span>  req_test_all;</span><br><span class="line">    <span class="type">ompi_request_test_some_fn_t</span> req_test_some;</span><br><span class="line">    <span class="type">ompi_request_wait_fn_t</span>      req_wait;</span><br><span class="line">    <span class="type">ompi_request_wait_any_fn_t</span>  req_wait_any;</span><br><span class="line">    <span class="type">ompi_request_wait_all_fn_t</span>  req_wait_all;</span><br><span class="line">    <span class="type">ompi_request_wait_some_fn_t</span> req_wait_some;</span><br><span class="line">&#125; <span class="type">ompi_request_fns_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/03/21/%E4%B8%8D%E5%90%8Ccpp%E7%89%88%E6%9C%AC%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/21/%E4%B8%8D%E5%90%8Ccpp%E7%89%88%E6%9C%AC%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="url">c++11/14、c++17/20 最简单的线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-21T11:07:00+08:00">
                2022-03-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="c-11-最基础最简单的："><a href="#c-11-最基础最简单的：" class="headerlink" title="c++11 最基础最简单的："></a>c++11 最基础最简单的：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>();</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> num);</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">    std::future&lt;<span class="type">int</span>&gt; <span class="title">enqueue</span><span class="params">(F&amp; f, Args&amp;... args)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector &lt;std::thread&gt; workers; <span class="comment">//thread array</span></span><br><span class="line"></span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt;tasks; <span class="comment">//task queue</span></span><br><span class="line"></span><br><span class="line">    std::mutex queue_mutex;</span><br><span class="line">    std::condition_variable cond;</span><br><span class="line">    <span class="type">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> num) :<span class="built_in">stop</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> thread = [<span class="keyword">this</span>] &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;)</span><br><span class="line">            &#123;</span><br><span class="line">                std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;queue_mutex)</span></span>;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>();<span class="comment">//stop 或许任务队列不为空时唤醒。</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>())</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    task = std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">                    tasks.<span class="built_in">pop</span>();<span class="comment">//有点类似bfs的思路</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">task</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        workers.<span class="built_in">emplace_back</span>(thread);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cond.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; worker : workers)</span><br><span class="line">    &#123;</span><br><span class="line">        worker.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">std::future&lt;<span class="type">int</span>&gt; <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp; f, Args&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::function&lt;<span class="keyword">decltype</span>(f(args...))()&gt; func = </span><br><span class="line">        std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); <span class="comment">// 连接函数和参数定义，特殊函数类型，避免左右值错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt; std::packaged_task&lt;<span class="built_in">int</span>()&gt; &gt;(</span><br><span class="line">     func</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; warpper_func = [task]()&#123;(*task)();&#125;;</span><br><span class="line">      <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">      tasks.<span class="built_in">emplace</span>(warpper_func);</span><br><span class="line">     cond.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    std::vector&lt;std::future&lt;<span class="type">int</span>&gt;&gt;results;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> tp = [i] &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;hello &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">           <span class="comment">// std::this_thread::sleep_for(std::chrono::seconds(1));</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;world &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> i * i;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        results.<span class="built_in">emplace_back</span>(</span><br><span class="line">            pool.<span class="built_in">enqueue</span>((tp))</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; result : results)</span><br><span class="line">        std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="C-11-14-一般性的线程池"><a href="#C-11-14-一般性的线程池" class="headerlink" title="C++11/14 一般性的线程池"></a>C++11/14 一般性的线程池</h1><p>上面我们有很多不足，比如限定了task function的返回值，而且逻辑不够优美。我们接着进行优化！</p>
<p>关于task function的 return type 是未定的问题，c++11 给出了两种方式。一个是decltype(expr),另外一个是std::result_of. 都可以通过尾置返回值类型进行处理。</p>
<p>我们首先使用decltype. 完整代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ThreadPool</span>();</span><br><span class="line">	<span class="built_in">ThreadPool</span>(<span class="type">int</span> num);</span><br><span class="line">	~<span class="built_in">ThreadPool</span>();</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"><span class="comment">//		-&gt;std::future&lt;decltype(f(args...))&gt;;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span>:</span></span><br><span class="line"><span class="function">	std::vector &lt;std::thread&gt; workers;</span> <span class="comment">//thread array</span></span><br><span class="line"></span><br><span class="line">	std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt;tasks; <span class="comment">//task queue</span></span><br><span class="line"></span><br><span class="line">	std::mutex queue_mutex;</span><br><span class="line">	std::condition_variable cond;</span><br><span class="line">	<span class="type">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> num) :<span class="built_in">stop</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> thread = [<span class="keyword">this</span>] &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;)</span><br><span class="line">            &#123;</span><br><span class="line">                std::function&lt;<span class="built_in">void</span>()&gt; task;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;queue_mutex)</span></span>;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>();<span class="comment">//stop 或许任务队列不为空时唤醒。</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>())</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    task = std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">                    tasks.<span class="built_in">pop</span>();<span class="comment">//有点类似bfs的思路</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">task</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        workers.<span class="built_in">emplace_back</span>(thread);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">		stop = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cond.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; worker : workers)</span><br><span class="line">	&#123;</span><br><span class="line">		worker.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">-&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> ret_type = std::future&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))&gt;;</span><br><span class="line">	std::function&lt;<span class="keyword">decltype</span>(f(args...))()&gt; func =</span><br><span class="line">		std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); <span class="comment">// 连接函数和参数定义，特殊函数类型，避免左右值错误</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> task = std::make_shared&lt; std::packaged_task&lt;<span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt; &gt;(</span><br><span class="line">		func</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">	std::function&lt;<span class="type">void</span>()&gt; warpper_func = [task]() &#123;(*task)(); &#125;;</span><br><span class="line">	ret_type res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">	<span class="keyword">if</span> (stop)</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">	tasks.<span class="built_in">emplace</span>(warpper_func);</span><br><span class="line">	cond.<span class="built_in">notify_one</span>();</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>优化版createthread 单独抽出来组成一个接口。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ThreadPool</span>();</span><br><span class="line">	<span class="built_in">ThreadPool</span>(<span class="type">int</span> num);</span><br><span class="line">	~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">CreateThread</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//template&lt;class F, class...Args&gt;</span></span><br><span class="line">	<span class="comment">//auto enqueue(F&amp;&amp; f, Args&amp;&amp;...args)-&gt;std::future&lt;typename std::_Forced_result_type&lt;F(Args...)&gt;::type&gt;;</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F &amp;&amp;f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">	-&gt;std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector &lt;std::thread&gt; workers; <span class="comment">//thread array</span></span><br><span class="line"></span><br><span class="line">	std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt;tasks; <span class="comment">//task queue</span></span><br><span class="line"></span><br><span class="line">	std::mutex queue_mutex;</span><br><span class="line">	std::condition_variable cond;</span><br><span class="line">	<span class="type">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ThreadPool::CreateThread</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (;;)</span><br><span class="line">	&#123;</span><br><span class="line">		std::function&lt;<span class="type">void</span>()&gt; task;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(<span class="keyword">this</span>-&gt;queue_mutex)</span></span>;</span><br><span class="line">			<span class="keyword">this</span>-&gt;cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>();<span class="comment">//stop 或许任务队列不为空时唤醒。</span></span><br><span class="line">				&#125;</span><br><span class="line">			);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (stop &amp;&amp; tasks.<span class="built_in">empty</span>())</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			task = std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());</span><br><span class="line">			tasks.<span class="built_in">pop</span>();<span class="comment">//有点类似bfs的思路</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">task</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> num) :<span class="built_in">stop</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> thread = std::<span class="built_in">bind</span>(&amp;ThreadPool::CreateThread,<span class="keyword">this</span>);<span class="comment">//&amp;，this 不能丢</span></span><br><span class="line">		workers.<span class="built_in">emplace_back</span>(thread);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//或者直接下面</span></span><br><span class="line">		<span class="comment">//workers.emplace_back(std::bind(&amp;ThreadPool::CreateThread, this));</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">		stop = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cond.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; worker : workers)</span><br><span class="line">	&#123;</span><br><span class="line">		worker.<span class="built_in">join</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">-&gt;std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> ret_type = std::future&lt; <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))&gt;; <span class="comment">//typename 此处加不加均可以的，下面同</span></span><br><span class="line">	std::function&lt; <span class="keyword">decltype</span>(f(args...))()&gt; func =</span><br><span class="line">		std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); <span class="comment">// 连接函数和参数定义，特殊函数类型，避免左右值错误</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> task = std::make_shared&lt; std::packaged_task&lt; <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...))()&gt; &gt;(</span><br><span class="line">		func</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">	std::function&lt;<span class="type">void</span>()&gt; warpper_func = [task]() &#123;(*task)(); &#125;;</span><br><span class="line">	ret_type res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">	<span class="keyword">if</span> (stop)</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">	tasks.<span class="built_in">emplace</span>(warpper_func);</span><br><span class="line">	cond.<span class="built_in">notify_one</span>();</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>test 代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    std::vector&lt;std::future&lt;<span class="type">int</span>&gt;&gt;results;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> tp = [i] &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;hello &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;world &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> i * i;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> ans = pool.<span class="built_in">enqueue</span>(std::<span class="built_in">move</span>(tp));</span><br><span class="line">        results.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(ans));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; result : results)</span><br><span class="line">        std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那我们现在采用第二种方式。</p>
<p>需要更改的地方如下：</p>
<p>enqueue 的声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">	<span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">	-&gt;std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span>;</span><br></pre></td></tr></table></figure></p>
<p>enqueue 的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">-&gt;std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="title">F</span><span class="params">(Args...)</span>&gt;::type&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> ret_type = std::future&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::type&gt;; <span class="comment">//typename 此处加不加均可以的，下面同</span></span><br><span class="line">	std::function&lt;<span class="keyword">typename</span> std::result_of&lt;F(Args...)&gt;::<span class="built_in">type</span>()&gt; func =</span><br><span class="line">		std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...); <span class="comment">// 连接函数和参数定义，特殊函数类型，避免左右值错误</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> task = std::make_shared&lt; std::packaged_task&lt;<span class="keyword">typename</span> std::result_of&lt;<span class="built_in">F</span>(Args...)&gt;::<span class="built_in">type</span>()&gt; &gt;(</span><br><span class="line">		func</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">	std::function&lt;<span class="type">void</span>()&gt; warpper_func = [task]() &#123;(*task)(); &#125;;</span><br><span class="line">	ret_type res = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">	<span class="keyword">if</span> (stop)</span><br><span class="line">		<span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">	<span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">	tasks.<span class="built_in">emplace</span>(warpper_func);</span><br><span class="line">	cond.<span class="built_in">notify_one</span>();</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/03/19/Leetcode1701_1800/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/19/Leetcode1701_1800/" itemprop="url">Leetcode1701 - 1800</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-19T16:02:00+08:00">
                2022-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Leetcode1799-Maximize-Score-After-N-Operations"><a href="#Leetcode1799-Maximize-Score-After-N-Operations" class="headerlink" title="Leetcode1799. Maximize Score After N Operations"></a>Leetcode1799. Maximize Score After N Operations</h1><p>You are given nums, an array of positive integers of size 2 * n. You must perform n operations on this array.</p>
<p>In the ith operation (1-indexed), you will:</p>
<ul>
<li>Choose two elements, x and y.</li>
<li>Receive a score of i * gcd(x, y).</li>
<li>Remove x and y from nums.</li>
</ul>
<p>Return the maximum score you can receive after performing n operations.</p>
<p>The function gcd(x, y) is the greatest common divisor of x and y.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The optimal choice of operations is:</span><br><span class="line">(1 * gcd(1, 2)) = 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [3,4,6,8]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: The optimal choice of operations is:</span><br><span class="line">(1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,4,5,6]</span><br><span class="line">Output: 14</span><br><span class="line">Explanation: The optimal choice of operations is:</span><br><span class="line">(1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14</span><br></pre></td></tr></table></figure></p>
<p>状态压缩dp，代码很好懂<br>``C++<br>class Solution {<br>public:</p>
<pre><code>vector&lt;int&gt; num;
vector&lt;int&gt; f;
vector&lt;vector&lt;int&gt;&gt; gcd;
int n, maxstate;

int dfs(int state, int t) &#123;
    if (f[state] != -1)
        return f[state];
    f[state] = 0;
    for (int i = 0; i &lt; n; i ++)
        for (int j = i+1; j &lt; n; j ++) &#123;
            if (!(state &amp; (1 &lt;&lt; i)) || !(state &amp; (1 &lt;&lt; j)))
                continue;
            int v = t * gcd[i][j];
            int newstate = state - (1 &lt;&lt; i) - (1 &lt;&lt; j);
            f[state] = max(f[state], dfs(newstate, t+1) + v);
        &#125;
    return f[state];
&#125;

int maxScore(vector&lt;int&gt;&amp; nums) &#123;
    this-&gt;num = nums;
    n = nums.size();
    maxstate = 1 &lt;&lt; n;

    f.assign(maxstate, -1);

    // 预处理gcd
    gcd.assign(n, vector&lt;int&gt;(n));
    for (int i = 0; i &lt; n; i ++)
        for (int j = i+1; j &lt; n; j ++)
            gcd[i][j] = __gcd(nums[i], nums[j]);

    return dfs(maxstate-1, 1);
&#125;
</code></pre><p>};</p>
<pre><code>
也可以用bfs的方法，把状态变成一个图
```C++
class Solution &#123;
public:

    vector&lt;int&gt; num;
    vector&lt;int&gt; f;
    vector&lt;vector&lt;int&gt;&gt; gcd;
    int n, maxstate;

    int bfs() &#123;
        using pii = pair&lt;int, int&gt;;
        queue&lt;pii&gt; q;
        vector&lt;bool&gt; vis(maxstate, false);
        q.push(&#123;0, 1&#125;);
        f[0] = 0;

        while(!q.empty()) &#123;
            printf(&quot;aaa %d\n&quot;, maxstate);
            pii p = q.front();
            q.pop();
            int state = p.first;
            int t = p.second;
            if (vis[state])
                continue;
            vis[state] = true;
            for (int i = 0; i &lt; n; i ++)
                for (int j = i+1; j &lt; n; j ++) &#123;
                    if ((state &amp; (1 &lt;&lt; i)) || (state &amp; (1 &lt;&lt; j)))
                        continue;
                    int newstate = state | (1 &lt;&lt; i) | (1 &lt;&lt; j);
                    int score = t * gcd[i][j];
                    if (f[state] + score &gt; f[newstate]) &#123;
                        f[newstate] = f[state] + score;
                        q.push(&#123;newstate, t+1&#125;);
                    &#125;
                &#125;
        &#125;
        return f[maxstate-1];
    &#125;

    int maxScore(vector&lt;int&gt;&amp; nums) &#123;
        this-&gt;num = nums;
        n = nums.size();
        maxstate = 1 &lt;&lt; n;

        f.assign(maxstate, -1);

        // 预处理gcd
        gcd.assign(n, vector&lt;int&gt;(n));
        for (int i = 0; i &lt; n; i ++)
            for (int j = i+1; j &lt; n; j ++)
                gcd[i][j] = __gcd(nums[i], nums[j]);

        return bfs();
    &#125;
&#125;;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/03/10/simd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/10/simd/" itemprop="url">SIMD介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-10T15:00:00+08:00">
                2022-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SSE技术简介"><a href="#SSE技术简介" class="headerlink" title="SSE技术简介"></a>SSE技术简介</h1><p>SIMD（single-instruction, multiple-data）是一种使用单道指令处理多道数据流的CPU执行模式，即在一个CPU指令执行周期内用一道指令完成处理多个数据的操作。</p>
<p>从 SIMD 架构介绍可知，相较于 SISD架构，SIMD架构的计算机具有更高的理论峰值浮点算力，因而更适合计算密集型任务。如下图所示，以加法指令为例，在SISD架构计算机上，CPU先执行一条指令，进行A1 + B1 = C1计算，再执行下一条指令，进行A2 + B2 = C2计算，按此顺序依次完成后续计算。四个加法计算需依次串行执行四次。而对于SIMD指令来说，CPU只需执行一条指令，即可完成四个加法计算操作，四个加法计算操作并行执行。</p>
<p><img src="/img/v2-4ce09b56931d0c07dfd285b7c53d1258_1440w.webp" alt="img"></p>
<p>图2 SISD 和 SIMD</p>
<p>SIMD 架构的计算机之所以能够并行化执行四个浮点数（甚至更多）操作的原因是支持 SIMD 指令的 CPU在设计时增加了一些专用的向量寄存器。SIMD向量寄存器的长度往往大于通用寄存器，比如SEE 的 XMM寄存器的长度为128位，AVX和AVX2的YMM寄存器为256位。因此，这些专用的向量寄存器可以同时放入多个数据。但需要注意，这里放入的多个数据需要保证数据类型是一致的。</p>
<h3 id="Intel-x86-64-SIMD-指令集"><a href="#Intel-x86-64-SIMD-指令集" class="headerlink" title="Intel x86-64 SIMD 指令集"></a>Intel x86-64 SIMD 指令集</h3><p><img src="/img/v2-2cb6a4793ac96f046b18caf785a7d25a_1440w.webp" alt="img"></p>
<p>图3 Intel SIMD 指令集发展</p>
<ol>
<li><a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/MMX_(instruction_set">MMX 指令集</a>)，MMX（Multi Media eXtension，多媒体扩展指令集）指令集是Intel公司于<strong>1996</strong>年推出的一项<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%8C%87%E4%BB%A4/12583714">多媒体指令</a>增强技术。MMX指令集中包括有57条多媒体指令，通过这些指令可以一次处理多个数据，在处理结果超过实际处理能力的时候也能进行正常处理，这样在软件的配合下，就可以得到更高的性能。</li>
<li><a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Streaming_SIMD_Extensions">SSE/SSE2/SSE3/SSE4/SSE5 指令集</a>，Intel在<strong>1999</strong>年推出SSE（Streaming SIMD eXtensions）指令集，是x86上对SIMD指令集的一个扩展，主要用于处理单精度浮点数。Intel陆续推出SSE2、SSE3、SSE4版本。其中，SSE主要处理单精度浮点数，SSE2引入了整数的处理，SSE指令集引入了8个128bit的寄存器，称为XMM0到XMM7，正因为这些寄存器存储了多个数据，使用一条指令处理，因此称这项功能为SIMD。</li>
<li><a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX指令集</a>，AVX在2008年3月提出，并在<strong>2011</strong>年 Sandy Bridge系列处理器中首次支持。AVX指令集在单指令多数据流计算性能增强的同时也沿用了的MMX/SSE指令集。不过和MMX/SSE的不同点在于增强的AVX指令，从指令的格式上就发生了很大的变化。x86(IA-32/Intel 64)架构的基础上增加了prefix(Prefix)，所以实现了新的命令，也使更加复杂的指令得以实现，从而提升了x86 CPU的性能。</li>
<li>AVX2指令集，<strong>2013</strong>年英特尔推出了包含AVX2的处理器。此架构增强了将AVX的打包整数功能从128位扩展到256位。AVX2指令集的一个重要更新是增加了乘加融合（FMA）指令，也添加了新的数据广播、混合和排列指令。</li>
<li>AVX512指令集，<strong>2017</strong>年Intel 在 Skylake 体系结构中支持了AVX512 指令集。与AVX和AVX2不同，AVX512并不是一个不同的指令集扩展，而是一个相互关联的指令集扩展的集合。对于一个x86处理器，如果其支持AVX512F指令集扩展，那么它就是一个符合AVX512标准的处理器。符合AVX512标准的处理器可以选择性地支持附加的AVX512扩展，如高性能计算、服务器、桌面应用、移动服务等场景增加额外的扩展支持。</li>
</ol>
<p>在 Linux 中，可以键入 lscpu 来查看 CPU 的基础信息，包括型号、代号、分级缓存信息和支持的指令集等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@TENCENT64 ~]<span class="comment"># lscpu</span></span><br><span class="line">Architecture:        x86_64</span><br><span class="line">...</span><br><span class="line">Flags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc art arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch cpuid_fault epb cat_l3 cdp_l3 invpcid_single intel_ppin ssbd mba ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid cqm mpx rdt_a avx512f avx512dq rdseed adx smap clflushopt clwb intel_pt avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local dtherm ida arat pln pts pku ospke avx512_vnni md_clear flush_l1d arch_capabilities</span><br></pre></td></tr></table></figure>
<p>考虑一下下面这个任务：计算一个很长的浮点型数组中每一个元素的平方根。实现这个任务的算法可以这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each f in array <span class="comment">//对数组中的每一个元素</span></span><br><span class="line">    f = <span class="built_in">sqrt</span>(f) <span class="comment">//计算它的平方根</span></span><br></pre></td></tr></table></figure>
<p>为了了解实现的细节，我们把上面的代码这样写：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each f in array</span><br><span class="line">&#123;</span><br><span class="line">    把f从内存加载到浮点寄存器</span><br><span class="line">    计算平方根</span><br><span class="line">    再把计算结果从寄存器中取出放入内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具有Intel SSE指令集支持的处理器有8个128位的寄存器，每一个寄存器可以存放4个（32位）单精度的浮点数。SSE同时提供了一个指令集，其中的指令可以允许把浮点数加载到这些128位的寄存器之中，这些数就可以在这些寄存器中进行算术逻辑运算，然后把结果放回内存。采用SSE技术后，算法可以写成下面的样子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each <span class="number">4</span> members in array <span class="comment">//对数组中的每4个元素</span></span><br><span class="line">&#123;</span><br><span class="line">    把数组中的这<span class="number">4</span>个数加载到一个<span class="number">128</span>位的SSE寄存器中</span><br><span class="line">    在一个CPU指令执行周期中完成计算这<span class="number">4</span>个数的平方根的操作</span><br><span class="line">    把所得的<span class="number">4</span>个结果取出写入内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++编程人员在使用SSE指令函数编程时不必关心这些128位的寄存器，你可以使用128位的数据类型“__m128”和一系列C++函数来实现这些算术和逻辑操作，而决定程序使用哪个SSE寄存器以及代码优化是C++编译器的任务。当需要对很长的浮点数数组中的元素进行处理的时候，SSE技术确实是一种很高效的方法。</p>
<p>下表不完全列举了 AVX512 的各种扩展指令集和对应的简要说明。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>CPUID 标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVX512F</td>
<td>基本指令集</td>
</tr>
<tr>
<td>AVX512ER</td>
<td>指数和倒数指令集</td>
</tr>
<tr>
<td>AVX512PF</td>
<td>预取指令集</td>
</tr>
<tr>
<td>AVX512CD</td>
<td>冲突检测指令集</td>
</tr>
<tr>
<td>AVX512DQ</td>
<td>双字和四字指令集</td>
</tr>
<tr>
<td>AVX512BW</td>
<td>字节和字指令集</td>
</tr>
<tr>
<td>AVX512VL</td>
<td>128位和256位向量指令集</td>
</tr>
<tr>
<td>AVX512_IFMA</td>
<td>整数融合乘加运算</td>
</tr>
<tr>
<td>AVX512_VBMI</td>
<td>附加向量字节指令集</td>
</tr>
<tr>
<td>AVX512_VNNI</td>
<td>向量神经网络指令集</td>
</tr>
</tbody>
</table>
</div>
<h3 id="向量寄存器"><a href="#向量寄存器" class="headerlink" title="向量寄存器"></a>向量寄存器</h3><ol>
<li>SSE 和 AVX 各自有16个寄存器，SSE 的16个寄存器为 XMM0 - XMM15，XMM是128位寄存器，而YMM是256位寄存器。XMM寄存器也可以用于使用类似x86-SSE的单精度值或者双精度值执行标量浮点运算。</li>
<li>支持AVX的x86-64处理器包含16个256位大小的寄存器，名为YMM0 ~ YMM15。每个YMM寄存器的低阶128位的别名是相对应的XMM寄存器。大多数AVX指令可以使用任何一个XMM或者YMM寄存器作为SIMD操作数。</li>
<li>AVX512 将每个AVX SIMD 寄存器的大小从256 位扩展到512位，称为ZMM寄存器；符合AVX512标准的处理器包含32个ZMM寄存器，名为ZMM0 ~ ZMM31。YMM 和 XMM 寄存器分别对应于每个ZMM寄存器的低阶 256 位和 128 位别名。AVX512 处理器还包括八个名为K0~K7的新的操作掩码寄存器；</li>
</ol>
<p><img src="/img/v2-77093f45bae35b0d44533d521925e015_1440w.webp" alt="img"></p>
<p>图4 向量寄存器</p>
<h1 id="SSE程序设计详细介绍"><a href="#SSE程序设计详细介绍" class="headerlink" title="SSE程序设计详细介绍"></a>SSE程序设计详细介绍</h1><p>包含的头文件：</p>
<p>所有的SSE指令函数和<code>__m128</code>数据类型都在<code>xmmintrin.h</code>文件中定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xmmintrin.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>因为程序中用到的SSE处理器指令是由编译器决定，所以它并没有相关的.lib库文件。</p>
<h2 id="数据分组（Data-Alignment）"><a href="#数据分组（Data-Alignment）" class="headerlink" title="数据分组（Data Alignment）"></a>数据分组（Data Alignment）</h2><p>由SSE指令处理的每一个浮点数数组必须把其中需要处理的数每16个字节（128位二进制）分为一组。一个静态数组（static array）可由<code>__declspec(align(16))</code>关键字声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__declspec(<span class="built_in">align</span>(<span class="number">16</span>)) <span class="type">float</span> m_fArray[ARRAY_SIZE];</span><br></pre></td></tr></table></figure></p>
<p>动态数组（dynamic array）可由_aligned_malloc函数为其分配空间：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_fArray = (<span class="type">float</span>*) _aligned_malloc(ARRAY_SIZE * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">16</span>);</span><br></pre></td></tr></table></figure></p>
<p>由_aligned_malloc函数分配空间的动态数组可以由_aligned_free函数释放其占用的空间：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_aligned_free(m_fArray);</span><br></pre></td></tr></table></figure></p>
<h2 id="m128-数据类型"><a href="#m128-数据类型" class="headerlink" title="__m128 数据类型"></a>__m128 数据类型</h2><p>该数据类型的变量可用做SSE指令的操作数，它们不能被用户指令直接存取。_m128类型的变量被自动分配为16个字节的字长。</p>
<ol>
<li>SSE 有三种类型定义<code>__m128</code>,<code>__m128d</code> 和<code>__m128i</code>，分别用以表示单精度浮点型、双精度浮点型和整型。</li>
<li>AVX/AVX2 有三种类型定义<code>__m256</code>,<code>__m256d</code> 和<code>__m256i</code>，分别用以表示单精度浮点型、双精度浮点型和整型。</li>
<li>AVX512 有三种类型定义<code>__m512</code>,<code>__m512d</code> 和 <code>__512i</code>，分别用以表示单精度浮点型、双精度浮点型和整型。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>__m128</td>
<td>包含4个单精度浮点数的128位向量</td>
<td>4 x 32 bit</td>
</tr>
<tr>
<td>__m128d</td>
<td>包含2个双精度浮点数的128位向量</td>
<td>2 x 64 bit</td>
</tr>
<tr>
<td>__m128i</td>
<td>包含数个整型数值的128位向量</td>
<td>128 bit</td>
</tr>
<tr>
<td>__m256</td>
<td>包含8个单精度浮点数的256位向量</td>
<td>8 x 32 bit</td>
</tr>
<tr>
<td>__m256d</td>
<td>包含4个双精度浮点数的256位向量</td>
<td>4 x 64 bit</td>
</tr>
<tr>
<td>__m256i</td>
<td>包含数个整型数值的256位向量</td>
<td>256 bit</td>
</tr>
<tr>
<td>__m512</td>
<td>包含16个单精度浮点数的512位向量</td>
<td>16 x 32 bit</td>
</tr>
<tr>
<td>__m512d</td>
<td>包含8个双精度浮点数的512位向量</td>
<td>8 x 64 bit</td>
</tr>
<tr>
<td>__m512i</td>
<td>包含数个整型数值的512位向量</td>
<td>512 bit</td>
</tr>
</tbody>
</table>
</div>
<p><strong>char, short, int, long 均属于整型。</strong></p>
<p><img src="/img/v2-28db68861eba0863f77e5fcc69a82a2e_1440w.webp" alt="img"></p>
<p>图5 数据类型</p>
<h2 id="编程实例"><a href="#编程实例" class="headerlink" title="编程实例"></a>编程实例</h2><p>SSETest项目是一个基于对话框的应用程序，它用到了三个浮点数组参与运算：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fResult[i] = <span class="built_in">sqrt</span>( fSource1[i]*fSource1[i] + fSource2[i]*fSource2[i] ) + <span class="number">0.5</span></span><br></pre></td></tr></table></figure><br>其中i = 0, 1, 2 … ARRAY_SIZE-1</p>
<p>其中ARRAY_SIZE被定义为30000。数据源数组（Source数组）通过使用sin和cos函数给它赋值，我们用Kris Jearakul开发的瀑布状图表控件（Waterfall chart control）[3] 来显示参与计算的源数组和结果数组。计算所需的时间(以毫秒ms为单位)在对话框中显示出来。我们使用三种不同的途径来完成计算：</p>
<ul>
<li>纯C++代码；</li>
<li>使用SSE指令函数的C++代码；</li>
<li>包含SSE汇编指令的代码。</li>
</ul>
<p>　纯C++代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSSETestDlg::ComputeArrayCPlusPlus</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">float</span>* pArray1, <span class="comment">// [输入] 源数组1</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">float</span>* pArray2, <span class="comment">// [输入] 源数组2</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">float</span>* pResult, <span class="comment">// [输出] 用来存放结果的数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">int</span> nSize)</span> <span class="comment">// [输入] 数组的大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span>* pSource1 = pArray1;</span><br><span class="line">    <span class="type">float</span>* pSource2 = pArray2;</span><br><span class="line">    <span class="type">float</span>* pDest = pResult;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; nSize; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        *pDest = (<span class="type">float</span>)<span class="built_in">sqrt</span>((*pSource1) * (*pSource1) + (*pSource2) * (*pSource2)) + <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        pSource1++;</span><br><span class="line">        pSource2++;</span><br><span class="line">        pDest++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们用具有SSE特性的C++代码重写上面这个函数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>实现的功能</th>
<th>对应的SSE汇编指令</th>
<th>Visual C++.NET中的SSE函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>将4个32位浮点数放进一个128位的存储单元。</td>
<td>movss 和 shufps</td>
<td>_mm_set_ps1</td>
</tr>
<tr>
<td>将4对32位浮点数同时进行相乘操作。这4对32位浮点数来自两个128位的存储单元，再把计算结果（乘积）赋给一个128位的存储单元。</td>
<td>mulps</td>
<td>_mm_mul_ps</td>
</tr>
<tr>
<td>将4对32位浮点数同时进行相加操作。这4对32位浮点数来自两个128位的存储单元，再把计算结果（相加之和）赋给一个128位的存储单元。</td>
<td>addps</td>
<td>_mm_add_ps</td>
</tr>
<tr>
<td>对一个128位存储单元中的4个32位浮点数同时进行求平方根操作。</td>
<td>sqrtps</td>
<td>_mm_sqrt_ps</td>
</tr>
</tbody>
</table>
</div>
<p>　使用Visual C++.NET的 SSE指令函数的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSSETestDlg::ComputeArrayCPlusPlusSSE</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">float</span>* pArray1, <span class="comment">// [输入] 源数组1</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">float</span>* pArray2, <span class="comment">// [输入] 源数组2</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">float</span>* pResult, <span class="comment">// [输出] 用来存放结果的数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">int</span> nSize)</span> <span class="comment">// [输入] 数组的大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nLoop = nSize/ <span class="number">4</span>;</span><br><span class="line">    __m128 m1, m2, m3, m4;</span><br><span class="line">    __m128* pSrc1 = (__m128*) pArray1;</span><br><span class="line">    __m128* pSrc2 = (__m128*) pArray2;</span><br><span class="line">    __m128* pDest = (__m128*) pResult;</span><br><span class="line">    __m128 m0_5 = _mm_set_ps1(<span class="number">0.5f</span>); <span class="comment">// m0_5[0, 1, 2, 3] = 0.5</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; nLoop; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        m1 = _mm_mul_ps(*pSrc1, *pSrc1); <span class="comment">// m1 = *pSrc1 * *pSrc1</span></span><br><span class="line">        m2 = _mm_mul_ps(*pSrc2, *pSrc2); <span class="comment">// m2 = *pSrc2 * *pSrc2</span></span><br><span class="line">        m3 = _mm_add_ps(m1, m2); <span class="comment">// m3 = m1 + m2</span></span><br><span class="line">        m4 = _mm_sqrt_ps(m3); <span class="comment">// m4 = sqrt(m3)</span></span><br><span class="line">        *pDest = _mm_add_ps(m4, m0_5); <span class="comment">// *pDest = m4 + 0.5</span></span><br><span class="line">        pSrc1++;</span><br><span class="line">        pSrc2++;</span><br><span class="line">        pDest++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用SSE汇编指令实现的C++函数代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSSETestDlg::ComputeArrayAssemblySSE</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">float</span>* pArray1, <span class="comment">// [输入] 源数组1</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">float</span>* pArray2, <span class="comment">// [输入] 源数组2</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">float</span>* pResult, <span class="comment">// [输出] 用来存放结果的数组</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                            <span class="type">int</span> nSize)</span> <span class="comment">// [输入] 数组的大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nLoop = nSize/<span class="number">4</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">0.5f</span>;</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        movss xmm2, f <span class="comment">// xmm2[0] = 0.5</span></span><br><span class="line">        shufps xmm2, xmm2, <span class="number">0</span> <span class="comment">// xmm2[1, 2, 3] = xmm2[0]</span></span><br><span class="line">        mov esi, pArray1 <span class="comment">// 输入的源数组1的地址送往esi</span></span><br><span class="line">        mov edx, pArray2 <span class="comment">// 输入的源数组2的地址送往edx</span></span><br><span class="line">        mov edi, pResult <span class="comment">// 输出结果数组的地址保存在edi</span></span><br><span class="line">        mov ecx, nLoop <span class="comment">//循环次数送往ecx</span></span><br><span class="line"></span><br><span class="line">start_loop:</span><br><span class="line">        movaps xmm0, [esi] <span class="comment">// xmm0 = [esi]</span></span><br><span class="line">        mulps xmm0, xmm0 <span class="comment">// xmm0 = xmm0 * xmm0</span></span><br><span class="line">        movaps xmm1, [edx] <span class="comment">// xmm1 = [edx]</span></span><br><span class="line">        mulps xmm1, xmm1 <span class="comment">// xmm1 = xmm1 * xmm1</span></span><br><span class="line">        addps xmm0, xmm1 <span class="comment">// xmm0 = xmm0 + xmm1</span></span><br><span class="line">        sqrtps xmm0, xmm0 <span class="comment">// xmm0 = sqrt(xmm0)</span></span><br><span class="line">        addps xmm0, xmm2 <span class="comment">// xmm0 = xmm1 + xmm2</span></span><br><span class="line">        movaps [edi], xmm0 <span class="comment">// [edi] = xmm0</span></span><br><span class="line">        add esi, <span class="number">16</span> <span class="comment">// esi += 16</span></span><br><span class="line">        add edx, <span class="number">16</span> <span class="comment">// edx += 16</span></span><br><span class="line">        add edi, <span class="number">16</span> <span class="comment">// edi += 16</span></span><br><span class="line">        dec ecx <span class="comment">// ecx--</span></span><br><span class="line">        jnz start_loop <span class="comment">//如果不为0则转向start_loop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，在我的计算机上运行计算测试的结果：</p>
<ul>
<li>纯C++代码计算所用的时间是26 毫秒</li>
<li>使用SSE的C++ 函数计算所用的时间是 9 毫秒</li>
<li>包含SSE汇编指令的C++代码计算所用的时间是 9 毫秒</li>
</ul>
<p>SSESample 示例项目</p>
<p>SSESample项目是一个基于对话框的应用程序，其中它用下面的浮点数数组进行计算：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fResult[i] = <span class="built_in">sqrt</span>(fSource[i]*<span class="number">2.8</span>)</span><br></pre></td></tr></table></figure></p>
<p>其中i = 0, 1, 2 … ARRAY_SIZE-1</p>
<p>这个程序同时计算了数组中的最大值和最小值。</p>
<p>使用SSE汇编指令计算的结果会好一些，因为使用了效率增强了的SSX寄存器组。但是在通常情况下，使用SSE的C++ 函数计算会比汇编代码计算的效率更高一些，因为C++编译器的优化后的代码有很高的运算效率，若要使汇编代码比优化后的代码运算效率更高，这通常是很难做到的。</p>
<p>　纯C++代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入: m_fInitialArray</span></span><br><span class="line"><span class="comment">// 输出: m_fResultArray, m_fMin, m_fMax</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSSESampleDlg::OnBnClickedButtonCplusplus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_fMin = FLT_MAX;</span><br><span class="line">    m_fMax = FLT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        m_fResultArray[i] = <span class="built_in">sqrt</span>(m_fInitialArray[i] * <span class="number">2.8f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( m_fResultArray[i] &lt; m_fMin )</span><br><span class="line">            m_fMin = m_fResultArray[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( m_fResultArray[i] &gt; m_fMax )</span><br><span class="line">            m_fMax = m_fResultArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　使用Visual C++.NET的 SSE指令函数的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入: m_fInitialArray</span></span><br><span class="line"><span class="comment">// 输出: m_fResultArray, m_fMin, m_fMax</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSSESampleDlg::OnBnClickedButtonSseC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __m128 coeff = _mm_set_ps1(<span class="number">2.8f</span>); <span class="comment">// coeff[0, 1, 2, 3] = 2.8</span></span><br><span class="line">    __m128 tmp;</span><br><span class="line"></span><br><span class="line">    __m128 min128 = _mm_set_ps1(FLT_MAX); <span class="comment">// min128[0, 1, 2, 3] = FLT_MAX</span></span><br><span class="line">    __m128 max128 = _mm_set_ps1(FLT_MIN); <span class="comment">// max128[0, 1, 2, 3] = FLT_MIN</span></span><br><span class="line"></span><br><span class="line">    __m128* pSource = (__m128*) m_fInitialArray;</span><br><span class="line">    __m128* pDest = (__m128*) m_fResultArray;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE/<span class="number">4</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = _mm_mul_ps(*pSource, coeff); <span class="comment">// tmp = *pSource * coeff</span></span><br><span class="line">        *pDest = _mm_sqrt_ps(tmp); <span class="comment">// *pDest = sqrt(tmp)</span></span><br><span class="line"></span><br><span class="line">        min128 = _mm_min_ps(*pDest, min128);</span><br><span class="line">        max128 = _mm_max_ps(*pDest, max128);</span><br><span class="line"></span><br><span class="line">        pSource++;</span><br><span class="line">        pDest++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算max128的最大值和min128的最小值</span></span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">u</span></span><br><span class="line">    &#123;</span><br><span class="line">        __m128 m;</span><br><span class="line">        <span class="type">float</span> f[<span class="number">4</span>];</span><br><span class="line">    &#125; x;</span><br><span class="line"></span><br><span class="line">    x.m = min128;</span><br><span class="line">    m_fMin = <span class="built_in">min</span>(x.f[<span class="number">0</span>], <span class="built_in">min</span>(x.f[<span class="number">1</span>], <span class="built_in">min</span>(x.f[<span class="number">2</span>], x.f[<span class="number">3</span>])));</span><br><span class="line"></span><br><span class="line">    x.m = max128;</span><br><span class="line">    m_fMax = <span class="built_in">max</span>(x.f[<span class="number">0</span>], <span class="built_in">max</span>(x.f[<span class="number">1</span>], <span class="built_in">max</span>(x.f[<span class="number">2</span>], x.f[<span class="number">3</span>])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　使用SSE汇编指令的C++函数代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 输入: m_fInitialArray</span></span><br><span class="line">    <span class="comment">// 输出: m_fResultArray, m_fMin, m_fMax</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CSSESampleDlg::OnBnClickedButtonSseAssembly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span>* pIn = m_fInitialArray;</span><br><span class="line">        <span class="type">float</span>* pOut = m_fResultArray;</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> f = <span class="number">2.8f</span>;</span><br><span class="line">        <span class="type">float</span> flt_min = FLT_MIN;</span><br><span class="line">        <span class="type">float</span> flt_max = FLT_MAX;</span><br><span class="line"></span><br><span class="line">        __m128 min128;</span><br><span class="line">        __m128 max128;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用以下的附加寄存器:xmm2、xmm3、xmm4:</span></span><br><span class="line">        <span class="comment">// xmm2 – 相乘系数</span></span><br><span class="line">        <span class="comment">// xmm3 – 最小值</span></span><br><span class="line">        <span class="comment">// xmm4 – 最大值</span></span><br><span class="line"></span><br><span class="line">        _asm</span><br><span class="line">        &#123;</span><br><span class="line">            movss xmm2, f <span class="comment">// xmm2[0] = 2.8</span></span><br><span class="line">            shufps xmm2, xmm2, <span class="number">0</span> <span class="comment">// xmm2[1, 2, 3] = xmm2[0]</span></span><br><span class="line"></span><br><span class="line">            movss xmm3, flt_max <span class="comment">// xmm3 = FLT_MAX</span></span><br><span class="line">            shufps xmm3, xmm3, <span class="number">0</span> <span class="comment">// xmm3[1, 2, 3] = xmm3[0]</span></span><br><span class="line"></span><br><span class="line">            movss xmm4, flt_min <span class="comment">// xmm4 = FLT_MIN</span></span><br><span class="line">            shufps xmm4, xmm4, <span class="number">0</span> <span class="comment">// xmm3[1, 2, 3] = xmm3[0]</span></span><br><span class="line"></span><br><span class="line">            mov esi, pIn <span class="comment">// 输入数组的地址送往esi</span></span><br><span class="line">            mov edi, pOut <span class="comment">// 输出数组的地址送往edi</span></span><br><span class="line">            mov ecx, ARRAY_SIZE/<span class="number">4</span> <span class="comment">// 循环计数器初始化</span></span><br><span class="line"></span><br><span class="line">start_loop:</span><br><span class="line">            movaps xmm1, [esi] <span class="comment">// xmm1 = [esi]</span></span><br><span class="line">            mulps xmm1, xmm2 <span class="comment">// xmm1 = xmm1 * xmm2</span></span><br><span class="line">            sqrtps xmm1, xmm1 <span class="comment">// xmm1 = sqrt(xmm1)</span></span><br><span class="line">            movaps [edi], xmm1 <span class="comment">// [edi] = xmm1</span></span><br><span class="line"></span><br><span class="line">            minps xmm3, xmm1</span><br><span class="line">            maxps xmm4, xmm1</span><br><span class="line"></span><br><span class="line">            add esi, <span class="number">16</span></span><br><span class="line">            add edi, <span class="number">16</span></span><br><span class="line"></span><br><span class="line">            dec ecx</span><br><span class="line">            jnz start_loop</span><br><span class="line"></span><br><span class="line">            movaps min128, xmm3</span><br><span class="line">            movaps max128, xmm4</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">union</span> <span class="title class_">u</span></span><br><span class="line">        &#123;</span><br><span class="line">            __m128 m;</span><br><span class="line">            <span class="type">float</span> f[<span class="number">4</span>];</span><br><span class="line">        &#125; x;</span><br><span class="line"></span><br><span class="line">        x.m = min128;</span><br><span class="line">        m_fMin = <span class="built_in">min</span>(x.f[<span class="number">0</span>], <span class="built_in">min</span>(x.f[<span class="number">1</span>], <span class="built_in">min</span>(x.f[<span class="number">2</span>], x.f[<span class="number">3</span>])));</span><br><span class="line"></span><br><span class="line">        x.m = max128;</span><br><span class="line">        m_fMax = <span class="built_in">max</span>(x.f[<span class="number">0</span>], <span class="built_in">max</span>(x.f[<span class="number">1</span>], <span class="built_in">max</span>(x.f[<span class="number">2</span>], x.f[<span class="number">3</span>])));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="SIMD"><a href="#SIMD" class="headerlink" title="SIMD"></a>SIMD</h1><p>SSE（为Streaming SIMD Extensions的缩写）是由 Intel公司，在1999年推出Pentium III处理器时，同时推出的新指令集。如同其名称所表示的，SSE是一种SIMD指令集。SSE有8个128位寄存器，XMM0 ~XMM7。这些128位元的寄存器，可以用来存放四个32位的单精确度浮点数。SSE的浮点数运算指令就是使用这些寄存器。</p>
<p>SSE寄存器结构如下：<br><img src="/img/20160330145907051.jpg" alt=""></p>
<h2 id="寄存器与指令数据细节"><a href="#寄存器与指令数据细节" class="headerlink" title="寄存器与指令数据细节"></a>寄存器与指令数据细节</h2><p>在MMX指令集中，使用的寄存器称作MM0到MM7，实际上借用了浮点处理器的8个寄存器的低64Bit，这样导致了浮点运算速度降低。</p>
<p>SSE指令集推出时，Intel公司在Pentium III CPU中增加了8个128位的SSE指令专用寄存器，称作XMM0到XMM7。这样SSE指令寄存器可以全速运行，保证了与浮点运算的并行性。这些XMM寄存器用于4个单精度浮点数运算的SIMD执行，并可以与MMX整数运算或x87浮点运算混合执行。</p>
<p>2001年在Pentium 4上引入了SSE2技术，进一步扩展了指令集，使得XMM寄存器上可以执行8/16/32位宽的整数SIMD运算或双精度浮点数的SIMD运算。对整型数据的支持使得所有的MMX指令都是多余的了，同时也避免了占用浮点数寄存器。SSE2为了更好地利用高速寄存器，还新增加了几条寄存指令，允许程序员控制已经寄存过的数据。这使得 SIMD技术基本完善。</p>
<p>SSE3指令集扩展的指令包含寄存器的局部位之间的运算，例如高位和低位之间的加减运算；浮点数到整数的转换，以及对超线程技术的支持。</p>
<p>AVX是Intel的SSE延伸架构，把寄存器XMM 128bit提升至YMM 256bit，以增加一倍的运算效率。此架构支持了三运算指令（3-Operand Instructions），减少在编码上需要先复制才能运算的动作。在微码部分使用了LES LDS这两少用的指令作为延伸指令Prefix。AVX的256bit的YMM寄存器分为两个128bit的lanes，AVX指令并不支持跨lanes的操作。其中YMM寄存器的低128位与Intel SSE指令集的128bitXMM寄存器复用。尽管VGX并不要求内存对齐，但是内存对齐有助于提升性能。如对于128-bit访问的16字节对齐和对于256-bit访问的32字节对齐。</p>
<p>AVX虽然已经将支持的SIMD数据宽度增加到了256位，但仅仅增加了对256位的浮点SIMD支持，整点SIMD数据的宽度还停留在128位上，AVX2支持的整点SIMD数据宽度从128位扩展到256位。同时支持了跨lanes操作，加入了增强广播、置换指令支持的数据元素类型、移位操作对各个数据元素可变移位数的支持、跨距访存支持。AVX硬件由16个256bitYMM寄存器（YMM0~YMM15）组成。</p>
<p>每一代的指令集都是对上一代兼容的，支持上一代的指令，也可以使用上一代的寄存器，也就是说，AVX2也依然支持128位，64位的操作，也可以使用上一代的寄存器（当然，寄存器的硬件实现可能有区别）。AVX也对部分之前的指令接口进行了重构，所以可以在指令文档中找到几个处于不同代际有着相同功能调用接口却不相同的函数。</p>
<p>另外，不同代际的指令不要混用，每次状态切换将消耗 50-80 个时钟周期，会拖慢程序的运行速度。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>由于通常没有内建的128bit和256bit数据类型，SIMD指令使用自己构建的数据类型，这些类型以union实现，这些数据类型可以称作向量，一般来说，MMX指令是<code>__m64</code> 类型的数据，SSE是<code>__m128</code>类型的数据等等。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">__declspec</span>(intrin_type) _CRT_ALIGN(<span class="number">8</span>) __m64</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> __int64    m64_u64;</span><br><span class="line">    <span class="type">float</span>               m64_f32[<span class="number">2</span>];</span><br><span class="line">    __int8              m64_i8[<span class="number">8</span>];</span><br><span class="line">    __int16             m64_i16[<span class="number">4</span>];</span><br><span class="line">    __int32             m64_i32[<span class="number">2</span>];    </span><br><span class="line">    __int64             m64_i64;</span><br><span class="line">    <span class="type">unsigned</span> __int8     m64_u8[<span class="number">8</span>];</span><br><span class="line">    <span class="type">unsigned</span> __int16    m64_u16[<span class="number">4</span>];</span><br><span class="line">    <span class="type">unsigned</span> __int32    m64_u32[<span class="number">2</span>];</span><br><span class="line">&#125; __m64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">__declspec</span>(intrin_type) _CRT_ALIGN(<span class="number">16</span>) __m128 &#123;</span><br><span class="line">     <span class="type">float</span>               m128_f32[<span class="number">4</span>];</span><br><span class="line">     <span class="type">unsigned</span> __int64    m128_u64[<span class="number">2</span>];</span><br><span class="line">     __int8              m128_i8[<span class="number">16</span>];</span><br><span class="line">     __int16             m128_i16[<span class="number">8</span>];</span><br><span class="line">     __int32             m128_i32[<span class="number">4</span>];</span><br><span class="line">     __int64             m128_i64[<span class="number">2</span>];</span><br><span class="line">     <span class="type">unsigned</span> __int8     m128_u8[<span class="number">16</span>];</span><br><span class="line">     <span class="type">unsigned</span> __int16    m128_u16[<span class="number">8</span>];</span><br><span class="line">     <span class="type">unsigned</span> __int32    m128_u32[<span class="number">4</span>];</span><br><span class="line"> &#125; __m128;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">__declspec</span>(intrin_type) _CRT_ALIGN(<span class="number">16</span>) __m128i &#123;</span><br><span class="line">    __int8              m128i_i8[<span class="number">16</span>];</span><br><span class="line">    __int16             m128i_i16[<span class="number">8</span>];</span><br><span class="line">    __int32             m128i_i32[<span class="number">4</span>];    </span><br><span class="line">    __int64             m128i_i64[<span class="number">2</span>];</span><br><span class="line">    <span class="type">unsigned</span> __int8     m128i_u8[<span class="number">16</span>];</span><br><span class="line">    <span class="type">unsigned</span> __int16    m128i_u16[<span class="number">8</span>];</span><br><span class="line">    <span class="type">unsigned</span> __int32    m128i_u32[<span class="number">4</span>];</span><br><span class="line">    <span class="type">unsigned</span> __int64    m128i_u64[<span class="number">2</span>];</span><br><span class="line">&#125; __m128i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__declspec</span>(intrin_type) _CRT_ALIGN(<span class="number">16</span>) __m128d &#123;</span><br><span class="line">    <span class="type">double</span>              m128d_f64[<span class="number">2</span>];</span><br><span class="line">&#125; __m128d;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>__m128</td>
<td>包含4个float类型数字的向量</td>
</tr>
<tr>
<td>__m128d</td>
<td>包含2个double类型数字的向量</td>
</tr>
<tr>
<td>__m128i</td>
<td>包含若干个整型数字的向量</td>
</tr>
<tr>
<td>__m256</td>
<td>包含8个float类型数字的向量</td>
</tr>
<tr>
<td>__m256d</td>
<td>包含4个double类型数字的向量</td>
</tr>
<tr>
<td>__m256i</td>
<td>包含若干个整型数字的向量</td>
</tr>
</tbody>
</table>
</div>
<p>每一种类型，从2个下划线开头，接一个m，然后是向量的位长度。如果向量类型是以d结束的，那么向量里面是double类型的数字。如果没有后缀，就代表向量只包含float类型的数字。整形的向量可以包含各种类型的整形数，例如char,short,unsigned long long。也就是说，__m256i可以包含32个char，16个short类型，8个int类型，4个long类型。这些整形数可以是有符号类型也可以是无符号类型。</p>
<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>为了方便CPU用指令对内存进行访问，通常要求某种类型对象的地址必须是某个值K（通常是2、4或8）的倍数，如果一个变量的内存地址正好位于它长度的整数倍，我们就称他是自然对齐的。不同长度的内存访问会用到不同的汇编指令，这种对齐限制简化了形成处理器和存储器系统之间接口的硬件设计，提高了内存的访问效率。</p>
<p>通常对于各种类型的对齐规则如下：</p>
<ul>
<li>数组 ：按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。</li>
<li>联合 ：按其包含的长度最大的数据类型对齐。</li>
<li>结构体： 结构体中每个数据类型都要对齐</li>
</ul>
<p>对于SIMD的内存对齐是指<code>__m128</code>等union在内存中存储时的存储方式。然而由于结构内存对齐的规则略微复杂，我们以结构为例进行说明：</p>
<p>一般情况下，由于内存对齐的原因存储多种类型数据的结构体所占的内存大小并非元素本身类型大小之和。对于自然对齐而言：</p>
<p>对于各成员变量来说，存放的起始地址相对于结构的起始地址的偏移量必须为该变量的类型所占用的字节数的倍数，各成员变量在存放的时候根据在结构中出现的顺序依次申请空间， 同时按照上面的对齐方式调整位置， 空缺的字节自动填充。</p>
<p>对于整个结构体来说，为了确保结构的大小为结构的字节边界数(即该结构中占用最大的空间的类型的字节数)的倍数，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。</p>
<p>所以一般我们在定义结构体时定义各元素的顺序也会影响实际结构体在存储时的整体大小，把大小相同或相近的元素放一起，可以减少结构体占用的内存空间。</p>
<p>除了自然对齐的内存大小，我们也可以设置自己需要的对齐大小，我们称之为对齐系数，如果结构内最大类型的字节数小于对齐系数，结构体内存大小应按最大元素大小对齐，如果最大元素大小超过对齐系数，应按对齐系数大小对齐。</p>
<p>对齐系数大小的设定可以使用下列方法：</p>
<p><code>#pragma pack (16)</code>使用预编译器指令要求对齐。<code>#pragma pack()</code>恢复为默认对齐方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__ ((<span class="built_in">aligned</span> (<span class="number">16</span>)))<span class="comment">//GCC要求对齐</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__declspec(intrin_type) _CRT_ALIGN(<span class="number">16</span>)<span class="comment">//Microsoft Visual C++要求对齐</span></span><br></pre></td></tr></table></figure>
<p>联合的内存对齐方式与结构类似。</p>
<p>SIMD的指令中通常有对内存对齐的要求，例如，SSE中大部分指令要求地址是16bytes对齐的，以<code>_mm_load_ps</code>函数来说明，这个函数对应于SSE的loadps指令。</p>
<p>函数原型为：<code>extern __m128 _mm_load_ps(float const*_A);</code></p>
<p>可以看到，它的输入是一个指向float的指针，返回的就是一个<code>__m128</code>类型的数据，从函数的角度理解，就是把一个float数组的四个元素依次读取，返回一个组合的<code>__m128</code>类型的SSE数据类型，从而可以使用这个返回的结果传递给其它的SSE指令进行运算，比如加法等；从汇编的角度理解，它对应的就是读取内存中连续四个地址的float数据，将其放入SSE的寄存器(XMM)中，从而给其他的指令准备好数据进行计算。其使用示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> input[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">4.0f</span> &#125;;</span><br><span class="line">__m128 a = _mm_load_ps(input);|<span class="comment">//WARNING</span></span><br></pre></td></tr></table></figure></p>
<p>这里加载正确的前提是：input这个浮点数阵列都是对齐在16 bytes的边上。否则程序会崩溃或得不到正确结果。如果没有对齐，就需要使用_mm_loadu_ps函数，这个函数用于处理没有对齐在16bytes上的数据，但是其速度会比较慢。</p>
<p>对于上面的例子，如果要将input指定为16bytes对齐，可以采用的方式是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__declspec(<span class="built_in">align</span>(<span class="number">16</span>)) <span class="type">float</span> input[<span class="number">4</span>] = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>为了简化，头文件<code>&lt;xmmintrin.h&gt;</code>中定义了一个宏<code>_MM_ALIGN16</code>来表示上面的含义，即可以用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_MM_ALIGN16 <span class="type">float</span> input[<span class="number">4</span>] = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>256-bit AVX 指令在内存访问上对内存对齐比128-bit SSE 指令有更高要求。虽然在一个cache-line 之内，Intel 的对齐和非对齐指令已经没有性能差距了，但是由于AVX 有更长的内存访问宽度（YMM &lt;-&gt; memory），会更频繁地触及cache-line 边界。所以1）尽量使用对齐内存分配；2）有时候内存对齐不能保证，可以用128-bit（XMM）指令访问内存，然后再组合成256-bit YMM</p>
<h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><p>SSE的浮点运算指令分为两大类：Packed 和Scalar。Packed指令是一次对XMM寄存器中的四个浮点数（即DATA0 ~ DATA3）均进行计算，而Scalar则只对XMM暂存器中的DATA0进行计算。如下图所示：<br><img src="/img/20160330150558576.jpg" alt=""></p>
<p>下面是SSE指令的一般格式，由三部分组成，第一部分是表示指令的作用，比如加法add等，第二部分是s或者p分别表示scalar或packed，第三部分为s，表示单精度浮点数（single precision floating point data）。<br><img src="/img/20160330150731953.jpg" alt=""></p>
<p>根据上面知道，SSE的寄存器是128bit的，那么SSE就需要使用128bit的数据类型，SSE使用4个浮点数（4*32bit）组合成一个新的数据类型，用于表示128bit类型，SSE指令的返回结果也是128bit的。</p>
<p>SSE 指令和一般的x86 指令很类似，基本上包括两种定址方式：寄存器-寄存器方式(reg-reg)和寄存器-内存方式(reg-mem)：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addps xmm0, xmm1 ; reg-reg</span><br><span class="line">addps xmm0, [ebx] ; reg-mem</span><br></pre></td></tr></table></figure></p>
<p>SSE中大部分指令要求地址是16byte对齐的。要理解这个问题，以<code>_mm_load_ps</code>函数来解释，这个函数对应于<code>loadps</code>的SSE指令。其原型为：<code>extern __m128 _mm_load_ps(float const*_A);</code></p>
<p>可以看到，它的输入是一个指向float的指针，返回的就是一个<code>__m128</code>类型的数据，从函数的角度理解，就是把一个float数组的四个元素依次读取，返回一个组合的<code>__m128</code>类型的SSE数据类型，从而可以使用这个返回的结果传递给其它的SSE指令进行运算，比如加法等；从汇编的角度理解，它对应的就是读取内存中连续四个地址的float数据，将其放入SSE新的暂存器(XMM0~8)中，从而给其他的指令准备好数据进行计算。其使用示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> input[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">4.0f</span> &#125;;  </span><br><span class="line">__m128 a = _mm_load_ps(input);  </span><br></pre></td></tr></table></figure>
<p>这里加载正确的前提是：input这个浮点数数组是对齐在16 byte的边上。否则加载的结果和预期的不一样。如果没有对齐，就需要使用<code>_mm_loadu_ps</code>函数，这个函数用于处理没有对齐在16byte上的数据，但是其速度会比较慢。</p>
<p>这个只是使用SSE指令的时候要注意一下，我们知道，x86的little-endian特性，位址较低的byte会放在暂存器的右边。也就是说，若以上面的input为例，在载入到XMM暂存器后，暂存器中的DATA0会是1.0，而DATA1是2.0，DATA2是3.0，DATA3是4.0。如果需要以相反的顺序载入的话，可以用_mm_loadr_ps 这个intrinsic，根据需要进行选择。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>使用软件CPU-Z可以查看CPU支持的指令集。</p>
<p>我们可以在C/C++使用封装的函数而不是嵌入的汇编代码的方式来调用指令集，这就是Compiler Intrinsics。</p>
<p>Intrinsics指令是对MMX、SSE等指令集的指令的一种封装，以函数的形式提供，使得程序员更容易编写和使用这些高级指令，在编译的时候，这些函数会被内联为汇编，不会产生函数调用的开销。</p>
<p>除了我们这里使用的intrinsics指令，还有intrinsics函数需要以作区分，这两者既有联系又有区别。编译器指令<code>#pragma intrinsic()</code>可以将一些指定的系统库函数编译为内部函数，从而去掉函数调用参数传递等的开销，这种方式只适用于编译器规定的一部分函数，不是所有函数都能使用，同时会增大生成代码的大小。</p>
<p>intrinsics更广泛的使用是指令集的封装，能将函数直接映射到高级指令集，同时隐藏了寄存器分配和调度等，从而使得程序员可以以函数调用的方式来实现汇编能达到的功能，编译器会生成为对应的SSE等指令集汇编。</p>
<p>Intel Intrinsic Guide可以查询到所有的Intrinsic指令、对应的汇编指令以及如何使用等。</p>
<p>对于VC来说，VC6支持MMX、3DNow!、SSE、SSE2，然后更高版本的VC支持更多的指令集。但是，VC没有提供检测Intrinsic函数集支持性的办法。</p>
<p>而对于GCC来说，它使用-mmmx、-msse等编译器开关来启用各种指令集，同时定义了对应的<code>__MMX__</code>、<code>__SSE__</code>等宏，然后<code>x86intrin.h</code>会根据这些宏来声明相应的Intrinsic函数集。<code>__MMX__</code>、<code>__SSE__</code>等宏可以帮助我们判断Intrinsic函数集是否支持，但这只是GCC的专用功能。</p>
<p>如果使用GCC编译器时，使用intrinsics指令时需要在编写cmake或者makefile文件时加上相关参数，例如使用AVX指令集时添加-mavx2参数。</p>
<p>GCC:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>头文件</th>
<th>宏</th>
<th>编译器参数</th>
</tr>
</thead>
<tbody>
<tr>
<td>avx2intrin.h</td>
<td><strong>AVX2</strong></td>
<td>-mavx2</td>
</tr>
<tr>
<td>avxintrin.h</td>
<td><strong>AVX</strong></td>
<td>-mavx</td>
</tr>
<tr>
<td>emmintrin.h</td>
<td><strong>SSE2</strong></td>
<td>-msse2</td>
</tr>
<tr>
<td>nmmintrin.h</td>
<td><strong>SSE4_2</strong></td>
<td>-msse4.2</td>
</tr>
<tr>
<td>xmmintrin.h</td>
<td><strong>SSE</strong></td>
<td>-msse</td>
</tr>
<tr>
<td>mmintrin.h</td>
<td><strong>MMX</strong></td>
<td>-mmmx</td>
</tr>
</tbody>
</table>
</div>
<p>头文件设置<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mmintrin.h&gt;</span> <span class="comment">//MMX</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xmmintrin.h&gt;</span> <span class="comment">//SSE(include mmintrin.h)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span> <span class="comment">//SSE2(include xmmintrin.h)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pmmintrin.h&gt;</span> <span class="comment">//SSE3(include emmintrin.h)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tmmintrin.h&gt;</span><span class="comment">//SSSE3(include pmmintrin.h)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;smmintrin.h&gt;</span><span class="comment">//SSE4.1(include tmmintrin.h)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nmmintrin.h&gt;</span><span class="comment">//SSE4.2(include smmintrin.h)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wmmintrin.h&gt;</span><span class="comment">//AES(include nmmintrin.h)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;immintrin.h&gt;</span><span class="comment">//AVX(include wmmintrin.h)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span><span class="comment">//(include immintrin.h)</span></span></span><br></pre></td></tr></table></figure></p>
<p>上述头文件中，下一个头文件包含上一个头文件中内容，例如xmmintrin.h为SSE 头文件，此头文件里包含MMX头文件，emmintrin.h为SSE2头文件，此头文件里包含SSE头文件。</p>
<p>VC引入<code>&lt;intrin.h&gt;</code>会自动引入当前编译器所支持的所有Intrinsic头文件。GCC引入<code>&lt;x86intrin.h&gt;</code>.</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用SSE指令，首先要了解这一类用于进行初始化加载数据以及将寄存器的数据保存到内存相关的指令，我们知道，大多数SSE指令是使用的xmm0到xmm8的寄存器，那么使用之前，就需要将数据从内存加载到这些寄存器，在寄存器中完成运算后， 再把计算结果从寄存器中取出放入内存。C++编程人员在使用SSE指令函数编程时，除了加载存储数据外，不必关心这些128位的寄存器的调度，你可以使用128位的数据类型__m128和一系列C++函数来实现这些算术和逻辑操作，而决定程序使用哪个SSE寄存器以及代码优化是C++编译器的任务。</p>
<p>load系列函数，用于加载数据，从内存到寄存器。</p>
<p>set系列函数，用于加载数据，大部分需要多个指令执行周期完成，但是可能不需要16字节对齐.这一系列函数主要是类似于load的操作，但是可能会调用多条指令去完成，方便的是可能不需要考虑对齐的问题。</p>
<p>store系列函数，用于将计算结果等SSE寄存器的数据保存到内存中。这一系列函数和load系列函数的功能对应，基本上都是一个反向的过程</p>
<p>SSE 指令和 AVX 指令混用<br>SSE/AVX 的混用有时不可避免，AVX-SSE transition penalty并不是由混合SSE和AVX指令导致的，而是因为混合了legacy SSE encoding 和 VEX encoding。</p>
<p>所以在使用Intel intrinsic写全新的程序时其实并不需要太担心这个问题，因为只要指定了合适的CPU 架构（比如-mavx），SSE 和AVX intrinsic 都会被编译器生成VEX-encoding 代码。</p>
<h2 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h2><p>SIMD指令的intrinsics函数名称一般为如下形式，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_mm&lt;bit_width&gt;_&lt;name&gt;_&lt;data_type&gt;</span><br></pre></td></tr></table></figure></p>
<p><bit_width> 表明了向量的位长度，即操作对象的数据类型大小，对于128位的向量，这个参数为空，对于256位的向量，这个参数为256。</p>
<p><name>描述了内联函数的算术操作。一般由两部分组成：</p>
<p>第一部分是表示指令的作用，比如加法add等；</p>
<p>第二部分是可选的修饰符，表示一些特殊的作用，比如从内存对齐，逆序加载等；</p>
<p><data_type> 表明了操作的粒度，具体情形见下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><data_type>标识</th>
<th>数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>epi8/epi16/epi32</td>
<td>有符号的8,16,32位整数</td>
</tr>
<tr>
<td>epu8/epu16/epu32</td>
<td>无符号的8,16.32位整数</td>
</tr>
<tr>
<td>si128/si256</td>
<td>未指定的128,256位向量</td>
</tr>
<tr>
<td>ps</td>
<td>包装型单精度浮点数</td>
</tr>
<tr>
<td>ss</td>
<td>scalar single precision floating point data    数量型单精度浮点数</td>
</tr>
<tr>
<td>pd</td>
<td>pached double precision floating point data    包装型双精度浮点数</td>
</tr>
<tr>
<td>sd</td>
<td>数量型双精度浮点数</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>可选的修饰符</th>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>loadu</td>
<td>Unaligned memory: 对内存未对齐的数据进行操作</td>
</tr>
<tr>
<td>s</td>
<td>subs/adds</td>
<td>Saturate: 饱和计算将考虑内存能够存储的最小/最大值。非饱和计算略内存问题。即计算的上溢和下溢</td>
</tr>
<tr>
<td>h</td>
<td>hsub/hadd</td>
<td>Horizontally: 在水平方向上做加减法</td>
</tr>
<tr>
<td>hi/lo</td>
<td>mulhi</td>
<td>高/低位</td>
</tr>
<tr>
<td>r</td>
<td>setr</td>
<td>Reverse order: 逆序初始化向量</td>
</tr>
<tr>
<td>fm</td>
<td>fmadd</td>
<td>Fused-Multiply-Add(FMA)运算，单一指令进行三元运算</td>
</tr>
</tbody>
</table>
</div>
<p>在饱和模式下，当计算结果发生溢出（上溢或下溢）时，CPU会自动去掉溢出的部分，使计算结果取该数据类型表示数值的上限值（如果上溢）或下限值（如果下溢）。</p>
<p>注释中的printf部分是利用<code>__m128</code>这个数据类型来获取相关的值，这个类型是一个union类型，具体定义可以参考相关头文件，但是，对于实际使用，有时候这个值是一个中间值，需要后面计算使用，就得使用store了，效率更高。上面使用的是<code>_mm_loadu_ps</code>和<code>_mm_storeu_ps</code>，不要求字节对齐，如果使用<code>_mm_load_ps</code>和<code>_mm_store_ps</code>，会发现程序会崩溃或得不到正确结果。下面是指定字节对齐后的一种实现方法：</p>
<p>这类函数名一般以<code>__m</code>开头。函数名称和指令名称有一定的关系</p>
<p>SSE/AVX 指令集允许使用汇编指令集去操作XMM和YMM寄存器，但直接使用AVX 汇编指令编写汇编代码并不是十分友好而且效率低下。因此，intrinsic function 应运而生。Intrinsic function 类似于 high level 的汇编，开发者可以无痛地将 instinsic function 同 C/C++ 的高级语言特性（如分支、循环、函数和类）无缝衔接。</p>
<p>SSE/AVX intrinsic functions 的命名习惯如下</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__&lt;return_type&gt; _&lt;vector_size&gt;_&lt;intrin_op&gt;_&lt;suffix&gt;</span><br></pre></td></tr></table></figure>
<p>__128i, _256i是由整型构成的向量，char、 short、 int 、 long 均属于整型。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__m128 _mm_set_ps (float e3, float e2, float e1, float e0)</span><br><span class="line"></span><br><span class="line">__m256 _mm256_add_pd (__m256 a, __m256 b)</span><br><span class="line"></span><br><span class="line">__m512 _mm512_max_epi64 (__m512 a, __m512 b)</span><br></pre></td></tr></table></figure>
<ol>
<li>return_type, 如 m128、m256 和 m512 代表函数的返回值类型，m128 代表128位的向量，m256代表256位的向量，m512代表512位的向量。</li>
<li>vector_size , 如 mm、mm256 和 mm512 代表函数操作的数据向量的位长度，mm 代表 128 位的数据向量（SSE），mm256 代表256位的数据向量（AVX 和 AVX2）, mm512 代表512位的数据向量。</li>
<li>intrin_op，如 set、add 和 max 非常直观的解释函数功能。函数基础功能可以分为数值计算、数据传输、比较和转型四种，参阅 <a href="https://link.zhihu.com/?target=https%3A//www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html">Intel Intrinsics Guide</a> 和 <a href="https://link.zhihu.com/?target=https%3A//db.in.tum.de/~finis/x86-intrin-cheatsheet-v2.2.pdf%3Flang%3Den">x86 Intrinsics Cheat Sheet</a>。</li>
<li>suffix, 如ps、pd、epi64代表函数参数的数据类型，其中 p = packed，s = 单精度浮点数，d = 双精度浮点数，ep</li>
</ol>
<ul>
<li>ps: 由float类型数据组成的向量</li>
<li>pd:由double类型数据组成的向量</li>
<li>epi8/epi16/epi32/epi64: 由8位/16位/32位/64位的有符号整数组成的向量</li>
<li>epu8/epu16/epu32/epu64: 包含8位/16位/32位/64位的无符号整数组成的向量</li>
<li>si128/si256: 未指定的128位或者256位向量</li>
</ul>
<h2 id="常用的-Intrinsic-指令"><a href="#常用的-Intrinsic-指令" class="headerlink" title="常用的 Intrinsic 指令"></a>常用的 Intrinsic 指令</h2><p>在理解了最基础的指令后，可以到 Intel Intrinsic Guide 查询到所有指令。</p>
<p>1、 load系列，用于加载数据，从内存到暂存器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__m128 _mm_load_ss (<span class="type">float</span> *p)  </span><br><span class="line">__m128 _mm_load_ps (<span class="type">float</span> *p)  </span><br><span class="line">__m128 _mm_load1_ps (<span class="type">float</span> *p)  </span><br><span class="line">__m128 _mm_loadh_pi (__m128 a, __m64 *p)  </span><br><span class="line">__m128 _mm_loadl_pi (__m128 a, __m64 *p)  </span><br><span class="line">__m128 _mm_loadr_ps (<span class="type">float</span> *p)  </span><br><span class="line">__m128 _mm_loadu_ps (<span class="type">float</span> *p)</span><br></pre></td></tr></table></figure>
<p>上面是从手册查询到的load系列的函数。其中，</p>
<ul>
<li><code>_mm_load_ss</code>用于scalar的加载，所以，加载一个单精度浮点数到暂存器的低字节，其它三个字节清0，（r0 := *p, r1 := r2 := r3 := 0.0）。</li>
<li><code>_mm_load_ps</code>用于packed的加载（下面的都是用于packed的），要求p的地址是16字节对齐，否则读取的结果会出错，（r0 := p[0], r1 := p[1], r2 := p[2], r3 := p[3]）。</li>
<li><code>_mm_load1_ps</code>表示将p地址的值，加载到暂存器的四个字节，需要多条指令完成，所以，从性能考虑，在内层循环不要使用这类指令。（r0 := r1 := r2 := r3 := *p）。</li>
<li><code>_mm_loadh_pi</code>和<code>_mm_loadl_pi</code>分别用于从两个参数高底字节等组合加载。具体参考手册。</li>
<li><code>_mm_loadr_ps</code>表示以<code>_mm_load_ps</code>反向的顺序加载，需要多条指令完成，当然，也要求地址是16字节对齐。（r0 := p[3], r1 := p[2], r2 := p[1], r3 := p[0]）。</li>
<li><code>_mm_loadu_ps</code>和<code>_mm_load_ps</code>一样的加载，但是不要求地址是16字节对齐，对应指令为movups。</li>
</ul>
<p>2、set系列，用于加载数据，大部分需要多条指令完成，但是可能不需要16字节对齐。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__m128 _mm_set_ss (<span class="type">float</span> w)  </span><br><span class="line">__m128 _mm_set_ps (<span class="type">float</span> z, <span class="type">float</span> y, <span class="type">float</span> x, <span class="type">float</span> w)  </span><br><span class="line">__m128 _mm_set1_ps (<span class="type">float</span> w)  </span><br><span class="line">__m128 _mm_setr_ps (<span class="type">float</span> z, <span class="type">float</span> y, <span class="type">float</span> x, <span class="type">float</span> w)  </span><br><span class="line">__m128 _mm_setzero_ps ()  </span><br></pre></td></tr></table></figure>
<p>这一系列函数主要是类似于load的操作，但是可能会调用多条指令去完成，方便的是可能不需要考虑对齐的问题。</p>
<ul>
<li><code>_mm_set_ss</code>对应于_mm_load_ss的功能，不需要字节对齐，需要多条指令。（r0 = w, r1 = r2 = r3 = 0.0）</li>
<li><code>_mm_set_ps</code>对应于_mm_load_ps的功能，参数是四个单独的单精度浮点数，所以也不需要字节对齐，需要多条指令。（r0=w, r1 = x, r2 = y, r3 = z，注意顺序）</li>
<li><code>_mm_set1_ps</code>对应于_mm_load1_ps的功能，不需要字节对齐，需要多条指令。（r0 = r1 = r2 = r3 = w）</li>
<li><code>_mm_setzero_ps</code>是清0操作，只需要一条指令。（r0 = r1 = r2 = r3 = 0.0）</li>
</ul>
<p>3、store系列，用于将计算结果等SSE寄存器的数据保存到内存中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _mm_store_ss (<span class="type">float</span> *p, __m128 a)  </span><br><span class="line"><span class="type">void</span> _mm_store_ps (<span class="type">float</span> *p, __m128 a)  </span><br><span class="line"><span class="type">void</span> _mm_store1_ps (<span class="type">float</span> *p, __m128 a)  </span><br><span class="line"><span class="type">void</span> _mm_storeh_pi (__m64 *p, __m128 a)  </span><br><span class="line"><span class="type">void</span> _mm_storel_pi (__m64 *p, __m128 a)  </span><br><span class="line"><span class="type">void</span> _mm_storer_ps (<span class="type">float</span> *p, __m128 a)  </span><br><span class="line"><span class="type">void</span> _mm_storeu_ps (<span class="type">float</span> *p, __m128 a)  </span><br><span class="line"><span class="type">void</span> _mm_stream_ps (<span class="type">float</span> *p, __m128 a) </span><br></pre></td></tr></table></figure></p>
<p>这一系列函数和load系列函数的功能对应，基本上都是一个反向的过程。</p>
<ul>
<li><code>_mm_store_ss</code>：一条指令，*p = a0</li>
<li><code>_mm_store_ps</code>：一条指令，p[i] = a[i]。</li>
<li><code>_mm_store1_ps</code>：多条指令，p[i] = a0。</li>
<li><code>_mm_storeh_pi</code>，_mm_storel_pi：值保存其高位或低位。</li>
<li><code>_mm_storer_ps</code>：反向，多条指令。</li>
<li><code>_mm_storeu_ps</code>：一条指令，p[i] = a[i]，不要求16字节对齐。</li>
<li><code>_mm_stream_ps</code>：直接写入内存，不改变cache的数据。</li>
</ul>
<p>4、算术指令</p>
<p>SSE提供了大量的浮点运算指令，包括加法、减法、乘法、除法、开方、最大值、最小值、近似求倒数、求开方的倒数等等，可见SSE指令的强大之处。那么在了解了上面的数据加载和数据保存的指令之后，使用这些算术指令就很容易了，下面以加法为例。SSE中浮点加法的指令有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__m128 _mm_add_ss (__m128 a, __m128 b)  </span><br><span class="line">__m128 _mm_add_ps (__m128 a, __m128 b)  </span><br></pre></td></tr></table></figure>
<p>其中，<code>_mm_add_ss</code>表示scalar执行模式，<code>_mm_add_ps</code>表示packed执行模式。</p>
<p>一般而言，使用SSE指令写代码，步骤为：使用load/set函数将数据从内存加载到SSE暂存器；使用相关SSE指令完成计算等；使用store系列函数将结果从暂存器保存到内存，供后面使用。</p>
<h1 id="mm-prefetch"><a href="#mm-prefetch" class="headerlink" title="_mm_prefetch"></a>_mm_prefetch</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void_mm_prefetch</span>(<span class="type">char</span> *p, <span class="type">int</span> i)</span><br></pre></td></tr></table></figure>
<p>从地址P处预取尺寸为cache line大小的数据缓存，参数i指示预取方式（<code>_MM_HINT_T0</code>, <code>_MM_HINT_T1</code>, <code>_MM_HINT_T2</code>, <code>_MM_HINT_NTA</code>，分别表示不同的预取方式）</p>
<ul>
<li>T0 预取数据到所有级别的缓存，包括L0。</li>
<li>T1 预取数据到除L0外所有级别的缓存。</li>
<li>T2 预取数据到除L0和L1外所有级别的缓存。</li>
<li>NTA  预取数据到非临时缓冲结构中，可以最小化对缓存的污染。</li>
</ul>
<p>如果在CPU操作数据之前，我们就已经将数据主动加载到缓存中，那么就减少了由于缓存不命中，需要从内存取数的情况，这样就可以加速操作，获得性能上提升。使用主动缓存技术来优化内存拷贝。</p>
<p>注 意，CPU对数据操作拥有绝对自由！使用预取指令只是按我们自己的想法对CPU的数据操作进行补充，有可能CPU当前并不需要我们加载到缓存的数据，这 样，我们的预取指令可能会带来相反的结果，比如对于多任务系统，有可能我们冲掉了有用的缓存。不过，在多任务系统上，由于线程或进程的切换所花费的时间相 对于预取操作来说太长了, 所以可以忽略线程或进程切换对缓存预取的影响。</p>
<h1 id="mm-movehl-ps"><a href="#mm-movehl-ps" class="headerlink" title="_mm_movehl_ps"></a>_mm_movehl_ps</h1><p>Moves the upper two single-precision, floating-point values of  b  to the lower two single-precision, floating-point values of the result. The upper two single-precision, floating-point values of a are passed through to the result.</p>
<p>将 b 的高 64 位移至结果的低 64 位， a 的高 64 位传递给结果。</p>
<p>如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = __m128 _mm_movehl_ps( __m128 a, __m128 b ); <span class="comment">//r = &#123;a3, a2, b3, b2&#125; // 高 — 低</span></span><br><span class="line"></span><br><span class="line">s = _mm_movehl_ps( x , x );<span class="comment">// 高-- 低s = &#123;x3, x2, x3, x2&#125;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="关于指令集的一些问题集中回答"><a href="#关于指令集的一些问题集中回答" class="headerlink" title="关于指令集的一些问题集中回答"></a>关于指令集的一些问题集中回答</h1><h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><p>（1）浮点计算 vs 整数计算：为什么要分开讲呢？因为在指令集中也是分开的，另外，由于浮点数占4个字节或者8个字节，而整数却可以分别占1,2,4个字节按照应用场合不同使用的不同，因此向量化加速也不同。因此一个指令最多完成4个浮点数计算。而可以完成16个int8_t数据的计算。</p>
<p>（2）优化技巧：注意指令的顺序，为什么呢，因为CPU是流水线工作的，因此相邻的指令开始的执行的时间并非一个指令执行完毕之后才会开始，但是一旦遇到数据联系，这时候会发生阻塞，如果我们很好的安排指令的顺序，使得数据相关尽量少发生，或者发生的时候上一个指令已经执行完了。因此注意稍微修改指令的执行顺序就会使得代码变快。</p>
<h2 id="指令集的一些问题"><a href="#指令集的一些问题" class="headerlink" title="指令集的一些问题"></a>指令集的一些问题</h2><p>（1）没有统一的移植标准。</p>
<p>就以SSE指令而言。SSE的指令集是X86架构CPU特有的，对于ARM架构、MIPS架构等CPU是不支持的，所以使用了SSE指令集的程序，是不具备可移植标准的。</p>
<p>不仅如此，前面说过Intel和AMD对于同样的128bit向量的指令语法是不一样的，所以，在Intel之下所写的代码并不能一直到AMD的机器上进行指令集加速，其它的也一样，也就是说，写的某一种指令加速代码，不具备完全的可移植性。</p>
<p>SIMD指令，可以一次性装载多个元素到寄存器。如果是128位宽度，则可以一次装载4个单精度浮点数。这4个float可以一次性地参与乘法计算，理论上可提速4倍。不同的平台有不同的SIMD指令集，如Intel平台的指令集有MMX、SSE、AVX2、AVX512等（后者是对前者的扩展，本质一样），ARM平台是128位的NEON指令集。如果你希望用SIMD给算法加速，你首先需要学习不同平台的SIMD指令集，并为不同的平台写不同的代码，最后逐个测试准确性。这样无法实现write once, run anywhere的目标。</p>
<p>（2）针对指令集没办法转移的解决方案</p>
<p>OpenCV 4.x中提供了强大的统一向量指令（universal intrinsics），使用这些指令可以方便地为算法提速。所有的计算密集型任务皆可使用这套指令加速，并不是专门针对计算机视觉算法。目前OpenCV的代码加速实现基本上都基于这套指令。OpenCV设计了一套统一的向量指令universal intrinsics，可以让你写一份代码，在不同平台上都可以实现向量加速</p>
<h2 id="指令集优化代码的一般步骤"><a href="#指令集优化代码的一般步骤" class="headerlink" title="指令集优化代码的一般步骤"></a>指令集优化代码的一般步骤</h2><ol>
<li>第一步：即所谓的load步骤。指的是需要将数据从内存加载（load）到CPU的内存储里面；</li>
<li>第二步：即所谓的运算。将加载进来的数据进行加减乘除等等运算；</li>
<li>第三步：即所谓的store步骤。将运算的结果需要重新存储到内存里面；</li>
</ol>
<h1 id="SSE指令集的使用说明"><a href="#SSE指令集的使用说明" class="headerlink" title="SSE指令集的使用说明"></a>SSE指令集的使用说明</h1><p>SSE本质上类似于一个向量处理器，所谓的向量处理器实际上就是进行向量的运算，</p>
<p>包括了4个主要部分：单精确度浮点数运算指令、整数运算指令(为MMX的延伸，并与MMX使用同样的暂存器)、Cache控制指令、状态控制指令。</p>
<h2 id="如何使用SSE指令"><a href="#如何使用SSE指令" class="headerlink" title="如何使用SSE指令"></a>如何使用SSE指令</h2><p>使用SSE指令有两种方式：</p>
<ul>
<li>一是直接在C/C++中嵌入（汇编）指令；</li>
<li>二是使用Intel C++ Compiler或是Microsoft Visual C++中提供的支持SSE指令集的intrinsics内联函数。</li>
</ul>
<p>从代码可读和维护角度讲，推荐使用intrinsics内联函数的形式。intrinsics是对MMX、SSE等指令集的一种封装，以函数的形式提供，使得程序员更容易编写和使用这些高级指令，在编译的时候，这些函数会被内联为汇编，不会产生函数调用的开销。想要使用SSE指令，则需要包含对应的头文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mmintrin.h&gt;</span> <span class="comment">//mmx</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xmmintrin.h&gt;</span> <span class="comment">//sse</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span> <span class="comment">//sse2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pmmintrin.h&gt;</span> <span class="comment">//sse3</span></span></span><br></pre></td></tr></table></figure></p>
<p>备注：本文所介绍的是在VS平台中VC++所提供的intrinstic内联函数的使用说明。这样使用起来就很简单了，主要是包含两部分，数据类型和数据操作指令（加载load、运算、存储store），另外，虽然现在SSE已经有了很多个版本，SSE、SSE2、SSE3、SSE4.1、SSSE4.2等等，它们之间有所差别，但是大致的使用以及思想原理是一致的。</p>
<h2 id="SSE的数据类型"><a href="#SSE的数据类型" class="headerlink" title="SSE的数据类型"></a>SSE的数据类型</h2><p>SSE指令中intrinsics函数的数据类型为：</p>
<p>（1）<code>__m128</code>（单精度浮点数），如果使用<code>sizeof(__m128)</code>计算该类型大小，结果为16，即等于四个浮点数长度。<code>__declspec(align(16))</code>做为数组定义的修释符，表示该数组是以16字节为边界对齐的，因为SSE指令大部分支持这种格式的内存数据。他的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__declspec</span>(intrin_type) __declspec(<span class="built_in">align</span>(<span class="number">16</span>)) __m128 &#123;</span><br><span class="line">    <span class="type">float</span> m128_f32[<span class="number">4</span>];</span><br><span class="line">&#125; __m128;</span><br></pre></td></tr></table></figure>
<p>除<code>__m128</code>外、还包括</p>
<p>（2）<code>__m128d</code>（双精度浮点数）</p>
<p>（3）<code>__m128i</code>（整型）。其中<code>__m128i</code>是一个共用体类型（union），其定义如下 ：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">__declspec</span>(intrin_type) __declspec(<span class="built_in">align</span>(<span class="number">16</span>)) __m128i &#123;</span><br><span class="line">    __int8 m128i_i8[<span class="number">16</span>];</span><br><span class="line">    __int16 m128i_i16[<span class="number">8</span>];</span><br><span class="line">    __int32 m128i_i32[<span class="number">4</span>];</span><br><span class="line">    __int64 m128i_i64[<span class="number">2</span>];</span><br><span class="line">    <span class="type">unsigned</span> __int8 m128i_u8[<span class="number">16</span>];</span><br><span class="line">    <span class="type">unsigned</span> __int16 m128i_u16[<span class="number">8</span>];</span><br><span class="line">    <span class="type">unsigned</span> __int32 m128i_u32[<span class="number">4</span>];</span><br><span class="line">    <span class="type">unsigned</span> __int64 m128i_u64[<span class="number">2</span>];</span><br><span class="line">&#125; __m128i;</span><br></pre></td></tr></table></figure></p>
<p>注意数据类型前面是两个短的下划线哦！！！</p>
<h2 id="数据操作指令的一般格式（包括了数据加载load、数据运算、数据存储store）"><a href="#数据操作指令的一般格式（包括了数据加载load、数据运算、数据存储store）" class="headerlink" title="数据操作指令的一般格式（包括了数据加载load、数据运算、数据存储store）"></a>数据操作指令的一般格式（包括了数据加载load、数据运算、数据存储store）</h2><p>SSE指令通常由三部分构成：</p>
<ul>
<li>第一部分为前缀<code>_mm</code>（多媒体扩展指令集），表示该函数属于SSE指令集（前面只有一个短下划线）</li>
<li>第二部分为指令的操作类型，<ul>
<li>如加载数据一般是_load以及它的变种</li>
<li>如_add、_mul等以及这些运算的变种（一个短下划线）</li>
<li>存储数据_store以及它的一些变种</li>
</ul>
</li>
<li>第三部分通常由一个短下划线加上两个字母组成。<ul>
<li>第一个字母表示对结果变量的影响方式，为p或s。<ul>
<li>p(packed：包裹指令) ：该指令对xmm寄存器中的每个元素进行运算，即一次对四个浮点数(data0~data3)均进行计算；</li>
<li>s(scalar：标量指令)：该指令对寄存器中的第一个元素进行运算，即一次只对xmm寄存器中的data0进行计算。</li>
<li>如果针对SSE的四个数所组成的向量，如果是packed模式，则进行向量运算，如果是scalar模式，只会对第一组数据进行运算。</li>
</ul>
</li>
<li>第二个字母表示参与运算的数据类型，<ul>
<li>s表示32位浮点数，</li>
<li>d表示64位浮点数，</li>
<li>i32表示带符号32位整型，</li>
<li>i64表示带符号64位整型，</li>
<li>u32表示无符号32位整型，</li>
</ul>
</li>
<li>第三部分还可以是<code>_pi**</code>格式或者是<code>_*pi**</code>格式。<ul>
<li><code>_pi**</code>（<code>**</code>为长度，可以是8，16，32，64）packed操作所有的<code>**</code>位有符号整数，使用的寄存器长度为64位；</li>
<li><code>_epi**</code>（<code>**</code>为长度）packed操作所有的<code>**</code>位的有符号整数，使用的寄存器长度为128位；</li>
<li><code>_epu**</code>同样的道理 packed操作所有的<code>**</code>位的无符号整数；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以此类推。由于SSE只支持32位浮点数的运算，所以你可能会在这些指令封装函数中找不到包含非s修饰符的，但你可以在MMX和SSE2的指令集中去认识它们。</p>
<h2 id="使用SSE指令注意的问题"><a href="#使用SSE指令注意的问题" class="headerlink" title="使用SSE指令注意的问题"></a>使用SSE指令注意的问题</h2><p>（1）SSE指令的内存对齐要求</p>
<p>SSE中大部分指令要求地址是16bytes对齐的，要理解这个问题，以<code>_mm_load_ps</code>函数来解释，这个函数对应于loadps的SSE指令。其原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> __m128 _mm_load_ps(<span class="type">float</span> <span class="type">const</span>*_A);</span><br></pre></td></tr></table></figure></p>
<p>可以看到，它的输入是一个指向float的指针，返回的就是一个<code>__m128</code>类型的数据，从函数的角度理解，就是把一个float数组的四个元素依次读取，返回一个组合的<code>__m128</code>类型的SSE数据类型，从而可以使用这个返回的结果传递给其它的SSE指令进行运算，比如加法等；从汇编的角度理解，它对应的就是读取内存中连续四个地址的float数据，将其放入SSE新的暂存器中，从而给其他的指令准备好数据进行计算。其使用示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> input[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">4.0f</span> &#125;;</span><br><span class="line">__m128 a = _mm_load_ps(input);</span><br></pre></td></tr></table></figure></p>
<p>这里加载正确的前提是：input这个浮点数阵列都是对齐在16 bytes的边上。否则加载的结果和预期的不一样。如果没有对齐，就需要使用<code>_mm_loadu_ps</code>函数，这个函数用于处理没有对齐在16bytes上的数据，但是其速度会比较慢。</p>
<p>关于内存对齐的问题，这里就不详细讨论什么是内存对齐了，以及如何指定内存对齐方式。这里主要提一下，SSE的intrinsics函数中的扩展的方式：</p>
<ul>
<li>对于上面的例子，如果要将input指定为16bytes对齐，可以采用的方式是：<code>__declspec(align(16)) float input[4];</code></li>
<li>为了简化，在xmmintrin.h中定义了一个宏<code>_MM_ALIGN16</code>来表示上面的含义，即：<code>_MM_ALIGN16 float input[4];</code></li>
</ul>
<p>（2）大小端问题：</p>
<p>这个只是使用SSE指令的时候要注意一下，我们知道，x86的little-endian特性，位址较低的byte会放在暂存器的右边。也就是说，若以上面的input为例，即<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> input[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">4.0f</span> &#125;;</span><br><span class="line">__m128 a = _mm_load_ps(input);</span><br></pre></td></tr></table></figure></p>
<p>在载入到XMM暂存器后，暂存器中的 DATA0会是1.0，而DATA1是2.0，DATA2是3.0，DATA3是4.0。如下：</p>
<p>如果需要以相反的顺序载入的话，可以用_mm_loadr_ps 这个intrinsic，根据需要进行选择。</p>
<h2 id="常用的一些SSE指令简介"><a href="#常用的一些SSE指令简介" class="headerlink" title="常用的一些SSE指令简介"></a>常用的一些SSE指令简介</h2><p>（1）load系列，用于加载数据（从内存到暂存器），大部分需要16字节对齐<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__m128 _mm_load_ss(<span class="type">float</span> *p) <span class="comment">//将一个单精度浮点数加载到寄存器的第一个字节，其它三个字节清零（r0 := *p, r1 := r2 := r3 := 0.0）</span></span><br><span class="line">__m128 _mm_load_ps(<span class="type">float</span> *p) <span class="comment">//将四个单精度浮点数加载到寄存器（r0 := p[0], r1 := p[1], r2 := p[2], r3 := p[3]）</span></span><br><span class="line">__m128 _mm_load1_ps(<span class="type">float</span> *p)<span class="comment">//将p地址的值加载到暂存器的四个字节，需要多条指令完成。从性能考虑，在内层循环不要使用这类指令（r0 := r1 := r2 := r3 := *p）</span></span><br><span class="line"></span><br><span class="line">__m128 _mm_loadh_pi(__m128 a, __m64 *p)<span class="comment">//</span></span><br><span class="line">__m128 _mm_loadl_pi(__m128 a, __m64 *p)<span class="comment">//</span></span><br><span class="line">__m128 _mm_loadr_ps(<span class="type">float</span> *p)<span class="comment">//以_mm_load_ps反向的顺序加载，需要多条指令完成。（r0 := p[3], r1 := p[2], r2 := p[1], r3 := p[0]）</span></span><br><span class="line">__m128 _mm_loadu_ps(<span class="type">float</span> *p)<span class="comment">//_mm_load_ps一样的加载，但是不要求地址是16字节对齐</span></span><br></pre></td></tr></table></figure></p>
<p>（2）set系列，用于加载数据，类似于load操作，但是大部分需要多条指令完成，可能不需要16字节对齐<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__m128 _mm_set_ss(<span class="type">float</span> w)<span class="comment">//对应于_mm_load_ss的功能，不需要字节对齐，需要多条指令（r0 = w, r1 = r2 = r3 = 0.0）</span></span><br><span class="line">__m128 _mm_set_ps(<span class="type">float</span> z, <span class="type">float</span> y, <span class="type">float</span> x, <span class="type">float</span> w)<span class="comment">//对应于_mm_load_ps的功能，参数是四个单独的单精度浮点数，所以也不需要字节对齐，需要多条指令。（r0=w, r1 = x, r2 = y, r3 = z，注意顺序）</span></span><br><span class="line">__m128 _mm_set1_ps(<span class="type">float</span> w)<span class="comment">//对应于_mm_load1_ps的功能，不需要字节对齐，需要多条指令。（r0 = r1 = r2 = r3 = w）</span></span><br><span class="line">__m128 _mm_setr_ps(<span class="type">float</span> z, <span class="type">float</span> y, <span class="type">float</span> x, <span class="type">float</span> w)<span class="comment">//对应于_mm_loadr_ps功能，不需要字节对齐，需要多条指令。（r0=z, r1 = y, r2 = x, r3 = w，注意顺序）</span></span><br><span class="line">__m128 _mm_setzero_ps()<span class="comment">//清0操作，只需要一条指令。（r0 = r1 = r2 = r3 = 0.0）</span></span><br></pre></td></tr></table></figure></p>
<p>（3）store系列，将计算结果等SSE暂存器的数据保存到内存中，与load系列函数的功能对应，基本上都是一个反向的过程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _mm_store_ss(<span class="type">float</span> *p, __m128 a) <span class="comment">//一条指令，*p = a0</span></span><br><span class="line"><span class="type">void</span> _mm_store_ps(<span class="type">float</span> *p, __m128 a) <span class="comment">//一条指令，p[i] = a[i]</span></span><br><span class="line"><span class="type">void</span> _mm_store1_ps(<span class="type">float</span> *p, __m128 a) <span class="comment">//多条指令，p[i] = a0</span></span><br><span class="line"><span class="type">void</span> _mm_storeh_pi(__m64 *p, __m128 a) <span class="comment">//</span></span><br><span class="line"><span class="type">void</span> _mm_storel_pi(__m64 *p, __m128 a) <span class="comment">//</span></span><br><span class="line"><span class="type">void</span> _mm_storer_ps(<span class="type">float</span> *p, __m128 a) <span class="comment">//反向，多条指令</span></span><br><span class="line"><span class="type">void</span> _mm_storeu_ps(<span class="type">float</span> *p, __m128 a) <span class="comment">//一条指令，p[i] = a[i]，不要求16字节对齐</span></span><br><span class="line"><span class="type">void</span> _mm_stream_ps(<span class="type">float</span> *p, __m128 a) <span class="comment">//直接写入内存，不改变cache的数据</span></span><br></pre></td></tr></table></figure></p>
<p>（4）算数指令系列，SSE提供了大量的浮点运算指令，包括加法、减法、乘法、除法、开方、最大值、最小值等等<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__m128 _mm_add_ss (__m128 a, __m128 b)</span><br><span class="line">__m128 _mm_add_ps (__m128 a, __m128 b)</span><br></pre></td></tr></table></figure></p>
<p>当然算数指令有很多，这里只列举了两个，应该说主要是算术运算指令。</p>
<p>（5）数据类型转换系列<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__mm_cvtss_si32 <span class="comment">//单精度浮点数转换为有符号32位整数</span></span><br><span class="line">__mm_cvttss_si32 <span class="comment">//单精度浮点数转换为有符号32位整数（带截断操作）</span></span><br><span class="line">__mm_cvtpi16_ps <span class="comment">//16位有符号整数转换为单精度浮点数</span></span><br></pre></td></tr></table></figure></p>
<h2 id="SSE指令的加速效果"><a href="#SSE指令的加速效果" class="headerlink" title="SSE指令的加速效果"></a>SSE指令的加速效果</h2><p>（1）对于scalar模式的SSE加速</p>
<p>是不是只要采用SSE进行加速就一定会加快运行速度呢？当然不是了，SSE包含packed和scalar两种方式，我们采用scalar运算由于每一次只计算一个值，通过实验对比，使用SSE的scalar加速反而还没有原始的C代码速度快，</p>
<p>（2）对于packed模式的加速</p>
<p>使用packed模式加速，虽然每一次运算4个单精度浮点数，使用SSE优化之后，我们的代码不一定会得到4倍速的提升，因为编译器可能已经自动对某些代码进行SSE优化了。</p>
<h1 id="SSE优化的具体实例"><a href="#SSE优化的具体实例" class="headerlink" title="SSE优化的具体实例"></a>SSE优化的具体实例</h1><p>案例说明，比如我要经过两个矩阵的逐元素乘积，我分别通过三种方式来对比</p>
<ul>
<li>方式一：原生的C/C++代码</li>
<li>方式二：使用SSE的scalar进行优化</li>
<li>方式三：使用OpenCV自带的mul函数</li>
</ul>
<h2 id="方式一：原生的C-C-代码"><a href="#方式一：原生的C-C-代码" class="headerlink" title="方式一：原生的C/C++代码"></a>方式一：原生的C/C++代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Mat1和Mat2矩阵元素乘积之后更新到Mat2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mat_multi</span><span class="params">(Mat m1, Mat m2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> * pixel_1 = (<span class="type">float</span> *)m1.data + i * m1.step / <span class="number">4</span>; <span class="comment">//32f</span></span><br><span class="line">        <span class="type">float</span> * pixel_2 = (<span class="type">float</span> *)m2.data + i * m2.step / <span class="number">4</span>; <span class="comment">//32f</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m1.cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            *pixel_2 = (*pixel_1) * (*pixel_2);</span><br><span class="line">            pixel_1 += <span class="number">1</span>;</span><br><span class="line">            pixel_2 += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方式二：使用SSE的scalar进行优化"><a href="#方式二：使用SSE的scalar进行优化" class="headerlink" title="方式二：使用SSE的scalar进行优化"></a>方式二：使用SSE的scalar进行优化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sse_mat_multi</span><span class="params">(Mat m1, Mat m2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m1.rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> * pixel_1 = (<span class="type">float</span> *)m1.data + i * m1.step / <span class="number">4</span>; <span class="comment">//32f</span></span><br><span class="line">        <span class="type">float</span> * pixel_2 = (<span class="type">float</span> *)m2.data + i * m2.step / <span class="number">4</span>; <span class="comment">//32f</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m1.cols; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            __m128 sse_1 = _mm_load_ps(pixel_1); <span class="comment">//将a地址指向的值复制给SSEA</span></span><br><span class="line">            __m128 sse_2 = _mm_load_ps(pixel_2); <span class="comment">//将b地址指向的值复制给SSEB</span></span><br><span class="line">            __m128 h = _mm_mul_ss(sse_1, sse_2); <span class="comment">//声明了变量并赋值（1.0f）</span></span><br><span class="line">            _mm_storer_ps(pixel_2, h);</span><br><span class="line">            pixel_1 += <span class="number">1</span>;</span><br><span class="line">            pixel_2 += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果测试<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argv, <span class="type">char</span> *args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">clock_t</span> start, end;</span><br><span class="line">    Mat m1 = <span class="built_in">Mat</span>(<span class="built_in">Size</span>(<span class="number">10000</span>, <span class="number">10000</span>), CV_32FC1);</span><br><span class="line">    m1.<span class="built_in">setTo</span>(<span class="number">1</span>);</span><br><span class="line">    Mat m2 = <span class="built_in">Mat</span>(<span class="built_in">Size</span>(<span class="number">10000</span>, <span class="number">10000</span>), CV_32FC1);</span><br><span class="line">    m1.<span class="built_in">setTo</span>(<span class="number">2</span>);</span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">mat_multi</span>(m1, m2);</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;mat multi is : &quot;</span> &lt;&lt; (<span class="type">double</span>)(end - start) &lt;&lt; std::endl;</span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">sse_mat_multi</span>(m1, m2);</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sse mat multi is : &quot;</span> &lt;&lt; (<span class="type">double</span>)(end - start) &lt;&lt; std::endl;</span><br><span class="line">    start = <span class="built_in">clock</span>();</span><br><span class="line">    m1.<span class="built_in">mul</span>(m2);</span><br><span class="line">    end = <span class="built_in">clock</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;opencv mul is : &quot;</span> &lt;&lt; (<span class="type">double</span>)(end - start) &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果为：</span></span><br><span class="line"><span class="comment">mat multi is : 198</span></span><br><span class="line"><span class="comment">sse mat multi is : 259</span></span><br><span class="line"><span class="comment">opencv mul is : 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>结论：由此可见自己写的基于scalar模式下的SSE优化反而变得慢了，而OpenCV原本的矩阵运算非常迅速，速度快的不是一点点，因为现在OpenCV4以上的版本，OpenCV使用了非常多的优化手段，比如parallel，SSE指令集加速，所以我们一般不要自己重写OpenCV已经有了的运算。</p>
<h1 id="SSE优化使用VC-提供的指令集优化对比汇编指令优化"><a href="#SSE优化使用VC-提供的指令集优化对比汇编指令优化" class="headerlink" title="SSE优化使用VC++提供的指令集优化对比汇编指令优化"></a>SSE优化使用VC++提供的指令集优化对比汇编指令优化</h1><p>（1）原生态的C/C++<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSSETestDlg::ComputeArrayCPlusPlus</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">float</span>* pArray1, <span class="comment">// [in] first source array</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">float</span>* pArray2, <span class="comment">// [in] second source array</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">float</span>* pResult, <span class="comment">// [out] result array</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nSize)</span> <span class="comment">// [in] size of all arrays</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span>* pSource1 = pArray1;</span><br><span class="line">    <span class="type">float</span>* pSource2 = pArray2;</span><br><span class="line">    <span class="type">float</span>* pDest = pResult;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; nSize; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        *pDest = (<span class="type">float</span>)<span class="built_in">sqrt</span>((*pSource1) * (*pSource1) + (*pSource2)</span><br><span class="line">        * (*pSource2)) + <span class="number">0.5f</span>;</span><br><span class="line">        pSource1++;</span><br><span class="line">        pSource2++;</span><br><span class="line">        pDest++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）使用VC++的SSE头文件来实现<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSSETestDlg::ComputeArrayCPlusPlusSSE</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">float</span>* pArray1, <span class="comment">// [in] first source array</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">float</span>* pArray2, <span class="comment">// [in] second source array</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">float</span>* pResult, <span class="comment">// [out] result array</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nSize)</span> <span class="comment">// [in] size of all arrays</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nLoop = nSize/ <span class="number">4</span>;</span><br><span class="line">    __m128 m1, m2, m3, m4;</span><br><span class="line">    __m128* pSrc1 = (__m128*) pArray1;</span><br><span class="line">    __m128* pSrc2 = (__m128*) pArray2;</span><br><span class="line">    __m128* pDest = (__m128*) pResult;</span><br><span class="line">    __m128 m0_5 = _mm_set_ps1(<span class="number">0.5f</span>); <span class="comment">// m0_5[0, 1, 2, 3] = 0.5</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; nLoop; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        m1 = _mm_mul_ps(*pSrc1, *pSrc1); <span class="comment">// m1 = *pSrc1 * *pSrc1</span></span><br><span class="line">        m2 = _mm_mul_ps(*pSrc2, *pSrc2); <span class="comment">// m2 = *pSrc2 * *pSrc2</span></span><br><span class="line">        m3 = _mm_add_ps(m1, m2); <span class="comment">// m3 = m1 + m2</span></span><br><span class="line">        m4 = _mm_sqrt_ps(m3); <span class="comment">// m4 = sqrt(m3)</span></span><br><span class="line">        *pDest = _mm_add_ps(m4, m0_5); <span class="comment">// *pDest = m4 + 0.5</span></span><br><span class="line">        pSrc1++;</span><br><span class="line">        pSrc2++;</span><br><span class="line">        pDest++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）直接使用SSE的汇编指令，将汇编指令嵌入到C/C++里面<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CSSETestDlg::ComputeArrayAssemblySSE</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">float</span>* pArray1, <span class="comment">// [输入] 源数组1</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">float</span>* pArray2, <span class="comment">// [输入] 源数组2</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">float</span>* pResult, <span class="comment">// [输出] 用来存放结果的数组</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> nSize)</span> <span class="comment">// [输入] 数组的大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nLoop = nSize/<span class="number">4</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">0.5f</span>;</span><br><span class="line">    _asm</span><br><span class="line">    &#123;</span><br><span class="line">        movss xmm2, f <span class="comment">// xmm2[0] = 0.5</span></span><br><span class="line">        shufps xmm2, xmm2, <span class="number">0</span> <span class="comment">// xmm2[1, 2, 3] = xmm2[0]</span></span><br><span class="line">        mov esi, pArray1 <span class="comment">// 输入的源数组1的地址送往esi</span></span><br><span class="line">        mov edx, pArray2 <span class="comment">// 输入的源数组2的地址送往edx</span></span><br><span class="line">        mov edi, pResult <span class="comment">// 输出结果数组的地址保存在edi</span></span><br><span class="line">        mov ecx, nLoop <span class="comment">//循环次数送往ecx</span></span><br><span class="line">        start_loop:</span><br><span class="line">        movaps xmm0, [esi] <span class="comment">// xmm0 = [esi]</span></span><br><span class="line">        mulps xmm0, xmm0 <span class="comment">// xmm0 = xmm0 * xmm0</span></span><br><span class="line">        movaps xmm1, [edx] <span class="comment">// xmm1 = [edx]</span></span><br><span class="line">        mulps xmm1, xmm1 <span class="comment">// xmm1 = xmm1 * xmm1</span></span><br><span class="line">        addps xmm0, xmm1 <span class="comment">// xmm0 = xmm0 + xmm1</span></span><br><span class="line">        sqrtps xmm0, xmm0 <span class="comment">// xmm0 = sqrt(xmm0)</span></span><br><span class="line">        addps xmm0, xmm2 <span class="comment">// xmm0 = xmm1 + xmm2</span></span><br><span class="line">        movaps [edi], xmm0 <span class="comment">// [edi] = xmm0</span></span><br><span class="line">        add esi, <span class="number">16</span> <span class="comment">// esi += 16</span></span><br><span class="line">        add edx, <span class="number">16</span> <span class="comment">// edx += 16</span></span><br><span class="line">        add edi, <span class="number">16</span> <span class="comment">// edi += 16</span></span><br><span class="line">        dec ecx <span class="comment">// ecx--</span></span><br><span class="line">        jnz start_loop <span class="comment">//如果不为0则转向start_loop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="SIMD-1"><a href="#SIMD-1" class="headerlink" title="SIMD"></a>SIMD</h1><p><strong>First Intrinsic Function Demo</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __AVX__</span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">warning</span> No AVX support - will not compile</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __m256 a = _mm256_set_ps(<span class="number">8.0</span>, <span class="number">7.0</span>, <span class="number">6.0</span>, <span class="number">5.0</span>, </span><br><span class="line">                             <span class="number">4.0</span>, <span class="number">3.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    __m256 b = _mm256_set_ps(<span class="number">18.0</span>, <span class="number">17.0</span>, <span class="number">16.0</span>, <span class="number">15.0</span>, </span><br><span class="line">                             <span class="number">14.0</span>, <span class="number">13.0</span>, <span class="number">12.0</span>, <span class="number">11.0</span>);</span><br><span class="line">    __m256 c = _mm256_add_ps(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> d[<span class="number">8</span>];</span><br><span class="line">    _mm256_storeu_ps(d, c);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result equals &quot;</span> &lt;&lt; d[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; d[<span class="number">1</span>]</span><br><span class="line">              &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; d[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; d[<span class="number">3</span>] &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">              &lt;&lt; d[<span class="number">4</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; d[<span class="number">5</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; d[<span class="number">6</span>] &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">              &lt;&lt; d[<span class="number">7</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># g++ --std=c++14 -O2 -mavx avx.cpp -o demo</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ./avx </span><br><span class="line">result equals 12,14,16,18,20,22,24,26</span><br></pre></td></tr></table></figure>
<h2 id="AVX2-Instruction-amp-Intrinsic-Function"><a href="#AVX2-Instruction-amp-Intrinsic-Function" class="headerlink" title="AVX2 Instruction &amp; Intrinsic Function"></a><strong>AVX2 Instruction &amp; Intrinsic Function</strong></h2><p>本节主要罗列了几种不同功能的指令集和对应的 intrinsic function，没细看的必要，随用随看吧。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Intrinsic Function</th>
<th>Operation</th>
<th>AVX2 Instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>_mm256_set1_pd</td>
<td>Set all four words with the same value</td>
<td>Composite</td>
</tr>
<tr>
<td>_mm256_set_pd</td>
<td>Set four values</td>
<td>Composite</td>
</tr>
<tr>
<td>_mm256_setr_pd</td>
<td>Set four values, in reverse order</td>
<td>Composite</td>
</tr>
<tr>
<td>_mm256_setzero_pd</td>
<td>Clear all four values</td>
<td>VXORPD</td>
</tr>
<tr>
<td>_mm256_set_m128d</td>
<td>Set lower and higher 128-bit part</td>
<td>VINSERTF128</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a><strong>Load</strong></h3><div class="table-container">
<table>
<thead>
<tr>
<th>Intrinsic Function</th>
<th>Operation</th>
<th>AVX2 Instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>_mm256_load_pd</td>
<td>Load four double values, address aligned</td>
<td>VMOVAPD ymm, mem</td>
</tr>
<tr>
<td>_mm256_loadu_pd</td>
<td>Load four double values, address unaligned</td>
<td>VMOVUPD ymm, mem</td>
</tr>
<tr>
<td>_mm256_maskload_pd</td>
<td>Load four double values using mask</td>
<td>VMASKMOVPD ymm, mem</td>
</tr>
<tr>
<td>_mm256_broadcast_sd</td>
<td>Load one double value into all four words</td>
<td>VBROADCASTSD ymm, mem</td>
</tr>
<tr>
<td>_mm256_broadcast_pd</td>
<td>Load a pair of double values into the lower and higher part of vector.</td>
<td>VBROADCASTSD ymm, mem</td>
</tr>
<tr>
<td>_mm256_i64gather_pd</td>
<td>Load double values from memory using indices.</td>
<td>VGATHERPD ymm, mem, ymm</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Intrinsic Function</th>
<th>Operation</th>
<th>AVX2 Instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>_mm256_store_pd</td>
<td>Store four values, address aligned</td>
<td>VMOVAPD</td>
</tr>
<tr>
<td>_mm256_storeu_pd</td>
<td>Store four values, address unaligned</td>
<td>VMOVUPD</td>
</tr>
<tr>
<td>_mm256_maskstore_pd</td>
<td>Store four values using mask</td>
<td>VMASKMOVPD</td>
</tr>
<tr>
<td>_mm256_storeu2_m128d</td>
<td>Store lower and higher 128-bit parts into different memory locations</td>
<td>Composite</td>
</tr>
<tr>
<td>_mm256_stream_pd</td>
<td>Store values without caching, address aligned</td>
<td>VMOVNTPD</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Intrinsic Function</th>
<th>Operation</th>
<th>AVX2 Instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>_mm256_add_ps</td>
<td>Addition</td>
<td>VADDPS</td>
</tr>
<tr>
<td>_mm256_sub_ps</td>
<td>Subtraction</td>
<td>VSUBPS</td>
</tr>
<tr>
<td>_mm256_addsub_ps</td>
<td>Alternatively add and subtract</td>
<td>VADDSUBPS</td>
</tr>
<tr>
<td>_mm256_hadd_ps</td>
<td>Half addition</td>
<td>VHADDPS</td>
</tr>
<tr>
<td>_mm256_hsub_pd</td>
<td>Half subtraction</td>
<td>VHSUBPD</td>
</tr>
<tr>
<td>_mm256_mul_pd</td>
<td>Multiplication</td>
<td>VMULPD</td>
</tr>
<tr>
<td>_mm256_sqrt_pd</td>
<td>Squared Root</td>
<td>VSQRTPD</td>
</tr>
<tr>
<td>_mm256_max_pd</td>
<td>Computes Maximum</td>
<td>VMAXPD</td>
</tr>
<tr>
<td>_mm256_min_pd</td>
<td>Computes Minimum</td>
<td>VMINPD</td>
</tr>
<tr>
<td>_mm256_ceil_pd</td>
<td>Computes Ceil</td>
<td>VROUNDPD</td>
</tr>
<tr>
<td>_mm256_floor_pd</td>
<td>Computes Floor</td>
<td>VROUNDPD</td>
</tr>
<tr>
<td>_mm256_round_pd</td>
<td>Round</td>
<td>VROUNDPD</td>
</tr>
<tr>
<td>_mm256_dp_ps</td>
<td>Single precision dot product</td>
<td>VDPPS</td>
</tr>
<tr>
<td>_mm256_fmadd_pd</td>
<td>Fused multiply-add</td>
<td>VFMADD132pd</td>
</tr>
<tr>
<td>_mm256_fmsub_pd</td>
<td>Fused multiply-subtract</td>
<td>VFMSUB132pd</td>
</tr>
<tr>
<td>_mm256_fmaddsub_pd</td>
<td>Alternatively fmadd, fmsub</td>
<td>VFMADDSUB132pd</td>
</tr>
</tbody>
</table>
</div>
<p>示例代码</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// n a multiple of 4, x is 32-byte aligned</span><br><span class="line">void addindex_vec2(double *x, int n) &#123;</span><br><span class="line">  __m256d x_vec, init, incr, ind;</span><br><span class="line">  ind = _mm256_set_pd(3, 2, 1, 0);</span><br><span class="line">  incr = _mm256_set1_pd(4);</span><br><span class="line">  for (int i = 0; i &lt; n; i+=4) &#123;</span><br><span class="line">    x_vec = _mm256_load_pd(x+i); // load 4 doubles</span><br><span class="line">    x_vec = _mm256_add_pd(x_vec, ind); // add the two</span><br><span class="line">    ind = _mm256_add_pd(ind, incr); // update ind</span><br><span class="line">    _mm256_store_pd(x+i, x_vec); // store back</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Compare"><a href="#Compare" class="headerlink" title="Compare"></a>Compare</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Intrinsic Function &amp; Instruction</th>
<th>Macro For Operation</th>
<th>Operation</th>
</tr>
</thead>
<tbody>
<tr>
<td>_mm256_cmp_pd / VCMPPD</td>
<td>_CMP_EQ_OQ</td>
<td>Equal</td>
</tr>
<tr>
<td></td>
<td>_CMP_EQ_UQ</td>
<td>Equal (unordered)</td>
</tr>
<tr>
<td></td>
<td>_CMP_GE_OQ</td>
<td>Greater Than or Equal</td>
</tr>
<tr>
<td></td>
<td>_CMP_GT_OQ</td>
<td>Greater Than</td>
</tr>
<tr>
<td></td>
<td>_CMP_LE_OQ</td>
<td>Less Than or Equal</td>
</tr>
<tr>
<td></td>
<td>_CMP_LT_OQ</td>
<td>Less Than</td>
</tr>
<tr>
<td></td>
<td>_CMP_NEQ_OQ</td>
<td>Not Equal</td>
</tr>
<tr>
<td></td>
<td>_CMP_NEQ_UQ</td>
<td>Not Equal (unordered)</td>
</tr>
<tr>
<td></td>
<td>_CMP_NGE_UQ</td>
<td>Not Greater Than or Equal (unordered)</td>
</tr>
<tr>
<td></td>
<td>_CMP_NGT_UQ</td>
<td>Not Greater Than (unordered)</td>
</tr>
<tr>
<td></td>
<td>_CMP_NLE_UQ</td>
<td>Not Less Than or Equal (unordered)</td>
</tr>
<tr>
<td></td>
<td>_CMP_NLT_UQ</td>
<td>Not Less Than (unordered)</td>
</tr>
<tr>
<td></td>
<td>_CMP_TRUE_UQ</td>
<td>True (unordered)</td>
</tr>
<tr>
<td></td>
<td>_CMP_FALSE_OQ</td>
<td>False</td>
</tr>
<tr>
<td></td>
<td>_CMP_ORD_Q</td>
<td>Ordered</td>
</tr>
<tr>
<td></td>
<td>_CMP_UNORD_Q</td>
<td>Unordered</td>
</tr>
</tbody>
</table>
</div>
<p>示例代码</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;xmmintrin.h&gt;</span><br><span class="line">void fcond_vec1(double *x, size_t n) &#123;</span><br><span class="line">  int i;</span><br><span class="line">  __m256d vt, vmask, vp, vm, vr, ones, mones, thresholds;</span><br><span class="line">  ones = _mm256_set1_pd(1.);</span><br><span class="line">  mones = _mm256_set1_pd(-1.);</span><br><span class="line">  thresholds = _mm256_set1_pd(0.5);</span><br><span class="line">  for(i = 0; i &lt; n; i+=4) &#123;</span><br><span class="line">    vt = _mm256_load_pd(x+i);</span><br><span class="line">    vmask = _mm256_cmp_pd(vt, thresholds, _CMP_GT_OQ);</span><br><span class="line">    vp = _mm256_and_pd(vmask, ones);</span><br><span class="line">    vm = _mm256_andnot_pd(vmask, mones);</span><br><span class="line">    vr = _mm256_add_pd(vt, _mm256_or_pd(vp, vm));</span><br><span class="line">    _mm256_store_pd(x+i, vr);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Convert"><a href="#Convert" class="headerlink" title="Convert"></a>Convert</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Intrinsic Function</th>
<th>Operation</th>
<th>AVX2 Instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>_mm256_cvtepi32_pd</td>
<td>Convert from 32-bit integer</td>
<td>VCVTDQ2PD</td>
</tr>
<tr>
<td>_mm256_cvtepi32_ps</td>
<td>Convert from 32-bit integer</td>
<td>VCVTDQ2PD</td>
</tr>
<tr>
<td>_mm256_cvtpd_epi32</td>
<td>Convert to 32-bit integer</td>
<td>VCVTPD2DQ</td>
</tr>
<tr>
<td>_mm256_cvtps_epi32</td>
<td>Convert to 32-bit integer</td>
<td>VCVTPS2DQ</td>
</tr>
<tr>
<td>_mm256_cvtps_pd</td>
<td>Convert from floats</td>
<td>VCVTPS2PD</td>
</tr>
<tr>
<td>_mm256_cvtpd_ps</td>
<td>Convert to floats</td>
<td>VCVTPD2PS</td>
</tr>
<tr>
<td>_mm256_cvttpd_epi32</td>
<td>Convert to 32-bit integer with truncation</td>
<td>VCVTPD2DQ</td>
</tr>
<tr>
<td>_mm256_cvtsd_f64</td>
<td>Extract</td>
<td>MOVSD</td>
</tr>
<tr>
<td>_mm256_cvtss_f32</td>
<td>Extract</td>
<td>MOVSS</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/img/v2-f184fe55254b04164c53f6e8a0a84561_1440w.webp" alt="img"></p>
<h3 id="Shuffles"><a href="#Shuffles" class="headerlink" title="Shuffles"></a><strong>Shuffles</strong></h3><div class="table-container">
<table>
<thead>
<tr>
<th>Intrinsic Function</th>
<th>Operation</th>
<th>AVX2 Instruction</th>
</tr>
</thead>
<tbody>
<tr>
<td>_mm256_unpackhi_pd</td>
<td>Unpack High</td>
<td>VUNPCKHPD</td>
</tr>
<tr>
<td>_mm256_unpacklo_pd</td>
<td>Unpack Low</td>
<td>VUNPCKLPD</td>
</tr>
<tr>
<td>_mm256_movemask_pd</td>
<td>Create four-bit mask</td>
<td>VMOVMSKPD</td>
</tr>
<tr>
<td>_mm256_movedup_pd</td>
<td>Duplicates</td>
<td>VMOVDDUP</td>
</tr>
<tr>
<td>_mm256_blend_pd</td>
<td>Selects data from 2 sources using constant mask</td>
<td>VBLENDPD</td>
</tr>
<tr>
<td>_mm256_blendv_pd</td>
<td>Selects data from 2 sources using variable mask</td>
<td>VBLENDVPD</td>
</tr>
<tr>
<td>_mm256_insertf128_pd</td>
<td>Insert 128-bit value into packed array elements selected by index.</td>
<td>VINSERTF128</td>
</tr>
<tr>
<td>_mm256_extractf128_pd</td>
<td>Extract 128-bits selected by index.</td>
<td>VEXTRACTF128</td>
</tr>
<tr>
<td>_mm256_shuffle_pd</td>
<td>Shuffle</td>
<td>VSHUFPD</td>
</tr>
<tr>
<td>_mm256_permute_pd</td>
<td>Permute</td>
<td>VPERMILPD</td>
</tr>
<tr>
<td>_mm256_permute4x64_pd</td>
<td>Permute 64-bits elements</td>
<td>VPERMPD</td>
</tr>
<tr>
<td>_mm256_permute2f128_pd</td>
<td>Permute 128-bits elements</td>
<td>VPERM2F128</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/img/v2-7ffb174473ad7b96fcebbc2fddf7678c_1440w.webp" alt="img"></p>
<p><img src="/img/v2-bf61297f49fbcaa226c7e31b9d89b256_1440w.webp" alt="img"></p>
<p>示例代码</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void fcond(double *x, size_t n) &#123;</span><br><span class="line">  int i;</span><br><span class="line">  for(i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    if(x[i] &gt; 0.5)</span><br><span class="line">      x[i] += 1.;</span><br><span class="line">    else </span><br><span class="line">      x[i] -= 1.;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;immintrin.h&gt;</span><br><span class="line">void fcond_vec2(double *x, size_t n) &#123;</span><br><span class="line">  int i;</span><br><span class="line">  __m256d vt, vmask, vp, vm, vr, ones, mones, thresholds;</span><br><span class="line">  ones = _mm256_set1_pd(1.);</span><br><span class="line">  mones = _mm256_set1_pd(-1.);</span><br><span class="line">  thresholds = _mm256_set1_pd(0.5);</span><br><span class="line">  for(i = 0; i &lt; n; i+=4) &#123;</span><br><span class="line">    vt = _mm256_load_pd(x+i);</span><br><span class="line">    vmask = _mm256_cmp_pd(vt, thresholds, _CMP_GT_OQ);</span><br><span class="line">    vb = _mm256_blendv_pd(mones, ones, vmask);</span><br><span class="line">    vr = _mm256_add_pd(vt, vb);</span><br><span class="line">    _mm256_store_pd(x+i, vr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AVX2-Samples"><a href="#AVX2-Samples" class="headerlink" title="AVX2 Samples"></a><strong>AVX2 Samples</strong></h2><p>上一节中，罗列了一堆无聊的 AVX2 指令和对应的 <strong>Intrinsic Function，</strong>下面我们通过一些具体的例子来演示如何<strong>使用Intrinsic Function进行编程。</strong></p>
<h3 id="Gelu"><a href="#Gelu" class="headerlink" title="Gelu"></a>Gelu</h3><p><a href="https://link.zhihu.com/?target=https%3A//www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/nn/GELU_cn.html">Gelu</a> 是一类激活算子，其函数定义如下：</p>
<p><img src="/img/v2-2dc629f6eea019046bb8ceae8a8c1cc8_1440w.webp" alt="img"></p>
<p>注意，Gelu 中包含了一个三角函数 tanh 操作，但是如果不使用Intel c++ compiler，编译器可能不支持相应的 AVX2 指令；因此，为了完成 tanh 和其他的科学计算函数如三角函数、指数等操作，可以使用两种方式来解决</p>
<ol>
<li>直接编写科学计算函数的近似实现，平滑替换；</li>
<li>使用 <a href="https://link.zhihu.com/?target=https%3A//github.com/shibatch/sleef">https://github.com/shibatch/sleef</a> 或者 <a href="https://link.zhihu.com/?target=https%3A//github.com/vectorclass/version2">https://github.com/vectorclass/version2</a> 提供的高效实现；</li>
</ol>
<p>方法 1 在用法上较为方便，省去了学习第三方库的时间成本，但是本质上是一种重复造轮子的行为；方法2 中介绍的两个库也算轻量，并不存在陡峭的学习曲线，十分推荐；不过在本文中，主要目的是介绍 intrinsic function 的使用，所以尽量不调用第三方库。</p>
<p>Tanh 函数的近似实现为</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float fast_tanh(float x) &#123;</span><br><span class="line">  float x2 = x * x;</span><br><span class="line">  float a = x * (135135.0f + x2 * (17325.0f + x2 * (378.0f + x2)));</span><br><span class="line">  float b = 135135.0f + x2 * (62370.0f + x2 * (3150.0f + x2 * 28.0f));</span><br><span class="line">  return a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的实现为</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void _AVX_Gelu(float* dst, const float* src, size_t size) &#123;</span><br><span class="line">  auto var1 = _mm256_set1_ps(0.044715f);</span><br><span class="line">  auto var2 = _mm256_set1_ps(0.79788458f);</span><br><span class="line">  auto var3 = _mm256_set1_ps(378.f);</span><br><span class="line">  auto var4 = _mm256_set1_ps(17325.f);</span><br><span class="line">  auto var5 = _mm256_set1_ps(135135.f);</span><br><span class="line">  auto var6 = _mm256_set1_ps(28.f);</span><br><span class="line">  auto var7 = _mm256_set1_ps(3150.f);</span><br><span class="line">  auto var8 = _mm256_set1_ps(62370.f);</span><br><span class="line">  auto var9 = _mm256_set1_ps(135135.f);</span><br><span class="line">  auto var10 = _mm256_set1_ps(0.5);</span><br><span class="line">  auto varOne = _mm256_set1_ps(1.f);</span><br><span class="line">  auto varNegOne = _mm256_set1_ps(-1.f);</span><br><span class="line"></span><br><span class="line">  for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">    // 计算 x^3</span><br><span class="line">    auto x = _mm256_loadu_ps(src + i * 8);</span><br><span class="line">    auto y = _mm256_mul_ps(x, x);</span><br><span class="line">    y = _mm256_mul_ps(y, x);</span><br><span class="line">    // 计算 0.044715 * x^3</span><br><span class="line">    y = _mm256_mul_ps(y, var1);</span><br><span class="line">    // 计算 0.044715 * x^3 + x</span><br><span class="line">    y = _mm256_add_ps(y, x);</span><br><span class="line">    // 计算 sqrt(2 / PI) * (0.044715 * x^3 + x)</span><br><span class="line">    y = _mm256_mul_ps(y, var2);</span><br><span class="line"></span><br><span class="line">    // y = tanh(y)</span><br><span class="line">    &#123;</span><br><span class="line">      auto y2 = _mm256_mul_ps(y, y);</span><br><span class="line">      auto w = _mm256_add_ps(y2, var3);</span><br><span class="line">      w = _mm256_mul_ps(w, y2);</span><br><span class="line">      w = _mm256_add_ps(w, var4);</span><br><span class="line">      w = _mm256_mul_ps(w, y2);</span><br><span class="line">      w = _mm256_add_ps(w, var5);</span><br><span class="line">      w = _mm256_mul_ps(w, y);</span><br><span class="line">      auto z = _mm256_mul_ps(y2, var6);</span><br><span class="line">      z = _mm256_add_ps(z, var7);</span><br><span class="line">      z = _mm256_mul_ps(z, y2);</span><br><span class="line">      z = _mm256_add_ps(z, var8);</span><br><span class="line">      z = _mm256_mul_ps(z, y2);</span><br><span class="line">      z = _mm256_add_ps(z, var9);</span><br><span class="line">      z = _mm256_div_ps(w, z);</span><br><span class="line">      z = _mm256_max_ps(z, varNegOne);</span><br><span class="line">      y = _mm256_min_ps(z, varOne);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y = _mm256_add_ps(y, varOne);</span><br><span class="line">    y = _mm256_mul_ps(y, x);</span><br><span class="line">    y = _mm256_mul_ps(y, var10);</span><br><span class="line">    _mm256_storeu_ps(dst + i * 8, y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码都十分直白，不言自明。</p>
<h3 id="MatrixAdd"><a href="#MatrixAdd" class="headerlink" title="MatrixAdd"></a>MatrixAdd</h3><p>下面的例子演示了如何使用 intrinsic function 做 col-major 矩阵的加法运算，由于 AVX2 指令集可以一次打包 8 个浮点数运算，所以代码中将 PACK_UNIT 设置为 8。</p>
<p>代码的逻辑十分简单，按行循环遍历，按列打包浮点数运算。出于方便考虑，默认代码中 cols 是8的倍数，可以省去尾数处理的逻辑。显而易见，该实现没有考虑矩阵的规模进行针对性优化，比如运算矩阵和结果矩阵有多大，直接存取会发生多少次cache miss？如何进行循环展开。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define PACK_UNIT 8</span><br><span class="line"></span><br><span class="line">void MatrixAdd(float* C, const float* A, const float* B, const size_t cs,</span><br><span class="line">               const size_t as, const size_t bs, const size_t rows,</span><br><span class="line">               const size_t cols) &#123;</span><br><span class="line">  for (int row = 0; row &lt; rows; ++row) &#123;</span><br><span class="line">    auto a = A + as * row;</span><br><span class="line">    auto b = B + bs * row;</span><br><span class="line">    auto c = C + cs * row;</span><br><span class="line"></span><br><span class="line">    for (int col = 0; col &lt; cols; col += PACK_UNIT) &#123;</span><br><span class="line">      _mm256_storeu_ps(c + PACK_UNIT * col,</span><br><span class="line">                       _mm256_add_ps(_mm256_loadu_ps(b + PACK_UNIT * col),</span><br><span class="line">                                     _mm256_loadu_ps(a + PACK_UNIT * col)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ --std=c++14 -O2 -mavx2 matrixadd.cc -o madd</span><br></pre></td></tr></table></figure>
<h3 id="MatrixTranspose"><a href="#MatrixTranspose" class="headerlink" title="MatrixTranspose"></a>MatrixTranspose</h3><p>以下代码用以演示如何使用 intrinsic function 进行 8 x 8 矩阵的转换，重点在于理解 <strong>mm256_unpacklo_ps 、</strong>mm256_unpackhi_ps 和 __mm256_shuffle_ps 指令的使用。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">void matrixTranspose(float* dst, const float* src) &#123;</span><br><span class="line">  __m256 r0, r1, r2, r3, r4, r5, r6, r7;</span><br><span class="line">  __m256 t0, t1, t2, t3, t4, t5, t6, t7;</span><br><span class="line"></span><br><span class="line">  r0 =_mm256_insertf128_ps(_mm256_castps128_ps256(_mm_load_ps(&amp;src[0 * 8 + 0])),</span><br><span class="line">                            _mm_load_ps(&amp;src[4 * 8 + 0]), 1);</span><br><span class="line">  r1 =_mm256_insertf128_ps(_mm256_castps128_ps256(_mm_load_ps(&amp;src[1 * 8 + 0])),</span><br><span class="line">                            _mm_load_ps(&amp;src[5 * 8 + 0]), 1);</span><br><span class="line">  r2 =_mm256_insertf128_ps(_mm256_castps128_ps256(_mm_load_ps(&amp;src[2 * 8 + 0])),</span><br><span class="line">                            _mm_load_ps(&amp;src[6 * 8 + 0]), 1);</span><br><span class="line">  r3 =_mm256_insertf128_ps(_mm256_castps128_ps256(_mm_load_ps(&amp;src[3 * 8 + 0])),</span><br><span class="line">                            _mm_load_ps(&amp;src[7 * 8 + 0]), 1);</span><br><span class="line">  r4 =_mm256_insertf128_ps(_mm256_castps128_ps256(_mm_load_ps(&amp;src[0 * 8 + 4])),</span><br><span class="line">                            _mm_load_ps(&amp;src[4 * 8 + 4]), 1);</span><br><span class="line">  r5 =_mm256_insertf128_ps(_mm256_castps128_ps256(_mm_load_ps(&amp;src[1 * 8 + 4])),</span><br><span class="line">                            _mm_load_ps(&amp;src[5 * 8 + 4]), 1);</span><br><span class="line">  r6 =_mm256_insertf128_ps(_mm256_castps128_ps256(_mm_load_ps(&amp;src[2 * 8 + 4])),</span><br><span class="line">                            _mm_load_ps(&amp;src[6 * 8 + 4]), 1);</span><br><span class="line">  r7 =_mm256_insertf128_ps(_mm256_castps128_ps256(_mm_load_ps(&amp;src[3 * 8 + 4])),</span><br><span class="line">                            _mm_load_ps(&amp;src[7 * 8 + 4]), 1);</span><br><span class="line"></span><br><span class="line">  t0 = _mm256_unpacklo_ps(r0, r1);</span><br><span class="line">  t1 = _mm256_unpackhi_ps(r0, r1);</span><br><span class="line">  t2 = _mm256_unpacklo_ps(r2, r3);</span><br><span class="line">  t3 = _mm256_unpackhi_ps(r2, r3);</span><br><span class="line">  t4 = _mm256_unpacklo_ps(r4, r5);</span><br><span class="line">  t5 = _mm256_unpackhi_ps(r4, r5);</span><br><span class="line">  t6 = _mm256_unpacklo_ps(r6, r7);</span><br><span class="line">  t7 = _mm256_unpackhi_ps(r6, r7);</span><br><span class="line"></span><br><span class="line">  r0 = _mm256_shuffle_ps(t0, t2, 0x44);</span><br><span class="line">  r1 = _mm256_shuffle_ps(t0, t2, 0xEE);</span><br><span class="line">  r2 = _mm256_shuffle_ps(t1, t3, 0x44);</span><br><span class="line">  r3 = _mm256_shuffle_ps(t1, t3, 0xEE);</span><br><span class="line">  r4 = _mm256_shuffle_ps(t4, t6, 0x44);</span><br><span class="line">  r5 = _mm256_shuffle_ps(t4, t6, 0xEE);</span><br><span class="line">  r6 = _mm256_shuffle_ps(t5, t7, 0x44);</span><br><span class="line">  r7 = _mm256_shuffle_ps(t5, t7, 0xEE);</span><br><span class="line"></span><br><span class="line">  _mm256_store_ps(&amp;dst[0 * 8], r0);</span><br><span class="line">  _mm256_store_ps(&amp;dst[1 * 8], r1);</span><br><span class="line">  _mm256_store_ps(&amp;dst[2 * 8], r2);</span><br><span class="line">  _mm256_store_ps(&amp;dst[3 * 8], r3);</span><br><span class="line">  _mm256_store_ps(&amp;dst[4 * 8], r4);</span><br><span class="line">  _mm256_store_ps(&amp;dst[5 * 8], r5);</span><br><span class="line">  _mm256_store_ps(&amp;dst[6 * 8], r6);</span><br><span class="line">  _mm256_store_ps(&amp;dst[7 * 8], r7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h3><p>softmax 的函数方程并不复杂，实现时关键点在于如何实现 exp ，下面的实现中参考了 <a href="https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/48863719/fastest-implementation-of-exponential-function-using-avx">Fastest Implementation of Exponential Function Using AVX</a> ，可以一起研究下。</p>
<p><img src="/img/v2-9096aea74645d1f6ef698c914d507776_1440w.webp" alt="img"></p>
<p>关于如何快速计算</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">void _AVX_Softmax(float* dest, const float* source, size_t size) &#123;</span><br><span class="line">  float tmpfloat8[8];</span><br><span class="line">  int count = size / 8;</span><br><span class="line"></span><br><span class="line">  // step 1: get maxValue</span><br><span class="line">  float maxValue = source[0];</span><br><span class="line">  if (count &gt; 0) &#123;</span><br><span class="line">    auto maxVal = _mm256_loadu_ps(source);</span><br><span class="line">    for (int i = 1; i &lt; count; i++) &#123;</span><br><span class="line">      maxVal = _mm256_max_ps(maxVal, _mm256_loadu_ps(source + i * 8));</span><br><span class="line">    &#125;</span><br><span class="line">    _mm256_storeu_ps(tmpfloat8, maxVal);</span><br><span class="line">    maxValue = tmpfloat8[0] &gt; tmpfloat8[1] ? tmpfloat8[0] : tmpfloat8[1];</span><br><span class="line">    for (int i = 2; i &lt; 8; i++) &#123;</span><br><span class="line">      maxValue = maxValue &gt; tmpfloat8[i] ? maxValue : tmpfloat8[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // step 2: get exp(x - maxValue) and sum(exp(x - maxValue))</span><br><span class="line">  float sumValue = 0.f;</span><br><span class="line">  if (count &gt; 0) &#123;</span><br><span class="line">    auto sumVal = _mm256_set1_ps(0.f);</span><br><span class="line">    auto p0 = _mm256_set1_ps(0.6931471805599453);</span><br><span class="line">    auto p1 = _mm256_set1_ps(1.4426950408889634);</span><br><span class="line">    auto p2 = _mm256_set1_ps(1.f);</span><br><span class="line">    auto p3 = _mm256_set1_ps(1.f);</span><br><span class="line">    auto p4 = _mm256_set1_ps(0.5);</span><br><span class="line">    auto p5 = _mm256_set1_ps(0.1666666666666666);</span><br><span class="line">    auto p6 = _mm256_set1_ps(0.041666666666666664);</span><br><span class="line">    auto p7 = _mm256_set1_ps(0.008333333333333333);</span><br><span class="line">    auto xMax = _mm256_set1_ps(87);</span><br><span class="line">    auto xMin = _mm256_set1_ps(-87);</span><br><span class="line">    auto basic = _mm256_set1_epi32(1 &lt;&lt; 23);</span><br><span class="line">    auto temp127 = _mm256_set1_epi32(127);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">      auto x = _mm256_sub_ps(_mm256_loadu_ps(source + i * 8),</span><br><span class="line">                             _mm256_set1_ps(maxValue));</span><br><span class="line">      x = _mm256_max_ps(x, xMin);</span><br><span class="line">      x = _mm256_min_ps(x, xMax);</span><br><span class="line">      auto div = _mm256_mul_ps(x, p1);</span><br><span class="line">      auto divInt = _mm256_cvtps_epi32(div);</span><br><span class="line">      div = _mm256_cvtepi32_ps(divInt);</span><br><span class="line">      auto div2 = _mm256_add_epi32(divInt, temp127);</span><br><span class="line">      div2 = _mm256_mullo_epi32(div2, basic);</span><br><span class="line">      auto expBasic = _mm256_castsi256_ps(div2);</span><br><span class="line">      auto xReamin = _mm256_sub_ps(x, _mm256_mul_ps(div, p0));</span><br><span class="line">      auto t = xReamin;</span><br><span class="line">      auto c0 = _mm256_mul_ps(p7, t);</span><br><span class="line">      auto c1 = _mm256_add_ps(c0, p6);</span><br><span class="line">      auto c2 = _mm256_mul_ps(c1, t);</span><br><span class="line">      auto c3 = _mm256_add_ps(c2, p5);</span><br><span class="line">      auto c4 = _mm256_mul_ps(c3, t);</span><br><span class="line">      auto c5 = _mm256_add_ps(c4, p4);</span><br><span class="line">      auto c6 = _mm256_mul_ps(c5, t);</span><br><span class="line">      auto c7 = _mm256_add_ps(c6, p3);</span><br><span class="line">      auto c8 = _mm256_mul_ps(c7, t);</span><br><span class="line">      auto c9 = _mm256_add_ps(c8, p2);</span><br><span class="line">      auto expRemain = c9;</span><br><span class="line">      auto expRes = _mm256_mul_ps(expBasic, expRemain);</span><br><span class="line">      sumVal = _mm256_add_ps(expRes, sumVal);</span><br><span class="line">      _mm256_storeu_ps(dest + 8 * i, expRes);</span><br><span class="line">    &#125;</span><br><span class="line">    _mm256_storeu_ps(tmpfloat8, sumVal);</span><br><span class="line">    for (int i = 0; i &lt; 8; i++) &#123;</span><br><span class="line">      sumValue += tmpfloat8[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  auto param = 0.6931471805599453;</span><br><span class="line">  float xLimit = 87;</span><br><span class="line"></span><br><span class="line">  // step 3: get x / sum and store</span><br><span class="line">  for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">    // using  1 / ((1 / x) * sum) instead x * (1 / sum) or x / sum for some bugs</span><br><span class="line">    // in intel cpu</span><br><span class="line">    auto x = _mm256_rcp_ps(_mm256_loadu_ps(dest + 8 * i));</span><br><span class="line">    auto y = _mm256_set1_ps(sumValue);</span><br><span class="line">    auto z = _mm256_rcp_ps(_mm256_mul_ps(x, y));</span><br><span class="line">    _mm256_storeu_ps(dest + 8 * i, z);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文介绍的内容和示例终究是小打小闹，真正有价值的工作还是在GEMM和Conv 这类计算密集型的热点算子上做出深度优化。后面有计划再介绍vectorclass 和 xbyak ，然后通过深度学习推理框架中GEMM算子为例来演示如何进行分块、打包、寄存器优化等技术。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/03/07/Intel_TBB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/07/Intel_TBB/" itemprop="url">Intel Thread Building Blocks (TBB)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-03-07T22:51:00+08:00">
                2022-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在多核的平台上开发并行化的程序，必须合理地利用系统的资源 - 如与内核数目相匹配的线程，内存的合理访问次序，最大化重用缓存。有时候用户使用(系统)低级的应用接口创建、管理线程，很难保证是否程序处于最佳状态。 </p>
<p>Intel Thread Building Blocks (TBB) 很好地解决了上述问题： </p>
<ul>
<li>TBB提供C++模版库，用户不必关注线程，而专注任务本身。 </li>
<li>抽象层仅需很少的接口代码，性能上毫不逊色。 </li>
<li>灵活地适合不同的多核平台。 </li>
<li>线程库的接口适合于跨平台的移植(Linux, Windows, Mac) </li>
<li>支持的C++编译器 – Microsoft, GNU and Intel  </li>
</ul>
<p>主要的功能：</p>
<ul>
<li>通用的并行算法 <ul>
<li>循环的并行： <ul>
<li>parallel_for, parallel_reduce – 相对独立的循环层 </li>
<li>parallel_scan – 依赖于上一层的结果 </li>
</ul>
</li>
</ul>
</li>
<li>流的并行算法 <ul>
<li>parallel_while – 用于非结构化的流或堆 </li>
<li>pipeline - 对流水线的每一阶段并行，有效使用缓存 </li>
</ul>
</li>
<li>并行排序 <ul>
<li>parallel_sort – 并行快速排序，调用了parallel_for </li>
</ul>
</li>
<li>任务调度者 <ul>
<li>管理线程池，及隐藏本地线程复杂度 </li>
<li>并行算法的实现由任务调度者的接口完成 </li>
<li>任务调度者的设计考虑到本地线程的并行所引起的性能问题 </li>
</ul>
</li>
<li>并行容器 <ul>
<li>concurrent_hash_map </li>
<li>concurrent_vector </li>
<li>concurrent_queue </li>
</ul>
</li>
<li>同步原语 <ul>
<li>atomic </li>
<li>mutex </li>
<li>spin_mutex – 适合于较小的敏感区域 </li>
<li>queuing_mutex – 线程按次序等待(获得)一个锁 </li>
<li>spin_rw_mutex </li>
<li>queuing_rw_mutex </li>
</ul>
</li>
<li>高性能的内存申请 <ul>
<li>使用TBB的allocator 代替 C语言的 malloc/realloc/free 调用 </li>
<li>使用TBB的allocator 代替 C++语言的 new/delete 操作 </li>
</ul>
</li>
</ul>
<h1 id="术语与基本概念"><a href="#术语与基本概念" class="headerlink" title="术语与基本概念"></a>术语与基本概念</h1><h2 id="分割（splitable-concept）："><a href="#分割（splitable-concept）：" class="headerlink" title="分割（splitable concept）："></a>分割（splitable concept）：</h2><p>包含一个分割构造函数的类型是可分割的。分割构造函数原型为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X::X(X&amp; obj, Split)</span><br></pre></td></tr></table></figure></p>
<p>能将实例obj分割为obj以及一个新构造的对象。其中的Split是一个哑元参数，在tbb_stddef.h中的有其定义（一个空类）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class split &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>TBB将在以下情况使用分割构造：</p>
<ul>
<li>将一个区域（range）分为两个子区域（subrange）以便并行处理</li>
<li>将一个主体（body，即函数对象）分为两个主体以便并行处理 </li>
</ul>
<h2 id="区域（range-concept）"><a href="#区域（range-concept）" class="headerlink" title="区域（range concept）"></a>区域（range concept）</h2><p>描述了一种集合类型的需求，这种集合可被递归分割。区域类型R必须满足以下需求： </p>
<ul>
<li><code>R::R(const R&amp; )</code>：构造函数</li>
<li><code>R::~R()</code>：析构函数</li>
<li><code>bool R::empty() const</code>：区域为空返回ture</li>
<li><code>bool R::is_divisible() const</code>：如果区域可再分，返回ture</li>
<li><code>R::R(R&amp; r, split)</code>：将r分为两个子区域</li>
</ul>
<p>TBB内置了三种区域模板：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typenameValue&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">blocked_range</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;typenameRowValue, <span class="keyword">typename</span> ColValue&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">blocked_range2d</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;typenamePageValue, <span class="keyword">typename</span> RowValue, <span class="keyword">typename</span> ColValue&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">blocked_range3d</span>; </span><br></pre></td></tr></table></figure></p>
<p><code>blocked_range&lt;Value&gt;</code>描述了一个能被递归分割的半开放区域[I,j)。 </p>
<h2 id="分割器（partitioner）："><a href="#分割器（partitioner）：" class="headerlink" title="分割器（partitioner）："></a>分割器（partitioner）：</h2><p>指定了循环模板将其任务分割后分配给各个线程的方式。循环模板（如parallel_for、parallel_reduce、parallel_scan）的默认行为只是尽量递归将区域分割以使所有的处理器处于繁忙状态，不一定分割的尽可能合适。如下表所示，可选的分割器参数允许指定其他的行为： </p>
<ul>
<li><code>const auto_partitioner&amp;</code>：按负载平衡进行分割，而不是真正依照Range::is_divisible的许可。当与类（比如blocked_range）一起使用时，选择一个合适的粒度也很重要。常规可接受的性能可以通过尺寸为1的默认粒度来达到。</li>
<li><code>affinity_partitioner&amp;</code>：与auto_partitioner类似，但通过选择映射子区域到工作线程提高缓存的亲缘性。当一个循环体在一个相同的数据集再次执行并且该数据集与缓存相符时，能显著提高性能。</li>
<li><code>const simple_partitioner&amp;</code>：递归分割一个区域，直到不能再分。何时终止递归分割由函数Range：：is_devisible完全决定。当与blocked_range等类一起使用时，选择合适的可并发粒度在限制开销方面至关重要。</li>
</ul>
<h1 id="基本算法参考及使用"><a href="#基本算法参考及使用" class="headerlink" title="基本算法参考及使用"></a>基本算法参考及使用</h1><h2 id="基本算法（algorithms）"><a href="#基本算法（algorithms）" class="headerlink" title="基本算法（algorithms）"></a>基本算法（algorithms）</h2><p>Intel TBB提供的大多数并行算法支持泛型。但是这些受支持的类型必须实现必要的概念方法。并行算法可以嵌套，例如，一个<code>parallel_for</code>的内部可以调用另一个<code>parallel_for</code>。目前版本的TBB（4.0）提供的基本算法如下所示：</p>
<ul>
<li>parallel_for</li>
<li>parallel_reduce</li>
<li>parallel_scan</li>
<li>parallel_do</li>
<li>管道(pipeline、parallel_pipeline)</li>
<li>parallel_sort</li>
<li>parallel_invoke</li>
</ul>
<h3 id="parallel-for"><a href="#parallel-for" class="headerlink" title="parallel_for"></a>parallel_for</h3><p>parallel_for是在一个值域执行并行迭代操作的模板函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;typenameIndex, <span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">Func <span class="title">parallel_for</span><span class="params">( Index first, Index_type last, <span class="type">const</span> Func&amp; f</span></span></span><br><span class="line"><span class="params"><span class="function">                  [, task_group_context&amp;group] )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;typenameIndex, <span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">Func <span class="title">parallel_for</span><span class="params">( Index first, Index_type last, </span></span></span><br><span class="line"><span class="params"><span class="function">                  Index step, <span class="type">const</span> Func&amp;f</span></span></span><br><span class="line"><span class="params"><span class="function">                  [, task_group_context&amp;group] )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;typenameRange, <span class="keyword">typename</span> Body&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_for</span><span class="params">( <span class="type">const</span> Range&amp; range, <span class="type">const</span> Body&amp; body, </span></span></span><br><span class="line"><span class="params"><span class="function">                  [, partitioner[,task_group_context&amp; group]] )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>头文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “tbb/parallel_for.h”</span></span><br></pre></td></tr></table></figure></p>
<p><code>parallel_for(first, last,step, f)</code>表示一个循环的并行执行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i= first; i&lt;last; i+=step) <span class="built_in">f</span>(i);</span><br></pre></td></tr></table></figure></p>
<p>注意以下几点：</p>
<ol>
<li>索引类型必须是整形</li>
<li>循环不能回环</li>
<li>步长（step）必须为正，如果省略了，隐指为1</li>
<li>并没有保证迭代操作以并行方式进行</li>
<li>较小的迭代等待更大的迭代可能会发生死锁</li>
<li>分割策略总是auto_partitioner</li>
</ol>
<p><code>parallel_for(range, body, partitioner)</code>提供了并行迭代的泛型形式。它表示在区域的每个值，并行执行<code>body</code>。<code>partitioner</code>选项指定了分割策略。Range类型必须符合Range概念模型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tbb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/blocked_range.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_for.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt;::iterator IntVecIt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">body</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> blocked_range&lt;IntVecIt&gt;&amp;r)</span><span class="type">const</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> i = r.<span class="built_in">begin</span>(); i!=r.<span class="built_in">end</span>(); i++)</span><br><span class="line">         cout&lt;&lt;*i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">      vec.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt; IntVecIt&gt;(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>())</span><br><span class="line">      , <span class="built_in">body</span>());</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="parallel-reduce"><a href="#parallel-reduce" class="headerlink" title="parallel_reduce"></a>parallel_reduce</h3><p>parallel_reduce模板在一个区域迭代，将由各个任务计算得到的部分结果合并，得到最终结果。</p>
<p>parallel_reduce对区域（range）类型的要求与parallel_for一样。body类型需要分割构造函数以及一个join方法。body的分割构造函数拷贝运行循环体需要的只读数据，并分配并归操作中初始化并归变量的标志元素。join方法会组合并归操作中各任务的结果。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;typenameRange, <span class="keyword">typename</span> Value, </span></span><br><span class="line"><span class="function">        <span class="keyword">typename</span> Func, <span class="keyword">typename</span> Reduction&gt;</span></span><br><span class="line"><span class="function">Value <span class="title">parallel_reduce</span><span class="params">(<span class="type">const</span> Range&amp; range, <span class="type">const</span> Value&amp; identity,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> Func&amp; func,<span class="type">const</span> Reduction&amp; reduction,</span></span></span><br><span class="line"><span class="params"><span class="function">                    [, partitioner[,task_group_context&amp; group]] )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;typenameRange, <span class="keyword">typename</span> Body&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_reduce</span><span class="params">(<span class="type">const</span> Range&amp; range, <span class="type">const</span> Body&amp; body</span></span></span><br><span class="line"><span class="params"><span class="function">                     [, partitioner[,task_group_context&amp; group]] )</span></span>;</span><br></pre></td></tr></table></figure>
<p>头文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “tbb/parallel_reduce.h”</span></span><br></pre></td></tr></table></figure></p>
<p>parallel_reduce模板有两种形式。函数形式是为方便与lambda表达式一起使用而设计。第二种形式是为了最小化数据拷贝。下面总结了第一种形式中的identity,func,reduction的类型要求要求：</p>
<ul>
<li><code>Value Identity</code>：<code>Func::operator()</code>的左标识元素</li>
<li><code>Value Func::operator()(const Range&amp; range, const Value&amp; x)</code>：累计从初始值x开始的子区域的结果</li>
<li><code>Value Reduction::operator()(const Value&amp; x, const Value&amp; y);</code>：合并x跟y的结果</li>
</ul>
<p>parallel_reduce使用分割构造函数来为每个线程生成一个或多个body的拷贝。当它拷贝body的时候，也许body的<code>operator()</code>或者<code>join()</code>正在并发运行。要确保这种并发运行下的安全。典型应用中，这种安全要求不会消耗你太多的精力。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_reduce.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/blocked_range.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">      vec.<span class="built_in">push_back</span>(i);</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">parallel_reduce</span>(blocked_range&lt;vector&lt;<span class="type">int</span>&gt;::iterator&gt;(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()),</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        [](<span class="type">const</span> blocked_range&lt;vector&lt;<span class="type">int</span>&gt;::iterator&gt;&amp; r, <span class="type">int</span> init)-&gt;<span class="type">int</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> a = r.<span class="built_in">begin</span>(); a!=r.<span class="built_in">end</span>(); a++)</span><br><span class="line">                init+=*a;</span><br><span class="line">            <span class="keyword">return</span> init;</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        [](<span class="type">int</span> x, <span class="type">int</span> y)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x+y;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;result:&quot;</span>&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> n = <span class="number">1</span>&lt;&lt;<span class="number">26</span>;</span><br><span class="line">    <span class="type">float</span> res = tbb::<span class="built_in">parallel_reduce</span>(tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n), (<span class="type">float</span>)<span class="number">0</span>,</span><br><span class="line">    [&amp;] (tbb::blocked_range&lt;<span class="type">size_t</span>&gt; r, <span class="type">float</span> local_res) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">            local_res += std::<span class="built_in">sin</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> local_res;</span><br><span class="line">    &#125;, [] (<span class="type">float</span> x, <span class="type">float</span> y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="parallel-scan"><a href="#parallel-scan" class="headerlink" title="parallel_scan"></a>parallel_scan</h3><p>并行计算前束（prefix）的函数模板。即输入一个数组，生成一个数组，其中每个元素的值都是原数组中在此元素之前的元素的某个运算符的结果的累积。比如求和：输入：[2, 8,  9, -4,  1, 3, -2,  7]，生成：[0, 2, 10, 19, 15, 16, 19, 17]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_scan</span><span class="params">( <span class="type">const</span> Range&amp; range, Body&amp; body )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_scan</span><span class="params">( <span class="type">const</span> Range&amp; range, Body&amp; body, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">    auto_partitioner&amp; )</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Range, <span class="keyword">typename</span> Body&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_scan</span><span class="params">( <span class="type">const</span> Range&amp; range, Body&amp; body, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">simple_partitioner&amp; )</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> “tbb/parallel_scan.h”</span></span><br></pre></td></tr></table></figure>
<p><code>parallel_scan&lt;Range,Body&gt;</code>以泛型形式实现并行前束。它的要求如下：</p>
<ul>
<li><code>void Body::operator()(const Range&amp; r, pre_scan tag)</code>：累积归纳区域r</li>
<li>·void Body::operator()(const Range&amp; r, final_scan tag)`：归纳区域r以及计算扫描结果</li>
<li><code>Body::Body(Body&amp; b, split)</code>：分割b以便this和b能被单独累积归纳。*this对象即本表下行的对象a</li>
<li><code>void Body::reverse_join(Body&amp; a)</code>：将a的归纳结果合并到this，this是先前从a的分割构造函数中创建的。*this对象即本表上一行中的对象b</li>
<li><code>void Body::assign(Body&amp; b)</code>：将b的归纳结果赋给this</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_scan.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/blocked_range.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Body</span></span><br><span class="line">&#123;</span><br><span class="line">    T _sum;</span><br><span class="line">    T* <span class="type">const</span> _y;</span><br><span class="line">    <span class="type">const</span> T* <span class="type">const</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Body</span>(T y[], <span class="type">const</span> T x[]):_sum(<span class="number">0</span>), _x(x), _y(y)&#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">get_sum</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _sum;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tag&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> blocked_range&lt;<span class="type">int</span>&gt;&amp; r, Tag)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T temp = _sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i&lt; r.<span class="built_in">end</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp+=_x[i];</span><br><span class="line">            <span class="keyword">if</span>(Tag::<span class="built_in">is_final_scan</span>())</span><br><span class="line">                _y[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        _sum = temp;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">Body</span>(Body&amp;b, split):_x(b._x), _y(b._y), _sum(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse_join</span><span class="params">(Body&amp; a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _sum+=a._sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">assign</span><span class="params">(Body&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _sum = b._sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> y[<span class="number">10</span>];</span><br><span class="line">    <span class="function">Body&lt;<span class="type">int</span>&gt; <span class="title">body</span><span class="params">(y,x)</span></span>;</span><br><span class="line">    <span class="built_in">parallel_scan</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, <span class="number">10</span>), body);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sum:&quot;</span>&lt;&lt;body.<span class="built_in">get_sum</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> n = <span class="number">1</span>&lt;&lt;<span class="number">26</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">float</span> res = tbb::<span class="built_in">parallel_scan</span>(tbb::<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n), (<span class="type">float</span>)<span class="number">0</span>,</span><br><span class="line">    [&amp;] (tbb::blocked_range&lt;<span class="type">size_t</span>&gt; r, <span class="type">float</span> local_res, <span class="keyword">auto</span> is_final) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">            local_res += std::<span class="built_in">sin</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (is_final) &#123;</span><br><span class="line">                a[i] = local_res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> local_res;</span><br><span class="line">    &#125;, [] (<span class="type">float</span> x, <span class="type">float</span> y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; a[n / <span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="parallel-do"><a href="#parallel-do" class="headerlink" title="parallel_do"></a>parallel_do</h3><p>并行处理工作项的模板函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Body&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallel_do</span><span class="params">( InputIterator first, InputIteratorlast,</span></span></span><br><span class="line"><span class="params"><span class="function">    Body body[,task_group_context&amp; group] )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/parallel_do.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><code>parallel_do(first, last,body)</code>在对处于半开放区间[first, last)的元素应用函数对象body（不见得并行运行）。如果body重载的()函数的第二个参数（类型为<code>parallel_do_feeder</code>）不为空，那么可以增加另外的工作项。当对输入队列或者通过<code>parallel_do_feeder::add</code>方法添加的所有项x执行的<code>body(x)</code>都返回后，函数结束。其中的<code>parallel_do_feeder</code>允许<code>parallel_do</code>的<code>body</code>添加额外的工作项，只有<code>parallel_do</code>才能创建或者销毁<code>parallel_do_feeder</code>对象。其他的代码对<code>parallel_do_feeder</code>唯一能做的事就是调用它的add方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/parallel_do.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">t_test</span></span><br><span class="line">&#123;</span><br><span class="line">       string msg;</span><br><span class="line">       <span class="type">int</span> ref;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           cout&lt;&lt;msg&lt;&lt;endl;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">body_test</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* t, parallel_do_feeder&lt;T*&gt;&amp; feeder)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">              (*t)();</span><br><span class="line">              <span class="keyword">if</span>(t-&gt;ref == <span class="number">0</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                   t-&gt;msg = <span class="string">&quot;added msg&quot;</span>;</span><br><span class="line">                   feeder.<span class="built_in">add</span>(t);</span><br><span class="line">                   t-&gt;ref++;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;    </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       t_test *pt = <span class="keyword">new</span> t_test;</span><br><span class="line">       pt-&gt;ref = <span class="number">0</span>;</span><br><span class="line">       pt-&gt;msg = <span class="string">&quot;original msg&quot;</span>;</span><br><span class="line"> </span><br><span class="line">       vector&lt;t_test*&gt; vec;</span><br><span class="line">       vec.<span class="built_in">push_back</span>(pt);</span><br><span class="line">       <span class="built_in">parallel_do</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">body_test</span>&lt;t_test&gt;());</span><br><span class="line">       <span class="keyword">delete</span> pt;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pipleline"><a href="#pipleline" class="headerlink" title="pipleline"></a>pipleline</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">pipeline</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">pipeline</span>();</span><br><span class="line">    ~<span class="built_in">pipeline</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_filter</span><span class="params">( filter&amp; f )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">( <span class="type">size_t</span> max_number_of_live_tokens</span></span></span><br><span class="line"><span class="params"><span class="function">                        [,task_group_context&amp; group] )</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可按以下步骤使用pipeline类：</p>
<ol>
<li>从filter继承类f，f的构造函数传递给基类filter的构造函数一个参数，来指定它的模式</li>
<li>重载虚方法<code>filter::operator()</code>来实现过滤器对元素处理，并返回一个将被下一个过滤器处理的元素指针。如果流里没有其他的要处理的元素，返回空值。最后一个过滤器的返回值将被忽略。</li>
<li>生成pipeline类的实例</li>
<li>生成过滤器f的实例，并将它们按先后顺序加给pipeline。一个过滤器的实例一次只能加给一个pipeline。同一时间，一个过滤器禁止成为多个pipeline的成员。</li>
<li>调用pipeline::run方法。参数max_number_of_live_tokens指定了能并发运行的阶段数量上限。较高的值会以更多的内存消耗为代价来增加并发性。 </li>
</ol>
<p>函数<code>parallel_pipeline</code>提供了一种强类型的面向lambda的方式来建立并运行管道。 </p>
<p>过滤器基类filter<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">filter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">mode</span></span><br><span class="line">    &#123;</span><br><span class="line">        parallel = implementation-defined,</span><br><span class="line">        serial_in_order = implementation-defined,</span><br><span class="line">        serial_out_of_order =implementation-defined</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_serial</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_ordered</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="type">void</span>* item )</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">finalize</span><span class="params">( <span class="type">void</span>* item )</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">filter</span>();</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">filter</span>( mode );</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>过滤器模式有三种模式：parallel，serial_in_order,serial_out_of_order</p>
<ul>
<li>parallel过滤器能不按特定的顺序并行处理多个工作项</li>
<li>serial_out_of_order过滤器不按特定的顺序每次处理一个工作项</li>
<li>serial_in_order过滤器每次处理一个工作项。管道中的所有serial_in_order过滤器都按同样的顺序处理工作项。</li>
</ul>
<p>由于parallel过滤器支持并行加速，所以推荐使用。如果必须使用serial过滤器，那么serial_out_of_order类型的过滤器是优先考虑的，因为他在处理顺序上的约束较少。</p>
<h3 id="线程绑定过滤器thread-bound-filter"><a href="#线程绑定过滤器thread-bound-filter" class="headerlink" title="线程绑定过滤器thread_bound_filter"></a>线程绑定过滤器thread_bound_filter</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">thread_bound_filter</span>: <span class="keyword">public</span> filter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">thread_bound_filter</span>(mode filter_mode);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">result_type</span></span><br><span class="line">    &#123;</span><br><span class="line">        success,</span><br><span class="line">        item_not_available,</span><br><span class="line">        end_of_stream</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">result_type <span class="title">try_process_item</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">result_type <span class="title">process_item</span><span class="params">()</span></span>;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>管道中过滤器的抽象基类，线程必须显式为其提供服务。当一个过滤器必须由某个指定线程执行的时候会派上用场。服务于<code>thread_bound_filter</code>的线程不能是调用<code>pipeline::run()</code>的线程。 </p>
<p>example:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/pipeline.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tbb/compat/thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tbb/task_scheduler_init.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> namespacestd;</span><br><span class="line"><span class="keyword">using</span> namespacetbb;</span><br><span class="line"><span class="type">char</span> input[] =<span class="string">&quot;abcdefg\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">inputfilter</span>:<span class="keyword">public</span> filter</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;input:&quot;</span>&lt;&lt;*_ptr&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> _ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">inputfilter</span>():<span class="built_in">filter</span>(serial_in_order),_ptr(input)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">outputfilter</span>: <span class="keyword">public</span> thread_bound_filter</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">void</span> *item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;*(<span class="type">char</span>*)item;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="built_in">outputfilter</span>():<span class="built_in">thread_bound_filter</span>(serial_in_order)&#123;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run_pipeline</span><span class="params">(pipeline *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">run</span>(<span class="number">8</span>);</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inputfilter inf;</span><br><span class="line">    outputfilter ouf;</span><br><span class="line">    pipeline p;</span><br><span class="line">    p.<span class="built_in">add_filter</span>(inf);</span><br><span class="line">    p.<span class="built_in">add_filter</span>(ouf);</span><br><span class="line">     <span class="comment">//由于主线程服务于继承自thread_bound_filter的outputfilter，所以pipeline要运行在另一个单独的线程</span></span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(run_pipeline, &amp;p)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(ouf.<span class="built_in">process_item</span>()!=thread_bound_filter::end_of_stream)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="简单循环的并行化"><a href="#简单循环的并行化" class="headerlink" title="简单循环的并行化"></a>简单循环的并行化</h1><p>假设你想要对某个数组的所有元素都应用函数 Foo，并且能安全地同时处理。先列出来串行化的代码版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SerialApplyFoo</span><span class="params">( <span class="type">float</span> a[], <span class="type">size_t</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">size_t</span> i=<span class="number">0</span>; i!=n; ++i ) </span><br><span class="line">        <span class="built_in">Foo</span>(a[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>迭代空间的类型为 size_t ，范围从0到 n-1 。模板函数<code>tbb::parallel_for</code>会将此迭代空间打散为一些块（chunk），在每个块上运行一个独立的线程。将此循环并行化的第一个步骤是将此循环体转变成对块的操作的形式。这种形式是一种STL风格的函数对象，叫做实体对象（body object），其中 operator() 处理一个块。下面的代码声明了这个实体对象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplyFoo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> *<span class="type">const</span> my_a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">float</span> *a = my_a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)  <span class="built_in">Foo</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ApplyFoo</span>(<span class="type">float</span> a[]) : <span class="built_in">my_a</span>(a)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p>
<p>例子中的 using 指令可以使你在使用 tbb 中定义的数据时不需要每次都加上 tbb 前缀。后面的例子都假定提供了这么个 using 指令。</p>
<p>注意<code>operator()</code>的参数。<code>blocked_range&lt;T&gt;</code>是intel tbb 库提供的一个模板类。它以类型<code>T</code>上声明了一个一维迭代空间。<code>parallel_for</code>也能接受其他类型的迭代空间。Intel TBB 库为二维空间提供了<code>blocked_range2d</code>。</p>
<p>ApplyFoo 的实例需要成员变量来记住所有在初始循环的外部定义却在内部使用的局部变量。由于parallel_for 并不在意实体对象的创建方式，这些成员变量通常由实体对象的构造函数初始化。模板函数parallel_for 要求实体对象有拷贝构造函数，通过调用它为每个工作者线程创建隔离的拷贝。它也通过调用析构函数来销毁这些拷贝。在大多数情况下，隐式产生的拷贝构造函数与析构函数就够用了。如果不满足需求，那么为了一致性，你就要同时定义两者。</p>
<p>因为实体对象可能被拷贝，它的<code>operator()</code>就不能修改实体。否则，这些改动对于调用<code>parallel_for</code>的线程可见与否依赖于<code>operator()</code>执行是在原始对象还是在拷贝对象上。为了凸显这点小差别，<code>parallel_for</code>要求实体对象的<code>operator ()</code>声明为 const.</p>
<p>示例的<code>operator()</code>将<code>my_a</code>加载到局部变量<code>a</code>。</p>
<p>一旦你将循环体写成了实体对象，使用下面的方式调用模板方法<code>parallel_for</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParallelApplyFoo</span><span class="params">(<span class="type">float</span> a[], <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n), <span class="built_in">ApplyFoo</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里构造的<code>blocked_range</code>代表了从 0 到 n -1 的整个迭代区域。<code>parallel_for</code>会将此区域为每个处理器分出子区域。构造函数的一般形式是<code>blocked_range&lt;T&gt;(begin, end, grainsize)</code>。 T 指定了值的类型。 参数 begin 和 end 规定半开放区间<code>[begin,end)</code>作为该迭代区域的STL样式。参数 grainsize 后面会提到。例子使用默认的 grainsize值（1），因为默认情况下， parallel_for的启发式算法能在默认粒度下很好的工作。</p>
<p>采用lambda表达式，上面的例子可以写为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>( disable: 588)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParallelApplyFoo</span><span class="params">(<span class="type">float</span> *a, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n),</span><br><span class="line">        [=](<span class="type">const</span> blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)  </span><br><span class="line">                <span class="built_in">Foo</span>(a[i]);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了更紧凑，对于在一个整形的连续区域执行并行循环，TBB有对应形式的<code>parallel_for</code>。表达式<code>parallel_for(first,last,step,f)</code>就像<code>for(auto i = first; i&lt; last; i+= step) f(i)</code>，只是在资源许可的情况下，每个<code>f(i)</code>可以并行求值。参数 step 是可选的。前面的例子可以重写为如下紧凑形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable: 588)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParallelApplyFoo</span><span class="params">(<span class="type">float</span> a[], <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">parallel_for</span>(<span class="built_in">size_t</span>(<span class="number">0</span>), n, [=](<span class="type">size_t</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Foo</span>(a[i]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>紧凑形式只能支持整形的线性迭代空间。自动分块特性将在下面介绍。</p>
<h2 id="自动分块"><a href="#自动分块" class="headerlink" title="自动分块"></a>自动分块</h2><p>并行循环的构造导致它调度工作的每个分块额外的开销。从2.2 版本开始，Intel TBB 视负载平衡所需自动选择分块尺寸。TBB采用的启发式算法会限制开销，同时为负载均衡提供足够的可选项。</p>
<p>注意：典型地，一个至少需要100万个时钟周期的循环才能使用parallel_for来提高性能。例如，在一个2GHz的处理器上需要500微秒的循环是可以从parallel_for 受益的。</p>
<p>对于大部分应用，推荐使用默认的自动分块。然而，伴随大多数启发式算法，总有一些更精确地控制块的尺寸会产生更好性能的情况。下一节会解释。</p>
<h2 id="控制分块"><a href="#控制分块" class="headerlink" title="控制分块"></a>控制分块</h2><p>分块是通过分区（partitioner）和粒度（grainsize）控制的。为了分块时获得最大的控制权，两者都需要指定。</p>
<ul>
<li>指定<code>simple_partitioner()</code>作为<code>parallel_for</code>的第三个参数。关闭自动分块。</li>
</ul>
<p>指定构造区间时的粒度。这里讨论的构造形式为：<code>blocked_range&lt;T&gt;(begin,end,grainsize)</code>。<code>grainsize</code>的默认值为1，它是每个块的循环迭代的单位。如果块太小，间接的开销可能更甚于有用的工作。</p>
<p>上节的例子修改为使用显式的粒度 G ：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParallelApplyFoo</span><span class="params">( <span class="type">float</span> a[], <span class="type">size_t</span> n )</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>,n,G), <span class="built_in">ApplyFoo</span>(a),  </span><br><span class="line">                 <span class="built_in">simple_partitioner</span>()); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<p>粒度为并行设置了最低门槛。例子中的<code>parallel_for</code>在块上（大小不见得一样）调用<code>ApplyFoo::operator()</code>。让块尺寸作为在块上迭代的数量。使用<code>simple_partitioner</code>确保<code>[G/2] &lt;= chunksize &lt;= G</code>。</p>
<p>使用<code>auto_partitioner</code>、<code>affinity_partitioner</code>时，可以仅为区间（range）指定粒度，这是一种中等级别的控制。<code>auto_partitioner</code>是默认的分区器。两个分区器都实现了“自动分块”一节中描述的自动粒度启发式算法。<code>affinity_partitioner</code>实现了额外的窍门（在下面的“带宽与缓存亲缘性”一节中解释）。虽然这些分区器可能导致超出 G  迭代数量的块，但不会产生少于 [G/2] 迭代的块。分区器在启发式算法失败时会产生浪费性的小块，虽然偶然，但显式指定区间粒度会很有用。</p>
<h2 id="带宽与缓存（cache）亲缘性"><a href="#带宽与缓存（cache）亲缘性" class="headerlink" title="带宽与缓存（cache）亲缘性"></a>带宽与缓存（cache）亲缘性</h2><p>对于足够简单的函数 Foo, 编写成并行循环的例子也许不能展现出良好的加速效果。原因可能是处理器与内存间的系统带宽不足。这种情况下，你可能要重新考虑算法以便更好地利用缓存（cache）。为更好地利用缓存进行重构通常会使程序（无论并行还是串行）受益。</p>
<p>某些情况下的重构的一种替代方案是<code>affinity_partitioner</code>。他不仅自动选择粒度，而且优化缓存的亲缘性。使用它在下列情况下会显著地改进性能：</p>
<ul>
<li>每次数据问题时，计算只有少量操作</li>
<li>被循环访问的数据适合留在缓存中</li>
<li>循环，或者类似的循环，在同样的数据上重复执行</li>
<li>可用硬件线程的数量多于两个。如果只有两个线程可用，intel TBB 的默认调度会提供良好的缓存亲缘性。</li>
</ul>
<p>下面的代码展示了如何使用<code>affinity_partitioner</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ParallelApplyFoo</span><span class="params">(<span class="type">float</span> a[], <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">static</span> affinity_partitioner ap;</span><br><span class="line">   <span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n), <span class="built_in">ApplyFoo</span>(a), ap);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimeStepFoo</span><span class="params">(<span class="type">float</span> a[], <span class="type">size_t</span> n, <span class="type">int</span> steps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; steps; ++t) </span><br><span class="line">       <span class="built_in">ParallelApplyFoo</span>(a, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>affinity_partitioner</code>的对象<code>ap</code>存在于循环迭代中。它记着循环的迭代从哪里执行，这样每个迭代都能被以前执行它的线程处理。示例中将<code>affinity_partitioner</code>的对象示例声明为局部静态变量来得到<code>ap</code>正确的生存周期。另一种方法是将它定义在<code>TimeStepFoo</code>函数中循环体的外面， 传递给<code>parallel_for</code>的调用链。 </p>
<h2 id="分区器总结"><a href="#分区器总结" class="headerlink" title="分区器总结"></a>分区器总结</h2><p>并行循环模板<code>parallel_for</code>以及<code>parallel_reduce</code>接受一个可选的<code>partitioner</code> 参数，通过它指定执行循环的策略。下表总结了三种分区器，以及当与<code>blocked_range</code>联合使用时的效果。</p>
<ul>
<li><code>simple_partitioner</code>：以粒度为单位选择块大小</li>
<li><code>auto_partitioner</code>：自动选择块大小</li>
<li><code>affinity_partitioner</code>：自动选择块大小以及缓存亲缘性</li>
</ul>
<p><code>auto_partitioner</code>在不指定分区器的情况下使用。一般来说， 应该使用<code>auto_partitioner</code>或者<code>affinity_partitioner</code>，因为他们基于有效的执行资源来制定块的数量。然而，在下述情况下，<code>simple_partitioner</code>是可用的：</p>
<ul>
<li><code>operator()</code>的子区域（subrange）不能超出某个限度。 这可能是有利的。例如，如果你的<code>operator()</code>需要一个跟区域大小成正比的临时数组。子区域的大小限定了，你就可以为这个数组使用一个自动变量而不是使用动态内存分配。</li>
<li>大尺度的子区域不能有效使用缓存。例如，假定一个子区域的处理流程需要重复清理同一块内存区域。保持子区域在某个限度下可以使重复引用的内存区域适合放入缓存。</li>
<li>你想调整为某个特定的机器。</li>
</ul>
<h2 id="parallel-reduce-1"><a href="#parallel-reduce-1" class="headerlink" title="parallel_reduce"></a>parallel_reduce</h2><p>循环可以做减量，像这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">SerialSumFoo</span><span class="params">(<span class="type">float</span> a[], <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != n; ++i) </span><br><span class="line">        sum += <span class="built_in">Foo</span>(a[i]);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果迭代是独立的，你可以使用模板类<code>parallel_reduce</code>来并行化这个循环：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">ParallelSumFoo</span><span class="params">( <span class="type">const</span> <span class="type">float</span> a[], <span class="type">size_t</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SumFoo <span class="title">sf</span><span class="params">(a)</span></span>; </span><br><span class="line">    <span class="built_in">parallel_reduce</span>( <span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>,n), sf ); </span><br><span class="line">    <span class="keyword">return</span> sf.my_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类<code>SumFoo</code>指定了降低的细节，诸如怎么累加子总和并将它们合并。下面是<code>SumFoo</code>的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SumFoo</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span>* my_a; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="type">float</span> my_sum;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="type">const</span> blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r )</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">float</span> *a = my_a; </span><br><span class="line">        <span class="type">float</span> sum = my_sum; </span><br><span class="line">        <span class="type">size_t</span> end = r.<span class="built_in">end</span>(); </span><br><span class="line">        <span class="keyword">for</span>( <span class="type">size_t</span> i=r.<span class="built_in">begin</span>(); i!=end; ++i )  </span><br><span class="line">            sum += <span class="built_in">Foo</span>(a[i]);  </span><br><span class="line">        my_sum = sum;     </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">SumFoo</span>( SumFoo&amp; x, split ) : <span class="built_in">my_a</span>(x.my_a), <span class="built_in">my_sum</span>(<span class="number">0</span>) &#123;&#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">( <span class="type">const</span> SumFoo&amp; y )</span> </span>&#123;my_sum+=y.my_sum;&#125; </span><br><span class="line">        </span><br><span class="line">    <span class="built_in">SumFoo</span>(<span class="type">float</span> a[] ) : </span><br><span class="line">        <span class="built_in">my_a</span>(a), <span class="built_in">my_sum</span>(<span class="number">0</span>) </span><br><span class="line">    &#123;&#125; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></p>
<p>注意与<code>parallel_for</code>章节中提到的<code>ApplyFoo</code>类的区别。第一，<code>operator()</code>不是<code>const</code>。这是因为它必须更新<code>SumFoo::my_sum</code>。第二，<code>SumFoo</code>提供分割构造函数以及一个<code>join</code>方法以使<code>parallel_reduce</code>工作。分割构造函数需要两个参数，其一，一个指向原始对象的引用，其二，一个类型为<code>split</code>（TBB库中定义） 的哑元参数。这个哑元参数将分割构造函数与拷贝构造函数区分开。</p>
<p>提示：实例中，<code>operator()</code>的定义为访问标量值在循环内部使用局部临时变量（a, sum, end）。这种技术通过明白告诉编译器这些值可以放在缓存中而不是内存中来提高性能。如果这些值过大不适合放进寄存器，或者以一种编译器不能追踪的方式获取地址，这项技术就没用了。在一个典型的优化编译器中，为只写变量（如例子中的 sum )使用局部临时变量应该足够了。因为随后编译器就能推断这个循环不会写任何其他的位置，并将其他的读取提升到循环外。</p>
<p>当任务调度器确定工作者线程有效时，<code>parallel_reduce</code>调用分割构造函数为工作者创建子任务。当子任务完工后，<code>parallel_reduce</code>使用<code>join</code>方法 来累加子任务的结果。</p>
<p>如果没有工作者线程可用，迭代的第二半约减操作时就使用第一半使用过的同一个实体对象。它开始的地方，就是第一半结束的地方。</p>
<p>小心： 因为分割/合并在没有有效工作者时不能派上用场， parallel_reduce 没有必要做递归分割。</p>
<p>小心：因为同一个实体（body）可能被用来累加多个子区域， operator() 不能丢弃早先的累加值就至关重要了。下面的代码展示了一种错误定义<code>SumFoo::operator()</code>的方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SumFoo</span></span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="type">float</span> my_sum;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">( <span class="type">const</span> blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r )</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ... </span><br><span class="line">        <span class="type">float</span> sum = <span class="number">0</span>;  <span class="comment">// WRONG – should be &quot;sum = my_sum&quot;. </span></span><br><span class="line">        ... </span><br><span class="line">        <span class="keyword">for</span>( ... )  </span><br><span class="line">            sum += <span class="built_in">Foo</span>(a[i]);  </span><br><span class="line">        my_sum = sum;    </span><br><span class="line">    &#125; </span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于错误的函数实现，<code>operator()</code>只是返回了应用parallel_reduce后最后一个子区域而不是所有子区域的值。<code>parallel_reduce</code>的分区器与粒度的规则跟<code>parallel_for</code>是一样的。</p>
<p><code>parallel_reduce</code>归纳了所有相关操作。通常，分割构造函数会做两件事：</p>
<ul>
<li>拷贝必要的只读信息来运行循环体</li>
<li>初始化约减操作标识元素的变量</li>
<li>join 方法做相应的合并操作。你可以在同一时间做多个约减操作：可以使用单个parallel_reduce 同时搜集最大、最小</li>
</ul>
<p>注意：约减（reduction）操作可以是不可交换的。例子中浮点数加法如果替换成了字符串连接，同样可行。</p>
<p>高级示例</p>
<p>一个高级点的联合操作的例子是找到最小<code>Foo(i)</code>的索引。串行版本是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">SerialMinIndexFoo</span><span class="params">( <span class="type">const</span> <span class="type">float</span> a[], <span class="type">size_t</span> n )</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> value_of_min = FLT_MAX;   <span class="comment">// FLT_MAX from &lt;climits&gt; </span></span><br><span class="line">    <span class="type">long</span> index_of_min = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">for</span>( <span class="type">size_t</span> i=<span class="number">0</span>; i&lt;n; ++i ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> value = <span class="built_in">Foo</span>(a[i]); </span><br><span class="line">        <span class="keyword">if</span>( value&lt;value_of_min ) </span><br><span class="line">        &#123;</span><br><span class="line">            value_of_min = value; </span><br><span class="line">            index_of_min = i; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> index_of_min; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<p>循环的工作方式就是保持最终找到的最小值以及这个值的索引。这是循环迭代间携带的唯一信息。为了将此循环转换成<code>parallel_reduce</code>， 函数对象（<code>operator()</code>）必须保持追踪这个携带信息，并知道如何在这些迭代跨越多个线程时合并这个信息。同样，函数对象必须记录一个指向 a 的指针来提供上下文。</p>
<p>下面的代码展示了完整的函数对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinIndexFoo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> *<span class="type">const</span> my_a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> value_of_min;</span><br><span class="line">    <span class="type">long</span> index_of_min;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> blocked_range&lt;<span class="type">size_t</span>&gt;&amp; r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">float</span> *a = my_a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> value = <span class="built_in">Foo</span>(a[i]);</span><br><span class="line">            <span class="keyword">if</span> (value &lt; value_of_min)</span><br><span class="line">            &#123;</span><br><span class="line">               value_of_min = value;</span><br><span class="line">               index_of_min = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">MinIndexFoo</span>(MinIndexFoo&amp; x, split) :</span><br><span class="line">        <span class="built_in">my_a</span>(x.my_a),</span><br><span class="line">        <span class="built_in">value_of_min</span>(FLT_MAX),  <span class="comment">// FLT_MAX from &lt;climits&gt;</span></span><br><span class="line">        <span class="built_in">index_of_min</span>(<span class="number">-1</span>)</span><br><span class="line">     &#123; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">const</span> SumFoo&amp; y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y.value_of_min &lt; value_of_min)</span><br><span class="line">        &#123;</span><br><span class="line">            value_of_min = y.value_of_min;</span><br><span class="line">            index_of_min = y.index_of_min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">MinIndexFoo</span>(<span class="type">const</span> <span class="type">float</span> a[]) :</span><br><span class="line">        <span class="built_in">my_a</span>(a),</span><br><span class="line">        <span class="built_in">value_of_min</span>(FLT_MAX),  <span class="comment">// FLT_MAX from &lt;climits&gt;</span></span><br><span class="line">        <span class="built_in">index_of_min</span>(<span class="number">-1</span>),</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在可以使用<code>parallel_reduce</code>来重写<code>SerialMinIndex</code>了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">ParallelMinIndexFoo</span><span class="params">(<span class="type">float</span> a[], <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">MinIndexFoo <span class="title">mif</span><span class="params">(a)</span></span>;</span><br><span class="line">   <span class="built_in">parallel_reduce</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">0</span>, n), mif);</span><br><span class="line">   <span class="keyword">return</span> mif.index_of_min;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>截至目前，所有的示例都使用<code>blocked_range&lt;T&gt;</code>类来指定区域。这个类可以在很多情况下使用，但并非适用所有的情况。你可以使用Intel Threading Building Blocks 定义自己的迭代空间对象。这个对象必需提供两个方法以及一个“分割构造函数”指定将其自身分割为子空间的方式。如果这个类叫R， 方法以及构造函数会是下面这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">R</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// True if range is empty </span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">    <span class="comment">// True if range can be split into non-empty subranges </span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_divisible</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">    <span class="comment">// Split r into subranges r and *this </span></span><br><span class="line">    <span class="built_in">R</span>( R&amp; r, split ); </span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果区域为空，<code>empty()</code>返回 true. 如果区域可被分割为两个非空子区域，而且这个分割带来的好处多于带来的损耗，is_divisible 就返回 true. 分割构造函数有两个参数：</p>
<ul>
<li>第一个类型为 R</li>
<li>第二个类型为 tbb::split</li>
<li>第二个参数没用；它只是为了将这个构造函数与普通的拷贝构造函数区分开。分割构造函数会试图将 r 大约分成两个等分， 将 r 更新为第一个等分，将构造出来的对象作为第二个等分。这两个等分都应该是非空的。并行算法模板在只有 r.is_divisible 为 true 的情况下才在 r 调用分割构造函数。</li>
</ul>
<p>迭代空间不用必须是线性的。tbb/blocked_range2d.h 就是个二维区域的示例。它的分割构造函数试图沿着最长的坐标轴分割此区域。当与parallel_for 一起使用时，它以使循环陷入“递归阻塞”的方式来改进缓存使用。这种漂亮的缓存行为意味着在 blocked_ranged2d<T> 上使用 parallel_for 能让循环比对应的串行版本运行的更快，即使是在单个的处理器上。</p>
<h1 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h1><p>互斥控制某块代码能同时被多少线程执行。在Intel  Threading Building Blocks（intelTBB）中，互斥通过互斥体（mutexes）和锁（locks）来实现。互斥体是一种对象，在此对象上，一个线程可以获得一把锁。在同一时间，只有一个线程能持有某个互斥体的锁，其他线程必须等待时机。</p>
<p>最简单的互斥体是<code>spin_mutex</code>。试图在<code>spin_mutex</code>上获得锁的线程要保持繁忙等待，直到成功。<code>spin_mutex</code>适合一个锁只被持有数个指令时常的情况。例如，下面的代码使用一个互斥体FreeListMutex来保护一个共享变量FreeList。它负责审查在同一时间只有一个线程访问FreeList。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Node* FreeList;</span><br><span class="line"><span class="keyword">typedef</span> spin_mutex FreeListMutexType;</span><br><span class="line">FreeListMutexType FreeListMutex;</span><br><span class="line"><span class="function">Node* <span class="title">AllocateNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node* n;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">FreeListMutexType::scoped_lock <span class="title">lock</span><span class="params">(FreeListMutex)</span></span>;</span><br><span class="line">		n = FreeList;</span><br><span class="line">		<span class="keyword">if</span> (n)</span><br><span class="line">			FreeList = n-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!n)</span><br><span class="line">		n = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FreeNode</span><span class="params">(Node* n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">FreeListMutexType::scoped_lock <span class="title">lock</span><span class="params">(FreeListMutex)</span></span>;</span><br><span class="line">	n-&gt;next = FreeList;</span><br><span class="line">	FreeList = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>scoped_lock</code>的构造子（构造函数）会一直等待，直到FreeListMutex上没有别的锁。析构子（析构函数）释放获得的锁。AllocateNode中的大括弧也许看起来不太常见。它们的作用是使锁的生命周期尽可能的短，这样其他的正在等待的线程就能尽可能快地得到机会。</p>
<p>注意：确保命名锁对象，否则它会被过快的销毁。例如，如果例子中的scoped_lock对象以如下方式创建<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FreeListMutexType::<span class="built_in">scoped_lock</span> (FreeListMutex);</span><br></pre></td></tr></table></figure></p>
<p>这样<code>scoped_lock</code>会在执行到分号处时销毁，即在FreeList被访问前释放锁。</p>
<p>编写<code>AllocatedNode</code>的另一种可选方式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">AllocateNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node* n;</span><br><span class="line">	FreeListMutexType::scoped_lock lock;</span><br><span class="line">	lock.<span class="built_in">acquire</span>(FreeListMutex);</span><br><span class="line">	n = FreeList;</span><br><span class="line">	<span class="keyword">if</span> (n)</span><br><span class="line">		FreeList = n-&gt;next;</span><br><span class="line">	lock.<span class="built_in">release</span>();</span><br><span class="line">	<span class="keyword">if</span> (!n)</span><br><span class="line">		n = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>acquire</code>方法在得到锁前会一直等待；<code>release</code>方法释放该锁。</p>
<p>推荐的做法是尽可能得加上大括弧，以使得那些代码被锁保护对于维护者来说更为清晰。</p>
<p>如果你很熟悉锁的C接口，也许会疑惑为什么在互斥体对象自身上没有获取、释放方法。原因是C接口不是异常安全的，因为如果被保护的区域抛出一个异常，控制流就会略过释放操作。借助面向对象接口，析构scoped_lock对象会致使锁的释放，无论是正常退出保护区域，还是因为异常。即使对于我们使用acquire、release方法实现的AllocateNode的版本也是这样的——显式释放让锁得以早点释放，而后，析构函数判断锁已经被释放，就不去操作锁了。</p>
<p>Intel TBB中所有的互斥体都有类似的接口，不但能让他们易于学习，还能适用于泛型编程。例如，所有的互斥体都嵌套一个<code>scoped_lock</code>类型，对于给定类型M，对应的锁类型是<code>M::scoped_lock</code>。</p>
<p>推荐为互斥体类型使用typedef，如同前面的例子所示。以这种方式，你可以稍后改变锁的类型而不用编辑其余的代码。在这些例子中，可以使用<code>typedef queuing_mutex FreeListMutexType</code>来代替<code>typedef spin_mutex FreeListMutexType</code>（及使用<code>queuing_mutex</code>代替<code>spin_mutex</code>），代码仍然正确。</p>
<h2 id="互斥体要素"><a href="#互斥体要素" class="headerlink" title="互斥体要素"></a>互斥体要素</h2><p>互斥体的行家总结了互斥体的各种特性。知道这些是有帮助的，因为它们影响通用性、性能的权衡。选择正确会有助于性能提升。互斥体能以下面的要素描述：</p>
<ul>
<li>可伸缩性   一些互斥体被称为可伸缩的。在严格意义上，这不是一个准确的名字，因为互斥体限制在某个时间某个线程的执行。一个可伸缩的互斥体是不会比这个做的更差。如果等待线程消耗了大量的处理器循环和内存带宽，减少了线程做实际工作的速度，此时互斥体会比串行执行更糟糕。在轻微竞争的情况下，可伸缩互斥体通常要比非可伸缩互斥体要慢，此时非可伸缩互斥体要优于前者。如果有疑惑，就使用可伸缩互斥体。</li>
<li>公平    互斥体可以是公平或者非公平的。公平的互斥体按照线程到达的顺序使其通过，防止饿死线程。每个线程依序进行。然而，非公平互斥体会更快，它们允许正在运行的线程先通过，而不是下一个也许因为某个中断正在睡眠的在线（in line）线程。</li>
<li>递归    互斥体可以是递归的，也可以是非递归的。可递归互斥体允许线程在持有此互斥体锁的情况下再次获得锁。这在一些递归算法中很有用，但也增加了锁实现的开销。</li>
<li>放弃或者阻塞   这是影响性能的实现细节。在长等待时，Intel TBB的互斥体要么放弃（yields）要么阻塞（blocks）。这里的放弃（yields）的意思是，重复轮询看能否有进展，如果不能，就暂时放弃处理器的使用权。阻塞意味着直到互斥体完成处理才释放处理器。如果等待短暂，就使用放弃互斥体；如果等待时间往往比较长，就使用阻塞互斥体。（在windows系统中，yield通过SwitchToThread()实现，其他系统中通过<code>sched_yield()</code>实现）</li>
</ul>
<p>下面是互斥体的行为总结：</p>
<ul>
<li><code>spin_mutex</code>    非可伸缩，非公平，非递归，在用户空间自旋（光吃不干）。看起来它似乎在所有场景里都是最坏的，例外就是，在轻微竞争的情况下，它非常快。如果你设计程序时，竞争行为在很多spin_mutex对象间传播，那还是使用别的种类的互斥体为好。如果互斥体是重度竞争的，你的算法无论如何都不会是可伸缩的。此种情况下，重新设计算法比寻找更有效的锁合适。</li>
<li><code>queuing_mutex</code>   可伸缩，公平，非递归，在用户控件自旋。当可伸缩与公平很重要时使用。</li>
<li><code>spin_rw_mutex</code>、<code>queuing_rw_mutex</code>     与spin_mutex、queuing_mutex类似，但是增加了读取锁支持。</li>
<li><code>mutex</code>与<code>recursive_mutex</code>    这两个互斥体是对系统原生互斥的包装。在windows系统中，是在CRITICAL_SECTION（关键代码段）上封装的。在Linux以及Mac OS 操作系统中，通过pthread的互斥体实现。封装的好处是加入了异常安全接口，并相比Intel TBB的其他互斥体提供了接口的一致性，这样当出于性能方面考虑时能方便地将其替换为别的互斥体。</li>
<li><code>null_mutex</code>和<code>null_rw_mutex</code>   这两个互斥体什么都不做。它们可被用作模版参数。例如，假定你要定义一个容器模板并且知道它的一些实例会被多个线程共享，需要内部锁定，但是其余的会被某个线程私有，不需要锁定。你可以定义一个将互斥体类型作为参数的模板。在需要锁定时，这个参数可以是真实互斥体类型中的一种，在不需要锁定时，将null_mutex作为参数传入。</li>
</ul>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>互斥在当多个线程写操作某个共享变量时是必要的。但允许多个读操作者进入保护区域就没什么大不了了。互斥体的读写变种，在类名称中以<em>rw</em>标记，通过区分读取锁与写入锁，允许多个读操作者。一个给定的互斥体，可以有多个读取锁。</p>
<p><code>scoped_lock</code>的构造函数通过一个额外的布尔型参数来区分读取锁请求与写入锁请求。如果这个参数为false，表示请求读取锁。true表示请求写入锁。默认值为true，这样，当省略此参数时，<code>spin_rw_mutex</code>或者<code>queuing_rw_mutex</code>的行为就跟没有<code>_rw_</code>的版本一样。</p>
<h3 id="升级-降级"><a href="#升级-降级" class="headerlink" title="升级/降级"></a>升级/降级</h3><p>通过方法<code>upgrade_to_writer</code>可以将一个读取锁升级为写入锁：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;string&gt; MyVector;</span><br><span class="line"><span class="keyword">typedef</span> spin_rw_mutex MyVectorMutexType;</span><br><span class="line">MyVectorMutexType MyVectorMutex;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddKeyIfMissing</span><span class="params">(<span class="type">const</span> string&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Obtain a reader lock on MyVectorMutex </span></span><br><span class="line">	<span class="function">MyVectorMutexType::scoped_lock</span></span><br><span class="line"><span class="function">		<span class="title">lock</span><span class="params">(MyVectorMutex,<span class="comment">/*is_writer=*/</span><span class="literal">false</span>)</span></span>;</span><br><span class="line">	<span class="type">size_t</span> n = MyVector.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (MyVector[i] == key) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (!MyVectorMutex.<span class="built_in">upgrade_to_writer</span>())</span><br><span class="line">		<span class="comment">// Check if key was added while lock was temporarily released </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = n; i&lt;MyVector.<span class="built_in">size</span>(); ++i)</span><br><span class="line">			<span class="keyword">if</span> (MyVector[i] == key) <span class="keyword">return</span>;</span><br><span class="line">	vector.<span class="built_in">push_back</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，vector在某些时候必须重新搜索。这是因为upgrade_to_writer在它升级前可能不得不临时释放锁。否则，接下来可能会发生死锁（下面会讲到）。upgrade_to_writer方法返回值为bool类型，在没有释放锁就成功升级的情况下会返回true，如果锁被临时释放了，返回false。因此，如果upgrade_to_writer返回了false，代码必须重新运行查找操作确保“key”没有被其他的线程插入。例子假定“keys”总被追加到vector的末端，而且这些键值不会被移除。由于这些假定，它不用重新搜索整个vector，而仅搜索那些最初搜索过的之外的元素。需要记住的关键点是，如果upgrade_to_writer返回了false，任何假定持有读取锁的假定都可能无效，必须重新检查。</p>
<pre><code>于此相应，有个相对的方法downgrade_to_reader，但是在实际应用中，基本找不到使用它的理由。
</code></pre><h3 id="锁异常"><a href="#锁异常" class="headerlink" title="锁异常"></a>锁异常</h3><p>锁会导致性能与正确性问题。对于使用锁的新手，有些问题要避免：</p>
<ul>
<li>死锁：当多个线程企图获得多个锁，而且它们会相互持有对方需要的锁时，死锁就会发生。更为准确地定义，当发生以下情况时死锁会发生：</li>
<li>存在线程回路：每个线程至少持有互斥体上的一个锁，而且在等待回路中下一个线程已经持有锁的互斥体</li>
<li>任何线程都不愿意放弃它的锁：避免需要同一时间持有两把锁的情况。将大块的程序拆分为小块，每块都可以在持有一把锁的情况下完工。</li>
<li>总是以同样的顺序取锁。例如，如果你有“外部容器”与“内部容器”互斥体，需要从中获取锁，你可以总是先从“外部密室”获取。另外一个例子是在锁具有命名的情况下“以字母顺序获取锁”。或者，如果锁没有命名，就以互斥体的数字地址作为顺序获取锁。</li>
</ul>
<h3 id="锁护送"><a href="#锁护送" class="headerlink" title="锁护送"></a>锁护送</h3><p>另外一个与锁相关的常见问题是锁护送。当操作系统打断一个持有锁的线程时，这种情况就会发生。所有其他的需要这把锁的线程都必须等待被中断的线程恢复并释放锁。公平互斥体会导致更糟糕的状况，因为，如果一个正在等待的线程被中断，所有它后面的线程都必须等待它恢复（就不单是需要它持有锁的那些线程的问题了）。</p>
<p>要最小化这种情况发生，应该尽量缩短持有锁的时间。在请求锁之前，进行任何可被预先计算的工作。</p>
<p>要避免这种情况，尽可能使用原子操作代替锁。</p>
<h1 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h1><p>Intel Threading Building Blocks (Intel® TBB)是基于任务（task）驱动的。一般来说，只有在TBB提供的算法模板中找不到合适的模板时，才考虑使用任务调度器自行实现。任务（task）是一个逻辑概念，操作系统并没有提供对应的实现。你可以把它当作线程池的进化。实现时，一个thread可对应多个task。在非阻塞编程时，相对于线程（thread），基于任务的编程有很多优点，比如：</p>
<ul>
<li>task的启动、停止通常比thread更快</li>
<li>task更能匹配有效资源（因为有TBB的任务调度器）</li>
<li>task在编程时使程序员更能专注业务实现而不是底层细节</li>
<li>task实现了负载均衡</li>
</ul>
<p>但是，要记住，task的应用场景是并行，而不是并发（不要企图把TBB用于Socket之类的并发敲打）。如果一个task被阻塞，其对应的thread也将被阻塞，这样，运行于thread之上的所有task都将被阻塞。</p>
<h2 id="任务对象的生成"><a href="#任务对象的生成" class="headerlink" title="任务对象的生成"></a>任务对象的生成</h2><p>task的定义在task.h中，派生类必须要实现纯虚函数<code>execute</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! Should be overridden by derived classes.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> task* <span class="title">execute</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>task对象不能直接new，而是要使用TBB中重载的new操作符：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="type">size_t</span> bytes, <span class="type">const</span> tbb::internal::allocate_root_proxy&amp; )</span> </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="type">size_t</span> bytes, <span class="type">const</span> tbb::internal::allocate_root_with_context_proxy&amp; p )</span> </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="type">size_t</span> bytes, <span class="type">const</span> tbb::internal::allocate_continuation_proxy&amp; p )</span> </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="type">size_t</span> bytes, <span class="type">const</span> tbb::internal::allocate_child_proxy&amp; p )</span> </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">( <span class="type">size_t</span> bytes, <span class="type">const</span> tbb::internal::allocate_additional_child_of_proxy&amp; p )</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面是TBB Tutorial中的示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tbb/tick_count.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> tbb::task;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">SerialFib</span><span class="params">(<span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">SerialFib</span>(n - <span class="number">1</span>) + <span class="built_in">SerialFib</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FibTask</span> : <span class="keyword">public</span> task</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">long</span> n;</span><br><span class="line">	<span class="type">long</span>* <span class="type">const</span> sum;</span><br><span class="line">	<span class="built_in">FibTask</span>(<span class="type">long</span> n_, <span class="type">long</span>* sum_) :</span><br><span class="line">		<span class="built_in">n</span>(n_), <span class="built_in">sum</span>(sum_)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">task* <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;   </span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*sum = <span class="built_in">SerialFib</span>(n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">long</span> x, y;</span><br><span class="line">			FibTask&amp; a = *<span class="built_in">new</span>(<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">1</span>, &amp;x);</span><br><span class="line">			FibTask&amp; b = *<span class="built_in">new</span>(<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">2</span>, &amp;y);</span><br><span class="line">			<span class="comment">// ref_count的值为2+1（a+b+后面函数sapwn_and_wait_for_all产生的等待任务） </span></span><br><span class="line">			<span class="built_in">set_ref_count</span>(<span class="number">3</span>);</span><br><span class="line">			<span class="built_in">spawn</span>(b);			 </span><br><span class="line">			<span class="built_in">spawn_and_wait_for_all</span>(a);</span><br><span class="line">			*sum = x + y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">ParallelFib</span><span class="params">(<span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> sum;</span><br><span class="line">	FibTask&amp; a = *<span class="built_in">new</span>(task::<span class="built_in">allocate_root</span>()) <span class="built_in">FibTask</span>(n, &amp;sum);</span><br><span class="line">	task::<span class="built_in">spawn_root_and_wait</span>(a);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line">	tick_count start = tick_count::<span class="built_in">now</span>();</span><br><span class="line">	<span class="built_in">ParallelFib</span>(<span class="number">10</span>);</span><br><span class="line">	tick_count end = tick_count::<span class="built_in">now</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tick count = %f\n&quot;</span>, (end - start).<span class="built_in">seconds</span>());</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="任务的调度"><a href="#任务的调度" class="headerlink" title="任务的调度"></a>任务的调度</h2><p>调度器持有一个定向图表，每个节点对应一个任务对象。每个task指向它的继任者（successor），也就是指向等待它完成的任务（可以为空）。successor可以通过task::parent()得到。每个任务对象都包含一个引用计数，用来统计将此任务作为继任者的任务数量”。下图是斐波那契计算的任务图形快照：<br><img src="/img/20150401170607494.jpg" alt=""></p>
<p>任务A、B、C都产生了子任务并等待其完成。它们的引用计数为子任务的数目+1.</p>
<p>任务D正在运行，但是没有产生子任务，所以不需要设置引用计数</p>
<p>任务E、F、G都没有开始执行（spawned，当时没有excuting）</p>
<p>调度器运行任务的方式倾向于最小化内存需求以及跨线程通讯。但也需要在两种执行方式（深度优先、广度优先）间达到平衡。假定树是固定的，深度优先就是最佳的顺序执行方式：</p>
<ul>
<li>趁热打铁  最深层次的通常是最新创建的任务，因此在缓存（cache）中处于活跃状态。如果他们能完成，紧接着他们的任务就会被执行（比如D执行完后执行C），虽然不如第一个任务在缓存中的状态活跃，但相比创建事件更久的任务，它是最有效的。</li>
<li>最小化空间占用  执行最浅节点的任务会将树按照广度优先展开。这将同时创建指数级数量的节点。于此相比，深度优先只创建同等数量的节点，而且同一时间存在一个线性数量，因为它将其他准备好的任务压入堆栈。</li>
</ul>
<p>虽然广度优先有着严重的内存占用问题，但在如果你拥有无数个物理线程，它能最大并行化。一般来说物理线程都是有限的，所以广度优先执行的数量让有效的处理器保持繁忙就够了。调度器实现了广度优先、深度优先的混合执行模式。每个线程都有自己的就绪任务队列。当一个线程产出一个任务时，就将此任务推入队列的底部。</p>
<h2 id="线程的队列"><a href="#线程的队列" class="headerlink" title="线程的队列"></a>线程的队列</h2><p>线程执行任务的时候，按照以下规则从任务队列取得任务：</p>
<ul>
<li>规则1：获取上一个task的execute方法返回的task，如果为空继续获取</li>
<li>规则2：从自身的队列底部弹出一个task，如果队列为空，继续下一条判断</li>
<li>规则3：随机选择一个任务队列，从其顶部“偷”一个task。如果选择的队列为空，继续遍历其余的队列，直到成功</li>
</ul>
<p>规则2的效果就是执行本线程最近产出的任务，属于深度优先执行任务。规则3会从别的线程任务队列中选择最先产出的任务，发生广度优先任务执行，将潜在的并行变为实际的并行执行。作为任务演进图的一部分，获取任务是自动的。任务入队可以是显式的，也可以是隐式的。一个线程总是把任务加入自己队列的底部（不会加入另外线程的队列）。只有偷窃器才能把一个线程产出的任务传送到另外一个线程。在以下条件下，一个线程会将一个任务压入它的队列：</p>
<ul>
<li>任务被此线程显式产出，比如方法spawn</li>
<li>一个任务被方法task::recycle_to_reexecute标记为再执行</li>
<li>一个线程执行完最后的前任任务，并且此后隐式地将任务的引用计数减少到0。如果这种情况发生，线程隐式的将后续任务推入他的队列底部。如果一个任务有外部引用，执行完它所有的孩子任务并不会导致它的引用计数为0</li>
</ul>
<p>总体来说，任务调度的基本策略是“广度优先窃取，深度优先运行”。广度优先窃取准则会使线程保持繁忙，提升并行效率。深度优先运行准则会使每个线程在有足够工作需要做时，保持高效操作。</p>
<h2 id="有用的任务技术"><a href="#有用的任务技术" class="headerlink" title="有用的任务技术"></a>有用的任务技术</h2><h3 id="递归链式反应"><a href="#递归链式反应" class="headerlink" title="递归链式反应"></a>递归链式反应</h3><p>如果任务图为树形结构，调度器能工作的最好。因为此时“广度优先窃取、深度优先执行”策略非常适合。而且，树形结构的任务图也能很快地为很多任务创建出来。比如，一个主控任务需要创建N个孩子，如果直接创建，需要O（N）个步骤。但使用树形结构叉分建立，只需要O(lg(N))个步骤。</p>
<p> 一般情况下，问题都不是明显的树形结构，但可以轻松将他们映射到树。比如，parallel_for工作在迭代空间（比如，一个整数队列）。模板函数parallel_for使用定义将一个迭代空间递归映射到一个二叉树。</p>
<h3 id="持续传递"><a href="#持续传递" class="headerlink" title="持续传递"></a>持续传递</h3><p><code>spawn_and_wait_for_all</code>方法使正在执行的父任务等待所有的子任务完成，但是会稍微影响一些性能。当一个线程调用这个函数时，它会保持繁忙直到所有的孩子任务完成。有些时候，父任务准备就绪，可以继续执行，但却不能马上开始，因为它的线程还在执行其他任务中的一个任务。解决方案是父任务不再等待它的孩子，而是产出子任务后返回。子任务不是被作为父任务的孩子被分配，而是作为父任务的持续任务（continuation task）。这样，空闲的线程在它的子任务完成后就能偷窃并运行持续任务。上述FibTask的“持续传递”变体如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FibContinuation</span> : <span class="keyword">public</span> task</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span>* <span class="type">const</span> sum;</span><br><span class="line">	<span class="type">long</span> x, y;</span><br><span class="line">	<span class="built_in">FibContinuation</span>(<span class="type">long</span>* sum_) : <span class="built_in">sum</span>(sum_) &#123;&#125;</span><br><span class="line">	<span class="function">task* <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		*sum = x + y;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FibTask</span> : <span class="keyword">public</span> task</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">long</span> n;</span><br><span class="line">	<span class="type">long</span>* <span class="type">const</span> sum;</span><br><span class="line">	<span class="built_in">FibTask</span>(<span class="type">long</span> n_, <span class="type">long</span>* sum_) :</span><br><span class="line">		<span class="built_in">n</span>(n_), <span class="built_in">sum</span>(sum_)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">task* <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n&lt;<span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*sum = <span class="built_in">SerialFib</span>(n);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			FibContinuation&amp; c =</span><br><span class="line">				*<span class="built_in">new</span>(<span class="built_in">allocate_continuation</span>()) <span class="built_in">FibContinuation</span>(sum);</span><br><span class="line">			FibTask&amp; a = *<span class="built_in">new</span>(c.<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">2</span>, &amp;c.x);</span><br><span class="line">			FibTask&amp; b = *<span class="built_in">new</span>(c.<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">1</span>, &amp;c.y);</span><br><span class="line">			<span class="comment">// 这里的引用计数是2，而不是2+1. </span></span><br><span class="line">			c.<span class="built_in">set_ref_count</span>(<span class="number">2</span>);</span><br><span class="line">			<span class="built_in">spawn</span>(b);</span><br><span class="line">			<span class="built_in">spawn</span>(a);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>两个版本的以下不同点需要了解：</p>
<ul>
<li>最大的区别是，在execute方法中，原来版本的x、y都是局部变量。在持续传递版本，它们就不能是局部变量了，因为父任务在子任务完成之前就返回了。作为替代方案，他们都是持续任务FibContinuation的字段。</li>
<li>改为使用allocate_continuation分配持续的任务。它与allocate_child类似，只是它的继任者（successor）是c而不是this，并且设置this的继任者为NULL，下面的图示了这种转换：</li>
</ul>
<p><img src="/img/20150415215857456.jpg" alt=""></p>
<p>这种转换的一个属性就是它不改变继任者的引用计数，这样就避免了涉入引用计数逻辑。</p>
<p>引用计数被设置为2，子任务的数量。在初始版本，它被设置为3，因为spawn_and_wait_for_all需要增加计数。而且，代码设置持续任务（FibContinuation）而不是父任务的引用计数，因为是持续任务对象在等待子任务。</p>
<p>指针sum通过<code>FibContinuation</code>的构造函数传递给持续任务对象，因为现在是<code>FibContinuation</code>把计算结果保存到<code>*sum</code>。子任务仍然使用<code>allocate_child</code>分配，但是都作为<code>c</code>，而不是父节点的孩子。这样，当两个子任务完成后，就是c而不是this作为继任者被产出。如果你凑巧使用<code>this.allocate_child()</code>，父任务就会在两个子任务完成后再次运行。</p>
<p>如果大家还记得初始版本中的ParallelFib是怎么编写的，就也许会担心持续传递风格会打破这段代码，因为现在根FibTask在子任务完工之前完成，并且实现代码使用<code>spawn_root_and_wait</code>来等待根<code>FibTask</code>。这算不上问题，因为<code>spawn_root_and_wait</code>被设计的能与持续传递风格很好的工作。调用<code>spawn_root_and_wait(x)</code>并不真的等待x结束。实际上，它构造了X的一个亚元(dummy)继任者，并且等待继任者的引用计数被消减。因为<code>allocate_continuation</code>将此亚元继任者传递给持续任务，亚元继任者的引用计数会在持续任务完成后才递减。</p>
<h3 id="调度旁路"><a href="#调度旁路" class="headerlink" title="调度旁路"></a>调度旁路</h3><p>调度旁路（scheduler bypass）是一种优化手段，此时你直接指定下一个要运行的任务。持续传递风格经常会为调度旁路开启机会。例如，在持续传递例子的最后，方法<code>execute()</code>产出任务“a”后返回。这会导致正在执行的线程做以下事情：</p>
<ol>
<li>将任务“a”入栈线程的任务队列</li>
<li>从方法<code>execute()</code>返回</li>
<li>将任务“a”出栈，如果它被别的线程“偷窃”</li>
</ol>
<p>步骤1、3都是不必要的队列操作，更坏的是，允许“偷窃”会损害局部性而没有显著增加并行。方法execute()能通过返回一个指向“a”的指针而不是产出它来避免这些问题。由线程执行任务的规则1可知，“a”变为此线程的下一个要执行的任务。而且，这种方法保证执行任务“a”的是此线程，而不是另外的线程。</p>
<p>下面的示例显示了前一节的例子中必须要做的变更：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FibTask</span> : <span class="keyword">public</span> task</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">		<span class="function">task* <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n&lt;CutOff)</span><br><span class="line">		&#123;</span><br><span class="line">			*sum = <span class="built_in">SerialFib</span>(n);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			FibContinuation&amp; c =</span><br><span class="line">				*<span class="built_in">new</span>(<span class="built_in">allocate_continuation</span>()) <span class="built_in">FibContinuation</span>(sum);</span><br><span class="line">			FibTask&amp; a = *<span class="built_in">new</span>(c.<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">2</span>, &amp;c.x);</span><br><span class="line">			FibTask&amp; b = *<span class="built_in">new</span>(c.<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">1</span>, &amp;c.y);</span><br><span class="line">			<span class="comment">// Set ref_count to &quot;two children&quot;. </span></span><br><span class="line">			c.<span class="built_in">set_ref_count</span>(<span class="number">2</span>);</span><br><span class="line">			<span class="built_in">spawn</span>(b);</span><br><span class="line">			<span class="built_in">spawn</span>(a);</span><br><span class="line">			<span class="comment">//return NULL;</span></span><br><span class="line">			<span class="keyword">return</span> &amp;a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="任务再生"><a href="#任务再生" class="headerlink" title="任务再生"></a>任务再生</h3><p>不但可以绕过调度器，也可以绕过任务分配与再分配。这在递归任务执行调度旁路时，会有相应的更高几率发生。考虑前面的例子。当它创建了一个持续任务“c”，会执行下面的步骤：</p>
<ol>
<li>创建子任务“a”</li>
<li>创建并产出子任务“b”</li>
<li>从<code>execute()</code>方法返回指向任务“a”的指针</li>
<li>销毁父任务</li>
</ol>
<p>如果把“a”当作父任务，就可以避免上述的步骤1、4. 在很多场景中，步骤1需要从父任务中拷贝状态。将“a”当作父任务会消除拷贝开销。下面的例子显示了使用任务再生改造调度旁路的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">FibTask</span> : <span class="keyword">public</span> task</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*const*/</span> <span class="type">long</span> n;</span><br><span class="line">	<span class="type">long</span>* <span class="comment">/*const*/</span> sum;</span><br><span class="line">	...</span><br><span class="line">		<span class="function">task* <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n&lt;<span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			*sum = <span class="built_in">SerialFib</span>(n);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			FibContinuation&amp; c =</span><br><span class="line">				*<span class="built_in">new</span>(<span class="built_in">allocate_continuation</span>()) <span class="built_in">FibContinuation</span>(sum);</span><br><span class="line">			FibTask&amp; a = *<span class="built_in">new</span>(c.<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">2</span>, &amp;c.x);</span><br><span class="line">			FibTask&amp; b = *<span class="built_in">new</span>(c.<span class="built_in">allocate_child</span>()) <span class="built_in">FibTask</span>(n - <span class="number">1</span>, &amp;c.y);</span><br><span class="line">			<span class="built_in">recycle_as_child_of</span>(c);</span><br><span class="line">			n -= <span class="number">2</span>;</span><br><span class="line">			sum = &amp;c.x;</span><br><span class="line">			<span class="comment">// Set ref_count to &quot;two children&quot;. </span></span><br><span class="line">			c.<span class="built_in">set_ref_count</span>(<span class="number">2</span>);</span><br><span class="line">			<span class="built_in">spawn</span>(b);</span><br><span class="line">			<span class="comment">//return &amp;a;</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>execute()</code>方法现在返回this，而不是”a” 任务。调用<code>recycle_as_child_of(c)</code>有几种作用：</p>
<ul>
<li>标记this在<code>execute()</code>返回后不能自动销毁</li>
<li>设置this的继任者为<code>c</code></li>
</ul>
<p>为了防止引用计数问题，<code>recycle_as_child_of</code>有个前置条件，那就是this的继任者必须为空。这是在<code>allocate_continuation</code>发生后的情况。下图显示了allocate_continuation、recycle_as_child_of如何转换任务图：</p>
<p><img src="/img/20150415220015936.jpg" alt=""></p>
<p>使用任务再生时，确保原始任务的字段在任务开始运行后不能处于被使用状态。例子使用调度旁路技术来确保这点。可以在产出时，当它的字段没有被使用时再产出再生任务。这个限制甚至适用于任何const字段，因为产出（spawning）后，任务可能在父任务没有任何动作的情况下运行并销毁。</p>
<p>一个类似的方法，<code>task::recycle_as_continuation()</code>，将一个任务作为一个持续任务而不是孩子任务。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于任务调度的复杂性，官方并不鼓励直接使用调度器，采用<code>parallel_for</code>、<code>parallel_reduce</code>等模板是个好主意。以下细节需要谨记：</p>
<ul>
<li>使用<code>new(allocation_method)T</code>来分配一个<code>task</code> （<code>allocation_method</code>是<code>task</code>类的一种分配方法）。不要创建局部或者文件作用域的task实例</li>
<li>除非使用<code>allocate_additional_child_of</code>，否则在运行任何任务前，它的兄弟任务都必须分配完毕。</li>
<li>采用持续传递、绕过调度器，以及任务再生等技术榨取最大性能</li>
<li>如果一个任务完成了，并且没有被标记为再执行，就会自动销毁。同样，它的继任者的引用计数会减少，如果到了0，继任者会被自动产出</li>
</ul>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><p>Intel Threading Building Blocks（Intel TBB）提供了两种与STL模板类（<code>std::allocator</code>)类似的内存分配器模板。这两类模板（<code>scalable_allocator&lt;T&gt;</code>、<code>cache_aligned_allocator&lt;T&gt;</code>）解决并行编程中的如下关键问题：</p>
<ul>
<li>可伸缩性    当在线程中使用原本为串行编程而设计的内存分配器因单个同一时间只允许一个线程分配的共享池而竞争的时候，可伸缩性的问题就会凸显。使用内存分配模板scalable_allocator<T>来避免此类可伸缩性瓶颈。这个模板可以提升急速分配、释放内存程序的性能。</li>
<li>伪共享   当两个线程访问同一缓存行的不同字节时，伪共享的问题就会出现。这是因为，缓存行（cache line）是不同处理器缓存间交换信息的单位。如果一个处理器修改了一个缓存行而另外一个处理器读（或者写）同一个缓存行，那么它必须从一个处理器移动到另外一个处理器，即使两个处理处理的是这行内的不同字节。因为缓存行的移动会耗费数百个时钟周期，伪共享会损害性能。</li>
</ul>
<p>使用<code>cache_aligned_allocator&lt;T&gt;</code>类在某个缓存行分配。两个使用<code>cache_aligned_allocator</code>分配的对象能被确保不会使用伪共享。如果一个对象使用<code>cache_aligned_allocator&lt;T&gt;</code>分配，而另外一个对象使用了不同的方式，就没有了这种保证。<code>cache_aligned_allocator&lt;T&gt;</code>的接口类似<code>std::allocator</code>，所以你可以将它作为allocator参数传递给STL的模板类。</p>
<p>下面的代码展示了如何声明一个使用<code>cache_aligned_allocator</code>作为分配器的STL vector：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>,cache_aligned_allocator&lt;<span class="type">int</span>&gt; &gt;;</span><br></pre></td></tr></table></figure>
<p><code>cache_aligned_allocator&lt;T&gt;</code>的设计功能的实现伴随着空间开销，因为它必须至少分配一条缓存行占用的内存，即使是对很小的对象。所以，如果伪共享不成问题，就别使用<code>cache_aligned_allocator&lt;T&gt;</code>。可伸缩内存分配器包含了Intel的PSL CTG团队开发的McRT技术。</p>
<h2 id="动态库的选择"><a href="#动态库的选择" class="headerlink" title="动态库的选择"></a>动态库的选择</h2><p><code>scalable_allocator&lt;T&gt;</code>模板需要Intel TBB 可伸缩内存分配器库。它并不需要Intel TBB的常规库，并且能与Intel TBB独立开来使用。如果没有指定可伸缩分配器库，模板<code>tbb_allocator&lt;T&gt;</code>、<code>cache_aligned_allocator&lt;T&gt;</code>就会使用<code>malloc</code>、<code>free</code>等标准库提供的内存分配函数。因此，甚至可以在忽略可伸缩内存分配器库的应用中使用这些模板。Intel Threading Building Blocks的其余部分，有没有Intel TBB可伸缩内存分配器库都可以使用。</p>
<h2 id="自动替换malloc等C-C-动态内存分配函数"><a href="#自动替换malloc等C-C-动态内存分配函数" class="headerlink" title="自动替换malloc等C/C++动态内存分配函数"></a>自动替换malloc等C/C++动态内存分配函数</h2><p>在windows、Linux操作系统中，可以自动使用Intel TBB中相应的可伸缩实现替换所有标准动态内存分配函数调用（比如：malloc）。在一些场合，可以提升性能。</p>
<h3 id="Linux-C-C-动态内存借口替换"><a href="#Linux-C-C-动态内存借口替换" class="headerlink" title="Linux C/C++动态内存借口替换"></a>Linux C/C++动态内存借口替换</h3><p>替换通过代理库（release：libtbbmalloc_proxy.so.x、debug：libtbbmalloc_proxy_debug.so.x）提供。替换行为可以通过运行时加载代理库（通过LD_PRELOAD）或者链接（linking）代理库实现。代理库实现了以下动态内存函数：</p>
<ul>
<li>C library：malloc，calloc，realloc，free</li>
<li>标准POSIX函数：posix_memalign</li>
<li>废弃的函数：valloc，memalign，pvalloc，mallopt</li>
<li>全局C++操作符：new、delete</li>
</ul>
<p>动态加载时，要保证代理库以及相应的可伸缩内存分配器库可被访问。要做到这点，可通过在<code>LD_LIBRARY_PATH</code>中包含或者将其加入到<code>/etc/ld.so.conf</code>中</p>
<p>下面是一个如何设置<code>LD_PRELOAD</code>以及链接程序使用替换的例子。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set LD_PRELOAD so that loader loads release version of proxy </span></span><br><span class="line">LD_PRELOAD=libtbbmalloc_proxy.so.2 </span><br><span class="line"><span class="comment"># Link with release version of proxy and scalable allocator </span></span><br><span class="line">g++ foo.o bar.o -ltbbmalloc_proxy -ltbbmalloc -o a.out</span><br></pre></td></tr></table></figure></p>
<p>使用Debug版本的库：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set LD_PRELOAD so that loader loads debug version of proxy </span></span><br><span class="line">LD_PRELOAD=libtbbmalloc_proxy_debug.so.2 </span><br><span class="line"><span class="comment"># Link with debug version of proxy and scalable allocator </span></span><br><span class="line">g++ foo.o bar.o -ltbbmalloc_proxy_debug -ltbbmalloc_debug -o a.out</span><br></pre></td></tr></table></figure></p>
<h3 id="windows下C-动态内存接口替换"><a href="#windows下C-动态内存接口替换" class="headerlink" title="windows下C++动态内存接口替换"></a>windows下C++动态内存接口替换</h3><p>替换通过代理库（release：tbbmalloc_proxy.dll，debug：tbbmalloc_debug_proxy.dll）提供。能以下面的任一种方式实现：</p>
<ul>
<li>包含头文件 #include “tbb/tbbmalloc_proxy.h”</li>
<li>设置链接参数 <ul>
<li>对于32位代码：tbbmalloc_proxy.lib /INCLUDE:”___TBB_malloc_proxy”  （三个下划线）</li>
<li>对于64位代码：tbbmalloc_proxy.lib /INCLUDE:”__TBB_malloc_proxy”      （两个下划线）</li>
</ul>
</li>
</ul>
<p>代理库实现了下面的动态内存函数：</p>
<ul>
<li>标准C运行时动态内存函数：malloc，calloc，realloc，free</li>
<li>全局C++操作符：new，delete</li>
<li>Microsoft C运行时库函数：<code>_msize</code></li>
</ul>
<p>同样要保证代理库、可伸缩内存分配库在程序启动时能被加载，例如，可将其路径包含在<code>%PATH%</code>环境变量中。</p>
<h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>可以使用原子操作来避免使用互斥。当一个线程执行原子操作，在其他线程眼里，这个操作是瞬时完成的。原子操作的优点是，相比较锁操作是快速的，而且不用为死锁、锁护送等问题而烦恼。缺点是，它们只有有限的一组操作，常常无法和成为有效的复杂操作。尽管如此，也不应该放弃使用原子操作替换互斥的机会。<code>aotmic&lt;T&gt;</code>类以C++风格实现了原子操作。   </p>
<p>原子操作的一个典型应用是线程安全的引用计数。设x是类型为 int 的引用计数，当它变为0时程序需要做一些操作。在单线程代码中，你可以使用 int 来定义 x，然后<code>--x;if ( x==0 ) action()</code>。但在多线程环境中，这种方法可能会失效，因为两个线程可能以下表的方式交替操作（其中的t(x)代表机器的寄存器）。</p>
<p>下表列出了原子操作模板的5种基本操作：</p>
<ul>
<li><code>= x</code>：读取 x 的值</li>
<li><code>x =</code>：给 x 赋值，并返回它</li>
<li><code>x.fetch_and_store(y)</code>：执行x=y，并返回x的旧值</li>
<li><code>x.fetch_and_add(y)</code>：执行x+=y，并返回x的旧值</li>
<li><code>x.compare_and_swap(y,z)</code>：如果x==z，执行 x=y . 返回x的旧值</li>
</ul>
<p>因为这些操作都是自动的，它们可被在安全应用而不用互斥体。考虑下面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="type">unsigned</span>&gt; counter;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">GetUniqueInteger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> counter.<span class="built_in">fetch_and_add</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例程 GetUniqueInteger 每被调用一次就返回一个不同的整形，直到计数器又从头计数。无论多少个线程同时执行这段代码，都不会出例外。</p>
<p>compare_and_swap 是很多非阻塞算法的基本操作。互斥体的一个问题是，如果持有某个锁的线程挂起了，其他所有线程在它恢复之前都会被阻塞。非阻塞算法用原子操作代替锁来避免这个问题。他们（非阻塞算法）通常很复杂，而且需要复杂的分析去验证。然而，下面的习惯很直观，值得知晓。它以一种基于 globalx 旧值的方式更新 globalx 。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="type">int</span>&gt; globalx;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">UpdateX</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">// Update x and return old value of x. </span></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// Read globalX </span></span><br><span class="line">		oldx = globalx;</span><br><span class="line">		<span class="comment">// Compute new value </span></span><br><span class="line">		newx = ...expression involving oldx....</span><br><span class="line">			<span class="comment">// Store new value if another thread has not changed globalX. </span></span><br><span class="line">	&#125; <span class="keyword">while</span> (globalx.<span class="built_in">compare_and_swap</span>(newx, oldx) != oldx);</span><br><span class="line">	<span class="keyword">return</span> oldx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>比较差的情况下，一些线程迭代循环直到没有其他的线程干预。一般来说，如果更新只需要少数指令，这种方法要快于相应的互斥体解决方案。</p>
<p>注意：如果下述序列不利于你的意图，那么上述的更新方法就不可取：</p>
<ul>
<li>一个线程从 globalx 中读取值 A</li>
<li>其他的线程将 globalx 从 A 修改为 B ，再到 A</li>
<li>步骤1 的线程执行 compare_and_swap， 读取 A ，但没有检测到期间变化到 B</li>
</ul>
<p>这个问题被称为 ABA 问题。为链表数据结构设计设计非阻塞算法时，它常常成为问题。</p>
<h2 id="atomic没有构造函数"><a href="#atomic没有构造函数" class="headerlink" title="atomic没有构造函数"></a>atomic<T>没有构造函数</h2><p><code>atomic&lt;T&gt;</code>模板类特意没有声明构造函数，因为诸如上述的 GetUniqueInteger 之类的例子一般要求在所有的文件作用域构造函数被调用前就可以工作。如果该模板类声明了构造函数，在它被引用后，也许要初始化一个文件作用域的实例。在下述上下文中，任何没有生命构造函数的 C++类的原子类型<code>atomic&lt;T&gt;</code>的对象 X 被自动初始化为 0 ：</p>
<ul>
<li>X 被声明为文件作用域变量，或者类的静态数据成员</li>
<li>X 是类的成员，并且显式地出现在该类的构造函数的初始化列表中</li>
</ul>
<p>下面的代码是对这些问题的解释</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">atomic&lt;<span class="type">int</span>&gt; x; <span class="comment">// 由于处于文件作用域，初始化为0 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">	atomic&lt;<span class="type">int</span>&gt; y;</span><br><span class="line">	atomic&lt;<span class="type">int</span>&gt; notzeroed;</span><br><span class="line">	<span class="type">static</span> atomic&lt;<span class="type">int</span>&gt; z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Foo</span>() :</span><br><span class="line">		<span class="built_in">y</span>() <span class="comment">// y 初始化为0. </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// notzeroed has unspecified value here. </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; Foo::z; <span class="comment">// 静态成员，初始化为0</span></span><br></pre></td></tr></table></figure>
<h1 id="异常与终止"><a href="#异常与终止" class="headerlink" title="异常与终止"></a>异常与终止</h1><p>Intel TBB支持异常与终止（cancellation），当算法中的代码抛出异常时，会按依次发生：</p>
<ul>
<li>捕获异常。算法内进一步的异常被忽略。</li>
<li>算法终止。挂起的迭代操作不被执行。如果内部存在嵌套的Intel TBB并行，那么它的取消与否取决于特定实现（下面会提到）</li>
<li>算法的所有部分都停止后，会在调用算法的线程（thread）上抛出异常。</li>
</ul>
<p>步骤3中抛出的异常可能是初始的异常，也可能仅仅是captured_exception类型的摘要。后者常发生在当前的系统中，因为在线程间传递异常需要支持C++的std::exception_ptr机制。随着编译器在支持此项特性上的进展，将来的Intel TBB版本可能抛出初始的异常。所以，确保你的代码可以捕获两种异常中的任意异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; Data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Update</span> &#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> blocked_range&lt;<span class="type">int</span>&gt;&amp; r)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i) Data.<span class="built_in">at</span>(i) += <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Data.<span class="built_in">resize</span>(<span class="number">1000</span>);</span><br><span class="line">   <span class="keyword">try</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, <span class="number">2000</span>), <span class="built_in">Update</span>());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">catch</span> (captured_exception&amp; ex)</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;captured_exception: &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">catch</span> (out_of_range&amp; ex)</span><br><span class="line">   &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;out_of_range: &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="无异常终止"><a href="#无异常终止" class="headerlink" title="无异常终止"></a>无异常终止</h2><p>要取消某个算法而不抛出异常，使用表达式<code>task::self().cancel_group_execution()</code>. 其中的<code>task::self()</code>引用当前线程最靠内的Intel TBB任务。调用<code>cancel_group_execution()</code>取消它的<code>task_group_context</code>中的所以线程（下节会详细介绍）。如果的确导致了任务终止，此方法会返回 true ，如果task_group_context 已经被取消，就会返回 false。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tbb/tbb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> tbb;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; Data;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Update</span> &#123;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">const</span> blocked_range&lt;<span class="type">int</span>&gt;&amp; r)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = r.<span class="built_in">begin</span>(); i != r.<span class="built_in">end</span>(); ++i) <span class="keyword">if</span> (i &lt; Data.<span class="built_in">size</span>())</span><br><span class="line">         &#123;</span><br><span class="line">            ++Data[i];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">            <span class="comment">// Cancel related tasks.</span></span><br><span class="line">            <span class="keyword">if</span> (task::<span class="built_in">self</span>().<span class="built_in">cancel_group_execution</span>()) </span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; caused cancellation\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Data.<span class="built_in">resize</span>(<span class="number">1000</span>);</span><br><span class="line">   <span class="built_in">parallel_for</span>(<span class="built_in">blocked_range</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>, <span class="number">2000</span>), <span class="built_in">Update</span>());</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/4/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">130</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
