<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="开始leveldb是由Google两位大牛开发的单机KV存储系统，涉及到了skip list、内存KV table、LRU cache管理、table文件存储、operation log系统等。开始之前先来看看Leveldb的基本框架，几大关键组件 leveldb是一种基于operation log的文件系统，是Log-Structured-Merge Tree的典型实现。LSM源自Ousterh">
<meta property="og:type" content="article">
<meta property="og:title" content="leveldb源码分析">
<meta property="og:url" content="http://yoursite.com/2022/01/30/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="开始leveldb是由Google两位大牛开发的单机KV存储系统，涉及到了skip list、内存KV table、LRU cache管理、table文件存储、operation log系统等。开始之前先来看看Leveldb的基本框架，几大关键组件 leveldb是一种基于operation log的文件系统，是Log-Structured-Merge Tree的典型实现。LSM源自Ousterh">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/leveldb1.png">
<meta property="og:image" content="http://yoursite.com/img/leveldb2.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb3.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb4.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb5.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb6.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb7.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb8.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb9.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb10.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb11.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb12.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb13.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb14.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb15.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb16.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb17.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb18.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb19.webp">
<meta property="og:image" content="http://yoursite.com/img/leveldb20.webp">
<meta property="article:published_time" content="2022-01-30T03:14:00.000Z">
<meta property="article:modified_time" content="2022-01-31T07:05:45.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/leveldb1.png">

<link rel="canonical" href="http://yoursite.com/2022/01/30/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>leveldb源码分析 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/resume.pdf" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">128</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/01/30/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          leveldb源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-30 11:14:00" itemprop="dateCreated datePublished" datetime="2022-01-30T11:14:00+08:00">2022-01-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-31 15:05:45" itemprop="dateModified" datetime="2022-01-31T15:05:45+08:00">2022-01-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>leveldb是由Google两位大牛开发的单机KV存储系统，涉及到了skip list、内存KV table、LRU cache管理、table文件存储、operation log系统等。开始之前先来看看Leveldb的基本框架，几大关键组件<br><img src="/img/leveldb1.png" alt=""></p>
<p>leveldb是一种<strong>基于operation log的文件系统，是Log-Structured-Merge Tree的典型实现</strong>。LSM源自Ousterhout和Rosenblum在1991年发表的经典论文&lt;&lt;<em>The Design and Implementation of a Log-Structured File System</em> &gt;&gt;。</p>
<p>由于<strong>采用了op log</strong>，它就可以把随机的磁盘写操作，变成了对op log的append操作，因此提高了IO效率，最新的数据则存储在内存memtable中。</p>
<p>当<strong>op log文件</strong>大小超过限定值时，就定时做<strong>check point</strong>。Leveldb会生成新的Log文件和<strong>Memtable</strong>，后台调度会将<strong>Immutable Memtable</strong>的数据导出到磁盘，形成一个新的<strong>SSTable</strong>文件。SSTable就是由内存中的数据不断导出并进行<strong>Compaction操作</strong>后形成的，而且SSTable的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，依次类推，层级逐渐增高，这也是为何称之为LevelDb的原因。</p>
<h1 id="1-一些约定"><a href="#1-一些约定" class="headerlink" title="1. 一些约定"></a>1. 一些约定</h1><p>先说下代码中的一些约定：</p>
<h2 id="1-1-字节序"><a href="#1-1-字节序" class="headerlink" title="1.1 字节序"></a>1.1 字节序</h2><p>Leveldb<strong>对于数字的存储是little-endian的</strong>，在把int32或者int64转换为char*的函数中，是按照先低位再高位的顺序存放的，也就是little-endian的。</p>
<h2 id="1-2-VarInt"><a href="#1-2-VarInt" class="headerlink" title="1.2 VarInt"></a>1.2 VarInt</h2><p>把一个int32或者int64格式化到字符串中，除了上面说的little-endian字节序外，大部分还是变长存储的，也就是VarInt。对于VarInt，每byte的有效存储是7bit的，用最高的8bit位来表示是否结束，如果是1就表示后面还有一个byte的数字，否则表示结束。直接见Encode和Decode函数。</p>
<p><strong>在操作log中使用的是Fixed存储格式。</strong></p>
<h2 id="1-3-字符比较"><a href="#1-3-字符比较" class="headerlink" title="1.3 字符比较"></a>1.3 字符比较</h2><p>是基于<strong>unsigned</strong> char的，而非char。</p>
<h1 id="2-基本数据结构"><a href="#2-基本数据结构" class="headerlink" title="2. 基本数据结构"></a>2. 基本数据结构</h1><p>别看是基本数据结构，有些也不是那么简单的，像<strong>LRU Cache管理和Skip list那都算是leveldb的核心数据结构。</strong></p>
<h2 id="2-1-Slice"><a href="#2-1-Slice" class="headerlink" title="2.1 Slice"></a>2.1 Slice</h2><p>Leveldb中的基本数据结构：</p>
<ol>
<li>包括length和一个指向外部字节数组的指针。</li>
<li>和string一样，允许字符串中包含’\0’。</li>
</ol>
<p>提供一些基本接口，可以把const char和string转换为Slice；把Slice转换为string，取得数据指针const char。</p>
<h2 id="2-2-Status"><a href="#2-2-Status" class="headerlink" title="2.2 Status"></a>2.2 Status</h2><p>Leveldb 中的<strong>返回状态</strong>，将错误号和错误信息封装成Status类，统一进行处理。并定义了几种具体的返回状态，如成功或者文件不存在等。</p>
<p>为了节省空间Status并没有用std::string来<strong>存储错误信息</strong>，而是将返回码(code), 错误信息message及长度打包存储于一个字符串数组中。</p>
<p>成功状态OK 是NULL state_，否则state_ 是一个包含如下信息的数组:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">state_[0..3] == 消息message长度 </span><br><span class="line">state_[4]    == 消息code</span><br><span class="line">state_[5..]  ==消息message </span><br></pre></td></tr></table></figure>
<h2 id="2-3-Arena"><a href="#2-3-Arena" class="headerlink" title="2.3 Arena"></a>2.3 Arena</h2><p>Leveldb的简单的内存池，它所作的工作十分简单，申请内存时，将申请到的内存块放入std::vector blocks_中，在Arena的生命周期结束后，统一释放掉所有申请到的内存，内部结构如图2.3-1所示。</p>
<p><img src="/img/leveldb2.webp" alt=""></p>
<p><strong>Arena主要提供了两个申请函数</strong>：其中一个直接分配内存，另一个可以申请对齐的内存空间。</p>
<p>Arena没有直接调用delete/free函数，而是由Arena的析构函数统一释放所有的内存。</p>
<p>应该说这是和leveldb特定的应用场景相关的，比如一个memtable使用一个Arena，当memtable被释放时，由Arena统一释放其内存。</p>
<h2 id="2-4-Skip-list"><a href="#2-4-Skip-list" class="headerlink" title="2.4 Skip list"></a>2.4 Skip list</h2><p><strong>Skip list(跳跃表）是一种可以代替平衡树的数据结构。</strong>Skip lists应用概率保证平衡，平衡树采用严格的旋转（比如平衡二叉树有左旋右旋）来保证平衡，因此Skip list比较容易实现，而且相比平衡树有着较高的运行效率。</p>
<p>从概率上保持数据结构的平衡比显式的保持数据结构平衡要简单的多。<strong>对于大多数应用，用skip list要比用树更自然，算法也会相对简单</strong>。由于skip list比较简单，实现起来会比较容易，虽然和平衡树有着相同的时间复杂度(O(logn))，但是skip list的常数项相对小很多。skip list在空间上也比较节省。一个节点平均只需要1.333个指针（甚至更少），并且不需要存储保持平衡的变量。</p>
<p>如图2.4-1所示。</p>
<p><img src="/img/leveldb3.webp" alt=""></p>
<p>在Leveldb中，<strong>skip list是实现memtable的核心数据结构，memtable的KV数据都存储在skip list中。</strong></p>
<h2 id="2-5-Cache"><a href="#2-5-Cache" class="headerlink" title="2.5 Cache"></a>2.5 Cache</h2><p><strong>Leveldb内部通过双向链表实现了一个标准版的LRUCache</strong>，先上个示意图，看看几个数据之间的关系，如图2.5-1。</p>
<p><img src="/img/leveldb4.webp" alt=""></p>
<h3 id="Leveldb实现LRUCache的几个步骤"><a href="#Leveldb实现LRUCache的几个步骤" class="headerlink" title="Leveldb实现LRUCache的几个步骤"></a>Leveldb实现LRUCache的几个步骤</h3><p>接下来说说Leveldb实现LRUCache的几个步骤，很直观明了。</p>
<h4 id="S1"><a href="#S1" class="headerlink" title="S1"></a>S1</h4><p>定义一个LRUHandle结构体，代表cache中的元素。它包含了几个主要的成员：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void* value; </span><br></pre></td></tr></table></figure>
<p>这个存储的是cache的数据；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (*deleter)(const Slice&amp;, void* value);</span><br></pre></td></tr></table></figure>
<p>这个是数据从Cache中清除时执行的清理函数；</p>
<p>后面的三个成员事关LRUCache的数据的组织结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRUHandle *next_hash;</span><br></pre></td></tr></table></figure>
<p>指向节点在hash table链表中的下一个hash(key)相同的元素，在有碰撞时Leveldb采用的是链表法。最后一个节点的next_hash为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRUHandle *next, *prev;</span><br></pre></td></tr></table></figure>
<p>节点在双向链表中的前驱后继节点指针，所有的cache数据都是存储在一个双向list中，最前面的是最新加入的，每次新加入的位置都是head-&gt;next。所以<strong>每次剔除的规则就是剔除list tail。</strong></p>
<h4 id="S2"><a href="#S2" class="headerlink" title="S2"></a>S2</h4><p>Leveldb自己实现了一个hash table：<strong>HandleTable</strong>，而不是使用系统提供的hash table。这个类就是基本的hash操作<strong>：Lookup、Insert和Delete</strong>。</p>
<p>Hash table的作用是根据key快速查找元素是否在cache中，并返回LRUHandle节点指针，由此就能快速定位节点在hash表和双向链表中的位置。</p>
<p>它是通过LRUHandle的成员next_hash组织起来的。</p>
<p>HandleTable使用LRUHandle <strong>list_存储所有的hash节点，</strong>其实就是一个二维数组，**一维是不同的hash(key)，另一维则是相同hash(key)的碰撞list。</p>
<p>每次当hash节点数超过当前一维数组的长度后，都会做Resize操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRUHandle** new_list = new LRUHandle*[new_length];</span><br></pre></td></tr></table></figure>
<p>然后复制list_到new_list中，并删除旧的list_。</p>
<h4 id="S3"><a href="#S3" class="headerlink" title="S3"></a>S3</h4><p>基于HandleTable和LRUHandle，<strong>实现了一个标准的LRUcache，并内置了mutex保护锁，是线程安全的。</strong></p>
<p>其中存储所有数据的双向链表是LRUHandle lru_，这是一个list head；</p>
<p>Hash表则是HandleTable table_；</p>
<h4 id="S4"><a href="#S4" class="headerlink" title="S4"></a>S4</h4><p>ShardedLRUCache类，实际上到S3，一个标准的LRU Cache已经实现了，为何还要更近一步呢？答案就是速度！</p>
<p>为了多线程访问，尽可能快速，减少锁开销，ShardedLRUCache内部有16个LRUCache，查找Key时首先计算key属于哪一个分片，<strong>分片的计算方法</strong>是取32位hash值的高4位，然后在相应的LRUCache中进行查找，这样就大大减少了多线程的访问锁的开销。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRUCache shard_[kNumShards]</span><br></pre></td></tr></table></figure>
<p>它就是一个包装类，实现都在LRUCache类中。</p>
<h2 id="2-6-其它"><a href="#2-6-其它" class="headerlink" title="2.6 其它"></a>2.6 其它</h2><p>此外还有其它几个<strong>Random、Hash、CRC32、Histogram</strong>等，都在util文件夹下，不仔细分析了。</p>
<h1 id="3-Int-Coding"><a href="#3-Int-Coding" class="headerlink" title="3.Int Coding"></a>3.Int Coding</h1><p>轻松一刻，前面约定中讲过Leveldb使用了很多VarInt型编码，典型的如后面将涉及到的各种key。其中的<strong>编码、解码函数分为VarInt和FixedInt两种</strong>。int32和int64操作都是类似的。</p>
<h2 id="3-1-Eecode"><a href="#3-1-Eecode" class="headerlink" title="3.1 Eecode"></a>3.1 Eecode</h2><p>首先是<strong>FixedInt编码</strong>，直接上代码，很简单明了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EncodeFixed32</span><span class="params">(<span class="type">char</span>* buf, <span class="type">uint32_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (port::kLittleEndian) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, &amp;value,<span class="keyword">sizeof</span>(value));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    buf[<span class="number">0</span>] = value &amp; <span class="number">0xff</span>;</span><br><span class="line">    buf[<span class="number">1</span>] = (value &gt;&gt; <span class="number">8</span>)&amp; <span class="number">0xff</span>;</span><br><span class="line">    buf[<span class="number">2</span>] = (value &gt;&gt; <span class="number">16</span>)&amp; <span class="number">0xff</span>;</span><br><span class="line">    buf[<span class="number">3</span>] = (value &gt;&gt; <span class="number">24</span>)&amp; <span class="number">0xff</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是<strong>VarInt编码</strong>，int32和int64格式，代码如下，有效位是7bit的，因此把uint32按7bit分割，对unsigned char赋值时，超出0xFF会自动截断，因此直接<code>*(ptr++) = v|B</code>即可，不需要再把<code>(v|B)与0xFF</code>作&amp;操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">EncodeVarint32</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint32_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>* ptr =reinterpret_cast&lt;<span class="type">unsigned</span> <span class="type">char</span>*&gt;(dst);</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">7</span>)) &#123;</span><br><span class="line">    *(ptr++) = v;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">14</span>))&#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">7</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">21</span>))&#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">14</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">28</span>))&#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">21</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">21</span>) | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">28</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> reinterpret_cast&lt;<span class="type">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于uint64，直接循环</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">EncodeVarint64</span><span class="params">(<span class="type">char</span>* dst, <span class="type">uint64_t</span> v)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>* ptr =reinterpret_cast&lt;<span class="type">unsigned</span> <span class="type">char</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">while</span> (v &gt;= B) &#123;</span><br><span class="line">    *(ptr++) = (v &amp; (B<span class="number">-1</span>)) |B;</span><br><span class="line">    v &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *(ptr++) =static_cast&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(v);</span><br><span class="line">  returnreinterpret_cast&lt;<span class="type">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-Decode"><a href="#3-2-Decode" class="headerlink" title="3.2 Decode"></a>3.2 Decode</h2><p><strong>Fixed Int的Decode</strong>，操作，代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">DecodeFixed32</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (port::kLittleEndian) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> result;</span><br><span class="line">    <span class="comment">// gcc optimizes this to a plain load</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;result, ptr,<span class="keyword">sizeof</span>(result));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>((static_cast&lt;<span class="type">uint32_t</span>&gt;(static_cast&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(ptr[<span class="number">0</span>])))</span><br><span class="line">        |(static_cast&lt;<span class="type">uint32_t</span>&gt;(static_cast&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(ptr[<span class="number">1</span>])) &lt;&lt;<span class="number">8</span>)</span><br><span class="line">        | (static_cast&lt;<span class="type">uint32_t</span>&gt;(static_cast&lt;unsignedchar&gt;(ptr[<span class="number">2</span>])) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">        |(static_cast&lt;<span class="type">uint32_t</span>&gt;(static_cast&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(ptr[<span class="number">3</span>])) &lt;&lt;<span class="number">24</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看看<strong>VarInt的解码</strong>，很简单，依次读取1byte，直到最高位为0的byte结束，取低7bit，作(&lt;&lt;7)移位操作组合成Int。看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">GetVarint32Ptr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="type">char</span>* limit, </span></span><br><span class="line"><span class="params">                           <span class="type">uint32_t</span>* value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (p &lt; limit) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> result =*(reinterpret_cast&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*&gt;(p));</span><br><span class="line">    <span class="keyword">if</span> ((result &amp; <span class="number">128</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> GetVarint32PtrFallback(p,limit, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">GetVarint32PtrFallback</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> <span class="type">char</span>* limit,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint32_t</span>* value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> shift = <span class="number">0</span>; shift&lt;= <span class="number">28</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> byte =*(reinterpret_cast&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>*&gt;(p));</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (byte &amp; <span class="number">128</span>) &#123; <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((byte &amp; <span class="number">127</span>)&lt;&lt; shift);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result |= (byte &lt;&lt;shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      returnreinterpret_cast&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-Memtable之一"><a href="#4-Memtable之一" class="headerlink" title="4. Memtable之一"></a>4. Memtable之一</h1><p>Memtable是leveldb很重要的一块，leveldb的核心之一。我们肯定<strong>关注KV数据在Memtable中是如何组织的，秘密在Skip list中。</strong></p>
<h2 id="4-1-用途"><a href="#4-1-用途" class="headerlink" title="4.1 用途"></a>4.1 用途</h2><p>在Leveldb中，所有内存中的KV数据都存储在Memtable中，物理disk则存储在SSTable中。在系统运行过程中，如果Memtable中的数据占用内存到达指定值(Options.write_buffer_size)，则Leveldb就自动将Memtable转换为Memtable，并自动生成新的Memtable，也就是<strong>Copy-On-Write机制</strong>了。</p>
<p>Immutable Memtable则被新的线程Dump到磁盘中，Dump结束则该Immutable Memtable就可以释放了。因名知意，<strong>Immutable Memtable是只读的</strong>。</p>
<p><strong>所以可见，最新的数据都是存储在Memtable中的，Immutable Memtable和物理SSTable则是某个时点的数据。</strong></p>
<p>为了防止系统down机导致内存数据Memtable或者Immutable Memtable丢失，leveldb自然也<strong>依赖于log机制来保证可靠性</strong>了。</p>
<p>Memtable提供了写入KV记录，删除以及读取KV记录的接口，但是事实上<strong>Memtable并不执行真正的删除操作,</strong>删除某个Key的Value在Memtable内是作为插入一条记录实施的，但是会打上一个Key的删除标记，<strong>真正的删除操作在后面的 Compaction过程中，lazy delete。</strong></p>
<h2 id="4-2-核心是Skip-list"><a href="#4-2-核心是Skip-list" class="headerlink" title="4.2 核心是Skip list"></a>4.2 核心是Skip list</h2><p>另外，Memtable中的<strong>KV对是根据Key排序的</strong>，leveldb在插入等操作时保证key的有序性。想想，前面看到的Skip list不正是合适的人选吗，<strong>因此Memtable的核心数据结构是一个Skip list，Memtable只是一个接口类</strong>。当然随之而来的一个问题就是Skip list是如何组织KV数据对的，在后面分析Memtable的插入、查询接口时我们将会看到答案。</p>
<h2 id="4-3-接口说明"><a href="#4-3-接口说明" class="headerlink" title="4.3 接口说明"></a>4.3 接口说明</h2><p>先来看看Memtable的接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Ref</span><span class="params">()</span> &#123; ++refs_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Unref</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">Iterator* <span class="title function_">NewIterator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Add</span><span class="params">(SequenceNumber seq,</span></span><br><span class="line"><span class="params">          ValueType type,</span></span><br><span class="line"><span class="params">          <span class="type">const</span> Slice&amp; key,</span></span><br><span class="line"><span class="params">          <span class="type">const</span> Slice&amp; value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Get</span><span class="params">(<span class="type">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s)</span>;</span><br></pre></td></tr></table></figure>
<p>首先Memtable是基于引用计数的机制，如果引用计数为0，则在Unref中删除自己，<strong>Ref和Unref</strong>就是干这个的。</p>
<ul>
<li><strong>NewIterator</strong>是返回一个迭代器，可以遍历访问table的内部数据，很好的设计思想，这种方式隐藏了table的内部实现。外部调用者必须保证使用Iterator访问Memtable的时候该Memtable是live的。</li>
<li><strong>Add和Get</strong>是添加和获取记录的接口，没有Delete，还记得前面说过，memtable的delete实际上是插入一条type为kTypeDeletion的记录。</li>
</ul>
<h2 id="4-4-类图"><a href="#4-4-类图" class="headerlink" title="4.4 类图"></a>4.4 类图</h2><p>先来看看Memtable相关的<strong>整体类层次</strong>吧，并不复杂，还是相当清晰的。见图。</p>
<p><img src="/img/leveldb5.webp" alt=""></p>
<h2 id="4-5-Key结构"><a href="#4-5-Key结构" class="headerlink" title="4.5 Key结构"></a>4.5 Key结构</h2><p>Memtable是一个KV存储结构，那么这个<strong>key肯定是个重点</strong>了，在分析接口实现之前，有必要仔细分析一下Memtable对key的使用。</p>
<p>这里面有5个key的概念，可能会让人混淆，下面就来一个一个的分析。</p>
<h3 id="4-5-1-InternalKey-amp-ParsedInternalKey-amp-User-Key"><a href="#4-5-1-InternalKey-amp-ParsedInternalKey-amp-User-Key" class="headerlink" title="4.5.1 InternalKey &amp; ParsedInternalKey &amp; User Key"></a>4.5.1 InternalKey &amp; ParsedInternalKey &amp; User Key</h3><p><strong>InternalKey</strong>是一个复合概念，是有几个部分组合成的一个key，<strong>ParsedInternalKey</strong>就是对InternalKey分拆后的结果，先来看看ParsedInternalKey的成员，这是一个struct：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Slice user_key;</span><br><span class="line"></span><br><span class="line">SequenceNumber sequence;</span><br><span class="line"></span><br><span class="line">ValueType type;</span><br></pre></td></tr></table></figure>
<p>也就是说InternalKey是由User key + SequenceNumber + ValueType组合而成的，顺便先分析下几个Key相关的函数，它们是了解Internal Key和User Key的关键。</p>
<p>首先是<strong>InternalKey和ParsedInternalKey</strong>相互转换的两个函数，如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ParseInternalKey</span> <span class="params">(<span class="type">const</span> Slice&amp; internal_key,</span></span><br><span class="line"><span class="params">                       ParsedInternalKey* result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AppendInternalKey</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* result,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> ParsedInternalKey&amp; key)</span>;</span><br></pre></td></tr></table></figure>
<p>函数实现很简单，就是字符串的拼接与把字符串按字节拆分，代码略过。根据实现，容易得到<strong>InternalKey的格式</strong>为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| User <span class="title function_">key</span> <span class="params">(<span class="built_in">string</span>)</span> | sequence <span class="title function_">number</span> <span class="params">(<span class="number">7</span> bytes)</span> | value <span class="title function_">type</span> <span class="params">(<span class="number">1</span> byte)</span> |</span><br></pre></td></tr></table></figure>
<p>由此还可知道sequence number大小是7 bytes，<strong>sequence number是所有基于op log系统的关键数据</strong>，它唯一指定了不同操作的时间顺序。</p>
<p>把<strong>user key放到前面**</strong>的原因**是，这样对同一个user key的操作就可以按照sequence number顺序连续存放了，不同的user key是互不相干的，因此把它们的操作放在一起也没有什么意义。</p>
<p>另外用户可以为user key定制比较函数，系统默认是字母序的。</p>
<p>下面的两个函数是分别从InternalKey中拆分出<strong>User Key和Value Type</strong>的，非常直观，代码也附上吧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Slice <span class="title function_">ExtractUserKey</span><span class="params">(<span class="type">const</span> Slice&amp; internal_key)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(internal_key.size() &gt;= <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> Slice(internal_key.data(), internal_key.size() - <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ValueType <span class="title function_">ExtractValueType</span><span class="params">(<span class="type">const</span> Slice&amp; internal_key)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(internal_key.size() &gt;= <span class="number">8</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> n = internal_key.size();</span><br><span class="line">    <span class="type">uint64_t</span> num = DecodeFixed64(internal_key.data() + n - <span class="number">8</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c = num &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span> static_cast&lt;ValueType&gt;(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-2-LookupKey-amp-Memtable-Key"><a href="#4-5-2-LookupKey-amp-Memtable-Key" class="headerlink" title="4.5.2 LookupKey &amp; Memtable Key"></a>4.5.2 LookupKey &amp; Memtable Key</h3><p>Memtable的<strong>查询接口传入的是LookupKey</strong>，它也是由User Key和Sequence Number组合而成的，从其构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LookupKey(const Slice&amp; user_key, SequenceNumber s)</span><br></pre></td></tr></table></figure>
<p>中分析出LookupKey的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| Size (int32变长)| User key (string) | sequence number (7 bytes) | value type (1 byte) |</span><br></pre></td></tr></table></figure>
<p>两点：</p>
<ul>
<li>这里的Size是user key长度+8，也就是整个字符串长度了；</li>
<li>value type是kValueTypeForSeek，它等于kTypeValue。</li>
</ul>
<p>由于LookupKey的size是变长存储的，因此它使用kstart_记录了user key string的起始地址，否则将不能正确的获取size和user key；</p>
<p>LookupKey导出了三个函数，可以分别从LookupKey得到<strong>Internal Key</strong>，<strong>Memtable Key</strong>和<strong>User Key</strong>，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a key suitable for lookup in a MemTable.</span></span><br><span class="line">Slice <span class="title function_">memtable_key</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> Slice(start_, end_ - start_); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return an internal key (suitable for passing to an internal iterator)</span></span><br><span class="line">Slice <span class="title function_">internal_key</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> Slice(kstart_, end_ - kstart_); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the user key</span></span><br><span class="line">Slice <span class="title function_">user_key</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> Slice(kstart_, end_ - kstart_ - <span class="number">8</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>其中<strong>start_</strong>是LookupKey字符串的开始，<strong>end_</strong>是结束，<strong>kstart_</strong>是start_+4，也就是user key字符串的起始地址。</p>
<h1 id="4-Memtable之2"><a href="#4-Memtable之2" class="headerlink" title="4.Memtable之2"></a>4.Memtable之2</h1><h2 id="4-6-Comparator"><a href="#4-6-Comparator" class="headerlink" title="4.6 Comparator"></a>4.6 Comparator</h2><p>弄清楚了key，接下来就要看看key的使用了，先从<strong>Comparator</strong>开始分析。首先Comparator是一个抽象类，导出了几个接口。</p>
<p>其中<strong>Name()</strong>和<strong>Compare()</strong>接口都很明了，另外的两个Find xxx接口都有什么功能呢，直接看程序注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Advanced functions: these are used to reduce the space requirements </span></span><br><span class="line"><span class="comment">//for internal data structures like index blocks.                      </span></span><br><span class="line"><span class="comment">// 这两个函数：用于减少像index blocks这样的内部数据结构占用的空间</span></span><br><span class="line"><span class="comment">// 其中的*start和*key参数都是IN OUT的。</span></span><br><span class="line"><span class="comment">//If *start &lt; limit, changes *start to a short string in [start,limit).</span></span><br><span class="line"><span class="comment">//Simple comparator implementations may return with *start unchanged,</span></span><br><span class="line"><span class="comment">//i.e., an implementation of this method that does nothing is correct.</span></span><br><span class="line"><span class="comment">// 这个函数的作用就是：如果*start &lt; limit，就在[startlimit,)中找到一个</span></span><br><span class="line"><span class="comment">// 短字符串，并赋给*start返回</span></span><br><span class="line"><span class="comment">// 简单的comparator实现可能不改变*start，这也是正确的</span></span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">FindShortestSeparator</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* start, </span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> Slice&amp; limit)</span> <span class="type">const</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//Changes *key to a short string &gt;= *key.</span></span><br><span class="line"><span class="comment">//Simple comparator implementations may return with *key unchanged,</span></span><br><span class="line"><span class="comment">//i.e., an implementation of this method that does nothing is correct. </span></span><br><span class="line"><span class="comment">//这个函数的作用就是：找一个&gt;= *key的短字符串</span></span><br><span class="line"><span class="comment">//简单的comparator实现可能不改变*key，这也是正确的</span></span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">FindShortSuccessor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* key)</span> <span class="type">const</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>其中的<strong>实现类有两个</strong>，一个是<strong>内置的BytewiseComparatorImpl</strong>，另一个是<strong>InternalKeyComparator</strong>。下面分别来分析。</p>
<h3 id="4-6-1-BytewiseComparatorImpl"><a href="#4-6-1-BytewiseComparatorImpl" class="headerlink" title="4.6.1 BytewiseComparatorImpl"></a>4.6.1 BytewiseComparatorImpl</h3><p>首先是重载的Name和比较函数，比较函数如其名，就是字符串比较，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="type">const</span> <span class="type">char</span>* <span class="title function_">Name</span><span class="params">()</span> <span class="type">const</span> &#123;<span class="keyword">return</span><span class="string">&quot;leveldb.BytewiseComparator&quot;</span>;&#125;</span><br><span class="line">virtual <span class="type">int</span> <span class="title function_">Compare</span><span class="params">(<span class="type">const</span> Slice&amp; a, <span class="type">const</span> Slice&amp; b)</span> <span class="type">const</span> &#123;<span class="keyword">return</span> a.compare(b);&#125;</span><br></pre></td></tr></table></figure>
<p>再来看看Byte wise的comparator是如何实现<strong>FindShortestSeparator()</strong>的，没什么特别的，代码 + 注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="type">void</span> <span class="title function_">FindShortestSeparator</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* start, </span></span><br><span class="line"><span class="params">                                   onst Slice&amp; limit)</span> <span class="type">const</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 首先计算共同前缀字符串的长度</span></span><br><span class="line">  <span class="type">size_t</span> min_length = <span class="built_in">std</span>::min(start-&gt;size(), limit.size());</span><br><span class="line">  <span class="type">size_t</span> diff_index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ((diff_index &lt; min_length) &amp;&amp;</span><br><span class="line">        ((*start)[diff_index] == limit[diff_index]))</span><br><span class="line">  &#123;</span><br><span class="line">     diff_index++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (diff_index &gt;= min_length) </span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">// 说明*start是limit的前缀，或者反之，此时不作修改，直接返回</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">// 尝试执行字符start[diff_index]++，</span></span><br><span class="line">        设置start长度为diff_index+<span class="number">1</span>，并返回</span><br><span class="line">     <span class="comment">// ++条件：字符&lt; oxff 并且字符+1 &lt; limit上该index的字符</span></span><br><span class="line">     <span class="type">uint8_t</span> diff_byte = static_cast&lt;<span class="type">uint8_t</span>&gt;((*start)[diff_index]);</span><br><span class="line">     <span class="keyword">if</span> (diff_byte &lt; static_cast&lt;<span class="type">uint8_t</span>&gt;(<span class="number">0xff</span>) &amp;&amp;</span><br><span class="line">         diff_byte + <span class="number">1</span> &lt; static_cast&lt;<span class="type">uint8_t</span>&gt;(limit[diff_index])) </span><br><span class="line">     &#123;</span><br><span class="line">         (*start)[diff_index]++;</span><br><span class="line">         start-&gt;resize(diff_index + <span class="number">1</span>);</span><br><span class="line">          assert(Compare(*start, limit) &lt; <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是<code>FindShortSuccessor()</code>，这个更简单了，代码+注释如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="type">void</span> <span class="title function_">FindShortSuccessor</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* key)</span> <span class="type">const</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 找到第一个可以++的字符，执行++后，截断字符串；</span></span><br><span class="line">    <span class="comment">// 如果找不到说明*key的字符都是0xff啊，那就不作修改，直接返回</span></span><br><span class="line">    <span class="type">size_t</span> n = key-&gt;size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">uint8_t</span> byte = (*key)[i];</span><br><span class="line">        <span class="keyword">if</span> (byte != static_cast&lt;<span class="type">uint8_t</span>&gt;(<span class="number">0xff</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            (*key)[i] = byte + <span class="number">1</span>;</span><br><span class="line">            key-&gt;resize(i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Leveldb内建的基于<strong>Byte wise</strong>的comparator类就这么多内容了，下面再来看看InternalKeyComparator。</p>
<h3 id="4-6-2-InternalKeyComparator"><a href="#4-6-2-InternalKeyComparator" class="headerlink" title="4.6.2 InternalKeyComparator"></a>4.6.2 InternalKeyComparator</h3><p>从上面对Internal Key的讨论可知，由于它是由<strong>user key和sequence number和value type组合而成</strong>的，因此它还需要user key的比较，所以InternalKeyComparator有一个Comparator<em> user_comparator_成员，用于<em>*user key</em></em>的比较。</p>
<p>在leveldb中的名字为：”leveldb.InternalKeyComparator”，下面来看看比较函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Compare(<span class="type">const</span> Slice&amp; akey, <span class="type">const</span> Slice&amp; bkey)</span><br></pre></td></tr></table></figure>
<p>代码很简单，其比较逻辑是：</p>
<ul>
<li>S1 首先比较user key，基于用户设置的comparator，如果<strong>user key不相等</strong>就直接<strong>返回比较</strong>,<strong>否则</strong>执行进入S2</li>
<li>S2 取出8字节的sequence number | value type，如果akey的 <strong>&gt; bkey</strong>的则返回<strong>-1</strong>，如果akey的<strong>&lt;bkey</strong>的返回<strong>1</strong>，<strong>相等</strong>返回<strong>0</strong></li>
</ul>
<p>由此可见其排序比较依据依次是：</p>
<ol>
<li>首先根据user key按升序排列</li>
<li>然后根据sequence number按降序排列</li>
<li>最后根据value type按降序排列</li>
</ol>
<p>虽然比较时value type并不重要，因为sequence number是唯一的，但是直接取出8byte的sequence number | value type，然后做比较<strong>更方便</strong>，不需要再次移位提取出7byte的sequence number，又何乐而不为呢。这也是把value type安排在低7byte的好处吧，排序的两个依据就是<strong>user key和sequence number</strong>。</p>
<p>接下来就该看看其<strong>FindShortestSeparator()函数</strong>实现了，该函数取出Internal Key中的user key字段，根据user指定的comparator找到并替换start，如果start被替换了，就用<strong>新的start更新Internal Key</strong>，并使用最大的<strong>sequence number</strong>。否则保持不变。</p>
<p>函数声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InternalKeyComparator::FindShortestSeparator</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* start, <span class="type">const</span> Slice&amp; limit)</span> <span class="type">const</span>;</span><br></pre></td></tr></table></figure>
<p>函数实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试更新user key，基于指定的user comparator</span></span><br><span class="line">Slice user_start = ExtractUserKey(*start);</span><br><span class="line">Slice user_limit = ExtractUserKey(limit);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">tmp</span><span class="params">(user_start.data(), user_start.size())</span>;</span><br><span class="line">user_comparator_-&gt;FindShortestSeparator(&amp;tmp, user_limit);</span><br><span class="line"><span class="keyword">if</span>(tmp.size() &lt; user_start.size() &amp;&amp; user_comparator_-&gt;Compare(user_start, tmp) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// user key在物理上长度变短了，但其逻辑值变大了.生产新的*start时，</span></span><br><span class="line">    <span class="comment">// 使用最大的sequence number，以保证排在相同user key记录序列的第一个</span></span><br><span class="line">    PutFixed64(&amp;tmp, PackSequenceAndType(kMaxSequenceNumber,</span><br><span class="line">                                       kValueTypeForSeek));</span><br><span class="line">    assert(this-&gt;Compare(*start, tmp) &lt; <span class="number">0</span>);</span><br><span class="line">    assert(this-&gt;Compare(tmp, limit) &lt; <span class="number">0</span>);</span><br><span class="line">    start-&gt;swap(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是<strong>FindShortSuccessor(std::string* key)</strong>函数，该函数取出Internal Key中的<strong>user key</strong>字段，根据user指定的<strong>comparator</strong>找到并替换key，如果key被替换了，就用新的key更新<strong>Internal Key</strong>，并使用最大的<strong>sequence number</strong>。否则保持不变。实现逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Slice user_key = ExtractUserKey(*key);</span><br><span class="line"><span class="comment">// 尝试更新user key，基于指定的user comparator</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">tmp</span><span class="params">(user_key.data(), user_key.size())</span>;</span><br><span class="line">user_comparator_-&gt;FindShortSuccessor(&amp;tmp);</span><br><span class="line"><span class="keyword">if</span>(tmp.size()&lt;user_key.size() &amp;&amp; </span><br><span class="line">   user_comparator_-&gt;Compare(user_key, tmp)&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// user key在物理上长度变短了，但其逻辑值变大了.生产新的*start时，</span></span><br><span class="line">   <span class="comment">// 使用最大的sequence number，以保证排在相同user key记录序列的第一个</span></span><br><span class="line">   PutFixed64(&amp;tmp, PackSequenceAndType(kMaxSequenceNumber, kValueTypeForSeek));</span><br><span class="line">   assert(this-&gt;Compare(*key, tmp) &lt; <span class="number">0</span>);</span><br><span class="line">   key-&gt;swap(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-7-Memtable-Insert"><a href="#4-7-Memtable-Insert" class="headerlink" title="4.7 Memtable::Insert()"></a>4.7 Memtable::Insert()</h2><p>把相关的<strong>Key和Key Comparator</strong>都弄清楚后，是时候分析memtable本身了。首先是向memtable<strong>插入记录的接</strong>口，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Add</span><span class="params">(SequenceNumber seq, ValueType type, <span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span>;</span><br></pre></td></tr></table></figure>
<p>代码实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KV entry字符串有下面4部分连接而成</span></span><br><span class="line"><span class="comment">//key_size     : varint32 of internal_key.size()</span></span><br><span class="line"><span class="comment">//key bytes    : char[internal_key.size()]</span></span><br><span class="line"><span class="comment">//value_size   : varint32 of value.size()</span></span><br><span class="line"><span class="comment">//  value bytes  : char[value.size()]</span></span><br><span class="line"><span class="type">size_t</span> key_size = key.size();</span><br><span class="line"><span class="type">size_t</span> val_size = value.size();</span><br><span class="line"><span class="type">size_t</span> internal_key_size = key_size + <span class="number">8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> encoded_len = VarintLength(internal_key_size) +</span><br><span class="line">                           internal_key_size +</span><br><span class="line">                           VarintLength(val_size) + val_size;</span><br><span class="line"><span class="type">char</span>* buf = arena_.Allocate(encoded_len);</span><br><span class="line"><span class="type">char</span>* p = EncodeVarint32(buf, internal_key_size);</span><br><span class="line"><span class="built_in">memcpy</span>(p, key.data(), key_size);</span><br><span class="line">p += key_size;</span><br><span class="line">EncodeFixed64(p, (s &lt;&lt; <span class="number">8</span>) | type);</span><br><span class="line">p += <span class="number">8</span>;</span><br><span class="line">p = EncodeVarint32(p, val_size);</span><br><span class="line"><span class="built_in">memcpy</span>(p, value.data(), val_size);</span><br><span class="line">assert((p + val_size) - buf == encoded_len);</span><br><span class="line">able_.Insert(buf);</span><br></pre></td></tr></table></figure></p>
<p>根据代码，我们可以分析出KV记录在skip list的<strong>存储格式</strong>等信息，首先总长度为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VarInt(Internal Key size) len + internal key size + VarInt(value) len + value size</span><br></pre></td></tr></table></figure>
<p>它们的相互衔接也就是KV的存储格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| VarInt(Internal Key size) len | internal key |VarInt(value) len |value|</span><br></pre></td></tr></table></figure>
<p>其中前面说过：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">internal key = |user key |sequence number |type |</span><br><span class="line">Internal key size = key size + 8</span><br></pre></td></tr></table></figure>
<h2 id="4-8-Memtable-Get"><a href="#4-8-Memtable-Get" class="headerlink" title="4.8 Memtable::Get()"></a>4.8 Memtable::Get()</h2><p>Memtable的查找接口，根据一个<strong>LookupKey</strong>找到响应的记录，函数声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">MemTable::Get</span><span class="params">(<span class="type">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s)</span></span><br></pre></td></tr></table></figure>
<p>函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Slice memkey = key.memtable_key();</span><br><span class="line">Table::Iterator <span class="title function_">iter</span><span class="params">(&amp;table_)</span>;</span><br><span class="line">iter.Seek(memkey.data()); </span><br><span class="line"><span class="comment">// seek到value&gt;= memkey.data()的第一个记录</span></span><br><span class="line"><span class="keyword">if</span> (iter.Valid()) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里不需要再检查sequence number了，因为Seek()已经跳过了所有</span></span><br><span class="line">    <span class="comment">// 值更大的sequence number了</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* entry = iter.key();</span><br><span class="line">    <span class="type">uint32_t</span> key_length;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* key_ptr = GetVarint32Ptr(entry, entry+<span class="number">5</span>, </span><br><span class="line">                                       &amp;key_length);</span><br><span class="line">    <span class="comment">// 比较user key是否相同，key_ptr开始的len(internal key) -8 byte是user key</span></span><br><span class="line">    <span class="keyword">if</span> (comparator_.comparator.user_comparator()-&gt;Compare</span><br><span class="line">      (Slice(key_ptr, key_length - <span class="number">8</span>), key.user_key()) == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// len(internal key)的后8byte是 |sequence number | value type|</span></span><br><span class="line">        <span class="type">const</span> <span class="type">uint64_t</span> tag = DecodeFixed64(key_ptr + key_length - <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">switch</span> (static_cast&lt;ValueType&gt;(tag &amp; <span class="number">0xff</span>))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> kTypeValue: </span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">// 只取出value</span></span><br><span class="line">           Slice v = GetLengthPrefixedSlice(key_ptr + key_length);</span><br><span class="line">           value-&gt;assign(v.data(), v.size());</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">case</span> kTypeDeletion:</span><br><span class="line">       *s = Status::NotFound(Slice());</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>这段代码，主要就是一个<strong>Seek函数</strong>，根据传入的LookupmKey得到在emtable中存储的key，然后调用Skip list::Iterator的Seek函数查找。Seek<strong>直接调用</strong>Skip list的FindGreaterOrEqual(key)接口，返回<strong>大于等于key的Iterator</strong>。然后取出user key判断时候和传入的user key相同，如果<strong>相同</strong>则<strong>取出value</strong>，如果记录的Value Type为kTypeDeletion，返回Status::NotFound(Slice())。</p>
<h2 id="4-9-小结"><a href="#4-9-小结" class="headerlink" title="4.9 小结"></a>4.9 小结</h2><p>Memtable到此就分析完毕了，本质上就是一个有序的Skip list，排序基于user key的sequence number，其<strong>排序比较依据</strong>依次是：</p>
<ol>
<li><strong>首先根据user key按升序排列</strong></li>
<li><strong>然后根据sequence number按降序排列</strong></li>
<li><strong>最后根据value type按降序排列（这个其实无关紧要）</strong></li>
</ol>
<h1 id="5-操作Log-1"><a href="#5-操作Log-1" class="headerlink" title="5.操作Log 1"></a>5.操作Log 1</h1><p>分析完KV在内存中的存储，接下来就是<strong>操作日志</strong>。所有的写操作都必须先成功的<strong>append</strong>到操作日志中，然后再更新内存<strong>memtable</strong>。这样做有<strong>两点</strong>：</p>
<ol>
<li><strong>可以将随机的写IO变成append，极大的提高写磁盘速度；</strong></li>
<li><strong>防止在节点down机导致内存数据丢失，造成数据丢失，这对系统来说是个灾难。</strong></li>
</ol>
<p>在各种高效的存储系统中，这已经是口水技术了。</p>
<h2 id="5-1-格式"><a href="#5-1-格式" class="headerlink" title="5.1 格式"></a>5.1 格式</h2><p>在源码下的文档<strong>doc/log_format.txt</strong>中，作者详细描述了<strong>log格式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">The log file contents are a sequence of 32KB blocks. </span><br><span class="line">The only exception is that the tail of thefile may contain a partial block.</span><br><span class="line">Each block consists of a sequence of records:</span><br><span class="line">block:= record* trailer?</span><br><span class="line">record :=</span><br><span class="line">checksum: uint32     // crc32c of type and data[] ; little-endian</span><br><span class="line">length: uint16       // little-endian</span><br><span class="line">type: uint8          // One of FULL,FIRST, MIDDLE, LAST</span><br><span class="line">data: uint8[length]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>A record never starts within the last six bytes of a block (since it won’tfit).  Any leftover bytes here form thetrailer, which must consist entirely of zero bytes and must be skipped byreaders.</p>
</blockquote>
<p>翻译过来就是：Leveldb把日志文件切分成了大小为32KB的连续block块，block由连续的log record组成，log record的格式为：</p>
<p><strong>注意：CRC32, Length都是little-endian的。</strong></p>
<p><strong>Log Type</strong>有4种：FULL = 1、FIRST = 2、MIDDLE = 3、LAST = 4。FULL类型表明该log record包含了完整的user record；而user record可能内容很多，超过了block的可用大小，就需要分成几条log record，第一条类型为FIRST，中间的为MIDDLE，最后一条为LAST。也就是：</p>
<ol>
<li>FULL，说明该log record包含一个完整的user record；</li>
<li>FIRST，说明是user record的第一条log record</li>
<li>MIDDLE，说明是user record中间的log record</li>
<li>LAST，说明是user record最后的一条log record</li>
</ol>
<p>翻一下文档上的例子，考虑到如下序列的<strong>user records</strong>：</p>
<ul>
<li>A: length 1000</li>
<li>B: length 97270</li>
<li><p>C: length 8000</p>
</li>
<li><p>A作为FULL类型的record存储在第一个block中；</p>
</li>
<li>B将被拆分成3条log record，分别存储在第1、2、3个block中，这时block3还剩6byte，将被填充为0；</li>
<li>C将作为FULL类型的record存储在block 4中。</li>
</ul>
<p>由于<strong>一条logrecord长度最短为7</strong>，如果一个block的剩余空间&lt;=6byte，那么将<strong>被填充为\</strong>空字*<strong>*</strong>符串<strong>，另外长度为7的log record是</strong>不包括任何用户数据的**。</p>
<h2 id="5-2-写日志"><a href="#5-2-写日志" class="headerlink" title="5.2 写日志"></a>5.2 写日志</h2><p>写比读简单，而且写入决定了读，所以从写开始分析。有意思的是在写文件时，Leveldb使用了内存映射文件，内存映射文件的读写效率比普通文件要高。其中涉及到的类层次比较简单，如图：</p>
<p><img src="/img/leveldb6.webp" alt=""></p>
<p>注意Write类的成员<strong>type_crc_数组</strong>，这里存放的为Record Type预先计算的CRC32值，因为Record Type是固定的几种，为了效率。Writer类只有一个接口，就是<strong>AddRecord()</strong>，传入<strong>Slice参数</strong>，下面来看函数实现。首先取出slice的字<strong>符串指针和长度</strong>，初始化begin=true，表明是<strong>第一条log record</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* ptr = slice.data();</span><br><span class="line"><span class="type">size_t</span> left = slice.size();</span><br><span class="line"><span class="type">bool</span> begin = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>然后进入一个while循环，直到写入出错，或者成功写入全部数据</p>
<p>首先查看当前block是否小于7，如果小于7则补位，并重置block偏移<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dest_-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(<span class="string">&quot;\x00\x00\x00\x00\x00\x00&quot;</span>,leftover));</span><br><span class="line">block_offset_ = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>计算block剩余大小，以及本次log record可写入数据长度<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> avail =kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> fragment_length = (left &lt;avail) ? left : avail</span><br></pre></td></tr></table></figure></p>
<p>根据两个值，判断log type<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RecordType type;</span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> end = (left ==fragment_length); <span class="comment">// 两者相等，表明写</span></span><br><span class="line"><span class="keyword">if</span> (begin &amp;&amp; end)   type = kFullType;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (begin)     type = kFirstType;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (end)       type = kLastType;</span><br><span class="line"><span class="keyword">else</span>                type = kMiddleType;</span><br></pre></td></tr></table></figure></p>
<p>调用EmitPhysicalRecord函数，append日志；并更新指针、剩余长度和begin标记<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = EmitPhysicalRecord(type, ptr,fragment_length);</span><br><span class="line">ptr += fragment_length;</span><br><span class="line">left -= fragment_length;</span><br><span class="line">begin = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>接下来看看<strong>EmitPhysicalRecord函数</strong>，这是实际写入的地方，涉及到log的存储格式。函数声明为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StatusWriter::EmitPhysicalRecord(RecordType t, <span class="type">const</span> <span class="type">char</span>* ptr, <span class="type">size_t</span> n)</span><br></pre></td></tr></table></figure><br>参数ptr为用户record数据，参数n为record长度，不包含log header。</p>
<p>计算header，并Append到log文件，共7byte格式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">| CRC32 (<span class="number">4</span> byte) | payload length lower + high (<span class="number">2</span> byte) |   type (<span class="number">1b</span>yte)|</span><br><span class="line"><span class="type">char</span> buf[kHeaderSize];</span><br><span class="line">buf[<span class="number">4</span>] = static_cast&lt;<span class="type">char</span>&gt;(n&amp; <span class="number">0xff</span>);</span><br><span class="line">buf[<span class="number">5</span>] =static_cast&lt;<span class="type">char</span>&gt;(n &gt;&gt; <span class="number">8</span>);</span><br><span class="line">buf[<span class="number">6</span>] =static_cast&lt;<span class="type">char</span>&gt;(t);   <span class="comment">// 计算record type和payload的CRC校验值</span></span><br><span class="line"><span class="type">uint32_t</span> crc = crc32c::Extend(type_crc_[t], ptr, n);</span><br><span class="line">crc = crc32c::Mask(crc);        <span class="comment">// 空间调整</span></span><br><span class="line">EncodeFixed32(buf, crc);</span><br><span class="line">dest_-&gt;Append(Slice(buf,kHeaderSize));</span><br></pre></td></tr></table></figure>
<p>写入payload，并Flush，更新block的当前偏移<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s =dest_-&gt;Append(Slice(ptr, n));</span><br><span class="line">s = dest_-&gt;Flush();</span><br><span class="line">block_offset_ += kHeaderSize +n;</span><br></pre></td></tr></table></figure></p>
<p>以上就是写日志的逻辑，很直观。</p>
<h2 id="5-3-读日志"><a href="#5-3-读日志" class="headerlink" title="5.3 读日志"></a>5.3 读日志</h2><p>日志读取显然比写入要复杂，要检查<strong>checksum</strong>，检查是否有损坏等等，处理各种错误。</p>
<h3 id="5-3-1-类层次"><a href="#5-3-1-类层次" class="headerlink" title="5.3.1 类层次"></a>5.3.1 类层次</h3><p>Reader主要用到了两个接口，一个是<strong>汇报错误的Reporter</strong>，另一个是log文件<strong>读取类SequentialFile</strong>。</p>
<p>Reporter的接口只有<strong>一个</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Corruption</span><span class="params">(<span class="type">size_t</span> bytes,<span class="type">const</span> Status&amp; status)</span>;</span><br></pre></td></tr></table></figure>
<p>SequentialFile有<strong>两个</strong>接口：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Read</span><span class="params">(<span class="type">size_t</span> n, Slice* result, <span class="type">char</span>* scratch)</span>;</span><br><span class="line">Status <span class="title function_">Skip</span><span class="params">(<span class="type">uint64_t</span> n)</span>;</span><br></pre></td></tr></table></figure></p>
<p>说明下，Read接口有一个<strong>result</strong>参数传递结果就行了，为何还有一个scratch呢，这个就和Slice相关了。它的字符串指针是传入的外部char*指针，自己并不负责内存的管理与分配。因此Read接口需要调用者提供一个字符串指针，实际存放字符串的地方。</p>
<p><img src="/img/leveldb7.webp" alt=""></p>
<p>Reader类有几个成员变量，需要注意：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> eof_;          </span><br><span class="line"><span class="comment">// 上次Read()返回长度&lt; kBlockSize，暗示到了文件结尾EOF</span></span><br><span class="line"><span class="type">uint64_t</span> last_record_offset_;  <span class="comment">// 函数ReadRecord返回的上一个record的偏移</span></span><br><span class="line"><span class="type">uint64_t</span> end_of_buffer_offset_;<span class="comment">// 当前的读取偏移</span></span><br><span class="line"><span class="type">uint64_t</span> <span class="type">const</span> initial_offset_;<span class="comment">// 偏移，从哪里开始读取第一条record</span></span><br><span class="line">Slice   buffer_;               <span class="comment">// 读取的内容</span></span><br></pre></td></tr></table></figure>
<h3 id="5-3-2日志读取流程"><a href="#5-3-2日志读取流程" class="headerlink" title="5.3.2日志读取流程"></a>5.3.2日志读取流程</h3><p>Reader只有一个接口，那就是ReadRecord，下面来分析下这个函数。</p>
<h6 id="S1-1"><a href="#S1-1" class="headerlink" title="S1"></a>S1</h6><p>根据initial offset跳转到调用者指定的位置，开始读取日志文件。跳转就是直接调用SequentialFile的Seek接口。<br>另外，需要先调整调用者传入的<strong>initialoffset</strong>参数，调整和跳转逻辑在SkipToInitialBlock函数中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (last_record_offset_ &lt;initial_offset_) </span><br><span class="line">&#123; // 当前偏移 &lt; 指定的偏移，需要Seek</span><br><span class="line">	if (!SkipToInitialBlock()) return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码是SkipToInitialBlock函数调整read offset的逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算在block内的偏移位置，并圆整到开始读取block的起始位置</span></span><br><span class="line"><span class="type">size_t</span> offset_in_block =initial_offset_ % kBlockSize;</span><br><span class="line"><span class="type">uint64_t</span> block_start_location =initial_offset_ - offset_in_block;</span><br><span class="line"><span class="comment">// 如果偏移在最后的6byte里，肯定不是一条完整的记录，跳到下一个block</span></span><br><span class="line"><span class="keyword">if</span> (offset_in_block &gt;kBlockSize - <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">     offset_in_block = <span class="number">0</span>;</span><br><span class="line">     block_start_location +=kBlockSize;</span><br><span class="line">&#125;</span><br><span class="line">end_of_buffer_offset_ =block_start_location;            </span><br><span class="line"><span class="comment">// 设置读取偏移</span></span><br><span class="line"><span class="keyword">if</span> (block_start_location &gt; <span class="number">0</span>)  file_-&gt;Skip(block_start_location); <span class="comment">// 跳转</span></span><br></pre></td></tr></table></figure>
<p>首先计算出在<strong>block</strong>内的偏移位置，然后圆整到要读取block的起始位置。开始读取日志的时候都要保证读取的是完整的block，这就是<strong>调整的目的</strong>。</p>
<p>同时成员变量end_of_buffer_offset_<strong>记录</strong>了这个值，在后续读取中会用到。</p>
<h6 id=""><a href="#" class="headerlink" title=" "></a> </h6><p>S2在开始while循环前首先初始化几个标记：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 当前是否在fragment内，也就是遇到了FIRST 类型的record</span><br><span class="line">bool in_fragmented_record = false;</span><br><span class="line">uint64_t prospective_record_offset = 0; // 我们正在读取的逻辑record的偏移</span><br></pre></td></tr></table></figure>
<h6 id="S3-1"><a href="#S3-1" class="headerlink" title="S3"></a>S3</h6><p>进入到while(true)循环，直到读取到KLastType或者KFullType的record，或者到了文件结尾。从日志文件读取完整的record是ReadPhysicalRecord函数完成的。</p>
<p>读取出现错误时，并不会退出循环，而是<strong>汇报错误</strong>，继续执行，直到<strong>成功读取</strong>一条user record，或者遇到文件结尾。</p>
<p><strong>S3.1 从文件读取record</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> physical_record_offset = end_of_buffer_offset_ -buffer_.size();</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> record_type = ReadPhysicalRecord(&amp;fragment);</span><br></pre></td></tr></table></figure>
<p>physical_record_offset存储的是当前正在读取的record的偏移值。接下来根据不同的record_type类型，分别处理，一共有7种情况：</p>
<p><strong>S3.2 FULL type(kFullType)，表明是一条完整的log record，成功返回读取的user record数据。另外需要对早期版本做些work around，早期的Leveldb会在block的结尾生产一条空的kFirstType log record。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_fragmented_record) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (scratch-&gt;empty())in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">else</span> ReportCorruption(scratch-&gt;size(),<span class="string">&quot;partial record without end(1)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prospective_record_offset= physical_record_offset;</span><br><span class="line">scratch-&gt;clear(); <span class="comment">// 清空scratch，读取成功不需要返回scratch数据</span></span><br><span class="line">*record = fragment;</span><br><span class="line">last_record_offset_ =prospective_record_offset; <span class="comment">// 更新last record offset</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p><strong>S3.3 FIRST type(kFirstType)，表明是一系列logrecord(fragment)的第一个record。同样需要对早期版本做work around。</strong></p>
<p>把数据读取到scratch中，直到<strong>成功读取</strong>了LAST类型的log record，才把数据返回到<strong>result</strong>中，继续下次的读取循环。</p>
<p>如果再次遇到FIRSTor FULL类型的log record，如果scratch不为空，就说明日志文件有错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_fragmented_record) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (scratch-&gt;empty())in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> ReportCorruption(scratch-&gt;size(),<span class="string">&quot;partial record without end(2)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prospective_record_offset =physical_record_offset;</span><br><span class="line">scratch-&gt;assign(fragment.data(), fragment.size()); </span><br><span class="line"><span class="comment">//赋值给scratch</span></span><br><span class="line">in_fragmented_record =<span class="literal">true</span>; </span><br><span class="line"><span class="comment">// 设置fragment标记为true</span></span><br></pre></td></tr></table></figure>
<p><strong>S3.4 MIDDLE type(kMiddleType)，这个处理很简单，如果不是在fragment中，报告错误，否则直接append到scratch中就可以了。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!in_fragmented_record)</span><br><span class="line">&#123;</span><br><span class="line">    ReportCorruption(fragment.size(),</span><br><span class="line">    &quot;missing start of fragmentedrecord(1)&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;scratch-&gt;append(fragment.data(),fragment.size());&#125;</span><br></pre></td></tr></table></figure>
<p><strong>S3.5 LAST type(kLastType)，说明是一系列log record(fragment)中的最后一条。如果不在fragment中，报告错误。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (!in_fragmented_record) </span><br><span class="line">&#123;</span><br><span class="line">    ReportCorruption(fragment.size(),</span><br><span class="line">    &quot;missing start of fragmentedrecord(2)&quot;);</span><br><span class="line">&#125; </span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">    scratch-&gt;append(fragment.data(), fragment.size());</span><br><span class="line">    *record = Slice(*scratch);</span><br><span class="line">    last_record_offset_ =prospective_record_offset;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，4种正常的log record type已经处理完成，下面3种情况是其它的错误处理，类型声明在<strong>Logger类</strong>中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">    kEof = kMaxRecordType + 1, // 遇到文件结尾</span><br><span class="line">    // 非法的record，当前有3中情况会返回bad record：</span><br><span class="line">    // * CRC校验失败 (ReadPhysicalRecord reports adrop)</span><br><span class="line">    // * 长度为0 (No drop is reported)</span><br><span class="line">    // * 在指定的initial_offset之外 (No drop is reported)</span><br><span class="line">    kBadRecord = kMaxRecordType +2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>S3.6 遇到文件结尾kEof，返回false。不返回任何结果。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_fragmented_record) </span><br><span class="line">&#123;</span><br><span class="line">    ReportCorruption(scratch-&gt;size(), <span class="string">&quot;partial record withoutend(3)&quot;</span>);</span><br><span class="line">    scratch-&gt;clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p><strong>S3.7 非法的record(kBadRecord)，如果在fragment中，则报告错误。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_fragmented_record)</span><br><span class="line">&#123;</span><br><span class="line">    ReportCorruption(scratch-&gt;size(), <span class="string">&quot;error in middle ofrecord&quot;</span>);</span><br><span class="line">    in_fragmented_record = <span class="literal">false</span>;</span><br><span class="line">    scratch-&gt;clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>S3.8 缺省分支，遇到非法的record 类型，报告错误，清空scratch。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReportCorruption(…, &quot;unknownrecord type %u&quot;, record_type);</span><br><span class="line">in_fragmented_record = false; // 重置fragment标记</span><br><span class="line">scratch-&gt;clear();// 清空scratch</span><br></pre></td></tr></table></figure>
<p>上面就是ReadRecord的全部逻辑，解释起来还有些费力。</p>
<h3 id="5-3-3-从log文件读取record"><a href="#5-3-3-从log文件读取record" class="headerlink" title="5.3.3 从log文件读取record"></a>5.3.3 从log文件读取record</h3><p>就是前面讲过的<strong>ReadPhysicalRecord函数</strong>，它调用SequentialFile的Read接口，从文件读取数据。</p>
<p>该函数开始就进入了一个<strong>while(true)循环</strong>，其目的是为了读取到一个完整的record。读取的内容存放在成员变量<strong>buffer_</strong>中。这样的逻辑有些奇怪，实际上，完全不需要一个while(true)循环的。</p>
<p>函数基本逻辑如下：</p>
<h4 id="S1-2"><a href="#S1-2" class="headerlink" title="S1"></a>S1</h4><p>如果buffer_小于block header大小kHeaderSize，进入如下的几个分支：</p>
<p><strong>S1.1 如果eof_为false，表明还没有到文件结尾，清空buffer，并读取数据。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">buffer_.clear(); </span><br><span class="line"><span class="comment">// 因为上次肯定读取了一个完整的record</span></span><br><span class="line">Status status =file_-&gt;Read(kBlockSize, &amp;buffer_, backing_store_);</span><br><span class="line">end_of_buffer_offset_ +=buffer_.size(); </span><br><span class="line"><span class="comment">// 更新buffer读取偏移值</span></span><br><span class="line"><span class="keyword">if</span> (!status.ok())</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 读取失败，设置eof_为true，报告错误并返回kEof</span></span><br><span class="line">    buffer_.clear();</span><br><span class="line">    ReportDrop(kBlockSize,status);</span><br><span class="line">    eof_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> kEof;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (buffer_.size()&lt; kBlockSize)</span><br><span class="line">&#123;</span><br><span class="line">    eof_ = <span class="literal">true</span>; <span class="comment">// 实际读取字节&lt;指定(Block Size)，表明到了文件结尾</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>; <span class="comment">// 继续下次循环</span></span><br></pre></td></tr></table></figure>
<p><strong>S1.2 如果eof_为true并且buffer为空，表明已经到了文件结尾，正常结束，返回kEof。</strong></p>
<p><strong>S1.3 否则，也就是eof_为true，buffer不为空，说明文件结尾包含了一个不完整的record，报告错误，返回kEof。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size_t drop_size =buffer_.size();</span><br><span class="line">buffer_.clear();</span><br><span class="line">ReportCorruption(drop_size,&quot;truncated record at end of file&quot;);</span><br><span class="line">return kEof;</span><br></pre></td></tr></table></figure>
<h5 id="S2-进入到这里表明上次循环中的Read读取到了一个完整的log-record，continue后的第二次循环判断buffer-size-gt-kHeaderSize将执行到此处。"><a href="#S2-进入到这里表明上次循环中的Read读取到了一个完整的log-record，continue后的第二次循环判断buffer-size-gt-kHeaderSize将执行到此处。" class="headerlink" title="S2 进入到这里表明上次循环中的Read读取到了一个完整的log record，continue后的第二次循环判断buffer_.size() &gt;= kHeaderSize将执行到此处。"></a>S2 进入到这里表明上次循环中的Read读取到了一个完整的log record，continue后的第二次循环判断buffer_.size() &gt;= kHeaderSize将执行到此处。</h5><p>解析出log record的header部分，判断长度是否一致。</p>
<p>根据log的格式，前4byte是crc32。后面就是length和type，解析如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* header = buffer_.data();</span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> length = ((header[<span class="number">4</span>])&amp; <span class="number">0xff</span>) | ((header[<span class="number">5</span>]&amp;<span class="number">0xff</span>)&lt;&lt;<span class="number">8</span>)</span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> type = header[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">if</span> (kHeaderSize + length &gt;buffer_.size()) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 长度超出了，汇报错误</span></span><br><span class="line">    <span class="type">size_t</span> drop_size =buffer_.size();</span><br><span class="line">    buffer_.clear();</span><br><span class="line">    ReportCorruption(drop_size,<span class="string">&quot;bad record length&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> kBadRecord; <span class="comment">// 返回kBadRecord</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type == kZeroType&amp;&amp; length == <span class="number">0</span>)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 对于Zero Type类型，不汇报错误</span></span><br><span class="line">    buffer_.clear();</span><br><span class="line">    <span class="keyword">return</span> kBadRecord; <span class="comment">// 依然返回kBadRecord</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="S3-校验CRC32，如果校验出错，则汇报错误，并返回kBadRecord。"><a href="#S3-校验CRC32，如果校验出错，则汇报错误，并返回kBadRecord。" class="headerlink" title="S3 校验CRC32，如果校验出错，则汇报错误，并返回kBadRecord。"></a>S3 校验CRC32，如果校验出错，则汇报错误，并返回kBadRecord。</h5><h5 id="S4-如果record的开始位置在initial-offset之前，则跳过，并返回kBadRecord，否则返回record数据和type。"><a href="#S4-如果record的开始位置在initial-offset之前，则跳过，并返回kBadRecord，否则返回record数据和type。" class="headerlink" title="S4 如果record的开始位置在initial offset之前，则跳过，并返回kBadRecord，否则返回record数据和type。"></a>S4 如果record的开始位置在initial offset之前，则跳过，并返回kBadRecord，否则返回record数据和type。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buffer_.remove_prefix(kHeaderSize+ length);</span><br><span class="line">if (end_of_buffer_offset_ -buffer_.size() - kHeaderSize - </span><br><span class="line">    length &lt; initial_offset_) </span><br><span class="line">&#123;</span><br><span class="line">    result-&gt;clear();</span><br><span class="line">    return kBadRecord;</span><br><span class="line">&#125;</span><br><span class="line">*result = Slice(header +kHeaderSize, length);</span><br><span class="line">return type;</span><br></pre></td></tr></table></figure>
<p>从log文件读取record的逻辑就是这样的。至此，读日志的逻辑也完成了。接下来将进入磁盘存储的<strong>sstable</strong>部分。</p>
<h1 id="6-SSTable之一"><a href="#6-SSTable之一" class="headerlink" title="6. SSTable之一"></a>6. SSTable之一</h1><p><strong>SSTable是Leveldb的核心之一</strong>，是表数据最终在磁盘上的物理存储。也是体量比较大的模块。</p>
<h2 id="6-1-SSTable的文件组织"><a href="#6-1-SSTable的文件组织" class="headerlink" title="6.1 SSTable的文件组织"></a>6.1 SSTable的文件组织</h2><p>作者在文档<strong>doc/table_format.txt</strong>中描述了表的逻辑结构，如图6.1-1所示。逻辑上可分为两大块，数据存储区Data Block，以及各种Meta信息。</p>
<ol>
<li><p>文件中的<strong>k/v对</strong>是有序存储的，并且被划分到连续排列的Data Block里面，这些Data Block从文件头开始顺序存储，<strong>Data Block</strong>的存储格式代码在block_builder.cc中；</p>
</li>
<li><p>紧跟在Data Block之后的是<strong>Meta Block</strong>，其格式代码也在block_builder.cc中；Meta Block存储的是Filter信息，比如Bloom过滤器，用于快速定位key是否在data block中。</p>
</li>
<li><p><strong>MetaIndex Block</strong>是对Meta Block的索引，它只有一条记录，key是meta index的名字（也就是Filter的名字），value为指向meta index的BlockHandle；BlockHandle是一个结构体，成员offset_是Block在文件中的偏移，成员size_是block的大小；</p>
</li>
<li><p><strong>Index block</strong>是对Data Block的索引，对于其中的每个记录，其key &gt;=Data Block最后一条记录的key，同时&lt;其后Data Block的第一条记录的key；value是指向data index的BlockHandle；</p>
</li>
</ol>
<p><img src="/img/leveldb8.webp" alt=""></p>
<ol>
<li><strong>Footer</strong>，文件的最后，大小固定，其格式如图6.1-2所示。</li>
</ol>
<p><img src="/img/leveldb9.webp" alt=""></p>
<ul>
<li>成员<strong>metaindex_handle</strong>指出了meta index block的起始位置和大小；</li>
<li>成员<strong>index_handle</strong>指出了index block的起始地址和大小；</li>
</ul>
<p>这两个字段都是<strong>BlockHandle对象</strong>，可以理解为索引的索引，通过Footer可以直接定位到<strong>metaindex和index block</strong>。再后面是一个<strong>填充区和魔数</strong>（0xdb4775248b80fb57）。</p>
<h2 id="6-2-Block存储格式"><a href="#6-2-Block存储格式" class="headerlink" title="6.2 Block存储格式"></a>6.2 Block存储格式</h2><h3 id="6-2-1-Block的逻辑存储"><a href="#6-2-1-Block的逻辑存储" class="headerlink" title="6.2.1 Block的逻辑存储"></a>6.2.1 Block的逻辑存储</h3><p>Data Block是具体的k/v数据对存储区域，此外还有存储meta的metaIndex Block，存储data block索引信息的Index Block等等，他们都是以Block的方式存储的。<strong>来看看Block是如何组织的</strong>。每个Block有三部分构成：block data, type, crc32，如图6.2-1所示。</p>
<p><img src="/img/leveldb10.webp" alt=""></p>
<p><strong>类型type</strong>指明使用的是哪种压缩方式，<strong>当前支持none和snappy压缩。</strong></p>
<p>虽然<strong>block</strong>有好几种，但是Block Data都是有序的k/v对，因此写入、读取BlockData的接口都是统一的，对于Block Data的管理也都是相同的。</p>
<p>对Block的写入、读取将在创建、读取sstable时分析，知道了格式之后，其读取写入代码都是很直观的。</p>
<p>由于sstable对数据的存储格式都是Block，因此在分析sstable的读取和写入逻辑之前，<strong>我们先来分析下Leveldb对Block Data的管理。</strong></p>
<p>Leveldb对Block Data的管理是读写分离的，读取后的遍历查询操作由Block类实现，BlockData的构建则由BlockBuilder类实现。</p>
<h3 id="6-2-2-重启点-restartpoint"><a href="#6-2-2-重启点-restartpoint" class="headerlink" title="6.2.2 重启点-restartpoint"></a>6.2.2 重启点-restartpoint</h3><p><strong>BlockBuilder</strong>对key的存储是前缀压缩的，对于有序的字符串来讲，这能极大的减少存储空间。但是却增加了查找的时间复杂度，为了兼顾查找效率，每隔K个key，leveldb就不使用前缀压缩，而是存储整个key，这就是<strong>重启点</strong>（restartpoint）。</p>
<p>在构建Block时，有参数<strong>Options::block_restart_interval</strong>定每隔几个key就直接存储一个重启点key。</p>
<p>Block在结尾记录所有重启点的偏移，可以二分查找指定的key。Value直接存储在key的后面，无压缩。</p>
<p>对于一个k/v对，其在block中的存储格式为：</p>
<ul>
<li>共享前缀长度     shared_bytes:   varint32</li>
<li>前缀之后的字符串长度 unshared_bytes:  varint32</li>
<li>值的长度       value_length:   varint32</li>
<li>前缀之后的字符串   key_delta:   char[unshared_bytes]</li>
<li>值          value:  char[value_length]</li>
</ul>
<p>对于重启点，<strong>shared_bytes= 0</strong></p>
<p>Block的结尾段格式是：</p>
<ul>
<li>restarts:    uint32[num_restarts]</li>
<li>num_restarts: uint32 // 重启点个数</li>
</ul>
<p><strong>元素restarts[i]</strong>存储的是block的第i个重启点的偏移。很明显第一个k/v对，总是第一个重启点，也就是restarts[0] = 0;</p>
<p>图给出了block的存储示意图。</p>
<p><img src="/img/leveldb11.webp" alt=""></p>
<p><strong>总体来看Block可分为k/v存储区和后面的重启点存储区两部分</strong>，其中k/v的存储格式如前面所讲，可看做4部分：</p>
<p>前缀压缩的key长度信息 + value长度 + key前缀之后的字符串+ value</p>
<p>最后一个4byte为重启点的个数。</p>
<p>对Block的存储格式了解之后，对Block的构建和读取代码分析就是很直观的事情了。见下面的分析。</p>
<h2 id="6-3-Block的构建与读取"><a href="#6-3-Block的构建与读取" class="headerlink" title="6.3 Block的构建与读取"></a>6.3 Block的构建与读取</h2><h3 id="6-3-1-BlockBuilder的接口"><a href="#6-3-1-BlockBuilder的接口" class="headerlink" title="6.3.1 BlockBuilder的接口"></a>6.3.1 BlockBuilder的接口</h3><p>首先从Block的构建开始，这就是<strong>BlockBuilder类</strong>，来看下BlockBuilder的函数接口，一共有5个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reset</span><span class="params">()</span>; <span class="comment">// 重设内容，通常在Finish之后调用已构建新的block</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加k/v，要求：Reset()之后没有调用过Finish()；Key &gt; 任何已加入的key</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Add</span><span class="params">(<span class="type">const</span> Slice&amp; key,<span class="type">const</span> Slice&amp; value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束构建block，并返回指向block内容的指针</span></span><br><span class="line"></span><br><span class="line">Slice <span class="title function_">Finish</span><span class="params">()</span>;<span class="comment">// 返回Slice的生存周期：Builder的生存周期，or直到Reset()被调用</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">CurrentSizeEstimate</span><span class="params">()</span><span class="type">const</span>; <span class="comment">// 返回正在构建block的未压缩大小—估计值</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">empty</span><span class="params">()</span> <span class="type">const</span> &#123; returnbuffer_.empty();&#125; <span class="comment">// 没有entry则返回true</span></span><br></pre></td></tr></table></figure>
<p>主要成员变量如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>            buffer_;    <span class="comment">// block的内容</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">uint32_t</span>&gt;  restarts_;  <span class="comment">// 重启点-后面会分析到</span></span><br><span class="line"><span class="type">int</span>                    counter_;   <span class="comment">// 重启后生成的entry数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>            last_key_;  <span class="comment">// 记录最后添加的key</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3-2-BlockBuilder-Add"><a href="#6-3-2-BlockBuilder-Add" class="headerlink" title="6.3.2 BlockBuilder::Add()"></a>6.3.2 BlockBuilder::Add()</h3><p><strong>调用Add函数</strong>向当前Block中新加入一个k/v对{key, value}。函数处理逻辑如下：</p>
<h4 id="S1-3"><a href="#S1-3" class="headerlink" title="S1"></a>S1</h4><p>保证新加入的key &gt; 已加入的任何一个key；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assert(!finished_);  </span><br><span class="line"></span><br><span class="line">assert(counter_ &lt;= options_-&gt;block_restart_interval);</span><br><span class="line"></span><br><span class="line">assert(buffer_.empty() || options_-&gt;comparator-&gt;Compare(key,last_key_piece) &gt; 0);</span><br></pre></td></tr></table></figure>
<h4 id="S2-1"><a href="#S2-1" class="headerlink" title="S2"></a>S2</h4><p>如果计数器counter &lt; opions-&gt;block_restart_interval，则使用前缀算法压缩key，否则就把key作为一个重启点，无压缩存储；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Slice <span class="title function_">last_key_piece</span><span class="params">(last_key_)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123; <span class="comment">//前缀压缩</span></span><br><span class="line">    <span class="comment">// 计算key与last_key_的公共前缀</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> min_length= <span class="built_in">std</span>::min(last_key_piece.size(), key.size());</span><br><span class="line">    <span class="keyword">while</span> ((shared &lt; min_length)&amp;&amp; (last_key_piece[shared] == key[shared])) &#123;</span><br><span class="line">    shared++;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 新的重启点</span></span><br><span class="line">    restarts_.push_back(buffer_.size());</span><br><span class="line">    counter_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Slice <span class="title function_">last_key_piece</span><span class="params">(last_key_)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123; <span class="comment">//前缀压缩</span></span><br><span class="line">    <span class="comment">// 计算key与last_key_的公共前缀</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> min_length= <span class="built_in">std</span>::min(last_key_piece.size(), key.size());</span><br><span class="line">    <span class="keyword">while</span> ((shared &lt; min_length)&amp;&amp; (last_key_piece[shared] == key[shared]))</span><br><span class="line">        shared++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 新的重启点</span></span><br><span class="line">    restarts_.push_back(buffer_.size());</span><br><span class="line">    counter_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="S3-2"><a href="#S3-2" class="headerlink" title="S3"></a>S3</h5><p>根据上面的数据格式存储k/v对，追加到buffer中，并更新block状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> non_shared = key.size() - shared; <span class="comment">// key前缀之后的字符串长度</span></span><br><span class="line"><span class="comment">// append&quot;&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;&quot; 到buffer_  </span></span><br><span class="line">PutVarint32(&amp;buffer_, shared); </span><br><span class="line">PutVarint32(&amp;buffer_, non_shared); </span><br><span class="line">PutVarint32(&amp;buffer_, value.size());  </span><br><span class="line"><span class="comment">// 其后是前缀之后的字符串 + value </span></span><br><span class="line">buffer_.append(key.data() + shared, non_shared);  </span><br><span class="line">buffer_.append(value.data(), value.size());  </span><br><span class="line"><span class="comment">// 更新状态 ，last_key_ = key及计数器counter_</span></span><br><span class="line">last_key_.resize(shared);   <span class="comment">// 连一个string的赋值都要照顾到，使内存copy最小化</span></span><br><span class="line">last_key_.append(key.data() + shared, non_shared); </span><br><span class="line">assert(Slice(last_key_) == key);  </span><br><span class="line">counter_++;  </span><br></pre></td></tr></table></figure>
<h3 id="6-3-3-BlockBuilder-Finish"><a href="#6-3-3-BlockBuilder-Finish" class="headerlink" title="6.3.3 BlockBuilder::Finish()"></a>6.3.3 BlockBuilder::Finish()</h3><p>调用该函数完成Block的构建，很简单，压入重启点信息，并返回<code>buffer_</code>，设置结束标记<code>finished_</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; restarts_.size(); i++) &#123;  <span class="comment">// 重启点  </span></span><br><span class="line">      PutFixed32(&amp;buffer_, restarts_[i]);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">PutFixed32(&amp;buffer_, restarts_.size());    <span class="comment">// 重启点数量  </span></span><br><span class="line">finished_ = <span class="literal">true</span>;  </span><br><span class="line"><span class="keyword">return</span> Slice(buffer_);  </span><br></pre></td></tr></table></figure>
<h3 id="6-3-4-BlockBuilder-Reset-amp-大小"><a href="#6-3-4-BlockBuilder-Reset-amp-大小" class="headerlink" title="6.3.4 BlockBuilder::Reset() &amp; 大小"></a>6.3.4 BlockBuilder::Reset() &amp; 大小</h3><p>还有<strong>Reset和CurrentSizeEstimate两个函数，Reset复位函数</strong>，清空各个信息；<strong>函数CurrentSizeEstimate</strong>返回block的预计大小，从函数实现来看，应该在调用Finish之前调用该函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BlockBuilder::Reset</span><span class="params">()</span> &#123;  </span><br><span class="line">   buffer_.clear();  restarts_.clear();  last_key_.clear();  </span><br><span class="line">   restarts_.push_back(<span class="number">0</span>);       <span class="comment">// 第一个重启点位置总是 0  </span></span><br><span class="line">   counter_ = <span class="number">0</span>;  </span><br><span class="line">   finished_ = <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">BlockBuilder::CurrentSizeEstimate</span> <span class="params">()</span> <span class="type">const</span> &#123;  </span><br><span class="line">   <span class="comment">// buffer大小 +重启点数组长度 + 重启点长度(uint32)</span></span><br><span class="line">  <span class="keyword">return</span> (buffer_.size() +  restarts_.size() * <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>) + <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)); </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>Block的构建就这些内容了，下面开始分析Block的读取，就是类Block。</p>
<h3 id="6-3-5-Block类接口"><a href="#6-3-5-Block类接口" class="headerlink" title="6.3.5 Block类接口"></a>6.3.5 Block类接口</h3><p><strong>对Block的读取</strong>是由类Block完成的，先来看看其函数接口和关键成员变量。</p>
<p>Block只有两个函数接口，通过Iterator对象，调用者就可以遍历访问Block的存储的k/v对了；以及几个成员变量，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">size</span><span class="params">()</span> <span class="type">const</span> &#123; returnsize_; &#125;</span><br><span class="line">Iterator* <span class="title function_">NewIterator</span><span class="params">(constComparator* comparator)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* data_;        <span class="comment">// block数据指针</span></span><br><span class="line"><span class="type">size_t</span> size_;             <span class="comment">// block数据大小</span></span><br><span class="line"><span class="type">uint32_t</span> restart_offset_; <span class="comment">// 重启点数组在data_中的偏移</span></span><br><span class="line"><span class="type">bool</span> owned_;              <span class="comment">//data_[]是否是Block拥有的</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3-6-Block初始化"><a href="#6-3-6-Block初始化" class="headerlink" title="6.3.6 Block初始化"></a>6.3.6 Block初始化</h3><p>Block的构造函数接受一个BlockContents对象contents初始化，<strong>BlockContents</strong>是一个有3个成员的结构体。</p>
<ul>
<li>data = Slice();</li>
<li>cachable = false; // 无cache</li>
<li>heap_allocated = false; // 非heap分配</li>
</ul>
<p>根据contents为成员赋值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_ = contents.data.data(), size_ =contents.data.size(),owned_ = contents.heap_allocated;</span><br></pre></td></tr></table></figure>
<p>然后<strong>从data中解析出重启点数组</strong>，如果数据太小，或者重启点计算出错，就设置size_=0，表明该block data解析失败。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size_ &lt; <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>))&#123;</span><br><span class="line">  size_ = <span class="number">0</span>;  <span class="comment">// 出错了</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  restart_offset_ = size_ - (<span class="number">1</span> +NumRestarts()) * <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>);</span><br><span class="line">  <span class="keyword">if</span> (restart_offset_ &gt; size_- <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>)) size_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>NumRestarts()函数</strong>就是从最后的uint32解析出重启点的个数，并返回:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return DecodeFixed32(data_ +size_ - sizeof(uint32_t))</span><br></pre></td></tr></table></figure>
<h3 id="6-3-7-Block-Iter"><a href="#6-3-7-Block-Iter" class="headerlink" title="6.3.7 Block::Iter"></a>6.3.7 Block::Iter</h3><p>这是一个用以遍历Block内部数据的内部类，它继承了Iterator接口。<strong>函数NewIterator</strong>返回Block::Iter对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return new Iter(cmp, data_,restart_offset_, num_restarts);</span><br></pre></td></tr></table></figure>
<p>下面我们就<strong>分析Iter的实现</strong>。</p>
<p>主要成员变量有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Comparator* constcomparator_; // key比较器</span><br><span class="line">const char* const data_;      // block内容</span><br><span class="line">uint32_t const restarts_;     // 重启点(uint32数组)在data中的偏移</span><br><span class="line">uint32_t const num_restarts_; // 重启点个数</span><br><span class="line">uint32_t current_; // 当前entry在data中的偏移.  &gt;= restarts_表明非法</span><br><span class="line">uint32_t restart_index_;  // current_所在的重启点的index</span><br></pre></td></tr></table></figure>
<p>下面来看看对Iterator接口的实现，简单函数略过。</p>
<blockquote>
<p>首先是Next()函数，直接调用private函数ParseNextKey()跳到下一个k/v对，函数实现如下：</p>
</blockquote>
<h4 id="S1-4"><a href="#S1-4" class="headerlink" title="S1"></a>S1</h4><p>跳到下一个entry，其位置紧邻在当前value_之后。如果已经是最后一个entry了，返回false，标记current_为invalid。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">current_ = NextEntryOffset(); <span class="comment">// (value_.data() + value_.size()) - data_</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p = data_ +current_;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* limit = data_ +restarts_; <span class="comment">// Restarts come right after data</span></span><br><span class="line"><span class="keyword">if</span> (p &gt;= limit) &#123; <span class="comment">// entry到头了，标记为invalid.</span></span><br><span class="line">  current_ = restarts_;</span><br><span class="line">  restart_index_ =num_restarts_;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="S2-2"><a href="#S2-2" class="headerlink" title="S2"></a>S2</h4><p>解析出entry，解析出错则设置错误状态，记录错误并返回false。解析成功则根据信息组成key和value，并更新重启点index。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">uint32_t shared, non_shared,value_length;</span><br><span class="line">p = DecodeEntry(p, limit,&amp;shared, &amp;non_shared, &amp;value_length);</span><br><span class="line">if (p == NULL || key_.size()&lt; shared) &#123;</span><br><span class="line">  CorruptionError();</span><br><span class="line">  return false;</span><br><span class="line">&#125; else &#123; // 成功</span><br><span class="line">  key_.resize(shared);</span><br><span class="line">  key_.append(p, non_shared);</span><br><span class="line">  value_ = Slice(p +non_shared, value_length);</span><br><span class="line">  while (restart_index_ + 1&lt; num_restarts_ &amp;&amp; GetRestartPoint(restart_index_ + 1) &lt; current_) &#123;</span><br><span class="line">       ++restart_index_; //更新重启点index</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>函数DecodeEntry从</strong>字符串[p, limit)解析出key的前缀长度、key前缀之后的字符串长度和value的长度这三个vint32值，代码很简单。</li>
<li><strong>函数CorruptionError将current_和restart_index_</strong>都设置为invalid状态，并在status中设置错误状态。</li>
<li><strong>函数GetRestartPoint</strong>从data中读取指定restart index的偏移值restart[index]，并返回：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DecodeFixed32(data_ + restarts_ +index * sizeof(uint32_t);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接下来看看Prev函数，Previous操作分为两步：首先回到current_之前的重启点，然后再向后直到current_，实现如下：</p>
</blockquote>
<h4 id="S1-5"><a href="#S1-5" class="headerlink" title="S1"></a>S1</h4><p>首先向前回跳到在current_前面的那个重启点，并定位到重启点的k/v对开始位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> original =current_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (GetRestartPoint(restart_index_)&gt;= original) &#123;</span><br><span class="line">        <span class="comment">// 到第一个entry了，标记invalid状态</span></span><br><span class="line">        <span class="keyword">if</span> (restart_index_ == <span class="number">0</span>) &#123; </span><br><span class="line">            current_ = restarts_;</span><br><span class="line">            restart_index_ =num_restarts_;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      restart_index_--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据restart index定位到重启点的k/v对</span></span><br><span class="line">SeekToRestartPoint(restart_index_);</span><br></pre></td></tr></table></figure>
<h4 id="S2-3"><a href="#S2-3" class="headerlink" title="S2"></a>S2</h4><p>第二步，从重启点位置开始向后遍历，直到遇到original前面的那个k/v对。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do &#123;&#125; while (ParseNextKey() &amp;&amp;NextEntryOffset() &lt; original);</span><br></pre></td></tr></table></figure>
<p>说说上面遇到的<strong>SeekToRestartPoint函数</strong>，它只是设置了几个有限的状态，其它值将在函数ParseNextKey()中设置。感觉这有点tricky，这里的value_并不是k/v对的value，而只是一个指向k/v对起始位置的0长度指针，这样后面的ParseNextKey函数将会取出重启点的k/v值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SeekToRestartPoint</span><span class="params">(uint32_tindex)</span> &#123;</span><br><span class="line">  key_.clear();</span><br><span class="line">  restart_index_ = index;</span><br><span class="line">  <span class="comment">// ParseNextKey()会设置current_;</span></span><br><span class="line">  <span class="comment">//ParseNextKey()从value_结尾开始, 因此需要相应的设置value_</span></span><br><span class="line">  <span class="type">uint32_t</span> offset =GetRestartPoint(index);</span><br><span class="line">  value_ = Slice(data_ + offset,<span class="number">0</span>); <span class="comment">// value长度设置为0，字符串指针是data_+offset</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SeekToFirst/Last，这两个函数都很简单，借助于前面的SeekToResartPoint函数就可以完成。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="type">void</span> <span class="title function_">SeekToFirst</span><span class="params">()</span> &#123;</span><br><span class="line">  SeekToRestartPoint(<span class="number">0</span>);</span><br><span class="line">  ParseNextKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">SeekToLast</span><span class="params">()</span> &#123;</span><br><span class="line">  SeekToRestartPoint(num_restarts_ - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (ParseNextKey()&amp;&amp; NextEntryOffset() &lt; restarts_) &#123;&#125; <span class="comment">//Keep skipping</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后一个Seek函数，跳到指定的target(Slice)，函数逻辑如下：</p>
</blockquote>
<h5 id="S1-6"><a href="#S1-6" class="headerlink" title="S1"></a>S1</h5><p>二分查找，找到key &lt; target的最后一个重启点，典型的二分查找算法，代码就不再贴了。</p>
<h5 id="S2-4"><a href="#S2-4" class="headerlink" title="S2"></a>S2</h5><p>找到后，跳转到重启点，其索引由left指定，这是前面二分查找到的结果。如前面所分析的，value_指向重启点的地址，而size_指定为0，这样ParseNextKey函数将会取出重启点的k/v值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SeekToRestartPoint(left);</span><br></pre></td></tr></table></figure>
<h5 id="S3-3"><a href="#S3-3" class="headerlink" title="S3"></a>S3</h5><p>自重启点线性向下，直到遇到key&gt;= target的k/v对。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!ParseNextKey()) <span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">if</span> (Compare(key_, target)&gt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是Block::Iter的全部实现逻辑，这样Block的创建和读取遍历都已经分析完毕。</p>
<h2 id="6-4-创建sstable文件"><a href="#6-4-创建sstable文件" class="headerlink" title="6.4 创建sstable文件"></a>6.4 创建sstable文件</h2><p>了解了<strong>sstable</strong>文件的存储格式，以及<strong>Data Block</strong>的组织，下面就可以分析如何创建sstable文件了。相关代码在table_builder.h/.cc以及block_builder.h/.cc（构建Block）中。</p>
<h4 id="6-4-1-TableBuilder类"><a href="#6-4-1-TableBuilder类" class="headerlink" title="6.4.1 TableBuilder类"></a>6.4.1 TableBuilder类</h4><p>构建sstable文件的类是<strong>TableBuilder</strong>，该类提供了几个有限的方法可以用来添加<strong>k/v对</strong>，Flush到文件中等等，它依赖于<strong>BlockBuilder</strong>来构建Block。</p>
<p>TableBuilder的几个接口说明下：</p>
<ol>
<li><strong>void Add(const Slice&amp; key, const Slice&amp; value)</strong>，向当前正在构建的表添加新的{key, value}对，要求根据Option指定的<strong>Comparator</strong>，key必须位于所有前面添加的key之后；</li>
<li><strong>void Flush()</strong>，将当前缓存的k/v全部flush到文件中，一个高级方法，大部分的client不需要直接调用该方法；</li>
<li>void Finish()，<strong>结束表的构建</strong>，该方法被调用后，将不再会使用传入的WritableFile；</li>
<li>void Abandon()，结束表的构建，并丢弃当前缓存的内容，该方法被调用后，将不再会使用传入的WritableFile；【<strong>只是设置closed为true，无其他操作</strong>】</li>
<li>一旦<strong>Finish()/Abandon()</strong>方法被调用，将不能再次执行Flush或者Add操作。</li>
</ol>
<p>下面来看看涉及到的类。</p>
<p>其中<strong>WritableFile和op log</strong>一样，使用的都是<strong>内存映射</strong>文件。Options是一些调用者可设置的选项。</p>
<p>TableBuilder只有一个成员变量<strong>Rep* rep_</strong>，实际上Rep结构体的成员就是TableBuilder所有的成员变量；这样做的<strong>目的</strong>，<strong>可能是为了隐藏其内部细</strong>节。Rep的定义也是在.cc文件中，对外是透明的。</p>
<p>简单解释下成员的含义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Options options;              <span class="comment">// data block的选项</span></span><br><span class="line">Options index_block_options;  <span class="comment">// index block的选项</span></span><br><span class="line">WritableFile* file;           <span class="comment">// sstable文件</span></span><br><span class="line"><span class="type">uint64_t</span> offset; </span><br><span class="line"><span class="comment">// 要写入data block在sstable文件中的偏移，初始0</span></span><br><span class="line">Status status;                <span class="comment">//当前状态-初始ok</span></span><br><span class="line">BlockBuilder data_block;      <span class="comment">//当前操作的data block</span></span><br><span class="line">BlockBuilder index_block;     <span class="comment">// sstable的index block</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> last_key;         <span class="comment">//当前data block最后的k/v对的key</span></span><br><span class="line"><span class="type">int64_t</span> num_entries;          <span class="comment">//当前data block的个数，初始0</span></span><br><span class="line"><span class="type">bool</span> closed;                  <span class="comment">//调用了Finish() or Abandon()，初始false</span></span><br><span class="line">FilterBlockBuilder*filter_block; </span><br><span class="line"><span class="comment">//根据filter数据快速定位key是否在block中</span></span><br><span class="line"><span class="type">bool</span> pending_index_entry;     <span class="comment">//见下面的Add函数，初始false</span></span><br><span class="line">BlockHandle pending_handle;   <span class="comment">//添加到index block的data block的信息</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> compressed_output;<span class="comment">//压缩后的data block，临时存储，写入后即被清空</span></span><br></pre></td></tr></table></figure>
<p>Filter block是存储的<strong>过滤器信息</strong>，它会存储{key, 对应data block在sstable的偏移值}，<strong>不一定</strong>是<strong>完全精确</strong>的，以快速定位给定key是否在data block中。</p>
<p>下面分析如何向<strong>sstable中添加k/v对</strong>，创建并持久化sstable。其它函数都比较简单，略过。另外对于Abandon，简单设置<strong>closed=true</strong>即返回。</p>
<h3 id="6-4-2-添加k-v对"><a href="#6-4-2-添加k-v对" class="headerlink" title="6.4.2 添加k/v对"></a>6.4.2 添加k/v对</h3><p>这是通过方法<strong>Add(constSlice&amp; key, const Slice&amp; value)</strong>完成的，没有返回值。下面分析下函数的逻辑：</p>
<p><strong>S1 首先保证文件没有close，也就是没有调用过Finish/Abandon，以及保证当前status是ok的；如果当前有缓存的kv对，保证新加入的key是最大的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rep* r = rep_;</span><br><span class="line">assert(!r-&gt;closed);</span><br><span class="line"><span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (r-&gt;num_entries &gt; <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">    assert(r-&gt;options.comparator-&gt;Compare(key, Slice(r-&gt;last_key))&gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>S2 如果标记r-&gt;pending_index_entry为true，表明遇到下一个data block的第一个k/v，根据key调整r-&gt;last_key，这是通过Comparator的FindShortestSeparator完成的。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r-&gt;pending_index_entry) </span><br><span class="line">&#123;</span><br><span class="line">     assert(r-&gt;data_block.empty());</span><br><span class="line">     r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key,key);</span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">     r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">     r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line">     r-&gt;pending_index_entry =<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来将pending_handle加入到<strong>index block中</strong>{r-&gt;last_key, r-&gt;pending_handle’sstring}。最后将r-&gt;pending_index_entry设置为false。</p>
<p>值得讲讲<strong>pending_index_entry</strong>这个标记的意义，见代码注释：</p>
<p><strong>直到</strong>遇到<strong>下一个databock</strong>的第一个key时，我们才为上一个datablock生成index entry，这样的<strong>好处</strong>是：可以为index使用较短的key；比如上一个data block最后一个k/v的key是”the quick brown fox”，其后继data block的第一个key是”the who”，我们就可以用一个<strong>较短的字符串</strong>“the r”作为上一个data block的index block entry的key。</p>
<p>简而言之，就是在开始<strong>下一个datablock</strong>时，Leveldb才将上一个data block加入到index block中。标记<strong>pending_index_entry</strong>就是干这个用的，对应data block的index entry信息就保存在（BlockHandle）pending_handle。</p>
<p><strong>S3 如果filter_block不为空，就把key加入到filter_block中。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (r-&gt;filter_block != NULL) </span><br><span class="line">&#123;</span><br><span class="line">    r-&gt;filter_block-&gt;AddKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>S4 设置r-&gt;last_key = key，将(key, value)添加到r-&gt;data_block中，并更新entry数。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r-&gt;last_key.assign(key.data(), key.size());</span><br><span class="line">r-&gt;num_entries++;</span><br><span class="line">r-&gt;data_block.Add(key,value);</span><br></pre></td></tr></table></figure>
<p><strong>S5 如果data block的个数超过限制，就立刻Flush到文件中。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const size_testimated_block_size = r-&gt;data_block.CurrentSizeEstimate();</span><br><span class="line">if (estimated_block_size &gt;=r-&gt;options.block_size)  Flush();</span><br></pre></td></tr></table></figure>
<h3 id="6-4-3-Flush文件"><a href="#6-4-3-Flush文件" class="headerlink" title="6.4.3 Flush文件"></a>6.4.3 Flush文件</h3><p>该函数逻辑比较简单，直接见代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Rep* r = rep_;</span><br><span class="line">assert(!r-&gt;closed);               <span class="comment">// 首先保证未关闭，且状态ok</span></span><br><span class="line"><span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (r-&gt;data_block.empty())<span class="keyword">return</span>; <span class="comment">// data block是空的</span></span><br><span class="line"><span class="comment">// 保证pending_index_entry为false，即data block的Add已经完成</span></span><br><span class="line">assert(!r-&gt;pending_index_entry);</span><br><span class="line"><span class="comment">// 写入data block，并设置其index entry信息—BlockHandle对象</span></span><br><span class="line">WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);</span><br><span class="line"><span class="comment">//写入成功，则Flush文件，并设置r-&gt;pending_index_entry为true，</span></span><br><span class="line"><span class="comment">//以根据下一个data block的first key调整index entry的key—即r-&gt;last_key</span></span><br><span class="line"><span class="keyword">if</span> (ok()) </span><br><span class="line">&#123;</span><br><span class="line">     r-&gt;pending_index_entry =<span class="literal">true</span>;</span><br><span class="line">     r-&gt;status =r-&gt;file-&gt;Flush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">NULL</span>)</span><br><span class="line">&#123; </span><br><span class="line">     <span class="comment">//将data block在sstable中的便宜加入到filter block中</span></span><br><span class="line">     r-&gt;filter_block-&gt;StartBlock(r-&gt;offset); </span><br><span class="line">     <span class="comment">// 并指明开始新的data block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-4-4-WriteBlock函数"><a href="#6-4-4-WriteBlock函数" class="headerlink" title="6.4.4 WriteBlock函数"></a>6.4.4 WriteBlock函数</h3><p>在Flush文件时，会调用WriteBlock函数将data block写入到文件中，该函数同时还设置<strong>data block的index entry</strong>信息。原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">WriteBlock</span><span class="params">(BlockBuilder* block, BlockHandle* handle)</span></span><br></pre></td></tr></table></figure>
<p>该函数做些预处理工作，<strong>序列化</strong>要写入的data block，根据需要压缩数据，真正的写入逻辑是在<strong>WriteRawBlock</strong>函数中。下面分析该函数的处理逻辑。</p>
<p><strong>S1 获得block的序列化数据Slice，根据配置参数决定是否压缩，以及根据压缩格式压缩数据内容。对于Snappy压缩，如果压缩率太低&lt;12.5%，还是作为未压缩内容存储。</strong></p>
<p>BlockBuilder的Finish()函数将data block的数据序列化成一个<strong>Slice</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Rep* r = rep_;</span><br><span class="line">Slice raw = block-&gt;Finish(); </span><br><span class="line"><span class="comment">// 获得data block的序列化字符串</span></span><br><span class="line">Slice block_contents;</span><br><span class="line">CompressionType type =r-&gt;options.compression;</span><br><span class="line"><span class="keyword">switch</span> (type)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">case</span> kNoCompression: block_contents= raw; <span class="keyword">break</span>; <span class="comment">// 不压缩</span></span><br><span class="line">     <span class="keyword">case</span> kSnappyCompression: </span><br><span class="line">     &#123; </span><br><span class="line">          <span class="comment">// snappy压缩格式</span></span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">string</span>* compressed =&amp;r-&gt;compressed_output;</span><br><span class="line">          <span class="keyword">if</span>(port::Snappy_Compress(raw.data(), raw.size(), compressed) &amp;&amp;</span><br><span class="line">             compressed-&gt;size()&lt; raw.size() - (raw.size() / <span class="number">8u</span>)) </span><br><span class="line">          &#123;</span><br><span class="line">                block_contents =*compressed;</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">          &#123; </span><br><span class="line">                 <span class="comment">// 如果不支持Snappy，或者压缩率低于12.5%，依然当作不压缩存储</span></span><br><span class="line">                 block_contents = raw;</span><br><span class="line">                 type = kNoCompression;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><strong>S2 将data内容写入到文件，并重置block成初始化状态，清空compressedoutput。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WriteRawBlock(block_contents,type, handle);  </span><br><span class="line">r-&gt;compressed_output.clear();  </span><br><span class="line">block-&gt;Reset();</span><br></pre></td></tr></table></figure>
<h3 id="6-4-5-WriteRawBlock函数"><a href="#6-4-5-WriteRawBlock函数" class="headerlink" title="6.4.5 WriteRawBlock函数"></a>6.4.5 WriteRawBlock函数</h3><p>在WriteBlock把准备工作都做好后，就可以写入到<strong>sstable</strong>文件中了。来看函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">WriteRawBlock</span><span class="params">(<span class="type">const</span> Slice&amp; data, CompressionType, BlockHandle*handle)</span>;</span><br></pre></td></tr></table></figure>
<p>函数逻辑很简单，见代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Rep* r = rep_;</span><br><span class="line">handle-&gt;set_offset(r-&gt;offset); </span><br><span class="line"><span class="comment">// 为index设置data block的handle信息</span></span><br><span class="line">handle-&gt;set_size(block_contents.size());</span><br><span class="line">r-&gt;status =r-&gt;file-&gt;Append(block_contents); <span class="comment">// 写入data block内容</span></span><br><span class="line"><span class="keyword">if</span> (r-&gt;status.ok()) </span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 写入1byte的type和4bytes的crc32</span></span><br><span class="line">     chartrailer[kBlockTrailerSize];</span><br><span class="line">     trailer[<span class="number">0</span>] = type;</span><br><span class="line">     <span class="type">uint32_t</span> crc = crc32c::Value(block_contents.data(),</span><br><span class="line">                                  block_contents.size());</span><br><span class="line">     crc = crc32c::Extend(crc, trailer, <span class="number">1</span>);  <span class="comment">// Extend crc tocover block type</span></span><br><span class="line">     EncodeFixed32(trailer+<span class="number">1</span>, crc32c::Mask(crc));</span><br><span class="line">     r-&gt;status =r-&gt;file-&gt;Append(Slice(trailer, kBlockTrailerSize));</span><br><span class="line">     <span class="keyword">if</span> (r-&gt;status.ok()) </span><br><span class="line">     &#123; </span><br><span class="line">          <span class="comment">// 写入成功更新offset-下一个data block的写入偏移</span></span><br><span class="line">          r-&gt;offset +=block_contents.size() + kBlockTrailerSize;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-4-6-Finish函数"><a href="#6-4-6-Finish函数" class="headerlink" title="6.4.6 Finish函数"></a>6.4.6 Finish函数</h3><p>调用Finish函数，表明调用者将所有已经添加的<strong>k/v对</strong>持久化到sstable，并关闭sstable文件。</p>
<p>该函数逻辑很清晰，可<strong>分为5部分</strong>。</p>
<p><strong>S1 首先调用Flush，写入最后的一块data block，然后设置关闭标志closed=true。表明该sstable已经关闭，不能再添加k/v对。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rep* r = rep_;</span><br><span class="line">Flush();</span><br><span class="line">assert(!r-&gt;closed);</span><br><span class="line">r-&gt;closed = true;</span><br><span class="line">BlockHandle filter_block_handle,metaindex_block_handle, index_block_handle;</span><br></pre></td></tr></table></figure>
<p><strong>S2 写入filter block到文件中。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (ok() &amp;&amp;r-&gt;filter_block != NULL) </span><br><span class="line">&#123;</span><br><span class="line">     WriteRawBlock(r-&gt;filter_block-&gt;Finish(), kNoCompression,&amp;filter_block_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>S3 写入meta index block到文件中。</strong></p>
<p>如果filterblock不为NULL，则加入从”filter.Name”到filter data位置的映射。通过<strong>meta index block</strong>，可以根据filter名字快速定位到filter的数据区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (ok()) </span><br><span class="line">&#123;</span><br><span class="line">     BlockBuildermeta_index_block(&amp;r-&gt;options);</span><br><span class="line">     if (r-&gt;filter_block !=NULL) </span><br><span class="line">     &#123;</span><br><span class="line">          //加入从&quot;filter.Name&quot;到filter data位置的映射</span><br><span class="line">          std::string key =&quot;filter.&quot;;</span><br><span class="line">          key.append(r-&gt;options.filter_policy-&gt;Name());</span><br><span class="line">          std::string handle_encoding;</span><br><span class="line">          filter_block_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">          meta_index_block.Add(key,handle_encoding);</span><br><span class="line">     &#125;</span><br><span class="line">     // TODO(postrelease): Add stats and other metablocks</span><br><span class="line">     WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>S4 写入index block，如果成功Flush过data block，那么需要为最后一块data block设置index block，并加入到index block中。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if (ok()) </span><br><span class="line">&#123;</span><br><span class="line">     if (r-&gt;pending_index_entry)</span><br><span class="line">     &#123; </span><br><span class="line">          // Flush时会被设置为true</span><br><span class="line">          r-&gt;options.comparator-&gt;FindShortSuccessor(&amp;r-&gt;last_key);</span><br><span class="line">          std::string handle_encoding;</span><br><span class="line">          r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">          r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding)); </span><br><span class="line">          // 加入到index block中</span><br><span class="line">          r-&gt;pending_index_entry =false;</span><br><span class="line">      &#125;</span><br><span class="line">      WriteBlock(&amp;r-&gt;index_block, &amp;index_block_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>S5 写入Footer。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (ok()) </span><br><span class="line">&#123;</span><br><span class="line">     Footer footer;</span><br><span class="line">     footer.set_metaindex_handle(metaindex_block_handle);</span><br><span class="line">     footer.set_index_handle(index_block_handle);</span><br><span class="line">     std::string footer_encoding;</span><br><span class="line">     footer.EncodeTo(&amp;footer_encoding);</span><br><span class="line">     r-&gt;status =r-&gt;file-&gt;Append(footer_encoding);</span><br><span class="line">     if (r-&gt;status.ok()) </span><br><span class="line">     &#123;</span><br><span class="line">          r-&gt;offset +=footer_encoding.size();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个写入流程就分析完了，对于<strong>Datablock和Filter Block</strong>的操作将在<strong>Data block和Filter Block中</strong>单独分析，下面的读取相同。</p>
<h2 id="6-5-读取sstable文件"><a href="#6-5-读取sstable文件" class="headerlink" title="6.5 读取sstable文件"></a>6.5 读取sstable文件</h2><h3 id="6-5-1-类层次"><a href="#6-5-1-类层次" class="headerlink" title="6.5.1 类层次"></a>6.5.1 类层次</h3><p><strong>Sstable</strong>文件的读取逻辑在<strong>类Table</strong>中，其中涉及到的类还是比较多的，如图6.5-1所示。</p>
<p><img src="/img/leveldb12.webp" alt="img"></p>
<p>Table类导出的函数只有<strong>3个</strong>，先从这三个导出函数开始分析。其中涉及到的类（包括上图中为画出的）都会一一遇到，然后再一一拆解。</p>
<p>本节分析<strong>sstable的打开逻辑</strong>，后面再分析key的查找与数据遍历。</p>
<h3 id="6-5-2-Table-Open"><a href="#6-5-2-Table-Open" class="headerlink" title="6.5.2 Table::Open()"></a>6.5.2 Table::Open()</h3><p>打开一个sstable文件，函数声明为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Status <span class="title function_">Open</span><span class="params">(<span class="type">const</span> Options&amp; options, RandomAccessFile* file,</span></span><br><span class="line"><span class="params">                   uint64_tfile_size, Table** table)</span>;</span><br></pre></td></tr></table></figure>
<p>这是Table类的一个<strong>静态函数</strong>，如果操作成功，指针<strong>*table</strong>指向新打开的表，否则返回错误。</p>
<p>要打开的文件和大小分别由<strong>参数file和file_size</strong>指定；option是一些选项；</p>
<p>下面就分析下函数逻辑：</p>
<h5 id="S1-7"><a href="#S1-7" class="headerlink" title="S1"></a>S1</h5><p>首先从文件的结尾读取Footer，并Decode到Footer对象中，如果文件长度小于Footer的长度，则报错。Footer的decode很简单，就是根据前面的Footer结构，解析并判断magic number是否正确，解析出meta index和index block的偏移和长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*table = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;Footer::kEncodedLength) </span><br><span class="line">&#123; </span><br><span class="line">     <span class="comment">// 文件太短</span></span><br><span class="line">     returnStatus::InvalidArgument(<span class="string">&quot;file is too short to be an sstable&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">charfooter_space[Footer::kEncodedLength]; <span class="comment">// Footer大小是固定的</span></span><br><span class="line">Slice footer_input;</span><br><span class="line">Status s = file-&gt;Read(size -Footer::kEncodedLength, Footer::kEncodedLength,</span><br><span class="line">                      &amp;footer_input, footer_space);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</span><br><span class="line">Footer footer;</span><br><span class="line">s =footer.DecodeFrom(&amp;footer_input);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure>
<h5 id="S2-5"><a href="#S2-5" class="headerlink" title="S2"></a>S2</h5><p>解析出了Footer，我们就可以读取index block和meta index了，首先读取index block。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BlockContents contents;</span><br><span class="line">Block* index_block = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (s.ok()) </span><br><span class="line">&#123;</span><br><span class="line">     s = ReadBlock(file, ReadOptions(),footer.index_handle(), &amp;contents);</span><br><span class="line">     <span class="keyword">if</span> (s.ok())</span><br><span class="line">     &#123;</span><br><span class="line">          index_block = newBlock(contents);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是通过调用<strong>ReadBlock</strong>完成的，下面会分析这个函数。</p>
<h5 id="S3-4"><a href="#S3-4" class="headerlink" title="S3"></a>S3</h5><p>已经成功读取了footer和index block，此时table已经可以响应请求了。构建table对象，并读取metaindex数据构建filter policy。如果option打开了cache，还要为table创建cache。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok())</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 已成功读取footer和index block: 可以响应请求了</span></span><br><span class="line">     Rep* rep = new Table::Rep;</span><br><span class="line">     rep-&gt;options = options;</span><br><span class="line">     rep-&gt;file = file;</span><br><span class="line">     rep-&gt;metaindex_handle =footer.metaindex_handle();</span><br><span class="line">     rep-&gt;index_block =index_block;</span><br><span class="line">     rep-&gt;cache_id =(options.block_cache ? options.block_cache-&gt;NewId() : <span class="number">0</span>);</span><br><span class="line">     rep-&gt;filter_data = rep-&gt;filter= <span class="literal">NULL</span>;</span><br><span class="line">     *table = new Table(rep);</span><br><span class="line">     (*table)-&gt;ReadMeta(footer);</span><br><span class="line">     <span class="comment">// 调用ReadMeta读取metaindex</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (index_block) deleteindex_block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，Table的打开操作就已经为完成了。下面来分析上面用到的<strong>ReadBlock()和ReadMeta()函数</strong>。</p>
<h3 id="6-5-3-ReadBlock"><a href="#6-5-3-ReadBlock" class="headerlink" title="6.5.3 ReadBlock()"></a>6.5.3 ReadBlock()</h3><p>前面讲过block的格式，以及Block的写入（TableBuilder::WriteRawBlock），现在我们可以轻松的分析<strong>Block的读取操作</strong>了。</p>
<p>这是一个<strong>全局函数</strong>，声明为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Status ReadBlock(RandomAccessFile* file, const ReadOptions&amp; options, </span><br><span class="line">                 const BlockHandle&amp;handle, BlockContents* result);</span><br></pre></td></tr></table></figure>
<p>下面来分析实现逻辑：</p>
<h5 id="S1-8"><a href="#S1-8" class="headerlink" title="S1"></a>S1</h5><p>初始化结果result，BlockContents是一个有3个成员的结构体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result-&gt;data = Slice();</span><br><span class="line">result-&gt;cachable = false;      // 无cache</span><br><span class="line">result-&gt;heap_allocated =false; // 非heap分配</span><br></pre></td></tr></table></figure>
<h5 id="S2-6"><a href="#S2-6" class="headerlink" title="S2"></a>S2</h5><p>根据handle指定的偏移和大小，读取block内容，type和crc32值，其中常量kBlockTrailerSize=5= 1byte的type和4bytes的crc32。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Status s = file-&gt;Read(handle.offset(),handle.size() + kBlockTrailerSize,</span><br><span class="line">                      &amp;contents, buf);</span><br></pre></td></tr></table></figure>
<h5 id="S3-5"><a href="#S3-5" class="headerlink" title="S3"></a>S3</h5><p>如果option要校验CRC32，则计算content + type的CRC32并校验。</p>
<h5 id="S4-1"><a href="#S4-1" class="headerlink" title="S4"></a>S4</h5><p>最后根据type指定的存储类型，如果是非压缩的，则直接取数据赋给result，否则先解压，把解压结果赋给result，目前支持的是snappy压缩。</p>
<p>另外，文件的<strong>Read接口</strong>返回的Slice结果，其data指针可能没有使用我们传入的buf，如果没有，那么释放Slice的<strong>data指针</strong>就是我们的事情，否则就是文件来管理的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data != buf) </span><br><span class="line">&#123; </span><br><span class="line">     <span class="comment">// 文件自己管理，cacheable等标记设置为false</span></span><br><span class="line">     delete[] buf;</span><br><span class="line">     result-&gt;data =Slice(data, n);</span><br><span class="line">     result-&gt;heap_allocated= result-&gt;cachable =<span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line">      <span class="comment">// 读取者自己管理，标记设置为true</span></span><br><span class="line">      result-&gt;data =Slice(buf, n);</span><br><span class="line">      result-&gt;heap_allocated= result-&gt;cachable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于压缩存储，解压后的字符串存储需要读取者自行分配的，所以标记都是<strong>true</strong>。</p>
<h3 id="6-5-4-Table-ReadMeta"><a href="#6-5-4-Table-ReadMeta" class="headerlink" title="6.5.4 Table::ReadMeta()"></a>6.5.4 Table::ReadMeta()</h3><p>解决完了Block的读取，接下来就是<strong>meta的读</strong>取了。函数声明为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Table::ReadMeta</span><span class="params">(<span class="type">const</span> Footer&amp; footer)</span></span><br></pre></td></tr></table></figure>
<p>函数逻辑并不复杂。</p>
<h5 id="S1-9"><a href="#S1-9" class="headerlink" title="S1"></a>S1</h5><p>首先调用ReadBlock读取meta的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(rep_-&gt;options.filter_policy == <span class="literal">NULL</span>) <span class="keyword">return</span>; </span><br><span class="line"><span class="comment">// 不需要metadata</span></span><br><span class="line">ReadOptions opt;</span><br><span class="line">BlockContents contents;</span><br><span class="line"><span class="keyword">if</span> (!ReadBlock(rep_-&gt;file,opt, footer.metaindex_handle(), &amp;contents).ok()) </span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">return</span>;  <span class="comment">// 失败了也没报错，因为没有meta信息也没关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="S2-7"><a href="#S2-7" class="headerlink" title="S2"></a>S2</h5><p>根据读取的content构建Block，找到指定的filter；如果找到了就调用ReadFilter构建filter对象。Block的分析留在后面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Block* meta = newBlock(contents);</span><br><span class="line">Iterator* iter =meta-&gt;NewIterator(BytewiseComparator());</span><br><span class="line">std::string key =&quot;filter.&quot;;</span><br><span class="line">key.append(rep_-&gt;options.filter_policy-&gt;Name());</span><br><span class="line">iter-&gt;Seek(key);</span><br><span class="line">if (iter-&gt;Valid() &amp;&amp;iter-&gt;key() == Slice(key)) ReadFilter(iter-&gt;value());</span><br><span class="line">delete iter;</span><br><span class="line">delete meta;</span><br></pre></td></tr></table></figure>
<h3 id="6-5-5-Table-ReadFilter"><a href="#6-5-5-Table-ReadFilter" class="headerlink" title="6.5.5 Table::ReadFilter()"></a>6.5.5 Table::ReadFilter()</h3><p>根据指定的偏移和大小，<strong>读取filter</strong>，函数声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void ReadFilter(const Slice&amp; filter_handle_value);</span><br></pre></td></tr></table></figure>
<p>简单分析下函数逻辑：</p>
<h5 id="S1-10"><a href="#S1-10" class="headerlink" title="S1"></a>S1</h5><p>从传入的filter_handle_value Decode出BlockHandle，这是filter的偏移和大小；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BlockHandle filter_handle;</span><br><span class="line">filter_handle.DecodeFrom(&amp;filter_handle_value);</span><br></pre></td></tr></table></figure>
<h5 id="S2-8"><a href="#S2-8" class="headerlink" title="S2"></a>S2</h5><p>根据解析出的位置读取filter内容，ReadBlock。如果block的heap_allocated为true，表明需要自行释放内存，因此要把指针保存在filter_data中。最后根据读取的data创建FilterBlockReader对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReadOptions opt;</span><br><span class="line">BlockContents block;</span><br><span class="line">ReadBlock(rep_-&gt;file, opt,filter_handle, &amp;block);</span><br><span class="line">if (block.heap_allocated)rep_-&gt;filter_data = block.data.data(); </span><br><span class="line">// 需要自行释放内存</span><br><span class="line">rep_-&gt;filter = newFilterBlockReader(rep_-&gt;options.filter_policy, block.data);</span><br></pre></td></tr></table></figure>
<p>以上就是<strong>sstable文件的读取操作</strong>，不算复杂。</p>
<h2 id="6-6-遍历Table"><a href="#6-6-遍历Table" class="headerlink" title="6.6 遍历Table"></a>6.6 遍历Table</h2><h3 id="6-6-1-遍历接口"><a href="#6-6-1-遍历接口" class="headerlink" title="6.6.1 遍历接口"></a>6.6.1 遍历接口</h3><p>Table导出了一个返回<strong>Iterator</strong>的接口，通过Iterator对象，调用者就可以<strong>遍历</strong>Table的内容，它简单的返回了一个<strong>TwoLevelIterator</strong>对象。见函数实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator* <span class="title function_">NewIterator</span><span class="params">(<span class="type">const</span> ReadOptions&amp;options)</span> <span class="type">const</span>;  </span><br><span class="line">&#123;  </span><br><span class="line">     <span class="keyword">return</span> NewTwoLevelIterator(rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator),  </span><br><span class="line">                                &amp;Table::BlockReader,const_cast&lt;Table*&gt;(this), options);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 函数NewTwoLevelIterator创建了一个TwoLevelIterator对象：  </span></span><br><span class="line">Iterator* <span class="title function_">NewTwoLevelIterator</span><span class="params">(Iterator* index_iter,BlockFunction block_function,  </span></span><br><span class="line"><span class="params">                              <span class="type">void</span>* arg, constReadOptions&amp; options)</span> </span><br><span class="line">&#123;  </span><br><span class="line">     <span class="keyword">return</span> newTwoLevelIterator(index_iter, block_function, arg, options);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这里有一个函数指针BlockFunction，类型为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef Iterator* (*BlockFunction)(void*, const ReadOptions&amp;, constSlice&amp;);</span><br></pre></td></tr></table></figure>
<p><strong>为什么叫TwoLevelIterator呢</strong>，下面就来看看。</p>
<h3 id="6-6-2-TwoLevelIterator"><a href="#6-6-2-TwoLevelIterator" class="headerlink" title="6.6.2 TwoLevelIterator"></a>6.6.2 TwoLevelIterator</h3><p>它也是<strong>Iterator的子类</strong>，之所以叫two level应该是不仅可以迭代其中存储的对象，它还接受了一个函数<strong>BlockFunction</strong>，可以遍历存储的对象，可见它是专门为<strong>Table定制</strong>的。<br>我们已经知道各种Block的<strong>存储格式</strong>都是<strong>相同</strong>的，但是各自block data存储的<strong>k/v</strong>又<strong>互不相同</strong>，于是我们就需要一个途径，能够在使用同一个方式<strong>遍历</strong>不同的block时，又能<strong>解析</strong>这些k/v。这就是<strong>BlockFunction</strong>，它又返回了一个针对block data的Iterator。<strong>Block和block data</strong>存储的k/v对的key是统一的。<br>先来看类的主要成员变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BlockFunction block_function_; <span class="comment">// block操作函数  </span></span><br><span class="line"><span class="type">void</span>* arg_;                    <span class="comment">// BlockFunction的自定义参数  </span></span><br><span class="line"><span class="type">const</span> ReadOptions options_;    <span class="comment">// BlockFunction的read option参数  </span></span><br><span class="line">Status status_;                <span class="comment">// 当前状态  </span></span><br><span class="line">IteratorWrapper index_iter_;   <span class="comment">// 遍历block的迭代器  </span></span><br><span class="line">IteratorWrapper data_iter_;    <span class="comment">// May be NULL-遍历block data的迭代器  </span></span><br><span class="line"><span class="comment">// 如果data_iter_ != NULL，data_block_handle_保存的是传递给  </span></span><br><span class="line"><span class="comment">// block_function_的index value，以用来创建data_iter_  </span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data_block_handle_; </span><br></pre></td></tr></table></figure>
<p>下面<strong>分析一下对于Iterator几个接口的实现。</strong></p>
<h5 id="S1-11"><a href="#S1-11" class="headerlink" title="S1"></a>S1</h5><p>对于其Key和Value接口都是返回的data_iter_对应的key和value：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="type">bool</span> <span class="title function_">Valid</span><span class="params">()</span> <span class="type">const</span> </span><br><span class="line">&#123;  </span><br><span class="line">      <span class="keyword">return</span> data_iter_.Valid();  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">virtual Slice <span class="title function_">key</span><span class="params">()</span> <span class="type">const</span> </span><br><span class="line">&#123;   </span><br><span class="line">       assert(Valid());  </span><br><span class="line">       <span class="keyword">return</span> data_iter_.key();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual Slice <span class="title function_">value</span><span class="params">()</span> <span class="type">const</span> </span><br><span class="line">&#123;  </span><br><span class="line">       assert(Valid());  </span><br><span class="line">       <span class="keyword">return</span> data_iter_.value();  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong>S2 在分析Seek系函数之前</strong>，有必要先了解下面这几个函数的用途。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void InitDataBlock();  </span><br><span class="line">void SetDataIterator(Iterator*data_iter); </span><br><span class="line">//设置date_iter_ = data_iter  </span><br><span class="line">voidSkipEmptyDataBlocksForward();  </span><br><span class="line">voidSkipEmptyDataBlocksBackward(); </span><br></pre></td></tr></table></figure>
<h6 id="S2-1"><a href="#S2-1" class="headerlink" title="S2.1"></a>S2.1</h6><p>首先是InitDataBlock()，它是根据index_iter来初始化data_iter，当定位到新的block时，需要更新data Iterator，指向该block中k/v对的合适位置，函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!index_iter_.Valid()) SetDataIterator(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// index_iter非法  </span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;  </span><br><span class="line">      Slice handle =index_iter_.value();  </span><br><span class="line">      <span class="keyword">if</span> (data_iter_.iter() != <span class="literal">NULL</span>&amp;&amp; handle.compare(data_block_handle_) == <span class="number">0</span>)</span><br><span class="line">      &#123;  </span><br><span class="line">           <span class="comment">//data_iter已经在该block data上了，无须改变  </span></span><br><span class="line">         &#125; </span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">      &#123; </span><br><span class="line">           <span class="comment">// 根据handle数据定位data iter  </span></span><br><span class="line">           Iterator* iter =(*block_function_)(arg_, options_, handle);  </span><br><span class="line">           data_block_handle_.assign(handle.data(), handle.size());  </span><br><span class="line">           SetDataIterator(iter);  </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="S2-2"><a href="#S2-2" class="headerlink" title="S2.2"></a>S2.2</h6><p>SkipEmptyDataBlocksForward，向前跳过空的datablock，函数实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">while (data_iter_.iter() == NULL|| !data_iter_.Valid()) </span><br><span class="line">&#123;   </span><br><span class="line">      // 跳到下一个block  </span><br><span class="line">      if (!index_iter_.Valid()) </span><br><span class="line">      &#123; </span><br><span class="line">           // 如果index iter非法，设置data iteration为NULL  </span><br><span class="line">           SetDataIterator(NULL);  </span><br><span class="line">           return;  </span><br><span class="line">         &#125;  </span><br><span class="line">      index_iter_.Next();  </span><br><span class="line">      InitDataBlock();  </span><br><span class="line">      if (data_iter_.iter() != NULL)data_iter_.SeekToFirst();</span><br><span class="line">      // 跳转到开始  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h6 id="S2-3"><a href="#S2-3" class="headerlink" title="S2.3"></a>S2.3</h6><p>SkipEmptyDataBlocksBackward，向后跳过空的datablock，函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (data_iter_.iter() == <span class="literal">NULL</span>|| !data_iter_.Valid()) </span><br><span class="line">&#123; </span><br><span class="line">     <span class="comment">// 跳到前一个block  </span></span><br><span class="line">     <span class="keyword">if</span> (!index_iter_.Valid()) </span><br><span class="line">     &#123; </span><br><span class="line">          <span class="comment">// 如果index iter非法，设置data iteration为NULL  </span></span><br><span class="line">          SetDataIterator(<span class="literal">NULL</span>);  </span><br><span class="line">          <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        index_iter_.Prev();  </span><br><span class="line">      InitDataBlock();  </span><br><span class="line">      <span class="keyword">if</span> (data_iter_.iter() != <span class="literal">NULL</span>)data_iter_.SeekToLast();</span><br><span class="line">      <span class="comment">// 跳转到开始  </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h5 id="S3-6"><a href="#S3-6" class="headerlink" title="S3"></a>S3</h5><p>了解了几个跳转的辅助函数，再来看Seek系接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TwoLevelIterator::Seek</span><span class="params">(<span class="type">const</span> Slice&amp; target)</span> </span><br><span class="line">&#123;  </span><br><span class="line">    index_iter_.Seek(target);  </span><br><span class="line">    InitDataBlock(); </span><br><span class="line">    <span class="comment">// 根据index iter设置data iter  </span></span><br><span class="line">    <span class="keyword">if</span> (data_iter_.iter() != <span class="literal">NULL</span>)data_iter_.Seek(target); </span><br><span class="line">    <span class="comment">// 调整data iter跳转到target  </span></span><br><span class="line">    SkipEmptyDataBlocksForward(); </span><br><span class="line">    <span class="comment">// 调整iter，跳过空的block  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TwoLevelIterator::SeekToFirst</span><span class="params">()</span> </span><br><span class="line">&#123;  </span><br><span class="line">    index_iter_.SeekToFirst();  </span><br><span class="line">    InitDataBlock();              <span class="comment">// 根据index iter设置data iter  </span></span><br><span class="line">    <span class="keyword">if</span> (data_iter_.iter() != <span class="literal">NULL</span>)data_iter_.SeekToFirst();  </span><br><span class="line">    SkipEmptyDataBlocksForward(); <span class="comment">// 调整iter，跳过空的block  </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TwoLevelIterator::SeekToLast</span><span class="params">()</span> </span><br><span class="line">&#123;  </span><br><span class="line">    index_iter_.SeekToLast();  </span><br><span class="line">    InitDataBlock();              <span class="comment">// 根据index iter设置data iter  </span></span><br><span class="line">    <span class="keyword">if</span> (data_iter_.iter() != <span class="literal">NULL</span>)data_iter_.SeekToLast();  </span><br><span class="line">    SkipEmptyDataBlocksBackward();<span class="comment">// 调整iter，跳过空的block  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TwoLevelIterator::Next</span><span class="params">()</span> </span><br><span class="line">&#123;  </span><br><span class="line">     assert(Valid());  </span><br><span class="line">     data_iter_.Next();  </span><br><span class="line">     SkipEmptyDataBlocksForward(); <span class="comment">// 调整iter，跳过空的block  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TwoLevelIterator::Prev</span><span class="params">()</span></span><br><span class="line">&#123;  </span><br><span class="line">     assert(Valid());  </span><br><span class="line">     data_iter_.Prev();  </span><br><span class="line">     SkipEmptyDataBlocksBackward();<span class="comment">// 调整iter，跳过空的block  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="6-6-3-BlockReader"><a href="#6-6-3-BlockReader" class="headerlink" title="6.6.3 BlockReader()"></a>6.6.3 BlockReader()</h3><p>上面<strong>传递给twolevel Iterator的函数是Table::BlockReader函数</strong>，声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static Iterator* Table::BlockReader(void* arg, const ReadOptions&amp;options,</span><br><span class="line">                                  constSlice&amp; index_value);</span><br></pre></td></tr></table></figure>
<p>它根据参数指明的<strong>blockdata</strong>，返回一个iterator对象，调用者就可以通过这个iterator对象遍历blockdata存储的k/v对，这其中用到了<strong>LRUCache</strong>。<br>函数实现逻辑如下：</p>
<h5 id="S1-12"><a href="#S1-12" class="headerlink" title="S1"></a>S1</h5><p>从参数中解析出BlockHandle对象，其中arg就是Table对象，index_value存储的是BlockHandle对象，读取Block的索引。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Table* table =reinterpret_cast&lt;Table*&gt;(arg);  </span><br><span class="line">Block* block = <span class="literal">NULL</span>;  </span><br><span class="line">Cache::Handle* cache_handle =<span class="literal">NULL</span>;  </span><br><span class="line">BlockHandle handle;  </span><br><span class="line">Slice input = index_value;  </span><br><span class="line">Status s =handle.DecodeFrom(&amp;input);</span><br></pre></td></tr></table></figure>
<h5 id="S2-9"><a href="#S2-9" class="headerlink" title="S2"></a>S2</h5><p>根据block handle，首先尝试从cache中直接取出block，不在cache中则调用ReadBlock从文件读取，读取成功后，根据option尝试将block加入到LRU cache中。并在Insert的时候注册了释放函数DeleteCachedBlock。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Cache* block_cache =table-&gt;rep_-&gt;options.block_cache;  </span><br><span class="line">BlockContents contents;  </span><br><span class="line"><span class="keyword">if</span> (block_cache != <span class="literal">NULL</span>)</span><br><span class="line">&#123;  </span><br><span class="line">     <span class="type">char</span> cache_key_buffer[<span class="number">16</span>]; </span><br><span class="line">     <span class="comment">// cache key的格式为table.cache_id + offset  </span></span><br><span class="line">     EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id);  </span><br><span class="line">     EncodeFixed64(cache_key_buffer+<span class="number">8</span>, handle.offset());  </span><br><span class="line">     Slice <span class="title function_">key</span><span class="params">(cache_key_buffer,<span class="keyword">sizeof</span>(cache_key_buffer))</span>;  </span><br><span class="line">     cache_handle =block_cache-&gt;Lookup(key); <span class="comment">// 尝试从LRU cache中查找  </span></span><br><span class="line">     <span class="keyword">if</span> (cache_handle != <span class="literal">NULL</span>)</span><br><span class="line">     &#123; </span><br><span class="line">          <span class="comment">// 找到则直接取值  </span></span><br><span class="line">          block =reinterpret_cast&lt;Block*&gt;(block_cache-&gt;Value(cache_handle));  </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">     &#123; </span><br><span class="line">          <span class="comment">// 否则直接从文件读取  </span></span><br><span class="line">          s =ReadBlock(table-&gt;rep_-&gt;file, </span><br><span class="line">                       options, handle, &amp;contents);  </span><br><span class="line">          <span class="keyword">if</span> (s.ok()) </span><br><span class="line">          &#123;  </span><br><span class="line">               block = new Block(contents);  </span><br><span class="line">               <span class="keyword">if</span> (contents.cachable&amp;&amp; options.fill_cache) </span><br><span class="line">               <span class="comment">// 尝试加到cache中  </span></span><br><span class="line">              cache_handle =block_cache-&gt;Insert(key, block,block-&gt;size(), &amp;DeleteCachedBlock);  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;  </span><br><span class="line">     s =ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);  </span><br><span class="line">     <span class="keyword">if</span> (s.ok()) block = newBlock(contents);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="S3-7"><a href="#S3-7" class="headerlink" title="S3"></a>S3</h5><p>如果读取到了block，调用Block::NewIterator接口创建Iterator，如果cache handle为NULL，则注册DeleteBlock，否则注册ReleaseBlock，事后清理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator* iter;  </span><br><span class="line"><span class="keyword">if</span> (block != <span class="literal">NULL</span>)</span><br><span class="line">&#123;  </span><br><span class="line">    iter =block-&gt;NewIterator(table-&gt;rep_-&gt;options.comparator);  </span><br><span class="line">    <span class="keyword">if</span> (cache_handle == <span class="literal">NULL</span>)  iter-&gt;RegisterCleanup(&amp;DeleteBlock,block, <span class="literal">NULL</span>);  </span><br><span class="line">    <span class="keyword">else</span> iter-&gt;RegisterCleanup(&amp;ReleaseBlock,block_cache, cache_handle);  </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> iter = NewErrorIterator(s); </span><br></pre></td></tr></table></figure>
<p>处理结束，最后<strong>返回iter</strong>。这里简单列下这几个<strong>静态函数</strong>，都很简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DeleteBlock</span><span class="params">(<span class="type">void</span>* arg, <span class="type">void</span>* ignored)</span> </span><br><span class="line">&#123; </span><br><span class="line">     deletereinterpret_cast&lt;Block*&gt;(arg);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DeleteCachedBlock</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">void</span>* value)</span>   </span><br><span class="line">&#123;  </span><br><span class="line">      Block* block =reinterpret_cast&lt;Block*&gt;(value);  </span><br><span class="line">      delete block;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ReleaseBlock</span><span class="params">(<span class="type">void</span>* arg, <span class="type">void</span>* h)</span> </span><br><span class="line">&#123;  </span><br><span class="line">      Cache* cache =reinterpret_cast&lt;Cache*&gt;(arg);  </span><br><span class="line">      Cache::Handle* handle =reinterpret_cast&lt;Cache::Handle*&gt;(h);  </span><br><span class="line">      cache-&gt;Release(handle);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="6-7-定位key"><a href="#6-7-定位key" class="headerlink" title="6.7 定位key"></a>6.7 定位key</h2><p>这里并不是精确的定位，而是在Table中找到<strong>第一个&gt;=指定key的k/v对</strong>，然后返回其value在sstable文件中的偏移。也是Table类的一个接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint64_t ApproximateOffsetOf(const Slice&amp; key) const;</span><br></pre></td></tr></table></figure>
<p>函数实现比较简单：</p>
<h5 id="S1-13"><a href="#S1-13" class="headerlink" title="S1"></a>S1</h5><p>调用Block::Iter的Seek函数定位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Iterator* index_iter=rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator);  </span><br><span class="line">index_iter-&gt;Seek(key);  </span><br><span class="line">uint64_t result; </span><br></pre></td></tr></table></figure>
<h5 id="S2-10"><a href="#S2-10" class="headerlink" title="S2"></a>S2</h5><p>如果index_iter是合法的值，并且Decode成功，返回结果offset。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BlockHandle handle;  </span><br><span class="line">handle.DecodeFrom(&amp;index_iter-&gt;value());  </span><br><span class="line">result = handle.offset(); </span><br></pre></td></tr></table></figure>
<h5 id="S3-8"><a href="#S3-8" class="headerlink" title="S3"></a>S3</h5><p>其它情况，设置result为rep_-&gt;metaindex_handle.offset()，metaindex的偏移在文件结尾附近。</p>
<h2 id="6-8-获取Key—InternalGet"><a href="#6-8-获取Key—InternalGet" class="headerlink" title="6.8 获取Key—InternalGet()"></a>6.8 获取Key—InternalGet()</h2><p><strong>InternalGet</strong>，这是为TableCache开的一个口子。这是一个<strong>private函数</strong>，声明为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Table::InternalGet</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options, constSlice&amp; k,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span>*arg, <span class="type">void</span> (*saver)(<span class="type">void</span>*, <span class="type">const</span> Slice&amp;, <span class="type">const</span> Slice&amp;))</span></span><br></pre></td></tr></table></figure>
<p>其中又有函数指针，在找到数据后，就调用传入的<strong>函数指针save</strong>r执行调用者的自定义处理逻辑，并且<strong>TableCache</strong>可能会做缓存。<br>函数逻辑如下：</p>
<h5 id="S1-14"><a href="#S1-14" class="headerlink" title="S1"></a>S1</h5><p>首先根据传入的key定位数据，这需要indexblock的Iterator。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Iterator* iiter =rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator);  </span><br><span class="line">iiter-&gt;Seek(k); </span><br></pre></td></tr></table></figure>
<h5 id="S2-11"><a href="#S2-11" class="headerlink" title="S2"></a>S2</h5><p>如果key是合法的，取出其filter指针，如果使用了filter，则检查key是否存在，这可以快速判断，提升效率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Status s;  </span><br><span class="line">Slice handle_value =iiter-&gt;value();  </span><br><span class="line">FilterBlockReader* filter = rep_-&gt;filter;  </span><br><span class="line">BlockHandle handle;  </span><br><span class="line">if (filter != NULL &amp;&amp; handle.DecodeFrom(&amp;handle_value).ok() &amp;&amp; !filter-&gt;KeyMayMatch(handle.offset(),k)) </span><br><span class="line">&#123; </span><br><span class="line">    // key不存在  </span><br><span class="line">&#125; </span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    // 否则就要读取block，并查找其k/v对  </span><br><span class="line">    Slice handle = iiter-&gt;value();  </span><br><span class="line">    Iterator* block_iter =BlockReader(this, options, iiter-&gt;value());  </span><br><span class="line">    block_iter-&gt;Seek(k);  </span><br><span class="line">    if (block_iter-&gt;Valid())(*saver)(arg, block_iter-&gt;key(), block_iter-&gt;value());  </span><br><span class="line">    s = block_iter-&gt;status();  </span><br><span class="line">    delete block_iter;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="S3-9"><a href="#S3-9" class="headerlink" title="S3"></a>S3</h5><p>最后返回结果，删除临时变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (s.ok()) s =iiter-&gt;status();  </span><br><span class="line">delete iiter;  </span><br><span class="line">return s; </span><br></pre></td></tr></table></figure>
<p>随着有关<strong>sstable文件读取</strong>的结束，sstable的源码也就分析完了，其中我们还遗漏了一些功课要做，那就是<strong>Filter和TableCache</strong>部分。</p>
<h1 id="7-TableCache"><a href="#7-TableCache" class="headerlink" title="7.TableCache"></a>7.TableCache</h1><h2 id="7-1-TableCache简介"><a href="#7-1-TableCache简介" class="headerlink" title="7.1 TableCache简介"></a>7.1 TableCache简介</h2><p><strong>TableCache缓存</strong>的是Table对象，每个DB一个，它内部使用一个LRUCache缓存所有的table对象，实际上其内容是文件编号{file number, TableAndFile}<em>。</em>TableAndFile是一个拥有<strong>2个变量</strong>的结构体：RandomAccessFile和Table*；</p>
<p>TableCache类的<strong>主要成员变量</strong>有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Env* const env_;            // 用来操作文件  </span><br><span class="line">const std::string dbname_;  // db名  </span><br><span class="line">Cache* cache_;              // LRUCache</span><br></pre></td></tr></table></figure>
<p>三个函数接口，其中的参数<code>@file_number</code>是文件编号，<code>@file_size</code>是文件大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Evict</span><span class="params">(uint64_tfile_number)</span>;  </span><br><span class="line"><span class="comment">// 该函数用以清除指定文件所有cache的entry，</span></span><br><span class="line"><span class="comment">//函数实现很简单，就是根据file number清除cache对象。  </span></span><br><span class="line">EncodeFixed64(buf,file_number); cache_-&gt;Erase(Slice(buf, <span class="keyword">sizeof</span>(buf)));  </span><br><span class="line">Iterator* <span class="title function_">NewIterator</span><span class="params">(constReadOptions&amp; options, <span class="type">uint64_t</span> file_number,  </span></span><br><span class="line"><span class="params">                      <span class="type">uint64_t</span> file_size, Table**tableptr = <span class="literal">NULL</span>)</span>;  </span><br><span class="line"><span class="comment">//该函数为指定的file返回一个iterator(对应的文件长度必须是&quot;file_size&quot;字节). </span></span><br><span class="line"><span class="comment">//如果tableptr不是NULL，那么tableptr保存的是底层的Table指针。</span></span><br><span class="line"><span class="comment">//返回的tableptr是cache拥有的，不能被删除，生命周期同返回的iterator</span></span><br><span class="line"></span><br><span class="line">Status <span class="title function_">Get</span><span class="params">(constReadOptions&amp; options,  </span></span><br><span class="line"><span class="params">           <span class="type">uint64_t</span> file_number,<span class="type">uint64_t</span> file_size,  </span></span><br><span class="line"><span class="params">           <span class="type">const</span> Slice&amp; k,<span class="type">void</span>* arg,  </span></span><br><span class="line"><span class="params">           <span class="type">void</span>(*handle_result)(<span class="type">void</span>*, <span class="type">const</span> Slice&amp;, <span class="type">const</span> Slice&amp;))</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个查找函数，如果在指定文件中seek 到internal key &quot;k&quot; 找到一个entry，</span></span><br><span class="line"><span class="comment">//就调用 (*handle_result)(arg,found_key, found_value).</span></span><br></pre></td></tr></table></figure>
<h2 id="7-2-TableCache-Get"><a href="#7-2-TableCache-Get" class="headerlink" title="7.2 TableCache::Get()"></a>7.2 TableCache::Get()</h2><p>先来看看<strong>Get接口，</strong>只有几行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cache::Handle* handle = <span class="literal">NULL</span>;  </span><br><span class="line">Status s =FindTable(file_number, file_size, &amp;handle);  </span><br><span class="line"><span class="keyword">if</span> (s.ok()) </span><br><span class="line">&#123;  </span><br><span class="line">    Table* t =reinterpret_cast&lt;TableAndFile*&gt;(cache_-&gt;Value(handle))-&gt;table;  </span><br><span class="line">    s = t-&gt;InternalGet(options,k, arg, saver);  </span><br><span class="line">    cache_-&gt;Release(handle);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure>
<p><strong>首先</strong>根据file_number找到Table的cache对象，<strong>如果</strong>找到了就调用Table::InternalGet，对查找结果的处理在调用者传入的<strong>saver回调函数</strong>中。<br>Cache在Lookup找到<strong>cache对象</strong>后，<strong>如果</strong>不再使用需要调用Release减引用计数。这个见Cache的接口说明。</p>
<h2 id="7-3-TableCache遍历"><a href="#7-3-TableCache遍历" class="headerlink" title="7.3 TableCache遍历"></a>7.3 TableCache遍历</h2><p>函数<code>NewIterator()</code>，返回一个可以遍历<strong>Table对象的Iterator指针</strong>，函数逻辑：</p>
<h4 id="S1-15"><a href="#S1-15" class="headerlink" title="S1"></a>S1</h4><p>初始化tableptr，调用FindTable，返回cache对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (tableptr != NULL) *tableptr =NULL;  </span><br><span class="line">Cache::Handle* handle = NULL;  </span><br><span class="line">Status s =FindTable(file_number, file_size, &amp;handle);  </span><br><span class="line">if (!s.ok()) returnNewErrorIterator(s);</span><br></pre></td></tr></table></figure>
<h4 id="S2-12"><a href="#S2-12" class="headerlink" title="S2"></a>S2</h4><p>从cache对象中取出Table对象指针，调用其NewIterator返回Iterator对象，并为Iterator注册一个cleanup函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Table* table =reinterpret_cast&lt;TableAndFile*&gt;(cache_-&gt;Value(handle))-&gt;table;  </span><br><span class="line">Iterator* result =table-&gt;NewIterator(options);  </span><br><span class="line">result-&gt;RegisterCleanup(&amp;UnrefEntry, cache_, handle);  </span><br><span class="line"><span class="keyword">if</span> (tableptr != <span class="literal">NULL</span>) *tableptr= table;  </span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<h2 id="7-4-TableCache-FindTable"><a href="#7-4-TableCache-FindTable" class="headerlink" title="7.4 TableCache::FindTable()"></a>7.4 TableCache::FindTable()</h2><p>前面的<strong>遍历和Get函数</strong>都依赖于FindTable这个私有函数完成对cache的查找，下面就来看看该函数的逻辑。函数声明为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Status FindTable(uint64_t file_number, uint64_t file_size,</span><br><span class="line">                 Cache::Handle** handle)</span><br></pre></td></tr></table></figure>
<p>函数流程为：</p>
<h4 id="S1-16"><a href="#S1-16" class="headerlink" title="S1"></a>S1</h4><p>首先根据file number从cache中查找table，找到就直接返回成功。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char buf[sizeof(file_number)];  </span><br><span class="line">EncodeFixed64(buf, file_number);  </span><br><span class="line">Slice key(buf, sizeof(buf));  </span><br><span class="line">*handle = cache_-&gt;Lookup(key);</span><br></pre></td></tr></table></figure>
<h4 id="S2-13"><a href="#S2-13" class="headerlink" title="S2"></a>S2</h4><p>如果没有找到，说明table不在cache中，则根据file number和db name打开一个RadomAccessFile。Table文件格式为：..sst。如果文件打开成功，则调用Table::Open读取sstable文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> fname =TableFileName(dbname_, file_number);  </span><br><span class="line">RandomAccessFile* file = <span class="literal">NULL</span>;  </span><br><span class="line">Table* table = <span class="literal">NULL</span>;  </span><br><span class="line">s =env_-&gt;NewRandomAccessFile(fname, &amp;file);  </span><br><span class="line"><span class="keyword">if</span> (s.ok()) s =Table::Open(*options_, file, file_size, &amp;table);</span><br></pre></td></tr></table></figure>
<h4 id="S3-10"><a href="#S3-10" class="headerlink" title="S3"></a>S3</h4><p>如果Table::Open成功则，插入到Cache中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TableAndFile* tf = newTableAndFile(table, file);  </span><br><span class="line">*handle = cache_-&gt;Insert(key,tf, 1, &amp;DeleteEntry); </span><br></pre></td></tr></table></figure>
<p>如果失败，则<strong>删除file</strong>，直接返回失败，失败的结果是不会cache的。</p>
<h2 id="7-5-辅助函数"><a href="#7-5-辅助函数" class="headerlink" title="7.5 辅助函数"></a>7.5 辅助函数</h2><p>有点啰嗦，不过还是写一下吧。其中一个是为<strong>LRUCache注册的删除函数DeleteEntry</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DeleteEntry</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">void</span>* value)</span> </span><br><span class="line">&#123;  </span><br><span class="line">    TableAndFile* tf =reinterpret_cast&lt;TableAndFile*&gt;(value);  </span><br><span class="line">    delete tf-&gt;table;  </span><br><span class="line">    delete tf-&gt;file;  </span><br><span class="line">    delete tf;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>另外一个是<strong>为Iterator注册的清除函数UnrefEntry</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">UnrefEntry</span><span class="params">(<span class="type">void</span>* arg1, <span class="type">void</span>* arg2)</span> </span><br><span class="line">&#123;  </span><br><span class="line">    Cache* cache =reinterpret_cast&lt;Cache*&gt;(arg1);  </span><br><span class="line">    Cache::Handle* h =reinterpret_cast&lt;Cache::Handle*&gt;(arg2);  </span><br><span class="line">    cache-&gt;Release(h);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="8-FilterPolicy-amp-Bloom之1"><a href="#8-FilterPolicy-amp-Bloom之1" class="headerlink" title="8.FilterPolicy&amp;Bloom之1"></a>8.FilterPolicy&amp;Bloom之1</h1><h2 id="8-1-FilterPolicy"><a href="#8-1-FilterPolicy" class="headerlink" title="8.1 FilterPolicy"></a>8.1 FilterPolicy</h2><p>因名知意，<strong>FilterPolicy</strong>是用于key过滤的，可以快速的排除不存在的key。前面介绍Table的时候，在<strong>Table::InternalGet</strong>函数中有过一面之缘。<br>FilterPolicy有3个接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="type">const</span> <span class="type">char</span>* <span class="title function_">Name</span><span class="params">()</span> <span class="type">const</span> = <span class="number">0</span>; </span><br><span class="line"><span class="comment">// 返回filter的名字</span></span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">CreateFilter</span><span class="params">(<span class="type">const</span> Slice* keys, </span></span><br><span class="line"><span class="params">                          <span class="type">int</span> n, <span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span><span class="type">const</span> = <span class="number">0</span>;</span><br><span class="line">virtual <span class="type">bool</span> <span class="title function_">KeyMayMatch</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; filter)</span><span class="type">const</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>CreateFilter接口</strong>，它根据指定的参数创建过滤器，并将结果append到dst中，<strong>注意：不能修改dst的原始内容，只做append。</strong><br>参数@keys[0,n-1]包含依据用户提供的comparator排序的key列表—可重复，并把根据这些key创建的filter追加到@*dst中。</p>
<p><strong>KeyMayMatch</strong>，参数@filter包含了调用CreateFilter函数append的数据，如果key在传递函数<strong>CreateFilter的key</strong>列表中，则必须返回<strong>true</strong>。</p>
<p><strong>注意</strong>：它不需要精确，也就是即使key不在前面传递的key列表中，也可以返回true，但是如果<strong>key在列表中</strong>，就<strong>必须返回true</strong>。<br><img src="/img/leveldb13.webp" alt=""></p>
<h2 id="8-2InternalFilterPolicy"><a href="#8-2InternalFilterPolicy" class="headerlink" title="8.2InternalFilterPolicy"></a>8.2InternalFilterPolicy</h2><p>这是一个简单的<strong>FilterPolicy的wrapper</strong>，以方便的把FilterPolicy应用在InternalKey上，<strong>InternalKey是Leveldb内部使用的key</strong>，这些前面都讲过。它所做的就是从InternalKey<strong>拆分</strong>得到user key，然后在user key上做FilterPolicy的操作。<br>它有一个成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constFilterPolicy* <span class="type">const</span> user_policy_;</span><br></pre></td></tr></table></figure>
<p>其<strong>Name()</strong>返回的是<strong>user_policy_-&gt;Name()</strong>；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InternalFilterPolicy::KeyMayMatch</span><span class="params">(<span class="type">const</span> Slice&amp; key, constSlice&amp; f)</span> <span class="type">const</span> </span><br><span class="line">&#123;</span><br><span class="line">     returnuser_policy_-&gt;KeyMayMatch(ExtractUserKey(key), f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InternalFilterPolicy::CreateFilter</span><span class="params">(<span class="type">const</span> Slice* keys,</span></span><br><span class="line"><span class="params">                                        <span class="type">int</span> n,<span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="type">const</span> </span><br><span class="line">&#123;</span><br><span class="line">     Slice* mkey =const_cast&lt;Slice*&gt;(keys);</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)mkey[i] = ExtractUserKey(keys[i]);</span><br><span class="line">     user_policy_-&gt;CreateFilter(keys, n, dst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-3-BloomFilter"><a href="#8-3-BloomFilter" class="headerlink" title="8.3 BloomFilter"></a>8.3 BloomFilter</h2><h3 id="8-3-1-基本理论"><a href="#8-3-1-基本理论" class="headerlink" title="8.3.1 基本理论"></a>8.3.1 基本理论</h3><p><strong>Bloom Filter</strong>实际上是一种<strong>hash算法</strong>，数学之美系列有专门介绍。它是由巴顿.布隆于一九七零年提出的，它实际上是一个很长的<strong>二进制向量</strong>和一系列<strong>随机映射函数</strong>。</p>
<p>Bloom Filter将元素映射到一个长度为m的bit向量上的一个bit，当这个bit是1时，就表示这个元素在集合内。<strong>使用hash</strong>的缺点就是元素很多时可能有冲突，为了减少误判，就使用k个hash函数计算出k个bit，只要有一个bit为0，就说明元素肯定不在集合内。下面的图8.3-1是一个示意图。</p>
<p><img src="/img/leveldb14.webp" alt=""></p>
<p>在leveldb的实现中，<strong>Name()返回”leveldb.BuiltinBloomFilter”</strong>，因此<strong>metaindex block</strong>中的key就是<code>filter.leveldb.BuiltinBloomFilter</code>。Leveldb使用了<strong>double hashing</strong>来模拟多个hash函数，当然这里不是用来解决冲突的。</p>
<p>和线性再探测（linearprobing）一样，<strong>Double hashing</strong>从一个hash值开始，重复向前迭代，直到解决冲突或者搜索完hash表。不同的是，<strong>double hashing使用的是另外一个hash函数，而不是固定的步长。</strong></p>
<p>给定两个独立的hash函数h1和h2，对于hash表T和值k，第i次迭代计算出的位置就是：<code>h(i, k) = (h1(k) + i*h2(k)) mod |T|</code>。对此，Leveldb选择的hash函数是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Gi(x)=H1(x)+iH2(x)</span><br><span class="line">H2(x)=(H1(x)&gt;&gt;<span class="number">17</span>) | (H1(x)&lt;&lt;<span class="number">15</span>)</span><br></pre></td></tr></table></figure>
<p>H1是一个<strong>基本的hash函数</strong>，H2是由H1循环右移得到的，Gi(x)就是第i次循环得到的hash值。在<strong>bloom_filter的数据</strong>的最后一个字节存放的是k_的值，k_实际上就是G(x)的个数，也就是计算时采用的<strong>hash函数个数</strong>。</p>
<h3 id="8-3-2-BloomFilter参数"><a href="#8-3-2-BloomFilter参数" class="headerlink" title="8.3.2 BloomFilter参数"></a>8.3.2 BloomFilter参数</h3><p>这里先来说下其两个成员变量：<strong>bits_per_key_</strong>和<strong>key_</strong>；其实这就是Bloom Hashing的两个关键参数。<strong>变量k_</strong>实际上就是模拟的hash函数的个数；</p>
<p>关于<strong>变量bits_per_key_</strong>，对于<strong>n个key</strong>，其hash table的大小就是<code>bits_per_key_</code>。它的值越大，发生冲突的概率就越低，那么bloom hashing误判的概率就越低。因此这是一个<strong>时间空间的trade-off</strong>。</p>
<p>对于<strong>hash(key)</strong>，在平均意义上，发生冲突的概率就是<code>1 / bits_per_key_</code>。它们在构造函数中根据传入的<strong>参数bits_per_key初始化</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bits_per_key_ = bits_per_key;  </span><br><span class="line">k_ =static_cast&lt;size_t&gt;(bits_per_key * 0.69); // 0.69 =~ ln(2)  </span><br><span class="line">if (k_ &lt; 1) k_ = 1;  </span><br><span class="line">if (k_ &gt; 30) k_ = 30;</span><br></pre></td></tr></table></figure>
<p>模拟hash函数的个数k_取值为<strong>bits_per_key_*ln(2)</strong>，为何不是0.5或者0.4了，可能是什么理论推导的结果吧，不了解了。</p>
<h3 id="8-3-3-建立BloomFilter"><a href="#8-3-3-建立BloomFilter" class="headerlink" title="8.3.3 建立BloomFilter"></a>8.3.3 建立BloomFilter</h3><p>了解了上面的理论，再来看<strong>leveldb对Bloom Fil**</strong>ter的实现<strong>就轻松多了，先来看</strong>Bloom Filter的构建<strong>。这就是</strong>FilterPolicy::CreateFilter接口的实现**：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void CreateFilter(const Slice* keys, int n, std::string* dst) const</span><br></pre></td></tr></table></figure>
<p>下面分析其实现代码，大概有如下几个步骤：</p>
<h5 id="S1-17"><a href="#S1-17" class="headerlink" title="S1"></a>S1</h5><p>首先根据key个数分配filter空间，并圆整到8byte。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size_t bits = n * bits_per_key_;  </span><br><span class="line">if (bits &lt; 64) bits = 64;      </span><br><span class="line">// 如果n太小FP会很高，限定filter的最小长度  </span><br><span class="line">size_t bytes = (bits + 7) / 8;    // 圆整到8byte  </span><br><span class="line">bits = bytes * 8;                 // bit计算的空间大小  </span><br><span class="line">const size_t init_size =dst-&gt;size();  </span><br><span class="line">dst-&gt;resize(init_size +bytes, 0); // 分配空间</span><br></pre></td></tr></table></figure>
<h5 id="S2-14"><a href="#S2-14" class="headerlink" title="S2"></a>S2</h5><p>在filter最后的字节位压入hash函数个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dst-&gt;push_back(static_cast&lt;char&gt;(k_));</span><br><span class="line">// Remember # of probes in filter</span><br></pre></td></tr></table></figure>
<h5 id="S3-11"><a href="#S3-11" class="headerlink" title="S3"></a>S3</h5><p>对于每个key，使用double-hashing生产一系列的hash值h(K_个)，设置bits array的第h位=1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="built_in">array</span> =&amp;(*dst)[init_size];  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n;i++) </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// double-hashing，分析参见[Kirsch,Mitzenmacher 2006]  </span></span><br><span class="line">    <span class="type">uint32_t</span> h =BloomHash(keys[i]); </span><br><span class="line">    <span class="comment">// h1函数  </span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> delta = (h&gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>); </span><br><span class="line">    <span class="comment">// h2函数、由h1 Rotate right 17 bits  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// double-hashing生产k_个的hash值  </span></span><br><span class="line">        <span class="type">const</span> <span class="type">uint32_t</span> bitpos = h% bits; </span><br><span class="line">        <span class="comment">// 在bits array上设置第bitpos位  </span></span><br><span class="line">        <span class="built_in">array</span>[bitpos/<span class="number">8</span>] |= (<span class="number">1</span>&lt;&lt; (bitpos % <span class="number">8</span>));  </span><br><span class="line">        h += delta;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>Bloom Filter的创建就完成了。</p>
<h3 id="8-3-4-查找BloomFilter"><a href="#8-3-4-查找BloomFilter" class="headerlink" title="8.3.4 查找BloomFilter"></a>8.3.4 查找BloomFilter</h3><p>在指定的filer中查找key是否存在，这就是<strong>bloom filter的查找函数：</strong><br><strong>bool KeyMayMatch(const Slice&amp; key, const Slice&amp; bloom_filter)</strong>，函数逻辑如下：</p>
<h5 id="S1-18"><a href="#S1-18" class="headerlink" title="S1"></a>S1</h5><p>准备工作，并做些基本判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> len =bloom_filter.size();  </span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="built_in">array</span> = bloom_filter.data();  </span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> bits = (len - <span class="number">1</span>)* <span class="number">8</span>;  </span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> k = <span class="built_in">array</span>[len<span class="number">-1</span>];</span><br><span class="line"><span class="comment">// 使用filter的k，而不是k_，这样更灵活  </span></span><br><span class="line"><span class="keyword">if</span> (k &gt; <span class="number">30</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"><span class="comment">// 为短bloom filter保留，当前认为直接match </span></span><br></pre></td></tr></table></figure>
<h5 id="S2-15"><a href="#S2-15" class="headerlink" title="S2"></a>S2</h5><p>计算key的hash值，重复计算阶段的步骤，循环计算k个hash值，只要有一个结果对应的bit位为0，就认为不匹配，否则认为匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint32_t h = BloomHash(key);  </span><br><span class="line">const uint32_t delta = (h&gt;&gt; 17) | (h &lt;&lt; 15);  // Rotate right 17 bits  </span><br><span class="line">for (size_t j = 0; j &lt; k;j++)</span><br><span class="line">&#123;  </span><br><span class="line">    const uint32_t bitpos = h %bits;  </span><br><span class="line">    if ((array[bitpos/8] &amp;(1 &lt;&lt; (bitpos % 8))) == 0) return false; </span><br><span class="line">    // notmatch  </span><br><span class="line">    h += delta;  </span><br><span class="line">&#125;  </span><br><span class="line">return true; // match  </span><br></pre></td></tr></table></figure>
<h2 id="8-4-Filter-Block格式"><a href="#8-4-Filter-Block格式" class="headerlink" title="8.4 Filter Block格式"></a>8.4 Filter Block格式</h2><p>Filter Block也就是前面sstable中的<strong>meta block</strong>，位于data block之后。</p>
<p>如果打开db时指定了FilterPolicy，那么每个创建的table都会保存一个filter block，table中的<strong>metaindex</strong>就包含一条从”filter.到filter block的BlockHandle的映射，其中”<N>”是filter policy的<strong>Name()函数返回的string</strong>。</p>
<p>Filter block存储了一连串的filter值，其中第i个filter保存的是block b中所有的key通过<strong>FilterPolicy::CreateFilter()</strong>计算得到的结果，block b在sstable文件中的偏移<strong>满足[ i*base … (i+1)*base-1 ]</strong>。</p>
<p>当前base是2KB，举个例子，如果block X和Y在sstable的起始位置都在[0KB, 2KB-1]中，X和Y中的所有<strong>key调用FilterPolicy::CreateFilter()</strong>的计算结果都将生产到同一个filter中，而且该filter是filter block的第一个filter。</p>
<p>Filter block也是一个block，其<strong>格式遵从block</strong>的基本格式：|block data| type | crc32|。其中block dat的格式如图8.4-1所示。</p>
<p><img src="/img/leveldb15.webp" alt=""></p>
<h2 id="8-5-构建FilterBlock"><a href="#8-5-构建FilterBlock" class="headerlink" title="8.5 构建FilterBlock"></a>8.5 构建FilterBlock</h2><h3 id="8-5-1-FilterBlockBuilder"><a href="#8-5-1-FilterBlockBuilder" class="headerlink" title="8.5.1 FilterBlockBuilder"></a>8.5.1 FilterBlockBuilder</h3><p>了解了filter机制，现在来看看<strong>filter block的构建</strong>，这就是类FilterBlockBuilder。它为指定的table构建所有的filter，结果是一个string字符串，并作为一个block存放在table中。它有三个函数接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始构建新的filter block，TableBuilder在构造函数和Flush中调用  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StartBlock</span><span class="params">(uint64_tblock_offset)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加key，TableBuilder每次向data block中加入key时调用  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AddKey</span><span class="params">(<span class="type">const</span> Slice&amp;key)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束构建，TableBuilder在结束对table的构建时调用  </span></span><br><span class="line">Slice <span class="title function_">Finish</span><span class="params">()</span>;    </span><br></pre></td></tr></table></figure>
<p><strong>FilterBlockBuilder的构建顺序</strong>必须满足如下范式：<code>(StartBlock AddKey*)* Finish</code>，显然这和前面讲过的BlockBuilder有所不同。<br>其成员变量有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> FilterPolicy* policy_; <span class="comment">// filter类型，构造函数参数指定  </span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> keys_;          <span class="comment">//Flattened key contents  </span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">size_t</span>&gt; start_; <span class="comment">// 各key在keys_中的位置  </span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> result_;        <span class="comment">// 当前计算出的filter data  </span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">uint32_t</span>&gt;filter_offsets_; <span class="comment">// 各个filter在result_中的位置  </span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Slice&gt; tmp_keys_;<span class="comment">// policy_-&gt;CreateFilter()参数   </span></span><br></pre></td></tr></table></figure>
<p>前面说过base是2KB，这对应两个常量<code>kFilterBase =11, kFilterBase =(1&lt;&lt;kFilterBaseLg)；</code>其实从后面的实现来看tmp_keys_完全不必作为成员变量，直接作为函数GenerateFilter()的栈变量就可以。下面就分别分析三个函数接口。</p>
<h3 id="8-5-2-FilterBlockBuilder-StartBlock"><a href="#8-5-2-FilterBlockBuilder-StartBlock" class="headerlink" title="8.5.2 FilterBlockBuilder::StartBlock()"></a>8.5.2 FilterBlockBuilder::StartBlock()</h3><p>它根据参数block_offset计算出filter index，然后循环调用GenerateFilter生产新的Filter。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> filter_index =(block_offset / kFilterBase);  </span><br><span class="line">assert(filter_index &gt;=filter_offsets_.size());  </span><br><span class="line"><span class="keyword">while</span> (filter_index &gt;filter_offsets_.size()) GenerateFilter();  </span><br></pre></td></tr></table></figure>
<p>我们来到GenerateFilter这个函数，看看它的逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//S1 如果filter中key个数为0，则直接压入result_.size()并返回  </span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> num_keys =start_.size();  </span><br><span class="line"><span class="keyword">if</span> (num_keys == <span class="number">0</span>) &#123; <span class="comment">// there are no keys for this filter  </span></span><br><span class="line">    filter_offsets_.push_back(result_.size()); <span class="comment">//result_.size()应该是0  </span></span><br><span class="line">    <span class="keyword">return</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//S2 从key创建临时key list，根据key的序列字符串kyes_和各key在keys_</span></span><br><span class="line"><span class="comment">//中的开始位置start_依次提取出key。  </span></span><br><span class="line"></span><br><span class="line">start_.push_back(keys_.size());  <span class="comment">// Simplify lengthcomputation  </span></span><br><span class="line">tmp_keys_.resize(num_keys);  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;  </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* base =keys_.data() + start_[i]; <span class="comment">// 开始指针  </span></span><br><span class="line">    <span class="type">size_t</span> length = start_[i+<span class="number">1</span>] -start_[i]; <span class="comment">// 长度  </span></span><br><span class="line">    tmp_keys_[i] = Slice(base,length);  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//S3 为当前的key集合生产filter，并append到result_  </span></span><br><span class="line"></span><br><span class="line">filter_offsets_.push_back(result_.size());  </span><br><span class="line">policy_-&gt;CreateFilter(&amp;tmp_keys_[<span class="number">0</span>], num_keys, &amp;result_);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//S4 清空，重置状态  </span></span><br><span class="line"></span><br><span class="line">tmp_keys_.clear();  </span><br><span class="line">keys_.clear();  </span><br><span class="line">start_.clear();  </span><br></pre></td></tr></table></figure>
<h3 id="8-5-3-FilterBlockBuilder-AddKey"><a href="#8-5-3-FilterBlockBuilder-AddKey" class="headerlink" title="8.5.3 FilterBlockBuilder::AddKey()"></a>8.5.3 FilterBlockBuilder::AddKey()</h3><p>这个接口很简单，就是把key添加到key_中，并在start_中记录位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Slice k = key;  </span><br><span class="line">start_.push_back(keys_.size());  </span><br><span class="line">keys_.append(k.data(),k.size());  </span><br></pre></td></tr></table></figure>
<h3 id="8-5-4-FilterBlockBuilder-Finish"><a href="#8-5-4-FilterBlockBuilder-Finish" class="headerlink" title="8.5.4 FilterBlockBuilder::Finish()"></a>8.5.4 FilterBlockBuilder::Finish()</h3><p>调用这个函数说明整个table的data block已经构建完了，可以生产最终的filter block了，在TableBuilder::Finish函数中被调用，向sstable写入meta block。函数逻辑为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//S1 如果start_数字不空，把为的key列表生产filter  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!start_.empty()) GenerateFilter();  </span><br><span class="line"></span><br><span class="line"><span class="comment">//S2 从0开始顺序存储各filter的偏移值，见filter block data的数据格式。  </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> array_offset =result_.size();  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; filter_offsets_.size();i++) &#123;  </span><br><span class="line">    PutFixed32(&amp;result_,filter_offsets_[i]);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//S3 最后是filter个数，和shift常量（11），并返回结果  </span></span><br><span class="line">PutFixed32(&amp;result_,array_offset);  </span><br><span class="line">result_.push_back(kFilterBaseLg);  <span class="comment">// Save encoding parameter in result  </span></span><br><span class="line"><span class="keyword">return</span> Slice(result_);  </span><br></pre></td></tr></table></figure>
<h3 id="8-5-5-简单示例"><a href="#8-5-5-简单示例" class="headerlink" title="8.5.5 简单示例"></a>8.5.5 简单示例</h3><p>让我们根据TableBuilder对FilterBlockBuilder接口的调用范式：<br>(StartBlock AddKey<em>)</em> Finish以及上面的函数实现，结合一个简单例子看看<strong>leveldb是如何为data block创建filter block（也就是meta block）的。</strong><br>考虑两个datablock，在sstable的范围分别是：<code>Block 1 [0, 7KB-1], Block 2 [7KB, 14.1KB]</code></p>
<ul>
<li>S1 首先TableBuilder为Block 1调用FilterBlockBuilder::StartBlock(0)，该函数直接返回；</li>
<li>S2 然后依次向Block 1加入k/v，其中会调用FilterBlockBuilder::AddKey，FilterBlockBuilder记录这些key。</li>
<li>S3 下一次TableBuilder添加k/v时，例行检查发现Block 1的大小超过设置，则执行Flush操作，Flush操作在写入Block 1后，开始准备Block 2并更新block offset=7KB，最后调用FilterBlockBuilder::StartBlock(7KB)，开始为Block 2构建Filter。</li>
<li>S4 在FilterBlockBuilder::StartBlock(7KB)中，计算出filter index = 3，触发3次GenerateFilter函数，为Block 1添加的那些key列表创建filter，其中第2、3次循环创建的是空filter。<ul>
<li>在StartBlock(7KB)时会向filter的偏移数组filter_offsets_压入两个包含空key set的元素，filter_offsets_[1]和filter_offsets_[2]，它们的值都等于7KB-1。</li>
</ul>
</li>
<li>S5 Block 2构建结束，TableBuilder调用Finish结束table的构建，这会再次触发Flush操作，在写入Block 2后，为Block 2的key创建filter。</li>
<li>这里如果Block 1的范围是[0, 1.8KB-1]，Block 2从1.8KB开始，那么Block 2将会和Block 1共用一个filter，它们的filter都被生成到filter 0中。<ul>
<li>当然在TableBuilder构建表时，Block的大小是根据参数配置的，也是基本均匀的。</li>
</ul>
</li>
</ul>
<h2 id="8-6-读取FilterBlock"><a href="#8-6-读取FilterBlock" class="headerlink" title="8.6 读取FilterBlock"></a>8.6 读取FilterBlock</h2><h3 id="8-6-1-FilterBlockReader"><a href="#8-6-1-FilterBlockReader" class="headerlink" title="8.6.1 FilterBlockReader"></a>8.6.1 FilterBlockReader</h3><p>FilterBlock的读取操作在FilterBlockReader类中，它的主要<strong>功能</strong>是根据传入的FilterPolicy和filter，进行key的匹配查找。<br>它有如下的几个成员变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> FilterPolicy* policy_; <span class="comment">// filter策略  </span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* data_;           <span class="comment">// filter data指针 (at block-start)  </span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* offset_;        <span class="comment">// offset array的开始地址 (at block-end)  </span></span><br><span class="line"><span class="type">size_t</span> num_;                <span class="comment">// offsetarray元素个数  </span></span><br><span class="line"><span class="type">size_t</span> base_lg_;            <span class="comment">// 还记得kFilterBaseLg吗  </span></span><br></pre></td></tr></table></figure>
<p>Filter策略和filter block内容都由构造函数传入。一个接口函数，就是key的批判查找：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool KeyMayMatch(uint64_t block_offset, const Slice&amp; key);</span><br></pre></td></tr></table></figure>
<h3 id="8-6-2-构造"><a href="#8-6-2-构造" class="headerlink" title="8.6.2 构造"></a>8.6.2 构造</h3><p>在构造函数中，根据存储格式解析出偏移数组开始指针、个数等信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FilterBlockReader::FilterBlockReader(<span class="type">const</span> FilterPolicy* policy, </span><br><span class="line">                                     constSlice&amp; contents)  </span><br><span class="line">    : policy_(policy),data_(<span class="literal">NULL</span>), offset_(<span class="literal">NULL</span>), num_(<span class="number">0</span>), base_lg_(<span class="number">0</span>) &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> n = contents.size();  </span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">5</span>) <span class="keyword">return</span>;  <span class="comment">// 1 byte forbase_lg_ and 4 for start of offset array  </span></span><br><span class="line">    base_lg_ = contents[n<span class="number">-1</span>]; <span class="comment">// 最后1byte存的是base  </span></span><br><span class="line">    <span class="type">uint32_t</span> last_word =DecodeFixed32(contents.data() + n - <span class="number">5</span>); <span class="comment">//偏移数组的位置  </span></span><br><span class="line">    <span class="keyword">if</span> (last_word &gt; n - <span class="number">5</span>)<span class="keyword">return</span>;  </span><br><span class="line">    data_ = contents.data();  </span><br><span class="line">    offset_ = data_ + last_word; <span class="comment">// 偏移数组开始指针  </span></span><br><span class="line">    num_ = (n - <span class="number">5</span> - last_word) / <span class="number">4</span>; <span class="comment">// 计算出filter个数  </span></span><br></pre></td></tr></table></figure>
<h3 id="8-6-3-查找"><a href="#8-6-3-查找" class="headerlink" title="8.6.3 查找"></a>8.6.3 查找</h3><p>查找函数传入两个参数</p>
<ul>
<li>@block_offset是查找data block在sstable中的偏移，Filter根据此偏移计算filter的编号；</li>
<li>@key是查找的key。</li>
</ul>
<p>声明如下：<code>bool FilterBlockReader::KeyMayMatch(uint64_t block_offset, constSlice&amp; key)</code></p>
<p>它<strong>首先</strong>计算出filterindex，<strong>根据</strong>index解析出filter的range，<strong>如果</strong>是合法的range，就从data_中取出filter，调用policy_做key的匹配查询。函数实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> index = block_offset&gt;&gt; base_lg_; <span class="comment">// 计算出filter index  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index &lt; num_) &#123;  </span><br><span class="line">  <span class="comment">// 解析出filter的range  </span></span><br><span class="line">  <span class="type">uint32_t</span> start =DecodeFixed32(offset_ + index*<span class="number">4</span>);</span><br><span class="line">  <span class="type">uint32_t</span> limit =DecodeFixed32(offset_ + index*<span class="number">4</span> + <span class="number">4</span>);  </span><br><span class="line">  <span class="keyword">if</span> (start &lt;= limit&amp;&amp; limit &lt;= (offset_ - data_)) &#123;  </span><br><span class="line">    Slice filter = Slice(data_ +start, limit - start); <span class="comment">// 根据range得到filter  </span></span><br><span class="line">    returnpolicy_-&gt;KeyMayMatch(key, filter);  </span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start == limit) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 空filter不匹配任何key  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 当匹配处理  </span></span><br></pre></td></tr></table></figure>
<p>至此，FilterPolicy和Bloom就分析完了。</p>
<h1 id="9-LevelDB框架之1"><a href="#9-LevelDB框架之1" class="headerlink" title="9 LevelDB框架之1"></a>9 LevelDB框架之1</h1><p>到此为止，基本上<code>Leveldb</code>的主要功能组件都已经分析完了，下面就是把它们组合在一起，形成一个高性能的k/v存储系统。这就是<code>leveldb::DB</code>类。</p>
<p>这里先看一下LevelDB的导出接口和涉及的类，后面将依次以接口分析的方式展开。而实际上leveldb::DB只是一个接口类，真正的实现和框架类是DBImpl这个类，正是它集合了上面的各种组件。此外，还有Leveldb对版本的控制，执行版本控制的是<code>Version</code>和<code>VersionSet</code>类。在leveldb的源码中，DBImpl和VersionSet是两个庞然大物，体量基本算是最大的。对于这两个类的分析，也会分散在打开、销毁和快照等等这些功能中，很难在一个地方集中分析。</p>
<p>作者在文档impl.html中描述了leveldb的实现，其中包括<strong>文件组织</strong>、<strong>compaction</strong>和<strong>recovery</strong>等等。下面的9.1和9.2基本都是翻译子impl.html文档。在进入框架代码之前，先来了解下leveldb的文件组织和管理。</p>
<h2 id="9-1-DB文件管理"><a href="#9-1-DB文件管理" class="headerlink" title="9.1 DB文件管理"></a>9.1 DB文件管理</h2><h3 id="9-1-1-文件类型"><a href="#9-1-1-文件类型" class="headerlink" title="9.1.1 文件类型"></a>9.1.1 文件类型</h3><p>对于一个数据库Level包含如下的6种文件:</p>
<p><strong>1/[0-9]+.log：db操作日志</strong><br>这就是前面分析过的操作日志，log文件包含了最新的db更新，每个更新都以<code>append</code>的方式追加到文件结尾。当log文件达到预定大小时（缺省大约4MB），<code>leveldb</code>就把它转换为一个有序表（如下-2），并创建一个新的log文件。<br>当前的log文件在内存中的存在形式就是<code>memtable</code>，每次read操作都会访问memtable，以保证read读取到的是最新的数据。</p>
<p><strong>2/[0-9]+.sst：db的sstable文件</strong><br>这两个就是前面分析过的<strong>静态sstable文件</strong>，sstable存储了以key排序的元素。每个元素或者是key对应的value，或者是key的删除标记（删除标记可以掩盖更老sstable文件中过期的value）。</p>
<p><code>Leveldb</code>把<code>sstable</code>文件通过level的方式组织起来，从log文件中生成的sstable被放在level 0。当level 0的sstable文件个数超过设置（当前为4个）时，leveldb就把所有的level 0文件，以及有重合的level 1文件merge起来，组织成一个新的level 1文件（每个level 1文件大小为2MB）。</p>
<p>Level 0的SSTable文件（后缀为.sst）和Level&gt;1的文件相比有特殊性：这个层级内的.sst文件，两个文件可能存在key重叠。对于Level&gt;0，同层sstable文件的key不会重叠。考虑level&gt;0，level中的文件的总大小超过10^level MB时（如level=1是10MB，level=2是100MB），那么level中的一个文件，以及所有level+1中和它有重叠的文件，会被merge到level+1层的一系列新文件。<strong>Merge操作</strong>的作用是将更新从低一级level迁移到最高级，只使用批量读写（最小化seek操作，提高效率）。</p>
<p><strong>3/MANIFEST-[0-9]+：DB元信息文件</strong><br>它记录的是leveldb的元信息，比如DB使用的Comparator名，以及各SSTable文件的管理信息：如Level层数、文件名、最小key和最大key等等。</p>
<p><strong>4/CURRENT：记录当前正在使用的Manifest文件</strong><br>它的内容就是当前的<code>manifest</code>文件名；因为在LevleDb的运行过程中，随着<code>Compaction</code>的进行，新的<code>SSTable</code>文件被产生，老的文件被废弃。并生成新的Manifest文件来记载<code>sstable</code>的变动，而<code>CURRENT</code>则用来记录我们关心的Manifest文件。</p>
<p>当db被重新打开时，leveldb总是生产一个新的manifest文件。Manifest文件使用log的格式，对服务状态的改变（新加或删除的文件）都会追加到该log中。</p>
<p>上面的log文件、sst文件、清单文件，末尾都带着序列号，其序号都是单调递增的（随着<code>next_file_number</code>从1开始递增），以保证不和之前的文件名重复。</p>
<p><strong>5/log：系统的运行日志，记录系统的运行信息或者错误日志。</strong></p>
<p><strong>6/dbtmp：临时数据库文件，repair时临时生成的。</strong><br>这里就涉及到几个关键的number计数器，log文件编号，下一个文件（sstable、log和manifest）编号，sequence。<br>所有正在使用的文件编号，包括log、sstable和manifest都应该小于下一个文件编号计数器。</p>
<h3 id="9-1-2-Level-0"><a href="#9-1-2-Level-0" class="headerlink" title="9.1.2 Level 0"></a>9.1.2 Level 0</h3><p>当操作log超过一定大小时（缺省是1MB），执行如下操作：</p>
<ul>
<li>S1 创建新的memtable和log文件，并重导向新的更新到新memtable和log中；</li>
<li>S2 在后台：</li>
<li>S2.1 将前一个memtable的内容dump到sstable文件；</li>
<li>S2.2 丢弃前一个memtable；</li>
<li>S2.3 删除旧的log文件和memtable</li>
<li>S2.4 把创建的sstable文件放到level 0</li>
</ul>
<h2 id="9-2-Compaction"><a href="#9-2-Compaction" class="headerlink" title="9.2 Compaction"></a>9.2 Compaction</h2><p>当<code>level L</code>的总文件大小查过限制时，我们就在后台执行<strong>compaction操作</strong>。Compaction操作从level L中选择一个文件f，以及选择中所有和f有重叠的文件。如果某个level (L+1)的文件ff只是和f部分重合，compaction依然选择ff的完整内容作为输入，在compaction后f和ff都会被丢弃。</p>
<p>另外：因为<code>level 0</code>有些特殊（同层文件可能有重合），从level 0到level 1的<code>compaction</code>就需要特殊对待：level 0的compaction可能会选择多个level 0文件，如果它们之间有重叠。</p>
<p>Compaction将选择的文件内容<code>merge</code>起来，并生成到一系列的level (L+1)文件中，如果输出文件超过设置（2MB），就切换到新的。当输出文件的key范围太大以至于和超过10个level (L+2)文件有重合时，也会切换。后一个规则确保了level (L+1)的文件不会和过多的level (L+2)文件有重合，其后的level (L+1) compaction不会选择过多的level (L+2)文件。</p>
<p>老的文件会被丢弃，新创建的文件将加入到server状态中。</p>
<p>Compaction操作在key空间中循环执行，详细讲一点就是，对于每个level，我们记录上次compaction的<code>ending key</code>。Level的下一次compaction将选择ending key之后的第一个文件（如果这样的文件不存在，将会跳到key空间的开始）。</p>
<p>Compaction会忽略被写覆盖的值，如果更高一层的level没有文件的范围包含了这个key，key的删除标记也会被忽略。</p>
<h3 id="9-2-1-时间"><a href="#9-2-1-时间" class="headerlink" title="9.2.1 时间"></a>9.2.1 时间</h3><p>Level 0的compaction最多从level 0读取4个1MB的文件，以及所有的level 1文件（10MB），也就是我们将读取14MB，并写入14BM。</p>
<p>Level &gt; 0的compaction，从level L选择一个2MB的文件，最坏情况下，将会和levelL+1的12个文件有重合（10：level L+1的总文件大小是level L的10倍；边界的2：level L的文件范围通常不会和level L+1的文件对齐）。因此Compaction将会读26MB，写26MB。对于100MB/s的磁盘IO来讲，compaction将最坏需要0.5秒。</p>
<p>如果磁盘IO更低，比如10MB/s，那么compaction就需要更长的时间5秒。如果user以10MB/s的速度写入，我们可能生成很多level 0文件（50个来装载5*10MB的数据）。这将会严重影响读取效率，因为需要merge更多的文件。</p>
<ul>
<li>解决方法1：为了降低该问题，我们可能想增加log切换的阈值，缺点就是，log文件越大，对应的memtable文件就越大，这需要更多的内存。</li>
<li>解决方法2：当level 0文件太多时，人工降低写入速度。</li>
<li>解决方法3：降低merge的开销，如把level 0文件都无压缩的存放在cache中。</li>
</ul>
<h3 id="9-2-2-文件数"><a href="#9-2-2-文件数" class="headerlink" title="9.2.2 文件数"></a>9.2.2 文件数</h3><p>对于更高的<code>level</code>我们可以创建更大的文件，而不是2MB，代价就是更多突发性的<code>compaction</code>。或者，我们可以考虑分区，把文件放存放多目录中。<br>在2011年2月4号，作者做了一个实验，在ext3文件系统中打开100KB的文件，结果表明可以不需要分区。</p>
<ul>
<li>文件数    文件打开ms</li>
<li>1000      9</li>
<li>10000    10</li>
<li>100000   16</li>
</ul>
<h2 id="9-3-Recovery-amp-GC"><a href="#9-3-Recovery-amp-GC" class="headerlink" title="9.3 Recovery &amp; GC"></a>9.3 Recovery &amp; GC</h2><h3 id="9-3-1-Recovery"><a href="#9-3-1-Recovery" class="headerlink" title="9.3.1 Recovery"></a>9.3.1 Recovery</h3><p>Db恢复的步骤：</p>
<ul>
<li>S1 首先从CURRENT读取最后提交的MANIFEST</li>
<li>S2 读取MANIFEST内容</li>
<li>S3 清除过期文件</li>
<li>S4 这里可以打开所有的sstable文件，但是更好的方案是lazy open</li>
<li>S5 把log转换为新的level 0sstable</li>
<li>S6 将新写操作导向到新的log文件，从恢复的序号开始</li>
</ul>
<h3 id="9-3-2-GC"><a href="#9-3-2-GC" class="headerlink" title="9.3.2 GC"></a>9.3.2 GC</h3><p>垃圾回收，每次compaction和recovery之后都会有文件被废弃，成为垃圾文件。<code>GC</code>就是删除这些文件的，它在每次compaction和recovery完成之后被调用。</p>
<h2 id="9-4-版本控制"><a href="#9-4-版本控制" class="headerlink" title="9.4 版本控制"></a>9.4 版本控制</h2><p>当执行一次<code>compaction</code>后，<code>Leveldb</code>将在当前版本基础上创建一个新版本，当前版本就变成了历史版本。还有，如果你创建了一个<code>Iterator</code>，那么该Iterator所依附的版本将不会被leveldb删除。</p>
<p>在leveldb中，<code>Version</code>就代表了一个版本，它包括<strong>当前磁盘及内存中的所有文件信息</strong>。在所有的version中，只有一个是<code>CURRENT</code>。<code>VersionSet</code>是所有Version的集合，这是个version的管理机构。</p>
<p>前面讲过的VersionEdit记录了Version之间的变化，相当于delta增量，表示又增加了多少文件，删除了文件。也就是说：<strong>Version0 + VersionEdit —&gt; Version1</strong>。</p>
<p>每次文件有变动时，leveldb就把变动记录到一个VersionEdit变量中，然后通过VersionEdit把变动应用到current version上，并把current version的快照，也就是db元信息保存到<code>MANIFEST</code>文件中。</p>
<p>另外，MANIFEST文件组织是以VersionEdit的形式写入的，它本身是一个log文件格式，采用<code>log::Writer/Reader</code>的方式读写，一个VersionEdit就是一条log record。</p>
<h3 id="9-4-1-VersionSet"><a href="#9-4-1-VersionSet" class="headerlink" title="9.4.1 VersionSet"></a>9.4.1 VersionSet</h3><p>和DBImpl一样，下面就初识一下Version和VersionSet。先来看看Version的成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;files_[config::kNumLevels]; <span class="comment">// sstable文件列表  </span></span><br><span class="line"><span class="comment">// Next fileto compact based on seek stats. 下一个要compact的文件  </span></span><br><span class="line">FileMetaData* file_to_compact_;  </span><br><span class="line"><span class="type">int</span> file_to_compact_level_;  </span><br><span class="line"><span class="comment">// 下一个应该compact的level和compaction分数.  </span></span><br><span class="line"><span class="comment">// 分数 &lt; 1 说明compaction并不紧迫. 这些字段在Finalize()中初始化  </span></span><br><span class="line"><span class="type">double</span> compaction_score_;  </span><br><span class="line"><span class="type">int</span> compaction_level_;  </span><br></pre></td></tr></table></figure>
<p>可见一个Version就是一个sstable文件集合，以及它管理的compact状态。Version通过Version<em> prev和</em>next指针构成了一个Version双向循环链表，表头指针则在VersionSet中（初始都指向自己）。<br>下面是VersionSet的成员。可见它除了通过Version管理所有的sstable文件外，还关心manifest文件信息，以及控制log文件等编号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=== 第一组，直接来自于DBImple，构造函数传入  </span></span><br><span class="line">Env* <span class="type">const</span> env_; <span class="comment">// 操作系统封装  </span></span><br><span class="line"><span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;  </span><br><span class="line"><span class="type">const</span> Options* <span class="type">const</span> options_;  </span><br><span class="line">TableCache* <span class="type">const</span> table_cache_; <span class="comment">// table cache  </span></span><br><span class="line"><span class="type">const</span> InternalKeyComparatoricmp_;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//=== 第二组，db元信息相关  </span></span><br><span class="line"><span class="type">uint64_t</span> next_file_number_; <span class="comment">// log文件编号  </span></span><br><span class="line"><span class="type">uint64_t</span> manifest_file_number_; <span class="comment">// manifest文件编号  </span></span><br><span class="line"><span class="type">uint64_t</span> last_sequence_;  </span><br><span class="line"><span class="type">uint64_t</span> log_number_; <span class="comment">// log编号  </span></span><br><span class="line"><span class="type">uint64_t</span> prev_log_number_; <span class="comment">// 0 or backingstore for memtable being compacted  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=== 第三组，menifest文件相关  </span></span><br><span class="line">WritableFile* descriptor_file_;  </span><br><span class="line"><span class="built_in">log</span>::Writer* descriptor_log_;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//=== 第四组，版本管理  </span></span><br><span class="line">Version dummy_versions_; <span class="comment">// versions双向链表head.  </span></span><br><span class="line">Version* current_; <span class="comment">// ==dummy_versions_.prev_  </span></span><br><span class="line"><span class="comment">// level下一次compaction的开始key，空字符串或者合法的InternalKey  </span></span><br><span class="line"><span class="built_in">std</span>::stringcompact_pointer_[config::kNumLevels];  </span><br></pre></td></tr></table></figure>
<p>关于版本控制大概了解其Version和VersionEdit的功能和管理范围，详细的函数操作在后面再慢慢揭开。</p>
<h3 id="9-4-2-VersionEdit"><a href="#9-4-2-VersionEdit" class="headerlink" title="9.4.2 VersionEdit"></a>9.4.2 VersionEdit</h3><p>LevelDB中对Manifest的Decode/Encode是通过类VersionEdit完成的，Menifest文件保存了LevelDB的管理元信息。VersionEdit这个名字起的蛮有意思，每一次compaction，都好比是生成了一个新的DB版本，对应的Menifest则保存着这个版本的DB元信息。VersionEdit并不操作文件，只是为Manifest文件读写准备好数据、从读取的数据中解析出DB元信息。<br>VersionEdit有两个作用：</p>
<ol>
<li>当版本间有增量变动时，VersionEdit记录了这种变动；</li>
<li>写入到MANIFEST时，先将current version的db元信息保存到一个VersionEdit中，然后在组织成一个log record写入文件；</li>
</ol>
<p>了解了VersionEdit的作用，来看看这个类导出的函数接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Clear</span><span class="params">()</span>; <span class="comment">// 清空信息  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Setxxx</span><span class="params">()</span>; <span class="comment">// 一系列的Set函数，设置信息  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加sstable文件信息，要求：DB元信息还没有写入磁盘Manifest文件  </span></span><br><span class="line"><span class="comment">// @level：.sst文件层次；@file 文件编号-用作文件名 @size 文件大小  </span></span><br><span class="line"><span class="comment">// @smallest, @largest：sst文件包含k/v对的最大最小key  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AddFile</span><span class="params">(<span class="type">int</span> level, <span class="type">uint64_t</span> file, <span class="type">uint64_t</span> file_size,  </span></span><br><span class="line"><span class="params">               constInternalKey&amp; smallest, <span class="type">const</span> InternalKey&amp; largest)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteFile</span><span class="params">(<span class="type">int</span> level, <span class="type">uint64_t</span> file)</span>; <span class="comment">// 从指定的level删除文件  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EncodeTo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="type">const</span>; <span class="comment">// 将信息Encode到一个string中  </span></span><br><span class="line">Status <span class="title function_">DecodeFrom</span><span class="params">(<span class="type">const</span> Slice&amp; src)</span>; <span class="comment">// 从Slice中Decode出DB元信息  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//===================下面是成员变量，由此可大概窥得DB元信息的内容。  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt; <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">uint64_t</span>&gt; &gt; DeletedFileSet;  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> comparator_; <span class="comment">// key comparator名字  </span></span><br><span class="line"><span class="type">uint64_t</span> log_number_; <span class="comment">// 日志编号  </span></span><br><span class="line"><span class="type">uint64_t</span> prev_log_number_; <span class="comment">// 前一个日志编号  </span></span><br><span class="line"><span class="type">uint64_t</span> next_file_number_; <span class="comment">// 下一个文件编号  </span></span><br><span class="line">SequenceNumber last_sequence_; <span class="comment">// 上一个seq  </span></span><br><span class="line"><span class="type">bool</span> has_comparator_; <span class="comment">// 是否有comparator  </span></span><br><span class="line"><span class="type">bool</span> has_log_number_;<span class="comment">// 是否有log_number_  </span></span><br><span class="line"><span class="type">bool</span> has_prev_log_number_;<span class="comment">// 是否有prev_log_number_  </span></span><br><span class="line"><span class="type">bool</span> has_next_file_number_;<span class="comment">// 是否有next_file_number_  </span></span><br><span class="line"><span class="type">bool</span> has_last_sequence_;<span class="comment">// 是否有last_sequence_  </span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="type">int</span>, InternalKey&gt; &gt;compact_pointers_; <span class="comment">// compact点  </span></span><br><span class="line">DeletedFileSet deleted_files_; <span class="comment">// 删除文件集合  </span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="type">int</span>, FileMetaData&gt; &gt; new_files_; <span class="comment">// 新文件集合  </span></span><br></pre></td></tr></table></figure>
<p><code>Set</code>系列的函数都很简单，就是根据参数设置相应的信息。<br><code>AddFile</code>函数就是根据参数生产一个FileMetaData对象，把sstable文件信息添加到<strong>new_files_数组</strong>中。<br><code>DeleteFile</code>函数则是把参数指定的文件添加到<code>deleted_files</code>中；<br><code>SetCompactPointer</code>函数把{level, key}指定的compact点加入到<code>compact_pointers_</code>中。<br>执行序列化和发序列化的是<code>Decode</code>和<code>Encode</code>函数，根据这些代码，我们可以了解Manifest文件的存储格式。序列化函数逻辑都很直观，不详细说了。</p>
<h3 id="9-4-3-Manifest文件格式"><a href="#9-4-3-Manifest文件格式" class="headerlink" title="9.4.3 Manifest文件格式"></a>9.4.3 Manifest文件格式</h3><p>前面说过Manifest文件记录了leveldb的管理元信息，这些元信息到底都包含哪些内容呢？下面就来一一列示。<br>首先是使用的coparator名、log编号、前一个log编号、下一个文件编号、上一个序列号。这些都是日志、sstable文件使用到的重要信息，这些字段不一定必然存在。</p>
<p>Leveldb在写入每个字段之前，都会先写入一个varint型数字来标记后面的字段类型。在读取时，先读取此字段，根据类型解析后面的信息。一共有9种类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kComparator = <span class="number">1</span>, kLogNumber = <span class="number">2</span>, kNextFileNumber = <span class="number">3</span>, kLastSequence = <span class="number">4</span>,</span><br><span class="line">kCompactPointer = <span class="number">5</span>, kDeletedFile = <span class="number">6</span>, kNewFile = <span class="number">7</span>, kPrevLogNumber = <span class="number">9</span></span><br><span class="line"><span class="comment">// 8 was used for large value refs</span></span><br></pre></td></tr></table></figure>
<p>其中8另有它用。</p>
<p>其次是compact点，可能有多个，写入格式为<code>&#123;kCompactPointer, level, internal key&#125;</code>。其后是删除文件，可能有多个，格式为<code>&#123;kDeletedFile, level, file number&#125;</code>。最后是新文件，可能有多个，格式为<code>&#123;kNewFile, level, file number, file size, min key, max key&#125;</code>。</p>
<p>对于版本间变动它是新加的文件集合，对于MANIFEST快照是该版本包含的所有sstable文件集合。</p>
<p><img src="/img/leveldb16.webp" alt=""></p>
<p>其中的数字都是varint存储格式，string都是以varint指明其长度，后面跟实际的字符串内容。</p>
<h2 id="9-5-DB接口"><a href="#9-5-DB接口" class="headerlink" title="9.5 DB接口"></a>9.5 DB接口</h2><h3 id="9-5-1-接口函数"><a href="#9-5-1-接口函数" class="headerlink" title="9.5.1 接口函数"></a>9.5.1 接口函数</h3><p>除了DB类， leveldb还导出了C语言风格的接口：接口和实现在c.h&amp;c.cc，它其实是对<code>leveldb::DB</code>的一层封装。DB是一个持久化的有序<strong>map{key, value}</strong>，它是线程安全的。DB只是一个虚基类，下面来看看其接口：</p>
<p>首先是一个静态函数，打开一个db，成功返回OK，打开的db指针保存在<em>dbptr中，用完后，调用者需要调用`delete </em>dbptr`删除之。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Status <span class="title function_">Open</span><span class="params">(<span class="type">const</span> Options&amp; options, <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;name, DB** dbptr)</span>;</span><br></pre></td></tr></table></figure>
<p>下面几个是纯虚函数，最后还有两个全局函数，为何不像Open一样作为静态函数呢。<br>注：在几个更新接口中，可考虑设置<code>options.sync = true</code>。另外，虽然是纯虚函数，但是leveldb还是提供了缺省的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置db项&#123;key, value&#125;  </span></span><br><span class="line">virtual Status <span class="title function_">Put</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, <span class="type">const</span> Slice&amp;key, <span class="type">const</span> Slice&amp; value)</span> = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 在db中删除&quot;key&quot;，key不存在依然返回成功  </span></span><br><span class="line">virtual Status <span class="title function_">Delete</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, <span class="type">const</span> Slice&amp;key)</span> = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 更新操作  </span></span><br><span class="line">virtual Status <span class="title function_">Write</span><span class="params">(<span class="type">const</span> WriteOptions&amp; options, WriteBatch*updates)</span> = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 获取操作，如果db中有”key”项则返回结果，没有就返回Status::IsNotFound()  </span></span><br><span class="line">virtual Status <span class="title function_">Get</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options, <span class="type">const</span> Slice&amp; key,<span class="built_in">std</span>::<span class="built_in">string</span>* value)</span> = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 返回heap分配的iterator，访问db的内容，返回的iterator的位置是invalid的  </span></span><br><span class="line"><span class="comment">// 在使用之前，调用者必须先调用Seek。  </span></span><br><span class="line">virtual Iterator* <span class="title function_">NewIterator</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options)</span> = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">// 返回当前db状态的handle，和handle一起创建的Iterator看到的都是  </span></span><br><span class="line"><span class="comment">// 当前db状态的稳定快照。不再使用时，应该调用ReleaseSnapshot(result)  </span></span><br><span class="line">virtual <span class="type">const</span> Snapshot* <span class="title function_">GetSnapshot</span><span class="params">()</span> = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放获取的db快照  </span></span><br><span class="line">virtual <span class="title function_">voidReleaseSnapshot</span><span class="params">(<span class="type">const</span> Snapshot* snapshot)</span> = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 借此方法DB实现可以展现它们的属性状态. 如果&quot;property&quot; 是合法的，  </span></span><br><span class="line"><span class="comment">// 设置&quot;*value&quot;为属性的当前状态值并返回true，否则返回false.  </span></span><br><span class="line"><span class="comment">// 合法属性名包括：  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  &gt;&quot;leveldb.num-files-at-level&lt;N&gt;&quot;– 返回level &lt;N&gt;的文件个数,  </span></span><br><span class="line"><span class="comment">//     &lt;N&gt; 是level 数的ASCII 值 (e.g. &quot;0&quot;).  </span></span><br><span class="line"><span class="comment">//  &gt;&quot;leveldb.stats&quot; – 返回描述db内部操作统计的多行string  </span></span><br><span class="line"><span class="comment">//  &gt;&quot;leveldb.sstables&quot; – 返回一个多行string，描述构成db内容的所有sstable  </span></span><br><span class="line">virtual <span class="type">bool</span> <span class="title function_">GetProperty</span><span class="params">(constSlice&amp; property, <span class="built_in">std</span>::<span class="built_in">string</span>* value)</span> = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;sizes[i]&quot;保存的是&quot;[range[i].start.. range[i].limit)&quot;中的key使用的文件空间.  </span></span><br><span class="line"><span class="comment">// 注：返回的是文件系统的使用空间大概值，  </span></span><br><span class="line"><span class="comment">//     如果用户数据以10倍压缩，那么返回值就是对应用户数据的1/10  </span></span><br><span class="line"><span class="comment">//     结果可能不包含最近写入的数据大小.  </span></span><br><span class="line">virtual <span class="title function_">voidGetApproximateSizes</span><span class="params">(<span class="type">const</span> Range* range, <span class="type">int</span> n, <span class="type">uint64_t</span>* sizes)</span> = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Compactkey范围[*begin,*end]的底层存储，删除和被覆盖的版本将会被抛弃  </span></span><br><span class="line"><span class="comment">// 数据会被重新组织，以减少访问开销  </span></span><br><span class="line"><span class="comment">// 注：那些不了解底层实现的用户不应该调用该方法。  </span></span><br><span class="line"><span class="comment">//begin==NULL被当作db中所有key之前的key.  </span></span><br><span class="line"><span class="comment">//end==NULL被当作db中所有key之后的key.  </span></span><br><span class="line"><span class="comment">// 所以下面的调用将会compact整个db:  </span></span><br><span class="line"><span class="comment">//    db-&gt;CompactRange(NULL, NULL);  </span></span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">CompactRange</span><span class="params">(constSlice* begin, <span class="type">const</span> Slice* end)</span> = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后是两个全局函数--删除和修复DB  </span></span><br><span class="line"><span class="comment">// 要小心，该方法将删除指定db的所有内容  </span></span><br><span class="line">Status <span class="title function_">DestroyDB</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="type">const</span> Options&amp;options)</span>;  </span><br><span class="line"><span class="comment">// 如果db不能打开了，你可能调用该方法尝试纠正尽可能多的数据  </span></span><br><span class="line"><span class="comment">// 可能会丢失数据，所以调用时要小心  </span></span><br><span class="line">Status <span class="title function_">RepairDB</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="type">const</span> Options&amp;options)</span>;  </span><br></pre></td></tr></table></figure>
<h3 id="9-5-2-类图"><a href="#9-5-2-类图" class="headerlink" title="9.5.2 类图"></a>9.5.2 类图</h3><p>这里又会设计到几个功能类，如图9.5-1所示。此外还有前面我们讲过的几大组件：<strong>操作日志的读写类、内存MemTable类、InternalFilterPolicy类、Internal Key比较类、以及sstable的读取构建类</strong>。如图9.5-2所示。</p>
<p><img src="/img/leveldb17.webp" alt=""></p>
<p><img src="/img/leveldb18.webp" alt=""></p>
<p>这里涉及的类很多，snapshot是内存快照，Version和VersionSet类。</p>
<h2 id="9-6-DBImpl类"><a href="#9-6-DBImpl类" class="headerlink" title="9.6 DBImpl类"></a>9.6 DBImpl类</h2><p>在向下继续之前，有必要先了解下DBImpl这个具体的实现类。主要是它的成员变量，这说明了它都利用了哪些组件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//== 第一组，他们在构造函数中初始化后将不再改变。其中，InternalKeyComparator和InternalFilterPolicy已经分别在Memtable和FilterPolicy中分析过。  </span></span><br><span class="line">Env* <span class="type">const</span> env_; <span class="comment">// 环境，封装了系统相关的文件操作、线程等等  </span></span><br><span class="line"><span class="type">const</span> InternalKeyComparatorinternal_comparator_;  <span class="comment">// key comparator  </span></span><br><span class="line"><span class="type">const</span> InternalFilterPolicyinternal_filter_policy_;      <span class="comment">// filter policy  </span></span><br><span class="line"><span class="type">const</span> Options options_;  <span class="comment">//options_.comparator == &amp;internal_comparator_  </span></span><br><span class="line"><span class="type">bool</span> owns_info_log_;  </span><br><span class="line"><span class="type">bool</span> owns_cache_;  </span><br><span class="line"><span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//== 第二组，只有两个。  </span></span><br><span class="line">TableCache* table_cache_; <span class="comment">// Table cache，线程安全的  </span></span><br><span class="line">FileLock* db_lock_;<span class="comment">// 锁db文件，persistent state，直到leveldb进程结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//== 第三组，被mutex_包含的状态和成员  </span></span><br><span class="line">port::Mutex mutex_; <span class="comment">// 互斥锁  </span></span><br><span class="line">port::AtomicPointershutting_down_;  </span><br><span class="line">port::CondVar bg_cv_;   <span class="comment">// 在background work结束时激发  </span></span><br><span class="line">MemTable* mem_;  </span><br><span class="line">MemTable* imm_;      <span class="comment">// Memtablebeing compacted  </span></span><br><span class="line">port::AtomicPointerhas_imm_;  <span class="comment">// BGthread 用来检查是否是非NULL的imm_  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这三个是log相关的  </span></span><br><span class="line">WritableFile* logfile_;    <span class="comment">// log文件  </span></span><br><span class="line"><span class="type">uint64_t</span> logfile_number_; <span class="comment">// log文件编号  </span></span><br><span class="line"><span class="built_in">log</span>::Writer* log_;       <span class="comment">// log writer  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//== 第四组，没有规律  </span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;Writer*&gt;writers_; <span class="comment">// writers队列.  </span></span><br><span class="line">WriteBatch* tmp_batch_;  </span><br><span class="line">SnapshotList snapshots_; <span class="comment">//snapshot列表  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Setof table files to protect from deletion because they are  </span></span><br><span class="line"><span class="comment">// part ofongoing compactions.  </span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="type">uint64_t</span>&gt;pending_outputs_; <span class="comment">// 待copact的文件列表，保护以防误删  </span></span><br><span class="line"><span class="type">bool</span> bg_compaction_scheduled_; <span class="comment">// 是否有后台compaction在调度或者运行?  </span></span><br><span class="line">Status bg_error_; <span class="comment">// paranoid mode下是否有后台错误?  </span></span><br><span class="line">ManualCompaction*manual_compaction_; <span class="comment">// 手动compaction信息  </span></span><br><span class="line">CompactionStatsstats_[config::kNumLevels]; <span class="comment">// compaction状态  </span></span><br><span class="line">VersionSet* versions_; <span class="comment">// 多版本DB文件，又一个庞然大物</span></span><br></pre></td></tr></table></figure>
<h1 id="10-Version分析之一"><a href="#10-Version分析之一" class="headerlink" title="10.Version分析之一"></a>10.Version分析之一</h1><p>先来<strong>分析leveldb对单版本的sstable文件管理</strong>，主要集中在Version类中。前面的10.4节已经说明了Version类的功能和成员，这里分析其函数接口和代码实现。<br><strong>Version不会修改其管理的sstable文件，只有读取操作。</strong></p>
<h2 id="10-1-Version接口"><a href="#10-1-Version接口" class="headerlink" title="10.1 Version接口"></a>10.1 Version接口</h2><p>先来看看Version类的接口函数，接下来再一一分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 追加一系列iterator到 @*iters中，</span></span><br><span class="line"><span class="comment">//将在merge到一起时生成该Version的内容  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求: Version已经保存了(见VersionSet::SaveTo)  </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AddIterators</span><span class="params">(constReadOptions&amp;, </span></span><br><span class="line"><span class="params">                  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Iterator*&gt;* iters)</span>;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定@key查找value，如果找到保存在@*val并返回OK。  </span></span><br><span class="line"><span class="comment">// 否则返回non-OK，设置@ *stats.  </span></span><br><span class="line"><span class="comment">// 要求：没有hold lock  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GetStats</span> &#123;</span>  </span><br><span class="line">  FileMetaData* seek_file;  </span><br><span class="line">  <span class="type">int</span> seek_file_level;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">Status <span class="title function_">Get</span><span class="params">(constReadOptions&amp;, <span class="type">const</span> LookupKey&amp; key, </span></span><br><span class="line"><span class="params">           <span class="built_in">std</span>::<span class="built_in">string</span>* val,GetStats* stats)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 把@stats加入到当前状态中，如果需要触发新的compaction返回true  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求：hold lock  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">UpdateStats</span><span class="params">(constGetStats&amp; stats)</span>;  </span><br><span class="line"><span class="type">void</span> <span class="title function_">GetOverlappingInputs</span><span class="params">(intlevel,  </span></span><br><span class="line"><span class="params">    <span class="type">const</span> InternalKey*begin,         <span class="comment">// NULL 指在所有key之前  </span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> InternalKey* end,           <span class="comment">// NULL指在所有key之后  </span></span></span><br><span class="line"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* inputs)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果指定level中的某些文件和[*smallest_user_key,*largest_user_key]</span></span><br><span class="line"><span class="comment">//有重合就返回true。  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @smallest_user_key==NULL表示比DB中所有key都小的key.  </span></span><br><span class="line"><span class="comment">// @largest_user_key==NULL表示比DB中所有key都大的key.  </span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OverlapInLevel</span><span class="params">(<span class="type">int</span> level,<span class="type">const</span> Slice*smallest_user_key,</span></span><br><span class="line"><span class="params">                    <span class="type">const</span> Slice* largest_user_key)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回我们应该在哪个level上放置新的memtable compaction，  </span></span><br><span class="line"><span class="comment">// 该compaction覆盖了范围[smallest_user_key,largest_user_key].  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">PickLevelForMemTableOutput</span><span class="params">(<span class="type">const</span> Slice&amp; smallest_user_key,  </span></span><br><span class="line"><span class="params">                           <span class="type">const</span> Slice&amp; largest_user_key)</span>;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指定level的sstable个数 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NumFiles</span><span class="params">(<span class="type">int</span> level)</span> <span class="type">const</span> &#123;<span class="keyword">return</span> files_[level].size();</span><br></pre></td></tr></table></figure>
<h2 id="10-2-Version-AddIterators"><a href="#10-2-Version-AddIterators" class="headerlink" title="10.2 Version::AddIterators()"></a>10.2 Version::AddIterators()</h2><p>该函数最终在<code>DB::NewIterators()</code>接口中被调用，调用层次为：<br><code>DBImpl::NewIterator()-&gt;DBImpl::NewInternalIterator()-&gt;Version::AddIterators()</code>。</p>
<p>函数功能是为该Version中的所有sstable都创建一个Two Level Iterator，以遍历sstable的内容。</p>
<ul>
<li>对于<strong>level=0</strong>级别的sstable文件，直接通过TableCache::NewIterator()接口创建，这会直接载入sstable文件到内存cache中。</li>
<li>对于<strong>level&gt;0</strong>级别的sstable文件，通过函数NewTwoLevelIterator()创建一个TwoLevelIterator，这就使用了lazy open的机制。</li>
</ul>
<p>下面来分析函数代码：</p>
<h4 id="S1-19"><a href="#S1-19" class="headerlink" title="S1"></a>S1</h4><p>对于level=0级别的sstable文件，直接装入cache，level0的sstable文件可能有重合，需要merge。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt;files_[<span class="number">0</span>].size(); i++) &#123;  </span><br><span class="line">	iters-&gt;push_back(vset_-&gt;table_cache_-&gt;NewIterator(<span class="comment">// versionset::table_cache_  </span></span><br><span class="line">		options,files_[<span class="number">0</span>][i]-&gt;number, files_[<span class="number">0</span>][i]-&gt;file_size));  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="S2-16"><a href="#S2-16" class="headerlink" title="S2"></a>S2</h4><p>对于level&gt;0级别的sstable文件，lazy open机制，它们不会有重叠。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ll = <span class="number">1</span>; ll &lt;config::kNumLevels; ll++) &#123;  </span><br><span class="line">	<span class="keyword">if</span>(!files_[ll].empty()) iters-&gt;push_back(NewConcatenatingIterator(options,level));  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>函数NewConcatenatingIterator()直接返回一个TwoLevelIterator对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> NewTwoLevelIterator(new LevelFileNumIterator(vset_-&gt;icmp_,&amp;files_[level]),</span><br><span class="line">                           &amp;GetFileIterator,vset_-&gt;table_cache_, options);</span><br></pre></td></tr></table></figure>
<ul>
<li>其第一级iterator是一个LevelFileNumIterator</li>
<li>第二级的迭代函数是GetFileIterator</li>
</ul>
<p>下面就来分别分析之。<br>GetFileIterator是一个静态函数，很简单，直接返回TableCache::NewIterator()。函数声明为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Iterator* <span class="title function_">GetFileIterator</span><span class="params">(<span class="type">void</span>* arg,<span class="type">const</span> ReadOptions&amp; options, constSlice&amp; file_value)</span></span><br><span class="line">TableCache* cache =reinterpret_cast&lt;TableCache*&gt;(arg);  </span><br><span class="line">	<span class="keyword">if</span> (file_value.size() != <span class="number">16</span>) &#123; <span class="comment">// 错误  </span></span><br><span class="line">		<span class="keyword">return</span> NewErrorIterator(Status::Corruption(<span class="string">&quot;xxx&quot;</span>));  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">	<span class="keyword">return</span> cache-&gt;NewIterator(options,  </span><br><span class="line">                DecodeFixed64(file_value.data()), <span class="comment">// filenumber  </span></span><br><span class="line">                DecodeFixed64(file_value.data() + <span class="number">8</span>)); <span class="comment">// filesize  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这里的<strong>file_value</strong>是取自于LevelFileNumIterator的value，它的value()函数把file number和size以Fixed 8byte的方式压缩成一个Slice对象并返回。</p>
<h2 id="10-3-Version-LevelFileNumIterator类"><a href="#10-3-Version-LevelFileNumIterator类" class="headerlink" title="10.3 Version::LevelFileNumIterator类"></a>10.3 Version::LevelFileNumIterator类</h2><p>这也是一个继承者Iterator的子类，一个内部Iterator。</p>
<p><strong>给定一个version/level对</strong>，生成该level内的文件信息。</p>
<p><strong>对于给定的entry</strong>：</p>
<ul>
<li>key()返回的是文件中所包含的最大的key；</li>
<li>value()返回的是|file number(8 bytes)|file size(8 bytes)|串；</li>
<li>它的构造函数接受两个参数：InternalKeyComparator&amp;，用于key的比较；</li>
<li>vector<FileMetaData*>*，指向version的所有sstable文件列表。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LevelFileNumIterator(<span class="type">const</span> InternalKeyComparator&amp; icmp,</span><br><span class="line">                                      <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* flist)</span><br><span class="line">                                      : icmp_(icmp), flist_(flist),index_(flist-&gt;size()) &#123;&#125; <span class="comment">// Marks as invalid</span></span><br></pre></td></tr></table></figure>
<p>来看看其接口实现。</p>
<p>Valid函数、SeekToxx和Next/Prev函数都很简单，毕竟容器是一个vector。Seek函数调用了FindFile，这个函数后面会分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="type">void</span> <span class="title function_">Seek</span><span class="params">(constSlice&amp; target)</span> &#123; index_ = FindFile(icmp_, *flist_, target);&#125;  </span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">SeekToFirst</span><span class="params">()</span> &#123;index_ = <span class="number">0</span>; &#125;  </span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">SeekToLast</span><span class="params">()</span> &#123;index_ = flist_-&gt;empty() ? <span class="number">0</span> : flist_-&gt;size() - <span class="number">1</span>;&#125;  </span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">Next</span><span class="params">()</span> &#123;  </span><br><span class="line">    assert(Valid());  </span><br><span class="line">    index_++;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">virtual <span class="type">void</span> <span class="title function_">Prev</span><span class="params">()</span> &#123;  </span><br><span class="line">    assert(Valid());  </span><br><span class="line">    <span class="keyword">if</span> (index_ == <span class="number">0</span>) index_ =flist_-&gt;size(); <span class="comment">// Marks as invalid  </span></span><br><span class="line">    <span class="keyword">else</span> index_--;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">Slice <span class="title function_">key</span><span class="params">()</span> <span class="type">const</span> &#123;  </span><br><span class="line">	assert(Valid());  </span><br><span class="line">	<span class="keyword">return</span>(*flist_)[index_]-&gt;largest.Encode(); <span class="comment">// 返回当前sstable包含的largest key  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">Slice <span class="title function_">value</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="comment">// 根据|number|size|的格式Fixed int压缩  </span></span><br><span class="line">    assert(Valid());  </span><br><span class="line">    EncodeFixed64(value_buf_,(*flist_)[index_]-&gt;number);  </span><br><span class="line">    EncodeFixed64(value_buf_+<span class="number">8</span>,(*flist_)[index_]-&gt;file_size);  </span><br><span class="line">    <span class="keyword">return</span> Slice(value_buf_,<span class="keyword">sizeof</span>(value_buf_));  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>来看FindFile，这其实是一个二分查找函数，因为传入的sstable文件列表是有序的，因此可以使用二分查找算法。就不再列出代码了。</p>
<h2 id="10-4-Version-Get"><a href="#10-4-Version-Get" class="headerlink" title="10.4 Version::Get()"></a>10.4 Version::Get()</h2><p>查找函数，直接在DBImpl::Get()中被调用，函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Version::Get</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options, constLookupKey&amp; k, <span class="built_in">std</span>::<span class="built_in">string</span>* value, GetStats* stats)</span></span><br></pre></td></tr></table></figure>
<p><strong>如果本次Get不止seek了一个文件</strong>（仅会发生在level 0的情况），就将搜索的第一个文件保存在stats中。<strong>如果stat有数据返回</strong>，表明本次读取在搜索到包含key的sstable文件之前，还做了其它无谓的搜索。这个结果将用在UpdateStats()中。<br>这个函数逻辑还是有些复杂的，来看看代码。</p>
<h4 id="S1-20"><a href="#S1-20" class="headerlink" title="S1"></a>S1</h4><p>首先，取得必要的信息，初始化几个临时变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Slice ikey = k.internal_key();  </span><br><span class="line">Slice user_key = k.user_key();  </span><br><span class="line">const Comparator* ucmp =vset_-&gt;icmp_.user_comparator();  </span><br><span class="line">Status s;  </span><br><span class="line">stats-&gt;seek_file = NULL;  </span><br><span class="line">stats-&gt;seek_file_level = -1;  </span><br><span class="line">FileMetaData* last_file_read =NULL; // 在找到&gt;1个文件时，读取时记录上一个  </span><br><span class="line">int last_file_read_level = -1;        // 这仅发生在level 0的情况下  </span><br><span class="line">std::vector&lt;FileMetaData*&gt;tmp;  </span><br><span class="line">FileMetaData* tmp2;  </span><br></pre></td></tr></table></figure>
<h4 id="S2-17"><a href="#S2-17" class="headerlink" title="S2"></a>S2</h4><p>从0开始遍历所有的level，依次查找。因为entry不会跨越level，因此如果在某个level中找到了entry，那么就无需在后面的level中查找了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;  </span><br><span class="line">    <span class="type">size_t</span> num_files = files_[level].size();  </span><br><span class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 本层没有文件，则直接跳过  </span></span><br><span class="line">    <span class="comment">// 取得level下的所有sstable文件列表，搜索本层  </span></span><br><span class="line">    FileMetaData* <span class="type">const</span>* files = &amp;files_[level][<span class="number">0</span>];   </span><br></pre></td></tr></table></figure>
<p>后面的所有逻辑都在for循环体中。</p>
<h4 id="S3-12"><a href="#S3-12" class="headerlink" title="S3"></a>S3</h4><p>遍历level下的sstable文件列表，搜索，注意对于level=0和&gt;0的sstable文件的处理，由于level 0文件之间的key可能有重叠，因此处理逻辑有别于&gt;0的level。</p>
<h5 id="S3-1"><a href="#S3-1" class="headerlink" title="S3.1"></a>S3.1</h5><p>对于level 0，文件可能有重叠，找到所有和user_key有重叠的文件，然后根据时间顺序从最新的文件依次处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tmp.reserve(num_files);  </span><br><span class="line"></span><br><span class="line">for (uint32_t i = 0; i &lt;num_files; i++) &#123; // 遍历level 0下的所有sstable文件  </span><br><span class="line">    FileMetaData* f =files[i];  </span><br><span class="line">    if(ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= 0 &amp;&amp;  </span><br><span class="line">    ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= 0)  </span><br><span class="line">    tmp.push_back(f); // sstable文件有user_key有重叠   </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">if (tmp.empty()) continue;  </span><br><span class="line">std::sort(tmp.begin(),tmp.end(), NewestFirst); // 排序  </span><br><span class="line">files = &amp;tmp[0]; num_files= tmp.size();// 指向tmp指针和大小  </span><br></pre></td></tr></table></figure>
<h5 id="S3-2"><a href="#S3-2" class="headerlink" title="S3.2"></a>S3.2</h5><p>对于level&gt;0，leveldb保证sstable文件之间不会有重叠，所以处理逻辑有别于level 0，直接根据ikey定位到sstable文件即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找，找到第一个largest key &gt;=ikey的file index  </span></span><br><span class="line"><span class="type">uint32_t</span> index =FindFile(vset_-&gt;icmp_, files_[level], ikey);  </span><br><span class="line"><span class="keyword">if</span> (index &gt;= num_files) &#123; <span class="comment">// 未找到，文件不存在  </span></span><br><span class="line">    files = <span class="literal">NULL</span>;  num_files = <span class="number">0</span>;  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    tmp2 = files[index];  </span><br><span class="line">    <span class="keyword">if</span>(ucmp-&gt;Compare(user_key, tmp2-&gt;smallest.user_key()) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">// 找到的文件其所有key都大于user_key，等于文件不存在  </span></span><br><span class="line">        files = <span class="literal">NULL</span>;  num_files = <span class="number">0</span>;  </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">		files = &amp;tmp2;  num_files = <span class="number">1</span>;  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="S4-2"><a href="#S4-2" class="headerlink" title="S4"></a>S4</h4><p>遍历找到的文件，存在files中，其个数为num_files。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (uint32_t i = 0; i &lt;num_files; ++i) &#123;</span><br></pre></td></tr></table></figure>
<p>后面的逻辑都在这一层循环中，只要在某个文件中找到了k/v对，就跳出for循环。</p>
<h5 id="S4-1"><a href="#S4-1" class="headerlink" title="S4.1"></a>S4.1</h5><p>如果本次读取不止搜索了一个文件，记录之，这仅会发生在level 0的情况下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(last_file_read != <span class="literal">NULL</span> &amp;&amp; stats-&gt;seek_file == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">   <span class="comment">// 本次读取不止seek了一个文件，记录第一个  </span></span><br><span class="line">   stats-&gt;seek_file =last_file_read;  </span><br><span class="line">   stats-&gt;seek_file_level= last_file_read_level;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">FileMetaData* f = files[i];  </span><br><span class="line">last_file_read = f; <span class="comment">// 记录本次读取的level和file  </span></span><br><span class="line">last_file_read_level =level;  </span><br></pre></td></tr></table></figure>
<h5 id="S4-2"><a href="#S4-2" class="headerlink" title="S4.2"></a>S4.2</h5><p>调用TableCache::Get()尝试获取{ikey, value}，如果返回OK则进入，否则直接返回，传递的回调函数是SaveValue()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Saver saver; <span class="comment">// 初始化saver  </span></span><br><span class="line">saver.state = kNotFound;  </span><br><span class="line">saver.ucmp = ucmp;  </span><br><span class="line">saver.user_key = user_key;  </span><br><span class="line">saver.value = value;  </span><br><span class="line">s = vset_-&gt;table_cache_-&gt;Get(options,f-&gt;number, f-&gt;file_size,  </span><br><span class="line">                            ikey, &amp;saver, SaveValue);  </span><br><span class="line"><span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;  </span><br></pre></td></tr></table></figure>
<h5 id="S4-3"><a href="#S4-3" class="headerlink" title="S4.3"></a>S4.3</h5><p>根据saver的状态判断，如果是Not Found则向下搜索下一个更早的sstable文件，其它值则返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (saver.state) &#123;  </span><br><span class="line">  <span class="keyword">case</span> kNotFound: <span class="keyword">break</span>; <span class="comment">// 继续搜索下一个更早的sstable文件  </span></span><br><span class="line">  <span class="keyword">case</span> kFound:  <span class="keyword">return</span> s; <span class="comment">// 找到  </span></span><br><span class="line">  <span class="keyword">case</span> kDeleted: <span class="comment">// 已删除  </span></span><br><span class="line">        s =Status::NotFound(Slice());  <span class="comment">// 为了效率，使用空的错误字符串  </span></span><br><span class="line">        <span class="keyword">return</span> s;  </span><br><span class="line">  <span class="keyword">case</span> kCorrupt: <span class="comment">// 数据损坏  </span></span><br><span class="line">        s =Status::Corruption(<span class="string">&quot;corrupted key for &quot;</span>, user_key);  </span><br><span class="line">        <span class="keyword">return</span> s;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>以上就是<code>Version::Get()</code>的代码逻辑，如果level 0的sstable文件太多的话，会影响读取速度，这也是为什么进行compaction的原因。<br>另外，还有一个传递给<code>TableCache::Get()</code>的saver函数，下面就来简单分析下。这是一个静态函数：<code>static void SaveValue(void* arg,const Slice&amp; ikey, const Slice&amp; v)</code>。它内部使用了结构体Saver：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Saver</span> &#123;</span></span><br><span class="line">    SaverState state;</span><br><span class="line">    <span class="type">const</span> Comparator* ucmp; <span class="comment">// user key比较器</span></span><br><span class="line">    Slice user_key;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数SaveValue的逻辑很简单。<strong>首先</strong>解析Table传入的InternalKey，<strong>然后</strong>根据指定的Comparator判断user key是否是要查找的user key。<strong>如果</strong>是并且type是kTypeValue，则<strong>设置</strong>到Saver::<em>value中，并<em>*返回</em></em>kFound，否则返回kDeleted。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Saver* s =reinterpret_cast&lt;Saver*&gt;(arg);  </span><br><span class="line">ParsedInternalKey parsed_key; <span class="comment">// 解析ikey到ParsedInternalKey  </span></span><br><span class="line"><span class="keyword">if</span> (!ParseInternalKey(ikey,&amp;parsed_key)) s-&gt;state = kCorrupt; <span class="comment">// 解析失败  </span></span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span>(s-&gt;ucmp-&gt;Compare(parsed_key.user_key, s-&gt;user_key) == <span class="number">0</span>) &#123; <span class="comment">// 比较user key  </span></span><br><span class="line">        s-&gt;state =(parsed_key.type == kTypeValue) ? kFound : kDeleted;  </span><br><span class="line">        <span class="keyword">if</span> (s-&gt;state == kFound) s-&gt;value-&gt;assign(v.data(), v.size()); <span class="comment">// 找到，保存结果  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>下面要分析的几个函数，或多或少都和compaction相关。</p>
<h2 id="10-5-Version-UpdateStats"><a href="#10-5-Version-UpdateStats" class="headerlink" title="10.5 Version::UpdateStats()"></a>10.5 Version::UpdateStats()</h2><p>当<code>Get</code>操作直接搜寻<code>memtable</code>没有命中时，就需要调用<code>Version::Get()</code>函数从磁盘load数据文件并查找。如果此次Get不止seek了一个文件，就记录第一个文件到stat并返回。其后leveldb就会调用<code>UpdateStats(stat)</code>。</p>
<p><code>Stat</code>表明在指定key range查找key时，都要先<strong>seek此文件</strong>，才能在后续的sstable文件中找到<code>key</code>。</p>
<p>该函数是将stat记录的sstable文件的<code>allowed_seeks</code>减1，减到0就执行compaction。也就是说如果文件被seek的次数超过了限制，表明读取效率已经很低，需要执行compaction了。所以说<code>allowed_seeks</code>是对compaction流程的有一个优化。</p>
<p>函数声明：<code>boolVersion::UpdateStats(const GetStats&amp; stats)</code>函数逻辑很简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileMetaData* f =stats.seek_file;  </span><br><span class="line"><span class="keyword">if</span> (f != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">   f-&gt;allowed_seeks--;  </span><br><span class="line">   <span class="keyword">if</span> (f-&gt;allowed_seeks &lt;=<span class="number">0</span> &amp;&amp; file_to_compact_ == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">       file_to_compact_ = f;  </span><br><span class="line">       file_to_compact_level_ =stats.seek_file_level;  </span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>变量<code>allowed_seeks</code>的值在sstable文件加入到<code>version</code>时确定，也就是后面将遇到的<code>VersionSet::Builder::Apply()</code>函数。</p>
<h2 id="10-6-Version-GetOverlappingInputs"><a href="#10-6-Version-GetOverlappingInputs" class="headerlink" title="10.6 Version::GetOverlappingInputs()"></a>10.6 Version::GetOverlappingInputs()</h2><p>它在指定level中找出和<strong>[begin, end]</strong>有重合的sstable文件，函数声明为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Version::GetOverlappingInputs</span><span class="params">(<span class="type">int</span> level,</span></span><br><span class="line"><span class="params">           <span class="type">const</span> InternalKey* begin, constInternalKey* end, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* inputs)</span>;</span><br></pre></td></tr></table></figure>
<p>要注意的是，对于<code>level0</code>，由于文件可能有重合，其处理具有特殊性。当在level 0中找到有sstable文件和<strong>[begin, end]</strong>重合时，会相应的将<code>begin/end</code>扩展到文件的min key/max key，然后重新开始搜索。了解了功能，下面分析函数实现代码，逻辑还是很直观的。</p>
<p>S1 首先根据参数初始化查找变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inputs-&gt;clear();  </span><br><span class="line">Slice user_begin, user_end;  </span><br><span class="line"><span class="keyword">if</span> (begin != <span class="literal">NULL</span>) user_begin =begin-&gt;user_key();  </span><br><span class="line"><span class="keyword">if</span> (end != <span class="literal">NULL</span>)  user_end = end-&gt;user_key();  </span><br><span class="line"><span class="type">const</span> Comparator* user_cmp =vset_-&gt;icmp_.user_comparator(); </span><br></pre></td></tr></table></figure>
<p>S2 遍历该层的sstable文件，比较sstable的<code>&#123;minkey,max key&#125;</code>和传入的<code>[begin, end]</code>，如果有重合就记录文件到<code>@inputs</code>中，需要对level 0做特殊处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt;files_[level].size(); ) &#123;  </span><br><span class="line">    FileMetaData* f =files_[level][i++];  </span><br><span class="line">    <span class="type">const</span> Slice file_start =f-&gt;smallest.user_key();  </span><br><span class="line">    <span class="type">const</span> Slice file_limit =f-&gt;largest.user_key();  </span><br><span class="line">    <span class="keyword">if</span> (begin != <span class="literal">NULL</span> &amp;&amp;user_cmp-&gt;Compare(file_limit, user_begin) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">       <span class="comment">//&quot;f&quot; 中的k/v全部在指定范围之前; 跳过  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end != <span class="literal">NULL</span>&amp;&amp; user_cmp-&gt;Compare(file_start, user_end) &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">       <span class="comment">//&quot;f&quot; 中的k/v全部在指定范围之后; 跳过  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">       inputs-&gt;push_back(f); <span class="comment">// 有重合，记录  </span></span><br><span class="line">       <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;  </span><br><span class="line">         <span class="comment">// 对于level 0，sstable文件可能相互有重叠，所以要检查新加的文件  </span></span><br><span class="line">         <span class="comment">// 是否范围更大，如果是则扩展范围重新开始搜索  </span></span><br><span class="line">         <span class="keyword">if</span> (begin != <span class="literal">NULL</span>&amp;&amp; user_cmp-&gt;Compare(file_start, user_begin) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">             user_begin = file_start;  </span><br><span class="line">             inputs-&gt;clear();  </span><br><span class="line">             i = <span class="number">0</span>;  </span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end != <span class="literal">NULL</span>&amp;&amp; user_cmp-&gt;Compare(file_limit, user_end) &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">             user_end = file_limit;  </span><br><span class="line">             inputs-&gt;clear();  </span><br><span class="line">             i = <span class="number">0</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="10-7-Version-OverlapInLevel"><a href="#10-7-Version-OverlapInLevel" class="headerlink" title="10.7 Version::OverlapInLevel()"></a>10.7 Version::OverlapInLevel()</h2><p>检查是否和指定level的文件有重合，该函数直接调用了<code>SomeFileOverlapsRange()</code>，这两个函数的声明为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Version::OverlapInLevel</span><span class="params">(<span class="type">int</span> level,<span class="type">const</span> Slice*smallest_user_key, </span></span><br><span class="line"><span class="params">                             <span class="type">const</span> Slice* largest_user_key)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> SomeFileOverlapsRange(vset_-&gt;icmp_,(level &gt; <span class="number">0</span>), files_[level],</span><br><span class="line">                                   smallest_user_key, largest_user_key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">SomeFileOverlapsRange</span><span class="params">(<span class="type">const</span> InternalKeyComparator&amp; icmp, </span></span><br><span class="line"><span class="params">							 <span class="type">bool</span> disjoint_sorted_files,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; files,<span class="type">const</span> 	</span></span><br><span class="line"><span class="params">                             Slice*smallest_user_key, </span></span><br><span class="line"><span class="params">                             <span class="type">const</span> Slice* largest_user_key)</span>;</span><br></pre></td></tr></table></figure>
<p>所以下面直接分析<code>SomeFileOverlapsRange()</code>函数的逻辑，代码很直观。<br><code>disjoint_sorted_files=true</code>，表明文件集合是互不相交、有序的，对于乱序的、可能有交集的文件集合，需要逐个查找，找到有重合的就返回true；对于有序、互不相交的文件集合，直接执行二分查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S1 乱序、可能相交的文件集合，依次查找  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; files.size(); i++) &#123;  </span><br><span class="line">     <span class="type">const</span> FileMetaData* f =files[i];  </span><br><span class="line">     <span class="keyword">if</span>(AfterFile(ucmp,smallest_user_key, f) ||</span><br><span class="line">        BeforeFile(ucmp, largest_user_key, f))&#123;  </span><br><span class="line">      &#125; <span class="keyword">else</span> </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 有重合  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// S2 有序&amp;互不相交，直接二分查找  </span></span><br><span class="line"><span class="type">uint32_t</span> index = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">if</span> (smallest_user_key != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">     <span class="comment">// Findthe earliest possible internal key smallest_user_key  </span></span><br><span class="line">     InternalKeysmall(*smallest_user_key, kMaxSequenceNumber,kValueTypeForSeek);  </span><br><span class="line">     index = FindFile(icmp, files,small.Encode());  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="keyword">if</span> (index &gt;= files.size())</span><br><span class="line">     <span class="comment">// 不存在比smallest_user_key小的key</span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line"> <span class="comment">//保证在largest_user_key之后</span></span><br><span class="line"> <span class="keyword">return</span> !BeforeFile(ucmp,largest_user_key, files[index]); </span><br></pre></td></tr></table></figure>
<p>上面的逻辑使用到了<code>AfterFile()</code>和<code>BeforeFile()</code>两个辅助函数，都很简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">AfterFile</span><span class="params">(<span class="type">const</span> Comparator* ucmp,  </span></span><br><span class="line"><span class="params">                       <span class="type">const</span> Slice* user_key, constFileMetaData* f)</span> &#123;  </span><br><span class="line">     <span class="keyword">return</span> (user_key!=<span class="literal">NULL</span>&amp;&amp; ucmp-&gt;Compare(*user_key, f-&gt;largest.user_key())&gt;<span class="number">0</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">BeforeFile</span><span class="params">(<span class="type">const</span> Comparator* ucmp,  </span></span><br><span class="line"><span class="params">constSlice* user_key, <span class="type">const</span> FileMetaData* f)</span> &#123;  </span><br><span class="line">	<span class="keyword">return</span> (user_key!=<span class="literal">NULL</span>&amp;&amp; ucmp-&gt;Compare(*user_key, f-&gt;smallest.user_key())&lt;<span class="number">0</span>);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="10-8-Version-PickLevelForMemTableOutput"><a href="#10-8-Version-PickLevelForMemTableOutput" class="headerlink" title="10.8 Version::PickLevelForMemTableOutput()"></a>10.8 Version::PickLevelForMemTableOutput()</h2><p>函数返回我们应该在哪个level上放置新的<code>memtable compaction</code>，这个compaction覆盖了范围<code>[smallest_user_key,largest_user_key]</code>。<br>该函数的调用链为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DBImpl::RecoverLogFile/DBImpl::CompactMemTable -&gt; DBImpl:: WriteLevel0Table-&gt;Version::PickLevelForMemTableOutput;</span><br></pre></td></tr></table></figure>
<p>函数声明如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int Version::PickLevelForMemTableOutput(const Slice&amp; smallest_user_key, constSlice&amp; largest_user_key);</span><br></pre></td></tr></table></figure></p>
<p>如果<code>level 0</code>没有找到重合就向下一层找，最大查找层次为<code>kMaxMemCompactLevel = 2</code>。如果在level 0or1找到了重合，就返回level 0。否则查找level 2，如果level 2有重合就返回level 1，否则返回level 2。<br>函数实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> level = <span class="number">0</span>;  </span><br><span class="line"><span class="comment">//level 0无重合  </span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">OverlapInLevel</span>(<span class="number">0</span>,&amp;smallest_user_key, &amp;largest_user_key)) &#123; </span><br><span class="line">    <span class="comment">// 如果下一层没有重叠，就压到下一层，  </span></span><br><span class="line">    <span class="comment">// andthe #bytes overlapping in the level after that are limited.  </span></span><br><span class="line">    <span class="built_in">InternalKeystart</span>(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);  </span><br><span class="line">    <span class="built_in">InternalKeylimit</span>(largest_user_key, <span class="number">0</span>, <span class="built_in">static_cast</span>&lt;ValueType&gt;(<span class="number">0</span>));  </span><br><span class="line">    std::vector&lt;FileMetaData*&gt; overlaps;  </span><br><span class="line">    <span class="keyword">while</span> (level &lt;config::kMaxMemCompactLevel) &#123;  </span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">OverlapInLevel</span>(level <span class="number">+1</span>, &amp;smallest_user_key, &amp;largest_user_key))  </span><br><span class="line">           <span class="keyword">break</span>; <span class="comment">// 检查level + 1层，有重叠就跳出循环  </span></span><br><span class="line">       <span class="built_in">GetOverlappingInputs</span>(level <span class="number">+2</span>, &amp;start, &amp;limit, &amp;overlaps); <span class="comment">// 没理解这个调用  </span></span><br><span class="line">       <span class="type">const</span> <span class="type">int64_t</span> sum =<span class="built_in">TotalFileSize</span>(overlaps);  </span><br><span class="line">       <span class="keyword">if</span> (sum &gt;kMaxGrandParentOverlapBytes) <span class="keyword">break</span>;  </span><br><span class="line">       level++;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> level;</span><br></pre></td></tr></table></figure>
<p>这个函数在整个<code>compaction</code>逻辑中的作用在分析DBImpl时再来结合整个流程分析，现在只需要了解它找到一个level存放新的compaction就行了。如果返回<strong>level = 0</strong>，表明在level 0或者1和指定的range有重叠；如果返回1，表明在level2和指定的range有重叠；否则就返回2（<code>kMaxMemCompactLevel</code>）。也就是说在<code>compactmemtable</code>的时候，写入的sstable文件不一定总是在level 0，如果比较顺利，没有重合的，它可能会写到level1或者level2中。</p>
<h2 id="10-9-小结"><a href="#10-9-小结" class="headerlink" title="10.9 小结"></a>10.9 小结</h2><p><code>Version</code>是管理某个版本的所有<code>sstable</code>的类，就其导出接口而言，无非是遍历sstable，查找k/v。以及为<code>compaction</code>做些事情，给定range，检查重叠情况。<br>而它不会修改它管理的sstable这些文件，对这些文件而言它是只读操作接口。</p>
<h1 id="11-VersionSet分析"><a href="#11-VersionSet分析" class="headerlink" title="11 VersionSet分析"></a>11 VersionSet分析</h1><p><code>Version</code>之后就是<code>VersionSet</code>，它并不是Version的简单集合，还肩负了不少的处理逻辑。这里的分析不涉及到<code>compaction</code>相关的部分，这部分会单独分析。包括log等各种编号计数器，compaction点的管理等等。</p>
<h2 id="11-1-VersionSet接口"><a href="#11-1-VersionSet接口" class="headerlink" title="11.1 VersionSet接口"></a>11.1 VersionSet接口</h2><p><strong>1 首先是构造函数，VersionSet会使用到TableCache，这个是调用者传入的。TableCache用于Get k/v操作。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VersionSet(const std::string&amp; dbname, const Options* options,</span><br><span class="line">           TableCache*table_cache, const InternalKeyComparator*);</span><br></pre></td></tr></table></figure>
<p><code>VersionSet</code>的构造函数很简单，除了根据参数初始化，还有两个地方值得注意：</p>
<ul>
<li><strong>N1</strong> next_file_number_从2开始；</li>
<li><strong>N2</strong> 创建新的Version并加入到Version链表中，并设置CURRENT=新创建version；</li>
<li>其它的数字初始化为0，指针初始化为NULL。</li>
</ul>
<p><strong>2 恢复函数，从磁盘恢复最后保存的元信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status Recover();</span><br></pre></td></tr></table></figure>
<p><strong>3 标记指定的文件编号已经被使用了</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void MarkFileNumberUsed(uint64_t number);</span><br></pre></td></tr></table></figure>
<p>逻辑很简单，就是根据编号更新文件编号计数器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (next_file_number_ &lt;= number) </span><br><span class="line">     next_file_number_ = number + 1;</span><br></pre></td></tr></table></figure>
<p><strong>4 在current version上应用指定的VersionEdit，生成新的MANIFEST信息，保存到磁盘上，并用作current version。</strong><br>要求：没有其它线程并发调用；要用于mu；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status LogAndApply(VersionEdit* edit, port::Mutex* mu)EXCLUSIVE_LOCKS_REQUIRED(mu);</span><br></pre></td></tr></table></figure>
<p><strong>5 对于@v中的@key，返回db中的大概位置</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> <span class="title function_">ApproximateOffsetOf</span><span class="params">(Version* v, <span class="type">const</span> InternalKey&amp; key)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>6 其它一些简单接口，信息获取或者设置，如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回current version</span></span><br><span class="line">Version* <span class="title function_">current</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> current_; </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前的MANIFEST文件号  </span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">ManifestFileNumber</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> manifest_file_number_;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配并返回新的文件编号  </span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">NewFileNumber</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> next_file_number_++; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前log文件编号  </span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">LogNumber</span><span class="params">()</span> <span class="type">const</span> &#123; </span><br><span class="line">     <span class="keyword">return</span> log_number_; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回正在compact的log文件编号，如果没有返回0  </span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">PrevLogNumber</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> prev_log_number_; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取、设置last sequence，set时不能后退  </span></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">LastSequence</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> last_sequence_; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SetLastSequence</span><span class="params">(<span class="type">uint64_t</span> s)</span> &#123;  </span><br><span class="line">    assert(s &gt;=last_sequence_);  </span><br><span class="line">    last_sequence_ = s;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定level中所有sstable文件大小的和  </span></span><br><span class="line"><span class="type">int64_t</span> <span class="title function_">NumLevelBytes</span><span class="params">(<span class="type">int</span> level)</span> <span class="type">const</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定level的文件个数  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NumLevelFiles</span><span class="params">(<span class="type">int</span> level)</span> <span class="type">const</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 重用@file_number，限制很严格：@file_number必须是最后分配的那个  </span></span><br><span class="line"><span class="comment">// 要求: @file_number是NewFileNumber()返回的.  </span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ReuseFileNumber</span><span class="params">(<span class="type">uint64_t</span> file_number)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (next_file_number_ ==file_number + <span class="number">1</span>) next_file_number_ = file_number;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于所有level&gt;0，遍历文件，找到和下一层文件的重叠数据的最大值(in bytes)  </span></span><br><span class="line"><span class="comment">// 这个就是Version:: GetOverlappingInputs()函数的简单应用  </span></span><br><span class="line"><span class="type">int64_t</span> <span class="title function_">MaxNextLevelOverlappingBytes</span><span class="params">()</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取函数，把所有version的所有level的文件加入到@live中  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AddLiveFiles</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="type">uint64_t</span>&gt;* live)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个可读的单行信息——每个level的文件数，保存在*scratch中  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LevelSummaryStorage</span> &#123;</span><span class="type">char</span> buffer[<span class="number">100</span>]; &#125;;  </span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="title function_">LevelSummary</span><span class="params">(LevelSummaryStorage* scratch)</span> <span class="type">const</span>; </span><br></pre></td></tr></table></figure>
<p>下面就来分析这两个接口<code>Recover</code>、<code>LogAndApply</code>以及<code>ApproximateOffsetOf</code>。</p>
<h2 id="11-2-VersionSet-Builder类"><a href="#11-2-VersionSet-Builder类" class="headerlink" title="11.2 VersionSet::Builder类"></a>11.2 VersionSet::Builder类</h2><p><code>Builder</code>是一个<strong>内部辅助类</strong>，其主要作用是：</p>
<ol>
<li>把一个<code>MANIFEST</code>记录的元信息应用到版本管理器<code>VersionSet</code>中；</li>
<li>把当前的版本状态设置到一个Version对象中。</li>
</ol>
<h3 id="11-2-1-成员与构造"><a href="#11-2-1-成员与构造" class="headerlink" title="11.2.1 成员与构造"></a>11.2.1 成员与构造</h3><p><code>Builder</code>的vset_与base_都是调用者传入的，此外它还为<code>FileMetaData</code>定义了一个比较类<code>BySmallestKey</code>，首先依照文件的min key，小的在前；如果min key相等则<code>file number</code>小的在前。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedefstd::set&lt;FileMetaData*, BySmallestKey&gt; FileSet;  </span><br><span class="line"><span class="comment">// 这个是记录添加和删除的文件  </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LevelState</span> &#123; </span><br><span class="line">  std::set&lt;<span class="type">uint64_t</span>&gt;deleted_files;  </span><br><span class="line">  <span class="comment">// 保证添加文件的顺序是有效定义的</span></span><br><span class="line">  FileSet* added_files;   </span><br><span class="line">&#125;;  </span><br><span class="line">VersionSet* vset_;  </span><br><span class="line">Version* base_;  </span><br><span class="line">LevelStatelevels_[config::kNumLevels];  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 其接口有3个：  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SaveTo</span><span class="params">(Version* v)</span></span>;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MaybeAddFile</span><span class="params">(Version* v, <span class="type">int</span> level, FileMetaData* f)</span></span>;  </span><br></pre></td></tr></table></figure>
<p>构造函数执行简单的初始化操作，在析构时，遍历检查<code>LevelState::added_files</code>，如果文件引用计数为0，则删除文件。</p>
<h3 id="11-2-2-Apply"><a href="#11-2-2-Apply" class="headerlink" title="11.2.2 Apply()"></a>11.2.2 Apply()</h3><p>函数声明：<code>voidApply(VersionEdit* edit)</code>，该函数将edit中的修改应用到当前状态中。注意除了<code>compaction</code>点直接修改了vset_，其它删除和新加文件的变动只是先存储在Builder自己的成员变量中，在调用SaveTo(v)函数时才施加到v上。</p>
<p><strong>S1 把edit记录的compaction点应用到当前状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit-&gt;compact_pointers_ =&gt; vset_-&gt;compact_pointer_</span><br></pre></td></tr></table></figure>
<p><strong>S2 把edit记录的已删除文件应用到当前状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit-&gt;deleted_files_ =&gt; levels_[level].deleted_files</span><br></pre></td></tr></table></figure>
<p><strong>S3把edit记录的新加文件应用到当前状态，这里会初始化文件的allowed_seeks值，以在文件被无谓seek指定次数后自动执行compaction，这里作者阐述了其设置规则。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.size(); i++) &#123;  </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> level =edit-&gt;new_files_[i].first;  </span><br><span class="line">    FileMetaData* f = newFileMetaData(edit-&gt;new_files_[i].second);  </span><br><span class="line">    f-&gt;refs = <span class="number">1</span>;  </span><br><span class="line">    f-&gt;allowed_seeks = (f-&gt;file_size /<span class="number">16384</span>); <span class="comment">// 16KB-见下面  </span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt;<span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;  </span><br><span class="line">    levels_[level].deleted_files.erase(f-&gt;number); <span class="comment">// 以防万一  </span></span><br><span class="line">    levels_[level].added_files-&gt;insert(f);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值allowed_seeks事关compaction的优化，其计算依据如下，首先假设：</p>
<ul>
<li>1 一次seek时间为10ms</li>
<li>2 写入10MB数据的时间为10ms（100MB/s）</li>
<li>3 compact 1MB的数据需要执行25MB的IO<ul>
<li>从本层读取1MB</li>
<li>从下一层读取10-12MB（文件的key range边界可能是非对齐的）</li>
<li>向下一层写入10-12MB</li>
</ul>
</li>
</ul>
<p>这意味这25次seek的代价等同于<code>compact 1MB</code>的数据，也就是一次seek花费的时间大约相当于<code>compact 40KB</code>的数据。基于保守的角度考虑，对于每16KB的数据，我们允许它在触发compaction之前能做一次seek。</p>
<h3 id="11-2-3-MaybeAddFile"><a href="#11-2-3-MaybeAddFile" class="headerlink" title="11.2.3 MaybeAddFile()"></a>11.2.3 MaybeAddFile()</h3><p>函数声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">voidMaybeAddFile(Version* v, <span class="type">int</span> level, FileMetaData* f);</span><br></pre></td></tr></table></figure>
<p>该函数尝试将f加入到<code>levels_[level]</code>文件set中。要满足两个条件：</p>
<ol>
<li>文件不能被删除，也就是不能在levels_[level].deleted_files集合中；</li>
<li>保证文件之间的key是连续的，即基于比较器vset_-&gt;icmp_，f的min key要大于levels_[level]集合中最后一个文件的max key；</li>
</ol>
<h3 id="11-2-4-SaveTo"><a href="#11-2-4-SaveTo" class="headerlink" title="11.2.4 SaveTo()"></a>11.2.4 SaveTo()</h3><p>把当前的状态存储到v中返回，函数声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SaveTo</span><span class="params">(Version* v)</span>;</span><br></pre></td></tr></table></figure>
<p>函数逻辑：For循环遍历所有的<code>level[0, config::kNumLevels-1]</code>，把新加的文件和已存在的文件merge在一起，丢弃已删除的文件，结果保存在v中。对于level&gt; 0，还要确保集合中的文件没有重合。</p>
<p><strong>S1 merge流程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原文件集合</span></span><br><span class="line">conststd::vector&lt;FileMetaData*&gt;&amp; base_files = base_-&gt;files_[level];   </span><br><span class="line">std::vector&lt;FileMetaData*&gt;::const_iterator base_iter =base_files.<span class="built_in">begin</span>();  </span><br><span class="line">std::vector&lt;FileMetaData*&gt;::const_iterator base_end =base_files.<span class="built_in">end</span>();  </span><br><span class="line"><span class="type">const</span> FileSet* added =levels_[level].added_files;  </span><br><span class="line">v-&gt;files_[level].<span class="built_in">reserve</span>(base_files.<span class="built_in">size</span>()+ added-&gt;<span class="built_in">size</span>());  </span><br><span class="line"><span class="keyword">for</span> (FileSet::const_iteratoradded_iter = added-&gt;<span class="built_in">begin</span>();</span><br><span class="line">    added_iter !=added-&gt;<span class="built_in">end</span>(); ++added_iter) &#123;  </span><br><span class="line">    <span class="comment">//加入base_中小于added_iter的那些文件  </span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(std::vector&lt;FileMetaData*&gt;::const_iterator bpos = std::<span class="built_in">upper_bound</span>(base_iter,base_end,*added_iter, cmp);  </span><br><span class="line">        base_iter != bpos;++base_iter) &#123; </span><br><span class="line">        <span class="comment">// base_iter逐次向后移到  </span></span><br><span class="line">        <span class="built_in">MaybeAddFile</span>(v, level,*base_iter);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 加入added_iter  </span></span><br><span class="line">    <span class="built_in">MaybeAddFile</span>(v, level,*added_iter); </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 添加base_剩余的那些文件  </span></span><br><span class="line">   <span class="keyword">for</span> (; base_iter != base_end;++base_iter) </span><br><span class="line">      <span class="built_in">MaybeAddFile</span>(v, level, *base_iter);</span><br></pre></td></tr></table></figure>
<p>对象cmp就是前面定义的比较仿函数<code>BySmallestKey</code>对象。</p>
<p><strong>S2 检查流程，保证level&gt;0的文件集合无重叠，基于vset_-&gt;icmp_，确保文件i-1的max key &lt; 文件i的min key。</strong></p>
<h2 id="11-3-Recover"><a href="#11-3-Recover" class="headerlink" title="11.3 Recover()"></a>11.3 Recover()</h2><p>对于<code>VersionSet</code>而言，<code>Recover</code>就是根据<code>CURRENT</code>指定的<code>MANIFEST</code>，读取db元信息。这是9.3介绍的Recovery流程的开始部分。</p>
<h3 id="11-3-1-函数流程"><a href="#11-3-1-函数流程" class="headerlink" title="11.3.1 函数流程"></a>11.3.1 函数流程</h3><p>下面就来分析其具体逻辑。</p>
<p><strong>S1 读取CURRENT文件，获得最新的MANIFEST文件名，根据文件名打开MANIFEST文件。CURRENT文件以\n结尾，读取后需要trim下。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string current; <span class="comment">// MANIFEST文件名  </span></span><br><span class="line"><span class="built_in">ReadFileToString</span>(env_, <span class="built_in">CurrentFileName</span>(dbname_), ¤t);  </span><br><span class="line">std::string dscname = dbname_ + <span class="string">&quot;/&quot;</span> + current;  </span><br><span class="line">SequentialFile* file;  </span><br><span class="line">env_-&gt;<span class="built_in">NewSequentialFile</span>(dscname, &amp;file); </span><br></pre></td></tr></table></figure>
<p><strong>S2 读取MANIFEST内容，MANIFEST是以log的方式写入的，因此这里调用的是log::Reader来读取。然后调用VersionEdit::DecodeFrom，从内容解析出VersionEdit对象，并将VersionEdit记录的改动应用到versionset中。读取MANIFEST中的log number, prev log number, nextfile number, last sequence。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;  </span><br><span class="line"><span class="keyword">while</span> (reader.<span class="built_in">ReadRecord</span>(&amp;record, &amp;scratch) &amp;&amp; s.<span class="built_in">ok</span>()) &#123;  </span><br><span class="line">      VersionEdit edit;  </span><br><span class="line">      s = edit.<span class="built_in">DecodeFrom</span>(record);  </span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">ok</span>())builder.<span class="built_in">Apply</span>(&amp;edit);  </span><br><span class="line">      <span class="comment">// log number, file number, …逐个判断  </span></span><br><span class="line">      <span class="keyword">if</span> (edit.has_log_number_) &#123; </span><br><span class="line">          log_number =edit.log_number_;  </span><br><span class="line">          have_log_number = <span class="literal">true</span>;  </span><br><span class="line">      &#125;  </span><br><span class="line">      … …  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><strong>S3 将读取到的log number, prev log number标记为已使用。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MarkFileNumberUsed</span>(prev_log_number);</span><br><span class="line"><span class="built_in">MarkFileNumberUsed</span>(log_number);</span><br></pre></td></tr></table></figure>
<p><strong>S4 最后，如果一切顺利就创建新的Version，并应用读取的几个number。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;  </span><br><span class="line">    Version* v = <span class="built_in">newVersion</span>(<span class="keyword">this</span>);  </span><br><span class="line">    builder.<span class="built_in">SaveTo</span>(v);  </span><br><span class="line">    <span class="comment">// 安装恢复的version  </span></span><br><span class="line">    <span class="built_in">Finalize</span>(v);  </span><br><span class="line">    <span class="built_in">AppendVersion</span>(v);  </span><br><span class="line">    manifest_file_number_ =next_file;  </span><br><span class="line">    next_file_number_ = next_file+ <span class="number">1</span>;  </span><br><span class="line">    last_sequence_ = last_sequence;  </span><br><span class="line">    log_number_ = log_number;  </span><br><span class="line">    prev_log_number_ =prev_log_number;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><code>Finalize(v)</code>和<code>AppendVersion(v)</code>用来安装并使用version v，在<code>AppendVersion</code>函数中会将<code>current version</code>设置为v。下面就来分别分析这两个函数。</p>
<h3 id="11-3-2-Finalize"><a href="#11-3-2-Finalize" class="headerlink" title="11.3.2 Finalize()"></a>11.3.2 Finalize()</h3><p>函数声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Finalize</span><span class="params">(Version*v)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数依照规则为下次的compaction计算出最适用的level，对于level 0和&gt;0需要分别对待，逻辑如下。</p>
<p><strong>S1 对于level 0以文件个数计算，kL0_CompactionTrigger默认配置为4。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">score =v-&gt;files_[level].<span class="built_in">size</span>()/<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(config::kL0_CompactionTrigger);</span><br></pre></td></tr></table></figure>
<p><strong>S2 对于level&gt;0，根据level内的文件总大小计算</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">uint64_t</span> level_bytes = <span class="built_in">TotalFileSize</span>(v-&gt;files_[level]);</span><br><span class="line">score = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(level_bytes) /<span class="built_in">MaxBytesForLevel</span>(level);</span><br></pre></td></tr></table></figure>
<p><strong>S3 最后把计算结果保存到v的两个成员compaction_level_和compaction_score_中。</strong></p>
<p>其中函数MaxBytesForLevel根据level返回其本层文件总大小的预定最大值。<br>计算规则为：<strong>1048576.0* level^10</strong>。<br>这里就有一个问题，为何level0和其它level计算方法不同，原因如下，这也是leveldb为<code>compaction</code>所做的另一个优化。</p>
<ol>
<li>对于较大的写缓存（write-buffer），做太多的level 0 compaction并不好</li>
<li>每次read操作都要merge level 0的所有文件，因此我们不希望level 0有太多的小文件存在（比如写缓存太小，或者压缩比较高，或者覆盖/删除较多导致小文件太多）。</li>
<li>看起来这里的写缓存应该就是配置的操作log大小。</li>
</ol>
<h3 id="11-3-3-AppendVersion"><a href="#11-3-3-AppendVersion" class="headerlink" title="11.3.3 AppendVersion()"></a>11.3.3 AppendVersion()</h3><p>函数声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AppendVersion</span><span class="params">(Version*v)</span></span>;</span><br></pre></td></tr></table></figure>
<p>把v加入到<code>versionset</code>中，并设置为<code>current version</code>。并对老的<code>current version</code>执行Uref()。在双向循环链表中的位置在<code>dummy_versions_</code>之前。</p>
<h2 id="11-4-LogAndApply"><a href="#11-4-LogAndApply" class="headerlink" title="11.4 LogAndApply()"></a>11.4 LogAndApply()</h2><p>函数声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LogAndApply</span><span class="params">(VersionEdit*edit, port::Mutex* mu)</span></span></span><br></pre></td></tr></table></figure>
<p>前面接口小节中讲过其功能：在currentversion上应用指定的VersionEdit，生成新的<strong>MANIFEST</strong>信息，保存到磁盘上，并用作<strong>current version</strong>，故为Log And Apply。<br>参数edit也会被函数修改。</p>
<h3 id="11-4-1-函数流程"><a href="#11-4-1-函数流程" class="headerlink" title="11.4.1 函数流程"></a>11.4.1 函数流程</h3><p>下面就来具体分析函数代码。</p>
<p><strong>S1 为edit设置log number等4个计数器。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (edit-&gt;has_log_number_) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(edit-&gt;log_number_ &gt;= log_number_);</span><br><span class="line">    <span class="built_in">assert</span>(edit-&gt;log_number_ &lt; next_file_number_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> edit-&gt;<span class="built_in">SetLogNumber</span>(log_number_);</span><br><span class="line"><span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) edit-&gt;<span class="built_in">SetPrevLogNumber</span>(prev_log_number_);</span><br><span class="line">edit-&gt;<span class="built_in">SetNextFile</span>(next_file_number_);</span><br><span class="line">edit-&gt;<span class="built_in">SetLastSequence</span>(last_sequence_);</span><br></pre></td></tr></table></figure>
<p>要保证edit自己的log number是比较大的那个，否则就是致命错误。保证edit的log number小于next file number，否则就是致命错误-见9.1小节。 </p>
<p><strong>S2 创建一个新的Version v，并把新的edit变动保存到v中。</strong> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Version* v = <span class="keyword">new</span> <span class="built_in">Version</span>(<span class="keyword">this</span>);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">    builder.<span class="built_in">Apply</span>(edit);</span><br><span class="line">    builder.<span class="built_in">SaveTo</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Finalize</span>(v); <span class="comment">//如前分析，只是为v计算执行compaction的最佳level  </span></span><br></pre></td></tr></table></figure>
<p><strong>S3 如果MANIFEST文件指针不存在，就创建并初始化一个新的MANIFEST文件。这只会发生在第一次打开数据库时。这个MANIFEST文件保存了current version的快照。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::string new_manifest_file;</span><br><span class="line">Status s;</span><br><span class="line"><span class="keyword">if</span> (descriptor_log_ == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里不需要unlock *mu因为我们只会在第一次调用LogAndApply时  </span></span><br><span class="line">    <span class="comment">// 才走到这里(打开数据库时).  </span></span><br><span class="line">    <span class="built_in">assert</span>(descriptor_file_ == <span class="literal">NULL</span>); <span class="comment">// 文件指针和log::Writer都应该是NULL  </span></span><br><span class="line">    new_manifest_file = <span class="built_in">DescriptorFileName</span>(dbname_, manifest_file_number_);</span><br><span class="line">    edit-&gt;<span class="built_in">SetNextFile</span>(next_file_number_);</span><br><span class="line">    s = env_-&gt;<span class="built_in">NewWritableFile</span>(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        descriptor_log_ = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(descriptor_file_);</span><br><span class="line">        s = <span class="built_in">WriteSnapshot</span>(descriptor_log_); <span class="comment">// 写入快照  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>S4 向MANIFEST写入一条新的log，记录current version的信息。在文件写操作时unlock锁，写入完成后，再重新lock，以防止浪费在长时间的IO操作上。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mu-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    std::string record;</span><br><span class="line">    edit-&gt;<span class="built_in">EncodeTo</span>(&amp;record);<span class="comment">// 序列化current version信息  </span></span><br><span class="line">    s = descriptor_log_-&gt;<span class="built_in">AddRecord</span>(record); <span class="comment">// append到MANIFEST log中  </span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) s = descriptor_file_-&gt;<span class="built_in">Sync</span>();</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="built_in">Log</span>(options_-&gt;info_log, <span class="string">&quot;MANIFEST write: %s\n&quot;</span>, s.<span class="built_in">ToString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ManifestContains</span>(record)) &#123; <span class="comment">// 返回出错，其实确实写成功了  </span></span><br><span class="line">            <span class="built_in">Log</span>(options_-&gt;info_log, <span class="string">&quot;MANIFEST contains log record despiteerror &quot;</span>);</span><br><span class="line">            s = Status::<span class="built_in">OK</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果刚才创建了一个MANIFEST文件，通过写一个指向它的CURRENT文件  </span></span><br><span class="line"><span class="comment">//安装它；不需要再次检查MANIFEST是否出错，因为如果出错后面会删除它  </span></span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; !new_manifest_file.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    s = <span class="built_in">SetCurrentFile</span>(env_, dbname_, manifest_file_number_);</span><br><span class="line">&#125;</span><br><span class="line">mu-&gt;<span class="built_in">Lock</span>();</span><br></pre></td></tr></table></figure>
<p><strong>S5 安装这个新的version</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123; <span class="comment">// 安装这个version  </span></span><br><span class="line">    <span class="built_in">AppendVersion</span>(v);</span><br><span class="line">    log_number_ = edit-&gt;log_number_;</span><br><span class="line">    prev_log_number_ = edit-&gt;prev_log_number_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// 失败了，删除  </span></span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">    <span class="keyword">if</span> (!new_manifest_file.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">        <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">        descriptor_log_ = descriptor_file_ = <span class="literal">NULL</span>;</span><br><span class="line">        env_-&gt;<span class="built_in">DeleteFile</span>(new_manifest_file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程的S4中，函数会检查MANIFEST文件是否已经有了这条record，那么什么时候会有呢？</p>
<p>主函数使用到了几个新的辅助函数WriteSnapshot，ManifestContains和SetCurrentFile，下面就来分析。</p>
<h3 id="11-4-2-WriteSnapshot"><a href="#11-4-2-WriteSnapshot" class="headerlink" title="11.4.2 WriteSnapshot()"></a>11.4.2 WriteSnapshot()</h3><p>函数声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteSnapshot</span><span class="params">(log::Writer*log)</span></span></span><br></pre></td></tr></table></figure>
<p>把currentversion保存到*log中，信息包括comparator名字、compaction点和各级sstable文件，函数逻辑很直观。</p>
<ul>
<li>S1 首先声明一个新的<strong>VersionEdit edit</strong>；</li>
<li>S2 设置comparator：<strong>edit.SetComparatorName(icmp_.user_comparator()-&gt;Name())</strong>;</li>
<li>S3 遍历所有level，根据compact_pointer_[level]，设置compaction点：<ul>
<li><strong>edit.SetCompactPointer(level, key)</strong>;</li>
</ul>
</li>
<li>S4 遍历所有level，根据current_-&gt;files_，设置sstable文件集合：<strong>edit.AddFile(level, xxx)</strong></li>
<li>S5 根据序列化并append到log（MANIFEST文件）中；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string record;</span><br><span class="line">edit.<span class="built_in">EncodeTo</span>(&amp;record);</span><br><span class="line">returnlog-&gt;<span class="built_in">AddRecord</span>(record);</span><br></pre></td></tr></table></figure>
<h3 id="11-4-3-ManifestContains"><a href="#11-4-3-ManifestContains" class="headerlink" title="11.4.3 ManifestContains()"></a>11.4.3 ManifestContains()</h3><p>函数声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ManifestContains</span><span class="params">(conststd::string&amp; record)</span></span></span><br></pre></td></tr></table></figure>
<p>如果当前MANIFEST包含指定的record就返回true，来看看函数逻辑。</p>
<ul>
<li>S1 根据当前的manifest_file_number_文件编号打开文件，创建<strong>SequentialFile</strong>对象</li>
<li>S2 根据创建的SequentialFile对象创建<strong>log::Reader</strong>，以读取文件</li>
<li>S3 调用log::Reader的ReadRecord依次读取record，如果和指定的record相同，就返回true，没有相同的record就返回false</li>
</ul>
<p><strong>SetCurrentFile</strong>很简单，就是根据指定manifest文件编号，构造出MANIFEST文件名，并写入到CURRENT即可。</p>
<h2 id="11-5-ApproximateOffsetOf"><a href="#11-5-ApproximateOffsetOf" class="headerlink" title="11.5 ApproximateOffsetOf()"></a>11.5 ApproximateOffsetOf()</h2><p>函数声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uint64_tApproximateOffsetOf</span>(Version* v, <span class="type">const</span> InternalKey&amp; ikey)</span><br></pre></td></tr></table></figure>
<p>在指定的version中查找指定key的大概位置。假设version中有n个<strong>sstable</strong>文件，并且落在了地i个sstable的key空间内，那么返回的位置 = sstable1文件大小+sstable2文件大小 + … + sstable (i-1)文件大小 + key在sstable i中的大概偏移。</p>
<p>可分为两段逻辑。</p>
<ul>
<li>首先直接和sstable的max key作比较，如果key &gt; max key，直接跳过该文件，还记得sstable文件是有序排列的。<ul>
<li>对于level &gt;0的文件集合而言，如果如果key &lt; sstable文件的min key，则直接跳出循环，因为后续的sstable的min key肯定大于key。</li>
</ul>
</li>
<li>key在sstable i中的大概偏移使用的是Table:: ApproximateOffsetOf(target)接口，前面分析过，它返回的是Table中&gt;= target的key的位置。</li>
</ul>
<p><strong>VersionSet的相关函数</strong>暂时分析到这里，compaction部分后需单独分析。</p>
<h1 id="12-DB的打开"><a href="#12-DB的打开" class="headerlink" title="12 DB的打开"></a>12 DB的打开</h1><p>先分析LevelDB是如何打开db的，万物始于创建。在打开流程中有几个辅助函数：<strong>DBImpl()，DBImpl::Recover, DBImpl::DeleteObsoleteFiles, DBImpl::RecoverLogFile, DBImpl::MaybeScheduleCompaction</strong>。</p>
<h2 id="12-1-DB-Open"><a href="#12-1-DB-Open" class="headerlink" title="12.1 DB::Open()"></a>12.1 DB::Open()</h2><p>打开一个db，进行PUT、GET操作，就是前面的静态函数<strong>DB::Open</strong>的工作。如果操作成功，它就返回一个db指针。前面说过DB就是一个接口类，其具体实现在DBImp类中，这是一个DB的子类。<br>函数声明为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DB::Open</span><span class="params">(<span class="type">const</span> Options&amp; options, <span class="type">const</span> std::string&amp;dbname, DB** dbptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>分解来看，Open()函数主要有以下5个执行步骤。</p>
<ul>
<li>S1 创建DBImpl对象，其后进入<strong>DBImpl::Recover()</strong>函数执行S2和S3。</li>
<li>S2 从已存在的db文件恢复db数据，根据CURRENT记录的MANIFEST文件读取db元信息；这通过调用<strong>VersionSet::Recover()</strong>完成。</li>
<li>S3 然后过滤出那些最近的更新log，前一个版本可能新加了这些log，但并没有记录在MANIFEST中。然后依次根据时间顺序，调用<strong>DBImpl::RecoverLogFile()</strong>从旧到新回放这些操作log。回放log时可能会修改db元信息，比如dump了新的level 0文件，因此它将返回一个VersionEdit对象，记录db元信息的变动。</li>
<li>S4 如果<strong>DBImpl::Recover()</strong>返回成功，就执行<strong>VersionSet::LogAndApply()</strong>应用VersionEdit，并保存当前的DB信息到新的MANIFEST文件中。</li>
<li>S5 最后删除一些过期文件，并检查是否需要执行compaction，如果需要，就启动后台线程执行。</li>
</ul>
<p>下面就来具体分析Open函数的代码，在Open函数中涉及到上面的3个流程。</p>
<p>S1 首先创建DBImpl对象，锁定并试图做Recover操作。Recover操作用来处理创建flag，比如存在就返回失败等等，尝试从已存在的sstable文件恢复db。并返回db元信息的变动信息，一个VersionEdit对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DBImpl* impl = <span class="built_in">newDBImpl</span>(options, dbname);  </span><br><span class="line">impl-&gt;mutex_.<span class="built_in">Lock</span>(); <span class="comment">// 锁db  </span></span><br><span class="line">VersionEdit edit;  </span><br><span class="line">Status s =impl-&gt;<span class="built_in">Recover</span>(&amp;edit); <span class="comment">// 处理flag&amp;恢复：create_if_missing,error_if_exists </span></span><br></pre></td></tr></table></figure>
<p>S2 如果Recover返回成功，则调用VersionSet取得新的log文件编号——实际上是在当前基础上+1，准备新的log文件。如果log文件创建成功，则根据log文件创建log::Writer。然后执行VersionSet::LogAndApply，根据edit记录的增量变动生成新的current version，并写入MANIFEST文件。</p>
<p>函数<strong>NewFileNumber(){returnnext_file_number_++;}</strong>，直接返回<strong>next_file_number_</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;<span class="built_in">NewFileNumber</span>();</span><br><span class="line">WritableFile* lfile;</span><br><span class="line">s = options.env-&gt;<span class="built_in">NewWritableFile</span>(<span class="built_in">LogFileName</span>(dbname, new_log_number), &amp;lfile);</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    edit.<span class="built_in">SetLogNumber</span>(new_log_number);</span><br><span class="line">    impl-&gt;logfile_ = lfile;</span><br><span class="line">    impl-&gt;logfile_number_ = new_log_number;</span><br><span class="line">    impl-&gt;log_ = newlog::<span class="built_in">Writer</span>(lfile);</span><br><span class="line">    s = impl-&gt;versions_-&gt;<span class="built_in">LogAndApply</span>(&amp;edit, &amp;impl-&gt;mutex_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>S3 如果VersionSet::LogAndApply返回成功，则删除过期文件，检查是否需要执行compaction，最终返回创建的DBImpl对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    impl-&gt;<span class="built_in">DeleteObsoleteFiles</span>();</span><br><span class="line">    impl-&gt;<span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">&#125;</span><br><span class="line">impl-&gt;mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>()) *dbptr = impl;</span><br><span class="line"><span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure>
<p>以上就是DB::Open的主题逻辑。</p>
<h2 id="12-2-DBImpl-DBImpl"><a href="#12-2-DBImpl-DBImpl" class="headerlink" title="12.2 DBImpl::DBImpl()"></a>12.2 DBImpl::DBImpl()</h2><p>构造函数做的都是初始化操作，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DBImpl::<span class="built_in">DBImpl</span>(<span class="type">const</span> Options&amp; options, <span class="type">const</span> std::string&amp;dbname)</span><br></pre></td></tr></table></figure>
<p>首先是初始化列表中，直接根据参数赋值，或者直接初始化。Comparator和filter policy都是参数传入的。在传递option时会首先将option中的参数合法化，<strong>logfile_number_</strong>初始化为0，指针初始化为NULL。<br>创建MemTable，并增加引用计数，创建WriteBatch。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mem_</span>(<span class="built_in">newMemTable</span>(internal_comparator_)),</span><br><span class="line"><span class="built_in">tmp_batch_</span>(<span class="keyword">new</span> WriteBatch),</span><br><span class="line">mem_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line"><span class="comment">// 然后在函数体中，创建TableCache和VersionSet。  </span></span><br><span class="line"><span class="comment">// 为其他预留10个文件，其余的都给TableCache.  </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> table_cache_size = options.max_open_files - <span class="number">10</span>;</span><br><span class="line">table_cache_ = <span class="built_in">newTableCache</span>(dbname_, &amp;options_, table_cache_size);</span><br><span class="line">versions_ = <span class="built_in">newVersionSet</span>(dbname_, &amp;options_, table_cache_, &amp;internal_comparator_);</span><br></pre></td></tr></table></figure>
<h2 id="12-3-DBImp-NewDB"><a href="#12-3-DBImp-NewDB" class="headerlink" title="12.3 DBImp::NewDB()"></a>12.3 DBImp::NewDB()</h2><p>当外部在调用<code>DB::Open()</code>时设置了option指定如果db不存在就创建，如果db不存在leveldb就会调用函数创建新的db。判断db是否存在的依据是<code>&lt;db name&gt;/CURRENT</code>文件是否存在。其逻辑很简单。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S1首先生产DB元信息，设置comparator名，以及log文件编号、文件编号，以及seq no。  </span></span><br><span class="line">VersionEdit new_db;</span><br><span class="line">new_db.<span class="built_in">SetComparatorName</span>(<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Name</span>());</span><br><span class="line">new_db.<span class="built_in">SetLogNumber</span>(<span class="number">0</span>);</span><br><span class="line">new_db.<span class="built_in">SetNextFile</span>(<span class="number">2</span>);</span><br><span class="line">new_db.<span class="built_in">SetLastSequence</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// S2 生产MANIFEST文件，将db元信息写入MANIFEST文件。  </span></span><br><span class="line"><span class="type">const</span> std::string manifest = <span class="built_in">DescriptorFileName</span>(dbname_, <span class="number">1</span>);</span><br><span class="line">WritableFile* file;</span><br><span class="line">Status s = env_-&gt;<span class="built_in">NewWritableFile</span>(manifest, &amp;file);</span><br><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) <span class="keyword">return</span> s;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">log::Writer <span class="title">log</span><span class="params">(file)</span></span>;</span><br><span class="line">    std::string record;</span><br><span class="line">    new_db.<span class="built_in">EncodeTo</span>(&amp;record);</span><br><span class="line">    s = log.<span class="built_in">AddRecord</span>(record);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) s = file-&gt;<span class="built_in">Close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> file;</span><br><span class="line"><span class="comment">// S3 如果成功，就把MANIFEST文件名写入到CURRENT文件中  </span></span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>()) </span><br><span class="line">    s = <span class="built_in">SetCurrentFile</span>(env_, dbname_, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    env_-&gt;<span class="built_in">DeleteFile</span>(manifest);</span><br><span class="line"><span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure>
<p>这就是创建新DB的逻辑，很简单。</p>
<h2 id="12-4-DBImpl-Recover"><a href="#12-4-DBImpl-Recover" class="headerlink" title="12.4 DBImpl::Recover()"></a>12.4 DBImpl::Recover()</h2><p>函数声明为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StatusDBImpl::<span class="built_in">Recover</span>(VersionEdit* edit)</span><br></pre></td></tr></table></figure>
<p>如果调用成功则设置VersionEdit。Recover的基本功能是：首先是处理创建flag，比如存在就返回失败等等；然后是尝试从已存在的sstable文件恢复db；最后如果发现有大于原信息记录的log编号的log文件，则需要回放log，更新db数据。回放期间db可能会dump新的level 0文件，因此需要把db元信息的变动记录到edit中返回。函数逻辑如下：</p>
<p>S1 创建目录，目录以db name命名，忽略任何创建错误，然后尝试获取<code>db name/LOCK</code>文件锁，失败则返回。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env_-&gt;<span class="built_in">CreateDir</span>(dbname_);</span><br><span class="line">Status s = env_-&gt;<span class="built_in">LockFile</span>(<span class="built_in">LockFileName</span>(dbname_), &amp;db_lock_);</span><br><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) <span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure>
<p>S2 根据CURRENT文件是否存在，以及option参数执行检查。</p>
<ul>
<li>如果文件不存在 &amp; <code>create_is_missing=true</code>，则调用函数NewDB()创建；否则报错。</li>
<li>如果文件存在 &amp; <code>error_if_exists=true</code>，则报错。</li>
</ul>
<p>S3 调用VersionSet的<strong>Recover()</strong>函数，就是从文件中恢复数据。如果出错则打开失败，成功则向下执行S4。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = versions_-&gt;Recover();</span><br></pre></td></tr></table></figure>
<p>S4尝试从所有比manifest文件中记录的log要新的log文件中恢复（前一个版本可能会添加新的log文件，却没有记录在manifest中）。另外，函数<code>PrevLogNumber()</code>已经不再用了，仅为了兼容老版本。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  S4.1 这里先找出所有满足条件的log文件：比manifest文件记录的log编号更新。  </span></span><br><span class="line"><span class="function">SequenceNumber <span class="title">max_sequence</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">uint64_t</span> min_log = versions_-&gt;<span class="built_in">LogNumber</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">uint64_t</span> prev_log = versions_-&gt;<span class="built_in">PrevLogNumber</span>();</span><br><span class="line">std::vector&lt;std::string&gt;filenames;</span><br><span class="line">s = env_-&gt;<span class="built_in">GetChildren</span>(dbname_, &amp;filenames); <span class="comment">// 列出目录内的所有文件  </span></span><br><span class="line"><span class="type">uint64_t</span> number;</span><br><span class="line">FileType type;</span><br><span class="line">std::vector&lt;<span class="type">uint64_t</span>&gt;logs;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; filenames.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 检查log文件是否比min log更新  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ParseFileName</span>(filenames[i], &amp;number, &amp;type) &amp;&amp; type == kLogFile</span><br><span class="line">        &amp;&amp; ((number &gt;= min_log) || (number == prev_log))) &#123;</span><br><span class="line">        logs.<span class="built_in">push_back</span>(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  S4.2 找到log文件后，首先排序，保证按照生成顺序，依次回放log。并把DB元信息的变动（sstable文件的变动）追加到edit中返回。  </span></span><br><span class="line">std::<span class="built_in">sort</span>(logs.<span class="built_in">begin</span>(), logs.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; logs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    s = <span class="built_in">RecoverLogFile</span>(logs[i], edit, &amp;max_sequence);</span><br><span class="line">    <span class="comment">// 前一版可能在生成该log编号后没有记录在MANIFEST中，  </span></span><br><span class="line">    <span class="comment">//所以这里我们手动更新VersionSet中的文件编号计数器  </span></span><br><span class="line">    versions_-&gt;<span class="built_in">MarkFileNumberUsed</span>(logs[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  S4.3 更新VersionSet的sequence  </span></span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (versions_-&gt;<span class="built_in">LastSequence</span>() &lt; max_sequence)</span><br><span class="line">        versions_-&gt;<span class="built_in">SetLastSequence</span>(max_sequence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是Recover的执行流程。</p>
<h2 id="12-5-DBImpl-DeleteObsoleteFiles"><a href="#12-5-DBImpl-DeleteObsoleteFiles" class="headerlink" title="12.5 DBImpl::DeleteObsoleteFiles()"></a>12.5 DBImpl::DeleteObsoleteFiles()</h2><p>这个是垃圾回收函数，如前所述，每次compaction和recovery之后都会有文件被废弃。DeleteObsoleteFiles就是删除这些垃圾文件的，它在每次compaction和recovery完成之后被调用。</p>
<p>其调用点包括：<strong>DBImpl::CompactMemTable,DBImpl::BackgroundCompaction,</strong> 以及DB::Open的<strong>recovery</strong>步骤之后。它会删除所有过期的log文件，没有被任何level引用到、或不是正在执行的compaction的output的sstable文件。该函数没有参数，其代码逻辑也很直观，就是列出db的所有文件，对不同类型的文件分别判断，如果是过期文件，就删除之，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S1 首先，确保不会删除pending文件，将versionset正在使用的所有文件加入到live中。  </span></span><br><span class="line">std::set&lt;<span class="type">uint64_t</span>&gt; live = pending_outputs_;</span><br><span class="line">versions_-&gt;<span class="built_in">AddLiveFiles</span>(&amp;live); <span class="comment">//该函数其后分析  </span></span><br><span class="line">                                <span class="comment">// S2 列举db的所有文件  </span></span><br><span class="line">std::vector&lt;std::string&gt;filenames;</span><br><span class="line">env_-&gt;<span class="built_in">GetChildren</span>(dbname_, &amp;filenames);</span><br><span class="line"><span class="comment">// S3 遍历所有列举的文件，根据文件类型，分别处理；  </span></span><br><span class="line"><span class="type">uint64_t</span> number;</span><br><span class="line">FileType type;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; filenames.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ParseFileName</span>(filenames[i], &amp;number, &amp;type)) &#123;</span><br><span class="line">        <span class="type">bool</span> keep = <span class="literal">true</span>; <span class="comment">//false表明是过期文件  </span></span><br><span class="line">                          <span class="comment">// S3.1 kLogFile，log文件，根据log编号判断是否过期  </span></span><br><span class="line">        keep = ((number &gt;= versions_-&gt;<span class="built_in">LogNumber</span>()) ||</span><br><span class="line">            (number == versions_-&gt;<span class="built_in">PrevLogNumber</span>()));</span><br><span class="line">        <span class="comment">// S3.2 kDescriptorFile，MANIFEST文件，根据versionset记录的编号判断  </span></span><br><span class="line">        keep = (number &gt;= versions_-&gt;<span class="built_in">ManifestFileNumber</span>());</span><br><span class="line">        <span class="comment">// S3.3 kTableFile，sstable文件，只要在live中就不能删除  </span></span><br><span class="line">        <span class="comment">// S3.4 kTempFile，如果是正在写的文件，只要在live中就不能删除  </span></span><br><span class="line">        keep = (live.<span class="built_in">find</span>(number) != live.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// S3.5 kCurrentFile,kDBLockFile, kInfoLogFile，不能删除  </span></span><br><span class="line">        keep = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// S3.6 如果keep为false，表明需要删除文件，如果是table还要从cache中删除  </span></span><br><span class="line">        <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type == kTableFile) table_cache_-&gt;<span class="built_in">Evict</span>(number);</span><br><span class="line">            <span class="built_in">Log</span>(options_.info_log, <span class="string">&quot;Delete type=%d #%lld\n&quot;</span>, type, number);</span><br><span class="line">            env_-&gt;<span class="built_in">DeleteFile</span>(dbname_ + <span class="string">&quot;/&quot;</span> + filenames[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是删除过期文件的逻辑，其中调用到了<strong>VersionSet::AddLiveFiles</strong>函数，保证不会删除active的文件。</p>
<p>函数<code>DbImpl::MaybeScheduleCompaction()</code>放在Compaction一节分析，基本逻辑就是如果需要compaction，就启动后台线程执行compaction操作。</p>
<h2 id="12-6-DBImpl-RecoverLogFile"><a href="#12-6-DBImpl-RecoverLogFile" class="headerlink" title="12.6 DBImpl::RecoverLogFile()"></a>12.6 DBImpl::RecoverLogFile()</h2><p>函数声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StatusRecoverLogFile</span>(<span class="type">uint64_t</span> log_number, VersionEdit* edit,SequenceNumber* max_sequence)</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>@log_number是指定的log文件编号</li>
<li>@edit记录db元信息的变化——sstable文件变动</li>
<li>@max_sequence 返回max{log记录的最大序号, *max_sequence}</li>
</ul>
<p>该函数打开指定的log文件，回放日志。期间可能会执行compaction，生产新的level 0sstable文件，记录文件变动到edit中。它声明了一个局部类LogReporter以打印错误日志，没什么好说的，下面来看代码逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S1 打开log文件返回SequentialFile*file，出错就返回，否则向下执行S2。  </span></span><br><span class="line"><span class="comment">// S2 根据log文件句柄file创建log::Reader，准备读取log。  </span></span><br><span class="line"><span class="function">log::Reader <span class="title">reader</span><span class="params">(file, &amp;reporter, <span class="literal">true</span><span class="comment">/*checksum*/</span>, <span class="number">0</span><span class="comment">/*initial_offset*/</span>)</span></span>;</span><br><span class="line"><span class="comment">// S3 依次读取所有的log记录，并插入到新生成的memtable中。这里使用到了批量更新接口WriteBatch，具体后面再分析。  </span></span><br><span class="line">std::string scratch;</span><br><span class="line">Slice record;</span><br><span class="line">WriteBatch batch;</span><br><span class="line">MemTable* mem = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (reader.<span class="built_in">ReadRecord</span>(&amp;record, &amp;scratch) &amp;&amp; status.<span class="built_in">ok</span>()) &#123; <span class="comment">// 读取全部log  </span></span><br><span class="line">    <span class="keyword">if</span> (record.<span class="built_in">size</span>() &lt; <span class="number">12</span>) &#123; <span class="comment">// log数据错误，不满足最小长度12  </span></span><br><span class="line">        reporter.<span class="built_in">Corruption</span>(record.<span class="built_in">size</span>(), Status::<span class="built_in">Corruption</span>(<span class="string">&quot;log recordtoo small&quot;</span>));</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WriteBatchInternal::<span class="built_in">SetContents</span>(&amp;batch, record); <span class="comment">// log内容设置到WriteBatch中  </span></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="literal">NULL</span>) &#123; <span class="comment">// 创建memtable  </span></span><br><span class="line">        mem = <span class="keyword">new</span> <span class="built_in">MemTable</span>(internal_comparator_);</span><br><span class="line">        mem-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    status = WriteBatchInternal::<span class="built_in">InsertInto</span>(&amp;batch, mem); <span class="comment">// 插入到memtable中  </span></span><br><span class="line">    <span class="built_in">MaybeIgnoreError</span>(&amp;status);</span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) <span class="keyword">break</span>;</span><br><span class="line">    <span class="type">const</span> SequenceNumber last_seq =</span><br><span class="line">        WriteBatchInternal::<span class="built_in">Sequence</span>(&amp;batch) + WriteBatchInternal::<span class="built_in">Count</span>(&amp;batch) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (last_seq &gt; *max_sequence) *max_sequence = last_seq; <span class="comment">// 更新max sequence  </span></span><br><span class="line">                                                           <span class="comment">// 如果mem的内存超过设置值，则执行compaction，如果compaction出，  </span></span><br><span class="line">                                                           <span class="comment">// 立刻返回错误，DB::Open失败  </span></span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;<span class="built_in">ApproximateMemoryUsage</span>() &gt; options_.write_buffer_size) &#123;</span><br><span class="line">        status = <span class="built_in">WriteLevel0Table</span>(mem, edit, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) <span class="keyword">break</span>;</span><br><span class="line">        mem-&gt;<span class="built_in">Unref</span>(); <span class="comment">// 释放当前memtable  </span></span><br><span class="line">        mem = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// S4 扫尾工作，如果mem != NULL，说明还需要dump到新的sstable文件中。  </span></span><br><span class="line"><span class="keyword">if</span> (status.<span class="built_in">ok</span>() &amp;&amp; mem != <span class="literal">NULL</span>) &#123;<span class="comment">// 如果compaction出错，立刻返回错误  </span></span><br><span class="line">    status = <span class="built_in">WriteLevel0Table</span>(mem, edit, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mem != <span class="literal">NULL</span>)mem-&gt;<span class="built_in">Unref</span>();</span><br><span class="line"><span class="keyword">delete</span> file;</span><br><span class="line"><span class="keyword">return</span> status;</span><br></pre></td></tr></table></figure>
<p>把MemTabledump到sstable是函数WriteLevel0Table的工作，其实这是compaction的一部分，准备放在compaction一节来分析。</p>
<h1 id="13-DB的关闭-amp-销毁"><a href="#13-DB的关闭-amp-销毁" class="headerlink" title="13 DB的关闭&amp;销毁"></a>13 DB的关闭&amp;销毁</h1><h2 id="13-1-DB关闭"><a href="#13-1-DB关闭" class="headerlink" title="13.1 DB关闭"></a>13.1 DB关闭</h2><p>外部调用者通过<code>DB::Open()</code>获取一个<code>DB*</code>对象，如果要关闭打开的<code>DB* db</code>对象，则直接<code>delete db</code>即可，这会调用到DBImpl的析构函数。析构依次执行如下的5个逻辑：</p>
<ul>
<li>S1 等待后台compaction任务结束</li>
<li>S2 释放db文件锁，<dbname>/lock文件</li>
<li>S3 删除VersionSet对象，并释放MemTable对象</li>
<li>S4 删除log相关以及TableCache对象</li>
<li>S5 删除options的block_cache以及info_log对象</li>
</ul>
<h2 id="13-2-DB销毁"><a href="#13-2-DB销毁" class="headerlink" title="13.2 DB销毁"></a>13.2 DB销毁</h2><p>函数声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StatusDestroyDB</span>(<span class="type">const</span> std::string&amp; dbname, <span class="type">const</span> Options&amp; options)</span><br></pre></td></tr></table></figure>
<p>该函数会删除掉db的数据内容，要谨慎使用。函数逻辑为：</p>
<ul>
<li>S1 获取dbname目录的文件列表到filenames中，如果为空则直接返回，否则进入S2。</li>
<li>S2 锁文件<code>&lt;dbname&gt;/lock</code>，如果锁成功就执行S3</li>
<li>S3 遍历filenames文件列表，过滤掉lock文件，依次调用DeleteFile删除。</li>
<li>S4 释放lock文件，并删除之，然后删除文件夹。</li>
</ul>
<p>Destory就执行完了，如果删除文件出现错误，记录之，依然继续删除下一个。最后返回错误代码。</p>
<h1 id="14-DB的查询与遍历"><a href="#14-DB的查询与遍历" class="headerlink" title="14 DB的查询与遍历"></a>14 DB的查询与遍历</h1><p>分析完如何打开和关闭db，本章就继续分析如何<strong>从db中根据key查询value</strong>，以及<strong>遍历整个db</strong>。</p>
<h2 id="14-1-Get"><a href="#14-1-Get" class="headerlink" title="14.1 Get()"></a>14.1 Get()</h2><p>函数声明：<strong>StatusGet(const ReadOptions&amp; options, const Slice&amp; key, std::string* value)</strong></p>
<p>从DB中查询key 对应的value，参数@options指定读取操作的选项，典型的如snapshot号，从指定的快照中读取。快照本质上就是一个sequence号，后面将单独在快照一章中分析。下面就来分析下函数逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// S1 锁mutex，防止并发，如果指定option则尝试获取snapshot；然后增加MemTable的引用值。  </span></span><br><span class="line"><span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">SequenceNumber snapshot;</span><br><span class="line"><span class="keyword">if</span> (options.snapshot != <span class="literal">NULL</span>)</span><br><span class="line">snapshot = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;number_;</span><br><span class="line"><span class="keyword">else</span> snapshot = versions_-&gt;<span class="built_in">LastSequence</span>(); <span class="comment">// 取当前版本的最后Sequence  </span></span><br><span class="line">MemTable *mem = mem_, *imm = imm_;</span><br><span class="line">Version* current = versions_-&gt;<span class="built_in">current</span>();</span><br><span class="line">mem-&gt;<span class="built_in">Ref</span>();</span><br><span class="line"><span class="keyword">if</span> (imm != <span class="literal">NULL</span>) imm-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">current-&gt;<span class="built_in">Ref</span>();</span><br><span class="line"><span class="comment">// S2 从sstable文件和MemTable中读取时，释放锁mutex；之后再次锁mutex。  </span></span><br><span class="line"><span class="type">bool</span> have_stat_update = <span class="literal">false</span>;</span><br><span class="line">Version::GetStats stats;</span><br><span class="line">&#123;</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="comment">// 先从memtable中查询，再从immutable memtable中查询  </span></span><br><span class="line">    <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mem-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">NULL</span> &amp;&amp; imm-&gt;<span class="built_in">Get</span>(lkey, value, &amp;s)) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 需要从sstable文件中查询  </span></span><br><span class="line">        s = current-&gt;<span class="built_in">Get</span>(options, lkey, value, &amp;stats);</span><br><span class="line">        have_stat_update = <span class="literal">true</span>; <span class="comment">// 记录之，用于compaction  </span></span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// S3 如果是从sstable文件查询出来的，检查是否需要做compaction。最后把MemTable的引用计数减1。  </span></span><br><span class="line"><span class="keyword">if</span> (have_stat_update &amp;¤t-&gt;<span class="built_in">UpdateStats</span>(stats)) &#123;</span><br><span class="line">    <span class="built_in">MaybeScheduleCompaction</span>();</span><br><span class="line">&#125;</span><br><span class="line">mem-&gt;<span class="built_in">Unref</span>();</span><br><span class="line"><span class="keyword">if</span> (imm != <span class="literal">NULL</span>)imm-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">current-&gt;<span class="built_in">Unref</span>();</span><br></pre></td></tr></table></figure>
<p>查询是比较简单的操作，UpdateStats在前面Version一节已经分析过。</p>
<h2 id="14-2-NewIterator"><a href="#14-2-NewIterator" class="headerlink" title="14.2 NewIterator()"></a>14.2 NewIterator()</h2><p>函数声明：<strong>Iterator*NewIterator(const ReadOptions&amp; options)</strong>。通过该函数生产了一个Iterator<em>对象，调用这就可以基于该对象遍历db内容了。函数很简单，调用两个函数创建了一个二级<em>*Iterator</em></em>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator* <span class="title">DBImpl::NewIterator</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options)</span> </span>&#123;</span><br><span class="line">    SequenceNumber latest_snapshot;</span><br><span class="line">    Iterator* internal_iter = <span class="built_in">NewInternalIterator</span>(options, &amp;latest_snapshot);</span><br><span class="line">    <span class="built_in">returnNewDBIterator</span>(&amp;dbname_, env_, <span class="built_in">user_comparator</span>(), internal_iter,</span><br><span class="line">        (options.snapshot != <span class="literal">NULL</span></span><br><span class="line">            ? <span class="built_in">reinterpret_cast</span>&lt;constSnapshotImpl*&gt;(options.snapshot)-&gt;number_</span><br><span class="line">            : latest_snapshot));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，函数NewDBIterator直接返回了一个<strong>DBIter</strong>指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator* <span class="title">NewDBIterator</span><span class="params">(<span class="type">const</span> std::string* dbname, Env* env,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Comparator*user_key_comparator, Iterator* internal_iter,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> SequenceNumber&amp; sequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">DBIter</span>(dbname, env, user_key_comparator, internal_iter, sequence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数NewInternalIterator有一些处理逻辑，就是收集所有能用到的iterator，生产一个Merging Iterator。这包括MemTable，Immutable MemTable，以及各sstable。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator* <span class="title">DBImpl::NewInternalIterator</span><span class="params">(<span class="type">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="params"><span class="function">    SequenceNumber*latest_snapshot)</span> </span>&#123;</span><br><span class="line">    IterState* cleanup = newIterState;</span><br><span class="line">    mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">    <span class="comment">// 根据last sequence设置lastest snapshot，并收集所有的子iterator  </span></span><br><span class="line">    *latest_snapshot = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">    std::vector&lt;Iterator*&gt;list;</span><br><span class="line">    list.<span class="built_in">push_back</span>(mem_-&gt;<span class="built_in">NewIterator</span>()); <span class="comment">// &gt;memtable  </span></span><br><span class="line">    mem_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    <span class="keyword">if</span> (imm_ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        list.<span class="built_in">push_back</span>(imm_-&gt;<span class="built_in">NewIterator</span>()); <span class="comment">// &gt;immutablememtable  </span></span><br><span class="line">        imm_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    versions_-&gt;<span class="built_in">current</span>()-&gt;<span class="built_in">AddIterators</span>(options, &amp;list); <span class="comment">// &gt;current的所有sstable  </span></span><br><span class="line">    Iterator* internal_iter = <span class="built_in">NewMergingIterator</span>(&amp;internal_comparator_, &amp;list[<span class="number">0</span>], list.<span class="built_in">size</span>());</span><br><span class="line">    versions_-&gt;<span class="built_in">current</span>()-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    <span class="comment">// 注册清理机制  </span></span><br><span class="line">    cleanup-&gt;mu = &amp;mutex_;</span><br><span class="line">    cleanup-&gt;mem = mem_;</span><br><span class="line">    cleanup-&gt;imm = imm_;</span><br><span class="line">    cleanup-&gt;version = versions_-&gt;<span class="built_in">current</span>();</span><br><span class="line">    internal_iter-&gt;<span class="built_in">RegisterCleanup</span>(CleanupIteratorState, cleanup, <span class="literal">NULL</span>);</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="keyword">return</span> internal_iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个清理函数CleanupIteratorState是很简单的，对注册的对象做一下Unref操作即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">CleanupIteratorState</span><span class="params">(<span class="type">void</span>* arg1, <span class="type">void</span>* arg2)</span> </span>&#123;</span><br><span class="line">    IterState* state = <span class="built_in">reinterpret_cast</span>&lt;IterState*&gt;(arg1);</span><br><span class="line">    state-&gt;mu-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">    state-&gt;mem-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">    <span class="keyword">if</span> (state-&gt;imm != <span class="literal">NULL</span>)state-&gt;imm-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">    state-&gt;version-&gt;<span class="built_in">Unref</span>();</span><br><span class="line">    state-&gt;mu-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="keyword">delete</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见对于db的遍历依赖于DBIter和Merging Iterator这两个迭代器，它们都是Iterator接口的实现子类。</p>
<h2 id="14-3-MergingIterator"><a href="#14-3-MergingIterator" class="headerlink" title="14.3 MergingIterator"></a>14.3 MergingIterator</h2><p>MergingIterator是一个合并迭代器，它内部使用了一组自Iterator，保存在其成员数组children_中。如上面的函数NewInternalIterator，包括memtable，immutable memtable，以及各sstable文件；它所做的就是根据调用者指定的key和sequence，从这些Iterator中找到合适的记录。</p>
<p>在分析其Iterator接口之前，先来看看两个辅助函数FindSmallest和FindLargest。FindSmallest<strong>从0开始向后遍历内部Iterator数组</strong>，找到key最小的Iterator，并设置到current_；FindLargest从<strong>最后一个向前遍历内部Iterator数组</strong>，找到key最大的Iterator，并设置到current_；</p>
<p>MergingIterator还定义了两个移动方向：kForward，向前移动；kReverse，向后移动。 </p>
<h3 id="14-3-1-Get系接口"><a href="#14-3-1-Get系接口" class="headerlink" title="14.3.1 Get系接口"></a>14.3.1 Get系接口</h3><p>下面就把其接口拖出来一个一个分析，首先是简单接口，key和value都是返回current_的值，current_是当前seek到的Iterator位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Slice <span class="title">key</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> current_-&gt;<span class="built_in">key</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Slice <span class="title">value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> current_-&gt;<span class="built_in">value</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">status</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    Status status;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123; <span class="comment">// 只有所有内部Iterator都ok时，才返回ok  </span></span><br><span class="line">        status = children_[i].<span class="built_in">status</span>();</span><br><span class="line">        <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-3-2-Seek系接口"><a href="#14-3-2-Seek系接口" class="headerlink" title="14.3.2 Seek系接口"></a>14.3.2 Seek系接口</h3><p>然后是几个seek系的函数，也比较简单，都是依次调用内部Iterator的seek系函数。然后做merge，对于Seek和SeekToFirst都调用FindSmallest；对于SeekToLast调用FindLargest。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_; i++) children_[i].<span class="built_in">SeekToFirst</span>();</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line">    direction_ = kForward;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SeekToLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_; i++) children_[i].<span class="built_in">SeekToLast</span>();</span><br><span class="line">    <span class="built_in">FindLargest</span>();</span><br><span class="line">    direction_ = kReverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Seek</span><span class="params">(constSlice&amp; target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_; i++) children_[i].<span class="built_in">Seek</span>(target);</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line">    direction_ = kForward;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-3-3-逐步移动"><a href="#14-3-3-逐步移动" class="headerlink" title="14.3.3 逐步移动"></a>14.3.3 逐步移动</h3><p>最后就是Next和Prev函数，完成迭代遍历。这可能会有点绕。下面分别来说明。</p>
<p>首先，在Next移动时，如果当前direction不是kForward的，也就是上一次调用了Prev或者SeekToLast函数，就需要先调整除current之外的所有iterator，为什么要做这种调整呢？啰嗦一点，考虑如下的场景，如图14.3-1所示。</p>
<p><img src="/img/leveldb19.webp" alt=""></p>
<p>当前direction为kReverse，并且有：<strong>Current = memtable Iterator</strong>。各Iterator位置为：{memtable, stable 0, sstable1} ={ key3:1:1, key2:3:1, key2:1:1}，这符合prev操作的largest key要求。</p>
<p>注：需要说明下，对于每个update操作，leveldb都会赋予一个全局唯一的sequence号，且是递增的。例子中的sequence号可理解为每个key的相对值，后面也是如此。</p>
<p>接下来我们来分析Prev移动的操作。</p>
<ul>
<li>第一次Prev，current(memtable iterator)移动到key1:3:0上，3者中最大者变成sstable0；因此current修改为sstable0；</li>
<li>第二次Prev，current(sstable0 Iterator)移动到key1:2:1上，3者中最大者变成sstable1；因此current修改为sstable1:</li>
<li>此时各Iterator的位置为{memtable, sstable 0, sstable1} = { key1:3:0, key1:2:1, key2:2:1}，并且current=sstable1。</li>
<li>接下来再调用Next，显然当前Key()为key2:2:1，综合考虑3个iterator，两次Next()的调用结果应该是key2:1:1和key3:1:1。而memtable和sstable0指向的key却是key1:3:0和key1:2:1，这时就需要调整memtable和sstable0了，使他们都定位到Key()之后，也就是key3:1:1和key2:3:1上。</li>
</ul>
<p>然后current(current1)Next移动到key2:1:1上。这就是Next时的调整逻辑，同理，对于Prev也有相同的调整逻辑。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="comment">// 确保所有的子Iterator都定位在key()之后.  </span></span><br><span class="line">    <span class="comment">// 如果我们在正向移动，对于除current_外的所有子Iterator这点已然成立  </span></span><br><span class="line">    <span class="comment">// 因为current_是最小的子Iterator，并且key() = current_-&gt;key()。  </span></span><br><span class="line">    <span class="comment">// 否则，我们需要明确设置其它的子Iterator  </span></span><br><span class="line">    <span class="keyword">if</span> (direction_ != kForward) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123; <span class="comment">// 把所有current之外的Iterator定位到key()之后  </span></span><br><span class="line">            IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">            <span class="keyword">if</span> (child != current_) &#123;</span><br><span class="line">                child-&gt;<span class="built_in">Seek</span>(<span class="built_in">key</span>());</span><br><span class="line">                <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>() &amp;&amp; comparator_-&gt;<span class="built_in">Compare</span>(<span class="built_in">key</span>(), child-&gt;<span class="built_in">key</span>()) == <span class="number">0</span>)</span><br><span class="line">                    child-&gt;<span class="built_in">Next</span>(); <span class="comment">// key等于current_-&gt;key()的，再向后移动一位  </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        direction_ = kForward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// current也向后移一位，然后再查找key最小的Iterator  </span></span><br><span class="line">    current_-&gt;<span class="built_in">Next</span>();</span><br><span class="line">    <span class="built_in">FindSmallest</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Prev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="comment">// 确保所有的子Iterator都定位在key()之前.  </span></span><br><span class="line">    <span class="comment">// 如果我们在逆向移动，对于除current_外的所有子Iterator这点已然成立  </span></span><br><span class="line">    <span class="comment">// 因为current_是最大的，并且key() = current_-&gt;key()  </span></span><br><span class="line">    <span class="comment">// 否则，我们需要明确设置其它的子Iterator  </span></span><br><span class="line">    <span class="keyword">if</span> (direction_ != kReverse) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</span><br><span class="line">            IteratorWrapper* child = &amp;children_[i];</span><br><span class="line">            <span class="keyword">if</span> (child != current_) &#123;</span><br><span class="line">                child-&gt;<span class="built_in">Seek</span>(<span class="built_in">key</span>());</span><br><span class="line">                <span class="keyword">if</span> (child-&gt;<span class="built_in">Valid</span>()) &#123;</span><br><span class="line">                    <span class="comment">// child位于&gt;=key()的第一个entry上，prev移动一位到&lt;key()  </span></span><br><span class="line">                    child-&gt;<span class="built_in">Prev</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// child所有的entry都 &lt; key()，直接seek到last即可  </span></span><br><span class="line">                    child-&gt;<span class="built_in">SeekToLast</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        direction_ = kReverse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//current也向前移一位，然后再查找key最大的Iterator  </span></span><br><span class="line">    current_-&gt;<span class="built_in">Prev</span>();</span><br><span class="line">    <span class="built_in">FindLargest</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是MergingIterator的全部代码逻辑了，每次Next或者Prev移动时，都要重新遍历所有的子Iterator以找到key最小或最大的Iterator作为current_。这就是merge的语义所在了。<br>但是它没有考虑到删除标记等问题，因此直接使用MergingIterator是不能正确的遍历DB的，这些问题留待给DBIter来解决。</p>
<h2 id="14-4-DBIter"><a href="#14-4-DBIter" class="headerlink" title="14.4 DBIter"></a>14.4 DBIter</h2><p>Leveldb数据库的<strong>MemTable</strong>和<strong>sstable</strong>文件的存储格式都是<strong>(user key, seq, type) =&gt; uservalue</strong>。DBIter把同一个userkey在DB中的多条记录合并为一条，综合考虑了userkey的序号、删除标记、和写覆盖等等因素。</p>
<p>从前面函数<strong>NewIterator</strong>的代码还能看到，DBIter内部使用了<strong>MergingIterator</strong>，在调用MergingItertor的系列seek函数后，DBIter还要处理key的删除标记。否则，遍历时会把已删除的key列举出来。</p>
<p>DBIter还定义了两个移动方向，默认是kForward：</p>
<ol>
<li><strong>kForward</strong>，向前移动，代码保证此时DBIter的内部迭代器刚好定位在this-&gt;key(),this-&gt;value()这条记录上；</li>
<li><strong>kReverse</strong>，向后移动，代码保证此时DBIter的内部迭代器刚好定位在所有key=this-&gt;key()的entry之前。</li>
</ol>
<p>其成员变量savedkey和saved value保存的是KReverse方向移动时的k/v对，每次seek系调用之后，其值都会跟随iter_而改变。</p>
<p>DBIter的代码开始读来感觉有些绕，主要就是它要处理删除标记，而且其底层的MergingIterator，对于同一个key会有多个不同sequence的entry。导致其Next/Prev操作比较复杂，要考虑到上一次移动的影响，跳过删除标记和重复的key。</p>
<p>DBIter必须导出Iterator定义的几个接口，下面就拖出来挨个分析。</p>
<h3 id="14-4-1-Get系接口"><a href="#14-4-1-Get系接口" class="headerlink" title="14.4.1 Get系接口"></a>14.4.1 Get系接口</h3><p>首先是几个简单接口，获取key、value和status的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kForward直接取iter_-&gt;value()，否则取saved value</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Slice <span class="title">value</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">assert</span>(valid_);</span><br><span class="line">    <span class="keyword">return</span> (direction_ == kForward) ? iter_-&gt;<span class="built_in">value</span>() : saved_value_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">status</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status_.<span class="built_in">ok</span>()) </span><br><span class="line">        returniter_-&gt;<span class="built_in">status</span>();</span><br><span class="line">    <span class="keyword">return</span> status_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-4-2-辅助函数"><a href="#14-4-2-辅助函数" class="headerlink" title="14.4.2 辅助函数"></a>14.4.2 辅助函数</h3><p>在分析seek系函数之前，先来理解两个重要的辅助函数：<strong>FindNextUserEntry</strong>和<strong>FindPrevUserEntry</strong>的功能和逻辑。其功能就是循环跳过下一个/前一个delete的记录，直到遇到<strong>kValueType</strong>的记录。</p>
<p>先来看看，函数声明为：<strong>void DBIter::FindNextUserEntry(bool skipping, std::string* skip)</strong></p>
<ul>
<li>参数@skipping表明是否要跳过sequence更小的entry；</li>
<li>参数@skip临时存储空间，保存seek时要跳过的key；</li>
</ul>
<p>在进入FindNextUserEntry时，<code>iter_</code>刚好定位在<code>this-&gt;key()</code>, <code>this-&gt;value()</code>这条记录上。下面来看函数实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Slice <span class="title">key</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">//kForward直接取iter_-&gt;key()，否则取saved key  </span></span><br><span class="line">    <span class="built_in">assert</span>(valid_);</span><br><span class="line">    <span class="keyword">return</span> (direction_ == kForward) ? <span class="built_in">ExtractUserKey</span>(iter_-&gt;<span class="built_in">key</span>()) : saved_key_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环直到找到合适的entry，direction必须是kForward  </span></span><br><span class="line"><span class="built_in">assert</span>(iter_-&gt;<span class="built_in">Valid</span>());</span><br><span class="line"><span class="built_in">assert</span>(direction_ == kForward);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ParsedInternalKey ikey;</span><br><span class="line">    <span class="comment">// 确保iter_-&gt;key()的sequence &lt;= 遍历指定的sequence  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ParseKey</span>(&amp;ikey) &amp;&amp; ikey.sequence &lt;= sequence_) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (ikey.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> kTypeDeletion:</span><br><span class="line">            <span class="comment">//对于该key，跳过后面遇到的所有entry，它们被这次删除覆盖了  </span></span><br><span class="line">            <span class="comment">//保存key到skip中，并设置skipping=true  </span></span><br><span class="line">            <span class="built_in">SaveKey</span>(ikey.user_key, skip);</span><br><span class="line">            skipping = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTypeValue:</span><br><span class="line">            <span class="keyword">if</span> (skipping &amp;&amp;</span><br><span class="line">                user_comparator_-&gt;<span class="built_in">Compare</span>(ikey.user_key, *skip) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 这是一个被删除覆盖的entry，或者user key比指定的key小，跳过  </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 找到，清空saved key并返回，iter_已定位到正确的entry  </span></span><br><span class="line">                valid_ = <span class="literal">true</span>;</span><br><span class="line">                saved_key_.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    iter_-&gt;<span class="built_in">Next</span>(); <span class="comment">// 继续检查下一个entry  </span></span><br><span class="line">&#125; <span class="keyword">while</span> (iter_-&gt;<span class="built_in">Valid</span>());</span><br><span class="line"><span class="comment">// 到这里表明已经找到最后了，没有符合的entry  </span></span><br><span class="line">saved_key_.<span class="built_in">clear</span>();</span><br><span class="line">valid_ = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>FindNextUserKey移动方向是<strong>kForward</strong>，DBIter在向kForward移动时，借用了saved key作为临时缓存。FindNextUserKey确保定位到的entry的sequence不会大于指定的sequence，并跳过被删除标记覆盖的旧记录。</p>
<p>接下来是FindPrevUserKey，函数声明为：<strong>void DBIter::FindPrevUserEntry()</strong>，在进入FindPrevUserEntry时，iter_刚好位于saved key对应的所有记录之前。源代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(direction_ == kReverse); <span class="comment">// 确保是kReverse方向  </span></span><br><span class="line">ValueType value_type =kTypeDeletion; <span class="comment">//后面的循环至少执行一次Prev操作  </span></span><br><span class="line"><span class="keyword">if</span> (iter_-&gt;<span class="built_in">Valid</span>()) &#123;  </span><br><span class="line">    <span class="keyword">do</span> &#123; <span class="comment">// 循环  </span></span><br><span class="line">        <span class="comment">// 确保iter_-&gt;key()的sequence &lt;= 遍历指定的sequence  </span></span><br><span class="line">        ParsedInternalKey ikey;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ParseKey</span>(&amp;ikey)&amp;&amp; ikey.sequence &lt;= sequence_) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((value_type !=kTypeDeletion) &amp;&amp;  </span><br><span class="line">                user_comparator_-&gt;<span class="built_in">Compare</span>(ikey.user_key, saved_key_) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 我们遇到了前一个key的一个未被删除的entry，跳出循环  </span></span><br><span class="line">             <span class="comment">// 此时Key()将返回saved_key，saved key非空；  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//根据类型，如果是Deletion则清空saved key和saved value  </span></span><br><span class="line">        <span class="comment">//否则，把iter_的user key和value赋给saved key和saved value  </span></span><br><span class="line">        value_type = ikey.type;  </span><br><span class="line">        <span class="keyword">if</span> (value_type ==kTypeDeletion) &#123;  </span><br><span class="line">            saved_key_.<span class="built_in">clear</span>();  </span><br><span class="line">            <span class="built_in">ClearSavedValue</span>();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            Slice raw_value =iter_-&gt;<span class="built_in">value</span>();  </span><br><span class="line">            <span class="keyword">if</span>(saved_value_.<span class="built_in">capacity</span>() &gt; raw_value.<span class="built_in">size</span>() + <span class="number">1048576</span>) &#123;  </span><br><span class="line">                std::string empty;  </span><br><span class="line">                <span class="built_in">swap</span>(empty,saved_value_);  </span><br><span class="line">            &#125;  </span><br><span class="line">         <span class="built_in">SaveKey</span>(<span class="built_in">ExtractUserKey</span>(iter_-&gt;<span class="built_in">key</span>()), &amp;saved_key_);  </span><br><span class="line">         saved_value_.<span class="built_in">assign</span>(raw_value.<span class="built_in">data</span>(), raw_value.<span class="built_in">size</span>());  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">      iter_-&gt;<span class="built_in">Prev</span>(); <span class="comment">// 前一个  </span></span><br><span class="line">    &#125; <span class="keyword">while</span> (iter_-&gt;<span class="built_in">Valid</span>());  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">if</span> (value_type == kTypeDeletion)&#123; <span class="comment">// 表明遍历结束了，将direction设置为kForward  </span></span><br><span class="line">      valid_ = <span class="literal">false</span>;  </span><br><span class="line">      saved_key_.<span class="built_in">clear</span>();  </span><br><span class="line">      <span class="built_in">ClearSavedValue</span>();  </span><br><span class="line">      direction_ = kForward;  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">  valid_ = <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>函数FindPrevUserKey根据指定的<strong>sequence</strong>，依次检查前一个entry，直到遇到user key小于saved key，并且类型不是Delete的entry。如果entry的类型是Delete，就清空saved key和saved value，这样在依次遍历前一个entry的循环中，只要类型不是Delete，就是要找的entry。这就是Prev的语义。</p>
<h3 id="14-4-3-Seek系函数"><a href="#14-4-3-Seek系函数" class="headerlink" title="14.4.3 Seek系函数"></a>14.4.3 Seek系函数</h3><p>了解了这两个重要的辅助函数，可以分析几个Seek接口了，它们需要借助于上面的这两个函数来跳过被delete的记录。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBIter::Seek</span><span class="params">(<span class="type">const</span> Slice&amp; target)</span> </span>&#123;  </span><br><span class="line">    direction_ = kForward; <span class="comment">// 向前seek  </span></span><br><span class="line">    <span class="comment">// 清空saved value和saved key，并根据target设置saved key  </span></span><br><span class="line">    <span class="built_in">ClearSavedValue</span>();  </span><br><span class="line">    saved_key_.<span class="built_in">clear</span>();  </span><br><span class="line">    <span class="built_in">AppendInternalKey</span>( <span class="comment">// kValueTypeForSeek(1) &gt; kDeleteType(0)  </span></span><br><span class="line">        &amp;saved_key_,<span class="built_in">ParsedInternalKey</span>(target, sequence_, kValueTypeForSeek));  </span><br><span class="line">    iter_-&gt;<span class="built_in">Seek</span>(saved_key_); <span class="comment">// iter seek到saved key  </span></span><br><span class="line">    <span class="comment">//可以定位到合法的iter，还需要跳过Delete的entry  </span></span><br><span class="line">    <span class="keyword">if</span> (iter_-&gt;<span class="built_in">Valid</span>()) <span class="built_in">FindNextUserEntry</span>(<span class="literal">false</span>,&amp;saved_key_);  </span><br><span class="line">    <span class="keyword">else</span> valid_ = <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBIter::SeekToFirst</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    direction_ = kForward; <span class="comment">// 向前seek  </span></span><br><span class="line">    <span class="comment">// 清空saved value，首先iter_-&gt;SeekToFirst，然后跳过Delete的entry  </span></span><br><span class="line">    <span class="built_in">ClearSavedValue</span>();  </span><br><span class="line">    iter_-&gt;<span class="built_in">SeekToFirst</span>();  </span><br><span class="line">    <span class="keyword">if</span> (iter_-&gt;<span class="built_in">Valid</span>()) <span class="built_in">FindNextUserEntry</span>(<span class="literal">false</span>,&amp;saved_key_ <span class="comment">/*临时存储*/</span>);  </span><br><span class="line">    <span class="keyword">else</span> valid_ = <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBIter::SeekToLast</span><span class="params">()</span> </span>&#123; <span class="comment">// 更简单  </span></span><br><span class="line">    direction_ = kReverse;  </span><br><span class="line">    <span class="built_in">ClearSavedValue</span>();  </span><br><span class="line">    iter_-&gt;<span class="built_in">SeekToLast</span>();  </span><br><span class="line">    <span class="built_in">FindPrevUserEntry</span>();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="14-4-4-Prev-和Next"><a href="#14-4-4-Prev-和Next" class="headerlink" title="14.4.4 Prev()和Next()"></a>14.4.4 Prev()和Next()</h3><p>Next和Prev接口，相对复杂一些。和底层的merging iterator不同，DBIter的Prev和Next步进是<strong>以key为单位的</strong>，而mergingiterator是以一个record为单位的。所以在调用merging Iterator做Prev和Next迭代时，必须循环直到key发生改变。</p>
<p>假设指定读取的sequence为2，当前iter在key4:2:1上，direction为kForward。此时调用Prev()，此图显示了Prev操作执行的5个步骤：</p>
<p><img src="/img/leveldb20.webp" alt=""></p>
<ul>
<li>S1 首先因为direction为kForward，先调整iter到key3:1:1上。此图也说明了调整的理由，key4:2:1前面还有key4:3:1。然后进入FindPrevUserEntry函数，执行S2到S4。</li>
<li>S2 跳到key3:2:0上时，这是一个删除标记，清空saved key（其中保存的是key3:1:1）。</li>
<li>S3 循环继续，跳到key2:1:1上，此时key2:1:1 &gt; saved key，设置saved key为key2:1:1，并继续循环。</li>
<li>S4 循环继续，跳到key2:2:1上，此时key2:2:1 &gt; saved key，设置saved key为key2:2:1，并继续循环。</li>
<li>S5 跳到Key1:1:1上，因为key1:1:1 &lt; saved key，跳出循环。</li>
</ul>
<p>最终状态iter_位置在key1:1:1上，而saved key保存的则是key2:2:1上，这也就是Prev应该定位到的值。也就是说在Prev操作下，iter_的位置并不是真正的key位置。这就是前面Get系函数中，在direction为kReverse时，返回saved key/value的原因。</p>
<p>同理，在Next时，如果direction是kReverse，根据上面的Prev可以发现，此时iter刚好是saved key的前一个entry。执行<strong>iter-&gt;Next()</strong>就跳到了saved key的dentry范围的sequence最大的那个entry。在前面的例子中，在Prev后执行Next，那么iter首先跳转到key2:3:1上，然后再调用FindNextUserEntry循环，使iter定位在key2:2:1上。</p>
<p>下面首先来分析Next的实现。如果direction是kReverse，表明上一次做的是kReverse跳转，这种情况下，iter_位于key是this-&gt;key()的所有entry之前，我们需要先把iter_跳转到this-&gt;key()对应的entries范围内。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBIter::Next</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">assert</span>(valid_);  </span><br><span class="line">    <span class="keyword">if</span> (direction_ == kReverse) &#123; <span class="comment">//需要预处理，并更改direction=kForward  </span></span><br><span class="line">      direction_ = kForward;  </span><br><span class="line">      <span class="comment">// iter_刚好在this-&gt;key()的所有entry之前，所以先跳转到this-&gt;key()  </span></span><br><span class="line">      <span class="comment">// 的entries范围之内，然后再做常规的skip  </span></span><br><span class="line">        <span class="keyword">if</span> (!iter_-&gt;<span class="built_in">Valid</span>()) iter_-&gt;<span class="built_in">SeekToFirst</span>();  </span><br><span class="line">        <span class="keyword">else</span> iter_-&gt;<span class="built_in">Next</span>();  </span><br><span class="line">        <span class="keyword">if</span> (!iter_-&gt;<span class="built_in">Valid</span>()) &#123;  </span><br><span class="line">          valid_ = <span class="literal">false</span>;  </span><br><span class="line">          saved_key_.<span class="built_in">clear</span>();  </span><br><span class="line">          <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 把saved_key_ 用作skip的临时存储空间  </span></span><br><span class="line">      std::string* skip =&amp;saved_key_;  </span><br><span class="line">      <span class="built_in">SaveKey</span>(<span class="built_in">ExtractUserKey</span>(iter_-&gt;<span class="built_in">key</span>()), skip);<span class="comment">// 设置skip为iter_-&gt;key()的user key  </span></span><br><span class="line">      <span class="built_in">FindNextUserEntry</span>(<span class="literal">true</span>, skip);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>接下来是Prev()，其实和Next()逻辑相似，但方向相反。</p>
<p>如果direction是kForward，表明上一次是做的是kForward跳转，这种情况下，iter_指向当前的entry，我们需要调整iter，使其指向到前一个key，iter的位置是这个key所有record序列的最后一个，也就是sequence最小的那个record。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBIter::Prev</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">assert</span>(valid_);  </span><br><span class="line">    <span class="keyword">if</span> (direction_ == kForward) &#123; <span class="comment">//需要预处理，并更改direction  </span></span><br><span class="line">      <span class="comment">// iter_指向当前的entry，向后扫描直到key发生改变，然后我们可以做  </span></span><br><span class="line">      <span class="comment">//常规的reverse扫描  </span></span><br><span class="line">        <span class="built_in">assert</span>(iter_-&gt;<span class="built_in">Valid</span>());  <span class="comment">// iter_必须合法，并把saved key设置为iter_-&gt;key()  </span></span><br><span class="line">        <span class="built_in">SaveKey</span>(<span class="built_in">ExtractUserKey</span>(iter_-&gt;<span class="built_in">key</span>()), &amp;saved_key_);  </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">            iter_-&gt;<span class="built_in">Prev</span>();  </span><br><span class="line">        <span class="keyword">if</span> (!iter_-&gt;<span class="built_in">Valid</span>()) &#123; <span class="comment">// 到头了，直接返回  </span></span><br><span class="line">            valid_ = <span class="literal">false</span>;  </span><br><span class="line">            saved_key_.<span class="built_in">clear</span>();  </span><br><span class="line">            <span class="built_in">ClearSavedValue</span>();  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">if</span> (user_comparator_-&gt;<span class="built_in">Compare</span>(<span class="built_in">ExtractUserKey</span>(iter_-&gt;<span class="built_in">key</span>()),  </span><br><span class="line">                                   saved_key_) &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// key变化就跳出循环，此时iter_刚好位于saved key对应的所有entry之前  </span></span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;     </span><br><span class="line">        direction_ = kReverse;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="built_in">FindPrevUserEntry</span>();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="14-5-小结"><a href="#14-5-小结" class="headerlink" title="14.5 小结"></a>14.5 小结</h2><p>查询操作并不复杂，只需要根据seq找到最新的记录即可。知道leveldb的遍历会比较复杂，不过也没想到会这么复杂。这主要是得益于sstable 0的重合性，以及memtable和sstable文件的重合性。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/28/cpp%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E5%8D%97/" rel="prev" title="C++性能优化指南">
      <i class="fa fa-chevron-left"></i> C++性能优化指南
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/06/cpp17guide/" rel="next" title="C++ 17 指南">
      C++ 17 指南 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B"><span class="nav-number">1.</span> <span class="nav-text">开始</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%B8%80%E4%BA%9B%E7%BA%A6%E5%AE%9A"><span class="nav-number">2.</span> <span class="nav-text">1. 一些约定</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 字节序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-VarInt"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 VarInt</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%AD%97%E7%AC%A6%E6%AF%94%E8%BE%83"><span class="nav-number">2.3.</span> <span class="nav-text">1.3 字符比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">2. 基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Slice"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 Slice</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Status"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 Status</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-Arena"><span class="nav-number">3.3.</span> <span class="nav-text">2.3 Arena</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-Skip-list"><span class="nav-number">3.4.</span> <span class="nav-text">2.4 Skip list</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-Cache"><span class="nav-number">3.5.</span> <span class="nav-text">2.5 Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Leveldb%E5%AE%9E%E7%8E%B0LRUCache%E7%9A%84%E5%87%A0%E4%B8%AA%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.5.1.</span> <span class="nav-text">Leveldb实现LRUCache的几个步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#S1"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S2"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">S2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S3"><span class="nav-number">3.5.1.3.</span> <span class="nav-text">S3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S4"><span class="nav-number">3.5.1.4.</span> <span class="nav-text">S4</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-%E5%85%B6%E5%AE%83"><span class="nav-number">3.6.</span> <span class="nav-text">2.6 其它</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Int-Coding"><span class="nav-number">4.</span> <span class="nav-text">3.Int Coding</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Eecode"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 Eecode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-Decode"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 Decode</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Memtable%E4%B9%8B%E4%B8%80"><span class="nav-number">5.</span> <span class="nav-text">4. Memtable之一</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E7%94%A8%E9%80%94"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E6%A0%B8%E5%BF%83%E6%98%AFSkip-list"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 核心是Skip list</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E"><span class="nav-number">5.3.</span> <span class="nav-text">4.3 接口说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E7%B1%BB%E5%9B%BE"><span class="nav-number">5.4.</span> <span class="nav-text">4.4 类图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-Key%E7%BB%93%E6%9E%84"><span class="nav-number">5.5.</span> <span class="nav-text">4.5 Key结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-InternalKey-amp-ParsedInternalKey-amp-User-Key"><span class="nav-number">5.5.1.</span> <span class="nav-text">4.5.1 InternalKey &amp; ParsedInternalKey &amp; User Key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-LookupKey-amp-Memtable-Key"><span class="nav-number">5.5.2.</span> <span class="nav-text">4.5.2 LookupKey &amp; Memtable Key</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Memtable%E4%B9%8B2"><span class="nav-number">6.</span> <span class="nav-text">4.Memtable之2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-Comparator"><span class="nav-number">6.1.</span> <span class="nav-text">4.6 Comparator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-1-BytewiseComparatorImpl"><span class="nav-number">6.1.1.</span> <span class="nav-text">4.6.1 BytewiseComparatorImpl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-2-InternalKeyComparator"><span class="nav-number">6.1.2.</span> <span class="nav-text">4.6.2 InternalKeyComparator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-Memtable-Insert"><span class="nav-number">6.2.</span> <span class="nav-text">4.7 Memtable::Insert()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-8-Memtable-Get"><span class="nav-number">6.3.</span> <span class="nav-text">4.8 Memtable::Get()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-9-%E5%B0%8F%E7%BB%93"><span class="nav-number">6.4.</span> <span class="nav-text">4.9 小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E6%93%8D%E4%BD%9CLog-1"><span class="nav-number">7.</span> <span class="nav-text">5.操作Log 1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E6%A0%BC%E5%BC%8F"><span class="nav-number">7.1.</span> <span class="nav-text">5.1 格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E5%86%99%E6%97%A5%E5%BF%97"><span class="nav-number">7.2.</span> <span class="nav-text">5.2 写日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E8%AF%BB%E6%97%A5%E5%BF%97"><span class="nav-number">7.3.</span> <span class="nav-text">5.3 读日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-%E7%B1%BB%E5%B1%82%E6%AC%A1"><span class="nav-number">7.3.1.</span> <span class="nav-text">5.3.1 类层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2%E6%97%A5%E5%BF%97%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B"><span class="nav-number">7.3.2.</span> <span class="nav-text">5.3.2日志读取流程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#S1-1"><span class="nav-number">7.3.2.0.0.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link"><span class="nav-number">7.3.2.0.0.2.</span> <span class="nav-text"> </span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#S3-1"><span class="nav-number">7.3.2.0.0.3.</span> <span class="nav-text">S3</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3-%E4%BB%8Elog%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96record"><span class="nav-number">7.3.3.</span> <span class="nav-text">5.3.3 从log文件读取record</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#S1-2"><span class="nav-number">7.3.3.1.</span> <span class="nav-text">S1</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#S2-%E8%BF%9B%E5%85%A5%E5%88%B0%E8%BF%99%E9%87%8C%E8%A1%A8%E6%98%8E%E4%B8%8A%E6%AC%A1%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84Read%E8%AF%BB%E5%8F%96%E5%88%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84log-record%EF%BC%8Ccontinue%E5%90%8E%E7%9A%84%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%BE%AA%E7%8E%AF%E5%88%A4%E6%96%ADbuffer-size-gt-kHeaderSize%E5%B0%86%E6%89%A7%E8%A1%8C%E5%88%B0%E6%AD%A4%E5%A4%84%E3%80%82"><span class="nav-number">7.3.3.1.1.</span> <span class="nav-text">S2 进入到这里表明上次循环中的Read读取到了一个完整的log record，continue后的第二次循环判断buffer_.size() &gt;&#x3D; kHeaderSize将执行到此处。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S3-%E6%A0%A1%E9%AA%8CCRC32%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%A0%A1%E9%AA%8C%E5%87%BA%E9%94%99%EF%BC%8C%E5%88%99%E6%B1%87%E6%8A%A5%E9%94%99%E8%AF%AF%EF%BC%8C%E5%B9%B6%E8%BF%94%E5%9B%9EkBadRecord%E3%80%82"><span class="nav-number">7.3.3.1.2.</span> <span class="nav-text">S3 校验CRC32，如果校验出错，则汇报错误，并返回kBadRecord。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S4-%E5%A6%82%E6%9E%9Crecord%E7%9A%84%E5%BC%80%E5%A7%8B%E4%BD%8D%E7%BD%AE%E5%9C%A8initial-offset%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%88%99%E8%B7%B3%E8%BF%87%EF%BC%8C%E5%B9%B6%E8%BF%94%E5%9B%9EkBadRecord%EF%BC%8C%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9Erecord%E6%95%B0%E6%8D%AE%E5%92%8Ctype%E3%80%82"><span class="nav-number">7.3.3.1.3.</span> <span class="nav-text">S4 如果record的开始位置在initial offset之前，则跳过，并返回kBadRecord，否则返回record数据和type。</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-SSTable%E4%B9%8B%E4%B8%80"><span class="nav-number">8.</span> <span class="nav-text">6. SSTable之一</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-SSTable%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87"><span class="nav-number">8.1.</span> <span class="nav-text">6.1 SSTable的文件组织</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-Block%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">8.2.</span> <span class="nav-text">6.2 Block存储格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-Block%E7%9A%84%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8"><span class="nav-number">8.2.1.</span> <span class="nav-text">6.2.1 Block的逻辑存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-%E9%87%8D%E5%90%AF%E7%82%B9-restartpoint"><span class="nav-number">8.2.2.</span> <span class="nav-text">6.2.2 重启点-restartpoint</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-Block%E7%9A%84%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%AF%BB%E5%8F%96"><span class="nav-number">8.3.</span> <span class="nav-text">6.3 Block的构建与读取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-BlockBuilder%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.3.1.</span> <span class="nav-text">6.3.1 BlockBuilder的接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-BlockBuilder-Add"><span class="nav-number">8.3.2.</span> <span class="nav-text">6.3.2 BlockBuilder::Add()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#S1-3"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S2-1"><span class="nav-number">8.3.2.2.</span> <span class="nav-text">S2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#S3-2"><span class="nav-number">8.3.2.2.1.</span> <span class="nav-text">S3</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-3-BlockBuilder-Finish"><span class="nav-number">8.3.3.</span> <span class="nav-text">6.3.3 BlockBuilder::Finish()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-4-BlockBuilder-Reset-amp-%E5%A4%A7%E5%B0%8F"><span class="nav-number">8.3.4.</span> <span class="nav-text">6.3.4 BlockBuilder::Reset() &amp; 大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-5-Block%E7%B1%BB%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.3.5.</span> <span class="nav-text">6.3.5 Block类接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-6-Block%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.3.6.</span> <span class="nav-text">6.3.6 Block初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-7-Block-Iter"><span class="nav-number">8.3.7.</span> <span class="nav-text">6.3.7 Block::Iter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#S1-4"><span class="nav-number">8.3.7.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S2-2"><span class="nav-number">8.3.7.2.</span> <span class="nav-text">S2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S1-5"><span class="nav-number">8.3.7.3.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S2-3"><span class="nav-number">8.3.7.4.</span> <span class="nav-text">S2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#S1-6"><span class="nav-number">8.3.7.4.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S2-4"><span class="nav-number">8.3.7.4.2.</span> <span class="nav-text">S2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S3-3"><span class="nav-number">8.3.7.4.3.</span> <span class="nav-text">S3</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E5%88%9B%E5%BB%BAsstable%E6%96%87%E4%BB%B6"><span class="nav-number">8.4.</span> <span class="nav-text">6.4 创建sstable文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-TableBuilder%E7%B1%BB"><span class="nav-number">8.4.0.1.</span> <span class="nav-text">6.4.1 TableBuilder类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2-%E6%B7%BB%E5%8A%A0k-v%E5%AF%B9"><span class="nav-number">8.4.1.</span> <span class="nav-text">6.4.2 添加k&#x2F;v对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-3-Flush%E6%96%87%E4%BB%B6"><span class="nav-number">8.4.2.</span> <span class="nav-text">6.4.3 Flush文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-4-WriteBlock%E5%87%BD%E6%95%B0"><span class="nav-number">8.4.3.</span> <span class="nav-text">6.4.4 WriteBlock函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-5-WriteRawBlock%E5%87%BD%E6%95%B0"><span class="nav-number">8.4.4.</span> <span class="nav-text">6.4.5 WriteRawBlock函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-6-Finish%E5%87%BD%E6%95%B0"><span class="nav-number">8.4.5.</span> <span class="nav-text">6.4.6 Finish函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-%E8%AF%BB%E5%8F%96sstable%E6%96%87%E4%BB%B6"><span class="nav-number">8.5.</span> <span class="nav-text">6.5 读取sstable文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-1-%E7%B1%BB%E5%B1%82%E6%AC%A1"><span class="nav-number">8.5.1.</span> <span class="nav-text">6.5.1 类层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-2-Table-Open"><span class="nav-number">8.5.2.</span> <span class="nav-text">6.5.2 Table::Open()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#S1-7"><span class="nav-number">8.5.2.0.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S2-5"><span class="nav-number">8.5.2.0.2.</span> <span class="nav-text">S2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S3-4"><span class="nav-number">8.5.2.0.3.</span> <span class="nav-text">S3</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-3-ReadBlock"><span class="nav-number">8.5.3.</span> <span class="nav-text">6.5.3 ReadBlock()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#S1-8"><span class="nav-number">8.5.3.0.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S2-6"><span class="nav-number">8.5.3.0.2.</span> <span class="nav-text">S2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S3-5"><span class="nav-number">8.5.3.0.3.</span> <span class="nav-text">S3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S4-1"><span class="nav-number">8.5.3.0.4.</span> <span class="nav-text">S4</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-4-Table-ReadMeta"><span class="nav-number">8.5.4.</span> <span class="nav-text">6.5.4 Table::ReadMeta()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#S1-9"><span class="nav-number">8.5.4.0.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S2-7"><span class="nav-number">8.5.4.0.2.</span> <span class="nav-text">S2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-5-Table-ReadFilter"><span class="nav-number">8.5.5.</span> <span class="nav-text">6.5.5 Table::ReadFilter()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#S1-10"><span class="nav-number">8.5.5.0.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S2-8"><span class="nav-number">8.5.5.0.2.</span> <span class="nav-text">S2</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-%E9%81%8D%E5%8E%86Table"><span class="nav-number">8.6.</span> <span class="nav-text">6.6 遍历Table</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-%E9%81%8D%E5%8E%86%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.6.1.</span> <span class="nav-text">6.6.1 遍历接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-TwoLevelIterator"><span class="nav-number">8.6.2.</span> <span class="nav-text">6.6.2 TwoLevelIterator</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#S1-11"><span class="nav-number">8.6.2.0.1.</span> <span class="nav-text">S1</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#S2-1"><span class="nav-number">8.6.2.0.1.1.</span> <span class="nav-text">S2.1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#S2-2"><span class="nav-number">8.6.2.0.1.2.</span> <span class="nav-text">S2.2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#S2-3"><span class="nav-number">8.6.2.0.1.3.</span> <span class="nav-text">S2.3</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S3-6"><span class="nav-number">8.6.2.0.2.</span> <span class="nav-text">S3</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-3-BlockReader"><span class="nav-number">8.6.3.</span> <span class="nav-text">6.6.3 BlockReader()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#S1-12"><span class="nav-number">8.6.3.0.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S2-9"><span class="nav-number">8.6.3.0.2.</span> <span class="nav-text">S2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S3-7"><span class="nav-number">8.6.3.0.3.</span> <span class="nav-text">S3</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7-%E5%AE%9A%E4%BD%8Dkey"><span class="nav-number">8.7.</span> <span class="nav-text">6.7 定位key</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#S1-13"><span class="nav-number">8.7.0.0.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S2-10"><span class="nav-number">8.7.0.0.2.</span> <span class="nav-text">S2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S3-8"><span class="nav-number">8.7.0.0.3.</span> <span class="nav-text">S3</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-8-%E8%8E%B7%E5%8F%96Key%E2%80%94InternalGet"><span class="nav-number">8.8.</span> <span class="nav-text">6.8 获取Key—InternalGet()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#S1-14"><span class="nav-number">8.8.0.0.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S2-11"><span class="nav-number">8.8.0.0.2.</span> <span class="nav-text">S2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S3-9"><span class="nav-number">8.8.0.0.3.</span> <span class="nav-text">S3</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-TableCache"><span class="nav-number">9.</span> <span class="nav-text">7.TableCache</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-TableCache%E7%AE%80%E4%BB%8B"><span class="nav-number">9.1.</span> <span class="nav-text">7.1 TableCache简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-TableCache-Get"><span class="nav-number">9.2.</span> <span class="nav-text">7.2 TableCache::Get()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-TableCache%E9%81%8D%E5%8E%86"><span class="nav-number">9.3.</span> <span class="nav-text">7.3 TableCache遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#S1-15"><span class="nav-number">9.3.0.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S2-12"><span class="nav-number">9.3.0.2.</span> <span class="nav-text">S2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-TableCache-FindTable"><span class="nav-number">9.4.</span> <span class="nav-text">7.4 TableCache::FindTable()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#S1-16"><span class="nav-number">9.4.0.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S2-13"><span class="nav-number">9.4.0.2.</span> <span class="nav-text">S2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S3-10"><span class="nav-number">9.4.0.3.</span> <span class="nav-text">S3</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="nav-number">9.5.</span> <span class="nav-text">7.5 辅助函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-FilterPolicy-amp-Bloom%E4%B9%8B1"><span class="nav-number">10.</span> <span class="nav-text">8.FilterPolicy&amp;Bloom之1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-FilterPolicy"><span class="nav-number">10.1.</span> <span class="nav-text">8.1 FilterPolicy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2InternalFilterPolicy"><span class="nav-number">10.2.</span> <span class="nav-text">8.2InternalFilterPolicy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-BloomFilter"><span class="nav-number">10.3.</span> <span class="nav-text">8.3 BloomFilter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-1-%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA"><span class="nav-number">10.3.1.</span> <span class="nav-text">8.3.1 基本理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-2-BloomFilter%E5%8F%82%E6%95%B0"><span class="nav-number">10.3.2.</span> <span class="nav-text">8.3.2 BloomFilter参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-3-%E5%BB%BA%E7%AB%8BBloomFilter"><span class="nav-number">10.3.3.</span> <span class="nav-text">8.3.3 建立BloomFilter</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#S1-17"><span class="nav-number">10.3.3.0.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S2-14"><span class="nav-number">10.3.3.0.2.</span> <span class="nav-text">S2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S3-11"><span class="nav-number">10.3.3.0.3.</span> <span class="nav-text">S3</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-4-%E6%9F%A5%E6%89%BEBloomFilter"><span class="nav-number">10.3.4.</span> <span class="nav-text">8.3.4 查找BloomFilter</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#S1-18"><span class="nav-number">10.3.4.0.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S2-15"><span class="nav-number">10.3.4.0.2.</span> <span class="nav-text">S2</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-Filter-Block%E6%A0%BC%E5%BC%8F"><span class="nav-number">10.4.</span> <span class="nav-text">8.4 Filter Block格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-%E6%9E%84%E5%BB%BAFilterBlock"><span class="nav-number">10.5.</span> <span class="nav-text">8.5 构建FilterBlock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-1-FilterBlockBuilder"><span class="nav-number">10.5.1.</span> <span class="nav-text">8.5.1 FilterBlockBuilder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-2-FilterBlockBuilder-StartBlock"><span class="nav-number">10.5.2.</span> <span class="nav-text">8.5.2 FilterBlockBuilder::StartBlock()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-3-FilterBlockBuilder-AddKey"><span class="nav-number">10.5.3.</span> <span class="nav-text">8.5.3 FilterBlockBuilder::AddKey()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-4-FilterBlockBuilder-Finish"><span class="nav-number">10.5.4.</span> <span class="nav-text">8.5.4 FilterBlockBuilder::Finish()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-5-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">10.5.5.</span> <span class="nav-text">8.5.5 简单示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-%E8%AF%BB%E5%8F%96FilterBlock"><span class="nav-number">10.6.</span> <span class="nav-text">8.6 读取FilterBlock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-1-FilterBlockReader"><span class="nav-number">10.6.1.</span> <span class="nav-text">8.6.1 FilterBlockReader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-2-%E6%9E%84%E9%80%A0"><span class="nav-number">10.6.2.</span> <span class="nav-text">8.6.2 构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-3-%E6%9F%A5%E6%89%BE"><span class="nav-number">10.6.3.</span> <span class="nav-text">8.6.3 查找</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-LevelDB%E6%A1%86%E6%9E%B6%E4%B9%8B1"><span class="nav-number">11.</span> <span class="nav-text">9 LevelDB框架之1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-DB%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="nav-number">11.1.</span> <span class="nav-text">9.1 DB文件管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-1-%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">11.1.1.</span> <span class="nav-text">9.1.1 文件类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-2-Level-0"><span class="nav-number">11.1.2.</span> <span class="nav-text">9.1.2 Level 0</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-Compaction"><span class="nav-number">11.2.</span> <span class="nav-text">9.2 Compaction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-1-%E6%97%B6%E9%97%B4"><span class="nav-number">11.2.1.</span> <span class="nav-text">9.2.1 时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-2-%E6%96%87%E4%BB%B6%E6%95%B0"><span class="nav-number">11.2.2.</span> <span class="nav-text">9.2.2 文件数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-Recovery-amp-GC"><span class="nav-number">11.3.</span> <span class="nav-text">9.3 Recovery &amp; GC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-1-Recovery"><span class="nav-number">11.3.1.</span> <span class="nav-text">9.3.1 Recovery</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-2-GC"><span class="nav-number">11.3.2.</span> <span class="nav-text">9.3.2 GC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"><span class="nav-number">11.4.</span> <span class="nav-text">9.4 版本控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-1-VersionSet"><span class="nav-number">11.4.1.</span> <span class="nav-text">9.4.1 VersionSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-2-VersionEdit"><span class="nav-number">11.4.2.</span> <span class="nav-text">9.4.2 VersionEdit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4-3-Manifest%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-number">11.4.3.</span> <span class="nav-text">9.4.3 Manifest文件格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-DB%E6%8E%A5%E5%8F%A3"><span class="nav-number">11.5.</span> <span class="nav-text">9.5 DB接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-5-1-%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">11.5.1.</span> <span class="nav-text">9.5.1 接口函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-5-2-%E7%B1%BB%E5%9B%BE"><span class="nav-number">11.5.2.</span> <span class="nav-text">9.5.2 类图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-6-DBImpl%E7%B1%BB"><span class="nav-number">11.6.</span> <span class="nav-text">9.6 DBImpl类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-Version%E5%88%86%E6%9E%90%E4%B9%8B%E4%B8%80"><span class="nav-number">12.</span> <span class="nav-text">10.Version分析之一</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-Version%E6%8E%A5%E5%8F%A3"><span class="nav-number">12.1.</span> <span class="nav-text">10.1 Version接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-Version-AddIterators"><span class="nav-number">12.2.</span> <span class="nav-text">10.2 Version::AddIterators()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#S1-19"><span class="nav-number">12.2.0.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S2-16"><span class="nav-number">12.2.0.2.</span> <span class="nav-text">S2</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-Version-LevelFileNumIterator%E7%B1%BB"><span class="nav-number">12.3.</span> <span class="nav-text">10.3 Version::LevelFileNumIterator类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-4-Version-Get"><span class="nav-number">12.4.</span> <span class="nav-text">10.4 Version::Get()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#S1-20"><span class="nav-number">12.4.0.1.</span> <span class="nav-text">S1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S2-17"><span class="nav-number">12.4.0.2.</span> <span class="nav-text">S2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S3-12"><span class="nav-number">12.4.0.3.</span> <span class="nav-text">S3</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#S3-1"><span class="nav-number">12.4.0.3.1.</span> <span class="nav-text">S3.1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S3-2"><span class="nav-number">12.4.0.3.2.</span> <span class="nav-text">S3.2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#S4-2"><span class="nav-number">12.4.0.4.</span> <span class="nav-text">S4</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#S4-1"><span class="nav-number">12.4.0.4.1.</span> <span class="nav-text">S4.1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S4-2"><span class="nav-number">12.4.0.4.2.</span> <span class="nav-text">S4.2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#S4-3"><span class="nav-number">12.4.0.4.3.</span> <span class="nav-text">S4.3</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-5-Version-UpdateStats"><span class="nav-number">12.5.</span> <span class="nav-text">10.5 Version::UpdateStats()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-6-Version-GetOverlappingInputs"><span class="nav-number">12.6.</span> <span class="nav-text">10.6 Version::GetOverlappingInputs()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-7-Version-OverlapInLevel"><span class="nav-number">12.7.</span> <span class="nav-text">10.7 Version::OverlapInLevel()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-8-Version-PickLevelForMemTableOutput"><span class="nav-number">12.8.</span> <span class="nav-text">10.8 Version::PickLevelForMemTableOutput()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-9-%E5%B0%8F%E7%BB%93"><span class="nav-number">12.9.</span> <span class="nav-text">10.9 小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-VersionSet%E5%88%86%E6%9E%90"><span class="nav-number">13.</span> <span class="nav-text">11 VersionSet分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-VersionSet%E6%8E%A5%E5%8F%A3"><span class="nav-number">13.1.</span> <span class="nav-text">11.1 VersionSet接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-VersionSet-Builder%E7%B1%BB"><span class="nav-number">13.2.</span> <span class="nav-text">11.2 VersionSet::Builder类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-1-%E6%88%90%E5%91%98%E4%B8%8E%E6%9E%84%E9%80%A0"><span class="nav-number">13.2.1.</span> <span class="nav-text">11.2.1 成员与构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-2-Apply"><span class="nav-number">13.2.2.</span> <span class="nav-text">11.2.2 Apply()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-3-MaybeAddFile"><span class="nav-number">13.2.3.</span> <span class="nav-text">11.2.3 MaybeAddFile()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-4-SaveTo"><span class="nav-number">13.2.4.</span> <span class="nav-text">11.2.4 SaveTo()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-Recover"><span class="nav-number">13.3.</span> <span class="nav-text">11.3 Recover()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-1-%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B"><span class="nav-number">13.3.1.</span> <span class="nav-text">11.3.1 函数流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-2-Finalize"><span class="nav-number">13.3.2.</span> <span class="nav-text">11.3.2 Finalize()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-3-AppendVersion"><span class="nav-number">13.3.3.</span> <span class="nav-text">11.3.3 AppendVersion()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-4-LogAndApply"><span class="nav-number">13.4.</span> <span class="nav-text">11.4 LogAndApply()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-1-%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B"><span class="nav-number">13.4.1.</span> <span class="nav-text">11.4.1 函数流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-2-WriteSnapshot"><span class="nav-number">13.4.2.</span> <span class="nav-text">11.4.2 WriteSnapshot()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-3-ManifestContains"><span class="nav-number">13.4.3.</span> <span class="nav-text">11.4.3 ManifestContains()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-5-ApproximateOffsetOf"><span class="nav-number">13.5.</span> <span class="nav-text">11.5 ApproximateOffsetOf()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-DB%E7%9A%84%E6%89%93%E5%BC%80"><span class="nav-number">14.</span> <span class="nav-text">12 DB的打开</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-DB-Open"><span class="nav-number">14.1.</span> <span class="nav-text">12.1 DB::Open()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-DBImpl-DBImpl"><span class="nav-number">14.2.</span> <span class="nav-text">12.2 DBImpl::DBImpl()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-DBImp-NewDB"><span class="nav-number">14.3.</span> <span class="nav-text">12.3 DBImp::NewDB()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-4-DBImpl-Recover"><span class="nav-number">14.4.</span> <span class="nav-text">12.4 DBImpl::Recover()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-5-DBImpl-DeleteObsoleteFiles"><span class="nav-number">14.5.</span> <span class="nav-text">12.5 DBImpl::DeleteObsoleteFiles()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-6-DBImpl-RecoverLogFile"><span class="nav-number">14.6.</span> <span class="nav-text">12.6 DBImpl::RecoverLogFile()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-DB%E7%9A%84%E5%85%B3%E9%97%AD-amp-%E9%94%80%E6%AF%81"><span class="nav-number">15.</span> <span class="nav-text">13 DB的关闭&amp;销毁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1-DB%E5%85%B3%E9%97%AD"><span class="nav-number">15.1.</span> <span class="nav-text">13.1 DB关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2-DB%E9%94%80%E6%AF%81"><span class="nav-number">15.2.</span> <span class="nav-text">13.2 DB销毁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-DB%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%B8%8E%E9%81%8D%E5%8E%86"><span class="nav-number">16.</span> <span class="nav-text">14 DB的查询与遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-Get"><span class="nav-number">16.1.</span> <span class="nav-text">14.1 Get()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-NewIterator"><span class="nav-number">16.2.</span> <span class="nav-text">14.2 NewIterator()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-3-MergingIterator"><span class="nav-number">16.3.</span> <span class="nav-text">14.3 MergingIterator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-1-Get%E7%B3%BB%E6%8E%A5%E5%8F%A3"><span class="nav-number">16.3.1.</span> <span class="nav-text">14.3.1 Get系接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-2-Seek%E7%B3%BB%E6%8E%A5%E5%8F%A3"><span class="nav-number">16.3.2.</span> <span class="nav-text">14.3.2 Seek系接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-3-%E9%80%90%E6%AD%A5%E7%A7%BB%E5%8A%A8"><span class="nav-number">16.3.3.</span> <span class="nav-text">14.3.3 逐步移动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-4-DBIter"><span class="nav-number">16.4.</span> <span class="nav-text">14.4 DBIter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-4-1-Get%E7%B3%BB%E6%8E%A5%E5%8F%A3"><span class="nav-number">16.4.1.</span> <span class="nav-text">14.4.1 Get系接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-4-2-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="nav-number">16.4.2.</span> <span class="nav-text">14.4.2 辅助函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-4-3-Seek%E7%B3%BB%E5%87%BD%E6%95%B0"><span class="nav-number">16.4.3.</span> <span class="nav-text">14.4.3 Seek系函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-4-4-Prev-%E5%92%8CNext"><span class="nav-number">16.4.4.</span> <span class="nav-text">14.4.4 Prev()和Next()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-5-%E5%B0%8F%E7%BB%93"><span class="nav-number">16.5.</span> <span class="nav-text">14.5 小结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuhao0102" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuhao0102" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuhhpc0203@gmail.com" title="E-Mail → mailto:yuhhpc0203@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
