<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="进程描述进程和程序首先我们对进程作一明确定义：所谓进程是由正文段(Text)、用户数据段(User Segment)以及系统数据段(System Segment)共同组成的一个执行环境。程序是一个静态的实体。这里，对可执行映像做进一步解释，可执行映像就是一个可执行文件的内容。程序装入内存后就可以运行了：在指令指针寄存器的控制下，不断地将指令取至CPU运行。 Linux是一个多任务操作系统，也就是说">
<meta property="og:type" content="article">
<meta property="og:title" content="深入分析Linux内核源码笔记2">
<meta property="og:url" content="http://yoursite.com/2021/09/24/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B02/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="进程描述进程和程序首先我们对进程作一明确定义：所谓进程是由正文段(Text)、用户数据段(User Segment)以及系统数据段(System Segment)共同组成的一个执行环境。程序是一个静态的实体。这里，对可执行映像做进一步解释，可执行映像就是一个可执行文件的内容。程序装入内存后就可以运行了：在指令指针寄存器的控制下，不断地将指令取至CPU运行。 Linux是一个多任务操作系统，也就是说">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/1633340089.png">
<meta property="og:image" content="http://yoursite.com/img/1633444585.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633446571.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633499471.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633533810.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633534143.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633534701.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633616074.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633769261.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633769552.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633772014.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633773251.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633773943.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633775726.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633775814.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633775997.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633835076.png">
<meta property="og:image" content="http://yoursite.com/img/1633847842.jpg">
<meta property="og:image" content="http://yoursite.com/img/1633848455.png">
<meta property="og:image" content="http://yoursite.com/img/1633849778.png">
<meta property="article:published_time" content="2021-09-24T14:00:00.000Z">
<meta property="article:modified_time" content="2021-10-10T07:37:11.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/1633340089.png">

<link rel="canonical" href="http://yoursite.com/2021/09/24/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B02/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>深入分析Linux内核源码笔记2 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/24/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入分析Linux内核源码笔记2
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-24 22:00:00" itemprop="dateCreated datePublished" datetime="2021-09-24T22:00:00+08:00">2021-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-10 15:37:11" itemprop="dateModified" datetime="2021-10-10T15:37:11+08:00">2021-10-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="进程描述"><a href="#进程描述" class="headerlink" title="进程描述"></a>进程描述</h1><h2 id="进程和程序"><a href="#进程和程序" class="headerlink" title="进程和程序"></a>进程和程序</h2><p>首先我们对进程作一明确定义：所谓进程是由正文段(Text)、用户数据段(User Segment)以及系统数据段(System Segment)共同组成的一个执行环境。程序是一个静态的实体。这里，对可执行映像做进一步解释，可执行映像就是一个可执行文件的内容。程序装入内存后就可以运行了：在指令指针寄存器的控制下，不断地将指令取至CPU运行。</p>
<p>Linux是一个多任务操作系统，也就是说，可以有多个程序同时装入内存并运行，操作系统为每个程序建立一个运行环境即创建进程，每个进程拥有自己的虚拟地址空间，它们之间互不干扰，即使要相互作用(例如多个进程合作完成某个工作)，也要通过内核提供的进程间通信机制(IPC)。Linux内核支持多个进程虚拟地并发执行，这是通过不断地保存和切换程序的运行环境而实现的，选择哪个进程运行是由调度程序决定的。</p>
<p>进程是一个动态实体，由 3 个独立的部分组成。</p>
<ol>
<li>正文段(Text)：存放被执行的机器指令。这个段是只读的，它允许系统中正在运行的两个或多个进程之间能够共享这一代码。</li>
<li>用户数据段(User Segment)：存放进程在执行时直接进行操作的所有数据，包括进程使用的全部变量在内。显然，这里包含的信息可以被改变。虽然进程之间可以共享正文段，但是每个进程需要有它自己的专用用户数据段。</li>
<li>系统数据段(System Segment)：该段有效地存放程序运行的环境。事实上，这正是程序和进程的区别所在。这一部分存放有进程的控制信息。系统中有许多进程，操作系统要管理它们、调度它们运行，就是通过这些控制信息。Linux为每个进程建立了<code>task_struct</code>数据结构来容纳这些控制信息。</li>
</ol>
<p>总之，进程是一个程序完整的执行环境。该环境是由正文段、用户数据段、系统数据段的信息交织在一起组成的。</p>
<h2 id="Linux中的进程概述"><a href="#Linux中的进程概述" class="headerlink" title="Linux中的进程概述"></a>Linux中的进程概述</h2><p>Linux中的每个进程由一个<code>task_struct</code>数据结构来描述，在Linux中，任务(Task)和进程(Process)是两个相同的术语，<code>task_struct</code>其实就是通常所说的“进程控制块”即PCB。<code>task_struct</code>容纳了一个进程的所有信息，是系统对进程进行控制的唯一手段，也是最有效的手段。</p>
<p>Linux支持多处理机(SMP)，所以系统中允许有多个CPU。Linux作为多处理机操作系统时，系统中允许的最大CPU个数为 32。和其他操作系统类似，Linux也支持两种进程：普通进程和实时进程。实时进程具有一定程度上的紧迫性，要求对外部事件做出非常快的响应；而普通进程则没有这种限制。所以，实时进程要比普通进程优先运行。</p>
<p>总之，包含进程所有信息的<code>task_struct</code>数据结构是比较庞大的，但是该数据结构本身并不复杂，我们将它的所有域按其功能可做如下划分：</p>
<ul>
<li>进程状态(State)；</li>
<li>进程调度信息(Scheduling Information)；</li>
<li>各种标识符(Identifiers)；</li>
<li>进程通信有关信息(IPC，Inter_Process Communication)；</li>
<li>时间和定时器信息(Times and Timers)；</li>
<li>进程链接信息(Links)；</li>
<li>文件系统信息(File System)；</li>
<li>虚拟内存信息(Virtual Memory)；</li>
<li>页面管理信息(page)；</li>
<li>对称多处理器(SMP)信息；</li>
<li>和处理器相关的环境(上下文)信息(Processor Specific Context)；</li>
<li>其他信息。</li>
</ul>
<p>下面我们对<code>task_struct</code>结构进行具体描述。</p>
<h2 id="task-struct-结构描述"><a href="#task-struct-结构描述" class="headerlink" title="task_struct`结构描述"></a>task_struct`结构描述</h2><h3 id="进程状态-State"><a href="#进程状态-State" class="headerlink" title="进程状态(State)"></a>进程状态(State)</h3><p>进程执行时，它会根据具体情况改变状态。进程状态是调度和对换的依据。Linux中的进程主要有如下状态，如表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>内核表示</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>TASK_RUNNING</td>
<td>可运行</td>
</tr>
<tr>
<td>TASK_INTERRUPTIBLE</td>
<td>可中断的等待状态</td>
</tr>
<tr>
<td>TASK_UNINTERRUPTIBLE</td>
<td>不可中断的等待状态</td>
</tr>
<tr>
<td>TASK_ZOMBIE</td>
<td>僵死</td>
</tr>
<tr>
<td>TASK_STOPPED</td>
<td>暂停</td>
</tr>
<tr>
<td>TASK_SWAPPING</td>
<td>换入/换出</td>
</tr>
</tbody>
</table>
</div>
<p>(1)可运行状态：处于这种状态的进程，要么正在运行、要么正准备运行。正在运行的进程就是当前进程(由<code>current</code>所指向的进程)，而准备运行的进程只要得到CPU就可以立即投入运行。系统中有一个运行队列(run_queue)，用来容纳所有处于可运行状态的进程，调度程序执行时，从中选择一个进程投入运行。当前运行进程一直处于该队列中，也就是说，current`总是指向运行队列中的某个元素，只是具体指向谁由调度程序决定。</p>
<p>(2)等待状态：处于该状态的进程正在等待某个事件(Event)或某个资源，它肯定位于系统中的某个等待队列(wait_queue)中。Linux中处于等待状态的进程分为两种：可中断的等待状态和不可中断的等待状态。处于可中断等待态的进程可以被信号唤醒，如果收到信号，该进程就从等待状态进入可运行状态，并且加入到运行队列中，等待被调度；而处于不可中断等待态的进程是因为硬件环境不能满足而等待，例如等待特定的系统资源，它任何情况下都不能被打断，只能用特定的方式来唤醒它，例如唤醒函数<code>wake_up()</code>等。</p>
<p>(3)暂停状态：此时的进程暂时停止运行来接受某种特殊处理。通常当进程接收到<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code>或<code>SIGTTOU</code>信号后就处于这种状态。</p>
<p>(4)僵死状态：进程虽然已经终止，但由于某种原因，父进程还没有执行<code>wait()</code>系统调用，终止进程的信息也还没有回收。顾名思义，处于该状态的进程就是死进程，这种进程实际上是系统中的垃圾，必须进行相应处理以释放其占用的资源。</p>
<h3 id="进程调度信息"><a href="#进程调度信息" class="headerlink" title="进程调度信息"></a>进程调度信息</h3><p>这一部分信息通常包括进程的类别(普通进程还是实时进程)、进程的优先级等，如表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>域名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>need_resched</td>
<td>调度标志</td>
</tr>
<tr>
<td>Nice</td>
<td>静态优先级</td>
</tr>
<tr>
<td>Counter</td>
<td>动态优先级</td>
</tr>
<tr>
<td>Policy</td>
<td>调度策略</td>
</tr>
<tr>
<td>rt_priority</td>
<td>实时优先级</td>
</tr>
</tbody>
</table>
</div>
<p>当<code>need_resched</code>被设置时，在“下一次的调度机会”就调用调度程序<code>schedule()</code>。<code>counter</code>代表进程剩余的时间片，是进程调度的主要依据，也可以说是进程的动态优先级，因为这个值在不断地减少；<code>nice</code>是进程的静态优先级，同时也代表进程的时间片，用于对<code>counter</code>赋值，可以用<code>nice()</code>系统调用改变这个值；<code>policy</code>是适用于该进程的调度策略，实时进程和普通进程的调度策略是不同的；<code>rt_priority</code>只对实时进程有意义，它是实时进程调度的依据。</p>
<p>进程的调度策略有 3 种，如表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
<th>适用范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>SCHED_OTHER</td>
<td>其他调度</td>
<td>普通进程</td>
</tr>
<tr>
<td>SCHED_FIFO</td>
<td>先来先服务调度</td>
<td>实时进程</td>
</tr>
<tr>
<td>SCHED_RR</td>
<td>时间片轮转调度</td>
<td>实时进程</td>
</tr>
</tbody>
</table>
</div>
<p>只有<code>root</code>用户能通过<code>sched_setscheduler()</code>系统调用来改变调度策略。</p>
<h3 id="标识符-Identifiers"><a href="#标识符-Identifiers" class="headerlink" title="标识符(Identifiers)"></a>标识符(Identifiers)</h3><p>每个进程都有一个唯一的进程标识符(PID，process identifier)，内核通过这个标识符来识别不同的进程，同时，进程标识符<code>PID</code>也是内核提供给用户程序的接口。PID是 32 位的无符号整数，它被顺序编号：新创建进程的<code>PID</code>通常是前一个进程的<code>PID</code>加 1。</p>
<h3 id="进程通信有关信息"><a href="#进程通信有关信息" class="headerlink" title="进程通信有关信息"></a>进程通信有关信息</h3><p>Linux支持多种不同形式的通信机制。它支持典型的<code>UNIX</code>通信机制(IPC Mechanisms)：信号(Signals)、管道(Pipes)，也支持<code>SystemV</code>通信机制：共享内存(Shared Memory)、信号量和消息队列(Message Queues)。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>域名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Spinlock_t sigmask_lock</td>
<td>信号掩码的自旋锁</td>
</tr>
<tr>
<td>Long blocked</td>
<td>信号掩码</td>
</tr>
<tr>
<td>Struct signal *sig</td>
<td>信号处理函数</td>
</tr>
<tr>
<td>Struct sem_undo *semundo</td>
<td>为避免死锁而在信号量上设置的取消操作</td>
</tr>
<tr>
<td>Struct sem_queue *semsleeping</td>
<td>与信号量操作相关的等待队列</td>
</tr>
</tbody>
</table>
</div>
<h3 id="进程链接信息-Links"><a href="#进程链接信息-Links" class="headerlink" title="进程链接信息(Links)"></a>进程链接信息(Links)</h3><p>程序创建的进程具有父/子关系。因为一个进程能创建几个子进程，而子进程之间有兄弟关系，在<code>task_struct</code>结构中有几个域来表示这种关系。</p>
<p>每个进程的<code>task_struct</code>结构有许多指针，通过这些指针，系统中所有进程的<code>task_struct</code>结构就构成了一棵进程树，这棵进程树的根就是初始化进程<code>init</code>的<code>task_struct</code>结构(<code>init</code>进程是Linux内核建立起来后人为创建的一个进程，是所有进程的祖先进程)。</p>
<h3 id="时间和定时器信息-Times-and-Timers"><a href="#时间和定时器信息-Times-and-Timers" class="headerlink" title="时间和定时器信息(Times and Timers)"></a>时间和定时器信息(Times and Timers)</h3><p>一个进程从创建到终止叫做该进程的生存期(lifetime)。进程在其生存期内使用CPU的时间，内核都要进行记录，以便进行统计、计费等有关操作。进程耗费CPU的时间由两部分组成：一是在用户模式(或称为用户态)下耗费的时间、一是在系统模式(或称为系统态)下耗费的时间。每个时钟滴答，也就是每个时钟中断，内核都要更新当前进程耗费CPU的时间信息。</p>
<h3 id="文件系统信息-File-System"><a href="#文件系统信息-File-System" class="headerlink" title="文件系统信息(File System)"></a>文件系统信息(File System)</h3><p>进程可以打开或关闭文件，文件属于系统资源，Linux内核要对进程使用文件的情况进行记录。<code>task_struct</code>结构中有两个数据结构用于描述进程与文件相关的信息。其中，<code>fs_struct</code>中描述了两个<code>VFS</code>索引节点(VFS inode)，这两个索引节点叫做<code>root</code>和<code>pwd</code>，分别指向进程的可执行映像所对应的根目录(Home Directory)和当前目录或工作目录。</p>
<p><code>file_struct</code>结构用来记录了进程打开的文件的描述符(Descriptor)。如表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>定义形式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct fs_struct *fs</td>
<td>进程的可执行映像所在的文件系统</td>
</tr>
<tr>
<td>struct files_struct *files</td>
<td>进程打开的文件</td>
</tr>
</tbody>
</table>
</div>
<p>在文件系统中，每个<code>VFS</code>索引节点唯一描述一个文件或目录，同时该节点也是向更低层的文件系统提供的统一的接口。</p>
<h3 id="虚拟内存信息-Virtual-Memory"><a href="#虚拟内存信息-Virtual-Memory" class="headerlink" title="虚拟内存信息(Virtual Memory)"></a>虚拟内存信息(Virtual Memory)</h3><p>除了内核线程(Kernel Thread)，每个进程都拥有自己的地址空间(也叫虚拟空间)，用<code>mm_struct</code>来描述。另外Linux 2.4 还引入了另外一个域<code>active_mm</code>，这是为内核线程而引入的。因为内核线程没有自己的地址空间，为了让内核线程与普通进程具有统一的上下文切换方式，当内核线程进行上下文切换时，让切换进来的线程的<code>active_mm</code>指向刚被调度出去的进程的<code>active_mm</code>(如果进程的<code>mm</code>域不为空，则其<code>active_mm</code>域与<code>mm</code>域相同)。内存信息如表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>定义形式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct mm_struct *mm</td>
<td>描述进程的地址空间</td>
</tr>
<tr>
<td>struct mm_struct *active_mm</td>
<td>内核线程所借用的地址空间</td>
</tr>
</tbody>
</table>
</div>
<h3 id="页面管理信息"><a href="#页面管理信息" class="headerlink" title="页面管理信息"></a>页面管理信息</h3><p>当物理内存不足时，Linux内存管理子系统需要把内存中的部分页面交换到外存，其交换是以页为单位的。有关页面的描述信息如表。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>定义形式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>int swappable</td>
<td>进程占用的内存页面是否可换出</td>
</tr>
<tr>
<td>unsigned long min_flat, maj_flt, nswap</td>
<td>进程累计的次(minor)缺页次数、主(major)次数及累计换出、换入页面数</td>
</tr>
<tr>
<td>unsigned long cmin_flat,cmaj_flt,cnswap</td>
<td>本进程作为祖先进程，其所有层次子进程的累计的次(minor)缺页次数、主(major)次数及累计换出、换入页面数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="对称多处理机-SMP-信息"><a href="#对称多处理机-SMP-信息" class="headerlink" title="对称多处理机(SMP)信息"></a>对称多处理机(SMP)信息</h3><p>Linux 2.4 对<code>SMP</code>进行了全面的支持，表是与多处理机相关的几个域。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>定义形式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>int has_cpu</td>
<td>进程当前是否拥有CPU</td>
</tr>
<tr>
<td>int processor</td>
<td>进程当前正在使用的CPU</td>
</tr>
<tr>
<td>int lock_depth</td>
<td>上下文切换时内核锁的深度</td>
</tr>
</tbody>
</table>
</div>
<h3 id="和处理器相关的环境-上下文-信息-Processor-Specific-Context"><a href="#和处理器相关的环境-上下文-信息-Processor-Specific-Context" class="headerlink" title="和处理器相关的环境(上下文)信息(Processor Specific Context)"></a>和处理器相关的环境(上下文)信息(Processor Specific Context)</h3><p>因为不同的处理器对内部寄存器和堆栈的定义不尽相同，所以叫做“和处理器相关的环境”，也叫做“处理机状态”。当进程暂时停止运行时，处理机状态必须保存在进程的<code>task_struct</code>结构中，当进程被调度重新运行时再从中恢复这些环境，也就是恢复这些寄存器和堆栈的值。处理机信息如表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>定义形式</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct thread_struct *tss</td>
<td>任务切换状态</td>
</tr>
</tbody>
</table>
</div>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="struct-wait-queue-wait-chldexit"><a href="#struct-wait-queue-wait-chldexit" class="headerlink" title="struct wait_queue *wait_chldexit"></a>struct wait_queue *wait_chldexit</h4><p>在进程结束时,或发出系统调用<code>wait4</code>时，为了等待子进程的结束，而将自己(父进程)睡眠在该等待队列上，设置状态标志为<code>TASK_INTERRUPTIBLE</code>，并且把控制权转给调度程序。</p>
<h4 id="struct-rlimit-rlim-RLIM-NLIMITS"><a href="#struct-rlimit-rlim-RLIM-NLIMITS" class="headerlink" title="struct rlimit rlim[RLIM_NLIMITS]"></a>struct rlimit rlim[RLIM_NLIMITS]</h4><p>每一个进程可以通过系统调用<code>setlimit</code>和<code>getlimit</code>来限制它资源的使用。</p>
<h4 id="int-exit-code-exit-signal"><a href="#int-exit-code-exit-signal" class="headerlink" title="int exit_code exit_signal"></a>int exit_code exit_signal</h4><p>程序的返回代码以及程序异常终止产生的信号，这些数据由父进程(子进程完成后)轮流查询。</p>
<h4 id="char-comm-16"><a href="#char-comm-16" class="headerlink" title="char comm[16]"></a>char comm[16]</h4><p>这个域存储进程执行的程序的名字，这个名字用在调试中。</p>
<h4 id="unsigned-long-personality"><a href="#unsigned-long-personality" class="headerlink" title="unsigned long personality"></a>unsigned long personality</h4><p><code>personality</code>进一步描述进程执行的程序属于何种<code>UNIX</code>平台的“个性”信息。通常有<code>PER_Linux,PER_Linux_32BIT,PER_Linux_EM86,PER_SVR4,PER_SVR3,PER_SCOSVR3,PER_WYSEV386,PER_ISCR4,PER_BSD,PER_XENIX</code>和<code>PER_MASK</code>等。</p>
<h4 id="int-did-exec-1"><a href="#int-did-exec-1" class="headerlink" title="int did_exec:1"></a>int did_exec:1</h4><p>按<code>POSIX</code>要求设计的布尔量，区分进程正在执行老程序代码，还是用系统调用<code>execve()</code>装入一个新的程序。</p>
<h4 id="struct-linux-binfmt-binfmt"><a href="#struct-linux-binfmt-binfmt" class="headerlink" title="struct linux_binfmt *binfmt"></a>struct linux_binfmt *binfmt</h4><p>指向进程所属的全局执行文件格式结构，共有<code>a.out、script、elf、java</code>等 4 种。</p>
<h2 id="task-struct-结构在内存中的存放"><a href="#task-struct-结构在内存中的存放" class="headerlink" title="task_struct`结构在内存中的存放"></a>task_struct`结构在内存中的存放</h2><p><code>task_struct</code>结构在内存的存放与内核栈是分不开的，因此，首先讨论内核栈。</p>
<h3 id="进程内核栈"><a href="#进程内核栈" class="headerlink" title="进程内核栈"></a>进程内核栈</h3><p>每个进程都有自己的内核栈。当进程从用户态进入内核态时，CPU就自动地设置该进程的内核栈，也就是说，CPU从任务状态段<code>TSS</code>中装入内核栈指针<code>esp</code>。</p>
<p>X86 内核栈的分布如图 4.2 所示。<br><img src="/img/1633340089.png" alt=""></p>
<p>在<code>Intel</code>系统中，栈起始于末端，并朝这个内存区开始的方向增长。从用户态刚切换到内核态以后，进程的内核栈总是空的，因此，esp寄存器直接指向这个内存区的顶端。在图 4.2中，从用户态切换到内核态后，esp寄存器包含的地址为 0x018fc00。进程描述符存放在从0x015fa00 开始的地址。只要把数据写进栈中，esp`的值就递减。</p>
<p>在<code>/include/linux/sched.h</code>中定义了如下一个联合结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">task_union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">stack</span>[<span class="number">2408</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从这个结构可以看出，内核栈占 8KB 的内存区。实际上，进程的<code>task_struct</code>结构所占的内存是由内核动态分配的，更确切地说，内核根本不给<code>task_struct</code>分配内存，而仅仅给内核栈分配 8KB 的内存，并把其中的一部分给<code>task_struct</code>使用。</p>
<p><code>task_struct</code>结构大约占 1K 字节左右，其具体数字与内核版本有关，因为不同的版本其域稍有不同。因此，内核栈的大小不能超过 7KB，否则，内核栈会覆盖<code>task_struct</code>结构，从而导致内核崩溃。不过，7KB`大小对内核栈已足够。</p>
<p>把<code>task_struct</code>结构与内核栈放在一起具有以下好处：</p>
<ul>
<li>内核可以方便而快速地找到这个结构，用伪代码描述如下：<code>task_struct = (struct task_struct *) STACK_POINTER &amp; 0xffffe000</code></li>
<li>避免在创建进程时动态分配额外的内存。</li>
<li><code>task_struct</code>结构的起始地址总是开始于页大小(<code>PAGE_SIZE</code>)的边界。</li>
</ul>
<h3 id="当前进程-current-宏"><a href="#当前进程-current-宏" class="headerlink" title="当前进程(current`宏)"></a>当前进程(current`宏)</h3><p>在Linux/include/i386/current.h<code>中定义了</code>current`宏，这是一段与体系结构相关的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> task_struct * <span class="title function_">get_current</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">current</span>;</span></span><br><span class="line">    __asm__(<span class="string">&quot;andl %%esp,%0; &quot;</span>:<span class="string">&quot;=r&quot;</span> (current) : <span class="string">&quot;0&quot;</span> (~<span class="number">8191UL</span>));</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上，这段代码相当于如下一组汇编指令(设<code>p</code>是指向当前进程<code>task_struct</code>结构的指针)：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0xffffe000, %ecx</span><br><span class="line">andl %esp, %ecx</span><br><span class="line">movl %ecx, p</span><br></pre></td></tr></table></figure></p>
<p>换句话说，仅仅只需检查栈指针的值，而根本无需存取内存，内核就可以导出<code>task_struct</code>结构的地址。</p>
<h2 id="进程组织方式"><a href="#进程组织方式" class="headerlink" title="进程组织方式"></a>进程组织方式</h2><p>为了对系统中的很多进程及处于不同状态的进程进行管理，Linux采用了如下几种组织方式。</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表是进行快速查找的一种有效的组织方式。Linux在进程中引入的哈希表叫做<code>pidhash</code>，在<code>include/linux/sched.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PIDHASH_SZ (4096 &gt;&gt; 2)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pidhash</span>[<span class="title">PIDHASH_SZ</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pid_hashfn(x) ((((x) &gt;&gt; 8) ^ (x)) &amp; (PIDHASH_SZ - 1))</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>PIDHASH_SZ</code>为表中元素的个数，表中的元素是指向<code>task_struct</code>结构的指针。<code>pid_hashfn</code>为哈希函数，把进程的<code>PID</code>转换为表的索引。通过这个函数，可以把进程的<code>PID</code>均匀地散列在它们的域(0 到<code>PID_MAX-1</code>)中。</p>
<p>Linux利用链地址法来处理冲突的PID：也就是说，每一表项是由冲突的<code>PID</code>组成的双向链表，这种链表是由<code>task_struct</code>结构中的<code>pidhash_next</code>和<code>pidhash_pprev</code>域实现的，同一链表中<code>pid</code>的大小由小到大排列。</p>
<p>哈希表<code>pidhash</code>中插入和删除一个进程时可以调用<code>hash_pid()</code>和<code>unhash_pid()</code>函数。对于一个给定的<code>pid</code>，可以通过<code>find_task_by_pid()</code>函数快速地找到对应的进程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> task_struct *<span class="title function_">find_task_by_pid</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>, **<span class="title">htable</span> =</span> &amp;pidhash[pid_hashfn(pid)];</span><br><span class="line">    <span class="keyword">for</span>(p = *htable; p &amp;&amp; p-&gt;pid != pid; p = p-&gt;pidhash_next)</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><p>哈希表的主要作用是根据进程的<code>pid</code>可以快速地找到对应的进程，但它没有反映进程创建的顺序，也无法反映进程之间的亲属关系，因此引入双向循环链表。每个进程<code>task_struct</code>结构中的<code>prev_task</code>和<code>next_task</code>域用来实现这种链表。</p>
<p>宏<code>SET_LINK</code>用来在该链表中插入一个元素：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SET_LINKS(p) do &#123; \</span></span><br><span class="line"><span class="meta"> (p)-&gt;next_task = &amp;init_task; \</span></span><br><span class="line"><span class="meta"> (p)-&gt;prev_task = init_task.prev_task; \</span></span><br><span class="line"><span class="meta"> init_task.prev_task-&gt;next_task = (p); \</span></span><br><span class="line"><span class="meta"> init_task.prev_task = (p); \</span></span><br><span class="line"><span class="meta"> (p)-&gt;p_ysptr = NULL; \</span></span><br><span class="line"><span class="meta"> <span class="keyword">if</span> (((p)-&gt;p_osptr = (p)-&gt;p_pptr-&gt;p_cptr) != NULL) \</span></span><br><span class="line"><span class="meta"> (p)-&gt;p_osptr-&gt;p_ysptr = p; \</span></span><br><span class="line"><span class="meta"> (p)-&gt;p_pptr-&gt;p_cptr = p; \</span></span><br><span class="line"><span class="meta"> &#125; while (0)</span></span><br></pre></td></tr></table></figure></p>
<p>从这段代码可以看出，链表的头和尾都为<code>init_task</code>，它对应的是进程 0(pid为 0)，也就是所谓的空进程，它是所有进程的祖先。这个宏把进程之间的亲属关系也链接起来。另外，还有一个宏<code>for_each_task()</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_task(p) \</span></span><br><span class="line"><span class="meta"> for (p = &amp;init_task ; (p = p-&gt;next_task) != &amp;init_task ; ) </span></span><br></pre></td></tr></table></figure></p>
<p>这个宏是循环控制语句。注意<code>init_task</code>的作用，因为空进程是一个永远不存在的进程，因此用它做链表的头和尾是安全的。</p>
<p>因为进程的双向循环链表是一个临界资源，因此在使用这个宏时一定要加锁，使用完后开锁。</p>
<h3 id="运行队列"><a href="#运行队列" class="headerlink" title="运行队列"></a>运行队列</h3><p>当内核要寻找一个新的进程在CPU上运行时，必须只考虑处于可运行状态的进程(即在<code>TASK_RUNNING</code>状态的进程)，因为扫描整个进程链表是相当低效的，所以引入了可运行状态进程的双向循环链表，也叫运行队列(runqueue)。</p>
<p>运行队列容纳了系统中所有可以运行的进程，它是一个双向循环队列。</p>
<h3 id="进程的运行队列链表"><a href="#进程的运行队列链表" class="headerlink" title="进程的运行队列链表"></a>进程的运行队列链表</h3><p>该队列通过<code>task_struct</code>结构中的两个指针<code>run_list</code>链表来维持。队列的标志有两个：一个是“空进程”<code>idle_task</code>，一个是队列的长度。有两个特殊的进程永远在运行队列中待着：当前进程和空进程。前面我们讨论过，当前进程就是由<code>cureent</code>指针所指向的进程，也就是当前运行着的进程，直到调度程序选定某个进程投入运行后，<code>current</code>才真正指向了当前运行进程；空进程是个比较特殊的进程，只有系统中没有进程可运行时它才会被执行，Linux将它看作运行队列的头，当调度程序遍历运行队列，是从<code>idle_task</code>开始、至<code>idle_task</code>结束的，在调度程序运行过程中，允许队列中加入新出现的可运行进程，新出现的可运行进程插入到队尾，这样的好处是不会影响到调度程序所要遍历的队列成员，可见，<code>idle_task</code>是运行队列很重要的标志。</p>
<p>另一个重要标志是队列长度，也就是系统中处于可运行状态(<code>TASK_RUNNING</code>)的进程数目，用全局整型变量<code>nr_running</code>表示，在<code>/kernel/fork.c</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nr_running=<span class="number">1</span>；</span><br></pre></td></tr></table></figure></p>
<p>若<code>nr_running</code>为 0，就表示队列中只有空进程。在这里要说明一下：若<code>nr_running</code>为0，则系统中的当前进程和空进程就是同一个进程。但是Linux会充分利用CPU而尽量避免出现这种情况。</p>
<h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>在 2.4 版本中，引入了一种特殊的链表—通用双向链表，它是内核中实现其他链表的基础，也是面向对象的思想在<code>C</code>语言中的应用。在等待队列的实现中多次涉及与此链表相关的内容。</p>
<h4 id="通用双向链表"><a href="#通用双向链表" class="headerlink" title="通用双向链表"></a>通用双向链表</h4><p>在<code>include/linux/list.h</code>中定义了这种链表：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这是双向链表的一个基本框架，在其他使用链表的地方就可以使用它来定义任意一个双向链表，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo_list</span> &#123;</span></span><br><span class="line"> <span class="type">int</span> data;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于<code>list_head</code>类型的链表，Linux定义了 5 个宏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(name) \</span></span><br><span class="line"><span class="meta"> struct list_head name = LIST_HEAD_INIT(name)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_LIST_HEAD(ptr) do &#123; \</span></span><br><span class="line"><span class="meta"> (ptr)-&gt;next = (ptr); (ptr)-&gt;prev = (ptr); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta"> ((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each(pos, head) \</span></span><br><span class="line"><span class="meta"> for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)</span></span><br></pre></td></tr></table></figure></p>
<p>前 3 个宏都是初始化一个空的链表，但用法不同，<code>LIST_HEAD_INIT()</code>在声明时使用，用来初始化结构元素，第 2 个宏用在静态变量初始化的声明中，而第 3 个宏用在函数内部。其中，最难理解的宏为<code>list_entry()</code>，在内核代码的很多处都用到这个宏，例如，在调度程序中，从运行队列中选择一个最值得运行的进程，部分代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(runqueue_head)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">tmp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">list_for_each(tmp, &amp;runqueue_head) &#123;</span><br><span class="line">    p = list_entry(tmp, <span class="keyword">struct</span> task_struct, run_list); </span><br><span class="line">    <span class="keyword">if</span> (can_schedule(p)) &#123;</span><br><span class="line">        <span class="type">int</span> weight = goodness(p, this_cpu, prev-&gt;active_mm);</span><br><span class="line">        <span class="keyword">if</span> (weight &gt; c)</span><br><span class="line">            c = weight, next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这段代码可以分析出<code>list_entry(ptr, type, member)</code>宏及参数的含义：<code>ptr</code>是指向<code>list_head</code>类型链表的指针，<code>type</code>为一个结构，而<code>member</code>为结构<code>type</code>中的一个域，类型为<code>list_head</code>，这个宏返回指向<code>type</code>结构的指针。在内核代码中大量引用了这个宏，因此，搞清楚这个宏的含义和用法非常重要。</p>
<p>另外，对<code>list_head</code>类型的链表进行删除和插入(头或尾)的宏为<code>list_del()</code>/<code>list_add()</code>/<code>list_add_tail()</code>，在内核的其他函数中可以调用这些宏。例如，从运行队列中删除、增加及移动一个任务的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">del_from_runqueue</span><span class="params">(<span class="keyword">struct</span> task_struct * p)</span></span><br><span class="line">&#123;</span><br><span class="line">    nr_running--;</span><br><span class="line">    list_del(&amp;p-&gt;run_list);</span><br><span class="line">    p-&gt;run_list.next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">add_to_runqueue</span><span class="params">(<span class="keyword">struct</span> task_struct * p)</span></span><br><span class="line">&#123;</span><br><span class="line">    list_add(&amp;p-&gt;run_list, &amp;runqueue_head);</span><br><span class="line">    nr_running++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">move_last_runqueue</span><span class="params">(<span class="keyword">struct</span> task_struct * p)</span></span><br><span class="line">&#123;</span><br><span class="line">    list_del(&amp;p-&gt;run_list);</span><br><span class="line">    list_add_tail(&amp;p-&gt;run_list, &amp;runqueue_head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">move_first_runqueue</span><span class="params">(<span class="keyword">struct</span> task_struct * p)</span></span><br><span class="line">&#123;</span><br><span class="line">    list_del(&amp;p-&gt;run_list);</span><br><span class="line">    list_add(&amp;p-&gt;run_list, &amp;runqueue_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="等待队列-1"><a href="#等待队列-1" class="headerlink" title="等待队列"></a>等待队列</h4><p>运行队列链表把处于<code>TASK_RUNNING</code>状态的所有进程组织在一起。当要把其他状态的进程分组时，不同的状态要求不同的处理，Linux选择了下列方式之一。</p>
<ul>
<li><code>TASK_STOPPED</code>或<code>TASK_ZOMBIE</code>状态的进程不链接在专门的链表中，也没必要把它们分组，因为父进程可以通过进程的<code>PID</code>或进程间的亲属关系检索到子进程。</li>
<li>把<code>TASK_INTERRUPTIBLE</code>或<code>TASK_UNINTERRUPTIBLE</code>状态的进程再分成很多类，其每一类对应一个特定的事件。在这种情况下，进程状态提供的信息满足不了快速检索进程，因此，有必要引入另外的进程链表。这些链表叫等待队列。</li>
</ul>
<p>等待队列表示一组睡眠的进程，当某一条件变为真时，由内核唤醒它们。等待队列由循环链表实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> <span class="title">wait_queue_t</span> ;</span></span><br></pre></td></tr></table></figure></p>
<p>另外，关于等待队列另一个重要的数据结构—等待队列首部的描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">    <span class="type">wq_lock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>下面给出 2.4 版中的一些主要函数及其功能：</p>
<ul>
<li><code>init_waitqueue_head()</code>——对等待队列首部进行初始化</li>
<li><code>init_waitqueue_entry()</code>——对要加入等待队列的元素进行初始化</li>
<li><code>waitqueue_active()</code>——判断等待队列中已经没有等待的进程</li>
<li><code>add_wait_queue()</code>——给等待队列中增加一个元素</li>
<li><code>remove_wait_queue()</code>——从等待队列中删除一个元素</li>
</ul>
<p>注意，在以上函数的实现中，都调用了对<code>list_head</code>类型链表的操作函数(<code>list_del()</code>/<code>list_add()</code>/<code>list_add_tail()</code>)，因此可以说，<code>list_head</code>类型相当于`C++中的基类型。</p>
<p>希望等待一个特定事件的进程能调用下列函数中的任一个：</p>
<p><code>sleep_on()</code>函数对当前的进程起作用，我们把当前进程叫做`P：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sleep_on(<span class="type">wait_queue_head_t</span> *q)</span><br><span class="line">&#123;</span><br><span class="line">    SLEEP_ON_VAR <span class="comment">/*宏定义，用来初始化要插入到等待队列中的元素*/</span></span><br><span class="line">    current-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">    SLEEP_ON_HEAD <span class="comment">/*宏定义，把`P`插入到等待队列 */</span> </span><br><span class="line">    schedule();</span><br><span class="line">    SLEEP_ON_TAIL <span class="comment">/*宏定义把`P`从等待队列中删除 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数把<code>P</code>的状态设置为<code>TASK_UNINTERRUPTIBLE</code>，并把<code>P</code>插入等待队列。然后，它调用调度程序恢复另一个程序的执行。当<code>P</code>被唤醒时，调度程序恢复<code>sleep_on()</code>函数的执行，把<code>P</code>从等待队列中删除。</p>
<p><code>interruptible_sleep_on()</code>与<code>sleep_on()</code>函数是一样的，但稍有不同，前者把进程<code>P</code>的状态设置为<code>TASK_INTERRUPTIBLE</code>而不是<code>TASK_UNINTERRUPTIBLE</code>，因此，通过接受一个信号可以唤醒`P。</p>
<p><code>sleep_on_timeout()</code>和<code>interruptible_sleep_on_timeout()</code>与前面情况类似，但它们允许调用者定义一个时间间隔，过了这个间隔以后，内核唤醒进程。为了做到这点，它们调用<code>schedule_timeout()</code>函数而不是<code>schedule()</code>函数。</p>
<p>利用<code>wake_up</code>或者<code>wake_up_interruptible</code>宏，让插入等待队列中的进程进入<code>TASK_RUNNING</code>状态，这两个宏最终都调用了<code>try_to_wake_up()</code>函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">try_to_wake_up</span><span class="params">(<span class="keyword">struct</span> task_struct * p, <span class="type">int</span> synchronous)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> success = <span class="number">0</span>;</span><br><span class="line">    spin_lock_irqsave(&amp;runqueue_lock, flags); <span class="comment">/*加锁*/</span></span><br><span class="line">    p-&gt;state = TASK_RUNNING;</span><br><span class="line">    <span class="keyword">if</span> (task_on_runqueue(p)) <span class="comment">/*判断`p`是否已经在运行队列*/</span></span><br><span class="line">        </span><br><span class="line">    add_to_runqueue(p); <span class="comment">/*不在，则把`p`插入到运行队列*/</span></span><br><span class="line">    <span class="keyword">if</span> (!synchronous || !(p-&gt;cpus_allowed &amp; (<span class="number">1</span> &lt;&lt; smp_processor_id())))</span><br><span class="line">        reschedule_idle(p);</span><br><span class="line">    success = <span class="number">1</span>;</span><br><span class="line">out:</span><br><span class="line">    spin_unlock_irqrestore(&amp;runqueue_lock, flags); <span class="comment">/*开锁*/</span></span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个函数中，<code>p</code>为要唤醒的进程。如果<code>p</code>不在运行队列中，则把它放入运行队列。如果重新调度正在进行的过程中，则调用<code>reschedule_idle()</code>函数，这个函数决定进程<code>p</code>是否应该抢占某一CPU上的当前进程。</p>
<p>实际上，在内核的其他部分，最常用的还是<code>wake_up</code>或者<code>wake_up_interruptible</code>宏，也就是说，如果你要在内核级进行编程，只需调用其中的一个宏。例如一个简单的实时时钟(RTC)中断程序如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(rtc_wait)</span>; <span class="comment">/*初始化等待队列首部*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock(&amp;rtc_lock);</span><br><span class="line">    rtc_irq_data = CMOS_READ(RTC_INTR_FLAGS);</span><br><span class="line">    spin_unlock(&amp;rtc_lock);</span><br><span class="line">    wake_up_interruptible(&amp;rtc_wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个中断处理程序通过从实时时钟的<code>I/O</code>端口(CMOS_READ<code>宏产生一对</code>outb/inb)读取数据，然后唤醒在<code>rtc_wait</code>等待队列上睡眠的任务。</p>
<h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><p>内核线程(thread)或叫守护进程(daemon)，在操作系统中占据相当大的比例，当Linux操作系统启动以后，尤其是<code>Xwindow</code>也启动以后，你可以用“ps”命令查看系统中的进程，这时会发现很多以“d”结尾的进程名，这些进程就是内核线程。</p>
<p>内核线程也可以叫内核任务，它们周期性地执行，例如，磁盘高速缓存的刷新，网络连接的维护，页面的换入换出等。在Linux中，内核线程与普通进程有一些本质的区别，从以下几个方面可以看出二者之间的差异。</p>
<ul>
<li>内核线程执行的是内核中的函数，而普通进程只有通过系统调用才能执行内核中的函数。</li>
<li>内核线程只运行在内核态，而普通进程既可以运行在用户态，也可以运行在内核态。</li>
<li>因为内核线程指只运行在内核态，因此，它只能使用大于<code>PAGE_OFFSET</code>(3G)的地址空间。另一方面，不管在用户态还是内核态，普通进程可以使用 4GB`的地址空间。</li>
</ul>
<p>内核线程是由<code>kernel_thread()</code>函数在内核态下创建的，这个函数所包含的代码大部分是内联式汇编语言，但在某种程度上等价于下面的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kernel_thread</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> * arg, <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> p ;</span><br><span class="line">    p = clone( <span class="number">0</span>, flags | CLONE_VM );</span><br><span class="line">    <span class="keyword">if</span> ( p ) <span class="comment">/* parent */</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* child */</span></span><br><span class="line">        fn(arg);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="进程的权能"><a href="#进程的权能" class="headerlink" title="进程的权能"></a>进程的权能</h2><p>Linux用“权能(capability)”表示一进程所具有的权力。一种权能仅仅是一个标志，它表明是否允许进程执行一个特定的操作或一组特定的操作。这个模型不同于传统的“超级用户对普通用户”模型，在后一种模型中，一个进程要么能做任何事情，要么什么也不能做，这取决于它的有效`UID。也就是说，超级用户与普通用户的划分过于笼统。如表给出了在Linux内核中已定义的权能。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CAP_CHOWN</td>
<td>忽略对文件和组的拥有者进行改变的限制</td>
</tr>
<tr>
<td>CAP_DAC_OVERRIDE</td>
<td>忽略文件的访问许可权</td>
</tr>
<tr>
<td>CAP_DAC_READ_SEARCH</td>
<td>忽略文件/目录读和搜索的许可权</td>
</tr>
<tr>
<td>CAP_FOWNER</td>
<td>忽略对文件拥有者的限制</td>
</tr>
<tr>
<td>CAP_FSETID</td>
<td>忽略对<code>setid</code>和<code>setgid</code>标志的限制</td>
</tr>
<tr>
<td>CAP_KILL</td>
<td>忽略对信号挂起的限制</td>
</tr>
<tr>
<td>CAP_SETGID</td>
<td>允许<code>setgid</code>标志的操作</td>
</tr>
<tr>
<td>CAP_SETUID</td>
<td>允许<code>setuid</code>标志的操作</td>
</tr>
<tr>
<td>CAP_SETPCAP</td>
<td>转移/删除对其他进程所许可的权能</td>
</tr>
<tr>
<td>CAP_LINUX_IMMUTABLE</td>
<td>允许对仅追加和不可变文件的修改</td>
</tr>
<tr>
<td>CAP_NET_BIND_SERVICE</td>
<td>允许捆绑到低于 1024TCP/UDP`的套节字</td>
</tr>
<tr>
<td>CAP_NET_BROADCAST</td>
<td>允许网络广播和监听多点传送</td>
</tr>
<tr>
<td>CAP_NET_ADMIN</td>
<td>允许一般的网络管理。</td>
</tr>
<tr>
<td>CAP_NET_RAW</td>
<td>允许使用<code>RAW</code>和<code>PACKET</code>套节字</td>
</tr>
<tr>
<td>CAP_IPC_LOCK</td>
<td>允许页和共享内存的加锁</td>
</tr>
<tr>
<td>CAP_IPC_OWNER</td>
<td>跳过<code>IPC</code>拥有者的检查</td>
</tr>
<tr>
<td>CAP_SYS_MODULE</td>
<td>允许内核模块的插入和删除</td>
</tr>
<tr>
<td>CAP_SYS_RAWIO</td>
<td>允许通过<code>ioperm()</code> 和<code>iopl()</code>访问<code>I/O</code>端口</td>
</tr>
<tr>
<td>CAP_SYS_CHROOT</td>
<td>允许使用<code>chroot()</code></td>
</tr>
<tr>
<td>CAP_SYS_PTRACE</td>
<td>允许在任何进程上使用<code>ptrace()</code></td>
</tr>
<tr>
<td>CAP_SYS_PACCT</td>
<td>允许配置进程的计账</td>
</tr>
<tr>
<td>CAP_SYS_ADMIN</td>
<td>允许一般的系统管理</td>
</tr>
<tr>
<td>CAP_SYS_BOOT</td>
<td>允许使用<code>reboot()</code></td>
</tr>
<tr>
<td>CAP_SYS_NICE</td>
<td>忽略对<code>nice()</code>的限制</td>
</tr>
<tr>
<td>CAP_SYS_RESOURCE</td>
<td>忽略对几个资源使用的限制</td>
</tr>
<tr>
<td>CAP_SYS_TIME</td>
<td>允许系统时钟和实时时钟的操作</td>
</tr>
<tr>
<td>CAP_SYS_TTY_CONFIG</td>
<td>允许配置<code>tty</code>设备</td>
</tr>
</tbody>
</table>
</div>
<p>任何时候，每个进程只需要有限种权能，这是其主要优势。因此，即使一位有恶意的用户使用有潜在错误程序，他也只能非法地执行有限个操作类型。</p>
<h2 id="内核同步"><a href="#内核同步" class="headerlink" title="内核同步"></a>内核同步</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>进程间对共享资源的互斥访问是通过“信号量”机制来实现的。信号量机制是操作系统教科书中比较重要的内容之一。Linux内核中提供了两个函数<code>down()</code>和<code>up()</code>，分别对应于操作系统教科书中的<code>P、V</code>操作。</p>
<p>信号量在内核中定义为<code>semaphore</code>数据结构，位于<code>include/i386/semaphore.h</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="type">int</span> sleepers;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> wait;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WAITQUEUE_DEBUG</span></span><br><span class="line">    <span class="type">long</span> __magic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中的<code>count</code>域就是“信号量”中的那个“量”，它代表着可用资源的数量。如果该值大于 0，那么资源就是空闲的，也就是说，该资源可以使用。相反，如果<code>count</code>小于 0，那么这个信号量就是繁忙的，也就是说，这个受保护的资源现在不能使用。在后一种情况下，count`的绝对值表示了正在等待这个资源的进程数。该值为 0 表示有一个进程正在使用这个资源，但没有其他进程在等待这个资源。</p>
<p><code>wait</code>域存放等待链表的地址，该链表中包含正在等待这个资源的所有睡眠的进程。当然，如果<code>count</code>大于或等于 0，则等待队列为空。为了明确表示等待队列中正在等待的进程数，引入了计数器`sleepers。</p>
<p><code>down()</code>和<code>up()</code>函数主要应用在文件系统和驱动程序中，把要保护的临界区放在这两个函数中间，用法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">down();</span><br><span class="line">临界区</span><br><span class="line">up();</span><br></pre></td></tr></table></figure><br>这两个函数是用嵌入式汇编实现的。</p>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>避免干扰的最简单方法就是保证操作的原子性，即操作必须在一条单独的指令内执行。有两种类型的原子操作，即位图操作和数学的加减操作。</p>
<h4 id="位图操作"><a href="#位图操作" class="headerlink" title="位图操作"></a>位图操作</h4><p>在内核的很多地方用到位图，例如内存管理中对空闲页的管理，位图还有一个广泛的用途就是简单的加锁，例如提供对打开设备的互斥访问。关于位图的操作函数如下，以下函数的参数中，addr`指向位图。</p>
<ul>
<li><code>void set_bit(int nr, volatile void *addr)</code>：设置位图的第<code>nr</code>位。</li>
<li><code>void clear_bit(int nr, volatile void *addr)</code>: 清位图的第<code>nr</code>位。</li>
<li><code>void change_bit(int nr, volatile void *addr)</code>: 改变位图的第<code>nr</code>位。</li>
<li><code>int test_and_set_bit(int nr, volatile void *addr)</code>: 设置第<code>nr</code>位，并返回该位原来的值，且两个操作是原子操作，不可分割。</li>
<li><code>int test_and_clear_bit(int nr, volatile void *addr)</code>: 清第<code>nr</code>为，并返回该位原来的值，且两个操作是原子操作。</li>
<li><code>int test_and_change_bit(int nr, volatile void *addr)</code>：改变第<code>nr</code>位，并返回该位原来的值，且这两个操作是原子操作。</li>
</ul>
<p>这些操作利用了<code>LOCK_PREFIX</code>宏，对于<code>SMP</code>内核，该宏是总线锁指令的前缀，对于单CPU这个宏不起任何作用。这就保证了在<code>SMP</code>环境下访问的原子性。</p>
<h4 id="算术操作"><a href="#算术操作" class="headerlink" title="算术操作"></a>算术操作</h4><p>有时候位操作是不方便的，取而代之的是需要执行算术操作，即加、减操作及加 1、减1 操作。典型的例子是很多数据结构中的引用计数域<code>count</code>(如<code>inode</code>结构)。这些操作的原子性是由<code>atomic_t</code>数据类型和表中的函数保证的。<code>atomic_t</code>的类型在<code>include/i386/atomic.h</code>，定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">volatile</span> <span class="type">int</span> counter; &#125; <span class="type">atomic_t</span>;</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>atomic_read(v)</code></td>
<td>返回*v</td>
</tr>
<tr>
<td><code>atomic_set(v,i)</code></td>
<td>把*v<code>设置成</code>i</td>
</tr>
<tr>
<td><code>atomic_add(i,v)</code></td>
<td>给*v<code>增加</code>i</td>
</tr>
<tr>
<td><code>atomic_sub(i,v)</code></td>
<td>从*v<code>中减去</code>i</td>
</tr>
<tr>
<td><code>atomic_inc(v)</code></td>
<td>给*v`加 1</td>
</tr>
<tr>
<td><code>atomic_dec(v)</code></td>
<td>从*v`中减去 1</td>
</tr>
<tr>
<td><code>atomic_dec_and_test(v)</code></td>
<td>从*v`中减去 1，如果结果非空就返回 1；否则返回 0</td>
</tr>
<tr>
<td><code>atomic_inc_and_test_greater_zero(v)</code></td>
<td>给*v`加 1，如果结果为正就返回 1；否则就返回 0</td>
</tr>
<tr>
<td><code>atomic_clear_mask(mask,addr)</code></td>
<td>清除由<code>mask</code>所指定的<code>addr</code>中的所有位</td>
</tr>
<tr>
<td><code>atomic_set_mask(mask,addr)</code></td>
<td>设置由<code>mask</code>所指定的<code>addr</code>中的所有位</td>
</tr>
</tbody>
</table>
</div>
<h3 id="自旋锁、读写自旋锁和大读者自旋锁"><a href="#自旋锁、读写自旋锁和大读者自旋锁" class="headerlink" title="自旋锁、读写自旋锁和大读者自旋锁"></a>自旋锁、读写自旋锁和大读者自旋锁</h3><p>在Linux内核中，临界区的代码或者是由进程上下文来执行，或者是由中断上下文来执行。在单CPU上，可以用<code>cli/sti</code>指令来保护临界区的使用，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">save_flags(flags);</span><br><span class="line">cli();</span><br><span class="line"><span class="comment">/* critical code */</span></span><br><span class="line">restore_flags(flags);</span><br></pre></td></tr></table></figure></p>
<p>但是，在<code>SMP</code>上，这种方法明显是没有用的，因为同一段代码序列可能由另一个进程同时执行,而<code>cli()</code>仅能单独地为每个CPU上的中断上下文提供对竞争资源的保护，它无法对运行在不同CPU上的上下文提供对竞争资源的访问。因此，必须用到自旋锁。</p>
<p>所谓自旋锁，就是当一个进程发现锁被另一个进程锁着时，它就不停地“旋转”，不断执行一个指令的循环直到锁打开。自旋锁只对<code>SMP</code>有用，对单CPU没有意义。有 3 种类型的自旋锁：基本的、读写以及大读者自旋锁。读写自旋锁适用于“多个读者少数写者”的场合，例如，有多个读者仅有一个写者，或者没有读者只有一个写者。大读者自旋锁是读写自旋锁的一种，但更照顾读者。大读者自旋锁现在主要用在`Sparc64 和网络系统中。</p>
<h1 id="进程调度与切换"><a href="#进程调度与切换" class="headerlink" title="进程调度与切换"></a>进程调度与切换</h1><h2 id="Linux时间系统"><a href="#Linux时间系统" class="headerlink" title="Linux时间系统"></a>Linux时间系统</h2><p>时间系统通常又被简称为时钟，它的主要任务是维持系统时间并且防止某个进程独占CPU及其他资源，也就是驱动进程的调度。</p>
<h3 id="时钟硬件"><a href="#时钟硬件" class="headerlink" title="时钟硬件"></a>时钟硬件</h3><p>大部分<code>PC</code>机中有两个时钟源，他们分别叫做<code>RTC</code>和<code>OS</code>(操作系统)时钟。RTC(Real Time Clock，实时时钟)也叫做<code>CMOS</code>时钟，它是<code>PC</code>主机板上的一块芯片(或者叫做时钟电路)，它靠电池供电，即使系统断电，也可以维持日期和时间。由于它独立于操作系统，所以也被称为硬件时钟，它为整个计算机提供一个计时标准，是最原始最底层的时钟数据。Linux只用<code>RTC</code>来获得时间和日期，同时，通过作用于<code>/dev/rtc</code>设备文件，也允许进程对<code>RTC</code>编程。内核通过<code>0x70</code>和<code>0x71 I/O</code>端口存取<code>RTC</code>。通过执行<code>/sbin/clock</code>系统程序(它直接作用于这两个<code>I/O</code>端口)，系统管理员可以配置时钟。</p>
<p>OS时钟产生于<code>PC</code>主板上的定时/计数芯片，由操作系统控制这个芯片的工作，OS时钟的基本单位就是该芯片的计数周期。在开机时操作系统取得<code>RTC</code>中的时间数据来初始化<code>OS</code>时钟，然后通过计数芯片的向下计数形成了<code>OS</code>时钟，所以<code>OS</code>时钟并不是本质意义上的时钟，它更应该被称为一个计数器。OS时钟只在开机时才有效，而且完全由操作系统控制，所以也被称为软时钟或系统时钟。下面我们重点描述<code>OS</code>时钟的产生。</p>
<p>可编程定时/计数器总体上由两部分组成：计数硬件和通信寄存器。通信寄存器包含有控制寄存器、状态寄存器、计数初始值寄存器(16 位)、计数输出寄存器等。通信寄存器在计数硬件和操作系统之间建立联系，用于二者之间的通信，操作系统通过这些寄存器控制计数硬件的工作方式、读取计数硬件的当前状态和计数值等信息。</p>
<p>在Linux内核初始化时，内核写入控制字和计数初值，这样计数硬件就会按照一定的计数方式对晶振产生的输入脉冲信号(5MHz~100MHz的频率)进行计数操作：计数器从计数初值开始，每收到一次脉冲信号，计数器减 1，当计数器减至 0 时，就会输出高电平或低电平，然后，如果计数为循环方式(通常为循环计数方式)，则重新从计数初值进行计数。这个输出脉冲将接到中断控制器上，产生中断信号，触发后面要讲的时钟中断，由时钟中断服务程序维持<code>OS</code>时钟的正常工作，所谓维持，其实就是简单的加 1 及细微的修正操作。这就是<code>OS</code>时钟产生的来源。</p>
<h3 id="Linux的时间系统"><a href="#Linux的时间系统" class="headerlink" title="Linux的时间系统"></a>Linux的时间系统</h3><p>系统时间是以“时钟滴答”为单位的，而时钟中断的频率决定了一个时钟滴答的长短，例如每秒有 100 次时钟中断，那么一个时钟滴答的就是 10 毫秒(记为 10ms)，相应地，系统时间就会每 10ms`增 1。不同的操作系统对时钟滴答的定义是不同的。</p>
<p>Linux中用全局变量<code>jiffies</code>表示系统自启动以来的时钟滴答数目，在<code>/kernel/time.c</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">volatile</span> jiffies</span><br></pre></td></tr></table></figure></p>
<p>在<code>jiffies</code>基础上，Linux提供了如下适合人们习惯的时间格式，在<code>/include/linux/time.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span> <span class="comment">/* 这是精度很高的表示*/</span></span><br><span class="line">    <span class="type">long</span> tv_sec; <span class="comment">/* 秒 (second) */</span></span><br><span class="line">    <span class="type">long</span> tv_nsec; <span class="comment">/* 纳秒：十亿分之一秒( nanosecond)*/</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span> <span class="comment">/* 普通精度 */</span></span><br><span class="line">    <span class="type">int</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line">    <span class="type">int</span> tv_usec; <span class="comment">/* 微秒：百万分之一秒(microsecond)*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> &#123;</span> <span class="comment">/* 时区 */</span></span><br><span class="line">    <span class="type">int</span> tz_minuteswest; <span class="comment">/* 格林尼治时间往西方的时差 */</span></span><br><span class="line">    <span class="type">int</span> tz_dsttime; <span class="comment">/* 时间修正方式 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>tv_sec</code>表示秒(second)，<code>tv_usec</code>表示微秒(microsecond，百万分之一秒即 10-6秒)，<code>tv_nsec</code>表示纳秒(nanosecond，十亿分之一秒即 10-9秒)。定义<code>tb_usec</code>和<code>tv_nsec</code>的目的是为了适用不同的使用要求，不同的场合根据对时间精度的要求选用这两种表示。</p>
<h2 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h2><h3 id="时钟中断的产生"><a href="#时钟中断的产生" class="headerlink" title="时钟中断的产生"></a>时钟中断的产生</h3><p>操作系统对可编程定时/计数器进行有关初始化，然后定时/计数器就对输入脉冲进行计数(分频)，脉冲信号接到中断控制器 8259A_1的 0 号管脚，触发一个周期性的中断，我们就把这个中断叫做时钟中断，时钟中断的周期，也就是脉冲信号的周期，我们叫做“滴答”或“时标”(tick)。从本质上说，时钟中断只是一个周期性的信号，完全是硬件行为，该信号触发CPU去执行一个中断服务程序，但是为了方便，我们就把这个服务程序叫做时钟中断</p>
<h3 id="Linux实现时钟中断的全过程"><a href="#Linux实现时钟中断的全过程" class="headerlink" title="Linux实现时钟中断的全过程"></a>Linux实现时钟中断的全过程</h3><h4 id="可编程定时-计数器的初始化"><a href="#可编程定时-计数器的初始化" class="headerlink" title="可编程定时/计数器的初始化"></a>可编程定时/计数器的初始化</h4><p>IBM PC<code>中使用的是 8253 或 8254 芯片。Linux对 8253的初始化程序段如下(在</code>/arch/i386/kernel/i8259.c<code>的</code>init_IRQ()`函数中)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set_intr_gate(ox20, interrupt[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">/* 在`IDT`的第 0x20 个表项中插入一个中断门。这个门中的段选择符设置成内核代码段的选择符，偏移域设置成 0 号中断处理程序的入口地址。*/</span></span><br><span class="line">outb_p(<span class="number">0x34</span>,<span class="number">0x43</span>); </span><br><span class="line"><span class="comment">/* 写计数器 0 的控制字：工作方式 2*/</span></span><br><span class="line">outb_p(LATCH &amp; <span class="number">0xff</span>, <span class="number">0x40</span>); </span><br><span class="line"><span class="comment">/* 写计数初值`LSB`计数初值低位字节 */</span></span><br><span class="line">outb(LATCH &gt;&gt; <span class="number">8</span> , <span class="number">0x40</span>); </span><br><span class="line"><span class="comment">/* 写计数初值`MSB`计数初值高位字节*/</span></span><br></pre></td></tr></table></figure></p>
<p>LATCH(英文意思为：锁存器，即其中锁存了计数器 0 的初值)为计数器 0 的计数初值，在<code>/include/linux/timex.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLOCK_TICK_RATE 1193180 <span class="comment">/* 图 5.3 中的输入脉冲 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LATCH ((CLOCK_TICK_RATE + HZ/2) / HZ) <span class="comment">/* 计数器 0 的计数初值 */</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="与时钟中断相关的函数"><a href="#与时钟中断相关的函数" class="headerlink" title="与时钟中断相关的函数"></a>与时钟中断相关的函数</h4><p>下面我们接着介绍时钟中断触发的服务程序，该程序代码比较复杂，分布在不同的源文件中，主要包括如下函数：</p>
<ul>
<li>时钟中断程序：<code>timer_interrupt();</code></li>
<li>中断服务通用例程：<code>do_timer_interrupt();</code></li>
<li>时钟函数：<code>do_timer();</code></li>
<li>中断安装程序：<code>setup_irq();</code></li>
<li>中断返回函数：<code>ret_from_intr();</code></li>
</ul>
<p><code>timer_interrupt()</code>大约每 10ms被调用一次，实际上，<code>timer_interrupt()</code>函数是一个封装例程，它真正做的事情并不多，但是，作为一个中断程序,它必须在关中断的情况下执行。如果只考虑单处理机的情况，该函数主要语句就是调用<code>do_timer_interrupt()</code>函数。</p>
<p><code>do_timer_interrupt()</code>函数有两个主要任务，一个是调用<code>do_timer()</code>，另一个是维持实时时钟(RTC，每隔一定时间段要回写)，其实现代码在<code>/arch/i386/kernel/time.c</code>中，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">do_timer_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    do_timer(regs); <span class="comment">/* 调用时钟函数，将时钟函数等同于时钟中断未尝不可*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(xtime.tv_sec &gt; last_rtc_update + <span class="number">660</span>)</span><br><span class="line">        update_RTC();</span><br><span class="line"><span class="comment">/* 每隔 11 分钟就更新`RTC`中的时间信息，以使`OS`时钟和`RTC`时钟保持同步，11 分钟即660 秒，`xtime.tv_sec`的单位是秒，`last_rtc_update`记录的是上次`RTC`更新时的值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中，<code>xtime</code>是前面所提到的<code>timeval</code>类型，这是一个全局变量。</p>
<p>时钟函数<code>do_timer()</code> (在<code>/kernel/sched.c</code>中)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_timer</span><span class="params">(<span class="keyword">struct</span> pt_regs * regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    (*(<span class="type">unsigned</span> <span class="type">long</span> *)&amp;jiffies)++; </span><br><span class="line">    <span class="comment">/*更新系统时间，这种写法保证对`jiffies`操作的原子性*/</span></span><br><span class="line">    update_process_times();</span><br><span class="line">    ++lost_ticks;</span><br><span class="line">    <span class="keyword">if</span>( ! user_mode ( regs ) )</span><br><span class="line">        ++lost_ticks_system;</span><br><span class="line">    mark_bh(TIMER_BH);</span><br><span class="line">    <span class="keyword">if</span> (tq_timer)</span><br><span class="line">        mark_bh(TQUEUE_BH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>update_process_times()</code>函数与进程调度有关，从函数的名子可以看出，它处理的是与当前进程与时间有关的变量，例如，要更新当前进程的时间片计数器<code>counter，如果</code>counter&lt;=0，则要调用调度程序，要处理进程的所有定时器：实时、虚拟、概况，另外还要做一些统计工作。</p>
<h4 id="中断安装程序"><a href="#中断安装程序" class="headerlink" title="中断安装程序"></a>中断安装程序</h4><p>从上面的介绍可以看出，时钟中断与进程调度密不可分，因此，一旦开始有时钟中断就可能要进行调度，在系统进行初始化时，所做的大量工作之一就是对时钟进行初始化，其函数<code>time_init()</code>的代码在<code>/arch/i386/kernel/time.c</code>中，对其简写如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">time_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    xtime.tv_sec=get_cmos_time();</span><br><span class="line">    xtime.tv_usec=<span class="number">0</span>;</span><br><span class="line">    setup_irq(<span class="number">0</span>，＆irq0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的<code>get_cmos_time()</code>函数就是把当时的实际时间从<code>CMOS</code>时钟芯片读入变量<code>xtime</code>中，时间精度为秒。而<code>setup_irq(0, &amp;irq0)</code>就是时钟中断安装函数，<code>irq0</code>指的是一个结构类型<code>irqaction</code>，其定义及初值如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> <span class="title">irq0</span> =</span> &#123; timer_interrupt, SA_INTERRUPT, <span class="number">0</span>, <span class="string">&quot;timer&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>setup_irq(0, &amp;irq0)</code>的代码在<code>/arch/i386/kernel/irq.c</code>中，其主要功能就是将中断程序连入相应的中断请求队列，以等待中断到来时相应的中断程序被执行。</p>
<p>我们将有关函数改写如下，体现时钟中断的大意：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do_timer_interrupt()` /*这是一个伪函数 */</span><br><span class="line">&#123;</span><br><span class="line">    SAVE_ALL /*保存处理机现场 */</span><br><span class="line">    intr_count += 1; /* 这段操作不允许被中断 */</span><br><span class="line">    timer_interrupt() /* 调用时钟中断程序 */</span><br><span class="line">    intr_count -= 1;</span><br><span class="line">    jmp ret_from_intr /* 中断返回函数 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>jmp ret_from_intr</code>是一段汇编代码，也是一个较为复杂的过程，它最终要调用<code>jmp ret_from_sys_call</code>，即系统调用返回函数，而这个函数与进程的调度又密切相关，因此，我们重点分析<code>jmp ret_from_sys_call</code>。</p>
<h3 id="系统调用返回函数"><a href="#系统调用返回函数" class="headerlink" title="系统调用返回函数"></a>系统调用返回函数</h3><p>系统调用返回函数的源代码在<code>/arch/i386/kernel/entry.S</code>中<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(ret_from_sys_call)</span><br><span class="line"> cli # need_resched and signals atomic test</span><br><span class="line"> cmpl $0,need_resched(%ebx)</span><br><span class="line"> jne reschedule</span><br><span class="line"> cmpl $0,sigpending(%ebx)</span><br><span class="line"> jne signal_return</span><br><span class="line"> restore_all:</span><br><span class="line"> RESTORE_ALL</span><br><span class="line"></span><br><span class="line"> ALIGN</span><br><span class="line"> signal_return:</span><br><span class="line"> sti # we can get here from an interrupt handler</span><br><span class="line"> testl $(VM_MASK),EFLAGS(%esp)</span><br><span class="line"> movl %esp,%eax</span><br><span class="line"> jne v86_signal_return</span><br><span class="line"> xorl %edx,%edx</span><br><span class="line"> call SYMBOL_NAME(do_signal)</span><br><span class="line"> jmp restore_all</span><br><span class="line"></span><br><span class="line"> ALIGN</span><br><span class="line"> v86_signal_return:</span><br><span class="line"> call SYMBOL_NAME(save_v86_state)</span><br><span class="line"> movl %eax,%esp</span><br><span class="line"> xorl %edx,%edx</span><br><span class="line"> call SYMBOL_NAME(do_signal)</span><br><span class="line"> jmp restore_all</span><br><span class="line"> ….</span><br><span class="line"> reschedule:</span><br><span class="line"> call SYMBOL_NAME(schedule) # test</span><br><span class="line"> jmp ret_from_sys_call</span><br></pre></td></tr></table></figure></p>
<p>这一段汇编代码就是前面我们所说的“从系统调用返回函数”<code>ret_from_sys_call</code>，它是从中断、异常及系统调用返回时的通用接口。这段代码主体就是<code>ret_from_sys_call</code>函数，其执行过程中要调用其他一些函数(实际上是一段代码，不是真正的函数)，在此我们列出相关的几个函数。</p>
<ul>
<li><code>ret_from_sys_call</code>：主体。</li>
<li><code>reschedule</code>：检测是否需要重新调度。</li>
<li><code>signal_return</code>：处理当前进程接收到的信号。</li>
<li><code>v86_signal_return</code>：处理虚拟 86 模式下当前进程接收到的信号。</li>
<li><code>RESTORE_ALL</code>：我们把这个函数叫做彻底返回函数，因为执行该函数之后，就返回到当前进程的地址空间中去了。</li>
</ul>
<p>可以看到<code>ret_from_sys_call</code>的主要作用有：检测调度标志<code>need_resched</code>，决定是否要执行调度程序；处理当前进程的信号；恢复当前进程的环境使之继续执行。</p>
<h2 id="Linux的调度程序—Schedule"><a href="#Linux的调度程序—Schedule" class="headerlink" title="Linux的调度程序—Schedule()"></a>Linux的调度程序—Schedule()</h2><p>进程的合理调度是一个非常复杂的工作，它取决于可执行程序的类型(实时或普通)、调度的策略及操作系统所追求的目标，幸运的是，Linux的调度程序比较简单。</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>系统通过不同的调度算法(Scheduling Algorithm)来实现这种资源的分配。一个好的调度算法应当考虑以下几个方面。<br>1.公平：保证每个进程得到合理的CPU时间。<br>2.高效：使CPU保持忙碌状态，即总是有进程在CPU上运行。<br>3.响应时间：使交互用户的响应时间尽可能短。<br>4.周转时间：使批处理用户等待输出的时间尽可能短。<br>5.吞吐量：使单位时间内处理的进程数量尽可能多。</p>
<h4 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h4><p>时间片(Time Slice)就是分配给进程运行的一段时间。在分时系统中，为了保证人机交互的及时性，系统使每个进程依次地按时间片轮流的方式执行，此时即应采用时间片轮转法进行调度。在通常的轮转法中，系统将所有的可运行(即就绪)进程按先来先服务的原则，排成一个队列，每次调度时把CPU分配给队首进程，并令其执行一个时间片。时间片的大小从几<code>ms</code>到几百<code>ms</code>不等。当执行的时间片用完时，系统发出信号，通知调度程序，调度程序便据此信号来停止该进程的执行，并将它送到运行队列的末尾，等待下一次执行。然后，把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证运行队列中的所有进程，在一个给定的时间(人所能接受的等待时间)内，均能获得一时间片的处理机执行时间。</p>
<h4 id="优先权调度算法"><a href="#优先权调度算法" class="headerlink" title="优先权调度算法"></a>优先权调度算法</h4><p>为了照顾到紧迫型进程在进入系统后便能获得优先处理，引入了最高优先权调度算法。当将该算法用于进程调度时，系统将把处理机分配给运行队列中优先权最高的进程，这时，又可进一步把该算法分成两种方式。</p>
<p>(1)非抢占式优先权算法(又称不可剥夺调度，Nonpreemptive Scheduling)，系统一旦将处理机(CPU)分配给运行队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可将处理机分配给另一个优先权高的进程。这种调度算法主要用于批处理系统中，也可用于某些对实时性要求不严的实时系统中。</p>
<p>(2)抢占式优先权调度算法(又称可剥夺调度，Preemptive Scheduling)该算法的本质就是系统中当前运行的进程永远是可运行进程中优先权最高的那个。在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但是只要一出现了另一个优先权更高的进程时，调度程序就暂停原最高优先权进程的执行，而将处理机分配给新出现的优先权最高的进程，即剥夺当前进程的运行。因此，在采用这种调度算法时，每当出现一新的可运行进程，就将它和当前运行进程进行优先权比较，如果高于当前进程，将触发进程调度。</p>
<p>这种方式的优先权调度算法，能更好的满足紧迫进程的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。Linux也采用这种调度算法。</p>
<h4 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h4><p>这是时下最时髦的一种调度算法。其本质是：综合了时间片轮转调度和抢占式优先权调度的优点，即：优先权高的进程先运行给定的时间片，相同优先权的进程轮流运行给定的时间片。</p>
<h3 id="Linux进程调度时机"><a href="#Linux进程调度时机" class="headerlink" title="Linux进程调度时机"></a>Linux进程调度时机</h3><p>Linux的调度程序是一个叫<code>schedule()</code>的函数，这个函数被调用的频率很高，由它来决定是否要进行进程的切换，如果要切换的话，切换到哪个进程等。我们先来看在什么情况下要执行调度程序，我们把这种情况叫做调度时机。Linux调度时机主要有。</p>
<ol>
<li>进程状态转换的时刻：进程终止、进程睡眠；</li>
<li>当前进程的时间片用完时(current-&gt;counter=0)；</li>
<li>设备驱动程序；</li>
<li>进程从中断、异常及系统调用返回到用户态时。</li>
</ol>
<ul>
<li>时机 1，进程要调用<code>sleep()</code>或<code>exit()</code>等函数进行状态转换，这些函数会主动调用调度程序进行进程调度。</li>
<li>时机 2，由于进程的时间片是由时钟中断来更新的，因此，这种情况和时机 4 是一样的。</li>
<li>时机 3，当设备驱动程序执行长而重复的任务时，直接调用调度程序。在每次反复循环中，驱动程序都检查<code>need_resched</code>的值，如果必要，则调用调度程序<code>schedule()</code>主动放弃CPU。</li>
<li>时机 4，如前所述，不管是从中断、异常还是系统调用返回，最终都调用<code>ret_from_sys_call()</code>，由这个函数进行调度标志的检测，如果必要，则调用调用调度程序。</li>
</ul>
<p>每个时钟中断(timer interrupt)发生时，由 3 个函数协同工作，共同完成进程的选择和切换，它们是：<code>schedule()</code>、<code>do_timer()</code>及<code>ret_form_sys_call()</code>。</p>
<ul>
<li><code>schedule()</code>：进程调度函数，由它来完成进程的选择(调度)。</li>
<li><code>do_timer()</code>：暂且称之为时钟函数，该函数在时钟中断服务程序中被调用，是时钟中断服务程序的主要组成部分，该函数被调用的频率就是时钟中断的频率即每秒钟 100 次；</li>
<li><code>ret_from_sys_call()</code>：系统调用返回函数。当一个系统调用或中断完成时，该函数被调用，用于处理一些收尾工作，例如信号处理、核心任务等。</li>
</ul>
<p>前面我们讲过，时钟中断是一个中断服务程序，它的主要组成部分就是时钟函数<code>do_timer()</code>，由这个函数完成系统时间的更新、进程时间片的更新等工作，更新后的进程时间片<code>counter</code>作为调度的主要依据。</p>
<p>在时钟中断返回时，要调用函数<code>ret_from_sys_call()</code>，前面我们已经讨论过这个函数，在这个函数中有如下几行：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmpl $0, _need_resched</span><br><span class="line">jne reschedule</span><br><span class="line"> ……</span><br><span class="line">restore_all:</span><br><span class="line"> RESTORE_ALL</span><br><span class="line"></span><br><span class="line">reschedule:</span><br><span class="line"> call SYMBOL_NAME(schedule)</span><br><span class="line"> jmp ret_from_sys_call</span><br></pre></td></tr></table></figure></p>
<p>这几行的意思很明显：检测<code>need_resched</code>标志，如果此标志为非 0，那么就转到<code>reschedule</code>处调用调度程序<code>schedule()</code>进行进程的选择。调度程序<code>schedule()</code>会根据具体的标准在运行队列中选择下一个应该运行的进程。当从调度程序返回时，如果发现又有调度标志被设置，则又调用调度程序，直到调度标志为 0，这时，从调度程序返回时由<code>RESTORE_ALL</code>恢复被选定进程的环境，返回到被选定进程的用户空间，使之得到运行。以上就是时钟中断这个最频繁的调度时机。</p>
<h3 id="进程调度的依据"><a href="#进程调度的依据" class="headerlink" title="进程调度的依据"></a>进程调度的依据</h3><p>调度程序运行时，要在所有处于可运行状态的进程之中选择最值得运行的进程投入运行。在每个进程的<code>task_struct</code>结构中有如下 5 项：<code>need_resched</code>、<code>nice</code>、<code>counter</code>、<code>policy</code>及<code>rt_priority</code></p>
<ul>
<li><code>need_resched</code>: 在调度时机到来时，检测这个域的值，如果为 1，则调用`schedule() 。</li>
<li><code>counter</code>: 进程处于运行状态时所剩余的时钟滴答数，每次时钟中断到来时，这个值就减 1。当这个域的值变得越来越小，直至为 0 时，就把<code>need_resched</code>域置 1，因此，也把这个域叫做进程的“动态优先级”。</li>
<li><code>nice</code>: 进程的“静态优先级”，这个域决定<code>counter</code>的初值。只有通过<code>nice()</code>、<code>sched_setparam()</code>或<code>setpriority()</code>系统调用才能改变进程的静态优先级。</li>
<li><code>rt_priority</code>: 实时进程的优先级</li>
<li><code>policy</code>: 从整体上区分实时进程和普通进程，因为实时进程和普通进程的调度是不同的，它们两者之间，实时进程应该先于普通进程而运行，可以通过系统调用<code>sched_setscheduler()</code>来改变调度的策略。</li>
</ul>
<p>对于同一类型的不同进程，采用不同的标准来选择进程。对于普通进程，选择进程的主要依据为<code>counter</code>和<code>nice</code>。对于实时进程，Linux采用了两种调度策略，即<code>FIFO</code>(先来先服务调度)和<code>RR</code>(时间片轮转调度)。因为实时进程具有一定程度的紧迫性，所以衡量一个实时进程是否应该运行，Linux采用了一个比较固定的标准。实时进程的<code>counter</code>只是用来表示该进程的剩余滴答数，并不作为衡量它是否值得运行的标准，这和普通进程是有区别的。</p>
<h3 id="进程可运行程度的衡量"><a href="#进程可运行程度的衡量" class="headerlink" title="进程可运行程度的衡量"></a>进程可运行程度的衡量</h3><p>函数<code>goodness()</code>就是用来衡量一个处于可运行状态的进程值得运行的程度。该函数综合使用了上面我们提到的 5 项，给每个处于可运行状态的进程赋予一个权值(weight)，调度程序以这个权值作为选择进程的唯一依据。函数主体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">goodness</span><span class="params">(<span class="keyword">struct</span> task_struct * p, <span class="keyword">struct</span> mm_struct *this_mm)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">/* 权值，作为衡量进程是否运行的唯一依据 */</span></span><br><span class="line">    weight=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;policy&amp;SCHED_YIELD)</span><br><span class="line">        <span class="keyword">goto</span> out; <span class="comment">/*如果该进程愿意“礼让(yield)”，则让其权值为－1 */</span></span><br><span class="line">    <span class="keyword">switch</span>(p-&gt;policy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 实时进程*/</span></span><br><span class="line">        <span class="keyword">case</span> SCHED_FIFO:</span><br><span class="line">        <span class="keyword">case</span> SCHED_RR:</span><br><span class="line">        weight = <span class="number">1000</span> + p-&gt;rt_priority;</span><br><span class="line">        <span class="comment">/* 普通进程 */</span></span><br><span class="line">        <span class="keyword">case</span> SCHED_OTHER:</span><br><span class="line">        &#123; </span><br><span class="line">            weight = p-&gt;counter;</span><br><span class="line">            <span class="keyword">if</span>(!weight)</span><br><span class="line">                <span class="keyword">goto</span> out </span><br><span class="line">            <span class="comment">/* 做细微的调整*/</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;mm=this_mm||!p-&gt;mm)</span><br><span class="line">                weight = weight+<span class="number">1</span>;</span><br><span class="line">            weight+=<span class="number">20</span>-p-&gt;nice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> weight; <span class="comment">/*返回权值*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，在<code>sched.h</code>中对调度策略定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_OTHER 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_FIFO 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_RR 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_YIELD 0x10</span></span><br></pre></td></tr></table></figure></p>
<p>这个函数比较很简单。首先，根据<code>policy</code>区分实时进程和普通进程。实时进程的权值取决于其实时优先级，其至少是 1000，与<code>conter</code>和<code>nice</code>无关。普通进程的权值需特别说明如下两点。</p>
<ol>
<li>为什么进行细微的调整？如果<code>p-&gt;mm</code>为空，则意味着该进程无用户空间(例如内核线程)，则无需切换到用户空间。如果<code>p-&gt;mm=this_mm</code>，则说明该进程的用户空间就是当前进程的用户空间，该进程完全有可能再次得到运行。对于以上两种情况，都给其权值加 1，算是对它们小小的“奖励”。</li>
<li>进程的优先级<code>nice</code>是从早期<code>UNIX</code>沿用下来的负向优先级，其数值标志“谦让”的程度，其值越大，就表示其越“谦让”，也就是优先级越低，其取值范围为-20～+19，因此，(20-p-&gt;nice)的取值范围就是 0～40。可以看出，普通进程的权值不仅考虑了其剩余的时间片，还考虑了其优先级，优先级越高，其权值越大。</li>
</ol>
<h3 id="进程调度的实现"><a href="#进程调度的实现" class="headerlink" title="进程调度的实现"></a>进程调度的实现</h3><p>调度程序在内核中就是一个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>, *<span class="title">p</span>;</span> <span class="comment">/* prev`表示调度之前的进程, next`表示调度之后的进程 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="type">int</span> this_cpu, c;</span><br><span class="line">    <span class="keyword">if</span> (!current-&gt;active_mm) </span><br><span class="line">        BUG();<span class="comment">/*如果当前进程的`active_mm`为空，出错*/</span></span><br><span class="line">need_resched_back:</span><br><span class="line">    prev = current; <span class="comment">/*让`prev`成为当前进程 */</span> </span><br><span class="line">    this_cpu = prev-&gt;processor;</span><br><span class="line">    <span class="keyword">if</span> (in_interrupt()) &#123;</span><br><span class="line">        <span class="comment">/*如果`schedule`是在中断服务程序内部执行，就说明发生了错误*/</span></span><br><span class="line">        printk(<span class="string">&quot;Scheduling in interrupt\n&quot;</span>);</span><br><span class="line">        BUG();</span><br><span class="line">    &#125;</span><br><span class="line">    release_kernel_lock(prev, this_cpu); <span class="comment">/*释放全局内核锁，并开`this_CPU的中断*/</span></span><br><span class="line">    spin_lock_irq(&amp;runqueue_lock); <span class="comment">/*锁住运行队列，并且同时关中断*/</span></span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;policy == SCHED_RR) <span class="comment">/*将一个时间片用完的`SCHED_RR`实时</span></span><br><span class="line"><span class="comment">        goto move_rr_last; 进程放到队列的末尾 */</span></span><br><span class="line">move_rr_back:</span><br><span class="line">    <span class="keyword">switch</span> (prev-&gt;state) &#123; <span class="comment">/*根据`prev`的状态做相应的处理*/</span></span><br><span class="line">        <span class="keyword">case</span> TASK_INTERRUPTIBLE: <span class="comment">/*此状态表明该进程可以被信号中断*/</span></span><br><span class="line">            <span class="keyword">if</span> (signal_pending(prev)) &#123; <span class="comment">/*如果该进程有未处理的信号，则让其变为可运行状态*/</span></span><br><span class="line">                prev-&gt;state = TASK_RUNNING;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">default</span>: <span class="comment">/*如果为可中断的等待状态或僵死状态*/</span></span><br><span class="line">        del_from_runqueue(prev); <span class="comment">/*从运行队列中删除*/</span></span><br><span class="line">        <span class="keyword">case</span> TASK_RUNNING:;<span class="comment">/*如果为可运行状态，继续处理*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    prev-&gt;need_resched = <span class="number">0</span>; </span><br><span class="line"><span class="comment">/*下面是调度程序的正文 */</span></span><br><span class="line">repeat_schedule: <span class="comment">/*真正开始选择值得运行的进程*/</span></span><br><span class="line">    next = idle_task(this_cpu); <span class="comment">/*缺省选择空闲进程*/</span></span><br><span class="line">    c = <span class="number">-1000</span>;</span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;state == TASK_RUNNING)</span><br><span class="line">        <span class="keyword">goto</span> still_running;</span><br><span class="line">still_running_back:</span><br><span class="line">    list_for_each(tmp, &amp;runqueue_head) &#123; <span class="comment">/*遍历运行队列*/</span></span><br><span class="line">        p = list_entry(tmp, <span class="keyword">struct</span> task_struct, run_list);</span><br><span class="line">        <span class="keyword">if</span> ( can_schedule ( p, this_cpu ) ) &#123; / * 单CPU中 ，该函数总返回 <span class="number">1</span>* /</span><br><span class="line">            <span class="type">int</span> weight = goodness(p, this_cpu, prev-&gt;active_mm);</span><br><span class="line">            <span class="keyword">if</span> (weight &gt; c)</span><br><span class="line">                c = weight, next = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果`c`为 0，说明运行队列中所有进程的权值都为 0，也就是分配给各个进程的时间片都已用完，需重新计算各个进程的时间片 */</span></span><br><span class="line">    <span class="keyword">if</span> (!c) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">        spin_unlock_irq(&amp;runqueue_lock);<span class="comment">/*锁住运行队列*/</span></span><br><span class="line">        read_lock(&amp;tasklist_lock); <span class="comment">/* 锁住进程的双向链表*/</span></span><br><span class="line">        for_each_task(p) <span class="comment">/* 对系统中的每个进程*/</span></span><br><span class="line">        p-&gt;counter = (p-&gt;counter &gt;&gt; <span class="number">1</span>) + NICE_TO_TICKS(p-&gt;nice);</span><br><span class="line">        read_unlock(&amp;tasklist_lock);</span><br><span class="line">        spin_lock_irq(&amp;runqueue_lock); </span><br><span class="line">        <span class="keyword">goto</span> repeat_schedule;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irq(&amp;runqueue_lock);<span class="comment">/*对运行队列解锁，并开中断*/</span></span><br><span class="line">    <span class="keyword">if</span> (prev == next) &#123; <span class="comment">/*如果选中的进程就是原来的进程*/</span></span><br><span class="line">        prev-&gt;policy &amp;= ~SCHED_YIELD;</span><br><span class="line">        <span class="keyword">goto</span> same_process;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 下面开始进行进程切换*/</span></span><br><span class="line">    kstat.context_swtch++; <span class="comment">/*统计上下文切换的次数*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> next-&gt;mm;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">oldmm</span> =</span> prev-&gt;active_mm;</span><br><span class="line">        <span class="keyword">if</span> (!mm) &#123; <span class="comment">/*如果是内核线程，则借用`prev`的地址空间*/</span></span><br><span class="line">            <span class="keyword">if</span> (next-&gt;active_mm) BUG();</span><br><span class="line">            next-&gt;active_mm = oldmm;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/*如果是一般进程，则切换到`next`的用户空间*/</span></span><br><span class="line">            <span class="keyword">if</span> (next-&gt;active_mm != mm) BUG();</span><br><span class="line">            switch_mm(oldmm, mm, next, this_cpu);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!prev-&gt;mm) &#123; <span class="comment">/*如果切换出去的是内核线程*/</span></span><br><span class="line">            prev-&gt;active_mm = <span class="literal">NULL</span>;<span class="comment">/*归还它所借用的地址空间*/</span></span><br><span class="line">            mmdrop(oldmm); <span class="comment">/*mm_struct`中的共享计数减 1*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch_to(prev, next, prev); <span class="comment">/*进程的真正切换，即堆栈的切换*/</span></span><br><span class="line">    __schedule_tail(prev); <span class="comment">/*置`prev-&gt;policy`的`SCHED_YIELD`为 0 */</span></span><br><span class="line">same_process:</span><br><span class="line">    reacquire_kernel_lock(current);<span class="comment">/*针对`SMP*/</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;need_resched) <span class="comment">/*如果调度标志被置位*/</span></span><br><span class="line">        <span class="keyword">goto</span> need_resched_back; <span class="comment">/*重新开始调度*/</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果当前进程既没有自己的地址空间，也没有向别的进程借用地址空间，那肯定出错。另外，如果<code>schedule()</code>在中断服务程序内部执行，那也出错。</li>
<li>对当前进程做相关处理，为选择下一个进程做好准备。当前进程就是正在运行着的进程，可是，当进入<code>schedule()</code>时，其状态却不一定是<code>TASK_RUNNIG</code>，例如，在<code>exit()</code>系统调用中，当前进程的状态可能已被改为<code>TASK_ZOMBE</code>；又例如，在<code>wait4()</code>系统调用中，当前进程的状态可能被置为<code>TASK_INTERRUPTIBLE</code>。因此，如果当前进程处于这些状态中的一种，就要把它从运行队列中删除。</li>
<li>从运行队列中选择最值得运行的进程，也就是权值最大的进程。</li>
<li>如果已经选择的进程其权值为 0，说明运行队列中所有进程的时间片都用完了(队列中肯定没有实时进程，因为其最小权值为 1000)，因此，重新计算所有进程的时间片，其中宏操作<code>NICE_TO_TICKS</code>就是把优先级<code>nice</code>转换为时钟滴答。</li>
<li>进程地址空间的切换。如果新进程有自己的用户空间，也就是说，如果<code>next-&gt;mm</code>与<code>next-&gt;active_mm</code>相同，那么，<code>switch_mm()</code>函数就把该进程从内核空间切换到用户空间，也就是加载<code>next</code>的页目录。如果新进程无用户空间(<code>next-&gt;mm</code>为空)，也就是说，如果它是一个内核线程，那它就要在内核空间运行，因此，需要借用前一个进程(prev)的地址空间，因为所有进程的内核空间都是共享的，因此，这种借用是有效的。</li>
<li>用宏<code>switch_to()</code>进行真正的进程切换。</li>
</ul>
<h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换，任务切换，或上下文切换。Intel<code>在</code>i386 系统结构的设计中考虑到了进程(任务)的管理和调度，并从硬件上支持任务之间的切换。</p>
<h3 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h3><p>Intel i386 体系结构包括了一个特殊的段类型，叫任务状态段(TSS)。<br><img src="/img/1633444585.jpg" alt=""></p>
<p>每个任务包含有它自己最小长度为 104 字节的<code>TSS</code>段，在<code>/include/i386/processor.h</code>中定义为<code>tss_struct</code>结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> back_link,__blh;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> esp0;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ss0,__ss0h;<span class="comment">/*0 级堆栈指针，即Linux中的内核级 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> esp1;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ss1,__ss1h; <span class="comment">/* 1 级堆栈指针，未用*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> esp2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ss2,__ss2h; <span class="comment">/* 2 级堆栈指针，未用*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> __cr3;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eflags; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eax,ecx,edx,ebx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> esp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ebp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> esi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> edi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> es, __esh;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> cs, __csh;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ss, __ssh;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ds, __dsh;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> fs, __fsh;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> gs, __gsh;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ldt, __ldth;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> trace, bitmap;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> io_bitmap[IO_BITMAP_SIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * pads the TSS to be cacheline-aligned (size is 0x100)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> __cacheline_filler[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>每个<code>TSS</code>有它自己 8 字节的任务段描述符(Task State Segment Descriptor ，简称<code>TSSD</code>)。这个描述符包括指向<code>TSS</code>起始地址的 32 位基地址域，20 位界限域，界限域值不能小于十进制 104(由<code>TSS</code>段的最小长度决定)。<code>TSS</code>描述符存放在<code>GDT</code>中，它是<code>GDT</code>中的一个表项。</p>
<p>后面将会看到，Linux在进程切换时，只用到<code>TSS</code>中少量的信息，因此Linux内核定义了另外一个数据结构，这就是<code>thread_struct</code>结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> esp0;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eip;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> esp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> fs;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> gs;</span><br><span class="line">    <span class="comment">/* Hardware debugging registers */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> debugreg[<span class="number">8</span>]; <span class="comment">/* %%db0-7 debug registers */</span></span><br><span class="line">    <span class="comment">/* fault info */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cr2, trap_no, error_code;</span><br><span class="line">    <span class="comment">/* floating point info */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">i387_union</span> <span class="title">i387</span>;</span></span><br><span class="line">    <span class="comment">/* virtual 86 mode info */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm86_struct</span> * <span class="title">vm86_info</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> screen_bitmap;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> v86flags, v86mask, v86mode, saved_esp0;</span><br><span class="line">    <span class="comment">/* IO permissions */</span></span><br><span class="line">    <span class="type">int</span> ioperm;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> io_bitmap[IO_BITMAP_SIZE+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>用这个数据结构来保存<code>cr2</code>寄存器、浮点寄存器、调试寄存器及指定给Intel 80x86 处理器的其他各种各样的信息。需要位图是因为<code>ioperm()</code> 及<code>iopl()</code>系统调用可以允许用户态的进程直接访问特殊的<code>I/O</code>端口。尤其是，如果把<code>eflag</code>寄存器中的<code>IOPL</code>域设置为 3，就允许用户态的进程访问对应的<code>I/O</code>访问权位图位为 0 的任何一个<code>I/O</code>端口。</p>
<h3 id="进程切换-1"><a href="#进程切换-1" class="headerlink" title="进程切换"></a>进程切换</h3><p>前面所介绍的<code>schedule()</code>中调用了<code>switch_to</code>宏，这个宏实现了进程之间的真正切换，其代码存放于<code>include/i386/system.h</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> switch_to(prev,next,last) do &#123; \</span></span><br><span class="line"><span class="meta">    asm volatile(<span class="string">&quot;pushl %%esi\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;pushl %%edi\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;pushl %%ebp\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;movl %%esp,%0\n\t&quot;</span> <span class="comment">/* save ESP */</span> \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;movl %3,%%esp\n\t&quot;</span> <span class="comment">/* restore ESP */</span> \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;movl $1f,%1\n\t&quot;</span> <span class="comment">/* save EIP */</span> \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;pushl %4\n\t&quot;</span> <span class="comment">/* restore EIP */</span> \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;jmp __switch_to\n&quot;</span> \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;1:\t&quot;</span> \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;popl %%ebp\n\t&quot;</span> \</span></span><br><span class="line"><span class="meta">    <span class="string">&quot;popl %%edi\n\t&quot;</span> \ </span></span><br><span class="line">    <span class="string">&quot;popl %%esi\n\t&quot;</span> \</span><br><span class="line">    :<span class="string">&quot;=m&quot;</span> (prev-&gt;thread.esp),<span class="string">&quot;=m&quot;</span> (prev-&gt;thread.eip), \</span><br><span class="line">    <span class="string">&quot;=b&quot;</span> (last) \</span><br><span class="line">    :<span class="string">&quot;m&quot;</span> (next-&gt;thread.esp),<span class="string">&quot;m&quot;</span> (next-&gt;thread.eip), \</span><br><span class="line">    <span class="string">&quot;a&quot;</span> (prev), <span class="string">&quot;d&quot;</span> (next), \</span><br><span class="line">    <span class="string">&quot;b&quot;</span> (prev)); \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p><code>switch_to</code>宏是用嵌入式汇编写成。</p>
<ul>
<li><code>thread</code>的类型为前面介绍的<code>thread_struct</code>结构。</li>
<li>输出参数有 3 个，表示这段代码执行后有 3 项数据会有变化，它们与变量及寄存器的对应关系如下：<ul>
<li>0%与<code>prev-&gt;thread.esp</code>对应，1%与<code>prev-&gt;thread.eip</code>对应，这两个参数都存放在内存，而 2%与<code>ebx</code>寄存器对应，同时说明<code>last</code>参数存放在<code>ebx</code>寄存器中。</li>
</ul>
</li>
<li>输入参数有 5 个，其对应关系如下：<ul>
<li>3%与<code>next-&gt;thread.esp</code>对应，4%与<code>next-&gt;thread.eip</code>对应，这两个参数都存放在内存，而 5%、6%和 7%分别与<code>eax、edx</code>及<code>ebx</code>相对应，同时说明<code>prev、next</code>以及<code>prev</code>这 3个参数分别放在这 3 个寄存器中。</li>
</ul>
</li>
<li>第 2～4 行就是在当前进程<code>prev</code>的内核栈中保存<code>esi、edi</code>及<code>ebp</code>寄存器的内容。</li>
<li>第 5 行将<code>prev</code>的内核堆栈指针<code>ebp</code>存入<code>prev-&gt;thread.esp</code>中。</li>
<li>第 6 行把将要运行进程<code>next</code>的内核栈指针<code>next-&gt;thread.esp</code>置入<code>esp</code>寄存器中。从现在开始，内核对<code>next</code>的内核栈进行操作，因此，这条指令执行从<code>prev</code>到<code>next</code>真正的上下文切换，因为进程描述符的地址与其内核栈的地址紧紧地联系在一起，因此，改变内核栈就意味着改变当前进程。如果此处引用<code>current，那就已经指向</code>next<code>的</code>task_struct`结构了。从这个意义上说，进程的切换在这一行指令执行完以后就已经完成。但是，构成一个进程的另一个要素是程序的执行，这方面的切换尚未完成。</li>
<li>第 7 行将标号“1”所在的地址，也就是第一条<code>popl</code>指令所在的地址保存在<code>prev-&gt;thread.eip</code>中，这个地址就是<code>prev</code>下一次被调度运行而切入时的“返回”地址。</li>
<li>第 8 行将<code>next-&gt;thread.eip</code>压入<code>next</code>的内核栈。那么，<code>next-&gt;thread.eip</code>究竟指向那个地址？实际上，它就是<code>next</code>上一次被调离时通过第 7 行保存的地址，也就是第 11 行<code>popl</code>指令的地址。因为，每个进程被调离时都要执行这里的第 7 行，这就决定了每个进程(除了新创建的进程)在受到调度而恢复执行时都从这里的第 11 行开始。</li>
<li>第 9 行通过<code>jump</code>指令(而不是<code>call</code>指令)转入一个函数<code>__switch_to()</code>。这个函数的具体实现将在下面介绍。当CPU执行到<code>__switch_to()</code>函数的<code>ret</code>指令时，最后进入堆栈的<code>next-&gt;thread.eip</code>就变成了返回地址，这就是标号“1”的地址。</li>
<li>第 11～13 行恢复<code>next</code>上次被调离时推进堆栈的内容。从现在开始，next`进程就成为当前进程而真正开始执行。</li>
</ul>
<p>下面我们来讨论<code>__switch_to()</code>函数。在调用<code>__switch_to()</code>函数之前，对其定义了<code>fastcall</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">FASTCALL</span><span class="params">(__switch_to(<span class="keyword">struct</span> task_struct *prev, <span class="keyword">struct</span> task_struct *next))</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>fastcall</code>对函数的调用不同于一般函数的调用，因为<code>__switch_to()</code>从寄存器取参数，而不像一般函数那样从堆栈取参数，也就是说，通过寄存器<code>eax</code>和<code>edx</code>把<code>prev</code>和<code>next</code>参数传递给<code>__switch_to()</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __switch_to(<span class="keyword">struct</span> task_struct *prev_p, <span class="keyword">struct</span> task_struct *next_p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">prev</span> =</span> &amp;prev_p-&gt;thread,</span><br><span class="line">    *next = &amp;next_p-&gt;thread;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> *<span class="title">tss</span> =</span> init_tss + smp_processor_id();</span><br><span class="line">    unlazy_fpu(prev_p);<span class="comment">/* 如果数学处理器工作，则保存其寄存器的值*/</span></span><br><span class="line">    <span class="comment">/* 将`TSS`中的内核级(0 级)堆栈指针换成`next-&gt;esp0，这就是`next`进程在内核栈的指针*/</span></span><br><span class="line"></span><br><span class="line">    tss-&gt;esp0 = next-&gt;esp0;</span><br><span class="line">    <span class="comment">/* 保存`fs`和`gs，但无需保存`es`和`ds，因为当处于内核时，内核段总是保持不变*/</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;movl %%fs,%0&quot;</span>:<span class="string">&quot;=m&quot;</span> (*(<span class="type">int</span> *)&amp;prev-&gt;fs))</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;movl %%gs,%0&quot;</span>:<span class="string">&quot;=m&quot;</span> (*(<span class="type">int</span> *)&amp;prev-&gt;gs))</span>;</span><br><span class="line">    <span class="comment">/*恢复`next`进程的`fs`和`gs */</span></span><br><span class="line">    loadsegment(fs, next-&gt;fs);</span><br><span class="line">    loadsegment(gs, next-&gt;gs);</span><br><span class="line">    <span class="comment">/* 如果`next`挂起时使用了调试寄存器，则装载 0～7 个寄存器中的 6 个寄存器，其中第 4、5 个寄存器没有使用 */</span></span><br><span class="line">    <span class="keyword">if</span> (next-&gt;debugreg[<span class="number">7</span>])&#123;</span><br><span class="line">        loaddebug(next, <span class="number">0</span>);</span><br><span class="line">        loaddebug(next, <span class="number">1</span>); </span><br><span class="line">        loaddebug(next, <span class="number">2</span>);</span><br><span class="line">        loaddebug(next, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">/* no 4 and 5 */</span></span><br><span class="line">        loaddebug(next, <span class="number">6</span>);</span><br><span class="line">        loaddebug(next, <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;ioperm || next-&gt;ioperm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (next-&gt;ioperm) &#123;</span><br><span class="line">            <span class="comment">/*把`next`进程的`I/O`操作权限位图拷贝到`TSS`中 */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(tss-&gt;io_bitmap, next-&gt;io_bitmap,</span><br><span class="line">            IO_BITMAP_SIZE*<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>));</span><br><span class="line">            <span class="comment">/* 把`io_bitmap`在`tss`中的偏移量赋给`tss-&gt;bitmap */</span></span><br><span class="line">            tss-&gt;bitmap = IO_BITMAP_OFFSET;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*如果一个进程要使用`I/O`指令，但是，若位图的偏移量超出`TSS`的范围，</span></span><br><span class="line"><span class="comment">            就会产生一个可控制的`SIGSEGV`信号。第一次对`sys_ioperm()的调用会</span></span><br><span class="line"><span class="comment">            建立起适当的位图 */</span></span><br><span class="line"></span><br><span class="line">            tss-&gt;bitmap = INVALID_IO_BITMAP_OFFSET;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的描述我们看到，尽管<code>Intel</code>本身为操作系统中的进程(任务)切换提供了硬件支持，但是Linux内核的设计者并没有完全采用这种思想，而是用软件实现了进程切换，而且，软件实现比硬件实现的效率更高，灵活性更大。</p>
<h1 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h1><h2 id="Linux的内存管理概述"><a href="#Linux的内存管理概述" class="headerlink" title="Linux的内存管理概述"></a>Linux的内存管理概述</h2><p>Linux的内存管理主要体现在对虚拟内存的管理。我们可以把Linux虚拟内存管理功能概括为以下几点：</p>
<ul>
<li>大地址空间；</li>
<li>进程保护；</li>
<li>内存映射；</li>
<li>公平的物理内存分配；</li>
<li>共享虚拟内存。</li>
</ul>
<h3 id="Linux虚拟内存的实现结构"><a href="#Linux虚拟内存的实现结构" class="headerlink" title="Linux虚拟内存的实现结构"></a>Linux虚拟内存的实现结构</h3><p>我们先从整体结构上了解Linux对虚拟内存的实现结构。<br><img src="/img/1633446571.jpg" alt=""></p>
<ol>
<li>内存映射模块(mmap)：负责把磁盘文件的逻辑地址映射到虚拟地址，以及把虚拟地址映射到物理地址。</li>
<li>交换模块(swap)：负责控制内存内容的换入和换出，它通过交换机制，使得在物理内存的页面(RAM`页)中保留有效的页 ，即从主存中淘汰最近没被访问的页，保存近来访问过的页。</li>
<li>核心内存管理模块(core)：负责核心内存管理功能，即对页的分配、回收、释放及请页处理等，这些功能将被别的内核子系统(如文件系统)使用。</li>
<li>结构特定的模块：负责给各种硬件平台提供通用接口，这个模块通过执行命令来改变硬件<code>MMU</code>的虚拟地址映射，并在发生页错误时，提供了公用的方法来通知别的内核子系统。这个模块是实现虚拟内存的物理基础。</li>
</ol>
<h3 id="内核空间和用户空间"><a href="#内核空间和用户空间" class="headerlink" title="内核空间和用户空间"></a>内核空间和用户空间</h3><p>Linux的虚拟地址空间也为 0～4G字节。Linux内核将这 4G 字节的空间分为两部分。将最高的 1G 字节(从虚拟地址 0xC0000000 到 0xFFFFFFFF)，供内核使用，称为“内核空间”。而将较低的 3G 字节(从虚拟地址 0x00000000 到 0xBFFFFFFF)，供各个进程使用，称为“用户空间”。因为每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有 4G 字节的虚拟空间。</p>
<p>Linux使用两级保护机制：0 级供内核使用，3 级供用户程序使用。每个进程有各自的私有用户空间(0～3G)，这个空间对系统中的其他进程是不可见的。最高的 1G`字节虚拟内核空间则为所有进程以及内核所共享。</p>
<h4 id="虚拟内核空间到物理空间的映射"><a href="#虚拟内核空间到物理空间的映射" class="headerlink" title="虚拟内核空间到物理空间的映射"></a>虚拟内核空间到物理空间的映射</h4><p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。不管是内核空间还是用户空间，它们都处于虚拟空间中。虽然内核空间占据了每个虚拟空间中的最高 1G 字节，但映射到物理内存却总是从最低地址(0x00000000)开始。如图 6.4 所示，对内核空间来说，其地址映射是很简单的线性映射，0xC0000000就是物理地址与线性地址之间的位移量，在Linux代码中就叫做<code>PAGE_OFFSET</code>。</p>
<p>我们来看一下在<code>include/asm/i386/page.h</code>中对内核空间中地址映射的说明及定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This handles the memory map.. We could make this a config</span></span><br><span class="line"><span class="comment">* option, but too many people screw it up, and too few need</span></span><br><span class="line"><span class="comment">* it.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* A __PAGE_OFFSET of 0xC0000000 means that the kernel has</span></span><br><span class="line"><span class="comment">* a virtual address space of one gigabyte, which limits the</span></span><br><span class="line"><span class="comment">* amount of physical memory you can use to about 950MB.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* If you want more physical memory than this then see the CONFIG_HIGHMEM4G</span></span><br><span class="line"><span class="comment">* and CONFIG_HIGHMEM64G options in the kernel configuration.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PAGE_OFFSET (0xC0000000)</span></span><br><span class="line">……</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_OFFSET ((unsigned long)__PAGE_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pa(x) ((unsigned long)(x)-PAGE_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __va(x) ((void *)((unsigned long)(x)+PAGE_OFFSET))</span></span><br></pre></td></tr></table></figure></p>
<p>源代码的注释中说明，如果你的物理内存大于 950MB，那么在编译内核时就需要加<code>CONFIG_HIGHMEM4G</code>和<code>CONFIG_HIGHMEM64G</code>选项，这种情况我们暂不考虑。如果物理内存小于950MB，则对于内核空间而言，给定一个虚地址<code>x，其物理地址为</code>x - PAGE_OFFSET<code>，给定一个物理地址</code>x，其虚地址为<code>x + PAGE_OFFSET</code>。这里再次说明，宏<code>__pa()</code>仅仅把一个内核空间的虚地址映射到物理地址，而决不适用于用户空间，用户空间的地址映射要复杂得多。</p>
<h4 id="内核映像"><a href="#内核映像" class="headerlink" title="内核映像"></a>内核映像</h4><p>在下面的描述中，我们把内核的代码和数据就叫内核映像(Kernel Image)。当系统启动时，Linux内核映像被安装在物理地址 0x00100000 开始的地方，即 1MB 开始的区间(第 1M 留作它用)。然而，在正常运行时， 整个内核映像应该在虚拟内核空间中，因此，连接程序在连接内核映像时，在所有的符号地址上加一个偏移量<code>PAGE_OFFSET</code>，这样，内核映像在内核空间的起始地址就为 0xC0100000。</p>
<p>例如，进程的页目录PGD(属于内核数据结构)就处于内核空间中。在进程切换时，要将寄存器<code>CR3</code>设置成指向新进程的页目录PGD，而该目录的起始地址在内核空间中是虚地址，但<code>CR3</code>所需要的是物理地址，这时候就要用<code>__pa()</code>进行地址转换。在<code>mm_context.h</code>中就有这么一行语句：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;movl %0,%%cr3&quot;</span>: :<span class="string">&quot;r&quot;</span> (__pa(next-&gt;pgd));</span></span><br></pre></td></tr></table></figure></p>
<p>这是一行嵌入式汇编代码，其含义是将下一个进程的页目录起始地址<code>next_pgd</code>，通过<code>__pa()</code>转换成物理地址，存放在某个寄存器中，然后用<code>mov</code>指令将其写入 CR3 寄存器中。经过这行语句的处理，CR3 就指向新进程<code>next</code>的页目录表<code>PGD</code>了。</p>
<h3 id="虚拟内存实现机制间的关系"><a href="#虚拟内存实现机制间的关系" class="headerlink" title="虚拟内存实现机制间的关系"></a>虚拟内存实现机制间的关系</h3><p>Linux虚拟内存的实现需要各种机制的支持，因此，本章我们将对内存的初始化进行描述以后，围绕以下几种实现机制进行介绍：</p>
<ul>
<li>内存分配和回收机制；</li>
<li>地址映射机制；</li>
<li>缓存和刷新机制；</li>
<li>请页机制；</li>
<li>交换机制；</li>
<li>内存共享机制。</li>
</ul>
<p><img src="/img/1633499471.jpg" alt=""></p>
<ul>
<li>首先内存管理程序通过映射机制把用户程序的逻辑地址映射到物理地址，在用户程序运行时如果发现程序中要用的虚地址没有对应的物理内存时，就发出了请页要求①；</li>
<li>如果有空闲的内存可供分配，就请求分配内存②(于是用到了内存的分配和回收)，</li>
<li>并把正在使用的物理页记录在页缓存中③(使用了缓存机制)。</li>
<li>如果没有足够的内存可供分配，那么就调用交换机制，腾出一部分内存④⑤。</li>
<li>另外在地址映射中要通过`TLB(翻译后援存储器)来寻找物理页⑧；</li>
<li>交换机制中也要用到交换缓存⑥；</li>
<li>并且把物理页内容交换到交换文件中后也要修改页表来映射文件地址⑦。</li>
</ul>
<h2 id="Linux内存管理的初始化"><a href="#Linux内存管理的初始化" class="headerlink" title="Linux内存管理的初始化"></a>Linux内存管理的初始化</h2><h3 id="启用分页机制"><a href="#启用分页机制" class="headerlink" title="启用分页机制"></a>启用分页机制</h3><p>当Linux启动时，首先运行在实模式下，随后就要转到保护模式下运行。Linux内核代码的入口点就是<code>/arch/i386/kernel/head.S</code>中的<code>startup_32</code>。</p>
<h4 id="页表的初步初始化"><a href="#页表的初步初始化" class="headerlink" title="页表的初步初始化"></a>页表的初步初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The page tables are initialized to only 8MB here - the final page</span></span><br><span class="line"><span class="comment"> * tables are set up later depending on memory size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.org <span class="number">0x2000</span></span><br><span class="line">ENTRY(pg0)</span><br><span class="line"></span><br><span class="line">.org <span class="number">0x3000</span></span><br><span class="line">ENTRY(pg1)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * empty_zero_page must immediately follow the page tables ! (The</span></span><br><span class="line"><span class="comment"> * initialization loop counts until empty_zero_page)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.org <span class="number">0x4000</span></span><br><span class="line">ENTRY(empty_zero_page)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Initialize page tables</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">    movl $pg0-__PAGE_OFFSET,%edi <span class="comment">/* initialize page tables */</span></span><br><span class="line">    movl $<span class="number">007</span>,%eax <span class="comment">/* &quot;007&quot; doesn&#x27;t mean with right to kill, but PRESENT+RW+USER */</span></span><br><span class="line"><span class="number">2</span>: stosl</span><br><span class="line">    add $<span class="number">0x1000</span>,%eax</span><br><span class="line">    cmp $empty_zero_page-__PAGE_OFFSET,%edi</span><br><span class="line">    jne <span class="number">2b</span></span><br></pre></td></tr></table></figure>
<p>内核的这段代码执行时，因为页机制还没有启用，还没有进入保护模式，因此指令寄存器<code>EIP</code>中的地址还是物理地址，但因为<code>pg0</code>中存放的是虚拟地址(gcc编译内核以后形成的符号地址都是虚拟地址)，因此，<code>$pg0-__PAGE_OFFSET</code>获得<code>pg0</code>的物理地址，可见<code>pg0</code>存放在相对于内核代码起点为 0x2000 的地方，即物理地址为 0x00102000，而<code>pg1</code>的物理地址则为 0x00103000。<code>pg0</code>和<code>pg1</code>这个两个页表中的表项则依次被设置为 0x007、0x1007、0x2007等。其中最低的 3 位均为 1，表示这两个页为用户页，可写，且页的内容在内存中。所映射的物理页的基地址则为 0x0、0x1000、0x2000 等，也就是物理内存中的页面 0、1、2、3 等等，共映射 2K个页面，即 8MB 的存储空间。由此可以看出，Linux内核对物理内存的最低要求为 8MB。紧接着存放的是<code>empty_zero_page</code>页(即零页)，零页存放的是系统启动参数和命令行参数。</p>
<h4 id="启用分页机制-1"><a href="#启用分页机制-1" class="headerlink" title="启用分页机制"></a>启用分页机制</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is initialized to create an identity-mapping at 0-8M (for bootup</span></span><br><span class="line"><span class="comment"> * purposes) and another mapping of the 0-8M area at virtual address</span></span><br><span class="line"><span class="comment"> * PAGE_OFFSET.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">.org <span class="number">0x1000</span></span><br><span class="line">ENTRY(swapper_pg_dir)</span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00102007</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00103007</span></span><br><span class="line">    .fill BOOT_USER_PGD_PTRS<span class="number">-2</span>,<span class="number">4</span>,<span class="number">0</span></span><br><span class="line"><span class="comment">/* default: 766 entries */</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00102007</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00103007</span></span><br><span class="line"><span class="comment">/* default: 254 entries */</span></span><br><span class="line">    .fill BOOT_KERNEL_PGD_PTRS<span class="number">-2</span>,<span class="number">4</span>,<span class="number">0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Enable paging</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="number">3</span>:</span><br><span class="line">    movl $swapper_pg_dir-__PAGE_OFFSET,%eax</span><br><span class="line">    movl %eax,%cr3 <span class="comment">/* set the page table pointer.. */</span></span><br><span class="line">    movl %cr0,%eax</span><br><span class="line">    orl $<span class="number">0x80000000</span>,%eax</span><br><span class="line">    movl %eax,%cr0 <span class="comment">/* ..and set paging (PG) bit */</span></span><br><span class="line">    jmp <span class="number">1f</span> <span class="comment">/* flush the prefetch-queue */</span></span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">    movl $<span class="number">1f</span>,%eax </span><br><span class="line">    jmp *%eax <span class="comment">/* make sure eip is relocated */</span></span><br><span class="line"><span class="number">1</span>:</span><br></pre></td></tr></table></figure>
<p>我们先来看这段代码的功能。这段代码就是把页目录<code>swapper_pg_dir</code>的物理地址装入控制寄存器<code>cr3，并把</code>cr0 中的最高位置成 1，这就开启了分页机制。但是，启用了分页机制，并不说明Linux内核真正进入了保护模式，因为此时，指令寄存器<code>EIP</code>中的地址还是物理地址，而不是虚地址。<code>jmp 1f</code>指令从逻辑上说不起什么作用，但是，从功能上说它起到丢弃指令流水线中内容的作用，因为这是一个短跳转，<code>EIP</code>中还是物理地址。紧接着的<code>mov</code>和<code>jmp</code>指令把第 2 个标号为 1 的地址装入<code>EAX</code>寄存器并跳转到那儿。在这两条指令执行的过程中, <code>EIP</code>还是指向物理地址“1MB＋某处”。因为编译程序使所有的符号地址都在虚拟内存空间中，因此，第 2 个标号 1 的地址就在虚拟内存空间的某处(PAGE_OFFSET+某处)，于是，<code>jmp</code>指令执行以后，EIP`就指向虚拟内核空间的某个地址，这就使CPU转入了内核空间，从而完成了从实模式到保护模式的平稳过渡。</p>
<p>然后再看页目录<code>swapper_pg_dir</code>中的内容。从前面的讨论我们知道<code>pg0 和</code>pg1 这两个页表的起始物理地址分别为 0x00102000 和 0x00103000。页目录项的最低 12位用来描述页表的属性。因此，在<code>swapper_pg_dir</code>中的第 0 和第 1 个目录项 0x00102007、0x00103007，就表示<code>pg0 和</code>pg1 这两个页表是用户页表、可写且页表的内容在内存。接着，把<code>swapper_pg_dir</code>中的第 2～767 共 766 个目录项全部置为 0。因为一个页表的大小为 4KB，每个表项占 4 个字节，即每个页表含有 1024 个表项，每个页的大小也为 4KB，因此这 768 个目录项所映射的虚拟空间为 768×1024×4K＝3G，也就是<code>swapper_pg_dir</code>表中的前 768 个目录项映射的是用户空间。</p>
<p>最后，在第 768 和 769 个目录项中又存放<code>pg0 和</code>pg1 这两个页表的地址和属性，而把第770～1023 共 254 个目录项置 0。这 256 个目录项所映射的虚拟地址空间为 256×1024×4K＝1G，也就是<code>swapper_pg_dir</code>表中的后 256 个目录项映射的是内核空间。由此可以看出，在初始的页目录<code>swapper_pg_dir</code>中，用户空间和内核空间都只映射了开头的两个目录项，即 8MB`的空间，而且有着相同的映射，如图 6.6 所示。<br><img src="/img/1633533810.jpg" alt=""></p>
<p>当CPU进入内核代码的起点<code>startup_32</code>后，是以物理地址来取指令的。在这种情况下，如果页目录只映射内核空间，而不映射用户空间的低区，则一旦开启页映射机制以后就不能继续执行了，这是因为，此时CPU中的指令寄存器<code>EIP</code>仍指向低区，仍会以物理地址取指令，直到以某个符号地址为目标作绝对转移或调用子程序为止。所以，Linux内核就采取了上述的解决办法。</p>
<p>但是，在CPU转入内核空间以后，应该把用户空间低区的映射清除掉。页目录<code>swapper_pg_dir</code>经扩充后就成为所有内核线程的页目录。在内核线程的正常运行中，处于内核态的CPU是不应该通过用户空间的虚拟地址访问内存的。清除了低区的映射以后，如果发生CPU在内核中通过用户空间的虚拟地址访问内存，就可以因为产生页面异常而捕获这个错误。</p>
<h4 id="物理内存的初始分布"><a href="#物理内存的初始分布" class="headerlink" title="物理内存的初始分布"></a>物理内存的初始分布</h4><p>经过这个阶段的初始化，初始化阶段页目录及几个页表在物理空间中的位置如图 6.7 所示。<br><img src="/img/1633534143.jpg" alt=""></p>
<p>其中<code>empty_zero_page</code>中存放的是在操作系统的引导过程中所收集的一些数据，叫做引导参数。因为这个页面开始的内容全为 0，所以叫做“零页”，代码中常常通过宏定义<code>ZERO_PAGE</code>来引用这个页面。不过，这个页面要到初始化完成，系统转入正常运行时才会用到。这里假定这些参数已被复制到“零页”，在<code>setup.c</code>中定义了引用这些参数的宏：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is set up by the setup-routine at boot-time</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PARAM ((unsigned char *)empty_zero_page)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCREEN_INFO (*(struct screen_info *) (PARAM+0)) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT_MEM_K (*(unsigned short *) (PARAM+2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALT_MEM_K (*(unsigned long *) (PARAM+0x1e0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E820_MAP_NR (*(char*) (PARAM+E820NR))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E820_MAP ((struct e820entry *) (PARAM+E820MAP))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APM_BIOS_INFO (*(struct apm_bios_info *) (PARAM+0x40))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DRIVE_INFO (*(struct drive_info_struct *) (PARAM+0x80))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_DESC_TABLE (*(struct sys_desc_table_struct*)(PARAM+0xa0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOUNT_ROOT_RDONLY (*(unsigned short *) (PARAM+0x1F2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAMDISK_FLAGS (*(unsigned short *) (PARAM+0x1F8))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORIG_ROOT_DEV (*(unsigned short *) (PARAM+0x1FC))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUX_DEVICE_INFO (*(unsigned char *) (PARAM+0x1FF))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOADER_TYPE (*(unsigned char *) (PARAM+0x210))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNEL_START (*(unsigned long *) (PARAM+0x214))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INITRD_START (*(unsigned long *) (PARAM+0x218))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INITRD_SIZE (*(unsigned long *) (PARAM+0x21c))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMAND_LINE ((char *) (PARAM+2048))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMAND_LINE_SIZE 256</span></span><br></pre></td></tr></table></figure></p>
<p>其中宏<code>PARAM</code>就是<code>empty_zero_page</code>的起始位置。</p>
<p>这里要特别对宏<code>E820_MAP</code>进行说明。<code>E820_MAP</code>是个<code>struct e820entry</code>数据结构的指针，存放在参数块中位移为 0x2d0 的地方。这个数据结构定义在<code>include/i386/e820.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> nr_map;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">e820entry</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr; <span class="comment">/* start of memory segment */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> size; <span class="comment">/* size of memory segment */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> type; <span class="comment">/* type of memory segment */</span></span><br><span class="line">    &#125; <span class="built_in">map</span>[E820MAX];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> <span class="title">e820</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>其中，<code>E820MAX</code>被定义为 32。从这个数据结构的定义可以看出，每个<code>e820entry</code>都是对一个物理区间的描述，并且一个物理区间必须是同一类型。如果有一片地址连续的物理内存空间，其一部分是<code>RAM</code>，而另一部分是<code>ROM，那就要分成两个区间。即使同属RAM，如果其中一部分要保留用于特殊目的，那也属于不同的分区。在</code>e820.h`文件中定义了 4 种不同的类型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> E820_RAM 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E820_RESERVED 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E820_ACPI 3 <span class="comment">/* usable as RAM once ACPI tables have been read */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E820_NVS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGH_MEMORY (1024*1024)</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>E820_NVS</code>表示“Non-Volatile Storage”，即“不挥发”存储器，包括<code>ROM、EPROM、Flash</code>存储器等。</p>
<p>因为历史的原因，把 1MB以上的空间定义为<code>HIGH_MEMORY</code>，这个称呼一直沿用到现在，于是代码中的常数<code>HIGH_MEMORY</code>就定义为“1024×1024”。现在，配备了 128MB 的内存已经是很普遍了。但是，为了保持兼容，就得留出最初 1MB`的空间。这个阶段初始化后，物理内存中内核映像的分布如图 6.8 所示。<br><img src="/img/1633534701.jpg" alt=""></p>
<p>符号<code>_text</code>对应物理地址 0x00100000，表示内核代码的第一个字节的地址。内核代码的结束位置用另一个类似的符号<code>_etext</code>表示。内核数据被分为两组：初始化过的数据和未初始化过的数据。初始化过的数据在<code>_etext</code>后开始，在<code>_edata</code>处结束，紧接着是未初始化过的数据，其结束符号为<code>_end</code>，这也是整个内核映像的结束符号。</p>
<h3 id="物理内存的探测"><a href="#物理内存的探测" class="headerlink" title="物理内存的探测"></a>物理内存的探测</h3><p>BIOS能引导操作系统，还担负着加电自检和对资源的扫描探测，包括了对物理内存的自检和扫描。对于这个阶段中获得的内存信息可以通过<code>BIOS</code>调用<code>int 0x15</code>加以检查。由于Linux内核不能作<code>BIOS</code>调用，因此内核本身就得代为检查，并根据获得的信息生成一幅物理内存构成图，然后通过上面提到的参数块传给内核，使得内核能知道系统中内存资源的配置。之所以称为e820 图，是因为在通过<code>int 0x15</code>查询内存的构成时要把调<br>用参数之一设置成<code>0xe820</code>。</p>
<p>分页机制启用以后，与内存管理相关的操作就是调用<code>init/main.c</code>中的<code>start_kernel()</code>函数，<code>start_kernel()</code>函数要调用一个叫<code>setup_arch()</code>的函数，<code>setup_arch()</code>位于<code>arch/i386/kernel/setup.c</code>文件中，我们所关注的与物理内存探测相关的内容就在这个函数中。</p>
<h4 id="setup-arch-函数"><a href="#setup-arch-函数" class="headerlink" title="setup_arch()函数"></a>setup_arch()函数</h4><ul>
<li>首先调用<code>setup_memory_region()</code>函数，这个函数处理内存构成图(map)，并把内存的分布信息存放在全局变量`e820 中。</li>
<li>调用<code>parse_mem_cmdline(cmdline_p)</code>函数。在特殊的情况下，有的系统可能有特殊的<code>RAM</code>空间结构，此时可以通过引导命令行中的选择项来改变存储空间的逻辑结构，使其正确反映内存的物理结构。此函数的作用就是分析命令行中的选择项，并据此对数据结构e820 中的内容作出修正，其代码也在<code>setup.c</code>中。</li>
</ul>
<p>宏定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_UP(x) (((x) + PAGE_SIZE-1) &gt;&gt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_DOWN(x) ((x) &gt;&gt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN_PHYS(x) ((x) &lt;&lt; PAGE_SHIFT)</span></span><br></pre></td></tr></table></figure></p>
<p><code>PFN_UP()</code>和<code>PFN_DOWN()</code>都是将地址<code>x</code>转换为页面号(PFN即<code>Page Frame Number</code>的缩写)，二者之间的区别为：<code>PFN_UP()</code>返回大于<code>x</code>的第 1 个页面号，而<code>PFN_DOWN()</code>返回小于<code>x</code>的第 1 个页面号。宏<code>PFN_PHYS()</code>返回页面号<code>x</code>的物理地址。</p>
<p>宏定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 128MB for vmalloc and initrd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VMALLOC_RESERVE (unsigned long)(128 &lt;&lt; 20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMEM (unsigned long)(-PAGE_OFFSET-VMALLOC_RESERVE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXMEM_PFN PFN_DOWN(MAXMEM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NONPAE_PFN (1 &lt;&lt; 20)</span></span><br></pre></td></tr></table></figure></p>
<p>对这几个宏描述如下：</p>
<ul>
<li><code>VMALLOC_RESERVE</code>：为<code>vmalloc()</code>函数访问内核空间所保留的内存区，大小为 128MB。</li>
<li><code>MAXMEM</code>：内核能够直接映射的最大<code>RAM</code>容量，为 1GB－128MB＝896MB(-PAGE_OFFSET`就等于 1GB)</li>
<li><code>MAXMEM_PFN</code>：返回由内核能直接映射的最大物理页面数。</li>
<li><code>MAX_NONPAE_PFN</code>：给出在 4GB 之上第 1 个页面的页面号。当页面扩充(PAE)功能启用时，才能访问 4GB 以上的内存。</li>
</ul>
<p>获得内核映像之后的起始页面号：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* partially used pages are not usable - thus</span></span><br><span class="line"><span class="comment">* we are rounding upwards:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">start_pfn = PFN_UP(__pa(&amp;_end));</span><br></pre></td></tr></table></figure></p>
<p>在上一节已说明，宏<code>__pa()</code>返回给定虚拟地址的物理地址。其中标识符<code>_end</code>表示内核映像在内核空间的结束位置。因此，存放在变量<code>start_pfn</code>中的值就是紧接着内核映像之后的页面号。</p>
<p>找出可用的最高页面号：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Find the highest page frame number we have available</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">max_pfn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e820.nr_map; i++) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start, end;</span><br><span class="line">    <span class="comment">/* RAM? */</span></span><br><span class="line">    <span class="keyword">if</span> (e820.<span class="built_in">map</span>[i].type != E820_RAM)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    start = PFN_UP(e820.<span class="built_in">map</span>[i].addr);</span><br><span class="line">    end = PFN_DOWN(e820.<span class="built_in">map</span>[i].addr + e820.<span class="built_in">map</span>[i].size);</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (end &gt; max_pfn)</span><br><span class="line">        max_pfn = end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码循环查找类型为<code>E820_RAM</code>(可用RAM)的内存区，并把最后一个页面的页面号存放在<code>max_pfn</code>中。</p>
<p>确定最高和最低内存范围：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Determine low and high memory ranges:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">max_low_pfn = max_pfn;</span><br><span class="line"><span class="keyword">if</span> (max_low_pfn &gt; MAXMEM_PFN) &#123;</span><br><span class="line">    max_low_pfn = MAXMEM_PFN;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> CONFIG_HIGHMEM</span></span><br><span class="line">        <span class="comment">/* Maximum memory usable is what is directly addressable */</span></span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;Warning only %ldMB will be used.\n&quot;</span>,</span><br><span class="line">        MAXMEM&gt;&gt;<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span> (max_pfn &gt; MAX_NONPAE_PFN)</span><br><span class="line">            printk(KERN_WARNING <span class="string">&quot;Use a PAE enabled kernel.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            printk(KERN_WARNING <span class="string">&quot;Use a HIGHMEM enabled kernel.\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span> <span class="comment">/* !CONFIG_HIGHMEM */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> CONFIG_X86_PAE</span></span><br><span class="line">        <span class="keyword">if</span> (max_pfn &gt; MAX_NONPAE_PFN) &#123;</span><br><span class="line">            max_pfn = MAX_NONPAE_PFN;</span><br><span class="line">            printk(KERN_WARNING <span class="string">&quot;Warning only 4GB will be used.\n&quot;</span>);</span><br><span class="line">            printk(KERN_WARNING <span class="string">&quot;Use a PAE enabled kernel.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !CONFIG_X86_PAE */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !CONFIG_HIGHMEM */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有两种情况：</p>
<ul>
<li>如果物理内存<code>RAM</code>大于 896MB，而小于 4GB，则选用<code>CONFIG_HIGHMEM</code>选项来进行访问；</li>
<li>如果物理内存<code>RAM</code>大于 4GB，则选用<code>CONFIG_X86_PAE</code>(启用<code>PAE</code>模式)来进行访问。</li>
</ul>
<p>上面这段代码检查了这两种情况，并显示适当的警告信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">highstart_pfn = highend_pfn = max_pfn; </span><br><span class="line"><span class="keyword">if</span> (max_pfn &gt; MAXMEM_PFN) &#123;</span><br><span class="line">    highstart_pfn = MAXMEM_PFN;</span><br><span class="line">    printk(KERN_NOTICE <span class="string">&quot;%ldMB HIGHMEM available.\n&quot;</span>,</span><br><span class="line">    pages_to_mb(highend_pfn - highstart_pfn));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>如果使用了<code>CONFIG_HIGHMEM</code>选项，上面这段代码仅仅打印出大于 896MB`的可用物理内存数量。</p>
<p>初始化引导时的分配器<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize the boot-time allocator (with low memory only): */</span></span><br><span class="line">bootmap_size = init_bootmem(start_pfn, max_low_pfn);</span><br></pre></td></tr></table></figure></p>
<p>通过调用<code>init_bootmem()</code>函数，为物理内存页面管理机制的建立做初步准备，为整个物理内存建立起一个页面位图。这个位图建立在从<code>start_pfn</code>开始的地方，也就是说，把内核映像终点<code>_end</code>上方的若干页面用作物理页面位图。在前面的代码中已经搞清楚了物理内存顶点所在的页面号为<code>max_low_pfn</code>，所以物理内存的页面号一定在 0～max_low_pfn`之间。建立这个位图的目的就是要搞清楚哪一些物理内存页面可以动态分配的。</p>
<p>用<code>bootmem</code>分配器，登记全部低区(0～896MB)的可用<code>RAM</code>页面<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Register fully available low RAM pages with the</span></span><br><span class="line"><span class="comment"> * bootmem allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e820.nr_map; i++) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> curr_pfn, last_pfn, size;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Reserve usable low memory</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (e820.<span class="built_in">map</span>[i].type != E820_RAM)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * We are rounding up the start address of usable memory:</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    curr_pfn = PFN_UP(e820.<span class="built_in">map</span>[i].addr);</span><br><span class="line">    <span class="keyword">if</span> (curr_pfn &gt;= max_low_pfn)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * ... and at the end of the usable range downwards:</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    last_pfn = PFN_DOWN(e820.<span class="built_in">map</span>[i].addr + e820.<span class="built_in">map</span>[i].size);</span><br><span class="line">    <span class="keyword">if</span> (last_pfn &gt; max_low_pfn)</span><br><span class="line">        last_pfn = max_low_pfn;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * .. finally, did all the rounding and playing</span></span><br><span class="line"><span class="comment">    * around just make the area go away?</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (last_pfn &lt;= curr_pfn) </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    size = last_pfn - curr_pfn;</span><br><span class="line">    free_bootmem(PFN_PHYS(curr_pfn), PFN_PHYS(size));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个循环仔细检查所有可以使用的RAM，并调用<code>free_bootmem()</code>函数把这些可用<code>RAM</code>标记为可用。这个函数调用以后，只有类型为 1(可用RAM)的内存被标记为可用的。</p>
<p>保留内存：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Reserve the bootmem bitmap itself as well. We do this in two</span></span><br><span class="line"><span class="comment">* steps (first step was init_bootmem()) because this catches</span></span><br><span class="line"><span class="comment">* the (very unlikely) case of us accidentally initializing the</span></span><br><span class="line"><span class="comment">* bootmem allocator with an invalid RAM area.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">reserve_bootmem(HIGH_MEMORY, (PFN_PHYS(start_pfn) +</span><br><span class="line">bootmap_size + PAGE_SIZE<span class="number">-1</span>) - (HIGH_MEMORY));</span><br></pre></td></tr></table></figure></p>
<p>这个函数把内核和<code>bootmem</code>位图所占的内存标记为“保留”。<code>HIGH_MEMORY</code>为 1MB，即内核开始的地方。</p>
<h4 id="setup-memory-region-函数"><a href="#setup-memory-region-函数" class="headerlink" title="setup_memory_region() 函数"></a>setup_memory_region() 函数</h4><p>这个函数用来处理<code>BIOS</code>的内存构成图，并把这个构成图拷贝到全局变量`e820 中。如果操作失败，就创建一个伪内存构成图。这个函数的主要操作如下所述。</p>
<ul>
<li>调用<code>sanitize_e820_map()</code>函数，以删除内存构成图中任何重叠的部分，因为<code>BIOS</code>所报告的内存构成图可能有重叠。</li>
<li>调用<code>copy_e820_map()</code>进行实际的拷贝。</li>
<li>如果操作失败，创建一个伪内存构成图，这个伪构成图有两部分：0 到 640K<code>及 1M</code>到最大物理内存。</li>
<li>打印最终的内存构成图。</li>
</ul>
<h4 id="copy-e820-map-函数"><a href="#copy-e820-map-函数" class="headerlink" title="copy_e820_map() 函数"></a>copy_e820_map() 函数</h4><p>函数原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">sanitize_e820_map</span><span class="params">(<span class="keyword">struct</span> e820entry * biosmap, <span class="type">char</span> * pnr_map)</span></span><br></pre></td></tr></table></figure></p>
<p>其主要操作如下概述。</p>
<ol>
<li><p>如果物理内存区间小于 2，那肯定出错。因为<code>BIOS</code>至少和<code>RAM</code>属于不同的物理区间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nr_map &lt; <span class="number">2</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从<code>BIOS</code>构成图中读出一项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> start = biosmap-&gt;addr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> size = biosmap-&gt;size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> end = start + size; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> type = biosmap-&gt;type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overflow in 64 bits? Ignore the memory map. */</span></span><br><span class="line"><span class="keyword">if</span> (start &gt; end)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些<code>BIOS</code>把 640KB～1MB 之间的区间作为<code>RAM</code>来用，这是不符合常规的。因为从0xA0000 开始的空间用于图形卡，因此，在内存构成图中要进行修正。如果一个区的起点在0xA0000 以下，而终点在 1MB 之上，就要将这个区间拆开成两个区间，中间跳过从 0xA0000到 1MB边界之间的那一部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Some BIOSes claim RAM in the 640k - 1M region.</span></span><br><span class="line"><span class="comment"> * Not right. Fix it up.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (type == E820_RAM) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0x100000U</span>LL &amp;&amp; end &gt; <span class="number">0xA0000U</span>LL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start &lt; <span class="number">0xA0000U</span>LL)</span><br><span class="line">                add_memory_region(start, <span class="number">0xA0000U</span>LL-start, type)</span><br><span class="line">            <span class="keyword">if</span> (end &lt;= <span class="number">0x100000U</span>LL)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            start = <span class="number">0x100000U</span>LL;</span><br><span class="line">            size = end - start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_memory_region(start, size, type);</span><br><span class="line">    &#125; <span class="keyword">while</span> (biosmap++,--nr_map);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="add-memory-region-函数"><a href="#add-memory-region-函数" class="headerlink" title="add_memory_region() 函数"></a>add_memory_region() 函数</h4><p>这个函数的功能就是在`e820 中增加一项，其主要操作如下所述。</p>
<ol>
<li><p>获得已追加在`e820 中的内存区数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = e820.nr_map;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果数目已达到最大(32)，则显示一个警告信息并返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == E820MAX) &#123;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;Oops! Too many entries in the memory map!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在e820 中增加一项，并给<code>nr_map</code>加 1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e820.<span class="built_in">map</span>[x].addr = start;</span><br><span class="line">e820.<span class="built_in">map</span>[x].size = size;</span><br><span class="line">e820.<span class="built_in">map</span>[x].type = type;</span><br><span class="line">e820.nr_map++;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="print-memory-map-函数"><a href="#print-memory-map-函数" class="headerlink" title="print_memory_map() 函数"></a>print_memory_map() 函数</h4><p>这个函数把内存构成图在控制台上输出。例如函数的输出为(BIOS所提供的物理<code>RAM</code>区间)：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BIOS-e820: 0000000000000000 - 00000000000a0000 (usable)</span><br><span class="line">BIOS-e820: 00000000000f0000 - 0000000000100000 (reserved)</span><br><span class="line">BIOS-e820: 0000000000100000 - 000000000c000000 (usable)</span><br><span class="line">BIOS-e820: 00000000ffff0000 - 0000000100000000 (reserved)</span><br></pre></td></tr></table></figure></p>
<h3 id="物理内存的描述"><a href="#物理内存的描述" class="headerlink" title="物理内存的描述"></a>物理内存的描述</h3><h4 id="一致存储结构-UMA-和非一致存储结构-NUMA"><a href="#一致存储结构-UMA-和非一致存储结构-NUMA" class="headerlink" title="一致存储结构(UMA)和非一致存储结构(NUMA)"></a>一致存储结构(UMA)和非一致存储结构(NUMA)</h4><p>在传统的计算机结构中，整个物理内存都是均匀一致的，CPU访问这个空间中的任何一个地址所需要的时间都相同，所以把这种内存称为“一致存储结构(Uniform Memory Architecture)”，简称`UMA。</p>
<p>在多CPU结构中，系统中只有一条总线(例如，PCI`总线)，每个CPU模块都有本地的物理内存，但是也可以通过系统总线访问其他CPU模块上的内存，所有的CPU模块都可以通过系统总线来访问公用的存储模块。因此，所有这些物理内存的地址可以互相连续而形成一个连续的物理地址空间。</p>
<p>显然，就某个特定的CPU而言，访问其本地的存储器速度是最快的，而穿过系统总线访问公用存储模块或其他CPU模块上的存储器就比较慢，而且还面临因可能的竞争而引起的不确定性。也就是说，在这样的系统中，其物理存储空间虽然地址连续，但因为所处“位置”不同而导致的存取速度不一致，所以称为“非一致存储结构( Non-Uniform Memory Architecture)，简称`NUMA。</p>
<p>为了对<code>NUMA</code>进行描述，引入一个新的概念——“存储节点(或叫节点)”，把访问时间相同的存储空间就叫做一个“存储节点”。一般来说，连续的物理页面应该分配在相同的存储节点上。</p>
<p>Linux把物理内存划分为 3个层次来管理：存储节点(Node)、管理区(Zone)和页面(Page)，并用 3 个相应的数据结构来描述。</p>
<h4 id="页面-Page-数据结构"><a href="#页面-Page-数据结构" class="headerlink" title="页面(Page)数据结构"></a>页面(Page)数据结构</h4><p>对一个物理页面的描述在<code>/include/linux/mm.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each physical page in the system has a struct page associated with</span></span><br><span class="line"><span class="comment"> * it to keep track of whatever it is we are using the page for at the</span></span><br><span class="line"><span class="comment"> * moment. Note that we have no way to track which tasks are using</span></span><br><span class="line"><span class="comment"> * a page.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Try to keep the most commonly accessed fields in single cache lines</span></span><br><span class="line"><span class="comment"> * here (16 bytes or greater). This ordering should be particularly</span></span><br><span class="line"><span class="comment"> * beneficial on 32-bit processors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The first line is data used in page cache lookup, the second line</span></span><br><span class="line"><span class="comment"> * is used for linear searches (eg. clock algorithm scans).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> make this structure smaller, it could be as small as 32 bytes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">/* -&gt;mapping has some page lists. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span> <span class="comment">/* The inode (or ...) we belong to. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> index; <span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next_hash</span>;</span> <span class="comment">/* Next page sharing our hash bucket in the pagecache hash table. */</span></span><br><span class="line">    <span class="type">atomic_t</span> count; <span class="comment">/* Usage count, see below. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">/* atomic flags, some possibly updated asynchronously */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span> <span class="comment">/* Pageout list, eg. active_list;</span></span><br><span class="line"><span class="comment">    protected by pagemap_lru_lock !! */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> wait; <span class="comment">/* Page locked? Stand in line... */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">pprev_hash</span>;</span> <span class="comment">/* Complement to *next_hash. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">buffers</span>;</span> <span class="comment">/* Buffer maps us to a disk block. */</span></span><br><span class="line">    <span class="type">void</span> *virtual; <span class="comment">/* Kernel virtual address (NULL if not kmapped, ie. highmem) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone_struct</span> *<span class="title">zone</span>;</span> <span class="comment">/* Memory zone we are in. */</span></span><br><span class="line">&#125; <span class="type">mem_map_t</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">mem_map_t</span> * mem_map;</span><br></pre></td></tr></table></figure></p>
<p>内核中用来表示这个数据结构的变量常常是<code>page</code>或<code>map</code>。当页面的数据来自一个文件时，<code>index</code>代表着该页面中的数据在文件中的偏移量；当页面的内容被换出到交换设备上，则<code>index</code>指明了页面的去向。结构中各个成分的次序是有讲究的，尽量使得联系紧密的若干域存放在一起，这样当这个数据结构被装入到高速缓存中时，联系紧密的域就可以存放在同一缓冲行(Cache Line)中。因为同一缓冲行(其大小为 16字节)中的内容几乎可以同时存取，因此，代码注释中希望这个数据结构尽量地小到用 32个字节可以描述。</p>
<p>系统中的每个物理页面都有一个<code>Page(或</code>mem_map_t)结构。系统在初始化阶段根据内存的大小建立起一个<code>Page</code>结构的数组<code>mem_map</code>，数组的下标就是内存中物理页面的序号。</p>
<h4 id="管理区-Zone"><a href="#管理区-Zone" class="headerlink" title="管理区`Zone"></a>管理区`Zone</h4><p>为了对物理页面进行有效的管理，Linux又把物理页面划分为 3 个区：</p>
<ul>
<li>专供<code>DMA</code>使用的<code>ZONE_DMA</code>区(小于 16MB);</li>
<li>常规的<code>ZONE_NORMAL</code>区(大于 16MB`小于 896MB);</li>
<li>内核不能直接映射的区<code>ZONE_HIGME</code>区(大于 896MB)。</li>
</ul>
<p>这里进一步说明为什么对<code>DMA</code>要单独设置管理区。</p>
<ul>
<li>首先，DMA使用的页面是磁盘<code>I/O</code>所需的，如果在页面的分配过程中，所有的页面全被分配完，那么页面及盘区的交换就无法进行了，这是操作系统决不允许出现的现象。</li>
<li>另外，在 i386 CPU中，页式存储管理的硬件支持是在CPU内部实现的，而不像有些CPU那样由一个单独的<code>MMU</code>来提供，所以<code>DMA</code>对内存的访问不经过<code>MMU</code>提供的地址映射。这样，外部设备就要直接访问物理页面的地址。可是，有些外设(特别是插在<code>ISA</code>总线上的外设接口卡)在这方面往往有些限制，要求用于<code>DMA</code>的物理地址不能过高。另一方面，当<code>DMA</code>所需的缓冲区超过一个物理页面的大小时，就要求两个物理页面在物理上是连续的，但因为此时<code>DMA</code>控制器不能依靠CPU内部的<code>MMU</code>将连续的虚存页面映射到物理上也连续的页面上，因此，用于<code>DMA</code>的物理页面必须加以单独管理。</li>
</ul>
<h4 id="存储节点-Node-的数据结构"><a href="#存储节点-Node-的数据结构" class="headerlink" title="存储节点(Node)的数据结构"></a>存储节点(Node)的数据结构</h4><p>存储节点的数据结构为<code>pglist_data</code>，定义于<code>include/linux/mmzone.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="type">zone_t</span> node_zones[MAX_NR_ZONES];</span><br><span class="line">    <span class="type">zonelist_t</span> node_zonelists[GFP_ZONEMASK+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> nr_zones;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *valid_addr_bitmap;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span> *<span class="title">bdata</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_start_paddr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_start_mapnr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_size;</span><br><span class="line">    <span class="type">int</span> node_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">node_next</span>;</span></span><br><span class="line">&#125; <span class="type">pg_data_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>显然，若干存储节点的<code>pglist_data</code>数据结构可以通过<code>node_next</code>形成一个单链表队列。每个结构中的<code>node_mem_map</code>指向具体节点的<code>page</code>结构数组，而数组<code>node_zone[]</code>就是该节点的最多 3 个页面管理区。</p>
<p>在<code>pglist_data</code>结构里设置了一个<code>node_zonelists</code>数组，其类型定义也在同一文件中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zonelist_struct</span> &#123;</span></span><br><span class="line">    <span class="type">zone_t</span> *zone[MAX_NR_ZONE+<span class="number">1</span>]; <span class="comment">//NULL delimited</span></span><br><span class="line">    <span class="type">int</span> gfp_mast;</span><br><span class="line">&#125; <span class="type">zonelist_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>zone[]</code>是个指针数组，各个元素按特定的次序指向具体的页面管理区，表示分配页面时先试<code>zone[0]</code>所指向的管理区，如果不能满足要求就试<code>zone[1]</code>所指向的管理区，等等。</p>
<h3 id="页面管理机制的初步建立"><a href="#页面管理机制的初步建立" class="headerlink" title="页面管理机制的初步建立"></a>页面管理机制的初步建立</h3><p>为了对页面管理机制作出初步准备，Linux使用了一种叫<code>bootmem</code>分配器(Bootmem Allocator)的机制，这种机制仅仅用在系统引导时，它为整个物理内存建立起一个页面位图。这个位图建立在从<code>start_pfn</code>开始的地方，也就是说，内核映像终点<code>_end</code>上方的地方。这个位图用来管理低区(例如小于 896MB)，因为在 0 到 896MB 的范围内，有些页面可能保留，有些页面可能有空洞，因此，建立这个位图的目的就是要搞清楚哪一些物理页面是可以动态分配的。用来存放位图的数据结构为<code>bootmem_data</code>(在<code>mm/numa.c</code>中) ：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_boot_start;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_low_pfn;</span><br><span class="line">    <span class="type">void</span> *node_bootmem_map;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> last_offset;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> last_pos;</span><br><span class="line">&#125; <span class="type">bootmem_data_t</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>node_boot_start</code>表示存放<code>bootmem</code>位图的第一个页面(即内核映像结束处的第一个页面)。</li>
<li><code>node_low_pfn</code>表示物理内存的顶点，最高不超过 896MB。</li>
<li><code>node_bootmem_map</code>指向<code>bootmem</code>位图</li>
<li><code>last_offset</code>用来存放在前一次分配中所分配的最后一个字节相对于<code>last_pos</code>的位移量。</li>
<li><code>last_pos</code>用来存放前一次分配的最后一个页面的页面号。这个域用在<code>__alloc_bootmem_core()</code>函数中，通过合并相邻的内存来减少内部碎片。</li>
</ul>
<p>下面介绍与<code>bootmem</code>相关的几个函数，这些函数位于<code>mm/bootmeme.c</code>中。</p>
<h4 id="init-bootmem-函数"><a href="#init-bootmem-函数" class="headerlink" title="init_bootmem()函数"></a>init_bootmem()函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __init <span class="title function_">init_bootmem</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> pages)</span></span><br><span class="line">&#123;</span><br><span class="line">    max_low_pfn = pages;</span><br><span class="line">    min_low_pfn = start;</span><br><span class="line">    <span class="keyword">return</span>(init_bootmem_core(&amp;contig_page_data, start, <span class="number">0</span>, pages));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数仅在初始化时用来建立<code>bootmem</code>分配器。这个函数实际上是<code>init_bootmem_core()</code>函数的封装函数。<code>init_bootmem()</code>函数的参数<code>start</code>表示内核映像结束处的页面号，而<code>pages</code>表示物理内存顶点所在的页面号。而函数<code>init_bootmem_core()</code>就是对<code>contig_page_data</code>变量进行初始化。下面我们来看一下对该变量的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numnodes = <span class="number">1</span>; <span class="comment">/* Initialized for UMA platforms */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bootmem_data_t</span> contig_bootmem_data;</span><br><span class="line"><span class="type">pg_data_t</span> contig_page_data = &#123; bdata: &amp;contig_bootmem_data &#125;;</span><br></pre></td></tr></table></figure></p>
<p>变量<code>contig_page_data</code>的类型就是前面介绍过的<code>pg_data_t</code>数据结构。每个<code>pg_data_t</code>数据结构代表着一片均匀的、连续的内存空间。在连续空间<code>UMA</code>结构中，只有一个节点<code>contig_page_data</code>，而在<code>NUMA</code>结构或不连续空间<code>UMA</code>结构中，有多个这样的数据结构。系统中各个节点的<code>pg_data_t</code>数据结构通过<code>node_next</code>连接在一起成为一个链。有一个全局量<code>pgdat_list</code>则指向这个链。从上面的定义可以看出，<code>contig_page_data</code>是链中的第一个节点。</p>
<p>这里假定整个物理空间为均匀的、连续的，以后若发现这个假定不能成立，则将新的<code>pg_data_t</code>结构加入到链中。<code>pg_data_t</code>结构中有个指针<code>bdata</code>，<code>contig_page_data</code>被初始化为指向<code>bootmem_data_t</code>数据结构。下面我们来看<code>init_bootmem_core()</code>函数的具体代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called once to set up the allocator itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> __init <span class="title function_">init_bootmem_core</span> <span class="params">(<span class="type">pg_data_t</span> *pgdat, <span class="type">unsigned</span> <span class="type">long</span> mapstart, <span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bootmem_data_t</span> *bdata = pgdat-&gt;bdata;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mapsize = ((end - start)+<span class="number">7</span>)/<span class="number">8</span>;</span><br><span class="line">    pgdat-&gt;node_next = pgdat_list;</span><br><span class="line">    pgdat_list = pgdat;</span><br><span class="line">    mapsize = (mapsize + (<span class="keyword">sizeof</span>(<span class="type">long</span>) - <span class="number">1UL</span>)) &amp; ~(<span class="keyword">sizeof</span>(<span class="type">long</span>) - <span class="number">1UL</span>);</span><br><span class="line">    bdata-&gt;node_bootmem_map = phys_to_virt(mapstart &lt;&lt; PAGE_SHIFT);</span><br><span class="line">    bdata-&gt;node_boot_start = (start &lt;&lt; PAGE_SHIFT);</span><br><span class="line">    bdata-&gt;node_low_pfn = end;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Initially all pages are reserved - setup_arch() has to</span></span><br><span class="line"><span class="comment">* register free RAM areas explicitly.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="built_in">memset</span>(bdata-&gt;node_bootmem_map, <span class="number">0xff</span>, mapsize);</span><br><span class="line">    <span class="keyword">return</span> mapsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面对这一函数给予说明。</p>
<ul>
<li>变量<code>mapsize</code>存放位图的大小。<code>(end - start)</code>给出现有的页面数，再加个 7 是为了向上取整，除以 8 就获得了所需的字节数(因为每个字节映射 8 个页面)。</li>
<li>变量<code>pgdat_list</code>用来指向节点所形成的循环链表首部，因为只有一个节点，因此使<code>pgdat_list</code>指向自己。</li>
<li>接下来的一句使<code>memsize</code>成为下一个 4 的倍数(4 为CPU的字长)。例如，假设有 40 个物理页面，因此，我们可以得出<code>memsize</code>为 5 个字节。所以，上面的操作就变为<code>(5+(4-1))&amp;~(4-1)</code>即<code>(00001000&amp;11111100)</code>，最低的两位变为 0，其结果为 8。这就有效地使<code>memsize</code>变为 4 的倍数。</li>
<li><code>phys_to_virt(mapstart &lt;&lt; PAGE_SHIFT)</code>把给定的物理地址转换为虚地址。</li>
<li>用节点的起始物理地址初始化<code>node_boot_start</code>(这里为 0x00000000)。</li>
<li>用物理内存节点的页面号初始化<code>node_low_pfn</code>。</li>
<li>初始化所有被保留的页面，即通过把页面中的所有位都置为 1 来标记保留的页面。</li>
<li>返回位图的大小。</li>
</ul>
<h4 id="free-bootmem-函数"><a href="#free-bootmem-函数" class="headerlink" title="free_bootmem()函数"></a>free_bootmem()函数</h4><p>这个函数把给定范围的页面标记为空闲(即可用)，也就是，把位图中某些位清 0，表示相应的物理内存可以投入分配。原函数为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">free_bootmem</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (free_bootmem_core(contig_page_data.bdata, addr, size));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，<code>free_bootmem()</code>是个封装函数，实际的工作是由<code>free_bootmem_core()</code>函数完成的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">free_bootmem_core</span><span class="params">(<span class="type">bootmem_data_t</span> *bdata, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* round down end of usable mem, partially free pages are</span></span><br><span class="line"><span class="comment">* considered reserved.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sidx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eidx = (addr + size - bdata-&gt;node_boot_start)/PAGE_SIZE;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> end = (addr + size)/PAGE_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (!size) BUG();</span><br><span class="line">    <span class="keyword">if</span> (end &gt; bdata-&gt;node_low_pfn)</span><br><span class="line">        BUG();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Round up the beginning of the address.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    start = (addr + PAGE_SIZE<span class="number">-1</span>) / PAGE_SIZE;</span><br><span class="line">    sidx = start - (bdata-&gt;node_boot_start/PAGE_SIZE);</span><br><span class="line">    <span class="keyword">for</span> (i = sidx; i &lt; eidx; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!test_and_clear_bit(i, bdata-&gt;node_bootmem_map))</span><br><span class="line">            BUG();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对此函数的解释如下。</p>
<ul>
<li>变量<code>eidx</code>被初始化为页面总数。</li>
<li>变量<code>end</code>被初始化为最后一个页面的页面号。</li>
<li>进行两个可能的条件检查。</li>
<li><code>start</code>初始化为第一个页面的页面号(向上取整)，而<code>sidx(start index)</code>初始化为相对于<code>node_boot_start</code>的页面号。</li>
<li>清位图中从<code>sidx</code>到<code>eidx</code>的所有位，即把这些页面标记为可用。</li>
</ul>
<h4 id="reserve-bootmem-函数"><a href="#reserve-bootmem-函数" class="headerlink" title="reserve_bootmem()函数"></a>reserve_bootmem()函数</h4><p>这个函数用来保留页面。为了保留一个页面，只需要在<code>bootmem</code>位图中把相应的位置为1 即可。原函数为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">reserve_bootmem</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">reserve_bootmem_core(contig_page_data.bdata, addr, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>reserve_bootmem()</code>为封装函数，实际调用的是<code>reserve_bootmem_core()</code>函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">reserve_bootmem_core</span> <span class="params">( <span class="type">bootmem_data_t</span> *bdata, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* round up, partially reserved pages are considered</span></span><br><span class="line"><span class="comment">* fully reserved.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sidx = (addr - bdata-&gt;node_boot_start)/PAGE_SIZE;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eidx = (addr + size - bdata-&gt;node_boot_start + PAGE_SIZE<span class="number">-1</span>)/PAGE_SIZE;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> end = (addr + size + PAGE_SIZE<span class="number">-1</span>)/PAGE_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (!size) BUG();</span><br><span class="line">    <span class="keyword">if</span> (sidx &lt; <span class="number">0</span>)</span><br><span class="line">        BUG();</span><br><span class="line">    <span class="keyword">if</span> (eidx &lt; <span class="number">0</span>)</span><br><span class="line">        BUG();</span><br><span class="line">    <span class="keyword">if</span> (sidx &gt;= eidx)</span><br><span class="line">        BUG();</span><br><span class="line">    <span class="keyword">if</span> ((addr &gt;&gt; PAGE_SHIFT) &gt;= bdata-&gt;node_low_pfn)</span><br><span class="line">        BUG();</span><br><span class="line">    <span class="keyword">if</span> (end &gt; bdata-&gt;node_low_pfn)</span><br><span class="line">        BUG();</span><br><span class="line">    <span class="keyword">for</span> (i = sidx; i &lt; eidx; i++)</span><br><span class="line">        <span class="keyword">if</span> (test_and_set_bit(i, bdata-&gt;node_bootmem_map))</span><br><span class="line">            printk(<span class="string">&quot;hm, page %08lx reserved twice.\n&quot;</span>, i*PAGE_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对此函数的解释如下。</p>
<ul>
<li><code>sidx (start index)</code>初始化为相对于<code>node_boot_start</code>的页面号。</li>
<li>变量<code>eidx</code>初始化为页面总数(向上取整)。</li>
<li>变量<code>end</code>初始化为最后一个页面的页面号(向上取整)。</li>
<li>进行各种可能的条件检查。</li>
<li>把位图中从<code>sidx</code>到<code>eidx</code>的所有位置 1。</li>
</ul>
<h4 id="alloc-bootmem-函数"><a href="#alloc-bootmem-函数" class="headerlink" title="__alloc_bootmem()函数"></a>__alloc_bootmem()函数</h4><p>这个函数以循环轮转的方式从不同节点分配页面。因为在i386 上只有一个节点，因此只循环一次。函数原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * __alloc_bootmem (<span class="type">unsigned</span> <span class="type">long</span> size,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> align,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> goal);</span><br><span class="line"><span class="type">void</span> * __alloc_bootmem_core (<span class="type">bootmem_data_t</span> *bdata,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> size,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> align,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> goal);</span><br></pre></td></tr></table></figure></p>
<p>其中<code>__alloc_bootmem()</code>为封装函数，实际调用的函数为<code>__alloc_bootmem_core()</code>，因为<code>__alloc_bootmem_core()</code>函数比较长，下面分片断来进行仔细分析。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> i, start = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> *ret;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> offset, remaining_size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> areasize, preferred, incr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> eidx = bdata-&gt;node_low_pfn - (bdata-&gt;node_boot_start &gt;&gt; PAGE_SHIFT);</span><br></pre></td></tr></table></figure></p>
<p>把<code>eidx</code>初始化为本节点中现有页面的总数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!size) BUG();</span><br><span class="line"><span class="keyword">if</span> (align &amp; (align<span class="number">-1</span>))</span><br><span class="line">    BUG();</span><br></pre></td></tr></table></figure></p>
<p>进行条件检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* We try to allocate bootmem pages above &#x27;goal&#x27;</span></span><br><span class="line"><span class="comment">* first, then we try to allocate lower pages.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (goal &amp;&amp; (goal &gt;= bdata-&gt;node_boot_start) &amp;&amp; ((goal &gt;&gt; PAGE_SHIFT) &lt; bdata-&gt;node_low_pfn)) &#123;</span><br><span class="line">    preferred = goal - bdata-&gt;node_boot_start;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">    preferred = <span class="number">0</span>;</span><br><span class="line">preferred = ((preferred + align - <span class="number">1</span>) &amp; ~(align - <span class="number">1</span>)) &gt;&gt; PAGE_SHIFT;</span><br></pre></td></tr></table></figure></p>
<p>开始分配后首选页的计算分为两步：</p>
<ol>
<li>如果<code>goal</code>为非 0 且有效，则给<code>preferred</code>赋初值，否则，其初值为 0。</li>
<li>根据参数<code>align</code>来对齐<code>preferred</code>的物理地址。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">areasize = (size+PAGE_SIZE<span class="number">-1</span>)/PAGE_SIZE;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>获得所需页面的总数(向上取整)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr = align &gt;&gt; PAGE_SHIFT ? : <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>根据对齐的大小来选择增加值。除非大于 4KB(很少见)，否则增加值为 1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">restart_scan:</span><br><span class="line"><span class="keyword">for</span> (i = preferred; i &lt; eidx; i += incr) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> j;</span><br><span class="line">    <span class="keyword">if</span> (test_bit(i, bdata-&gt;node_bootmem_map))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure></p>
<p>这个循环用来从首选页面号开始，找到空闲的页面号。<code>test_bit()</code>宏用来测试给定的位，如果给定位为 1，则返回 1。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (j = i + 1; j &lt; i + areasize; ++j) &#123;</span><br><span class="line">    if (j &gt;= eidx)</span><br><span class="line">        goto fail_block;</span><br><span class="line">    if (test_bit (j, bdata-&gt;node_bootmem_map))</span><br><span class="line">        goto fail_block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个循环用来查看在首次满足内存需求以后，是否还有足够的空闲页面。如果没有空闲页，就跳到<code>fail_block</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start = i;</span><br><span class="line"><span class="keyword">goto</span> found;</span><br></pre></td></tr></table></figure></p>
<p>如果一直到了这里，则说明从<code>i</code>开始找到了足够的页面，跳过<code>fail_block</code>并继续。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fail_block:;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (preferred) &#123;</span><br><span class="line">    preferred = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> restart_scan;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果到了这里，从首选页面中没有找到满足需要的连续页面，就忽略<code>preferred</code>的值，并从 0 开始扫描。如果<code>preferred</code>为 1，但没有找到满足需要的足够页面，则返回NULL。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">found:</span><br></pre></td></tr></table></figure></p>
<p>已经找到足够的内存，继续处理请求。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (start &gt;= eidx)</span><br><span class="line">    BUG();</span><br></pre></td></tr></table></figure></p>
<p>进行条件检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Is the next page of the previous allocation-end the start</span></span><br><span class="line"><span class="comment">* of this allocation&#x27;s buffer? If yes then we can &#x27;merge&#x27;</span></span><br><span class="line"><span class="comment">* the previous partial page with this allocation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (align &lt;= PAGE_SIZE &amp;&amp; bdata-&gt;last_offset &amp;&amp; bdata-&gt;last_pos+<span class="number">1</span> == start) &#123;</span><br><span class="line">    offset = (bdata-&gt;last_offset+align<span class="number">-1</span>) &amp; ~(align<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (offset &gt; PAGE_SIZE)</span><br><span class="line">        BUG();</span><br><span class="line">    remaining_size = PAGE_SIZE-offset;</span><br></pre></td></tr></table></figure></p>
<p>if语句检查下列条件：</p>
<ol>
<li>所请求对齐的值小于页的大小(4KB)。</li>
<li>变量<code>last_offset</code>为非 0。如果为 0，则说明前一次分配达到了一个非常好的页面边界，没有内部碎片。</li>
<li>检查这次请求的内存是否与前一次请求的内存是相临的，如果是，则把两次分配合在一起进行。</li>
</ol>
<p>如果以上 3 个条件都满足，则用前一次分配中最后一页剩余的空间初始化remaining_size。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (size &lt; remaining_size) &#123;</span><br><span class="line">    areasize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// last_pos unchanged</span></span><br><span class="line">    bdata-&gt;last_offset = offset+size;</span><br><span class="line">    ret = phys_to_virt(bdata-&gt;last_pos*PAGE_SIZE + offset + bdata-&gt;node_boot_start);</span><br></pre></td></tr></table></figure></p>
<p>如果请求内存的大小小于前一次分配中最后一页中的可用空间，则没必要分配任何新的页。变量<code>last_offset</code>增加到新的偏移量，而<code>last_pos</code>保持不变，因为没有增加新的页。把这次新分配的起始地址存放在变量<code>ret</code>中。宏<code>phys_to_virt()</code>返回给定物理地址的虚地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    remaining_size = size - remaining_size;</span><br><span class="line">    areasize = (remaining_size+PAGE_SIZE<span class="number">-1</span>)/PAGE_SIZE;</span><br><span class="line">    ret = phys_to_virt(bdata-&gt;last_pos*PAGE_SIZE + offset + bdata-&gt;node_boot_start);</span><br><span class="line">    bdata-&gt;last_pos = start+areasize<span class="number">-1</span>;</span><br><span class="line">    bdata-&gt;last_offset = remaining_size;</span><br></pre></td></tr></table></figure></p>
<p>所请求的大小大于剩余的大小。首先求出所需的页面数，然后更新变量<code>last_pos</code>和<code>last_offset</code>。例如，在前一次分配中，如果分配了 9KB，则占用 3 个页面，内部碎片为 12KB-9KB=3KB。因此，<code>page_offset</code>为 1KB，且剩余大小为 3KB。如果新的请求为 1KB，则第 3 个页面本身就能满足要求，但是，如果请求的大小为 10KB，则需要新分配<code>((10KB- 3KB) + PAGE_SIZE-1)/PAGE_SIZE</code>，即 2 个页面，因此，<code>page_offset</code>为 3KB。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">        bdata-&gt;last_offset &amp;= ~PAGE_MASK;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    bdata-&gt;last_pos = start + areasize - <span class="number">1</span>;</span><br><span class="line">    bdata-&gt;last_offset = size &amp; ~PAGE_MASK;</span><br><span class="line">    ret = phys_to_virt(start * PAGE_SIZE + bdata-&gt;node_boot_start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果因为某些条件未满足而导致不能进行合并，则执行这段代码，我们刚刚把<code>last_pos</code>和<code>last_offset</code>直接设置为新的值，而未考虑它们原先的值。<code>last_pos</code>的值还要加上所请求的页面数，而新<code>page_offset</code>值的计算就是屏蔽掉除了获得页偏移量位的所有位，即<code>size &amp;PAGE_MASK</code>，<code>PAGE_MASK</code>为 0x00000FFF，用<code>PAGE_MASK</code>的求反正好得到页的偏移量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Reserve the area now:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = start; i &lt; start+areasize; i++)</span><br><span class="line">    <span class="keyword">if</span> (test_and_set_bit(i, bdata-&gt;node_bootmem_map))</span><br><span class="line">        BUG();</span><br><span class="line"><span class="built_in">memset</span>(ret, <span class="number">0</span>, size); </span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure></p>
<p>现在，我们有了内存，就需要保留它。宏<code>test_and_set_bit()</code>用来测试并置位，如果某位原先的值为 0，则它返回 0；如果为 1，则返回 1。还有一个条件判断语句，进行条件判断(这种条件出现的可能性非常小，除非RAM坏)。然后，把这块内存初始化为 0，并返回给调用它的函数。</p>
<p>26</p>
<h4 id="free-all-bootmem-函数"><a href="#free-all-bootmem-函数" class="headerlink" title="free_all_bootmem()函数"></a>free_all_bootmem()函数</h4><p>这个函数用来在引导时释放页面，并清除<code>bootmem</code>分配器。函数原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_all_bootmem</span> <span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_all_bootmem_core</span><span class="params">(<span class="type">pg_data_t</span> *pgdat)</span>;</span><br></pre></td></tr></table></figure></p>
<p>同前面的函数调用形式类似，<code>free_all_bootmem()</code>为封装函数，实际调用<code>free_all_bootmem_core()</code>函数。下面，我们对<code>free_all_bootmem_core()</code>函数分片断来介绍。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pgdat-&gt;node_mem_map;</span><br><span class="line"><span class="type">bootmem_data_t</span> *bdata = pgdat-&gt;bdata;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> i, count, total = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!bdata-&gt;node_bootmem_map) BUG();</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">idx = bdata-&gt;node_low_pfn - (bdata-&gt;node_boot_start &gt;&gt; PAGE_SHIFT);</span><br></pre></td></tr></table></figure></p>
<p>把<code>idx</code>初始化为从内核映像结束处到内存顶点处的页面数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; idx; i++, page++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!test_bit(i, bdata-&gt;node_bootmem_map)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        ClearPageReserved(page);</span><br><span class="line">        set_page_count(page, <span class="number">1</span>);</span><br><span class="line">        __free_page(page);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>搜索<code>bootmem</code>位图，找到空闲页，并把<code>mem_map</code>中对应的项标记为空闲。<code>set_page_count()</code>函数把<code>page</code>结构的<code>count</code>域置 1，而<code>__free_page()</code>真正的释放页面，并修改伙伴(buddy)系统的位图。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">total += count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Now free the allocator bitmap itself, it&#x27;s not</span></span><br><span class="line"><span class="comment">* needed anymore:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">page = virt_to_page(bdata-&gt;node_bootmem_map);</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ((bdata-&gt;node_low_pfn-(bdata-&gt;node_boot_start &gt;&gt; PAGE_SHIFT))/<span class="number">8</span> + PAGE_SIZE<span class="number">-1</span>)/PAGE_SIZE; i++,page++) &#123;</span><br><span class="line">    count++; </span><br><span class="line">    ClearPageReserved(page);</span><br><span class="line">    set_page_count(page, <span class="number">1</span>);</span><br><span class="line">    __free_page(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获得<code>bootmem</code>位图的地址，并释放它所在的页面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total += count;</span><br><span class="line">bdata-&gt;node_bootmem_map = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> total;</span><br></pre></td></tr></table></figure></p>
<p>把该存储节点的<code>bootmem_map</code>域置为NULL，并返回空闲页面的总数。</p>
<h3 id="页表的建立"><a href="#页表的建立" class="headerlink" title="页表的建立"></a>页表的建立</h3><p>前面已经建立了为内存页面管理所需的数据结构，现在是进一步完善页面映射机制，并且建立起内存页面映射管理机制的时候了，与此相关的主要函数有：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paging_init() 函数</span><br><span class="line">pagetable_init() 函数</span><br></pre></td></tr></table></figure></p>
<h4 id="paging-init-函数"><a href="#paging-init-函数" class="headerlink" title="paging_init() 函数"></a>paging_init() 函数</h4><p>这个函数仅被调用一次，即由<code>setup_arch()</code>调用以建立页表，对此函数的具体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pagetable_init();</span><br></pre></td></tr></table></figure></p>
<p>这个函数实际上才真正地建立页表，后面会给出详细描述。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm__( <span class="string">&quot;movl %%ecx,%%cr3\n&quot;</span> ::<span class="string">&quot;c&quot;</span>(__pa(swapper_pg_dir)));</span><br></pre></td></tr></table></figure></p>
<p>因为<code>pagetable_init()</code>已经建立起页表，因此把<code>swapper_pg_dir</code>(页目录)的地址装入CR3寄存器。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_X86_PAE</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We will bail out later - printk doesnt work right now so</span></span><br><span class="line"><span class="comment"> * the user would just see a hanging kernel.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (cpu_has_pae)</span><br><span class="line">set_in_cr4(X86_CR4_PAE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">__flush_tlb_all();</span><br></pre></td></tr></table></figure></p>
<p>上面这一句是个宏，它使得转换旁路缓冲区(TLB)无效。TLB总是要维持几个最新的虚地址到物理地址的转换。每当页目录改变时，TLB就需要被刷新。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">kmap_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果使用了<code>CONFIG_HIGHMEM</code>选项，就要对大于 896MB的内存进行初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> zones_size[MAX_NR_ZONES] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_dma, high, low;</span><br><span class="line">    max_dma = virt_to_phys((<span class="type">char</span> *)MAX_DMA_ADDRESS) &gt;&gt; PAGE_SHIFT;</span><br></pre></td></tr></table></figure></p>
<p>低于 16MB的内存只能用于DMA，因此，上面这条语句用于存放 16MB的页面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">low = max_low_pfn;</span><br><span class="line">high = highend_pfn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (low &lt; max_dma)</span><br><span class="line">    zones_size[ZONE_DMA] = low;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    zones_size[ZONE_DMA] = max_dma;</span><br><span class="line">    zones_size[ZONE_NORMAL] = low - max_dma;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">    zones_size[ZONE_HIGHMEM] = high - low;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>计算 3 个管理区的大小，并存放在<code>zones_size</code>数组中。3 个管理区如下所述。</p>
<ul>
<li><code>ZONE_DMA</code>：从 0～16MB 分配给这个区。</li>
<li><code>ZONE_NORMAL</code>：从 16MB～896MB 分配给这个区。</li>
<li><code>ZONE_DMA</code>：896MB以上分配给这个区。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">free_area_init(zones_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return;</span><br></pre></td></tr></table></figure>
<p>这个函数用来初始化内存管理区并创建内存映射表，详细介绍参见后面内容。</p>
<h4 id="pagetable-init-函数"><a href="#pagetable-init-函数" class="headerlink" title="pagetable_init()函数"></a>pagetable_init()函数</h4><p>这个函数真正地在页目录<code>swapper_pg_dir</code>中建立页表，描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> vaddr, end;</span><br><span class="line"><span class="type">pgd_t</span> *pgd, *pgd_base;</span><br><span class="line"><span class="type">int</span> i, j, k;</span><br><span class="line"><span class="type">pmd_t</span> *pmd;</span><br><span class="line"><span class="type">pte_t</span> *pte, *pte_base;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This can be zero as well - no problem, in that case we exit</span></span><br><span class="line"><span class="comment">* the loops anyway due to the PTRS_PER_* conditions.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">end = (<span class="type">unsigned</span> <span class="type">long</span>)__va(max_low_pfn*PAGE_SIZE);</span><br></pre></td></tr></table></figure></p>
<p>计算<code>max_low_pfn</code>的虚拟地址，并把它存放在<code>end</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgd_base = swapper_pg_dir;</span><br></pre></td></tr></table></figure></p>
<p>让<code>pgd_base</code>(页目录基地址) 指向<code>swapper_pg_dir</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_X86_PAE</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PTRS_PER_PGD; i++)</span><br><span class="line">    set_pgd(pgd_base + i, __pgd(<span class="number">1</span> + __pa(empty_zero_page)));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果<code>PAE</code>被激活，<code>PTRS_PER_PGD</code>就为 4，且变量<code>swapper_pg_dir</code>用作页目录指针表，宏<code>set_pgd()</code>定义于<code>include/asm-i386/pgtable-3level.h</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = __pgd_offset(PAGE_OFFSET);</span><br><span class="line">pgd = pgd_base + i;</span><br></pre></td></tr></table></figure></p>
<p>宏<code>__pgd_offset()</code>在给定地址的页目录中检索相应的下标。因此<code>__pgd_offset(PAGE_OFFSET)</code>返回 0x300(或十进制 768)，即内核地址空间开始处的下标。因此，<code>pgd</code>现在指向页目录表的第 768 项。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; i &lt; PTRS_PER_PGD; pgd++, i++) &#123;</span><br><span class="line">    vaddr = i*PGDIR_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (end &amp;&amp; (vaddr &gt;= end))</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果使用了<code>CONFIG_X86_PAE</code>选项，<code>PTRS_PER_PGD</code>就为 4，否则，一般情况下它都为1024，即页目录的项数。<code>PGDIR_SIZE</code>给出一个单独的页目录项所能映射的<code>RAM</code>总量，在两级页目录中它为 4MB，当使用<code>CONFIG_X86_PAE</code>选项时，它为 1GB。计算虚地址<code>vaddr</code>，并检查它是否到了虚拟空间的顶部。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_X86_PAE</span></span><br><span class="line">    pmd = (<span class="type">pmd_t</span> *) alloc_bootmem_low_pages(PAGE_SIZE);</span><br><span class="line">    set_pgd(pgd, __pgd(__pa(pmd) + <span class="number">0x1</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    pmd = (<span class="type">pmd_t</span> *)pgd;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果使用了<code>CONFIG_X86_PAE</code>选项，则分配一页(4KB)的内存给<code>bootmem</code>分配器用，以保存中间页目录，并在总目录中设置它的地址。否则，没有中间页目录，就把中间页目录直接映射到总目录。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pmd != pmd_offset(pgd, <span class="number">0</span>))</span><br><span class="line">    BUG();</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; PTRS_PER_PMD; pmd++, j++) &#123;</span><br><span class="line">    vaddr = i*PGDIR_SIZE + j*PMD_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (end &amp;&amp; (vaddr &gt;= end))</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (cpu_has_pse) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> __pe;</span><br><span class="line">        set_in_cr4(X86_CR4_PSE);</span><br><span class="line">        boot_cpu_data.wp_works_ok = <span class="number">1</span>;</span><br><span class="line">        __pe = _KERNPG_TABLE + _PAGE_PSE + __pa(vaddr);</span><br><span class="line">        <span class="comment">/* Make it &quot;global&quot; too if supported */</span></span><br><span class="line">        <span class="keyword">if</span> (cpu_has_pge) &#123;</span><br><span class="line">            set_in_cr4(X86_CR4_PGE);</span><br><span class="line">            __pe += _PAGE_GLOBAL;</span><br><span class="line">        &#125;</span><br><span class="line">        set_pmd(pmd, __pmd(__pe));</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，开始填充页目录(如果有PAE，就是填充中间页目录)。计算表项所映射的虚地址，如果没有激活PAE，<code>PMD_SIZE</code>大小就为 0，因此，<code>vaddr = i * 4MB</code>。例如，表项 0x300 所映射的虚地址为<code>0x300 * 4MB = 3GB</code>。接下来，我们检查PSE(Page Size Extension)是否可用，如果是，就要避免使用页表而直接使用 4MB 的页。宏<code>CPU_has_pse()</code>用来检查处理器是否具有扩展页，如果有，则宏<code>set_in_cr4()</code>就启用它。</p>
<p>从Pentium II处理器开始，就可以有附加属性PGE (Page Global Enable)。当一个页被标记为全局的，且设置了PGE，那么，在任务切换发生或 CR3 被装入时，就不能使该页所在的页表(或页目录项)无效。这将提高系统性能，也是让内核处于 3GB以上的原因之一。选择了所有属性后，设置中间页目录项。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pte_base = pte = (<span class="type">pte_t</span> *)</span><br><span class="line">alloc_bootmem_low_pages(PAGE_SIZE);</span><br></pre></td></tr></table></figure></p>
<p>如果<code>PSE</code>不可用，就执行这一句，它为一个页表(4KB)分配空间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; PTRS_PER_PTE; pte++, k++) &#123;</span><br><span class="line">    vaddr = i*PGDIR_SIZE + j*PMD_SIZE + k*PAGE_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (end &amp;&amp; (vaddr &gt;= end))</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>在一个页表中有 1024 个表项(如果启用PAE，就是 512 个)，每个表项映射 4KB(1 页)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    *pte = mk_pte_phys(__pa(vaddr), PAGE_KERNEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>宏<code>mk_pte_phys()</code>创建一个页表项，这个页表项的物理地址为<code>__pa(vaddr)</code>。属性<code>PAGE_KERNEL</code>表示只有在内核态才能访问这一页表项。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        set_pmd(pmd, __pmd(_KERNPG_TABLE + __pa(pte_base)));</span><br><span class="line">        <span class="keyword">if</span> (pte_base != pte_offset(pmd, <span class="number">0</span>))</span><br><span class="line">            BUG();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过调用<code>set_pmd()</code>把该页表追加到中间页目录中。这个过程一直继续，直到把所有的物理内存都映射到从<code>PAGE_OFFSET</code>开始的虚拟地址空间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Fixed mappings, only the page table structure has to be</span></span><br><span class="line"><span class="comment">* created - mappings will be set by set_fixmap():</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vaddr = __fix_to_virt(__end_of_fixed_addresses - <span class="number">1</span>) &amp; PMD_MASK;</span><br><span class="line">fixrange_init(vaddr, <span class="number">0</span>, pgd_base);</span><br></pre></td></tr></table></figure></p>
<p>在内存的最高端(4GB～128MB)，有些虚地址直接用在内核资源的某些部分中，这些地址的映射定义在<code>/include/asm/fixmap.h</code>中，枚举类型<code>__end_of_fixed_addresses</code>用作索引，宏<code>__fix_to_virt()</code>返回给定索引的虚地址。函数<code>fixrange_init()</code>为这些虚地址创建合适的页表项。注意，这里仅仅创建了页表项，而没有进行映射。这些地址的映射是由<code>set_fixmap()</code>函数完成的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_HIGHMEM</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Permanent kmaps:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vaddr = PKMAP_BASE;</span><br><span class="line">fixrange_init(vaddr, vaddr + PAGE_SIZE*LAST_PKMAP, pgd_base);</span><br><span class="line">pgd = swapper_pg_dir + __pgd_offset(vaddr);</span><br><span class="line">pmd = pmd_offset(pgd, vaddr);</span><br><span class="line">pte = pte_offset(pmd, vaddr);</span><br><span class="line">pkmap_page_table = pte;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果使用了<code>CONFIG_HIGHMEM</code>选项，我们就可以访问 896MB以上的物理内存，这些内存的地址被暂时映射到为此目的而保留的虚地址上。<code>PKMAP_BASE</code>的值为 0xFE000000(即4064MB)，<code>LAST_PKMAP</code>的值为 1024。因此，从 4064MB 开始，由<code>fixrange_init()</code>在页表中创建的表项能覆盖 4MB 的空间。接下来，把覆盖 4MB 内存的页表项赋给<code>pkmap_page_table</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_X86_PAE</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Add low memory identity-mappings - SMP needs it when</span></span><br><span class="line"><span class="comment">* starting up on an AP from real-mode. In the non-PAE</span></span><br><span class="line"><span class="comment">* case we already have these mappings through head.S.</span></span><br><span class="line"><span class="comment">* All user-space mappings are explicitly cleared after</span></span><br><span class="line"><span class="comment">* SMP startup.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pgd_base[<span class="number">0</span>] = pgd_base[USER_PTRS_PER_PGD];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="内存管理区"><a href="#内存管理区" class="headerlink" title="内存管理区"></a>内存管理区</h3><p>前面已经提到，物理内存被划分为 3 个区来管理，它们是<code>ZONE_DMA</code>、<code>ZONE_NORMAL</code>和<code>ZONE_HIGHMEM</code>。每个区都用<code>struct zone_struct</code>结构来表示，定义于<code>include/linux/mmzone.h</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zone_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Commonly accessed fields:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> free_pages;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pages_min, pages_low, pages_high;</span><br><span class="line"><span class="type">int</span> need_balance;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* free areas of different sizes</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">free_area_t</span> free_area[MAX_ORDER];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Discontig memory support fields.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">zone_pgdat</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">zone_mem_map</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> zone_start_paddr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> zone_start_mapnr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* rarely used fields:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">&#125; <span class="type">zone_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZONE_DMA 0 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZONE_NORMAL 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZONE_HIGHMEM 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NR_ZONES 3</span></span><br></pre></td></tr></table></figure></p>
<p>对<code>struct zone_struct</code>结构中每个域的描述如下。</p>
<ul>
<li><code>lock</code>：用来保证对该结构中其他域的串行访问。</li>
<li><code>free_pages</code>：在这个区中现有空闲页的个数。</li>
<li><code>pages_min、pages_low</code>及<code>pages_high</code>是对这个区最少、次少及最多页面个数的描述。</li>
<li><code>need_balance</code>：与<code>kswapd</code>合在一起使用。</li>
<li><code>free_area</code>：在伙伴分配系统中的位图数组和页面链表。</li>
<li><code>zone_pgdat</code>：本管理区所在的存储节点。</li>
<li><code>zone_mem_map</code>：该管理区的内存映射表。</li>
<li><code>zone_start_paddr</code>：该管理区的起始物理地址。</li>
<li><code>zone_start_mapnr</code>：在<code>mem_map</code>中的索引(或下标)。</li>
<li><code>name</code>：该管理区的名字。</li>
<li><code>size</code>：该管理区物理内存总的大小。</li>
</ul>
<p>其中，<code>free_area_t</code>定义为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#difine MAX_ORDER 10</span></span><br><span class="line">type <span class="class"><span class="keyword">struct</span> <span class="title">free_area_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">free_list</span></span></span><br><span class="line"><span class="class">    <span class="title">unsigned</span> <span class="title">int</span> *<span class="title">map</span></span></span><br><span class="line"><span class="class">&#125; <span class="title">free_area_t</span></span></span><br></pre></td></tr></table></figure></p>
<p>因此，<code>zone_struct</code>结构中的<code>free_area[MAX_ORDER]</code>是一组“空闲区间”链表。为什么要定义一组而不是一个空闲队列呢？这是因为常常需要成块地在物理空间分配连续的多个页面，所以要按块的大小分别加以管理。因此，在管理区数据结构中既要有一个队列来保持一些离散(连续长度为 1)的物理页面，还要有一个队列来保持一些连续长度为 2 的页面块以及连续长度为 4、8、16、……、直至 2 MAX_ORDER(即 4M 字节)的队列。</p>
<p>如前所述，内存中每个物理页面都有一个<code>struct page</code>结构，位于<code>include/linux/mm.h</code>，该结构包含了对物理页面进行管理的所有信息，下面给出具体描述：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next_hash</span>;</span></span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">pprev_hash</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> * <span class="title">buffers</span>;</span></span><br><span class="line">    <span class="type">void</span> *virtual;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone_struct</span> *<span class="title">zone</span>;</span></span><br><span class="line">&#125; <span class="type">mem_map_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>对每个域的描述如下。</p>
<ul>
<li><code>list</code>：指向链表中的下一页。</li>
<li><code>mapping</code>：用来指定我们正在映射的索引节点(inode)。</li>
<li><code>index</code>：在映射表中的偏移。</li>
<li><code>next_hash</code>：指向页高速缓存哈希表中下一个共享的页。</li>
<li><code>count</code>：引用这个页的个数。</li>
<li><code>flags</code>：页面各种不同的属性。</li>
<li><code>lru</code>：用在<code>active_list</code>中。</li>
<li><code>wait</code>：等待这一页的页队列。</li>
<li><code>pprev_hash</code>：与<code>next_hash</code>相对应。</li>
<li><code>buffers</code>：把缓冲区映射到一个磁盘块。</li>
<li><code>zone</code>：页所在的内存管理区。</li>
</ul>
<p>与内存管理区相关的 3 个主要函数为：</p>
<ul>
<li><code>free_area_init()</code>函数；</li>
<li><code>build_zonelists()</code>函数；</li>
<li><code>mem_init()</code>函数。</li>
</ul>
<h4 id="free-area-init-函数"><a href="#free-area-init-函数" class="headerlink" title="free_area_init() 函数"></a>free_area_init() 函数</h4><p>这个函数用来初始化内存管理区并创建内存映射表，定义于<code>mm/page_alloc.c</code>中。函数原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_area_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *zones_size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_area_init_core</span><span class="params">(<span class="type">int</span> nid, <span class="type">pg_data_t</span> *pgdat,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> page **gmap,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> *zones_size,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> zone_start_paddr,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> *zholes_size,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> page *lmem_map)</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>free_area_init()</code>为封装函数，而<code>free_area_init_core()</code>为真正实现的函数，对该函数详细描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> i, j;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> map_size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> totalpages, offset, realtotalpages;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> zone_required_alignment = <span class="number">1UL</span> &lt;&lt; (MAX_ORDER<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (zone_start_paddr &amp; ~PAGE_MASK)</span><br><span class="line">    BUG();</span><br></pre></td></tr></table></figure></p>
<p>检查该管理区的起始地址是否是一个页的边界。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">totalpages = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_NR_ZONES; i++) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = zones_size[i];</span><br><span class="line">    totalpages += size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>计算本存储节点中页面的个数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">realtotalpages = totalpages;</span><br><span class="line"><span class="keyword">if</span> (zholes_size) </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_NR_ZONES; i++)</span><br><span class="line">        realtotalpages -= zholes_size[i];</span><br><span class="line">printk(<span class="string">&quot;On node %d totalpages: %lu\n&quot;</span>, nid, realtotalpages);</span><br></pre></td></tr></table></figure></p>
<p>打印除空洞以外的实际页面数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INIT_LIST_HEAD(&amp;active_list);</span><br><span class="line">INIT_LIST_HEAD(&amp;inactive_list);</span><br></pre></td></tr></table></figure></p>
<p>初始化循环链表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Some architectures (with lots of mem and discontinous memory</span></span><br><span class="line"><span class="comment">* maps) have to search for a good mem_map area:</span></span><br><span class="line"><span class="comment">* For discontigmem, the conceptual mem map array starts from</span></span><br><span class="line"><span class="comment">* PAGE_OFFSET, we need to align the actual array onto a mem map</span></span><br><span class="line"><span class="comment">* boundary, so that MAP_NR works.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">map_size = (totalpages + <span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> page);</span><br><span class="line"><span class="keyword">if</span> (lmem_map == (<span class="keyword">struct</span> page *)<span class="number">0</span>) &#123;</span><br><span class="line">    lmem_map = (<span class="keyword">struct</span> page *)</span><br><span class="line">    alloc_bootmem_node(pgdat, map_size);</span><br><span class="line">    lmem_map = (<span class="keyword">struct</span> page *)(PAGE_OFFSET + MAP_ALIGN((<span class="type">unsigned</span> <span class="type">long</span>)lmem_map - PAGE_OFFSET));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>给局部内存(即本节点中的内存)映射分配空间，并在<code>sizeof(mem_map_t)</code>边界上对齐它。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*gmap = pgdat-&gt;node_mem_map = lmem_map;</span><br><span class="line">pgdat-&gt;node_size = totalpages;</span><br><span class="line">pgdat-&gt;node_start_paddr = zone_start_paddr;</span><br><span class="line">pgdat-&gt;node_start_mapnr = (lmem_map - mem_map);</span><br><span class="line">pgdat-&gt;nr_zones = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>初始化本节点中的域。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Initially all pages are reserved - free ones are freed</span></span><br><span class="line"><span class="comment">* up by free_all_bootmem() once the early boot process is</span></span><br><span class="line"><span class="comment">* done.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (p = lmem_map; p &lt; lmem_map + totalpages; p++) &#123;</span><br><span class="line">    set_page_count(p, <span class="number">0</span>);</span><br><span class="line">    SetPageReserved(p);</span><br><span class="line">    init_waitqueue_head(&amp;p-&gt;wait);</span><br><span class="line">    memlist_init(&amp;p-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>仔细检查所有的页，并进行如下操作。</p>
<ol>
<li>把页的使用计数(count域)置为 0。</li>
<li>把页标记为保留。</li>
<li>初始化该页的等待队列。</li>
<li>初始化链表指针。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset = lmem_map - mem_map;</span><br></pre></td></tr></table></figure>
<p>变量<code>mem_map</code>是类型为<code>struct pages</code>的全局稀疏矩阵。<code>mem_map</code>下标的起始值取决于第一个节点的第一个管理区。如果第一个管理区的起始地址为 0，则下标就从 0 开始，并且与物理页面号相对应，也就是说，页面号就是<code>mem_map</code>的下标。每一个管理区都有自己的映射表，存放在<code>zone_mem_map</code>中，每个管理区又被映射到它所在的节点<code>node_mem_map</code>中，而每个节点又被映射到管理全局内存的<code>mem_map</code>中。</p>
<p>在上面的这行代码中，<code>offset</code>表示该节点放的内存映射表在全局<code>mem_map</code>中的入口点(下标)。在这里，<code>offset</code>为 0，因为在 i386 上，只有一个节点。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAX_NR_ZONES; j++) &#123;</span><br></pre></td></tr></table></figure></p>
<p>这个循环对<code>zone</code>的域进行初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">zone_t</span> *zone = pgdat-&gt;node_zones + j;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mask;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> size, realsize;</span><br><span class="line">realsize = size = zones_size[j];</span><br></pre></td></tr></table></figure></p>
<p>管理区的实际数据是存放在节点中的，因此，让指针指向正确的管理区，并获得该管理区的大小。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (zholes_size)</span><br><span class="line">    realsize -= zholes_size[j];</span><br><span class="line">printk(<span class="string">&quot;zone(%lu): %lu pages.\n&quot;</span>, j, size);</span><br></pre></td></tr></table></figure></p>
<p>计算各个区的实际大小，并进行打印。例如，在具有 256MB 的内存上，上面的输出为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zone(<span class="number">0</span>): <span class="number">4096</span> pages.</span><br><span class="line">zone(<span class="number">1</span>): <span class="number">61440</span> pages.</span><br><span class="line">zone(<span class="number">2</span>): <span class="number">0</span> pages.</span><br></pre></td></tr></table></figure></p>
<p>这里，管理区 2 为 0，因为只有 256MB 的RAM。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zone-&gt;size = size;</span><br><span class="line">zone-&gt;name = zone_names[j];</span><br><span class="line">zone-&gt;lock = SPIN_LOCK_UNLOCKED;</span><br><span class="line">zone-&gt;zone_pgdat = pgdat;</span><br><span class="line">zone-&gt;free_pages = <span class="number">0</span>;</span><br><span class="line">zone-&gt;need_balance = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>初始化管理区中的各个域。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!size)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果一个管理区的大小为 0，就没必要进一步的初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pgdat-&gt;nr_zones = j+<span class="number">1</span>;</span><br><span class="line">mask = (realsize / zone_balance_ratio[j]);</span><br><span class="line"><span class="keyword">if</span> (mask &lt; zone_balance_min[j])</span><br><span class="line">    mask = zone_balance_min[j];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mask &gt; zone_balance_max[j])</span><br><span class="line">    mask = zone_balance_max[j];</span><br></pre></td></tr></table></figure></p>
<p>计算合适的平衡比率。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zone-&gt;pages_min = mask;</span><br><span class="line">zone-&gt;pages_low = mask*<span class="number">2</span>;</span><br><span class="line">zone-&gt;pages_high = mask*<span class="number">3</span>;</span><br><span class="line">zone-&gt;zone_mem_map = mem_map + offset;</span><br><span class="line">zone-&gt;zone_start_mapnr = offset;</span><br><span class="line">zone-&gt;zone_start_paddr = zone_start_paddr;</span><br></pre></td></tr></table></figure></p>
<p>设置该管理区中页面数量的几个界限，并把在全局变量<code>mem_map</code>中的入口点作为<code>zone_mem_map</code>的初值。用全局变量<code>mem_map</code>的下标初始化变量<code>zone_start_mapnr</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((zone_start_paddr &gt;&gt; PAGE_SHIFT) &amp; (zone_required_alignment<span class="number">-1</span>))</span><br><span class="line">    printk(<span class="string">&quot;BUG: wrong zone alignment, it will crash\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> mem_map + offset + i;</span><br><span class="line">    page-&gt;zone = zone;</span><br><span class="line">    <span class="keyword">if</span> (j != ZONE_HIGHMEM)</span><br><span class="line">        page-&gt;virtual = __va(zone_start_paddr);</span><br><span class="line">    zone_start_paddr += PAGE_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对该管理区中的每一页进行处理。首先，把<code>struct page</code>结构中的<code>zone</code>域初始化为指向该管理区(zone)，如果这个管理区不是<code>ZONE_HIGHMEM</code>，则设置这一页的虚地址(即物理地址 + <code>PAGE_OFFSET</code>)。也就是说，建立起每一页物理地址到虚地址的映射。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset += size;</span><br></pre></td></tr></table></figure></p>
<p>把<code>offset</code>增加<code>size</code>，使它指向<code>mem_map</code>中下一个管理区的起始位置。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bitmap_size;</span><br><span class="line">    memlist_init(&amp;zone-&gt;free_area[i].free_list);</span><br><span class="line">    <span class="keyword">if</span> (i == MAX_ORDER<span class="number">-1</span>) &#123;</span><br><span class="line">        zone-&gt;free_area[i].<span class="built_in">map</span> = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>初始化<code>free_area[]</code>链表，把<code>free_area[]</code>中最后一个序号的位图置为NULL。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Page buddy system uses &quot;index &gt;&gt; (i+1)&quot;,</span></span><br><span class="line"><span class="comment">* where &quot;index&quot; is at most &quot;size-1&quot;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The extra &quot;+3&quot; is to round down to byte</span></span><br><span class="line"><span class="comment">* size (8 bits per byte assumption). Thus</span></span><br><span class="line"><span class="comment">* we get &quot;(size-1) &gt;&gt; (i+4)&quot; as the last byte</span></span><br><span class="line"><span class="comment">* we can access.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The &quot;+1&quot; is because we want to round the</span></span><br><span class="line"><span class="comment">* byte allocation up rather than down. So</span></span><br><span class="line"><span class="comment">* we should have had a &quot;+7&quot; before we shifted</span></span><br><span class="line"><span class="comment">* down by three. Also, we have to add one as</span></span><br><span class="line"><span class="comment">* we actually _use_ the last bit (it&#x27;s [0,n]</span></span><br><span class="line"><span class="comment">* inclusive, not [0,n[).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* So we actually had +7+1 before we shift</span></span><br><span class="line"><span class="comment">* down by 3. But (n+8) &gt;&gt; 3 == (n &gt;&gt; 3) + 1</span></span><br><span class="line"><span class="comment">* (modulo overflows, which we do not have).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Finally, we LONG_ALIGN because all bitmap</span></span><br><span class="line"><span class="comment">* operations are on longs.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       bitmap_size = (size<span class="number">-1</span>) &gt;&gt; (i+<span class="number">4</span>);</span><br><span class="line">       bitmap_size = LONG_ALIGN(bitmap_size+<span class="number">1</span>); </span><br><span class="line">       zone-&gt;free_area[i].<span class="built_in">map</span> = (<span class="type">unsigned</span> <span class="type">long</span> *)</span><br><span class="line">       alloc_bootmem_node(pgdat, bitmap_size);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>计算位图的大小，然后调用<code>alloc_bootmem_node</code>给位图分配空间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">build_zonelists(pgdat);</span><br></pre></td></tr></table></figure></p>
<p>在节点中为不同的管理区创建链表。</p>
<h4 id="build-zonelists-函数"><a href="#build-zonelists-函数" class="headerlink" title="build_zonelists()函数"></a>build_zonelists()函数</h4><p>函数原型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">build_zonelists</span><span class="params">(<span class="type">pg_data_t</span> *pgdat)</span></span><br></pre></td></tr></table></figure></p>
<p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j, k;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= GFP_ZONEMASK; i++) &#123;</span><br><span class="line">    <span class="type">zonelist_t</span> *zonelist;</span><br><span class="line">    <span class="type">zone_t</span> *zone;</span><br><span class="line">    zonelist = pgdat-&gt;node_zonelists + i;</span><br><span class="line">    <span class="built_in">memset</span>(zonelist, <span class="number">0</span>, <span class="keyword">sizeof</span>(*zonelist));</span><br></pre></td></tr></table></figure></p>
<p>获得节点中指向管理区链表的域，并把它初始化为空。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">j = <span class="number">0</span>;</span><br><span class="line">k = ZONE_NORMAL;</span><br><span class="line"><span class="keyword">if</span> (i &amp; __GFP_HIGHMEM)</span><br><span class="line">    k = ZONE_HIGHMEM;</span><br><span class="line"><span class="keyword">if</span> (i &amp; __GFP_DMA)</span><br><span class="line">    k = ZONE_DMA;</span><br></pre></td></tr></table></figure></p>
<p>把当前管理区掩码与 3 个可用管理区掩码相“与”，获得一个管理区标识，把它用在下面的<code>switch</code>语句中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (k) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        BUG();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * fallthrough:</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">case</span> ZONE_HIGHMEM:</span><br><span class="line">        zone = pgdat-&gt;node_zones + ZONE_HIGHMEM;</span><br><span class="line">        <span class="keyword">if</span> (zone-&gt;size) &#123;</span><br><span class="line">            <span class="meta">#<span class="keyword">ifndef</span> CONFIG_HIGHMEM</span></span><br><span class="line">            BUG();</span><br><span class="line">            <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            zonelist-&gt;zones[j++] = zone;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> ZONE_NORMAL:</span><br><span class="line">        zone = pgdat-&gt;node_zones + ZONE_NORMAL;</span><br><span class="line">        <span class="keyword">if</span> (zone-&gt;size)</span><br><span class="line">            zonelist-&gt;zones[j++] = zone;</span><br><span class="line">    <span class="keyword">case</span> ZONE_DMA:</span><br><span class="line">        zone = pgdat-&gt;node_zones + ZONE_DMA; </span><br><span class="line">        <span class="keyword">if</span> (zone-&gt;size)</span><br><span class="line">            zonelist-&gt;zones[j++] = zone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>给定的管理区掩码指定了优先顺序，我们可以用它找到在<code>switch</code>语句中的入口点。如果掩码为<code>__GFP_DMA</code>，管理区链表<code>zonelist</code>将仅仅包含<code>DMA</code>管理区，如果为<code>__GFP_HIGHMEM</code>，则管理区链表中就会依次有<code>ZONE_HIGHMEM</code>、<code>ZONE_NORMAL</code>和<code>ZONE_DMA</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    zonelist-&gt;zones[j++] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用<code>NULL</code>结束链表。</p>
<h4 id="mem-init-函数"><a href="#mem-init-函数" class="headerlink" title="mem_init() 函数"></a>mem_init() 函数</h4><p>这个函数由<code>start_kernel()</code>调用，以对管理区的分配算法进行进一步的初始化，定义于<code>arch/i386/mm/init.c</code>中，具体解释如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> codesize, reservedpages, datasize, initsize;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"><span class="type">int</span> bad_ppro;</span><br><span class="line"><span class="keyword">if</span> (!mem_map)</span><br><span class="line">    BUG();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">highmem_start_page = mem_map + highstart_pfn;</span><br><span class="line">max_mapnr = num_physpages = highend_pfn;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>HIGHMEM</code>被激活，就要获得<code>HIGHMEM</code>的起始地址和总的页面数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">max_mapnr = num_physpages = max_low_pfn;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>否则，页面数就是常规内存的页面数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">high_memory = (<span class="type">void</span> *) __va(max_low_pfn * PAGE_SIZE);</span><br></pre></td></tr></table></figure></p>
<p>获得低区内存中最后一个页面的虚地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* clear the zero-page */</span></span><br><span class="line"><span class="built_in">memset</span>(empty_zero_page, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line"><span class="comment">/* this will put all low memory onto the freelists */</span></span><br><span class="line">totalram_pages += free_all_bootmem();</span><br><span class="line">reservedpages = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>free_all_bootmem()</code>函数本质上释放所有的低区内存，从此以后，<code>bootmem</code>不再使用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Only count reserved RAM pages</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (tmp = <span class="number">0</span>; tmp &lt; max_low_pfn; tmp++)</span><br><span class="line">    <span class="keyword">if</span> (page_is_ram(tmp) &amp;&amp; PageReserved(mem_map+tmp))</span><br><span class="line">        reservedpages++;</span><br></pre></td></tr></table></figure></p>
<p>对<code>mem_map</code>查找一遍，并统计所保留的页面数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line"><span class="keyword">for</span> (tmp = highstart_pfn; tmp &lt; highend_pfn; tmp++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> mem_map + tmp; </span><br><span class="line">    <span class="keyword">if</span> (!page_is_ram(tmp)) &#123;</span><br><span class="line">        SetPageReserved(page);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (bad_ppro &amp;&amp; page_kills_ppro(tmp)) &#123;</span><br><span class="line">        SetPageReserved(page);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ClearPageReserved(page);</span><br><span class="line">    set_bit(PG_highmem, &amp;page-&gt;flags);</span><br><span class="line">    <span class="type">atomic_set</span>(&amp;page-&gt;count, <span class="number">1</span>);</span><br><span class="line">    __free_page(page);</span><br><span class="line">    totalhigh_pages++;</span><br><span class="line">&#125;</span><br><span class="line">totalram_pages += totalhigh_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>把高区内存查找一遍，并把保留但不能使用的页面标记为<code>PG_highmem</code>，并调用<code>__free_page()</code>释放它，还要修改伙伴系统的位图。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">codesize = (<span class="type">unsigned</span> <span class="type">long</span>) &amp;_etext - (<span class="type">unsigned</span> <span class="type">long</span>) &amp;_text;</span><br><span class="line">datasize = (<span class="type">unsigned</span> <span class="type">long</span>) &amp;_edata - (<span class="type">unsigned</span> <span class="type">long</span>) &amp;_etext;</span><br><span class="line">initsize = (<span class="type">unsigned</span> <span class="type">long</span>) &amp;__init_end - (<span class="type">unsigned</span> <span class="type">long</span>) &amp;__init_begin;</span><br><span class="line">printk(<span class="string">&quot;Memory: %luk/%luk available (%dk kernel code, %dk reserved, %dk data, %dk init, %ldk highmem)\n&quot;</span>, </span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>) nr_free_pages() &lt;&lt; (PAGE_SHIFT<span class="number">-10</span>), max_mapnr &lt;&lt; (PAGE_SHIFT<span class="number">-10</span>), codesize &gt;&gt; <span class="number">10</span>, </span><br><span class="line">    reservedpages &lt;&lt; (PAGE_SHIFT<span class="number">-10</span>), datasize &gt;&gt; <span class="number">10</span>, initsize &gt;&gt; <span class="number">10</span>, </span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>) (totalhigh_pages &lt;&lt; (PAGE_SHIFT<span class="number">-10</span>)));</span><br></pre></td></tr></table></figure></p>
<p>计算内核各个部分的大小，并打印统计信息。</p>
<p>从以上的介绍可以看出，在初始化阶段，对内存的初始化要做许多工作。但这里要说明的是，尽管在这个阶段建立起了初步的虚拟内存管理机制，但仅仅考虑了内核虚拟空间(3GB以上)，还根本没有涉及用户空间的管理。因此，在这个阶段，虚拟存储空间到物理存储空间的映射非常简单，仅仅通过一种简单的线性关系就可以达到虚地址到物理地址之间的相互转换。但是，了解这个初始化阶段又非常重要，它是后面进一步进行内存管理分析的基础。</p>
<h2 id="内存的分配和回收"><a href="#内存的分配和回收" class="headerlink" title="内存的分配和回收"></a>内存的分配和回收</h2><p>Linux采用著名的伙伴(Buddy)系统算法来解决外碎片问题。对于内存页面的管理，通常是先在虚存空间中分配一个虚存区间，然后才根据需要为此区间分配相应的物理页面并建立起映射，也就是说，虚存区间的分配在前，而物理页面的分配在后。</p>
<h3 id="伙伴算法"><a href="#伙伴算法" class="headerlink" title="伙伴算法"></a>伙伴算法</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Linux的伙伴算法把所有的空闲页面分为 10 个块组，每组中块的大小是 2 的幂次方个页面，例如，第 0 组中块的大小都为 20 (1 个页面)，第 1 组中块的大小都为 21(2 个页面)，第 9 组中块的大小都为 29(512 个页面)。也就是说，每一组中块的大小是相同的，且这同样大小的块形成一个链表。</p>
<p>假设要求分配的块的大小为 128 个页面(由多个页面组成的块我们就叫做页面块)。该算法先在块大小为 128 个页面的链表中查找，看是否有这样一个空闲块。如果有，就直接分配；如果没有，该算法会查找下一个更大的块，具体地说，就是在块大小 256 个页面的链表中查找一个空闲块。如果存在这样的空闲块，内核就把这 256 个页面分为两等份，一份分配出去，另一份插入到块大小为 128 个页面的链表中。如果在块大小为 256 个页面的链表中也没有找到空闲页块，就继续找更大的块，即 512 个页面的块。如果存在这样的块，内核就从512 个页面的块中分出 128 个页面满足请求，然后从 384 个页面中取出 256 个页面插入到块大小为 256 个页面的链表中。然后把剩余的 128 个页面插入到块大小为 128 个页面的链表中。如果 512 个页面的链表中还没有空闲块，该算法就放弃分配，并发出出错信号。</p>
<p>以上过程的逆过程就是块的释放过程，这也是该算法名字的来由。满足以下条件的两个块称为伙伴：</p>
<ol>
<li>两个块的大小相同；</li>
<li>两个块的物理地址连续。</li>
</ol>
<p>伙伴算法把满足以上条件的两个块合并为一个块，该算法是迭代算法，如果合并后的块还可以跟相邻的块进行合并，那么该算法就继续合并。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>在 6.2.6 节中所介绍的管理区数据结构<code>struct zone_struct</code>中，涉及到空闲区数据结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">free_area_t</span> free_area[MAX_ORDER];</span><br></pre></td></tr></table></figure></p>
<p>我们再次对<code>free_area_t</code>给予较详细的描述。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ORDER 10</span></span><br><span class="line">type <span class="class"><span class="keyword">struct</span> <span class="title">free_area_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">free_list</span></span></span><br><span class="line"><span class="class">    <span class="title">unsigned</span> <span class="title">int</span> *<span class="title">map</span></span></span><br><span class="line"><span class="class">&#125; <span class="title">free_area_t</span></span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>list_head</code>域是一个通用的双向链表结构，链表中元素的类型将为<code>mem_map_t</code>(即<code>struct page</code>结构)。<code>Map</code>域指向一个位图，其大小取决于现有的页面数。<code>free_area</code>第<code>k</code>项位图的每一位，描述的就是大小为 2k 个页面的两个伙伴块的状态。如果位图的某位为 0，表示一对兄弟块中或者两个都空闲，或者两个都被分配，如果为 1，肯定有一块已被分配。当兄弟块都空闲时，内核把它们当作一个大小为 2k+1的单独块来处理。如图 6.9 给出该数据结构的示意图。</p>
<p><img src="/img/1633616074.jpg" alt=""></p>
<p>图 6.9 中，<code>free_aea</code>数组的元素 0 包含了一个空闲页(页面编号为 0)；而元素 2 则包含了两个以 4 个页面为大小的空闲页面块，第一个页面块的起始编号为 4，而第二个页面块的起始编号为 56。</p>
<p>我们曾提到，当需要分配若干个内存页面时，用于<code>DMA</code>的内存页面必须是连续的。其实为了便于管理，从伙伴算法可以看出，只要请求分配的块大小不超过 512 个页面(2KB)，内核就尽量分配连续的页面。</p>
<h3 id="物理页面的分配和释放"><a href="#物理页面的分配和释放" class="headerlink" title="物理页面的分配和释放"></a>物理页面的分配和释放</h3><p>当一个进程请求分配连续的物理页面时，可以通过调用<code>alloc_pages()</code>来完成。Linux 2.4版本中有两个<code>alloc_pages()</code>，一个在<code>mm/numa.c</code>中，另一个在<code>mm/page_alloc,c</code>中，编译时根据所定义的条件选项<code>CONFIG_DISCONTIGMEM</code>来进行取舍。</p>
<h4 id="非一致存储结构-NUMA-中页面的分配"><a href="#非一致存储结构-NUMA-中页面的分配" class="headerlink" title="非一致存储结构(NUMA)中页面的分配"></a>非一致存储结构(NUMA)中页面的分配</h4><p><code>CONFIG_DISCONTIGMEM</code>条件编译的含义是“不连续的存储空间”，Linux把不连续的存储空间也归类为非一致存储结构(NUMA)。这是因为，不连续的存储空间本质上是一种广义的NUMA，因为那说明在最低物理地址和最高物理地址之间存在着空洞，而有空洞的空间当然是“不一致”的。所以，在地址不连续的物理空间也要像结构不一样的物理空间那样划分出若干连续且均匀的“节点”。因此，在存储结构不连续的系统中，每个模块都有若干个节点，因而都有个<code>pg_data_t</code>数据结构队列。我们先来看<code>mm/numa.c</code>中的<code>alloc_page()</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This can be refined. Currently, tries to do round robin, instead</span></span><br><span class="line"><span class="comment"> * should do concentratic circle search, starting from current node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> * _<span class="title">alloc_pages</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">ret</span> =</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">pg_data_t</span> *start, *temp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">static</span> <span class="type">pg_data_t</span> *next = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (order &gt;= MAX_ORDER)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    temp = NODE_DATA(numa_node_id());</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    spin_lock_irqsave(&amp;node_lock, flags);</span><br><span class="line">    <span class="keyword">if</span> (!next) next = pgdat_list;</span><br><span class="line">    temp = next;</span><br><span class="line">    next = next-&gt;node_next;</span><br><span class="line">    spin_unlock_irqrestore(&amp;node_lock, flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    start = temp;</span><br><span class="line">    <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = alloc_pages_pgdat(temp, gfp_mask, order)))</span><br><span class="line">            <span class="keyword">return</span>(ret);</span><br><span class="line">        temp = temp-&gt;node_next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = pgdat_list;</span><br><span class="line">    <span class="keyword">while</span> (temp != start) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = alloc_pages_pgdat(temp, gfp_mask, order)))</span><br><span class="line">            <span class="keyword">return</span>(ret);</span><br><span class="line">        temp = temp-&gt;node_next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对该函数的说明如下。</p>
<p>该函数有两个参数。<code>gfp_mask</code>表示采用哪种分配策略。参数<code>order</code>表示所需物理块的大小，可以是 1、2、3 直到<code>2MAX_ORDER-1</code>。如果定义了<code>CONFIG_NUMA</code>，也就是在<code>NUMA</code>结构的系统中，可以通过<code>NUMA_DATA()</code>宏找到CPU所在节点的<code>pg_data_t</code>数据结构队列，并存放在临时变量<code>temp</code>中。</p>
<p>如果在不连续的<code>UMA</code>结构中，则有个<code>pg_data_t</code>数据结构的队列<code>pgdat_list</code>，<code>pgdat_list</code>就是该队列的首部。因为队列一般都是临界资源，因此，在对该队列进行两个以上的操作时要加锁。</p>
<p>分配时轮流从各个节点开始，以求各节点负荷的平衡。函数中有两个循环，其形式基本相同，也就是，对节点队列基本进行两遍扫描，直至在某个节点内分配成功，则跳出循环，否则，则彻底失败，从而返回 0。对于每个节点，调用<code>alloc_pages_pgdat()</code>函数试图分配所需的页面。</p>
<h4 id="一致存储结构-UMA-中页面的分配"><a href="#一致存储结构-UMA-中页面的分配" class="headerlink" title="一致存储结构(UMA)中页面的分配"></a>一致存储结构(UMA)中页面的分配</h4><p>连续空间<code>UMA</code>结构的<code>alloc_page()</code>是在<code>include/linux/mm.h</code>中定义的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_DISCONTIGMEM</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page * <span class="title function_">alloc_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Gets optimized away by the compiler.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (order &gt;= MAX_ORDER)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> __alloc_pages(gfp_mask, order, </span><br><span class="line">        contig_page_data.node_zonelists+(gfp_mask &amp; GFP_ZONEMASK));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>从这个函数的定义可以看出，<code>alloc_page()</code>是<code>_alloc_pages()</code>的封装函数，而<code>_alloc_pages()</code>才是伙伴算法的核心。这个函数定义于<code>mm/page_alloc.c</code>中，我们先对此函数给予概要描述。</p>
<p><code>_alloc_pages()</code>在管理区链表<code>zonelist</code>中依次查找每个区，从中找到满足要求的区，然后用伙伴算法从这个区中分配给定大小(<code>2^order</code>个)的页面块。如果所有的区都没有足够的空闲页面，则调用<code>swapper</code>或<code>bdflush</code>内核线程，把脏页写到磁盘以释放一些页面。在<code>__alloc_pages()</code>和虚拟内存(简称VM)的代码之间有一些复杂的接口。每个区都要对刚刚被映射到某个进程<code>VM</code>的页面进行跟踪，被映射的页面也许仅仅做了标记，而并没有真正地分配出去。因为根据虚拟存储的分配原理，对物理页面的分配要尽量推迟到不能再推迟为止，也就是说，当进程的代码或数据必须装入到内存时，才给它真正分配物理页面。</p>
<p>搞清楚页面分配的基本原则后，我们对其代码具体分析如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the &#x27;heart&#x27; of the zoned buddy allocator:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> * __<span class="title">alloc_pages</span>(<span class="title">unsigned</span> <span class="title">int</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">zonelist_t</span> *<span class="title">zonelist</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min;</span><br><span class="line">    <span class="type">zone_t</span> **zone, * classzone;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> * <span class="title">page</span>;</span> </span><br><span class="line">    <span class="type">int</span> freed;</span><br><span class="line">    zone = zonelist-&gt;zones;</span><br><span class="line">    classzone = *zone;</span><br><span class="line">    min = <span class="number">1UL</span> &lt;&lt; order;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">zone_t</span> *z = *(zone++);</span><br><span class="line">        <span class="keyword">if</span> (!z)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        min += z-&gt;pages_low;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;free_pages &gt; min) &#123;</span><br><span class="line">            page = rmqueue(z, order);</span><br><span class="line">            <span class="keyword">if</span> (page)</span><br><span class="line">                <span class="keyword">return</span> page;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>这是对一个分配策略中所规定的所有页面管理区的循环。循环中依次考察各个区中空闲页面的总量，如果总量尚大于“最低水位线”与所请求页面数之和，就调用<code>rmqueue()</code>试图从该区中进行分配。如果分配成功，则返回一个<code>page</code>结构指针，指向页面块中第一个页面的起始地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">classzone-&gt;need_balance = <span class="number">1</span>;</span><br><span class="line">mb();</span><br><span class="line"><span class="keyword">if</span> (waitqueue_active(&amp;kswapd_wait))</span><br><span class="line">    wake_up_interruptible(&amp;kswapd_wait);</span><br></pre></td></tr></table></figure></p>
<p>如果发现管理区中的空闲页面总量已经降到最低点，则把<code>zone_t</code>结构中需要重新平衡的标志(<code>need_balance</code>)置 1，而且如果内核线程<code>kswapd</code>在一个等待队列中睡眠，就唤醒它，让它收回一些页面以备使用(可以看出，<code>need_balance</code>是和<code>kswapd</code>配合使用的)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">zone = zonelist-&gt;zones;</span><br><span class="line">min = <span class="number">1UL</span> &lt;&lt; order;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> local_min;</span><br><span class="line">    <span class="type">zone_t</span> *z = *(zone++);</span><br><span class="line">    <span class="keyword">if</span> (!z)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    local_min = z-&gt;pages_min;</span><br><span class="line">    <span class="keyword">if</span> (!(gfp_mask &amp; __GFP_WAIT))</span><br><span class="line">        local_min &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    min += local_min;</span><br><span class="line">    <span class="keyword">if</span> (z-&gt;free_pages &gt; min) &#123;</span><br><span class="line">        page = rmqueue(z, order);</span><br><span class="line">        <span class="keyword">if</span> (page)</span><br><span class="line">            <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果给定分配策略中所有的页面管理区都分配失败，那只好把原来的“最低水位”再向下调(除以 4)，然后看是否满足要求(<code>z-&gt;free_pages &gt; min</code>)，如果能满足要求，则调用<code>rmqueue()</code>进行分配。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* here we&#x27;re in the low on memory slow path */</span></span><br><span class="line">rebalance:</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;flags &amp; (PF_MEMALLOC | PF_MEMDIE)) &#123;</span><br><span class="line">        zone = zonelist-&gt;zones;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">zone_t</span> *z = *(zone++);</span><br><span class="line">            <span class="keyword">if</span> (!z)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            page = rmqueue(z, order);</span><br><span class="line">            <span class="keyword">if</span> (page)</span><br><span class="line">                <span class="keyword">return</span> page;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果分配还不成功，这时候就要看是哪类进程在请求分配内存页面。其中<code>PF_MEMALLOC</code>和<code>PF_MEMDIE</code>是进程的<code>task_struct</code>结构中<code>flags</code>域的值，对于正在分配页面的进程(如<code>kswapd</code>内核线程)，则其<code>PF_MEMALLOC</code>的值为 1(一般进程的这个标志为 0)，而对于使内存溢出而被杀死的进程，则其<code>PF_MEMDIE</code>为 1。不管哪种情况，都说明必须给该进程分配页面。因此，继续进行分配。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Atomic allocations - we can&#x27;t balance anything */</span></span><br><span class="line"><span class="keyword">if</span> (!(gfp_mask &amp; __GFP_WAIT))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果请求分配页面的进程不能等待，也不能被重新调度，只好在没有分配到页面的情况下“空手”返回。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">page = balance_classzone(classzone, gfp_mask, order, &amp;freed);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line">    <span class="keyword">return</span> page;</span><br></pre></td></tr></table></figure></p>
<p>如果经过几番努力，必须得到页面的进程(如<code>kswapd</code>)还没有分配到页面，就要调用<code>balance_classzone()</code>函数把当前进程所占有的局部页面释放出来。如果释放成功，则返回一个<code>page</code>结构指针，指向页面块中第一个页面的起始地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">zone = zonelist-&gt;zones;</span><br><span class="line">min = <span class="number">1UL</span> &lt;&lt; order;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">zone_t</span> *z = *(zone++);</span><br><span class="line">    <span class="keyword">if</span> (!z)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    min += z-&gt;pages_min;</span><br><span class="line">    <span class="keyword">if</span> (z-&gt;free_pages &gt; min) &#123;</span><br><span class="line">        page = rmqueue(z, order);</span><br><span class="line">        <span class="keyword">if</span> (page)</span><br><span class="line">            <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续进行分配。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Don&#x27;t let big-order allocations loop */</span></span><br><span class="line">    <span class="keyword">if</span> (order &gt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* Yield for kswapd, and try again */</span></span><br><span class="line">    current-&gt;policy |= SCHED_YIELD;</span><br><span class="line">    __set_current_state(TASK_RUNNING);</span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">goto</span> rebalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个函数中，频繁调用了<code>rmqueue()</code>函数，下面我们具体来看一下这个函数内容。</p>
<p><code>rmqueue()</code>函数试图从一个页面管理区分配若干连续的内存页面。这是最基本的分配操作，其具体代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page * <span class="title function_">rmqueue</span><span class="params">(<span class="type">zone_t</span> *zone, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">free_area_t</span> * area = zone-&gt;free_area + order;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> curr_order = order;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">head</span>, *<span class="title">curr</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        head = &amp;area-&gt;free_list;</span><br><span class="line">        curr = memlist_next(head);</span><br><span class="line">        <span class="keyword">if</span> (curr != head) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> index;</span><br><span class="line">            page = memlist_entry(curr, <span class="keyword">struct</span> page, <span class="built_in">list</span>);</span><br><span class="line">            <span class="keyword">if</span> (BAD_RANGE(zone,page))</span><br><span class="line">                BUG();</span><br><span class="line">            memlist_del(curr);</span><br><span class="line">            index = page - zone-&gt;zone_mem_map;</span><br><span class="line">            <span class="keyword">if</span> (curr_order != MAX_ORDER<span class="number">-1</span>)</span><br><span class="line">                MARK_USED(index, curr_order, area);</span><br><span class="line">            zone-&gt;free_pages -= <span class="number">1UL</span> &lt;&lt; order;</span><br><span class="line">            page = expand(zone, page, index, order, curr_order, area);</span><br><span class="line">            spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span><br><span class="line">            set_page_count(page, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (BAD_RANGE(zone,page))</span><br><span class="line">                BUG();</span><br><span class="line">            <span class="keyword">if</span> (PageLRU(page))</span><br><span class="line">                BUG();</span><br><span class="line">            <span class="keyword">if</span> (PageActive(page))</span><br><span class="line">                BUG();</span><br><span class="line">            <span class="keyword">return</span> page; </span><br><span class="line">        &#125;</span><br><span class="line">        curr_order++;</span><br><span class="line">        area++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (curr_order &lt; MAX_ORDER);</span><br><span class="line">    spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对该函数的解释如下。<br>参数<code>zone</code>指向要分配页面的管理区，<code>order</code>表示要求分配的页面数为<code>2^order</code>。</p>
<p><code>do</code>循环从<code>free_area</code>数组的第<code>order</code>个元素开始，扫描每个元素中由<code>page</code>结构组成的双向循环空闲队列。如果找到合适的页块，就把它从队列中删除，删除的过程是不允许其他进程、其他处理器来打扰的。所以要用<code>spin_lock_irqsave()</code>将这个循环加上锁。</p>
<p>首先在恰好满足大小要求的队列里进行分配。其中<code>memlist_entry(curr, struct page, list)</code>获得空闲块的第 1 个页面的地址，如果这个地址是个无效的地址，就陷入<code>BUG()</code>。如果有效，<code>memlist_del(curr)</code>从队列中摘除分配出去的页面块。如果某个页面块被分配出去，就要在<code>frea_area</code>的位图中进行标记，这是通过调用<code>MARK_USED()</code>宏来完成的。</p>
<p>如果分配出去后还有剩余块，就通过<code>expand()</code>获得所分配的页块，而把剩余块链入适当的空闲队列中。</p>
<p>如果当前空闲队列没有空闲块，就从更大的空闲块队列中找。</p>
<p><code>expand()</code>函数源代码如下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page * <span class="title function_">expand</span> <span class="params">(<span class="type">zone_t</span> *zone, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> index, <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">free_area_t</span> * area)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = <span class="number">1</span> &lt;&lt; high;</span><br><span class="line">    <span class="keyword">while</span> (high &gt; low) &#123;</span><br><span class="line">        <span class="keyword">if</span> (BAD_RANGE(zone,page))</span><br><span class="line">            BUG();</span><br><span class="line">        area--;</span><br><span class="line">        high--;</span><br><span class="line">        size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        memlist_add_head(&amp;(page)-&gt;<span class="built_in">list</span>, &amp;(area)-&gt;free_list);</span><br><span class="line">        MARK_USED(index, high, area);</span><br><span class="line">        index += size;</span><br><span class="line">        page += size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (BAD_RANGE(zone,page))</span><br><span class="line">        BUG();</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数<code>zone</code>指向已分配页块所在的管理区；<code>page</code>指向已分配的页块；<code>index</code>是已分配的页面在<code>mem_map</code>中的下标；<code>low</code>表示所需页面块大小为<code>2^low</code>，而<code>high</code>表示从空闲队列中实际进行分配的页面块大小为<code>2^high</code>；<code>area</code>是<code>free_area_struct</code>结构，指向实际要分配的页块。</p>
<p>通过上面介绍可以知道，返回给请求者的块大小为<code>2^low</code>个页面，并把剩余的页面放入合适的空闲队列，且对伙伴系统的位图进行相应的修改。例如，假定我们需要一个 2 页面的块，但是，我们不得不从<code>order</code>为 3(8 个页面)的空闲队列中进行分配，又假定我们碰巧选择物理页面 800 作为该页面块的底部。在我们这个例子中，这几个参数值为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">page == mem_map+<span class="number">800</span></span><br><span class="line">index == <span class="number">800</span></span><br><span class="line">low == <span class="number">1</span></span><br><span class="line">high == <span class="number">3</span></span><br><span class="line">area == zone-&gt;free_area+high ( 也就是`frea_area`数组中下标为 <span class="number">3</span> 的元素)</span><br></pre></td></tr></table></figure></p>
<p>首先把<code>size</code>初始化为分配块的页面数(例如，size = 1&lt;<3 == 8) `while`循环进行循环查找。每次循环都把`size`减半。如果我们从空闲队列中分配的一个块与所要求的大小匹配，那么`low = high`，就彻底从循环中跳出，返回所分配的页块。如果分配到的物理块所在的空闲块大于所需块的大小(即`2^high > 2^low<code>)，那就将该空闲块分为两半(即</code>area—;high—; size &gt;&gt;= 1)<code>，然后调用</code>memlist_add_head()<code>把刚分配出去的页面块又加入到低一档(物理块减半)的空闲队列中，准备从剩下的一半空闲块中重新进行分配，并调用</code>MARK_USED()`设置位图。</p>
<p>在上面的例子中，第 1 次循环，我们从页面 800 开始，把页面大小为 4的块其首地址插入到<code>frea_area[2]</code>中的空闲队列；因为<code>low&lt;high</code>，又开始第 2 次循环，这次从页面 804 开始，把页面大小为 2 的块插入到<code>frea_area[1]</code>中的空闲队列，此时，page＝806，high=low=1，退出循环，我们给调用者返回从 806 页面开始的一个 2 页面块。从这个例子可以看出，这是一种巧妙的分配算法。</p>
<h4 id="释放页面"><a href="#释放页面" class="headerlink" title="释放页面"></a>释放页面</h4><p>从上面的介绍可以看出，页面块的分配必然导致内存的碎片化，而页面块的释放则可以将页面块重新组合成大的页面块。页面的释放函数为<code>__free_pages(page struct *page, unsigned long order)</code>，该函数从给定的页面开始，释放的页面块大小为<code>2^order</code>。原函数为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __free_pages(page <span class="keyword">struct</span> *page, <span class="type">unsigned</span> <span class="type">long</span> order)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!PageReserved(page) &amp;&amp; put_page_testzero(page))</span><br><span class="line">        __free_pages_ok(page, order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中比较巧妙的部分就是调用<code>put_page_testzero()</code>宏，该函数把页面的引用计数减 1，如果减 1 后引用计数为 0，则该函数返回 1。因此，如果调用者不是该页面的最后一个用户，那么，这个页面实际上就不会被释放。另外要说明的是不可释放保留页<code>PageReserved</code>，这是通过<code>PageReserved()</code>宏进行检查的。</p>
<p>如果调用者是该页面的最后一个用户，则<code>__free_pages()</code>再调用<code>__free_pages_ok()</code>。<code>__free_pages_ok()</code>才是对页面块进行释放的实际函数，该函数把释放的页面块链入空闲链表，并对伙伴系统的位图进行管理，必要时合并伙伴块。这实际上是<code>expand()</code>函数的反操作。</p>
<h3 id="Slab分配机制"><a href="#Slab分配机制" class="headerlink" title="Slab分配机制"></a>Slab分配机制</h3><p>采用伙伴算法分配内存时，每次至少分配一个页面。但当请求分配的内存大小为几十个字节或几百个字节时应该如何处理？如何在一个页面中分配小的内存区，小内存区的分配所产生的内碎片又如何解决？</p>
<p>Linux 2.0 采用的解决办法是建立了 13 个空闲区链表，它们的大小从 32 字节到 132056字节。从Linux 2.2 开始，<code>MM</code>的开发者采用了一种叫做<code>Slab</code>的分配模式，主要是基于以下考虑。</p>
<ul>
<li>内核对内存区的分配取决于所存放数据的类型。例如，当给用户态进程分配页面时，内核调用<code>get_free_page()</code>函数，并用 0 填充这个页面。而给内核的数据结构分配页面时，事情没有这么简单，例如，要对数据结构所在的内存进行初始化、在不用时要收回它们所占用的内存。因此，Slab中引入了对象这个概念，所谓对象就是存放一组数据结构的内存区，其方法就是构造或析构函数，构造函数用于初始化数据结构所在的内存区，而析构函数收回相应的内存区。为了避免重复初始化对象，Slab分配模式并不丢弃已分配的对象，而是释放但把它们依然保留在内存中。当以后又要请求分配同一对象时，就可以从内存获取而不用进行初始化，这是在<code>Solaris</code>中引入<code>Slab</code>的基本思想。</li>
</ul>
<p>出于效率的考虑，Linux并不调用对象的构造或析构函数，而是把指向这两个函数的指针都置为空。Linux中引入<code>Slab</code>的主要目的是为了减少对伙伴算法的调用次数。</p>
<p>实际上，内核经常反复使用某一内存区。例如，只要内核创建一个新的进程，就要为该进程相关的数据结构(task_struct、打开文件对象等)分配内存区。当进程结束时，收回这些内存区。因为进程的创建和撤销非常频繁，因此，Linux的早期版本把大量的时间花费在反复分配或回收这些内存区上。从Linux 2.2 开始，把那些频繁使用的页面保存在高速缓存中并重新使用。</p>
<p>可以根据对内存区的使用频率来对它分类。对于预期频繁使用的内存区，可以创建一组特定大小的专用缓冲区进行处理，以避免内碎片的产生。对于较少使用的内存区，可以创建一组通用缓冲区(如Linux 2.0 中所使用的 2 的幂次方)来处理，即使这种处理模式产生碎片，也对整个系统的性能影响不大。</p>
<p>硬件高速缓存的使用，又为尽量减少对伙伴算法的调用提供了另一个理由，因为对伙伴算法的每次调用都会“弄脏”硬件高速缓存，因此，这就增加了对内存的平均访问次数。Slab分配模式把对象分组放进缓冲区。因为缓冲区的组织和管理与硬件高速缓存的命中率密切相关，因此，Slab缓冲区并非由各个对象直接构成，而是由一连串的“大块(Slab)”构成，而每个大块中则包含了若干个同种类型的对象，这些对象或已被分配，或空闲，如图6.10 所示。一般而言，对象分两种，一种是大对象，一种是小对象。<br><img src="/img/1633769261.jpg" alt=""></p>
<p>所谓小对象，是指在一个页面中可以容纳下好几个对象的那种。例如，一个<code>inode</code>结构大约占 300 多个字节，因此，一个页面中可以容纳 8 个以上的<code>inode</code>结构，因此，inode`结构就为小对象。Linux内核中把小于 512 字节的对象叫做小对象。</p>
<h4 id="Slab的数据结构"><a href="#Slab的数据结构" class="headerlink" title="Slab的数据结构"></a>Slab的数据结构</h4><p>Slab分配模式有两个主要的数据结构，一个是描述缓冲区的结构<code>kmem_cache_t</code>，一个是描述<code>Slab</code>的结构<code>kmem_slab_t</code>，下面对这两个结构给予简要讨论。</p>
<p><code>Slab</code>是<code>Slab</code>管理模式中最基本的结构。它由一组连续的物理页面组成，对象就被顺序放在这些页面中。其数据结构在<code>mm/slab.c</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* slab_t</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Manages the objs in a slab. Placed either at the beginning of mem allocated</span></span><br><span class="line"><span class="comment">* for a slab, or allocated from an general cache.</span></span><br><span class="line"><span class="comment">* Slabs are chained into three list: fully used, partial, fully free slabs.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slab_s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> colouroff;</span><br><span class="line">    <span class="type">void</span> *s_mem; <span class="comment">/* including colour offset */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> inuse; <span class="comment">/* num of objs active in slab */</span></span><br><span class="line">    <span class="type">kmem_bufctl_t</span> <span class="built_in">free</span>;</span><br><span class="line">&#125; <span class="type">slab_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>这里的链表用来将前一个<code>Slab</code>和后一个<code>Slab</code>链接起来形成一个双向链表，<code>colouroff</code>为该<code>Slab</code>上着色区的大小，指针<code>s_mem</code>指向对象区的起点，<code>inuse</code>是<code>Slab</code>中所分配对象的个数。最后，<code>free</code>的值指明了空闲对象链中的第一个对象，<code>kmem_bufctl_t</code>其实是一个整数。</p>
<p><code>Slab</code>结构的示意图如图 6.11 所示。</p>
<p>对于小对象，就把<code>Slab</code>的描述结构<code>slab_t</code>放在该<code>Slab</code>中；对于大对象，则把<code>Slab</code>结构游离出来，集中存放。关于<code>Slab</code>中的着色区再给予具体描述。每个<code>Slab</code>的首部都有一个小小的区域是不用的，称为“着色区(Coloring Area)”。着色区的大小使<code>Slab</code>中的每个对象的起始地址都按高速缓存中的“缓存行(Cache Line)”大小进行对齐(80386 的一级高速缓存行大小为 16 字节，Pentium为 32 字节)。因为<code>Slab</code>是由 1 个页面或多个页面(最多为 32)组成，因此，每个<code>Slab</code>都是从一个页面边界开始的，它自然按高速缓存的缓冲行对齐。</p>
<p>但是，Slab中的对象大小不确定，设置着色区的目的就是将<code>Slab</code>中第一个对象的起始地址往后推到与缓冲行对齐的位置。因为一个缓冲区中有多个<code>Slab</code>，因此，应该把每个缓冲区中的各个<code>Slab</code>着色区的大小尽量安排成不同的大小，这样可以使得在不同的<code>Slab</code>中，处于同一相对位置的对象，让它们在高速缓存中的起始地址相互错开，这样就可以改善高速缓存的存取效率。<br><img src="/img/1633769552.jpg" alt=""></p>
<p>每个<code>Slab</code>上最后一个对象以后也有个小小的废料区是不用的，这是对着色区大小的补偿，其大小取决于着色区的大小，以及<code>Slab</code>与其每个对象的相对大小。但该区域与着色区的总和对于同一种对象的各个<code>Slab</code>是个常数。每个对象的大小基本上是所需数据结构的大小。只有当数据结构的大小不与高速缓存中的缓冲行对齐时，才增加若干字节使其对齐。所以，一个<code>Slab</code>上的所有对象的起始地址都必然是按高速缓存中的缓冲行对齐的。</p>
<p>每个缓冲区管理着一个<code>Slab</code>链表，<code>Slab</code>按序分为 3 组。第 1 组是全满的<code>Slab</code>(没有空闲的对象)，第 2 组<code>Slab</code>中只有部分对象被分配，部分对象还空闲，最后一组<code>Slab</code>中的对象全部空闲。只所以这样分组，是为了对<code>Slab</code>进行有效的管理。每个缓冲区还有一个轮转锁(Spinlock)，在对链表进行修改时用这个轮转锁进行同步。类型<code>kmem_cache_s</code>在<code>mm/slab.c</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_s</span> &#123;</span></span><br><span class="line"><span class="comment">/* 1) each alloc &amp; free */</span></span><br><span class="line"><span class="comment">/* full, partial first, then free */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> objsize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags; <span class="comment">/* constant flags */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num; <span class="comment">/* # of objs per slab */</span></span><br><span class="line">    <span class="type">spinlock_t</span> spinlock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> batchcount;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 2) slab additions /removals */</span></span><br><span class="line"><span class="comment">/* order of pgs per slab (2^n) */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> gfporder;</span><br><span class="line"><span class="comment">/* force GFP flags, e.g. GFP_DMA */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> gfpflags;</span><br><span class="line">    <span class="type">size_t</span> colour; <span class="comment">/* cache colouring range */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> colour_off; <span class="comment">/* colour offset */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> colour_next; <span class="comment">/* cache colouring */</span></span><br><span class="line">    <span class="type">kmem_cache_t</span> *slabp_cache;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> growing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dflags; <span class="comment">/* dynamic flags */</span></span><br><span class="line">    <span class="comment">/* constructor func */</span></span><br><span class="line">    <span class="type">void</span> (*ctor)(<span class="type">void</span> *, <span class="type">kmem_cache_t</span> *, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="comment">/* de-constructor func */</span></span><br><span class="line">    <span class="type">void</span> (*dtor)(<span class="type">void</span> *, <span class="type">kmem_cache_t</span> *, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> failures;</span><br><span class="line"><span class="comment">/* 3) cache creation/removal */</span></span><br><span class="line">    <span class="type">char</span> name[CACHE_NAMELEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="comment">/* 4) per-cpu data */</span></span><br><span class="line">    <span class="type">cpucache_t</span> *cpudata[NR_CPUS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">…..</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后定义了<code>kmem_cache_t</code>，并给部分域赋予了初值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">kmem_cache_t</span> cache_cache = &#123;</span><br><span class="line"> slabs_full: LIST_HEAD_INIT(cache_cache.slabs_full),</span><br><span class="line"> slabs_partial: LIST_HEAD_INIT(cache_cache.slabs_partial),</span><br><span class="line"> slabs_free: LIST_HEAD_INIT(cache_cache.slabs_free), </span><br><span class="line"> objsize: <span class="keyword">sizeof</span>(<span class="type">kmem_cache_t</span>),</span><br><span class="line"> flags: SLAB_NO_REAP,</span><br><span class="line"> spinlock: SPIN_LOCK_UNLOCKED,</span><br><span class="line"> colour_off: L1_CACHE_BYTES,</span><br><span class="line"> name: <span class="string">&quot;kmem_cache&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对该结构说明如下。<br>该结构中有 3 个队列<code>slabs_full</code>、<code>slabs_partial</code>以及<code>slabs_free</code>，分别指向满<code>Slab</code>、半满<code>Slab</code>和空闲<code>Slab</code>，另一个队列<code>next</code>则把所有的专用缓冲区链成一个链表。除了这些队列和指针外，该结构中还有一些重要的域：<code>objsize</code>是原始的数据结构的大小，这里初始化为<code>kmem_cache_t</code>的大小；<code>num</code>表示每个<code>Slab</code>上有几个缓冲区；<code>gfporder</code>则表示每个<code>Slab</code>大小的对数，即每个<code>Slab</code>由<code>2^gfporder</code>个页面构成。</p>
<p>如前所述，着色区的使用是为了使同一缓冲区中不同<code>Slab</code>上的对象区的起始地址相互错开，这样有利于改善高速缓存的效率。<code>colour_off</code>表示颜色的偏移量，<code>colour</code>表示颜色的数量；一个缓冲区中颜色的数量取决于<code>Slab</code>中对象的个数、剩余空间以及高速缓存行的大小。所以，对每个缓冲区都要计算它的颜色数量，这个数量就保存在<code>colour</code>中，而下一个<code>Slab</code>将要使用的颜色则保存在<code>colour_next</code>中。当<code>colour_next</code>达到最大值时，就又从 0 开始。</p>
<p>着色区的大小可以根据(<code>colour_off×colour</code>)算得。例如，如果<code>colour</code>为 5，<code>colour_off</code>为 8，则第一个<code>Slab</code>的颜色将为 0，<code>Slab</code>中第一个对象区的起始地址(相对)为 0，下一个<code>Slab</code>中第一个对象区的起始地址为 8，再下一个为 16，24，32，0……等。<code>cache_cache</code>变量实际上就是缓冲区结构的头指针。</p>
<p>由此可以看出，缓冲区结构<code>kmem_cache_t</code>相当于<code>Slab</code>的总控结构，缓冲区结构与<code>Slab</code>结构之间的关系如图 6.12 所示。<br><img src="/img/1633772014.jpg" alt=""></p>
<p>在图 6.12 中，深灰色表示全满的<code>Slab</code>，浅灰色表示含有空闲对象的<code>Slab</code>，而无色表示空的<code>Slab</code>。缓冲区结构之间形成一个单向链表，<code>Slab</code>结构之间形成一个双向链表。另外，缓冲区结构还有分别指向满、半满、空闲<code>Slab</code>结构的指针。</p>
<h4 id="专用缓冲区的建立和撤销"><a href="#专用缓冲区的建立和撤销" class="headerlink" title="专用缓冲区的建立和撤销"></a>专用缓冲区的建立和撤销</h4><p>专用缓冲区是通过<code>kmem_cache_create()</code>函数建立的，函数原型为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">kmem_cache_t</span> *<span class="title function_">kmem_cache_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">size_t</span> size, <span class="type">size_t</span> offset,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> c_flags,</span></span><br><span class="line"><span class="params"><span class="type">void</span> (*ctor) (<span class="type">void</span> *objp, <span class="type">kmem_cache_t</span> *cachep, <span class="type">unsigned</span> <span class="type">long</span> flags),</span></span><br><span class="line"><span class="params"><span class="type">void</span> (*dtor) (<span class="type">void</span> *objp, <span class="type">kmem_cache_t</span> *cachep, <span class="type">unsigned</span> <span class="type">long</span> flags))</span> </span><br></pre></td></tr></table></figure></p>
<p>对其参数说明如下。</p>
<ul>
<li><code>name</code>：缓冲区名 ( 19 个字符)。</li>
<li><code>size</code>：对象大小。</li>
<li><code>offset</code>：所请求的着色偏移量。</li>
<li><code>c_flags</code>：对缓冲区的设置标志。<ul>
<li><code>SLAB_HWCACHE_ALIGN</code>：表示与第一个高速缓存中的缓冲行边界(16 或 32 字节)对齐。</li>
<li><code>SLAB_NO_REAP</code>：不允许系统回收内存。</li>
<li><code>SLAB_CACHE_DMA</code>：表示<code>Slab</code>使用的是<code>DMA</code>内存。</li>
</ul>
</li>
<li><code>ctor</code>：构造函数(一般都为<code>NULL</code>)。</li>
<li><code>dtor</code>：析构函数(一般都为<code>NULL</code>)。</li>
<li><code>objp</code>：指向对象的指针。</li>
<li><code>cachep</code>：指向缓冲区。</li>
</ul>
<p><code>kmem_cache_create()</code>函数要进行一系列的计算，以确定最佳的<code>Slab</code>构成。包括：每个<code>Slab</code>由几个页面组成，划分为多少个对象；<code>Slab</code>的描述结构<code>slab_t</code>应该放在<code>Slab</code>的外面还是放在<code>Slab</code>的尾部；还有“颜色”的数量等等。并根据调用参数和计算结果设置<code>kmem_cache_t</code>结构中的各个域，包括两个函数指针<code>ctor</code>和<code>dtor</code>。最后，将<code>kmem_cache_t</code>结构插入到<code>cache_cache</code>的<code>next</code>队列中。</p>
<p>但请注意，函数<code>kmem_cache_create()</code>所创建的缓冲区中还没有包含任何<code>Slab</code>，因此，也没有空闲的对象。只有以下两个条件都为真时，才给缓冲区分配<code>Slab</code>：</p>
<ol>
<li>已发出一个分配新对象的请求；</li>
<li>缓冲区不包含任何空闲对象。</li>
</ol>
<p>当这两个条件都成立时，<code>Slab</code>分配模式就调用<code>kmem_cache_grow()</code>函数给缓冲区分配一个新的<code>Slab</code>。其中，该函数调用<code>kmem_gatepages()</code>从伙伴系统获得一组页面；然后又调用<code>kmem_cache_slabgmt()</code>获得一个新的<code>Slab</code>结构；还要调用<code>kmem_cache_init_objs()</code>为新<code>Slab</code>中的所有对象申请构造方法(如果定义的话)；最后，调用<code>kmem_slab_link_end()</code>把这个<code>Slab</code>结构插入到缓冲区中<code>Slab</code>链表的末尾。</p>
<p><code>Slab</code>分配模式的最大好处就是给频繁使用的数据结构建立专用缓冲区。但到目前的版本为止，Linux内核中多数专用缓冲区的建立都用<code>NULL</code>作为构造函数的指针，例如，为虚存区间结构<code>vm_area_struct</code>建立的专用缓冲区<code>vm_area_cachep</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm_area_cachep = kmem_cache_create(<span class="string">&quot;vm_area_struct&quot;</span>,</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> vm_area_struct), <span class="number">0</span>,</span><br><span class="line">    SLAB_HWCACHE_ALIGN, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p>就把构造和析构函数的指针置为<code>NULL</code>，也就是说，内核并没有充分利用<code>Slab</code>管理机制所提供的好处。为了说明如何利用专用缓冲区，我们从内核代码中选取一个构造函数不为空的简单例子，这个例子与网络子系统有关，在<code>net/core/buff.c</code>中定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">skb_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    skbuff_head_cache = kmem_cache_create(<span class="string">&quot;skbuff_head_cache&quot;</span>,</span><br><span class="line">            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sk_buff),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            SLAB_HWCACHE_ALIGN,</span><br><span class="line">            skb_headerinit, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!skbuff_head_cache)</span><br><span class="line">        panic(<span class="string">&quot;cannot create skbuff cache&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;NR_CPUS; i++)</span><br><span class="line">        skb_queue_head_init(&amp;skb_head_pool[i].<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码中可以看出，<code>skb_init()</code>调用<code>kmem_cache_create()</code>为网络子系统建立一个<code>sk_buff</code>数据结构的专用缓冲区，其名称为<code>skbuff_head_cache</code>(你可以通过读取<code>/proc/slabinfo/</code>文件得到所有缓冲区的名字)。调用参数<code>offset</code>为 0，表示第一个对象在<code>Slab</code>中的位移并无特殊要求。但是参数<code>flags</code>为<code>SLAB_HWCACHE_ALIGN</code>，表示<code>Slab</code>中的对象要与高速缓存中的缓冲行边界对齐。对象的构造函数为<code>skb_headerinit()</code>，而析构函数为空，也就是说，在释放一个<code>Slab</code>时无需对各个缓冲区进行特殊的处理。</p>
<p>当从内核卸载一个模块时，同时应当撤销为这个模块中的数据结构所建立的缓冲区，这是通过调用<code>kmem_cache_destroy()</code>函数来完成的。</p>
<h3 id="通用缓冲区"><a href="#通用缓冲区" class="headerlink" title="通用缓冲区"></a>通用缓冲区</h3><p>在内核中初始化开销不大的数据结构可以合用一个通用的缓冲区。通用缓冲区非常类似于物理页面分配中的大小分区，最小的为 32，然后依次为 64、128、……直至 128KB(即 32 个页面)，但是，对通用缓冲区的管理又采用的是<code>Slab</code>方式。从通用缓冲区中分配和释放缓冲区的函数为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> flags)</span>;</span><br><span class="line">Void <span class="title function_">kree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *objp)</span>; </span><br></pre></td></tr></table></figure></p>
<p>因此，当一个数据结构的使用根本不频繁时，或其大小不足一个页面时，就没有必要给其分配专用缓冲区，而应该调用<code>kmalloc()</code>进行分配。如果数据结构的大小接近一个页面，则干脆通过<code>alloc_page()</code>为之分配一个页面。事实上，在内核中，尤其是驱动程序中，有大量的数据结构仅仅是一次性使用，而且所占内存只有几十个字节，因此，一般情况下调用<code>kmalloc()</code>给内核数据结构分配内存就足够了。另外，因为，在Linux 2.0 以前的版本一般都调用<code>kmalloc()</code>给内核数据结构分配内存，因此，调用该函数的一个优点是(让你开发的驱动程序)能保持向后兼容。</p>
<h3 id="内核空间非连续内存区的管理"><a href="#内核空间非连续内存区的管理" class="headerlink" title="内核空间非连续内存区的管理"></a>内核空间非连续内存区的管理</h3><p>首先，非连续内存处于<code>3GB</code>到<code>4GB</code>之间，也就是处于内核空间，如图 6.13 所示。<br><img src="/img/1633773251.jpg" alt=""></p>
<p>图 6.13 中，<code>PAGE_OFFSET</code>为 3GB，<code>high_memory</code>为保存物理地址最高值的变量，<code>VMALLOC_START</code>为非连续区的的起始地址，定义于<code>include/i386/pgtable.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VMALLOC_OFFSET (8*1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VMALLOC_START (((unsigned long) high_memory + 2*VMALLOC_OFFSET-1) &amp; ~(VMALLOC_OFFSET-1))</span></span><br></pre></td></tr></table></figure></p>
<p>在物理地址的末尾与第一个内存区之间插入了一个 8MB(<code>VMALLOC_OFFSET</code>)的区间，这是一个安全区，目的是为了“捕获”对非连续区的非法访问。出于同样的理由，在其他非连续的内存区之间也插入了 4KB 大小的安全区。每个非连续内存区的大小都是 4096 的倍数。</p>
<h4 id="非连续区的数据结构"><a href="#非连续区的数据结构" class="headerlink" title="非连续区的数据结构"></a>非连续区的数据结构</h4><p>描述非连续区的数据结构为<code>struct vm_struct</code>，定义于<code>include/linux/vmalloc.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">void</span> * addr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> * <span class="title">vmlist</span>;</span> </span><br></pre></td></tr></table></figure></p>
<p>非连续区组成一个单链表，链表第一个元素的地址存放在变量<code>vmlist</code>中。<code>addr</code>域是内存区的起始地址；<code>size</code>是内存区的大小加 4096(安全区的大小)。</p>
<h4 id="创建一个非连续区的结构"><a href="#创建一个非连续区的结构" class="headerlink" title="创建一个非连续区的结构"></a>创建一个非连续区的结构</h4><p>函数<code>get_vm_area()</code>创建一个新的非连续区结构，其代码在<code>mm/vmalloc.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> vm_struct * <span class="title function_">get_vm_area</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> **<span class="title">p</span>, *<span class="title">tmp</span>, *<span class="title">area</span>;</span></span><br><span class="line">    area = (<span class="keyword">struct</span> vm_struct *) kmalloc(<span class="keyword">sizeof</span>(*area), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!area)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    size += PAGE_SIZE;</span><br><span class="line">    addr = VMALLOC_START;</span><br><span class="line">    write_lock(&amp;vmlist_lock);</span><br><span class="line">    <span class="keyword">for</span> (p = &amp;vmlist; (tmp = *p) ; p = &amp;tmp-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((size + addr) &lt; addr)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="keyword">if</span> (size + addr &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) tmp-&gt;addr)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        addr = tmp-&gt;size + (<span class="type">unsigned</span> <span class="type">long</span>) tmp-&gt;addr;</span><br><span class="line">        <span class="keyword">if</span> (addr &gt; VMALLOC_END-size)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    area-&gt;flags = flags;</span><br><span class="line">    area-&gt;addr = (<span class="type">void</span> *)addr;</span><br><span class="line">    area-&gt;size = size;</span><br><span class="line">    area-&gt;next = *p;</span><br><span class="line">    *p = area;</span><br><span class="line">    write_unlock(&amp;vmlist_lock);</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">out:</span><br><span class="line">    write_unlock(&amp;vmlist_lock);</span><br><span class="line">    kfree(area);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数比较简单，就是在单链表中插入一个元素。其中调用了<code>kmalloc()</code>和<code>kfree()</code>函数，分别用来为<code>vm_struct</code>结构分配内存和释放所分配的内存。</p>
<h4 id="分配非连续内存区"><a href="#分配非连续内存区" class="headerlink" title="分配非连续内存区"></a>分配非连续内存区</h4><p><code>vmalloc()</code>函数给内核分配一个非连续的内存区，在<code>/include/linux/vmalloc.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> * <span class="title function_">vmalloc</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM, PAGE_KERNEL);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<p><code>vmalloc()</code>最终调用的是<code>__vmalloc()</code>函数，该函数的代码在<code>mm/vmalloc.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * __vmalloc (<span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">int</span> gfp_mask, <span class="type">pgprot_t</span> prot)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span></span><br><span class="line">    size = PAGE_ALIGN(size);</span><br><span class="line">    <span class="keyword">if</span> (!size || (size &gt;&gt; PAGE_SHIFT) &gt; num_physpages) &#123;</span><br><span class="line">        BUG();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    area = get_vm_area(size, VM_ALLOC);</span><br><span class="line">    <span class="keyword">if</span> (!area)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    addr = area-&gt;addr;</span><br><span class="line">    <span class="keyword">if</span> (vmalloc_area_pages(VMALLOC_VMADDR(addr), size, gfp_mask, prot)) &#123;</span><br><span class="line">        vfree(addr);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数首先把<code>size</code>参数取整为页面大小(4096)的一个倍数，也就是按页的大小进行对齐，然后进行有效性检查，如果有大小合适的可用内存，就调用<code>get_vm_area()</code>获得一个内存区的结构。但真正的内存区还没有获得，函数<code>vmalloc_area_pages()</code>真正进行非连续内存区的分配：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">vmalloc_area_pages</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">int</span> gfp_mask, <span class="type">pgprot_t</span> prot)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pgd_t</span> * dir;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> end = address + size;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    dir = pgd_offset_k(address);</span><br><span class="line">    spin_lock(&amp;init_mm.page_table_lock);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">pmd_t</span> *pmd;</span><br><span class="line">        pmd = pmd_alloc(&amp;init_mm, dir, address);</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (!pmd)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (alloc_area_pmd(pmd, address, end - address, gfp_mask, prot))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        address = (address + PGDIR_SIZE) &amp; PGDIR_MASK;</span><br><span class="line">        dir++;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (address &amp;&amp; (address &lt; end)); </span><br><span class="line">    spin_unlock(&amp;init_mm.page_table_lock);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数有两个主要的参数，<code>address</code>表示内存区的起始地址，<code>size</code>表示内存区的大小。内存区的末尾地址赋给了局部变量<code>end</code>。其中还调用了几个主要的函数或宏。</p>
<ol>
<li><code>pgd_offset_k()</code>宏导出这个内存区起始地址在页目录中的目录项。</li>
<li><code>pmd_alloc()</code>为新的内存区创建一个中间页目录。</li>
<li><code>alloc_area_pmd()</code>为新的中间页目录分配所有相关的页表，并更新页的总目录；该函数调用<code>pte_alloc_kernel()</code>函数来分配一个新的页表，之后再调用<code>alloc_area_pte()</code>为页表项分配具体的物理页面。</li>
<li>从<code>vmalloc_area_pages()</code>函数可以看出，该函数实际建立起了非连续内存区到物理页面的映射。</li>
</ol>
<h4 id="kmalloc-与vmalloc-的区别"><a href="#kmalloc-与vmalloc-的区别" class="headerlink" title="kmalloc()与vmalloc()的区别"></a>kmalloc()与vmalloc()的区别</h4><p>从前面的介绍已经看出，这两个函数所分配的内存都处于内核空间，即从 3GB～4GB；但位置不同，<code>kmalloc()</code>分配的内存处于<code>3GB～high_memory</code>之间，而<code>vmalloc()</code>分配的内存在<code>VMALLOC_START～4GB</code>之间，也就是非连续内存区。一般情况下在驱动程序中都是调用<code>kmalloc()</code>来给数据结构分配内存，而<code>vmalloc()</code>用在为活动的交换区分配数据结构，为某些I/O驱动程序分配缓冲区，例如在<code>include/asm-i386/module.h</code>中定义了如下语句：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> module_map(x) vmalloc(x)</span></span><br></pre></td></tr></table></figure><br>其含义就是把模块映射到非连续的内存区。</p>
<p>与<code>kmalloc()和</code>vmalloc()<code>相对应，两个释放内存的函数为</code>kfree()<code>和</code>vfree()`。</p>
<h2 id="地址映射机制"><a href="#地址映射机制" class="headerlink" title="地址映射机制"></a>地址映射机制</h2><p>顾名思义地址映射就是建立几种存储媒介(内存，辅存，虚存)间的关联，完成地址间的相互转换，它既包括磁盘文件到虚拟内存的映射，也包括虚拟内存到物理内存的映射，如图 6.14 所示。<br><img src="/img/1633773943.jpg" alt=""></p>
<h3 id="描述虚拟空间的数据结构"><a href="#描述虚拟空间的数据结构" class="headerlink" title="描述虚拟空间的数据结构"></a>描述虚拟空间的数据结构</h3><p>一个进程的虚拟地址空间主要由两个数据结构来描述。一个是最高层次的：<code>mm_struct</code>，一个是较高层次的：<code>vm_area_structs</code>。最高层次的<code>mm_struct</code>结构描述了一个进程的整个虚拟地址空间。较高层次的结构<code>vm_area_truct</code>描述了虚拟地址空间的一个区间(简称虚拟区)。</p>
<h4 id="MM-STRUCT结构"><a href="#MM-STRUCT结构" class="headerlink" title="MM_STRUCT结构"></a>MM_STRUCT结构</h4><p><code>mm_strcut</code>用来描述一个进程的虚拟地址空间，在<code>/include/linux/sched.h</code>中描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span> <span class="comment">/* 指向虚拟区间(VMA)链表 */</span></span><br><span class="line">    <span class="type">rb_root_t</span> mm_rb; <span class="comment">/*指向red_black树*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_cache</span>;</span> <span class="comment">/* 指向最近找到的虚拟区间*/</span></span><br><span class="line">    <span class="type">pgd_t</span> * pgd; <span class="comment">/*指向进程的页目录*/</span></span><br><span class="line">    <span class="type">atomic_t</span> mm_users; <span class="comment">/* 用户空间中的有多少用户*/</span></span><br><span class="line">    <span class="type">atomic_t</span> mm_count; <span class="comment">/* 对&quot;struct mm_struct&quot;有多少引用*/</span></span><br><span class="line">    <span class="type">int</span> map_count; <span class="comment">/* 虚拟区间的个数*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">mmap_sem</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> page_table_lock; <span class="comment">/* 保护任务页表和`mm-&gt;rss */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span> <span class="comment">/*所有活动(active)mm`的链表 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rss, total_vm, locked_vm; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> def_flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cpu_vm_mask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> swap_address;</span><br><span class="line">    <span class="type">unsigned</span> dumpable:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Architecture-specific MM context */</span></span><br><span class="line">    <span class="type">mm_context_t</span> context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对该结构进一步说明如下。<br>在内核代码中，指向这个数据结构的变量常常是<code>mm</code>。每个进程只有一个<code>mm_struct</code>结构，在每个进程的<code>task_struct</code>结构中，有一个指向该进程的结构。可以说，<code>mm_struct</code>结构是对整个用户空间的描述。</p>
<p>一个进程的虚拟空间中可能有多个虚拟区间(参见下面对<code>vm_area_struct</code>描述)，对这些虚拟区间的组织方式有两种，当虚拟区间较少时采用单链表，由<code>mmap</code>指针指向这个链表，当虚拟区间多时采用“红黑树(red_black tree)”结构，由<code>mm_rb</code>指向这颗树。把最近用到的虚拟区间结构应当放入高速缓存，这个虚拟区间就由<code>mmap_cache</code>指向。</p>
<p>指针<code>pgd</code>指向该进程的页目录(每个进程都有自己的页目录，注意同内核页目录的区别)，当调度程序调度一个程序运行时，就将这个地址转成物理地址，并写入控制寄存器(CR3)。由于进程的虚拟空间及其下属的虚拟区间有可能在不同的上下文中受到访问，而这些访问又必须互斥，所以在该结构中设置了信号量<code>mmap_sem</code>。</p>
<p>此外，<code>page_table_lock</code>也是为类似的目的而设置的。虽然每个进程只有一个虚拟地址空间，但这个地址空间可以被别的进程来共享，如，子进程共享父进程的地址空间(也即共享<code>mm_struct</code>结构)。所以，用<code>mm_user</code>和<code>mm_count</code>进行计数。类型<code>atomic_t</code>实际上就是整数，但对这种整数的操作必须是“原子”的。</p>
<p>另外，还描述了代码段、数据段、堆栈段、参数段以及环境段的起始地址和结束地址。</p>
<p>这里的段是对程序的逻辑划分，与我们前面所描述的段机制是不同的。</p>
<h4 id="VM-AREA-STRUCT结构"><a href="#VM-AREA-STRUCT结构" class="headerlink" title="VM_AREA_STRUCT结构"></a>VM_AREA_STRUCT结构</h4><p><code>vm_area_struct</code>描述进程的一个虚拟地址区间，在<code>/include/linux/mm.h</code>中描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span></span></span><br><span class="line"><span class="class">    <span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">vm_mm</span>;</span> <span class="comment">/* 虚拟区间所在的地址空间*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_start; <span class="comment">/* 在vm_mm中的起始地址*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end; <span class="comment">/*在vm_mm中的结束地址 */</span></span><br><span class="line">    <span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>;</span></span><br><span class="line">    <span class="type">pgprot_t</span> vm_page_prot; <span class="comment">/* 对这个虚拟区间的存取权限 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_flags; <span class="comment">/* 虚拟区间的标志 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">rb_node_t</span> vm_rb;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">    * one of the address_space-&gt;i_mmap&#123;,shared&#125; lists,</span></span><br><span class="line"><span class="comment">    * for shm areas, the list of attaches, otherwise unused.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next_share</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> **<span class="title">vm_pprev_share</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*对这个区间进行操作的函数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> * <span class="title">vm_ops</span>;</span></span><br><span class="line">    <span class="comment">/* Information about our backing store: */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff; <span class="comment">/* Offset (within vm_file) in PAGE_SIZE units, *not* PAGE_CACHE_SIZE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span> <span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_raend; <span class="comment">/* <span class="doctag">XXX:</span> put full readahead info here. */</span></span><br><span class="line">    <span class="type">void</span> * vm_private_data; <span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>vm_flag</code>是描述对虚拟区间的操作的标志，其定义和描述如表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>VM_DENYWRITE</code>在这个区间映射一个打开后不能用来写的文件</td>
</tr>
<tr>
<td><code>VM_EXEC</code>页可以被执行</td>
</tr>
<tr>
<td><code>VM_EXECUTABLE</code>页含有可执行代码</td>
</tr>
<tr>
<td><code>VM_GROWSDOWN</code>这个区间可以向低地址扩展</td>
</tr>
<tr>
<td><code>VM_GROWSUP</code>这个区间可以向高地址扩展</td>
</tr>
<tr>
<td><code>VM_IO</code>这个区间映射一个设备的I/O地址空间</td>
</tr>
<tr>
<td><code>VM_LOCKED</code>页被锁住不能被交换出去</td>
</tr>
<tr>
<td><code>VM_MAYEXEC VM_EXEC</code>标志可以被设置</td>
</tr>
<tr>
<td><code>VM_MAYREAD VM_READ</code>标志可以被设置</td>
</tr>
<tr>
<td><code>VM_MAYSHARE VM_SHARE</code>标志可以被设置</td>
</tr>
<tr>
<td><code>VM_MAYWRITE VM_WRITE</code>标志可以被设置</td>
</tr>
<tr>
<td><code>VM_READ</code>页是可读的</td>
</tr>
<tr>
<td><code>VM_SHARED</code>页可以被多个进程共享</td>
</tr>
<tr>
<td><code>VM_SHM</code>页用于<code>IPC</code>共享内存</td>
</tr>
<tr>
<td><code>VM_WRITE</code>页是可写的</td>
</tr>
</tbody>
</table>
</div>
<p>较高层次的结构<code>vm_area_struct</code>是由双向链表连接起来的，它们是按虚地址的降顺序来排列的，每个这样的结构都对应描述一个相邻的地址空间范围。之所以这样分割，是因为每个虚拟区间可能来源不同，有的可能来自可执行映像，有的可能来自共享库，而有的则可能是动态分配的内存区，所以对每一个由<code>vm_area_struct</code>结构所描述的区间的处理操作和它前后范围的处理操作不同。因此Linux把虚拟内存分割管理，并利用了虚拟内存处理例程(vm_ops)来抽象对不同来源虚拟内存的处理方法。不同的虚拟区间其处理操作可能不同，Linux在这里利用了面向对象的思想，即把一个虚拟区间看成一个对象，用<code>vm_area_struct</code>描述了这个对象的属性，其中的<code>vm_operation s-stract</code>结构描述了在这个对象上的操作，其定义在<code>/include/linux/mm.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These are the virtual MM functions - opening of an area, closing and</span></span><br><span class="line"><span class="comment"> * unmapping it (needed to keep files on disk up-to-date etc), pointer</span></span><br><span class="line"><span class="comment"> * to the functions called when a no-page or a wp-page exception occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*open)(<span class="keyword">struct</span> vm_area_struct * area);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> vm_area_struct * area);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> * (*<span class="title">nopage</span>)(<span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">area</span>, <span class="title">unsigned</span> <span class="title">long</span> <span class="title">address</span>, <span class="title">int</span> <span class="title">unused</span>);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>vm_operations</code>结构中包含的是函数指针；其中，<code>open</code>、<code>close</code>分别用于虚拟区间的打开、关闭，而<code>nopage</code>用于当虚存页面不在物理内存而引起的“缺页异常”时所应该调用的函数。图 6.15 给出了虚拟区间的操作集。<br><img src="/img/1633775726.jpg" alt=""></p>
<h4 id="红黑树结构"><a href="#红黑树结构" class="headerlink" title="红黑树结构"></a>红黑树结构</h4><p>一颗红黑树是具有以下特点的二叉树：</p>
<ul>
<li>每个节点着有颜色，或者为红，或者为黑；</li>
<li>根节点为黑色；</li>
<li>如果一个节点为红色，那么它的子节点必须为黑色； </li>
<li>从一个节点到叶子节点上的所有路径都包含有相同的黑色节点数；</li>
</ul>
<p>红黑树的结构在<code>include/linux/rbtree.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_node_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node_s</span> * <span class="title">rb_parent</span>;</span></span><br><span class="line">    <span class="type">int</span> rb_color;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RB_RED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RB_BLACK 1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node_s</span> * <span class="title">rb_right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node_s</span> * <span class="title">rb_left</span>;</span></span><br><span class="line">&#125; <span class="type">rb_node_t</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="进程的虚拟空间"><a href="#进程的虚拟空间" class="headerlink" title="进程的虚拟空间"></a>进程的虚拟空间</h3><p>用户进程经过编译、链接后形成的映象文件有一个代码段和数据段(包括<code>data</code>段和<code>bss</code>段)，其中代码段在下，数据段在上。数据段中包括了所有静态分配的数据空间，即全局变量和所有申明为<code>static</code>的局部变量，这些空间是进程所必需的基本要求，这些空间是在建立一个进程的运行映像时就分配好的。除此之外，堆栈使用的空间也属于基本要求，所以也是在建立进程时就分配好的，如图 6.17 所示。<br><img src="/img/1633775814.jpg" alt=""></p>
<p>由图 6.17 可以看出，堆栈空间安排在虚存空间的顶部，运行时由顶向下延伸；代码段和数据段则在低部，运行时并不向上延伸。从数据段的顶部到堆栈段地址的下沿这个区间是一个巨大的空洞，这就是进程在运行时可以动态分配的空间(也叫动态内存)。</p>
<p>进程在运行过程中，可能会通过系统调用<code>mmap</code>动态申请虚拟内存或释放已分配的内存，新分配的虚拟内存必须和进程已有的虚拟地址链接起来才能使用；Linux进程可以使用共享的程序库代码或数据，这样，共享库的代码和数据也需要链接到进程已有的虚拟地址中。在后面我们还会看到，系统利用了请页机制来避免对物理内存的过分使用。因为进程可能会访问当前不在物理内存中的虚拟内存，这时，操作系统通过请页机制把数据从磁盘装入到物理内存。为此，系统需要修改进程的页表，以便标志虚拟页已经装入到物理内存中，同时，Linux还需要知道进程虚拟空间中任何一个虚拟地址区间的来源和当前所在位置，以便能够装入物理内存。</p>
<p>由于上面这些原因，Linux采用了比较复杂的数据结构跟踪进程的虚拟地址。在进程的<code>task_struct</code>结构中包含一个指向<code>mm_struct</code>结构的指针。进程的<code>mm_struct</code>则包含装入的可执行映像信息以及进程的页目录指针<code>pgd</code>。该结构还包含有指向<code>vm_area_struct</code>结构的几个指针，每个<code>vm_area_struct</code>代表进程的一个虚拟地址区间。</p>
<p>图 6.18 是某个进程的虚拟内存简化布局以及相应的几个数据结构之间的关系。从图中以看出，系统以虚拟内存地址的降序排列<code>vm_area_struct</code>。除链表结构外，Linux还利用红黑(Red_black)树来组织<code>vm_area_struct</code>。通过这种树结构，Linux可以快速定位某个虚拟内存地址。<br><img src="/img/1633775997.jpg" alt=""></p>
<p>当进程利用系统调用动态分配内存时，Linux首先分配一个<code>vm_area_struct</code>结构，并链接到进程的虚拟内存链表中，当后续的指令访问这一内存区间时，因为Linux尚未分配相应的物理内存，因此处理器在进行虚拟地址到物理地址的映射时会产生缺页异常，当Linux处理这一缺页异常时，就可以为新的虚拟内存区分配实际的物理内存。</p>
<p>在内核中，经常会用到这样的操作：给定一个属于某个进程的虚拟地址，要求找到其所属的区间以及<code>vma_area_struct</code>结构，这是由<code>find_vma()</code>来实现的，其实现代码在<code>mm/mmap.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Look up the first VMA which satisfies addr &lt; vm_end, NULL if none. */</span></span><br><span class="line"><span class="keyword">struct</span> vm_area_struct * <span class="title function_">find_vma</span><span class="params">(<span class="keyword">struct</span> mm_struct * mm, <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        <span class="comment">/* Check the cache first. */</span></span><br><span class="line">        <span class="comment">/* (Cache hit rate is typically around 35%.) */</span></span><br><span class="line">        vma = mm-&gt;mmap_cache;</span><br><span class="line">        <span class="keyword">if</span> (!(vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)) &#123;</span><br><span class="line">            <span class="type">rb_node_t</span> * rb_node;</span><br><span class="line">            rb_node = mm-&gt;mm_rb.rb_node;</span><br><span class="line">            vma = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">while</span> (rb_node) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vma_tmp</span>;</span></span><br><span class="line">                vma_tmp = rb_entry(rb_node, <span class="keyword">struct</span> vm_area_struct, vm_rb);</span><br><span class="line">                <span class="keyword">if</span> (vma_tmp-&gt;vm_end &gt; addr) &#123;</span><br><span class="line">                    vma = vma_tmp;</span><br><span class="line">                    <span class="keyword">if</span> (vma_tmp-&gt;vm_start &lt;= addr)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    rb_node = rb_node-&gt;rb_left;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    rb_node = rb_node-&gt;rb_right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (vma)</span><br><span class="line">            mm-&gt;mmap_cache = vma;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数比较简单，我们对其主要点给予解释。</p>
<ul>
<li>参数的含义：函数有两个参数，一个是指向<code>mm_struct</code>结构的指针，这表示一个进程的虚拟地址空间；一个是地址，表示该进程虚拟地址空间中的一个地址。</li>
<li>条件检查：首先检查这个地址是否恰好落在上一次(最近一次)所访问的区间中。如果没有命中，那就要在红黑树中进行搜索，红黑树与<code>AVL</code>树类似。</li>
<li>查找节点：如果已经建立了红黑树结构(<code>rb_rode</code>不为空)，就在红黑树中搜索。<ul>
<li>如果找到指定地址所在的区间 ， 就把<code>mmap_cache</code>指针设置成指向所找到的<code>vm_area_struct</code>结构。</li>
<li>如果没有找到，说明该地址所在的区间还没有建立，此时，就得建立一个新的虚拟区间，</li>
</ul>
</li>
<li>再调用<code>insert_vm_struct()</code>函数将新建立的区间插入到<code>vm_struct</code>中的线性队列或红黑树中。</li>
</ul>
<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>当某个程序的映像开始执行时，可执行映像必须装入到进程的虚拟地址空间。如果该进程用到了任何一个共享库，则共享库也必须装入到进程的虚拟地址空间。由此可看出，Linux并不将映像装入到物理内存，相反，可执行文件只是被连接到进程的虚拟地址空间中。随着程序的运行，被引用的程序部分会由操作系统装入到物理内存，这种将映像链接到进程地址空间的方法被称为“内存映射”。</p>
<p>当可执行映像映射到进程的虚拟地址空间时，将产生一组<code>vm_area_struct</code>结构来描述虚拟内存区间的起始点和终止点，每个<code>vm_area_struct</code>结构代表可执行映像的一部分，可能是可执行代码，也可能是初始化的变量或未初始化的数据，这些都是在函数<code>do_mmap()</code>中来实现的。随着<code>vm_area_struct</code>结构的生成，这些结构所描述的虚拟内存区间上的标准操作函数也由Linux初始化。但要明确在这一步还没有建立从虚拟内存到物理内存的影射，也就是说还没有建立页表页目录。</p>
<p>为了对上面的原理进行具体的说明，我们来看一下<code>do_mmap()</code>的实现机制。函数<code>do_mmap()</code>为当前进程创建并初始化一个新的虚拟区，如果分配成功，就把这个新的虚拟区与进程已有的其他虚拟区进行合并，<code>do_mmap()</code>在<code>include/linux/mm.h</code>中定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">do_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">long</span> addr, </span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">unsigned</span> <span class="type">long</span> prot,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">long</span> flag, <span class="type">unsigned</span> <span class="type">long</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ret = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> ((offset + PAGE_ALIGN(len)) &lt; offset)</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (!(offset &amp; ~PAGE_MASK))</span><br><span class="line">    ret = do_mmap_pgoff(file, addr, len, prot, flag, offset &gt;&gt; PAGE_SHIFT);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数中参数的含义如下。</p>
<ul>
<li><code>file</code>：表示要映射的文件，file`结构将在第八章文件系统中进行介绍。</li>
<li><code>offset</code>：文件内的偏移量，因为我们并不是一下子全部映射一个文件，可能只是映射文件的一部分，off`就表示那部分的起始位置。</li>
<li><code>len</code>：要映射的文件部分的长度。</li>
<li><code>addr</code>：虚拟空间中的一个地址，表示从这个地址开始查找一个空闲的虚拟区。</li>
<li><code>prot</code>: 这个参数指定对这个虚拟区所包含页的存取权限。可能的标志有<code>PROT_READ</code>、<code>PROT_WRITE</code>、<code>PROT_EXEC</code>和<code>PROT_NONE</code>。前 3 个标志与标志<code>VM_READ</code>、<code>VM_WRITE</code>及<code>VM_EXEC</code>的意义一样。<code>PROT_NONE</code>表示进程没有以上 3 个存取权限中的任意一个。</li>
<li><code>flag</code>：这个参数指定虚拟区的其他标志：<ul>
<li><code>MAP_GROWSDOWN</code>，<code>MAP_LOCKED</code>，<code>MAP_DENYWRITE</code>和<code>MAP_EXECUTABLE</code>：<ul>
<li>它们的含义与表 6.1 中所列出标志的含义相同。</li>
</ul>
</li>
<li><code>MAP_SHARED</code>和<code>MAP_PRIVATE</code>：<ul>
<li>前一个标志指定虚拟区中的页可以被许多进程共享；后一个标志作用相反。这两个标志都涉及<code>vm_area_struct</code>中的<code>VM_SHARED</code>标志。</li>
</ul>
</li>
<li><code>MAP_ANONYMOUS</code><ul>
<li>表示这个虚拟区是匿名的，与任何文件无关。</li>
</ul>
</li>
<li><code>MAP_FIXED</code><ul>
<li>这个区间的起始地址必须是由参数<code>addr</code>所指定的。</li>
</ul>
</li>
<li><code>MAP_NORESERVE</code><ul>
<li>函数不必预先检查空闲页面的数目。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>do_mmap()</code>函数对参数<code>offset</code>的合法性检查后，就调用<code>do_mmap_pgoff()</code>函数，该函数才是内存映射的主要函数，<code>do_mmap_pgoff()</code>的代码在<code>mm/mmap.c</code>中，代码比较长，我们分段来介绍：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">do_mmap_pgoff</span><span class="params">(<span class="keyword">struct</span> file * file, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params"> <span class="type">unsigned</span> <span class="type">long</span> prot, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">unsigned</span> <span class="type">long</span> pgoff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> * <span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">vma</span>, * <span class="title">prev</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> vm_flags;</span><br><span class="line">    <span class="type">int</span> correct_wcount = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="type">rb_node_t</span> ** rb_link, * rb_parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file &amp;&amp; (!file-&gt;f_op || !file-&gt;f_op-&gt;mmap))</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((len = PAGE_ALIGN(len)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; TASK_SIZE)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/* offset overflow? */</span></span><br><span class="line">    <span class="keyword">if</span> ((pgoff + (len &gt;&gt; PAGE_SHIFT)) &lt; pgoff)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">/* Too many mappings? */</span></span><br><span class="line">    <span class="keyword">if</span> (mm-&gt;map_count &gt; MAX_MAP_COUNT)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br></pre></td></tr></table></figure></p>
<p>函数首先检查参数的值是否正确，所提的请求是否能够被满足，如果发生以上情况中的任何一种，<code>do_mmap()</code>函数都终止并返回一个负值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Obtain the address to map to. we verify (or select) it and ensure</span></span><br><span class="line"><span class="comment">* that it represents a valid section of the address space.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">addr = get_unmapped_area(file, addr, len, pgoff, flags);</span><br><span class="line"><span class="keyword">if</span> (addr &amp; ~PAGE_MASK)</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>get_unmapped_area()</code>函数在当前进程的用户空间中获得一个未映射区间的起始地址。<code>PAGE_MASK</code>的值为 0xFFFFF000，因此，如果<code>addr &amp; ~PAGE_MASK</code>为非 0，说明<code>addr</code>最低 12 位非 0，<code>addr</code>就不是一个有效的地址，就以这个地址作为返回值；否则，<code>addr</code>就是一个有效的地址(最低 12 位为 0)，继续向下看：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Do simple checking here so the lower-level routines won&#x27;t have</span></span><br><span class="line"><span class="comment">* to. we assume access permissions have been handled by the open</span></span><br><span class="line"><span class="comment">* of the memory object, so we don&#x27;t do any here.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vm_flags = calc_vm_flags(prot,flags) | mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* mlock MCL_FUTURE? */</span></span><br><span class="line"><span class="keyword">if</span> (vm_flags &amp; VM_LOCKED) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> locked = mm-&gt;locked_vm &lt;&lt; PAGE_SHIFT;</span><br><span class="line">    locked += len;</span><br><span class="line">    <span class="keyword">if</span> (locked &gt; current-&gt;rlim[RLIMIT_MEMLOCK].rlim_cur)</span><br><span class="line">        <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>flag</code>参数指定的新虚拟区中的页必须锁在内存，且进程加锁页的总数超过了保存在进程的<code>task_struct</code>结构<code>rlim[RLIMIT_MEMLOCK].rlim_cur</code>域中的上限值，则返回一个负值。继续：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123;</span><br><span class="line">        <span class="keyword">case</span> MAP_SHARED:</span><br><span class="line">            <span class="keyword">if</span> ((prot &amp; PROT_WRITE) &amp;&amp; !(file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line">                <span class="keyword">return</span> -EACCES;</span><br><span class="line">            <span class="comment">/* Make sure we don&#x27;t allow writing to an append-only file.. */</span></span><br><span class="line">            <span class="keyword">if</span> (IS_APPEND(file-&gt;f_dentry-&gt;d_inode) &amp;&amp; (file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line">                <span class="keyword">return</span> -EACCES;</span><br><span class="line">            <span class="comment">/* make sure there are no mandatory locks on the file. */</span></span><br><span class="line">            <span class="keyword">if</span> (locks_verify_locked(file-&gt;f_dentry-&gt;d_inode))</span><br><span class="line">                <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">            vm_flags |= VM_SHARED | VM_MAYSHARE;</span><br><span class="line">            <span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line">                vm_flags &amp;= ~(VM_MAYWRITE | VM_SHARED);</span><br><span class="line">            <span class="comment">/* fall through */</span></span><br><span class="line">        <span class="keyword">case</span> MAP_PRIVATE:</span><br><span class="line">            <span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_READ))</span><br><span class="line">                <span class="keyword">return</span> -EACCES;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm_flags |= VM_SHARED | VM_MAYSHARE;</span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; MAP_TYPE) &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        <span class="keyword">case</span> MAP_PRIVATE:</span><br><span class="line">            vm_flags &amp;= ~(VM_SHARED | VM_MAYSHARE);</span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line">        <span class="keyword">case</span> MAP_SHARED:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果<code>file</code>结构指针为 0，则目的仅在于创建虚拟区间，或者说，并没有真正的映射发生；</li>
<li>如果<code>file</code>结构指针不为 0，则目的在于建立从文件到虚拟区间的映射，那就要根据标志指定的映射种类，把为文件设置的访问权考虑进去。</li>
<li>如果所请求的内存映射是共享可写的，就要检查要映射的文件是为写入而打开的，而不是以追加模式打开的，还要检查文件上没有上强制锁。</li>
<li>对于任何种类的内存映射，都要检查文件是否为读操作而打开的。</li>
<li>如果以上条件都不满足，就返回一个错误码。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Clear old maps */</span></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">munmap_back:</span><br><span class="line">    vma = find_vma_prepare(mm, addr, &amp;prev, &amp;rb_link, &amp;rb_parent);</span><br><span class="line">    <span class="keyword">if</span> (vma &amp;&amp; vma-&gt;vm_start &lt; addr + len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (do_munmap(mm, addr, len))</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> munmap_back;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>find_vma_prepare()</code>与<code>find_vma()</code>基本相同，它扫描当前进程地址空间的<code>vm_area_struct</code>结构所形成的红黑树，试图找到结束地址高于<code>addr</code>的第 1 个区间；如果找到了一个虚拟区，说明<code>addr</code>所在的虚拟区已经在使用，也就是已经有映射存在，因此要调用<code>do_munmap()</code>把这个老的虚拟区从进程地址空间中撤销，如果撤销不成功，就返回一个负数；如果撤销成功，就继续查找，直到在红黑树中找不到<code>addr</code>所在的虚拟区，并继续下面的检查：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check against address space limit. */</span></span><br><span class="line"><span class="keyword">if</span> ((mm-&gt;total_vm &lt;&lt; PAGE_SHIFT) + len &gt; current-&gt;rlim[RLIMIT_AS].rlim_cur)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br></pre></td></tr></table></figure></p>
<p><code>total_vm</code>是表示进程地址空间的页面数，如果把文件映射到进程地址空间后，其长度超过了保存在当前进程<code>rlim[RLIMIT_AS].rlim_cur</code>中的上限值，则返回一个负数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private writable mapping? Check memory availability.. */</span></span><br><span class="line"><span class="keyword">if</span> ((vm_flags &amp; (VM_SHARED | VM_WRITE)) == VM_WRITE &amp;&amp; !(flags &amp; MAP_NORESERVE) &amp;&amp;!vm_enough_memory(len &gt;&gt; PAGE_SHIFT))</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br></pre></td></tr></table></figure>
<p>如果<code>flags</code>参数中没有设置<code>MAP_NORESERVE</code>标志，新的虚拟区含有私有的可写页，空闲页面数小于要映射的虚拟区的大小；则函数终止并返回一个负数；其中函数<code>vm_enough_memory()</code>用来检查一个进程的地址空间中是否有足够的内存来进行一个新的映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Can we just expand an old anonymous mapping? */</span></span><br><span class="line"><span class="keyword">if</span> (!file &amp;&amp; !(vm_flags &amp; VM_SHARED) &amp;&amp; rb_parent)</span><br><span class="line">    <span class="keyword">if</span> (vma_merge(mm, prev, rb_parent, addr, addr + len, vm_flags))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>
<p>如果是匿名映射(<code>file</code>为空)，并且这个虚拟区是非共享的，则可以把这个虚拟区和与它紧挨的前一个虚拟区进行合并；虚拟区的合并是由<code>vma_merge()</code>函数实现的。如果合并成功，则转<code>out</code>处，请看后面<code>out</code>处的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Determine the object being mapped and call the appropriate</span></span><br><span class="line"><span class="comment">* specific mapper. the address has already been validated, but</span></span><br><span class="line"><span class="comment">* not unmapped, but the maps are removed from the list.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vma = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!vma)</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">vma-&gt;vm_mm = mm;</span><br><span class="line">vma-&gt;vm_start = addr;</span><br><span class="line">vma-&gt;vm_end = addr + len;</span><br><span class="line">vma-&gt;vm_flags = vm_flags;</span><br><span class="line">vma-&gt;vm_page_prot = protection_map[vm_flags &amp; <span class="number">0x0f</span>];</span><br><span class="line">vma-&gt;vm_ops = <span class="literal">NULL</span>;</span><br><span class="line">vma-&gt;vm_pgoff = pgoff;</span><br><span class="line">vma-&gt;vm_file = <span class="literal">NULL</span>;</span><br><span class="line">vma-&gt;vm_private_data = <span class="literal">NULL</span>;</span><br><span class="line">vma-&gt;vm_raend = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>经过以上各种检查后，现在必须为新的虚拟区分配一个<code>vm_area_struct</code>结构。这是通过调用<code>Slab</code>分配函数<code>kmem_cache_alloc()</code>来实现的，然后就对这个结构的各个域进行了初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        error = -EINVAL;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; (VM_GROWSDOWN|VM_GROWSUP))</span><br><span class="line">            <span class="keyword">goto</span> free_vma;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_DENYWRITE) &#123;</span><br><span class="line">            error = deny_write_access(file);</span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> free_vma;</span><br><span class="line">            correct_wcount = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vma-&gt;vm_file = file;</span><br><span class="line">        get_file(file);</span><br><span class="line">        error = file-&gt;f_op-&gt;mmap(file, vma);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> unmap_and_free_vma;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MAP_SHARED) &#123;</span><br><span class="line">        error = shmem_zero_setup(vma);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> free_vma;</span><br><span class="line">    &#125;</span><br><span class="line">free_vma:</span><br><span class="line">    kmem_cache_free(vm_area_cachep, vma);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果建立的是从文件到虚存区间的映射，则情况下。</p>
<ul>
<li>当参数<code>flags</code>中的<code>VM_GROWSDOWN</code>或<code>VM_GROWSUP</code>标志位为 1 时，说明这个区间可以向低地址或高地址扩展，但从文件映射的区间不能进行扩展，因此转到<code>free_vma</code>，释放给<code>vm_area_struct</code>分配的<code>Slab</code>，并返回一个错误。</li>
<li>当<code>flags</code>中的<code>VM_DENYWRITE</code>标志位为 1 时，就表示不允许通过常规的文件操作访问该文件，所以要调用<code>deny_write_access()</code>排斥常规的文件操作。</li>
</ul>
<p><code>get_file()</code>函数的主要作用是递增<code>file</code>结构中的共享计数。</p>
<p>每个文件系统都有个<code>fiel_operation</code>数据结构，其中的函数指针<code>mmap</code>提供了用来建立从该类文件到虚存区间进行映射的操作，这是最具有实质意义的函数；对于大部分文件系统，这个函数为<code>generic_file_mmap()</code>函数实现的，该函数执行以下操作。</p>
<ul>
<li>初始化<code>vm_area_struct</code>结构中的<code>vm_ops</code>域。如果<code>VM_SHARED</code>标志为 1，就把该域设置成<code>file_shared_mmap</code>，否则就把该域设置成<code>file_private_mmap</code>。从某种意义上说，这个步骤所做的事情类似于打开一个文件并初始化文件对象的方法。</li>
<li>从索引节点的<code>i_mode</code>域检查要映射的文件是否是一个常规文件。如果是其他类型的文件(例如目录或套接字)，就返回一个错误代码。</li>
<li>从索引节点的<code>i_op</code>域中检查是否定义了<code>readpage()</code>的索引节点操作。如果没有定义，就返回一个错误代码。</li>
<li>调用<code>update_atime()</code>函数把当前时间存放在该文件索引节点的<code>i_atime</code>域中，并将这个索引节点标记成脏。</li>
<li>如果<code>flags</code>参数中的<code>MAP_SHARED</code>标志位为 1，则调用<code>shmem_zero_setup()</code>进行共享内存的映射。</li>
</ul>
<p>继续看<code>do_mmap()</code>中的代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Can addr have changed??</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Answer: Yes, several device drivers can do it in their</span></span><br><span class="line"><span class="comment">* f_op-&gt;mmap method. -DaveM</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">addr = vma-&gt;vm_start;</span><br></pre></td></tr></table></figure></p>
<p>源码作者给出了解释，意思是说，<code>addr</code>有可能已被驱动程序改变，因此，把新虚拟区的起始地址赋给<code>addr</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line"><span class="keyword">if</span> (correct_wcount)</span><br><span class="line"><span class="type">atomic_inc</span>(&amp;file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount);</span><br></pre></td></tr></table></figure></p>
<p>此时，应该把新建的虚拟区插入到进程的地址空间，这是由函数<code>vma_link()</code>完成的，该函数具有 3 方面的功能：</p>
<ol>
<li>把<code>vma</code>插入到虚拟区链表中；</li>
<li>把<code>vma</code>插入到虚拟区形成的红黑树中；</li>
<li>把<code>vam</code>插入到索引节点(inode)共享链表中。</li>
</ol>
<p>函数<code>atomic_inc(x)</code>给<code>*x</code>加 1，这是一个原子操作。在内核代码中，有很多地方调用了以<code>atomic</code>为前缀的函数。所谓原子操作，就是在操作过程中不会被中断。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">out:</span><br><span class="line">    mm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT;</span><br><span class="line">    <span class="keyword">if</span> (vm_flags &amp; VM_LOCKED) &#123;</span><br><span class="line">        mm-&gt;locked_vm += len &gt;&gt; PAGE_SHIFT;</span><br><span class="line">        make_pages_present(addr, addr + len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br></pre></td></tr></table></figure></p>
<p><code>do_mmap()</code>函数准备从这里退出，首先增加进程地址空间的长度，然后看一下对这个区间是否加锁，如果加锁，说明准备访问这个区间，就要调用<code>make_pages_present()</code>函数，建立虚拟页面到物理页面的映射，也就是完成文件到物理内存的真正调入。返回一个正数，说明这次映射成功。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unmap_and_free_vma:</span><br><span class="line">    <span class="keyword">if</span> (correct_wcount)</span><br><span class="line">        <span class="type">atomic_inc</span>(&amp;file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount);</span><br><span class="line">    vma-&gt;vm_file = <span class="literal">NULL</span>;</span><br><span class="line">    fput(file);</span><br><span class="line">    <span class="comment">/* Undo any partial mapping done by a device driver. */</span></span><br><span class="line">    zap_page_range(mm, vma-&gt;vm_start, vma-&gt;vm_end - vma-&gt;vm_start);</span><br></pre></td></tr></table></figure></p>
<p>如果对文件的操作不成功，则解除对该虚拟区间的页面映射，这是由<code>zap_page_range()</code>函数完成的。</p>
<p>这里要说明的是，文件到虚存的映射仅仅是建立了一种映射关系，也就是说，虚存页面到物理页面之间的映射还没有建立。当某个可执行映象映射到进程虚拟内存中并开始执行时，因为只有很少一部分虚拟内存区间装入到了物理内存，可能会遇到所访问的数据不在物理内存。这时，处理器将向Linux报告一个页故障及其对应的故障原因，于是就用到了请页机制。</p>
<h2 id="请页机制"><a href="#请页机制" class="headerlink" title="请页机制"></a>请页机制</h2><p>Linux采用请页机制来节约内存，它仅仅把当前正在执行的程序要使用的虚拟页(少量一部分)装入内存。当需要访问尚未装入物理内存的虚拟内存区域时，处理器将向Linux报告一个页故障及其对应的故障原因。本节将主要介绍<code>arch/i386/mm/fault.c</code>中的页故障处理函数<code>do_page_fault</code>，为了突出主题，我们将分析代码中的主要部分。</p>
<h3 id="页故障的产生"><a href="#页故障的产生" class="headerlink" title="页故障的产生"></a>页故障的产生</h3><p>页故障的产生有 3 种原因。</p>
<ol>
<li>一是程序出现错误，例如向随机物理内存中写入数据，或页错误发生在<code>TASK_SIZE</code>(3G)的范围外，这些情况下，虚拟地址无效，Linux将向进程发送<code>SIGSEGV</code>信号并终止进程的运行。</li>
<li>另一种情况是，虚拟地址有效，但其所对应的页当前不在物理内存中，即缺页错误，这时，操作系统必须从磁盘映像或交换文件(此页被换出)中将其装入物理内存。</li>
<li>最后一种情况是，要访问的虚地址被写保护，即保护错误，这时，操作系统必须判断：如果是用户进程正在写当前进程的地址空间，则发<code>SIGSEGV</code>信号并终止进程的运行；如果错误发生在一旧的共享页上时，则处理方法有所不同，也就是要对这一共享页进行复制，这就是我们后面要讲的写时复制(<code>Copy On Write</code>简称<code>COW</code>)技术。</li>
</ol>
<p>有关页错误的发生次数的信息可在目录<code>proc/stat</code>下找到。</p>
<h3 id="页错误的定位"><a href="#页错误的定位" class="headerlink" title="页错误的定位"></a>页错误的定位</h3><p>页错误的定位既包含虚拟地址的定位，也包含被调入页在交换文件(swapfile)或在可执行映象中的定位。</p>
<p>具体地说，在一个进程访问一个无效页表项时，处理器产生一个陷入并报告一个页错误，它描述了页错误发生的虚地址和访问类型，这些类型通过页的错误码<code>error_code</code>中的前 3位来判别 ，具体如下：</p>
<ul>
<li>bit 0 == 0 means no page found, 1 means protection fault</li>
<li>bit 1 == 0 means read, 1 means write</li>
<li>bit 2 == 0 means kernel, 1 means user-mode。</li>
</ul>
<p>也就是说，如果第 0 位为 0，则错误是由访问一个不存在的页引起的(页表的表项中·present`标志为 0)，否则，如果第 0 位为 1，则错误是由无效的访问权所引起的；如果第 1位为 0，则错误是由读访问或执行访问所引起，如果为 1，则错误是由写访问所引起的；如果第 2 位为 0，则错误发生在处理器处于内核态时，否则，错误发生在处理器处于用户态时。</p>
<p>页错误的线性地址被存于<code>CR2</code>寄存器，操作系统必须在<code>vm_area_struct</code>中找到页错误发生时页的虚拟地址，下面通过<code>do_page_fault()</code>中的一部分源代码来说明这个问题：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CR2 中包含有最新的页错误发生时的虚拟地址*/</span></span><br><span class="line">__asm__(<span class="string">&quot;movl %%cr2,%0&quot;</span>:<span class="string">&quot;=r&quot;</span> (address));</span><br><span class="line">vma = find_vma(current, address);</span><br></pre></td></tr></table></figure></p>
<p>如果没找到，则说明访问了非法虚地址，Linux会发信号终止进程(如果必要)。否则，检查页错误类型，如果是非法类型(越界错误，段权限错误等)同样会发信号终止进程，部分源代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    vma = find_vma(current, address);</span><br><span class="line">    <span class="keyword">if</span> (!vma)</span><br><span class="line">        <span class="keyword">goto</span> bad_area;</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_start &lt;= address)</span><br><span class="line">        <span class="keyword">goto</span> good_area;</span><br><span class="line">    <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_GROWSDOWN))</span><br><span class="line">        <span class="keyword">goto</span> bad_area;</span><br><span class="line">    <span class="keyword">if</span> (error_code &amp; <span class="number">4</span>) &#123; <span class="comment">/*如是用户态进程*/</span></span><br><span class="line">        <span class="comment">/* 不可访问堆栈空间*/</span></span><br><span class="line">        <span class="keyword">if</span> (address + <span class="number">32</span> &lt; regs-&gt;esp)</span><br><span class="line">            <span class="keyword">goto</span> bad_area;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (expand_stack(vma, address))</span><br><span class="line">        <span class="keyword">goto</span> bad_area;</span><br><span class="line">bad_area: <span class="comment">/* 用户态的访问*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (error_code &amp; <span class="number">4</span>) &#123;</span><br><span class="line">        current-&gt;tss.cr2 = address;</span><br><span class="line">        current-&gt;tss.error_code = error_code;</span><br><span class="line">        current-&gt;tss.trap_no = <span class="number">14</span>;</span><br><span class="line">        force_sig(SIGSEGV, current); <span class="comment">/* 给当前进程发杀死信号*/</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    die_if_kernel(<span class="string">&quot;Oops&quot;</span>, regs, error_code); <span class="comment">/*报告内核 */</span></span><br><span class="line">    do_exit(SIGKILL); <span class="comment">/*强行杀死进程*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="进程地址空间中的缺页异常处理"><a href="#进程地址空间中的缺页异常处理" class="headerlink" title="进程地址空间中的缺页异常处理"></a>进程地址空间中的缺页异常处理</h3><p>对有效的虚拟地址，如果是缺页错误，Linux必须区分页所在的位置，即判断页是在交换文件中，还是在可执行映像中。为此，Linux通过页表项中的信息区分页所在的位置。如果该页的页表项是无效的，但非空，则说明该页处于交换文件中，操作系统要从交换文件装入页。对于有效的虚拟地址<code>address</code>，<code>do_page_fault()</code>转到<code>good_area</code>标号处的语句执行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">good_area:</span><br><span class="line">    write = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (error_code &amp; <span class="number">2</span>) &#123; <span class="comment">/* 写访问 */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE))</span><br><span class="line">            <span class="keyword">goto</span> bad_area;</span><br><span class="line">        write++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="comment">/* 读访问 */</span></span><br><span class="line">        <span class="keyword">if</span> (error_code &amp; <span class="number">1</span> || !(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC)))</span><br><span class="line">            <span class="keyword">goto</span> bad_area;</span><br></pre></td></tr></table></figure></p>
<p>如果错误由写访问引起，函数检查这个虚拟区是否可写。如果不可写，跳到<code>bad_area</code>代码处；如果可写，把<code>write</code>局部变量置为 1。</p>
<p>如果错误由读或执行访问引起，函数检查这一页是否已经存在于物理内存中。如果在，错误的发生就是由于进程试图访问用户态下的一个有特权的页面(页面的<code>User/Supervisor</code>标志被清除)，因此函数跳到<code>bad_area</code>代码处(实际上这种情况从不发生，因为内核根本不会给用户进程分配有特权的页面)。如果不存在物理内存，函数还将检查这个虚拟区是否可读或可执行。</p>
<p>如果这个虚拟区的访问权限与引起错误的访问类型相匹配，则调用<code>handle_mm_fault()</code>函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!handle_mm_fault(tsk, vma, address, write)) &#123;</span><br><span class="line">    tsk-&gt;tss.cr2 = address;</span><br><span class="line">    tsk-&gt;tss.error_code = error_code;</span><br><span class="line">    tsk-&gt;tss.trap_no = <span class="number">14</span>;</span><br><span class="line">    force_sig(SIGBUS, tsk);</span><br><span class="line">    <span class="keyword">if</span> (!(error_code &amp; <span class="number">4</span>)) <span class="comment">/* 内核态 */</span></span><br><span class="line">        <span class="keyword">goto</span> no_context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>handle_mm_fault()</code>函数成功地给进程分配一个页面，则返回 1；否则返回一个适当的错误码，以便<code>do_page_fault()</code>函数可以给进程发送<code>SIGBUS</code>信号。</p>
<p><code>handle_mm_fault()</code>函数有 4 个参数：</p>
<ul>
<li><code>tsk</code>指向错误发生时正在CPU上运行的进程；</li>
<li><code>vma</code>指向引起错误的虚拟地址所在虚拟区；</li>
<li><code>address</code>为引起错误的虚拟地址；</li>
<li><code>write</code>：如果<code>tsk</code>试图向<code>address</code>写，则置为 1，如果<code>tsk</code>试图读或执行<code>address</code>，则置为 0。</li>
</ul>
<p><code>handle_mm_fault()</code>函数首先检查用来映射<code>address</code>的页中间目录和页表是否存在。即使<code>address</code>属于进程的地址空间，但相应的页表可能还没有分配，因此，在做别的事情之前首先执行分配页目录和页表的任务：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pgd = pgd_offset(vma-&gt;vm_mm, address);</span><br><span class="line">pmd = pmd_alloc(pgd, address);</span><br><span class="line"><span class="keyword">if</span> (!pmd)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">pte = pte_alloc(pmd, address);</span><br><span class="line"><span class="keyword">if</span> (!pte)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>pgd_offset()</code>宏计算出<code>address</code>所在页在页目录中的目录项指针。如果有中间目录(i386不起作用)，调用<code>pmd_alloc()</code>函数分配一个新的中间目录。然后，如果需要，调用<code>pte_alloc()</code>函数分配一个新的页表。如果这两步都成功，<code>pte</code>局部变量所指向的页表表项就是引用<code>address</code>的表项。然后调用<code>handle_pte_fault()</code>函数检查<code>address</code>地址所对应的页表表项:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> handle_pte_fault(tsk, vma, address, write_access, pte);</span><br></pre></td></tr></table></figure></p>
<p><code>handle_pte_fault()</code>函数决定怎样给进程分配一个新的页面。如果被访问的页不存在，也就是说，这个页还没有被存放在任何一个页面中，那么，内核分配一个新的页面并适当地初始化。这种技术称为请求调页。如果被访问的页存在但是被标为只读，也就是说，它已经被存放在一个页面中，那么，内核分配一个新的页面，并把旧页面的数据拷贝到新页面来初始化它的内容。这种技术称为写时复制。</p>
<h3 id="请求调页"><a href="#请求调页" class="headerlink" title="请求调页"></a>请求调页</h3><p>请求调页指的是一种动态内存分配技术，它把页面的分配推迟到不能再推迟为止，也就是说，一直推迟到进程要访问的页不在物理内存时为止，由此引起一个缺页错误。</p>
<p>对于全局分配(一开始就给进程分配所需要的全部页面，直到程序结束才释放这些页面)来说，请求调页是首选的，因为它增加了系统中的空闲页面的平均数，从而更好地利用空闲内存。从另一个观点来看，在内存总数保持不变的情况下，请求调页从总体上能使系统有更大的吞吐量。</p>
<p>为这一切优点付出的代价是系统额外的开销：由请求调页所引发的每个“缺页”错误必须由内核处理，这将浪费CPU的周期。幸运的是，局部性原理保证了一旦进程开始在一组页上运行，在接下来相当长的一段时间内它会一直停留在这些页上而不去访问其他的页：这样我们就可以认为“缺页”错误是一种稀有事件。</p>
<p>基于以下原因，被寻址的页可以不在主存中。</p>
<ol>
<li>进程永远也没有访问到这个页。内核能够识别这种情况，这是因为页表相应的表项被填充为 0，也就是说，<code>pte_none</code>宏返回 1。</li>
<li>进程已经访问过这个页，但是这个页的内容被临时保存在磁盘上。内核能够识别这种情况，这是因为页表相应表项没被填充为 0(然而，由于页面不存在物理内存中，<code>present</code>为 0)。</li>
</ol>
<p><code>handle_pte_fault()</code>函数通过检查与<code>address</code>相关的页表表项来区分这两种情况：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">entry = *pte;</span><br><span class="line"><span class="keyword">if</span> (!pte_present(entry)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pte_none(entry))</span><br><span class="line">        <span class="keyword">return</span> do_no_page(tsk, vma, address, write_access, pte);</span><br><span class="line">    <span class="keyword">return</span> do_swap_page(tsk, vma, address, pte, entry, write_access);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们将在交换机制一节检查页被保存到磁盘上的这种情况(<code>do_swap_page()</code>函数)。在其他情况下，当页从未被访问时则调用<code>do_no_page()</code>函数。有两种方法装入所缺的页，这取决于这个页是否被映射到磁盘文件。该函数通过检查<code>vma</code>虚拟区描述符的<code>nopage</code>域来确定这一点，如果页与文件建立起了映射关系，则<code>nopage</code>域就指向一个把所缺的页从磁盘装入到<code>RAM</code>的函数。因此，可能的情况如下所述。</p>
<ol>
<li><code>vma-&gt;vm_ops-&gt;nopage</code>域不为<code>NULL</code>。在这种情况下，某个虚拟区映射一个磁盘文件，<code>nopage</code>域指向从磁盘读入的函数。这种情况涉及到磁盘文件的低层操作。</li>
<li>或者<code>vm_ops</code>域为<code>NULL</code>，或者<code>vma-&gt;vm_ops-&gt;nopage</code>域为<code>NULL</code>。在这种情况下，虚拟区没有映射磁盘文件，也就是说，它是一个匿名映射。因此，<code>do_no_page()</code>调用<code>do_anonymous_page()</code>函数获得一个新的页面：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!vma-&gt;vm_ops || !vma-&gt;vm_ops-&gt;nopage)</span><br><span class="line">    <span class="keyword">return</span> do_anonymous_page(tsk, vma, page_table, write_access);</span><br></pre></td></tr></table></figure>
<p><code>do_anonymous_page()</code>函数分别处理写请求和读请求：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (write_access) &#123;</span><br><span class="line">        page = __get_free_page(GFP_USER);</span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">void</span> *)(page), <span class="number">0</span>, PAGE_SIZE)</span><br><span class="line">        entry = pte_mkwrite(pte_mkdirty(mk_pte(page, vma-&gt;vm_page_prot)));</span><br><span class="line">        vma-&gt;vm_mm-&gt;rss++;</span><br><span class="line">        tsk-&gt;min_flt++;</span><br><span class="line">        set_pte(pte, entry);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当处理写访问时，该函数调用<code>__get_free_page()</code>分配一个新的页面，并利用<code>memset</code>宏把新页面填为 0。然后该函数增加<code>tsk</code>的<code>min_flt</code>域以跟踪由进程引起的次级缺页(这些缺页只需要一个新页面)的数目，再增加进程的内存区结构<code>vma-&gt;vm_mm</code>的<code>rss</code>域以跟踪分配给进程的页面数目。然后页表相应的表项被设为页面的物理地址，并把这个页面标记为可写和脏两个标志。</p>
<p>相反，当处理读访问时，页的内容是无关紧要的，因为进程正在对它进行第一次寻址。给进程一个填充为 0 的页要比给它一个由其他进程填充了信息的旧页更为安全。Linux在请求调页方面做得更深入一些。没有必要立即给进程分配一个填充为零的新页面，由于我们也可以给它一个现有的称为零页的页，这样可以进一步推迟页面的分配。零页在内核初始化期间被静态分配，并存放在<code>empty_zero_page</code>变量中(一个有 1024 个长整数的数组，并用 0填充)；它存放在第六个页面中(从物理地址 0x00005000 开始)，并且可以通过<code>ZERO_PAGE</code>宏来引用。因此页表表项被设为零页的物理地址：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entry = pte_wrprotect(mk_pte(ZERO_PAGE, vma-&gt;vm_page_prot));</span><br><span class="line">set_pte(pte, entry);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>由于这个页被标记为不可写，如果进程试图写这个页，则写时复制机制被激活。当且仅当在这个时候，进程才获得一个属于自己的页并对它进行写。这种机制在下一部分进行描述。</p>
<h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><p>写时复制技术最初产生于<code>UNIX</code>系统，用于实现一种傻瓜式的进程创建：当发出<code>fork()</code>系统调用时，内核原样复制父进程的整个地址空间并把复制的那一份分配给子进程。这种行为是非常耗时的，因为它需要：</p>
<ul>
<li>为子进程的页表分配页面；</li>
<li>为子进程的页分配页面；</li>
<li>初始化子进程的页表；</li>
<li>把父进程的页复制到子进程相应的页中。</li>
</ul>
<p>写时复制：父进程和子进程共享页面而不是复制页面。然而，只要页面被共享，它们就不能被修改。无论父进程和子进程何时试图写一个共享的页面，就产生一个错误，这时内核就把这个页复制到一个新的页面中并标记为可写。原来的页面仍然是写保护的：当其他进程试图写入时，内核检查写进程是否是这个页面的唯一属主；如果是，它把这个页面标记为对这个进程是可写的。</p>
<p><code>Page</code>结构的<code>count</code>域用于跟踪共享相应页面的进程数目。只要进程释放一个页面或者在它上面执行写时复制，它的<code>count</code>域就递减；只有当<code>count</code>变为<code>NULL</code>时，这个页面才被释放。</p>
<p>现在我们讲述Linux怎样实现写时复制(COW)。当<code>handle_pte_fault()</code>确定“缺页”错误是由请求写一个页面所引起的时(这个页面存在于内存中且是写保护的)：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pte_present(pte)) &#123;</span><br><span class="line">    entry = pte_mkyoung(entry);</span><br><span class="line">    set_pte(pte, entry);</span><br><span class="line">    flush_tlb_page(vma, address);</span><br><span class="line">    <span class="keyword">if</span> (write_access) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pte_write(entry))</span><br><span class="line">            <span class="keyword">return</span> do_wp_page(tsk, vma, address, pte);</span><br><span class="line">        entry = pte_mkdirty(entry);</span><br><span class="line">        set_pte(pte, entry); </span><br><span class="line">        flush_tlb_page(vma, address);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，调用<code>pte_mkyoung()</code>和<code>set_pte()</code>函数来设置引起错误的页所对应页表项的访问位。这个设置使页“年轻”并减少它被交换到磁盘上的机会。如果错误由违背写保护而引起的，<code>handle_pte_fault()</code>返回由<code>do_wp_page()</code>函数产生的值；否则，则已检测到某一错误情况(例如，用户态地址空间中的页，其<code>User/Supervisor</code>标志为 0)，且函数返回1。</p>
<p><code>do_wp_page()</code>函数首先把<code>page_table</code>参数所引用的页表表项装入局部变量<code>pte</code>，然后再获得一个新页面：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pte = *page_table;</span><br><span class="line">new_page = __get_free_page(GFP_USER);</span><br></pre></td></tr></table></figure></p>
<p>由于页面的分配可能阻塞进程，因此，一旦获得页面，这个函数就在页表表项上执行下面的一致性检查：</p>
<ul>
<li>当进程等待一个空闲的页面时，这个页是否已经被交换出去(<code>pte</code>和<code>*page_table</code>的值不相同)；</li>
<li>这个页是否已不在物理内存中(页表表项中页的<code>Present</code>标志为 0)；</li>
<li>页现在是否可写(页项中页的<code>Read/Write</code>标志为 1)。</li>
</ul>
<p>如果以上情况中的任意一个发生，<code>do_wp_page()</code>释放以前所获得的页面，并返回 1。现在，函数更新次级缺页的数目，并把引起错误的页的页描述符指针保存到<code>page_map</code>局部变量中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsk-&gt;min_flt++;</span><br><span class="line">page_map = mem_map + MAP_NR(old_page);</span><br></pre></td></tr></table></figure></p>
<p>接下来，函数必须确定是否必须真的把这个页复制一份。如果仅有一个进程使用这个页，就无须应用写时复制技术，而且进程应该能够自由地写这个页。因此，这个页面被标记为可写，这样当试图写入的时候就不会再次引起“缺页”错误，以前分配的新的页面也被释放，函数结束并返回 1。这种检查是通过读取<code>page</code>结构的<code>count</code>域而进行的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (page_map-&gt;count == <span class="number">1</span>) &#123;</span><br><span class="line">    set_pte(page_table, pte_mkdirty(pte_mkwrite(pte)));</span><br><span class="line">    flush_tlb_page(vma, address);</span><br><span class="line">    <span class="keyword">if</span> (new_page)</span><br><span class="line">        free_page(new_page);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相反，如果这个页面由两个或多个进程所共享，函数把旧页面(old_page)的内容复制到新分配的页面(new_page)中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (old_page == ZERO_PAGE)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span> *) new_page, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span> *) new_page, (<span class="type">void</span> *) old_page, PAGE_SIZE);</span><br><span class="line">set_pte(page_table, pte_mkwrite(pte_mkdirty(</span><br><span class="line">mk_pte(new_page, vma-&gt;vm_page_prot))));</span><br><span class="line">flush_tlb_page(vma, address); </span><br><span class="line">__free_page(page_map);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果旧页面是零页面，就使用<code>memset</code>宏把新的页面填充为 0。否则，使用<code>memcpy</code>宏复制页面的内容。不要求一定要对零页作特殊的处理，但是特殊处理确实能够提高系统的性能，因为它使用很少的地址而保护了微处理器的硬件高速缓存。</p>
<p>然后，用新页面的物理地址更新页表的表项，并把新页面标记为可写和脏。最后，函数调用<code>__free_pages()</code>减小对旧页面的引用计数。</p>
<h3 id="对本节的几点说明"><a href="#对本节的几点说明" class="headerlink" title="对本节的几点说明"></a>对本节的几点说明</h3><ol>
<li>通过<code>fork()</code>建立进程，开始时只有一个页目录和一页左右的可执行页，于是缺页异常会频繁发生。</li>
<li>虚拟地址映射到物理地址，只有在请页时才完成，这时要建立页表和更新页表(页表是动态建立的)。页表不可被换出，不记年龄，它们被内核中保留，只有在<code>exit</code>时清除。</li>
<li>在处理页故障的过程中，因为要涉及到磁盘访问等耗时操作，因此操作系统会选择另外一个进程进入执行状态，即进行新一轮调度。</li>
</ol>
<h2 id="交换机制"><a href="#交换机制" class="headerlink" title="交换机制"></a>交换机制</h2><p>当物理内存出现不足时，Linux内存管理子系统需要释放部分物理内存页面。这一任务由内核的交换守护进程<code>kswapd</code>完成，该内核守护进程实际是一个内核线程，它在内核初始化时启动，并周期地运行。它的任务就是保证系统中具有足够的空闲页面，从而使内存管理子系统能够有效运行。</p>
<h3 id="交换的基本原理"><a href="#交换的基本原理" class="headerlink" title="交换的基本原理"></a>交换的基本原理</h3><p>在Linux中，我们把用作交换的磁盘空间叫做交换文件或交换区。在Linux中，交换的单位是页面而不是进程。尽管交换的单位是页面，但交换还是要付出一定的代价，尤其是时间的代价。这里要说明的是，页面交换是不得已而为之，例如在时间要求比较紧急的实时系统中，是不宜采用页面交换机制的，因为它使程序的执行在时间上有了较大的不确定性。</p>
<p>在页面交换中，必须考虑 4 个主要问题：</p>
<ul>
<li>哪种页面要换出；</li>
<li>如何在交换区中存放页面；</li>
<li>如何选择被交换出的页面；</li>
<li>何时执行页面换出操作。</li>
</ul>
<h4 id="哪种页面被换出"><a href="#哪种页面被换出" class="headerlink" title="哪种页面被换出"></a>哪种页面被换出</h4><p>可以把用户空间中的页面按其内容和性质分为以下几种：</p>
<ul>
<li>进程映像所占的页面，包括进程的代码段、数据段、堆栈段以及动态分配的“存储堆”；<ul>
<li>进程的代码段数据段所占的内存页面可以被换入换出，但堆栈所占的页面一般不被换出，因为这样可以简化内核的设计。</li>
</ul>
</li>
<li>通过系统调用<code>mmap()</code>把文件的内容映射到用户空间；<ul>
<li>这些页面所使用的交换区就是被映射的文件本身。</li>
</ul>
</li>
<li>进程间共享内存区。<ul>
<li>其页面的换入换出比较复杂。</li>
</ul>
</li>
</ul>
<p>与此相对照，映射到内核空间中的页面都不会被换出。具体来说，内核代码和内核中的全局量所占的内存页面既不需要分配(启动时被装入)，也不会被释放，这部分空间是静态的。除此之外，内核在执行过程中使用的页面要经过动态分配，但永驻内存，此类页面根据其内容和性质可以分为两类。</p>
<ol>
<li>内核调用<code>kmalloc()</code>或<code>vmalloc()</code>为内核中临时使用的数据结构而分配的页于是立即释放。但是，由于一个页面中存放有多个同种类型的数据结构，所以要到整个页面都空闲时才把该页面释放。</li>
<li>内核中通过调用<code>alloc_pages()</code>，为某些临时使用和管理目的而分配的页面，例如，每个进程的内核栈所占的两个页面、从内核空间复制参数时所使用的页面等。这些页面也是一旦使用完毕便无保存价值，所以立即释放。</li>
</ol>
<p>在内核中还有一种页面，虽然使用完毕，但其内容仍有保存价值，因此，并不立即释放。这类页面“释放”之后进入一个<code>LRU</code>队列，经过一段时间的缓冲让其“老化”。如果在此期间又要用到其内容了，就又将其投入使用，否则便继续让其老化，直到条件不再允许时才加以回收。这种用途的内核页面大致有以下这些：</p>
<ul>
<li>文件系统中用来缓冲存储一些文件目录结构<code>dentry</code>的空间；</li>
<li>文件系统中用来缓冲存储一些索引节点<code>inode</code>的空间；</li>
<li>用于文件系统读/写操作的缓冲区。</li>
</ul>
<h4 id="如何在交换区中存放页面"><a href="#如何在交换区中存放页面" class="headerlink" title="如何在交换区中存放页面"></a>如何在交换区中存放页面</h4><p>交换区也被划分为块，每个块的大小正好等于一页，我们把交换区中的一块叫做一个页插槽(Page Slot)，意思是说，把一个物理页面插入到一个插槽中。当进行换出时，内核尽可能把换出的页放在相邻的插槽中，从而减少在访问交换区时磁盘的寻道时间。这是高效的页面置换算法的物质基础。</p>
<p>如果系统使用了多个交换区，事情就变得更加复杂了。快速交换区(也就是存放在快速磁盘中的交换区)可以获得比较高的优先级。当查找一个空闲插槽时，要从优先级最高的交换区中开始搜索。如果优先级最高的交换区不止一个，为了避免超负荷地使用其中一个，应该循环选择相同优先级的交换区。如果在优先级最高的交换区中没有找到空闲插槽，就在优先级次高的交换区中继续进行搜索，依此类推。</p>
<h4 id="如何选择被交换出的页面"><a href="#如何选择被交换出的页面" class="headerlink" title="如何选择被交换出的页面"></a>如何选择被交换出的页面</h4><p>页面交换是非常复杂的，其主要内容之一就是如何选择要换出的页面，我们以循序渐进的方式来讨论页面交换策略的选择。</p>
<ul>
<li>策略一，需要时才交换。每当缺页异常发生时，就给它分配一个物理页面。如果发现没有空闲的页面可供分配，就设法将一个或多个内存页面换出到磁盘上，从而腾出一些内存页面来。</li>
<li>策略二，系统空闲时交换。与策略一相比较，这是一种积极的交换策略，也就是，在系统空闲时，预先换出一些页面而腾出一些内存页面，从而在内存中维持一定的空闲页面供应量，使得在缺页中断发生时总有空闲页面可供使用。至于换出页面的选择，一般都采用<code>LRU</code>(最近最少使用)算法。</li>
<li>策略三，换出但并不立即释放。当系统挑选出若干页面进行换出时，将相应的页面写入磁盘交换区中，并修改相应页表中页表项的内容(把<code>present</code>标志位置为 0)，但是并不立即释放，而是将其<code>page</code>结构留在一个缓冲(Cache)队列中，使其从活跃(Active)状态转为不活跃(Inactive)状态。至于这些页面的最后释放，要推迟到必要时才进行。</li>
<li>策略四，把页面换出推迟到不能再推迟为止。实际上，策略三还有值得改进的地方。首先在换出页面时不一定要把它的内容写入磁盘。如果一个页面自从最近一次换入后并没有被写过(如代码)，那么这个页面是“干净的”，就没有必要把它写入磁盘。其次，即使“脏”页面，也没有必要立即写出去，可以采用策略三。至于“干净”页面，可以一直缓冲到必要时才加以回收，因为回收一个“干净”页面花费的代价很小。</li>
</ul>
<p>下面对物理页面的换入/换出给出一个概要描述，这里涉及到前面介绍的<code>page</code>结构和<code>free_area</code>结构。</p>
<ol>
<li>释放页面。如果一个页面变为空闲可用，就把该页面的<code>page</code>结构链入某个页面管理区(Zone)的空闲队列<code>free_area</code>，同时页面的使用计数<code>count</code>减 1。</li>
<li>分配页面。调用<code>__alloc_pages()</code>或<code>__get_free_page()</code>从某个空闲队列分配内存页面，并将其页面的使用计数<code>count</code>置为 1。</li>
<li>活跃状态。已分配的页面处于活跃状态，该页面的数据结构<code>page</code>通过其队列头结构<code>lru</code>链入活跃页面队列<code>active_list</code>，并且在进程地址空间中至少有一个页与该页面之间建立了映射关系。</li>
<li>不活跃“脏”状态。处于该状态的页面其<code>page</code>结构通过其队列头结构<code>lru</code>链入不活跃“脏”页面队列<code>inactive_dirty_list</code>，并且原则是任何进程的页面表项不再指向该页面，也就是说，断开页面的映射，同时把页面的使用计数<code>count</code>减 1。</li>
<li>将不活跃“脏”页面的内容写入交换区，并将该页面的<code>page</code>结构从不活跃“脏”页面队列<code>inactive_dirty_list</code>转移到不活跃“干净”页面队列，准备被回收。</li>
<li>不活跃“干净”状态。页面<code>page</code>结构通过其队列头结构<code>lru</code>链入某个不活跃“干净”页面队列，每个页面管理区都有个不活跃“干净”页面队列<code>inactive_clean_list</code>。</li>
<li>如果在转入不活跃状态以后的一段时间内，页面又受到访问，则又转入活跃状态并恢复映射。</li>
<li>当需要时，就从“干净”页面队列中回收页面，也就是说或者把页面链入到空闲队列，或者直接进行分配。</li>
</ol>
<p>以上是页面换入/换出及回收的基本思想，实际的实现代码还要更复杂一些。</p>
<h4 id="何时执行页面换出操作"><a href="#何时执行页面换出操作" class="headerlink" title="何时执行页面换出操作"></a>何时执行页面换出操作</h4><p>Linux内核定期地检查系统内的空闲页面数是否小于预定义的极限，一旦发现空闲页面数太少，就预先将若干页面换出，以减轻缺页异常发生时系统所承受的负担。为此，Linux内核设置了一个专伺定期将页面换出的守护进程<code>kswapd</code>。</p>
<h3 id="页面交换守护进程kswapd"><a href="#页面交换守护进程kswapd" class="headerlink" title="页面交换守护进程kswapd"></a>页面交换守护进程kswapd</h3><p>从原理上说，<code>kswapd</code>相当于一个进程，它有自己的进程控制块<code>task_struct</code>结构。与普通进程相比，<code>kswapd</code>有其特殊性。首先，它没有自己独立的地址空间，所以在近代操作系统理论中把它称为“线程”以与进程相区别。那么，<code>kswapd</code>的地址空间实际上就是内核空间。其次，它的代码是静态地链接在内核中的，因此，可以直接调用内核中的各种子程序和函数。</p>
<p><code>kswapd</code>的源代码基本上都在<code>mm/vmscan.c</code>中，图 6.19 给出了<code>kswapd</code>中与交换有关的主要函数调用关系。<br><img src="/img/1633835076.png" alt=""></p>
<h4 id="kswapd"><a href="#kswapd" class="headerlink" title="kswapd()"></a>kswapd()</h4><p>在Linux 2.4.10 以后的版本中对<code>kswapd()</code>的实现代码进行了模块化组织，可读性大大加强，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kswapd</span><span class="params">(<span class="type">void</span> *unused)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line">    DECLARE_WAITQUEUE(wait, tsk);</span><br><span class="line">    daemonize(); <span class="comment">/*内核线程的初始化*/</span></span><br><span class="line">    <span class="built_in">strcpy</span>(tsk-&gt;comm, <span class="string">&quot;kswapd&quot;</span>);</span><br><span class="line">    sigfillset(&amp;tsk-&gt;blocked); <span class="comment">/*把进程PCB中的阻塞标志位全部置为 1*/</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Tell the memory management that we&#x27;re a &quot;memory allocator&quot;,</span></span><br><span class="line"><span class="comment">    * and that if we need more memory we should get access to it</span></span><br><span class="line"><span class="comment">    * regardless (see &quot;__alloc_pages()&quot;). &quot;kswapd&quot; should</span></span><br><span class="line"><span class="comment">    * never get caught in the normal page freeing logic.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * (Kswapd normally doesn&#x27;t need memory anyway, but sometimes</span></span><br><span class="line"><span class="comment">    * you need a small amount of memory in order to be able to</span></span><br><span class="line"><span class="comment">    * page out something else, and this flag essentially protects</span></span><br><span class="line"><span class="comment">    * us from recursively trying to free more memory as we&#x27;re</span></span><br><span class="line"><span class="comment">    * trying to free the first piece of memory in the first place).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    tsk-&gt;flags |= PF_MEMALLOC; <span class="comment">/*这个标志表示给`kswapd`要留一定的内存*/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Kswapd main loop.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        add_wait_queue(&amp;kswapd_wait, &amp;wait); <span class="comment">/*把kswapd加入等待队列*/</span></span><br><span class="line">        mb(); <span class="comment">/*增加一条汇编指令*/</span></span><br><span class="line">        <span class="keyword">if</span> (kswapd_can_sleep()) <span class="comment">/*检查调度标志是否置位*/</span></span><br><span class="line">            schedule(); <span class="comment">/*调用调度程序*/</span></span><br><span class="line">        _set_current_state(TASK_RUNNING); <span class="comment">/*让`kswapd`处于就绪状态*/</span></span><br><span class="line">        remove_wait_queue(&amp;kswapd_wait, &amp;wait); <span class="comment">/*把`kswapd`从等待队列删除*/</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If we actually get into a low-memory situation,</span></span><br><span class="line"><span class="comment">        * the processes needing more memory will wake us</span></span><br><span class="line"><span class="comment">        * up on a more timely basis.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        kswapd_balance(); <span class="comment">/* kswapd的核心函数，请看后面内容*/</span></span><br><span class="line">        run_task_queue(&amp;tq_disk); <span class="comment">/*运行tq_disk队列中的例程*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>kswapd</code>是内存管理中唯一的一个线程，其创建如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kswapd_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;Starting kswapd\n&quot;</span>);</span><br><span class="line">    swap_setup();</span><br><span class="line">    kernel_thread(kswapd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES | CLONE_SIGNAL);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，在内核启动时由模块的初始化例程调用<code>kswapd_init</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module_init(kswapd_init)</span><br></pre></td></tr></table></figure></p>
<p>从上面的介绍可以看出，<code>kswapd</code>成为内核的一个线程，其主循环是一个无限循环。循环一开始，把它加入等待队列，但如果调度标志为 1，就执行调度程序，紧接着就又把它从等待队列删除，将其状态变为就绪。只要调度程序再次执行，它就会得到执行，如此周而复始进行下去。</p>
<h4 id="kswapd-balance-函数"><a href="#kswapd-balance-函数" class="headerlink" title="kswapd_balance()函数"></a>kswapd_balance()函数</h4><p>在本章的初始化一节中，我们介绍了物理内存的 3 个层次，即存储节点、管理区和页面。所谓平衡就是对页面的释放要均衡地在各个存储节点、管理区中进行，代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kswapd_balance</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> need_more_balance;</span><br><span class="line">    <span class="type">pg_data_t</span> * pgdat;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        need_more_balance = <span class="number">0</span>;</span><br><span class="line">        pgdat = pgdat_list;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            need_more_balance |= kswapd_balance_pgdat(pgdat);</span><br><span class="line">        &#125; <span class="keyword">while</span> ((pgdat = pgdat-&gt;node_next));</span><br><span class="line">    &#125; <span class="keyword">while</span> (need_more_balance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数比较简单，主要是对每个存储节点进行扫描。然后又调用<code>kswapd_balance_pgdat()</code>对每个管理区进行扫描：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kswapd_balance_pgdat</span><span class="params">(<span class="type">pg_data_t</span> * pgdat)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> need_more_balance = <span class="number">0</span>, i;</span><br><span class="line">    <span class="type">zone_t</span> * zone;</span><br><span class="line">    <span class="keyword">for</span> (i = pgdat-&gt;nr_zones<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        zone = pgdat-&gt;node_zones + i;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(current-&gt;need_resched))</span><br><span class="line">            schedule();</span><br><span class="line">        <span class="keyword">if</span> (!zone-&gt;need_balance)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!try_to_free_pages(zone, GFP_KSWAPD, <span class="number">0</span>)) &#123;</span><br><span class="line">            zone-&gt;need_balance = <span class="number">0</span>;</span><br><span class="line">            __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">            schedule_timeout(HZ);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check_classzone_need_balance(zone))</span><br><span class="line">            need_more_balance = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            zone-&gt;need_balance = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，最主要的函数是<code>try_to_free_pages()</code>，能否调用这个函数取决于平衡标志<code>need_balance</code>是否为 1，也就是说看某个管理区的空闲页面数是否小于最高警戒线，这是由<code>check_classzone_need_balance()</code>函数决定的。当某个管理区的空闲页面数小于其最高警戒线时就调用<code>try_to_free_pages()</code>。</p>
<h4 id="try-to-free-pages"><a href="#try-to-free-pages" class="headerlink" title="try_to_free_pages()"></a>try_to_free_pages()</h4><p>该函数代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">try_to_free_pages</span><span class="params">(<span class="type">zone_t</span> *classzone, <span class="type">unsigned</span> <span class="type">int</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> priority = DEF_PRIORITY;</span><br><span class="line">    <span class="type">int</span> nr_pages = SWAP_CLUSTER_MAX;</span><br><span class="line">    gfp_mask = pf_gfp_mask(gfp_mask);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nr_pages = shrink_caches(classzone, priority, gfp_mask, nr_pages);</span><br><span class="line">        <span class="keyword">if</span> (nr_pages &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (--priority);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Hmm.. Cache shrink failed - time to kill something?</span></span><br><span class="line"><span class="comment">    * Mhwahahhaha! This is the part I really like. Giggle.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    out_of_memory();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的优先级表示对队列进行扫描的长度，缺省的优先级<code>DEF_PRIORITY</code>为 6(最低优先级)。假定队列长度为<code>L</code>，优先级 6 就表示要扫描的队列长度为<code>L/26</code>，所以这个循环至少循环 6 次。<code>nr_pages</code>为要换出的页面数，其最大值<code>SWAP_CLUSTER_MAX</code>为 32。其中主要调用的函数为<code>shrink_caches()</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shrink_caches</span><span class="params">(<span class="type">zone_t</span> * classzone, <span class="type">int</span> priority, <span class="type">unsigned</span> <span class="type">int</span> gfp_mask, <span class="type">int</span> nr_pages)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> chunk_size = nr_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ratio;</span><br><span class="line">    nr_pages -= kmem_cache_reap(gfp_mask);</span><br><span class="line">    <span class="keyword">if</span> (nr_pages &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    nr_pages = chunk_size;</span><br><span class="line">    <span class="comment">/* try to keep the active list 2/3 of the size of the cache */</span></span><br><span class="line">    ratio = (<span class="type">unsigned</span> <span class="type">long</span>) nr_pages * nr_active_pages / ((nr_inactive_pages + <span class="number">1</span>) * <span class="number">2</span>);</span><br><span class="line">    refill_inactive(ratio);</span><br><span class="line">    nr_pages = shrink_cache(nr_pages, classzone, gfp_mask, priority);</span><br><span class="line">    <span class="keyword">if</span> (nr_pages &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    shrink_dcache_memory(priority, gfp_mask);</span><br><span class="line">    shrink_icache_memory(priority, gfp_mask); </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_QUOTA</span></span><br><span class="line">    shrink_dqcache_memory(DEF_PRIORITY, gfp_mask);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> nr_pages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>kmem_cache_reap()</code>函数“收割(reap)”由<code>slab</code>机制管理的空闲页面。如果从<code>slap</code>回收的页面数已经达到要换出的页面数<code>nr_pages</code>，就不用从其他地方进行换出。<code>refill_inactive()</code>函数把活跃队列中的页面移到非活跃队列。<code>shrink_cache()</code>函数把一个“洗净”且未加锁的页面移到非活跃队列，以便该页能被尽快释放。</p>
<p>此外，除了从各个进程的用户空间所映射的物理页面中回收页面外，还调用<code>shrink_dcache_memory()</code>、<code>shrink_icache_memory()</code>及<code>shrink_dqcache_memory()</code>回收内核数据结构所占用的空间。</p>
<h4 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h4><p>到底哪些页面会被作为后选页以备换出，这是由<code>swap_out()</code>和<code>shrink_cache()</code>一起完成的。这个过程比较复杂，这里我们抛开源代码，以理清思路为目标。</p>
<p><code>shrink_cache()</code>要做很多换出的准备工作。它关注两个队列：“活跃的” LRU队列和“非活跃的” FIFO 队列，每个队列都是<code>struct page</code>形成的链表。该函数的代码比较长，我们把它所做的工作概述如下：</p>
<ul>
<li>把引用过的页面从活跃队列的队尾移到该队列的队头(实现<code>LRU</code>策略)；</li>
<li>把未引用过的页面从活跃队列的队尾移到非活跃队列的队头(为准备换出而排队)；</li>
<li>把脏页面安排在非活跃队列的队尾准备写到磁盘；</li>
<li>从非活跃队列的队尾恢复干净页面(写出的页面就成为干净的)。</li>
</ul>
<h3 id="交换空间的数据结构"><a href="#交换空间的数据结构" class="headerlink" title="交换空间的数据结构"></a>交换空间的数据结构</h3><p>Linux支持多个交换文件或设备，它们将被<code>swapon</code>和<code>swapoff</code>系统调用来打开或关闭。每个交换文件或设备都可用<code>swap_info_struct</code>结构来描述：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_info_struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">kdev_t</span> swap_device;</span><br><span class="line">    <span class="type">spinlock_t</span> sdev_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * <span class="title">swap_file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">swap_vfsmnt</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> * swap_map;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lowest_bit;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> highest_bit;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cluster_next; </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cluster_nr;</span><br><span class="line">    <span class="type">int</span> prio; <span class="comment">/* swap priority */</span></span><br><span class="line">    <span class="type">int</span> pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> max;</span><br><span class="line">    <span class="type">int</span> next; <span class="comment">/* next entry on swap list */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> nr_swap_pages;</span><br></pre></td></tr></table></figure></p>
<p><code>flags</code>域(<code>SWP_USED</code>或<code>SWP_WRITEOK</code>)用作控制访问交换文件。当<code>swapoff</code>被调用(为了取消一个文件)时，<code>SWP_WRITEOK</code>置成<code>off</code>，使在文件中无法分配空间。如果<code>swapon</code>加入一个新的交换文件时，<code>SWP_USED</code>被置位。这里还有一静态变量(<code>nr_swapfiles</code>)来记录当前活动的交换文件数。</p>
<p>域<code>lowest_bit</code>，<code>highest_bit</code>表明在交换文件中空闲范围的边界，这是为了快速寻址。当用户程序<code>mkswap</code>初始化交换文件或设备时，在文件的第一个页插槽的前 10 个字节，有一个包含有位图的标志，在位图里初始化为 0，代表坏的页插槽，1 代表相关页插槽是空闲的。</p>
<p>当用户程序调用<code>swapon()</code>时，有一页被分配给<code>swap_map</code>。<code>swap_map</code>为在交换文件中每一个页插槽保留了一个字节，0 代表可用页插槽，128 代表不可用页插槽。它被用于记下交换文件中每一页插槽上的<code>swap</code>请求。内存中的一页被换出时，调用<code>get_swap_page()</code>会得到一个一个记录换出位置的索引，然后在页表项中回填( 1～ 31 位)此索引。这是为了在发生在缺页异常时进行处理(<code>do_no_page</code>)。索引的高 7 位给定交换文件，后 24 位给定设备中的页插槽号。</p>
<p>另外函数<code>swap_duplicate()</code>被<code>copy_page_tables()</code>调用来实现子进程在<code>fork()</code>时继承被换出的页面，这里要增加域<code>swap_map</code>中此页面的<code>count</code>值，任何进程访问此页面时，会换入它的独立的拷贝。</p>
<p><code>swap_free()</code>减少域<code>swap_map</code>中的<code>count</code>值，如果<code>count</code>减到 0 时，则这页面又可再次分配(<code>get_swap_page</code>)，在把一个换出页面调入(<code>swap_in</code>)内存时或放弃一个页面时(<code>free_one_table</code>)调用<code>swap_free()</code>。相关函数在文件<code>filemap.c</code>中。</p>
<h3 id="交换空间的应用"><a href="#交换空间的应用" class="headerlink" title="交换空间的应用"></a>交换空间的应用</h3><h4 id="建立交换空间"><a href="#建立交换空间" class="headerlink" title="建立交换空间"></a>建立交换空间</h4><p>作为交换空间的交换文件实际就是通常的文件，但文件的扇区必须是连续的，即文件中必须没有“洞”，另外，交换文件必须保存在本地硬盘上。</p>
<p>由于内核要利用交换空间进行快速的内存页面交换，因此，它不进行任何文件扇区的检查，而认为扇区是连续的。由于这一原因，交换文件不能包含洞。可用下面的命令建立无洞的交换文件：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/extra-swap bs=1024 count=2048</span><br><span class="line">2048+0 records <span class="keyword">in</span> </span><br><span class="line">2048+0 records out</span><br></pre></td></tr></table></figure></p>
<p>上面的命令建立了一个名称为<code>extra-swap</code>，大小为<code>2048KB</code>的交换文件。</p>
<p>交换分区和其他分区也没有什么不同，可像建立其他分区一样建立交换分区。但该分区不包含任何文件系统。</p>
<p>建立交换文件或交换分区之后，需要在文件或分区的开头写入签名，写入的签名实际是由内核使用的一些管理信息。写入签名的命令为<code>mkswap</code>，如下所示：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkswap /extra-swp 2048</span><br><span class="line">Setting up swapspace, size = 2088960 bytes</span><br></pre></td></tr></table></figure></p>
<p>这时，新建立的交换空间尚未开始使用。使用<code>mkswap</code>命令时必须小心，因为该命令不会检查文件或分区内容，因此极有可能覆盖有用的信息，或破坏分区上的有效文件系统信息。</p>
<p>Linux内存管理子系统将每个交换空间的大小限制在 127MB (实际为 (4096.10)<em>8</em>4096 = 133890048 Byte = 127.6875MB)。可以在系统中同时使用 16 个交换空间，从而使交换空间总量达到 2GB。</p>
<h4 id="使用交换空间"><a href="#使用交换空间" class="headerlink" title="使用交换空间"></a>使用交换空间</h4><p>利用<code>swapon</code>命令可将经过初始化的交换空间投入使用。如下所示：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ swapon /extra-swap</span><br></pre></td></tr></table></figure></p>
<p>如果在<code>/etc/fstab</code>文件中列出交换空间，则可自动将交换空间投入使用：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/hda5 none swap sw 0 0</span><br><span class="line">/extra-swap none swap sw 0 0</span><br></pre></td></tr></table></figure></p>
<p>实际上，启动脚本会运行<code>swapon –a</code>命令，从而将所有出现在<code>/etc/fstab</code>文件中的交换空间投入使用。</p>
<p>利用<code>free</code>命令，可查看交换空间的使用。如下所示：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">total used free shared buffers</span><br><span class="line">Mem: 15152 14896 256 12404 2528</span><br><span class="line">-/+ buffers: 12368 2784</span><br><span class="line">Swap: 32452 6684 25768</span><br></pre></td></tr></table></figure></p>
<p>该命令输出的第一行<code>Mem</code>显示了系统中物理内存的使用情况。<code>total</code>列显示的是系统中的物理内存总量；<code>used</code>列显示正在使用的内存数量；<code>free</code>列显示空闲的内存量；<code>shared</code>列显示由多个进程共享的内存量，该内存量越多越好；<code>buffers</code>显示了当前的缓冲区高速缓存的大小。</p>
<p>输出的最后一行<code>Swap</code>显示了有关交换空间的类似信息。如果该行的内容均为 0，表明当前没有活动的交换空间。</p>
<p>利用<code>top</code>命令或查看<code>/proc</code>文件系统中的<code>/proc/meminfo</code>文件可获得相同的信息。利用<code>swapoff</code>命令可移去使用中的交换空间。但该命令应只用于临时交换空间，否则有可能造成系统崩溃。</p>
<p><code>swapoff –a</code>命令按照<code>/etc/fstab</code>文件中的内容移去所有的交换空间，但任何手工投入使用的交换空间保留不变。</p>
<h4 id="分配交换空间"><a href="#分配交换空间" class="headerlink" title="分配交换空间"></a>分配交换空间</h4><p>大多数人认为，交换空间的总量应该是系统物理内存量的两倍，实际上这一规则是不正确的，正确的交换空间大小应按如下规则确定。</p>
<ol>
<li>估计需要的内存总量。运行想同时运行的所有程序，并利用<code>free</code>或<code>ps</code>程序估计所需的内存总量，只需大概估计。</li>
<li>增加一些安全性余量。</li>
<li>减去已有的物理内存数量，然后将所得数据取整为`MB，这就是应当的交换空间大小。</li>
<li>如果得到的交换空间大小远远大于物理内存量，则说明需要增加物理内存数量，否则系统性能会因为过分的页面交换而下降。</li>
<li>当计算的结果说明不需要任何交换空间时，也有必要使用交换空间。Linux从性能的角度出发，会在磁盘空闲时将某些页面交换到交换空间中，以便减少必要时的交换时间。</li>
</ol>
<p>另外，如果在不同的磁盘上建立多个交换空间，有可能提高页面交换的速度，这是因为某些硬盘驱动器可同时在不同的磁盘上进行读写操作。</p>
<h2 id="缓存和刷新机制"><a href="#缓存和刷新机制" class="headerlink" title="缓存和刷新机制"></a>缓存和刷新机制</h2><h3 id="Linux使用的缓存"><a href="#Linux使用的缓存" class="headerlink" title="Linux使用的缓存"></a>Linux使用的缓存</h3><p>不管在硬件设计还是软件设计中，高速缓存是获得高性能的常用手段。Linux使用了多种和内存管理相关的高速缓存。</p>
<h4 id="缓冲区高速缓存"><a href="#缓冲区高速缓存" class="headerlink" title="缓冲区高速缓存"></a>缓冲区高速缓存</h4><p>缓冲区高速缓存中包含了由块设备使用的数据缓冲区。这些缓冲区中包含了从设备中读取的数据块或写入设备的数据块。缓冲区高速缓存由设备标识号和块标号索引，因此可以快速找出数据块。如果数据能够在缓冲区高速缓存中找到，则系统就没有必要在物理块设备上进行实际的读操作。</p>
<p>内核为每个缓冲区维护很多信息以有助于缓和写操作，这些信息包括一个“脏(dirty)”位，表示内存中的缓冲区已被修改，必须写到磁盘；还包括一个时间标志，表示缓冲区被刷新到磁盘之前已经在内存中停留了多长时间。因为缓冲区的有关信息被保存在缓冲区首部，所以，这些数据结构连同用户数据本身的缓冲区都需要维护。</p>
<h4 id="页面高速缓存"><a href="#页面高速缓存" class="headerlink" title="页面高速缓存"></a>页面高速缓存</h4><p>页面高速缓存是页面<code>I/O</code>操作访问数据所使用的磁盘高速缓存。页面高速缓存中一个页面的标识是通过文件的索引节点和文件中的偏移量达到的。与页面高速缓存有关的操作主要有 3 种：</p>
<ul>
<li>当访问的文件部分不在高速缓存中时增加一页面；</li>
<li>当高速缓存变得太大时删除一页面；</li>
<li>查找一个给定文件偏移量所在的页面。</li>
</ul>
<h4 id="交换高速缓存"><a href="#交换高速缓存" class="headerlink" title="交换高速缓存"></a>交换高速缓存</h4><p>只有修改后的(脏)页面才保存在交换文件中。修改后的页面写入交换文件后，如果该页面再次被交换但未被修改时，就没有必要写入交换文件，相反，只需丢弃该页面。交换高速缓存实际包含了一个页面表项链表，系统的每个物理页面对应一个页面表项。对交换出的页面，该页面表项包含保存该页面的交换文件信息，以及该页面在交换文件中的位置信息。</p>
<p>如果某个交换页面表项非零，则表明保存在交换文件中的对应物理页面没有被修改。如果这一页面在后续的操作中被修改，则处于交换缓存中的页面表项被清零。Linux需要从物理内存中交换出某个页面时，它首先分析交换缓存中的信息，如果缓存中包含该物理页面的一个非零页面表项，则说明该页面交换出内存后还没有被修改过，这时，系统只需丢弃该页面。</p>
<p>这里给出有关交换缓存的部分函数及功能：位于<code>/linux/mm/swap_state.c</code>中。初始化交换缓冲，设定大小，位置的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">init_swap_cache</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>显示交换缓冲信息的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">show_swap_cache_info</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>加入交换缓冲的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add_to_swap_cache</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> index, <span class="type">unsigned</span> <span class="type">long</span> entry)</span></span><br></pre></td></tr></table></figure></p>
<p>参数<code>index</code>是进入缓冲区的索引(<code>index</code>是索引表中的某一项)，<code>entry</code>是‘页面表项’。</p>
<p>复制被换出的页面：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">swap_duplicate</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>从缓冲区中移去某页面<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete_from_swap_cache(page_nr);</span><br></pre></td></tr></table></figure></p>
<h3 id="缓冲区高速缓存-1"><a href="#缓冲区高速缓存-1" class="headerlink" title="缓冲区高速缓存"></a>缓冲区高速缓存</h3><p>Linux采用了缓冲区高速缓存机制，而不同于其他操作系统的“写透”方式，也就是说，当把一个数据写入文件时，内核将把数据写入内存缓冲区，而不是直接写入磁盘。</p>
<p>在这里要用到一个数据结构<code>buffer_head</code>，它是用来描述缓冲区的数据结构，缓冲区的大小一般要比页面尺寸小，所以一页面中可以包含数个缓冲区，同一页面中的缓冲区用链表连接。回忆一下页面结构<code>page</code>，其中有一个域<code>buffer_head buffer</code>就是用来指向缓冲区的。</p>
<p>由于使用了缓冲技术，因此有可能出现这种情况：写磁盘的命令已经返回，但实际的写入磁盘的操作还未执行。</p>
<p>在Linux系统中，除了传统的<code>update</code>守护进程之外，还有一个额外的守护进程<code>dbflush</code>，这一进程可频繁运行不完整的<code>sync</code>从而可避免有时由于<code>sync</code>命令的超负荷磁盘操作而造成的磁盘冻结，一般情况下，它们在系统引导时自动执行，且每隔 30s 执行一次任务。<code>sync</code>命令使用基本的系统调用<code>sync()</code>来实现。<code>dbflush</code>在Linux系统中由<code>update</code>启动。如果由于某种原因该进程僵死了，则内核会发送警告信息，这时需要手工启动该进程(/sbin/update)。</p>
<h4 id="页面缓存的详细描述"><a href="#页面缓存的详细描述" class="headerlink" title="页面缓存的详细描述"></a>页面缓存的详细描述</h4><p>经内存映射的文件每次只读取一页面内容，读取后的页面保存在页面缓存中，利用页面缓存，可提高文件的访问速度。</p>
<p><img src="/img/1633847842.jpg" alt=""><br>如图 6.20 所示，页面缓存由<code>page_hash_table</code>组成，它是一个<code>mem_map_t</code>(即<code>struct page</code>数据结构)的指针向量。页面缓存的结构是Linux内核中典型的哈希表结构。哈希线性表中的指针代表一个链表，该链表所包含的所有节点均具有相同的哈希值，在该链表中查找可访问到指定的数据。</p>
<p>在Linux页面缓存中，访问<code>page_hash_table</code>的索引由文件的<code>VFS</code>(虚拟文件系统)索引节点<code>inode</code>和内存页面在文件中的偏移量生成。</p>
<p>当系统要从内存映射文件中读取某一未加锁的页面时，就首先要用到函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_page (<span class="keyword">struct</span> inode * inode, <span class="type">unsigned</span> <span class="type">long</span> offset)</span><br></pre></td></tr></table></figure></p>
<p>它完成如下工作。</p>
<p>首先是在“页面缓存”中查找，如果发现该页面保存在缓存中，则可以免除实际的文件读取，而只需从页面缓存中读取，这时，指向<code>mm_map_t</code>数据结构的指针被返回到页面故障的处理代码。部分代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数page_hash()是从哈希表中找页面*/</span></span><br><span class="line"><span class="keyword">for</span> (page = page_hash(inode, offset); page ; page = page-&gt;next_hash)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (page-&gt;inode != inode)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (page-&gt;offset != offset)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">/* 找到了特定页面 */</span></span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;page-&gt;count);</span><br><span class="line">    set_bit(PG_referenced, &amp;page-&gt;flags);<span class="comment">/*设访问位*/</span></span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> page;</span><br></pre></td></tr></table></figure></p>
<p>如果该页面不在缓存中，则必须从实际的文件系统映像中读取页面，这时Linux内核首先分配物理页面然后从磁盘读取页面内容。</p>
<p>如果可能，Linux还会预先读取文件中下一页面内容到页面缓存中，而不等页面错误发生才去“请页面”，这样做是为了提高装入代码的速度(有关代码在<code>filemap.c</code>中，如<code>generic_file_readahead()</code>等函数)。这样，如果进程要连续访问页面，则下一页面的内容不必再次从文件中读取了，而只需从页面缓存中读取。</p>
<p>随着映像的读取和执行，页面缓存中的内容可能会增多，这时，Linux可移走不再需要的页面。当系统中可用的物理内存量变小时，Linux也会通过缩小页面缓存的大小而释放更多的物理内存页面。</p>
<h4 id="有关页面缓存的函数"><a href="#有关页面缓存的函数" class="headerlink" title="有关页面缓存的函数"></a>有关页面缓存的函数</h4><p>先看把读入的页面如何存于缓存，这要用到函数<code>add_to_page_cache()</code>，它完成把指定的“文件页面”记入页面缓存中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">add_to_page_cache</span><span class="params">(<span class="keyword">struct</span> page * page,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> inode * inode, <span class="type">unsigned</span> <span class="type">long</span> offset)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/*设置有关页面域，引用数，页面使用方式，页面在文件中的偏移 */</span></span><br><span class="line">    page-&gt;count++;</span><br><span class="line">    page-&gt;flags &amp;= ~((<span class="number">1</span> &lt;&lt; PG_uptodate) | (<span class="number">1</span> &lt;&lt; PG_error));</span><br><span class="line">    page-&gt;offset = offset;</span><br><span class="line">    add_page_to_inode_queue(inode, page);<span class="comment">/* 把页面加入inode节点队列*/</span></span><br><span class="line">    add_page_to_hash_queue(inode, page);<span class="comment">/* 把页面加入哈唏表`page_hash_table[]*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>哈希表<code>page_hash_table[]</code>的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> * <span class="title">page_hash_table</span>[<span class="title">PAGE_HASH_SIZE</span>];</span></span><br></pre></td></tr></table></figure></p>
<p>下面是有关对哈希表操作的部分代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">add_page_to_inode_queue</span><span class="params">(<span class="keyword">struct</span> inode * inode, <span class="keyword">struct</span> page * page)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">p</span> =</span> &amp;inode-&gt;i_pages;<span class="comment">/*指向物理页面*/</span></span><br><span class="line">    inode-&gt;i_nrpages++;<span class="comment">/*节点中调入内存的页面数目增 1*/</span></span><br><span class="line">    page-&gt;inode = inode; <span class="comment">/*指向该页面来自的文件节点结构，相互连成链*/</span></span><br><span class="line">    page-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((page-&gt;next = *p) != <span class="literal">NULL</span>)</span><br><span class="line">        page-&gt;next-&gt;prev = page;</span><br><span class="line">    *p = page; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把页面加入哈希表：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">add_page_to_hash_queue</span><span class="params">(<span class="keyword">struct</span> inode * inode, <span class="keyword">struct</span> page * page)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">p</span> =</span> &amp;page_hash(inode,page-&gt;offset);</span><br><span class="line">    page_cache_size++; <span class="comment">/*哈希表中记录的页面数目加 1*/</span></span><br><span class="line">    set_bit(PG_referenced, &amp;page-&gt;flags);<span class="comment">/*设置访问位*/</span></span><br><span class="line">    page-&gt;age = PAGE_AGE_VALUE; <span class="comment">/*设缓存中的页面“年龄”为定值，为淘汰做准备*/</span></span><br><span class="line">    page-&gt;prev_hash = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((page-&gt;next_hash = *p) != <span class="literal">NULL</span>)</span><br><span class="line">        page-&gt;next_hash-&gt;prev_hash = page; </span><br><span class="line">    *p = page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有关页面的刷新函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remove_page_from_hash_queue(page); <span class="comment">/*从哈希表中去掉页面*/</span></span><br><span class="line">remove_page_from_inode_queue(page); <span class="comment">/*从 inode节点中去掉页面*/</span></span><br></pre></td></tr></table></figure></p>
<h3 id="翻译后援存储器-TLB"><a href="#翻译后援存储器-TLB" class="headerlink" title="翻译后援存储器(TLB)"></a>翻译后援存储器(TLB)</h3><p>页表的实现对虚拟内存系统效率是极为关键的。例如把一个寄存器的内容复制到另一个寄存器中的一条指令，在不使用分页时，只需访问内存一次取指令，而在使用分页时需要额外的内存访问去读取页表。而系统的运行速度一般是被CPU从内存中取得指令和数据的速率限制的，如果在每次访问内存时都要访问两次内存会使系统性能降低三分之二。</p>
<p>对这个问题的解决，有人提出了一个解决方案，这个方案基于这样的观察：大部分程序倾向于对较少的页面进行大量的访问。因此，只有一小部分页表项经常被用到，其他的很少被使用。</p>
<p>采取的解决办法是为计算机装备一个不需要经过页表就能把虚拟地址映射成物理地址的小的硬件设备，这个设备叫做<code>TLB</code>(翻译后援存储器，Translation Lookside Buffer)，有时也叫做相联存储器(Associative Memory)，如图 6.21 所示。它通常在<code>MMU</code>内部，条目的数量较少，在这个例子中是 6 个，80386 有 32 个。<br><img src="/img/1633848455.png" alt=""></p>
<p>每一个<code>TLB</code>寄存器的每个条目包含一个页面的信息：有效位、虚页面号、修改位、保护码和页面所在的物理页面号，它们和页面表中的表项一一对应，如表所示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>段号</th>
<th>虚页面号</th>
<th>页面框</th>
<th>保护</th>
<th>年龄</th>
<th>有效位</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>1</td>
<td>7</td>
<td>RW</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>8</td>
<td>7</td>
<td>16</td>
<td>RW</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>33</td>
<td>RX</td>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>72</td>
<td>RX</td>
<td>13</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>8</td>
<td>17</td>
<td>RW</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>7</td>
<td>34</td>
<td>RX</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>当一个虚地址被送到<code>MMU</code>翻译时，硬件首先把它和<code>TLB</code>中的所有条目同时(并行地)进行比较。如果它的虚页面号在<code>TLB</code>中，并且访问没有违反保护位，它的页面会直接从<code>TLB</code>中取出而不去访问页表；如果虚页面号在<code>TLB</code>中，但当前指令试图写一个只读的页面，这时将产生一个缺页异常，与直接访问页表时相同。</p>
<p>如<code>MMU</code>发现在<code>TLB</code>中没有命中，它将随即进行一次常规的页表查找，然后从<code>TLB</code>中淘汰一个条目并把它替换为刚刚找到的页表项。因此如果这个页面很快再被用到的话，第 2 次访问时它就能在<code>TLB</code>中直接找到。在一个<code>TLB</code>条目被淘汰时，被修改的位被复制回在内存中的页表项，其他的值则已经在那里了。当<code>TLB</code>从页表装入时，所有的域都从内存中取得。必须明确在分页机制中，<code>TLB</code>中的数据和页表中的数据的相关性，不是由处理器进行维护，而是必须由操作系统来维护，高速缓存的刷新是通过装入处理器(80386)中的寄存器 CR3 来完成的。</p>
<p>这里提到的命中率，指一个页面在<code>TBL</code>中找到的概率。一般来说<code>TLB</code>的尺寸大可增加命中率，但会增加成本和软件的管理。所以一般都采用 8～64 个条目的数量。假如命中率是 0.85，访问内存时间是 120 纳秒，访<code>TLB</code>时间是 15 纳秒。那么访问时间是：0.85×(15+120)+(1-0.85)×(15+120+120)=153 纳秒。</p>
<h3 id="刷新机制"><a href="#刷新机制" class="headerlink" title="刷新机制"></a>刷新机制</h3><h4 id="软件管理TLB"><a href="#软件管理TLB" class="headerlink" title="软件管理TLB"></a>软件管理TLB</h4><p>在现代的一些<code>RISC</code>机中，几乎全部的这种页面管理工作都是由软件完成的。在这些机器中，<code>TLB</code>条目是由操作系统显式地装入，在<code>TLB</code>没有命中时，<code>MMU</code>不是到页表中找到并装入需要的页面信息，而是产生一个<code>TLB</code>故障把问题交给操作系统。操作系统必须找到页面，从<code>TLB</code>中淘汰一个条目，装入一个新的条目，然后重新启动产生异常(或故障)的指令。当然，所有这些都必须用很少指令完成，因为<code>TLB</code>不命中的频率远比页面异常大得多。</p>
<p>令人惊奇的是，如果<code>TLB</code>的尺寸取一个合理的较大值(比如 64 个条目)以减少不命中的频率，那么软件管理的<code>TLB</code>效率可能相当高。这里主要的收益是一个简单得多的<code>MMU</code>，它在CPU芯片上为高速缓存和其他能提高性能的部件让出了相当大的面积。</p>
<p>为了减少<code>TLB</code>的不命中率，操作系统有时可以用它的直觉来指出那些页面可能将被使用并把他们预装入<code>TLB</code>中。例如，当一个客户进程向位于同一台机器的服务器进程发出一个<code>RPC</code>请求时，服务器很可能即将运行。知道了这一点，在客户进程因执行<code>RPC</code>陷入时，系统就可以找到服务器的代码、数据、堆栈的页面，并在<code>TLB</code>中提前为他们建立映射，以避免<code>TLB</code>故障的发生。无论是硬件还是软件，处理<code>TLB</code>不命中的一般方法是对页表执行索引操作找出所引用的页面。用软件执行这个搜索的一个问题是保存页表的页面本身可能就不在<code>TLB</code>中，这将在处理过程中再一次引发一个<code>TLB</code>异常，这种异常可以通过保持一个大的(比如 4KB)<code>TLB</code>条目的软件高速缓存而得到减少，这个高速缓存保持在固定位置，它的页面总是保持在<code>TLB</code>中，操作系统通过首先检查软件高速缓存可以大大减少<code>TLB</code>不命中的次数。</p>
<h4 id="刷新机制-1"><a href="#刷新机制-1" class="headerlink" title="刷新机制"></a>刷新机制</h4><p>用软件来管理<code>TLB</code>和其他缓存的一个重要的要求就是保持<code>TLB</code>和其他缓存中的内容的同步性，这样必须考虑在一定条件下刷新内容。</p>
<p>在Linux中刷新机制(包括<code>TLB</code>的刷新，缓存的刷新等等)主要要用来完成以下几个工作：</p>
<ol>
<li>保证在任何时刻内存管理硬件所看到的进程的内核映射和内核页表一致；</li>
<li>如果负责内存管理的内核代码对用户进程页面进行了修改，那么用户的进程在被允许继续执行前，要求必须在缓存中看到正确的数据。</li>
</ol>
<p>例如当正在执行<code>write()</code>系统调用时，要保证页面缓存中的页面为新页，也就是要使缓存中的页面内容和写入文件的一致，就需要更新缓存中的页面。</p>
<h4 id="通常当地址空间的状态改变时，调用适当的刷新机制来描述状态的改变"><a href="#通常当地址空间的状态改变时，调用适当的刷新机制来描述状态的改变" class="headerlink" title="通常当地址空间的状态改变时，调用适当的刷新机制来描述状态的改变"></a>通常当地址空间的状态改变时，调用适当的刷新机制来描述状态的改变</h4><p>在Linux中刷新机制的实现是通过一系列函数(或宏)来完成的,例如常用的两个刷新函数的一般形式为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flush_cache_foo();</span><br><span class="line">flush_tlb_foo();</span><br></pre></td></tr></table></figure></p>
<p>这两个函数的调用是有一定顺序的，它们的逻辑意义如下所述。</p>
<p>在地址空间改变前必须刷新缓存，防止缓存中存在非法的空映射。函数<code>flush_cache_*()</code>会把缓存中的映射变成无效( 这里的缓存指的是<code>MMU</code>中的缓存，它负责虚地址到物理地址的当前映射关系。在刷新地址后，由于页表的改变，必须刷新<code>TBL</code>以便硬件可以把新的页表信息装入<code>TLB</code>。</p>
<p>下面介绍一些刷新函数的作用和使用情况：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">flush_cache_all</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">flush_tlb_all</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><br>这两个例程是用来通知相应机制，内核地址空间的映射已被改变，它意味着所有的进程都被改变了；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">flush_cache_mm</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">flush_tlb_mm</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm)</span>;</span><br></pre></td></tr></table></figure>
<p>它们用来通知系统被<code>mm_struct</code>结构所描述的地址空间正在改变，它们仅发生在用户空间的地址改变时；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flush_cache_range(<span class="keyword">struct</span> mm_struct *mm,<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> end);</span><br><span class="line">flush_tlb_range(<span class="keyword">struct</span> mm_struct *mm,<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">unsigned</span> <span class="type">long</span> end);</span><br></pre></td></tr></table></figure>
<p>它们刷新用户空间中的指定范围；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">flush_cache_page</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma,<span class="type">unsigned</span> <span class="type">long</span> address)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">flush_tlb_page</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma,<span class="type">unsigned</span> <span class="type">long</span> address)</span>;</span><br></pre></td></tr></table></figure>
<p>刷新一页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">flush_page_to_ram</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> page)</span>;<span class="comment">/*如果使用`i386 处理器，此函数为空，相应的刷新功能由硬件内部自动完成*/</span></span><br></pre></td></tr></table></figure>
<p>这个函数一般用在写时复制，它会使虚拟缓存中的对应项无效，这是因为如果虚拟缓存不可以自动地回写，于是会造成虚拟缓存中页面和主存中的内容不一致。</p>
<p>例如，虚拟内存 0x2000 对任务 1、任务 2、任务 3 共享，但对任务 2 只是可读，它映射物理内存 0x1000，那么如果任务 2 要对虚拟内存 0x2000 执行写操作时，会产生页面错误。内存管理系统要给它重新分配一个物理页面如 0x2600，此页面的内容是物理内存 0x1000 的拷贝，这时虚拟索引缓存中就有两项内核别名项 0x2000 分别对应两个物理地址0x1000 和 0x2600，在任务 2 对物理页面 0x2600 的内容进行了修改后，这样内核别名即虚地址 0x2000 映射的物理页面内容不一致，任务 3 在来访问虚地址 0x2000 时就会产生不一致错误。为了避免不一致错误，使用<code>flush_page_to_ram</code>使得缓存中的内核别名无效。</p>
<p>一般刷新函数的使用顺序如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">copy_cow_page(old_page,new_page,address);</span><br><span class="line">flush_page_to_ram(old_page);</span><br><span class="line">flush_page_to_ram(new_page);</span><br><span class="line">flush_cache_page(vam,address);</span><br><span class="line">….</span><br><span class="line">free_page(old_page);</span><br><span class="line">flush_tlb_page(vma,address);</span><br></pre></td></tr></table></figure></p>
<h4 id="函数代码简介"><a href="#函数代码简介" class="headerlink" title="函数代码简介"></a>函数代码简介</h4><p>大部分刷新函数都在<code>include/asm/pttable.h</code>中定义，这里就 i386 中<code>__flush_tlb()</code>的定义给予说明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __flush_tlb()</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tmpreg;</span><br><span class="line">__asm__ __volatile__(</span><br><span class="line"><span class="string">&quot;movl %%cr3, %0; # flush TLB \n&quot;</span></span><br><span class="line"><span class="string">&quot;movl %0, %%cr3; \n&quot;</span></span><br><span class="line">: <span class="string">&quot;=r&quot;</span> (tmpreg)</span><br><span class="line">:: <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>这个函数比较简单，通过对<code>CR3</code>寄存的重新装入，完成对<code>TLB</code>的刷新。</p>
<h2 id="进程的创建和执行"><a href="#进程的创建和执行" class="headerlink" title="进程的创建和执行"></a>进程的创建和执行</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>新的进程通过克隆旧的程序(当前进程)而建立。<code>fork()</code>和<code>clone()</code>(对于线程)系统调用可用来建立新的进程。这两个系统调用结束时，内核在系统的物理内存中为新的进程分配新的<code>task_struct</code>结构，同时为新进程要使用的堆栈分配物理页。Linux还会为新的进程分配新的进程标识符。然后，新<code>task_struct</code>结构的地址保存在链表中，而旧进程的<code>task_struct</code>结构内容被复制到新进程的<code>task_struct</code>结构中。</p>
<p>在克隆进程时，Linux允许两个进程共享相同的资源。可共享的资源包括文件、信号处理程序和虚拟内存等(通过继承)。当某个资源被共享时，该资源的引用计数值会增加 1，从而只有两个进程均终止时，内核才会释放这些资源。图 6.24 说明了父进程和子进程共享打开的文件。</p>
<p>系统对进程虚拟内存的克隆过程则更加巧妙些。新的<code>vm_area_struct</code>结构、新进程自己的<code>mm_struct</code>结构以及新进程的页表必须在一开始就准备好，但这时并不复制任何虚拟内存，只有当两个进程中的任意一个向虚拟内存中写入数据时才复制相应的虚拟内存；而没有写入的任何内存页均可以在两个进程之间共享。代码页实际总是可以共享的。</p>
<p>内核线程是调用<code>kernel_thread()</code>函数创建的,而<code>kernel_thread()</code>在内核态调用了<code>clone()</code>系统调用。内核线程通常没有用户地址空间，即<code>p-&gt;mm = NULL</code>，它总是直接访问内核地址空间。</p>
<p>不管是<code>fork()</code>还是<code>clone()</code>系统调用，最终都调用了内核中的<code>do_fork()</code>，其源代码在<code>kernel/fork.c</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ok, this is the main fork-routine. It copies the system process</span></span><br><span class="line"><span class="comment"> * information (task[nr]) and sets up the necessary registers. It also</span></span><br><span class="line"><span class="comment"> * copies the data segment in its entirety. The &quot;stack_start&quot; and</span></span><br><span class="line"><span class="comment"> * &quot;stack_top&quot; arguments are simply passed along to the platform</span></span><br><span class="line"><span class="comment"> * specific copy_thread() routine. Most platforms ignore stack_top.</span></span><br><span class="line"><span class="comment"> * For an example that&#x27;s using stack_top, see</span></span><br><span class="line"><span class="comment"> * arch/ia64/kernel/process.c.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_fork</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="type">unsigned</span> <span class="type">long</span> stack_start, <span class="keyword">struct</span> pt_regs *regs, <span class="type">unsigned</span> <span class="type">long</span> stack_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">vfork</span>;</span></span><br><span class="line">    retval = -EPERM;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * CLONE_PID is only allowed for the initial SMP swapper</span></span><br><span class="line"><span class="comment">    * calls</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_PID) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;pid)</span><br><span class="line">            <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    p = alloc_task_struct();</span><br><span class="line">    <span class="keyword">if</span> (!p)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    *p = *current;</span><br><span class="line">    retval = -EAGAIN;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Check if we are over our maximum process limit, but be sure to</span></span><br><span class="line"><span class="comment">    * exclude root. This is needed to make it possible for login and</span></span><br><span class="line"><span class="comment">    * friends to set the per-user process limit to something lower</span></span><br><span class="line"><span class="comment">    * than the amount of processes root is running. -- Rik</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">atomic_read</span>(&amp;p-&gt;user-&gt;processes) &gt;= p-&gt;rlim[RLIMIT_NPROC].rlim_cur &amp;&amp; !capable(CAP_SYS_ADMIN) !capable(CAP_SYS_RESOURCE))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_free; </span><br><span class="line"></span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;p-&gt;user-&gt;__count);</span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;p-&gt;user-&gt;processes);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Counter increases are protected by</span></span><br><span class="line"><span class="comment">    * the kernel lock so nr_threads can&#x27;t</span></span><br><span class="line"><span class="comment">    * increase under us (but it may decrease).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (nr_threads &gt;= max_threads)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_count;</span><br><span class="line"></span><br><span class="line">    get_exec_domain(p-&gt;exec_domain);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;binfmt &amp;&amp; p-&gt;binfmt-&gt;module)</span><br><span class="line">        __MOD_INC_USE_COUNT(p-&gt;binfmt-&gt;module);</span><br><span class="line">    p-&gt;did_exec = <span class="number">0</span>;</span><br><span class="line">    p-&gt;swappable = <span class="number">0</span>;</span><br><span class="line">    p-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">    copy_flags(clone_flags, p);</span><br><span class="line">    p-&gt;pid = get_pid(clone_flags);</span><br><span class="line">    p-&gt;run_list.next = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;run_list.prev = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;p_cptr = <span class="literal">NULL</span>;</span><br><span class="line">    init_waitqueue_head(&amp;p-&gt;wait_chldexit);</span><br><span class="line">    p-&gt;vfork_done = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">        p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">        init_completion(&amp;vfork);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_lock_init(&amp;p-&gt;alloc_lock);</span><br><span class="line">    p-&gt;sigpending = <span class="number">0</span>;</span><br><span class="line">    init_sigpending(&amp;p-&gt;pending);</span><br><span class="line">    p-&gt;it_real_value = p-&gt;it_virt_value = p-&gt;it_prof_value = <span class="number">0</span>;</span><br><span class="line">    p-&gt;it_real_incr = p-&gt;it_virt_incr = p-&gt;it_prof_incr = <span class="number">0</span>;</span><br><span class="line">    init_timer(&amp;p-&gt;real_timer);</span><br><span class="line">    p-&gt;real_timer.data = (<span class="type">unsigned</span> <span class="type">long</span>) p;</span><br><span class="line">    p-&gt;leader = <span class="number">0</span>; <span class="comment">/* session leadership doesn&#x27;t inherit */</span></span><br><span class="line">    p-&gt;tty_old_pgrp = <span class="number">0</span>;</span><br><span class="line">    p-&gt;times.tms_utime = p-&gt;times.tms_stime = <span class="number">0</span>;</span><br><span class="line">    p-&gt;times.tms_cutime = p-&gt;times.tms_cstime = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p-&gt;cpus_runnable = ~<span class="number">0UL</span>; </span><br><span class="line">    p-&gt;processor = current-&gt;processor;</span><br><span class="line">    <span class="comment">/* ?? should we just memset this ?? */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; smp_num_cpus; i++)</span><br><span class="line">        p-&gt;per_cpu_utime[i] = p-&gt;per_cpu_stime[i] = <span class="number">0</span>;</span><br><span class="line">    spin_lock_init(&amp;p-&gt;sigmask_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">    p-&gt;lock_depth = <span class="number">-1</span>; <span class="comment">/* -1 = no lock */</span></span><br><span class="line">    p-&gt;start_time = jiffies;</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;local_pages);</span><br><span class="line"></span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    <span class="comment">/* copy all the process information */</span></span><br><span class="line">    <span class="keyword">if</span> (copy_files(clone_flags, p))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup;</span><br><span class="line">    <span class="keyword">if</span> (copy_fs(clone_flags, p))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_files;</span><br><span class="line">    <span class="keyword">if</span> (copy_sighand(clone_flags, p))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, p))</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_sighand;</span><br><span class="line">    retval = copy_thread(<span class="number">0</span>, clone_flags, stack_start, stack_size, p, regs);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_mm;</span><br><span class="line">    p-&gt;semundo = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Our parent execution domain becomes current domain</span></span><br><span class="line"><span class="comment">    These must match for thread signalling to apply */</span></span><br><span class="line"></span><br><span class="line">    p-&gt;parent_exec_id = p-&gt;self_exec_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ok, now we should be set up.. */</span></span><br><span class="line">    p-&gt;swappable = <span class="number">1</span>;</span><br><span class="line">    p-&gt;exit_signal = clone_flags &amp; CSIGNAL;</span><br><span class="line">    p-&gt;pdeath_signal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * &quot;share&quot; dynamic priority between parent and child, thus the</span></span><br><span class="line"><span class="comment">    * total amount of dynamic priorities in the system doesnt change,</span></span><br><span class="line"><span class="comment">    * more scheduling fairness. This is only important in the first</span></span><br><span class="line"><span class="comment">    * timeslice, on the long run the scheduling behaviour is unchanged.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    p-&gt;counter = (current-&gt;counter + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    current-&gt;counter &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!current-&gt;counter)</span><br><span class="line">        current-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Ok, add it to the run-queues and make it</span></span><br><span class="line"><span class="comment">    * visible to the rest of the system.</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * Let it rip!</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    retval = p-&gt;pid;</span><br><span class="line">    p-&gt;tgid = retval;</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;thread_group);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Need tasklist lock for parent etc handling! */</span></span><br><span class="line">    write_lock_irq(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CLONE_PARENT and CLONE_THREAD re-use the old parent */</span></span><br><span class="line">    p-&gt;p_opptr = current-&gt;p_opptr;</span><br><span class="line">    p-&gt;p_pptr = current-&gt;p_pptr;</span><br><span class="line">    <span class="keyword">if</span> (!(clone_flags &amp; (CLONE_PARENT | CLONE_THREAD))) &#123;</span><br><span class="line">        p-&gt;p_opptr = current;</span><br><span class="line">        <span class="keyword">if</span> (!(p-&gt;ptrace &amp; PT_PTRACED))</span><br><span class="line">            p-&gt;p_pptr = current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD) &#123;</span><br><span class="line">        p-&gt;tgid = current-&gt;tgid;</span><br><span class="line">        list_add(&amp;p-&gt;thread_group, &amp;current-&gt;thread_group);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SET_LINKS(p);</span><br><span class="line">    hash_pid(p);</span><br><span class="line">    nr_threads++;</span><br><span class="line">    write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ptrace &amp; PT_PTRACED)</span><br><span class="line">        send_sig(SIGSTOP, p, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    wake_up_process(p); <span class="comment">/* do this last */</span></span><br><span class="line">    ++total_forks;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK)</span><br><span class="line">        wait_for_completion(&amp;vfork);</span><br><span class="line"></span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">bad_fork_cleanup_mm:</span><br><span class="line">    exit_mm(p);</span><br><span class="line">bad_fork_cleanup_sighand:</span><br><span class="line">    exit_sighand(p);</span><br><span class="line">bad_fork_cleanup_fs:</span><br><span class="line">    exit_fs(p); <span class="comment">/* blocking */</span></span><br><span class="line">bad_fork_cleanup_files:</span><br><span class="line">    exit_files(p); <span class="comment">/* blocking */</span></span><br><span class="line">bad_fork_cleanup:</span><br><span class="line">    put_exec_domain(p-&gt;exec_domain);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;binfmt &amp;&amp; p-&gt;binfmt-&gt;module)</span><br><span class="line">        __MOD_DEC_USE_COUNT(p-&gt;binfmt-&gt;module);</span><br><span class="line">bad_fork_cleanup_count: </span><br><span class="line">    <span class="type">atomic_dec</span>(&amp;p-&gt;user-&gt;processes);</span><br><span class="line">    free_uid(p-&gt;user);</span><br><span class="line">bad_fork_free:</span><br><span class="line">    free_task_struct(p);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管<code>fork()</code>系统调用因为传递用户堆栈和寄存器参数而与特定的平台相关，但实际上<code>do_fork()</code>所做的工作还是可移植的。下面给出对以上代码的解释。</p>
<p>给局部变量赋初值<code>-ENOMEM</code>，当分配一个新的<code>task_struc</code>结构失败时就返回这个错误值。如果在<code>clone_flags</code>中设置了<code>CLONE_PID</code>标志，就返回一个错误(-EPERM)。因为<code>CLONE_PID</code>有特殊的作用，当这个标志为 1 时，父、子进程(线程)共用一个进程号，也就是说，子进程虽然有自己的<code>task_struct</code>结构，却使用父进程的<code>pid</code>。但是，只有 0 号进程(即系统中的空线程)才允许使用这个标志。</p>
<p>调用<code>alloc_task_struct()</code>为子进程分配两个连续的物理页面，低端用来存放子进程的<code>task_struct</code>结构，高端用作其内核空间的堆栈。用结构赋值语句<code>*p = *current</code>把当前进程<code>task_struct</code>结构中的所有内容都拷贝到新进程中。稍后，子进程不该继承的域会被设置成正确的值。</p>
<p>在<code>task_struct</code>结构中有个指针<code>user</code>，用来指向一个<code>user_struct</code>结构。一个用户常常有多个进程，所以有关用户的信息并不专属于某一个进程。这样，属于同一用户的进程就可以通过指针<code>user</code>共享这些信息。显然，每个用户有且只有一个<code>user_struct</code>结构。该结构中有一个引用计数器<code>count</code>，对属于该用户的进程数量进行计数。可想而知，内核线程并不属于某个用户，所以其<code>task_struct</code>中的<code>user</code>指针为 0。每个进程<code>task_struct</code>结构中有个数组<code>rlim</code>，对该进程占用各种资源的数量作出限制，而<code>rlim[RLIMIT_NPROC]</code>就规定了该进程所属用户可以拥有的进程数量。所以，如果当前进程是一个用户进程，并且该用户拥有的进程<br>数量已经达到了规定的界限值，就不允许它<code>fork()</code>了。</p>
<p>除了检查每个用户拥有的进程数量外，接着要检查系统中的任务总数(所有用户的进程数加系统的内核线程数)是否超过了最大值<code>max_threads</code>，如果是，也不允许再创建子进程。</p>
<p>在<code>task_struct</code>有一个指针<code>exec_doman</code>，指向一个<code>exec_doman</code>结构。在<code>exec_doman</code>结构中有一个域是<code>module</code>，这是指向某个<code>module</code>结构的指针。在Linux中，一个文件系统或驱动程序都可以作为一个单独的模块进行编译，并动态地链接到内核中。</p>
<p>在<code>module</code>结构中有一个计数器<code>count</code>，用来统计几个进程需要使用这个模块。因此，<code>get_exec_domain(p-&gt;exec_domain)</code>递增模块结构<code>module</code>中的计数器。</p>
<p>另外，每个进程所执行的程序属于某种可执行映像格式，如<code>a.out</code>格式、<code>elf</code>格式，甚至<code>Java</code>虚拟机格式。对于不同格式的支持通常是通过动态安装的模块来实现的。所以，<code>task_struct</code>中有一个执行<code>Linux_binfmt</code>结构的指针<code>binfmt</code>，而<code>__MOD_INC_USE_COUNT()</code>就是对有关模块的使用计数进行递增。</p>
<p>紧接着为什么要把进程的状态设置成为<code>TASK_UNINTERRUPTIBLE</code>？这是因为后面<code>get_pid()</code>的操作必须独占，子进程可能因为一时进不了临界区而只好暂时进入睡眠状态。</p>
<p><code>copy_flags()</code>函数将<code>clone_flags</code>参数中的标志位略加补充和变换，然后写入<code>p-&gt;flags</code>。</p>
<p><code>get_pid()</code>函数根据<code>clone_flags</code>中标志位<code>ClONE_PID</code>的值，或返回父进程(当前进程)的<code>pid</code>，或返回一个新的<code>pid</code>。</p>
<p>前面在复制父进程的<code>task_struct</code>结构时把父进程的所有域都照抄过来，但实际上很多域的值必须重新赋初值，因此，后面的赋值语句就是对子进程<code>task_struct</code>结构的初始化。其中<code>start_time</code>表示进程创建的时间，而全局变量<code>jiffies</code>就是从系统初始化开始至当前的是时钟滴答数。<code>local_pages</code>表示属于该进程的局部页面形成一个双向链表，在此进行了初始化。</p>
<p><code>copy_files()</code>有条件地复制已打开文件的控制结构，也就是说，这种复制只有在<code>clone_flags</code>中的<code>CLONE_FILES</code>标志为 0 时才真正进行，否则只是共享父进程的已打开文件。当一个进程有已打开文件时，<code>task_struct</code>结构中的指针<code>files</code>指向一个<code>file_struct</code>结构，否则为 0。所有与终端设备<code>tty</code>相联系的用户进程的头 3 个标准文件<code>stdin</code>、<code>stdout</code>及<code>stderr</code>都是预先打开的，所以指针一般不为空。</p>
<p><code>copy_fs()</code>也是只有在<code>clone_flags</code>中的<code>CLONE_FS</code>标志为 0 时才加以复制。在<code>task_struct</code>中有一个指向<code>fs_struct</code>结构的指针，<code>fs_struct</code>结构中存放的是进程的根目录<code>root</code>、当前工作目录<code>pwd</code>、一个用于文件操作权限的<code>umask</code>，还有一个计数器。类似地，<code>copy_sighand()</code>也是只有在<code>CLONE_SIGHAND</code>为 0 时才真正复制父进程的信号结构，否则就共享父进程。</p>
<p>信号是进程间通信的一种手段，信号随时都可以发向一个进程，就像中断随时都可以发向一个处理器一样。进程可以为各种信号设置相应的信号处理程序，一旦进程设置了信号处理程序，其<code>task_struct</code>结构中的指针<code>sig</code>就指向<code>signal_struct</code>结构(定义于<code>include/linux/sched.h</code>)。</p>
<p>用户空间的继承是通过<code>copy_mm()</code>函数完成的。进程的<code>task_struct</code>结构中有一个指针<code>mm</code>，就指向代表着进程地址空间的<code>mm_struct</code>结构。对<code>mm_struct</code>的复制也是在<code>clone_flags</code>中的<code>CLONE_VM</code>标志为 0 时才真正进行，否则，就只是通过已经复制的指针共享父进程的用户空间。对<code>mm_struct</code>的复制不只限于这个数据结构本身，还包括了对更深层次数据结构的复制，其中最主要的是<code>vm_area_struct</code>结构和页表的复制，这是由同一文件中的<code>dum_mmap()</code>函数完成的。</p>
<p>到此为止，<code>task_struct</code>结构中的域基本复制好了，但是用于内核堆栈的内容还没有复制，这就是<code>copy_thread()</code>的责任了。<code>copy_thread()</code>函数与平台相关，定义于<code>arch/i386/kernel/process.c</code>中。<code>copy_thread()</code>实际上只复制父进程的内核空间堆栈。</p>
<p>堆栈中的内容记录了父进程通过系统调用<code>fork()</code>进入内核空间、然后又进入<code>copy_thread()</code>函数的整个历程，子进程将要循相同的路线返回，所以要把它复制给子进程。但是，如果父子进程的内核空间堆栈完全相同，那返回用户空间后就无法区分哪个是子进程了，所以，复制以后还要略作调整。</p>
<p><code>parent_exec_id</code>表示父进程的执行域，<code>p-&gt;self_exec_id</code>是本进程(子进程)的执行域，<code>swappable</code>表示本进程的页面可以被换出。<code>exit_signal</code>为本进程执行<code>exit()</code>系统调用时向父进程发出的信号，<code>death_signal</code>为要求父进程在执行<code>exit()</code>时向本进程发出的信号。</p>
<p>另外，<code>counter</code>域的值是进程的时间片(以时钟滴达为单位)，代码中将父进程的时间片分成两半，让父、子进程各有原值的一半。</p>
<p>进程创建后必须处于某一组中，这是通过<code>task_struct</code>结构中的队列头<code>thread_group</code>与父进程链接起来，形成一个进程组(注意，<code>thread</code>并不单指线程，内核代码中经常用<code>thread</code>通指所有的进程)。</p>
<p>建立进程的家族关系。先建立起子进程的祖先和双亲(当然还没有兄弟和孩子)，然后通过<code>SET_LINKS()</code>宏将子进程的<code>task_struct</code>结构插入到内核中其他进程组成的双向链表中。通过<code>hash_pid()</code>将其链入按其<code>pid</code>计算得的哈希表中。</p>
<p>最后，通过<code>wake_up_process()</code>将子进程唤醒，也就是将其挂入可执行队列等待被调度。</p>
<p>但是，还有一种特殊情况必须考虑。当参数<code>clone_flags</code>中<code>CLONE_VFORK</code>标志位为 1 时，一定要保证子进程先运行，一直到子进程通过系统调用<code>execve()</code>执行一个新的可执行程序或通过系统调用<code>exit()</code>退出系统时，才可以恢复父进程的执行，这是通过<code>wait_for_completion</code>()函数实现的。为什么要这样做呢？这是因为当<code>CLONE_VFORK</code>标志位为 1 时，就说明父、子进程通过指针共享用户空间(指向相同的<code>mm_struct</code>结构)，那也说明父进程写入用户空间的内容同时也写入了子进程的用户空间，反之亦然。在这种情况下，父子进程对堆栈区的写入是致命的了。</p>
<p>到此为止，子进程的创建已经完成，该是从内核态返回用户态的时候了。实际上，<code>fork()</code>系统调用执行之后，父子进程返回到用户空间中相同的的地址，用户进程根据<code>fork()</code>的返回值分别安排父子进程执行不同的代码。</p>
<h3 id="程序执行"><a href="#程序执行" class="headerlink" title="程序执行"></a>程序执行</h3><h4 id="ELF可执行文件"><a href="#ELF可执行文件" class="headerlink" title="ELF可执行文件"></a>ELF可执行文件</h4><p><code>ELF</code>是“可执行可连接格式”的英文缩写，<code>ELF</code>在装入内存时多一些系统开支，但是更为灵活。<code>ELF</code>可执行文件包含了可执行代码和数据，通常也称为正文和数据。这种文件中包含一些表，根据这些表中的信息，内核可组织进程的虚拟内存。另外，文件中还包含有对内存布局的定义以及起始执行的指令位置。</p>
<p>下面我们分析一个简单程序在利用编译器编译并连接之后的<code>ELF</code>文件格式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main ()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(“Hello world!\n”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1633849778.png" alt=""></p>
<p>从图可以看出，<code>ELF</code>可执行映象文件的开头是 3 个字符‘E’、‘L’和‘F’，作为这类文件的标识符。<code>e_entry</code>定义了程序装入之后起始执行指令的虚拟地址。这个简单的<code>ELF</code>映像利用两个“物理头”结构分别定义代码和数据，<code>e_phnum</code>是该文件中所包含的物理头信息个数，本例为 2。<code>e_phyoff</code>是第一个物理头结构在文件中的偏移量，而<code>e_phentsize</code>则是物理头结构的大小，这两个偏移量均从文件头开始算起。根据上述两个信息，内核可正确读取两个物理头结构中的信息。</p>
<p>物理头结构的<code>p_flags</code>字段定义了对应代码或数据的访问属性。图中第 1 个<code>p_flags</code>字段的值为<code>FP_X</code>和<code>FP_R</code>，表明该结构定义的是程序的代码；类似地，第 2 个物理头定义程序数据，并且是可读可写的。<code>p_offset</code>定义对应的代码或数据在物理头之后的偏移量。</p>
<p><code>p_vaddr</code>定义代码或数据的起始虚拟地址。<code>p_filesz</code>和<code>p_memsz</code>分别定义代码或数据在文件中的大小以及在内存中的大小。</p>
<p>对我们的简单例子，程序代码开始于两个物理头之后，而程序数据则开始于物理头之后的第 0x68533 字节处，显然，程序数据紧跟在程序代码之后。程序的代码大小为 0x68532，显得比较大，这是因为连接程序将<code>C</code>函数<code>printf</code>的代码连接到了<code>ELF</code>文件的原因。程序代码的文件大小和内存大小是一样的，而程序数据的文件大小和内存大小不一样，这是因为内存数据中，起始的 2200 字节是预先初始化的数据，初始化值来自<code>ELF</code>映象，而其后的 2048 字节则由执行代码初始化。</p>
<p>如前面所描述的，Linux利用请页技术装入程序映像。当<code>shell</code>进程利用<code>fork()</code>系统调用建立了子进程之后，子进程会调用<code>exec()</code>系统调用(实际有多种<code>exec</code>调用)，<code>exec()</code>系统调用将利用<code>ELF</code>二进制格式装载器装载<code>ELF</code>映像，当装载器检验映像是有效的<code>ELF</code>文件之后，就会将当前进程(实际就是父进程或旧进程)的可执行映像从虚拟内存中清除，同时清除任何信号处理程序并关闭所有打开的文件(把相应<code>file</code>结构中的<code>f_count</code>引用计数减 1，如果这一计数为 0，内核负责释放这一文件对象)，然后重置进程页表。</p>
<p>完成上述过程之后，只需根据<code>ELF</code>文件中的信息将映象代码和数据的起始和终止地址分配并设置相应的虚拟地址区域，修改进程页表。这时，当前进程就可以开始执行对应的<code>ELF</code>映像中的指令了。</p>
<h3 id="执行函数"><a href="#执行函数" class="headerlink" title="执行函数"></a>执行函数</h3><p>在执行<code>fork()</code>之后，同一进程有两个拷贝都在运行，也就是说，子进程具有与父进程相同的可执行程序和数据(简称映像)。但是，子进程肯定不满足于仅仅成为父进程的“影子”，因此，父进程就要调用<code>execve()</code>装入并执行子进程自己的映像。<code>execve()</code>函数必须定位可执行文件的映像，然后装入并运行它。当然开始装入的并不是实际二进制映像的完全拷贝，拷贝的完全装入是用请页装入机制(Demand Pageing Loading)逐步完成的。开始时只需要把要执行的二进制映像头装入内存，可执行代码的<code>inode</code>节点被装入当前进程的执行域中就可以执行了。</p>
<p>由于Linux文件系统采用了<code>Linux_binfmt</code>数据结构(在<code>/include/linux/binfmt.h</code>中)来支持各种文件系统，所以Linux中的<code>exec()</code>函数执行时，使用已注册的<code>linux_binfmt</code>结构就可以支持不同的二进制格式。需要指出的是<code>binux_binfmt</code>结构中嵌入了两个指向函数的指针，一个指针指向可执行代码，另一个指向了库函数；使用这两个指针是为了装入可执行代码和要使用的库。<code>linux_binfmt</code>结构描述如下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="type">long</span> *use_count;</span><br><span class="line">    <span class="type">int</span> (*load_binary)(<span class="keyword">struct</span> linux_binprm *, <span class="keyword">struct</span> pt_regs * regs);<span class="comment">/*装入二进制代码*/</span></span><br><span class="line">    <span class="type">int</span> (*load_shlib)(<span class="type">int</span> fd); <span class="comment">/*装入公用库*/</span></span><br><span class="line">    <span class="type">int</span> (*core_dump)(<span class="type">long</span> signr, <span class="keyword">struct</span> pt_regs * regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在使用这种数据结构前必须调用<code>vod binfmt_setup()</code>函数进行初始化；这个函数分别初始化了一些可执行的文件格式，如：<code>init_elf_binfmt()</code>；<code>init_aout_binfmt()</code>；<code>init_java_binfmt()</code>；<code>init_script_binfmt()</code>。</p>
<p>其实初始化就是用<code>register_binfmt(struct linux_binfmt * fmt)</code>函数把文件格式注册到系统中，即加入<code>*formats</code>所指的链中，<code>*formats</code>的定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">formats</span> =</span> (<span class="keyword">struct</span> linux_binfmt *) <span class="literal">NULL</span></span><br></pre></td></tr></table></figure></p>
<p>在使用装入函数的指针时，如果可执行文件是<code>ELF</code>格式的，则指针指向的装入函数分别是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load_elf_binary(<span class="keyword">struct</span> linux_binprm * bprm, <span class="keyword">struct</span> pt_regs * regs);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_elf_library</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure></p>
<p>所以<code>elf_format</code>文件格式说明将被定义成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> <span class="title">elf_format</span> =</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MODULE</span></span><br><span class="line">    <span class="literal">NULL</span>, <span class="literal">NULL</span>, load_elf_binary, load_elf_library, elf_core_dump</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="literal">NULL</span>, &amp;mod_use_count_, load_elf_binary, load_elf_library, elf_core_dump<span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他格式文件处理很类似，相关代码请看本节后面介绍的<code>search_binary_handler()</code>函数。</p>
<p>另外还要提的是在装入二进制时还需要用到结构<code>Linux_binprm</code>，这个结构保存着一些在装入代码时需要的信息：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];<span class="comment">/*读入文件时用的缓冲区*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> page[MAX_ARG_PAGES];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> p;</span><br><span class="line">    <span class="type">int</span> sh_bang;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> * <span class="title">inode</span>;</span><span class="comment">/*映像来自的节点*/</span></span><br><span class="line">    <span class="type">int</span> e_uid, e_gid;</span><br><span class="line">    <span class="type">int</span> argc, envc; <span class="comment">/*参数数目，环境数目*/</span></span><br><span class="line">    <span class="type">char</span> * filename; <span class="comment">/* 二进制映像的名字，也就是要执行的文件名 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> loader, exec;</span><br><span class="line">    <span class="type">int</span> dont_iput; <span class="comment">/* binfmt handler has put inode */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其他域的含义在后面的<code>do_exec()</code>代码中做进一步解释。</p>
<p>Linux所提供的系统调用名为<code>execve()</code>，可是，C语言的程序库在此系统调用的基础上向应用程序提供了一整套的库函数，包括<code>execve()</code>、<code>execlp()</code>、<code>execle()</code>、<code>execv()</code>、<code>execvp()</code>，它们之间的差异仅仅是参数的不同。下面来介绍<code>execve()</code>的实现。</p>
<p>系统调用<code>execve()</code>在内核的入口为<code>sys_execve()</code>，其代码在<code>arch/i386/kernel/process.c</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* sys_execve() executes a new program.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">asmlinkage <span class="type">int</span> <span class="title function_">sys_execve</span><span class="params">(<span class="keyword">struct</span> pt_regs regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="type">char</span> * filename;</span><br><span class="line">    filename = getname((<span class="type">char</span> *) regs.ebx);</span><br><span class="line">    error = PTR_ERR(filename);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(filename))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    error = do_execve(filename, (<span class="type">char</span> **) regs.ecx, (<span class="type">char</span> **) regs.edx, &amp;regs);</span><br><span class="line">    <span class="keyword">if</span> (error == <span class="number">0</span>)</span><br><span class="line">        current-&gt;ptrace &amp;= ~PT_DTRACE;</span><br><span class="line">    putname(filename);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<p>系统调用进入内核时，<code>regs.ebx</code>中的内容为应用程序中调用相应的库函数时的第 1 个参数，这个参数就是可执行文件的路径名。但是此时文件名实际上存放在用户空间中，所以<code>getname()</code>要把这个文件名拷贝到内核空间，在内核空间中建立起一个副本。然后，调用<code>do_execve()</code>来完成该系统调用的主体工作。<code>do_execve()</code>的代码在<code>fs/exec.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* sys_execve() executes a new program.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_execve</span><span class="params">(<span class="type">char</span> * filename, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp, <span class="keyword">struct</span> pt_regs * regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binprm</span> <span class="title">bprm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    file = open_exec(filename);</span><br><span class="line">    retval = PTR_ERR(file);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    bprm.p = PAGE_SIZE*MAX_ARG_PAGES-<span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">    <span class="built_in">memset</span>(bprm.page, <span class="number">0</span>, MAX_ARG_PAGES*<span class="keyword">sizeof</span>(bprm.page[<span class="number">0</span>]));</span><br><span class="line">    bprm.file = file;</span><br><span class="line">    bprm.filename = filename;</span><br><span class="line">    bprm.sh_bang = <span class="number">0</span>;</span><br><span class="line">    bprm.loader = <span class="number">0</span>;</span><br><span class="line">    bprm.exec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((bprm.argc = count(argv, bprm.p / <span class="keyword">sizeof</span>(<span class="type">void</span> *))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        allow_write_access(file);</span><br><span class="line">        fput(file);</span><br><span class="line">        <span class="keyword">return</span> bprm.argc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((bprm.envc = count(envp, bprm.p / <span class="keyword">sizeof</span>(<span class="type">void</span> *))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        allow_write_access(file);</span><br><span class="line">        fput(file);</span><br><span class="line">        <span class="keyword">return</span> bprm.envc;</span><br><span class="line">    &#125;</span><br><span class="line">    retval = prepare_binprm(&amp;bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    retval = copy_strings_kernel(<span class="number">1</span>, &amp;bprm.filename, &amp;bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    bprm.exec = bprm.p;</span><br><span class="line">    retval = copy_strings(bprm.envc, envp, &amp;bprm); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    retval = copy_strings(bprm.argc, argv, &amp;bprm);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    retval = search_binary_handler(&amp;bprm,regs);</span><br><span class="line">    <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="comment">/* execve success */</span></span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">out:</span><br><span class="line">    <span class="comment">/* Something went wrong, return the inode and free the argument pages*/</span></span><br><span class="line">    allow_write_access(bprm.file);</span><br><span class="line">    <span class="keyword">if</span> (bprm.file)</span><br><span class="line">        fput(bprm.file);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; MAX_ARG_PAGES ; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> * <span class="title">page</span> =</span> bprm.page[i];</span><br><span class="line">        <span class="keyword">if</span> (page)</span><br><span class="line">            __free_page(page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数<code>filename</code>、<code>argv</code>、<code>envp</code>分别代表要执行文件的文件名、命令行参数及环境串。下面对以上代码给予解释。</p>
<p>首先，将给定可执行程序的文件找到并打开，这是由<code>open_exec()</code>函数完成的。<code>open_exec()</code>返回一个<code>file</code>结构指针，代表着所读入的可执行文件的映像。</p>
<p>所有<code>Linux_binprm</code>结构中有一个页面指针数组，数组的大小为系统所允许的最大参数个数<code>MAX_ARG_PAGES</code>(定义为 32)。<code>memset()</code>函数将这个指针数组初始化为全 0。</p>
<p>对局部变量<code>bprm</code>的各个域进行初始化。其中<code>bprm.p</code>几乎等于最大参数个数所占用的空间；<code>bprm.sh_bang</code>表示可执行文件的性质，当可执行文件是一个<code>Shell</code>脚本(Shell Sript)时置为 1，此时还没有可执行<code>Shell</code>脚本，因此给其赋初值 0，还有其他两个域也赋初值 0。</p>
<p>函数<code>count()</code>对字符串数组<code>argv[]</code>中参数的个数进行计数。<code>bprm.p / sizeof(void *)</code>表示所允许参数的最大值。同样，对环境变量也要统计其个数。</p>
<p>如果<code>count()</code>小于 0，说明统计失败，则调用<code>fput()</code>把该可执行文件写回磁盘，在写之前，调用<code>allow_write_access()</code>来防止其他进程通过内存映射改变该可执行文件的内容。</p>
<p>完成了对参数和环境变量的计数之后，又调用<code>prepare_binprm()</code>对<code>bprm</code>变量做进一步的准备工作。更具体地说，就是从可执行文件中读入开头的 128 个字节到<code>Linux_binprm</code>结构的缓冲区<code>buf</code>，这是为什么呢？因为不管目标文件是<code>ELF</code>格式还是<code>a.out</code>格式，或者其他格式，在其可执行文件的开头 128 个字节中都包括了可执行文件属性的信息。</p>
<p>然后，就调用<code>copy_strings</code>把参数以及执行的环境从用户空间拷贝到内核空间的<code>bprm</code>变量中，而调用<code>copy_strings_kernel()</code>从内核空间中拷贝文件名，因为前面介绍的<code>get_name()</code>已经把文件名拷贝到内核空间了。</p>
<p>所有的准备工作已经完成，关键是调用<code>search_binary_handler()</code>函数了，请看下面对这个函数的详细介绍。</p>
<p><code>search_binary_handler()</code>函数也在<code>exec.c</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* cycle the list of binary formats handler, until one recognizes the image</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">search_binary_handler</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm,<span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> try,retval=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">fmt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* kernel module loader fixup */</span></span><br><span class="line">    <span class="comment">/* so we don&#x27;t try to load run modprobe in kernel space. */</span></span><br><span class="line">    set_fs(USER_DS);</span><br><span class="line">    <span class="keyword">for</span> (try=<span class="number">0</span>; try&lt;<span class="number">2</span>; try++) &#123;</span><br><span class="line">        read_lock(&amp;binfmt_lock);</span><br><span class="line">        <span class="keyword">for</span> (fmt = formats ; fmt ; fmt = fmt-&gt;next) &#123;</span><br><span class="line">            <span class="type">int</span> ( *fn ) ( <span class="keyword">struct</span> linux_binprm *, <span class="keyword">struct</span> pt_regs * ) = fmt-&gt;load_binary;</span><br><span class="line">            <span class="keyword">if</span> (!fn)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!try_inc_mod_count(fmt-&gt;module))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            read_unlock(&amp;binfmt_lock);</span><br><span class="line">            retval = fn(bprm, regs);</span><br><span class="line">            <span class="keyword">if</span> (retval &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                put_binfmt(fmt);</span><br><span class="line">                allow_write_access(bprm-&gt;file);</span><br><span class="line">                <span class="keyword">if</span> (bprm-&gt;file)</span><br><span class="line">                    fput(bprm-&gt;file);</span><br><span class="line">                bprm-&gt;file = <span class="literal">NULL</span>;</span><br><span class="line">                current-&gt;did_exec = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> retval;</span><br><span class="line">            &#125;</span><br><span class="line">            read_lock(&amp;binfmt_lock);</span><br><span class="line">            put_binfmt(fmt);</span><br><span class="line">            <span class="keyword">if</span> (retval != -ENOEXEC)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!bprm-&gt;file) &#123;</span><br><span class="line">                read_unlock(&amp;binfmt_lock);</span><br><span class="line">                <span class="keyword">return</span> retval;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read_unlock(&amp;binfmt_lock);</span><br><span class="line">        <span class="keyword">if</span> (retval != -ENOEXEC) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> CONFIG_KMOD</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> printable(c) (((c)==<span class="string">&#x27;\t&#x27;</span>) || ((c)==<span class="string">&#x27;\n&#x27;</span>) || (0x20&lt;=(c) &amp;&amp; (c)&lt;=0x7e))</span></span><br><span class="line">            <span class="type">char</span> modname[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">if</span> (printable(bprm-&gt;buf[<span class="number">0</span>]) &amp;&amp;</span><br><span class="line">                printable(bprm-&gt;buf[<span class="number">1</span>]) &amp;&amp;</span><br><span class="line">                printable(bprm-&gt;buf[<span class="number">2</span>]) &amp;&amp;</span><br><span class="line">                printable(bprm-&gt;buf[<span class="number">3</span>]))</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">/* -ENOEXEC */</span></span><br><span class="line">            <span class="built_in">sprintf</span> ( modname, <span class="string">&quot;binfmt-%04x&quot;</span>, * ( <span class="type">unsigned</span> <span class="type">short</span> * ) (&amp;bprm-&gt;buf[<span class="number">2</span>]));</span><br><span class="line">            request_module(modname);</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>exec.c</code>中定义了一个静态变量<code>formats</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">formats</span></span></span><br></pre></td></tr></table></figure></p>
<p>因此，<code>formats</code>就指向链表队列的头，挂在这个队列中的成员代表着各种可执行文件格式。在<code>do_exec()</code>函数的准备阶段，已经从可执行文件头部读入 128 字节存放在<code>bprm</code>的缓冲区中，而且运行所需的参数和环境变量也已收集在<code>bprm</code>中。<code>search_binary_handler()</code>函数就是逐个扫描<code>formats</code>队列，直到找到一个匹配的可执行文件格式，运行的事就交给它。如果在这个队列中没有找到相应的可执行文件格式，就要根据文件头部的信息来查找是否有为此种格式设计的可动态安装的模块，如果有，就把这个模块安装进内核，并挂入<code>formats</code>队列，然后再重新扫描。下面对具体程序给予解释。</p>
<p>程序中有两层嵌套<code>for</code>循环。内层是针对<code>formats</code>队列的每个成员，让每一个成员都去执行一下<code>load_binary()</code>函数，如果执行成功，<code>load_binary()</code>就把目标文件装入并投入运行，并返回一个正数或 0。当CPU从系统调用<code>execve()</code>返回到用户程序时，该目标文件的执行就真正开始了，也就是，子进程新的主体真正开始执行了。如果<code>load_binary()</code>返回一个负数，就说明或者在处理的过程中出错，或者没有找到相应的可执行文件格式，在后一种情况下，返回<code>-ENOEXEC</code>。</p>
<p>内层循环结束后，如果<code>load_binary()</code>执行失败后的返回值为<code>-ENOEXEC</code>，就说明队列中所有成员都不认识目标文件的格式。这时，如果内核支持动态安装模块(取决于编译选项<code>CONFIG_KMOD</code>)，就根据目标文件的第 2 和第 3 个字节生成一个<code>binfmt</code>模块，通过<code>request_module()</code>试着将相应的模块装入内核。外层的<code>for</code>循环有两次，就是为了在安装了模块以后再来试一次。</p>
<p>在<code>Linux_binfmt</code>数据结构中，有 3 个函数指针：<code>load_binary</code>、<code>load_shlib</code>以及<code>core_dump</code>，其中<code>load_binary</code>就是具体的装载程序。不同的可执行文件其装载函数也不同，如<code>a.out</code>格式的装载函数为<code>load_aout_binary()</code>，<code>ELF</code>格式的装载函数为<code>load_elf_binary()</code>，其源代码分别在<code>fs/binfmt_aout.c</code>中和<code>fs/binfmt_elf</code>中。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3cpp11%20%E7%AC%94%E8%AE%B0/" rel="prev" title="深入理解C++11：C++11新特性解析与应用 笔记">
      <i class="fa fa-chevron-left"></i> 深入理解C++11：C++11新特性解析与应用 笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/24/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90LINUX%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%20%E7%AC%94%E8%AE%B01/" rel="next" title="深入分析Linux内核源码笔记1">
      深入分析Linux内核源码笔记1 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">进程描述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.1.</span> <span class="nav-text">进程和程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.</span> <span class="nav-text">Linux中的进程概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#task-struct-%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.3.</span> <span class="nav-text">task_struct&#96;结构描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81-State"><span class="nav-number">1.3.1.</span> <span class="nav-text">进程状态(State)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.2.</span> <span class="nav-text">进程调度信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6-Identifiers"><span class="nav-number">1.3.3.</span> <span class="nav-text">标识符(Identifiers)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%89%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.4.</span> <span class="nav-text">进程通信有关信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%93%BE%E6%8E%A5%E4%BF%A1%E6%81%AF-Links"><span class="nav-number">1.3.5.</span> <span class="nav-text">进程链接信息(Links)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BF%A1%E6%81%AF-Times-and-Timers"><span class="nav-number">1.3.6.</span> <span class="nav-text">时间和定时器信息(Times and Timers)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF-File-System"><span class="nav-number">1.3.7.</span> <span class="nav-text">文件系统信息(File System)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF-Virtual-Memory"><span class="nav-number">1.3.8.</span> <span class="nav-text">虚拟内存信息(Virtual Memory)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.9.</span> <span class="nav-text">页面管理信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA-SMP-%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.10.</span> <span class="nav-text">对称多处理机(SMP)信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8C%E5%A4%84%E7%90%86%E5%99%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E7%8E%AF%E5%A2%83-%E4%B8%8A%E4%B8%8B%E6%96%87-%E4%BF%A1%E6%81%AF-Processor-Specific-Context"><span class="nav-number">1.3.11.</span> <span class="nav-text">和处理器相关的环境(上下文)信息(Processor Specific Context)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">1.3.12.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#struct-wait-queue-wait-chldexit"><span class="nav-number">1.3.12.1.</span> <span class="nav-text">struct wait_queue *wait_chldexit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#struct-rlimit-rlim-RLIM-NLIMITS"><span class="nav-number">1.3.12.2.</span> <span class="nav-text">struct rlimit rlim[RLIM_NLIMITS]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int-exit-code-exit-signal"><span class="nav-number">1.3.12.3.</span> <span class="nav-text">int exit_code exit_signal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#char-comm-16"><span class="nav-number">1.3.12.4.</span> <span class="nav-text">char comm[16]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unsigned-long-personality"><span class="nav-number">1.3.12.5.</span> <span class="nav-text">unsigned long personality</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#int-did-exec-1"><span class="nav-number">1.3.12.6.</span> <span class="nav-text">int did_exec:1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#struct-linux-binfmt-binfmt"><span class="nav-number">1.3.12.7.</span> <span class="nav-text">struct linux_binfmt *binfmt</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#task-struct-%E7%BB%93%E6%9E%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E6%94%BE"><span class="nav-number">1.4.</span> <span class="nav-text">task_struct&#96;结构在内存中的存放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%86%85%E6%A0%B8%E6%A0%88"><span class="nav-number">1.4.1.</span> <span class="nav-text">进程内核栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B-current-%E5%AE%8F"><span class="nav-number">1.4.2.</span> <span class="nav-text">当前进程(current&#96;宏)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="nav-number">1.5.</span> <span class="nav-text">进程组织方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">1.5.1.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">1.5.2.</span> <span class="nav-text">双向循环链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97"><span class="nav-number">1.5.3.</span> <span class="nav-text">运行队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97%E9%93%BE%E8%A1%A8"><span class="nav-number">1.5.4.</span> <span class="nav-text">进程的运行队列链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="nav-number">1.5.5.</span> <span class="nav-text">等待队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">通用双向链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97-1"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">等待队列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.6.</span> <span class="nav-text">内核线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9D%83%E8%83%BD"><span class="nav-number">1.7.</span> <span class="nav-text">进程的权能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5"><span class="nav-number">1.8.</span> <span class="nav-text">内核同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">1.8.1.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="nav-number">1.8.2.</span> <span class="nav-text">原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E5%9B%BE%E6%93%8D%E4%BD%9C"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">位图操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">算术操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E3%80%81%E8%AF%BB%E5%86%99%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E5%A4%A7%E8%AF%BB%E8%80%85%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">1.8.3.</span> <span class="nav-text">自旋锁、读写自旋锁和大读者自旋锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%B8%8E%E5%88%87%E6%8D%A2"><span class="nav-number">2.</span> <span class="nav-text">进程调度与切换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.1.</span> <span class="nav-text">Linux时间系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E7%A1%AC%E4%BB%B6"><span class="nav-number">2.1.1.</span> <span class="nav-text">时钟硬件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E7%9A%84%E6%97%B6%E9%97%B4%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.1.2.</span> <span class="nav-text">Linux的时间系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="nav-number">2.2.</span> <span class="nav-text">时钟中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="nav-number">2.2.1.</span> <span class="nav-text">时钟中断的产生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%AE%9E%E7%8E%B0%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">2.2.2.</span> <span class="nav-text">Linux实现时钟中断的全过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E7%BC%96%E7%A8%8B%E5%AE%9A%E6%97%B6-%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">可编程定时&#x2F;计数器的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">与时钟中断相关的函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">中断安装程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.3.</span> <span class="nav-text">系统调用返回函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E7%9A%84%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E2%80%94Schedule"><span class="nav-number">2.3.</span> <span class="nav-text">Linux的调度程序—Schedule()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">2.3.1.</span> <span class="nav-text">基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">时间片轮转调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E6%9D%83%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">优先权调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">多级反馈队列调度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA"><span class="nav-number">2.3.2.</span> <span class="nav-text">Linux进程调度时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E4%BE%9D%E6%8D%AE"><span class="nav-number">2.3.3.</span> <span class="nav-text">进程调度的依据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%A6%E7%9A%84%E8%A1%A1%E9%87%8F"><span class="nav-number">2.3.4.</span> <span class="nav-text">进程可运行程度的衡量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.5.</span> <span class="nav-text">进程调度的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="nav-number">2.4.</span> <span class="nav-text">进程切换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81"><span class="nav-number">2.4.1.</span> <span class="nav-text">硬件支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2-1"><span class="nav-number">2.4.2.</span> <span class="nav-text">进程切换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">Linux内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">Linux的内存管理概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.1.</span> <span class="nav-text">Linux虚拟内存的实现结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4"><span class="nav-number">3.1.2.</span> <span class="nav-text">内核空间和用户空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%88%B0%E7%89%A9%E7%90%86%E7%A9%BA%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">虚拟内核空间到物理空间的映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%98%A0%E5%83%8F"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">内核映像</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.1.3.</span> <span class="nav-text">虚拟内存实现机制间的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.2.</span> <span class="nav-text">Linux内存管理的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="nav-number">3.2.1.</span> <span class="nav-text">启用分页机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%88%9D%E6%AD%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">页表的初步初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6-1"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">启用分页机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%88%86%E5%B8%83"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">物理内存的初始分布</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%8E%A2%E6%B5%8B"><span class="nav-number">3.2.2.</span> <span class="nav-text">物理内存的探测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-arch-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">setup_arch()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-memory-region-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">setup_memory_region() 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy-e820-map-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">copy_e820_map() 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#add-memory-region-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">add_memory_region() 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#print-memory-map-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.2.5.</span> <span class="nav-text">print_memory_map() 函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="nav-number">3.2.3.</span> <span class="nav-text">物理内存的描述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-UMA-%E5%92%8C%E9%9D%9E%E4%B8%80%E8%87%B4%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-NUMA"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">一致存储结构(UMA)和非一致存储结构(NUMA)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2-Page-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">页面(Page)数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E5%8C%BA-Zone"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">管理区&#96;Zone</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%8A%82%E7%82%B9-Node-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.3.4.</span> <span class="nav-text">存储节点(Node)的数据结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E5%88%9D%E6%AD%A5%E5%BB%BA%E7%AB%8B"><span class="nav-number">3.2.4.</span> <span class="nav-text">页面管理机制的初步建立</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#init-bootmem-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">init_bootmem()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#free-bootmem-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">free_bootmem()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reserve-bootmem-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">reserve_bootmem()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#alloc-bootmem-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.4.4.</span> <span class="nav-text">__alloc_bootmem()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#free-all-bootmem-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.4.5.</span> <span class="nav-text">free_all_bootmem()函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-number">3.2.5.</span> <span class="nav-text">页表的建立</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#paging-init-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">paging_init() 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pagetable-init-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.5.2.</span> <span class="nav-text">pagetable_init()函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA"><span class="nav-number">3.2.6.</span> <span class="nav-text">内存管理区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#free-area-init-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.6.1.</span> <span class="nav-text">free_area_init() 函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#build-zonelists-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.6.2.</span> <span class="nav-text">build_zonelists()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mem-init-%E5%87%BD%E6%95%B0"><span class="nav-number">3.2.6.3.</span> <span class="nav-text">mem_init() 函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6"><span class="nav-number">3.3.</span> <span class="nav-text">内存的分配和回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%99%E4%BC%B4%E7%AE%97%E6%B3%95"><span class="nav-number">3.3.1.</span> <span class="nav-text">伙伴算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">数据结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E9%87%8A%E6%94%BE"><span class="nav-number">3.3.2.</span> <span class="nav-text">物理页面的分配和释放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E4%B8%80%E8%87%B4%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-NUMA-%E4%B8%AD%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">非一致存储结构(NUMA)中页面的分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-UMA-%E4%B8%AD%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">一致存储结构(UMA)中页面的分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E9%A1%B5%E9%9D%A2"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">释放页面</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Slab%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="nav-number">3.3.3.</span> <span class="nav-text">Slab分配机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Slab%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">Slab的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%93%E7%94%A8%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E6%92%A4%E9%94%80"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">专用缓冲区的建立和撤销</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">3.3.4.</span> <span class="nav-text">通用缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">3.3.5.</span> <span class="nav-text">内核空间非连续内存区的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%8C%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.5.1.</span> <span class="nav-text">非连续区的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%8C%BA%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.5.2.</span> <span class="nav-text">创建一个非连续区的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%8C%BA"><span class="nav-number">3.3.5.3.</span> <span class="nav-text">分配非连续内存区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kmalloc-%E4%B8%8Evmalloc-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.5.4.</span> <span class="nav-text">kmalloc()与vmalloc()的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.</span> <span class="nav-text">地址映射机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.1.</span> <span class="nav-text">描述虚拟空间的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MM-STRUCT%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">MM_STRUCT结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VM-AREA-STRUCT%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">VM_AREA_STRUCT结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">红黑树结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4"><span class="nav-number">3.4.2.</span> <span class="nav-text">进程的虚拟空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-number">3.4.3.</span> <span class="nav-text">内存映射</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="nav-number">3.5.</span> <span class="nav-text">请页机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E6%95%85%E9%9A%9C%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="nav-number">3.5.1.</span> <span class="nav-text">页故障的产生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%94%99%E8%AF%AF%E7%9A%84%E5%AE%9A%E4%BD%8D"><span class="nav-number">3.5.2.</span> <span class="nav-text">页错误的定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">3.5.3.</span> <span class="nav-text">进程地址空间中的缺页异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E8%B0%83%E9%A1%B5"><span class="nav-number">3.5.4.</span> <span class="nav-text">请求调页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="nav-number">3.5.5.</span> <span class="nav-text">写时复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%9C%AC%E8%8A%82%E7%9A%84%E5%87%A0%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="nav-number">3.5.6.</span> <span class="nav-text">对本节的几点说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%88%B6"><span class="nav-number">3.6.</span> <span class="nav-text">交换机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">3.6.1.</span> <span class="nav-text">交换的基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%AA%E7%A7%8D%E9%A1%B5%E9%9D%A2%E8%A2%AB%E6%8D%A2%E5%87%BA"><span class="nav-number">3.6.1.1.</span> <span class="nav-text">哪种页面被换出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BA%A4%E6%8D%A2%E5%8C%BA%E4%B8%AD%E5%AD%98%E6%94%BE%E9%A1%B5%E9%9D%A2"><span class="nav-number">3.6.1.2.</span> <span class="nav-text">如何在交换区中存放页面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E8%A2%AB%E4%BA%A4%E6%8D%A2%E5%87%BA%E7%9A%84%E9%A1%B5%E9%9D%A2"><span class="nav-number">3.6.1.3.</span> <span class="nav-text">如何选择被交换出的页面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E6%89%A7%E8%A1%8C%E9%A1%B5%E9%9D%A2%E6%8D%A2%E5%87%BA%E6%93%8D%E4%BD%9C"><span class="nav-number">3.6.1.4.</span> <span class="nav-text">何时执行页面换出操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8Bkswapd"><span class="nav-number">3.6.2.</span> <span class="nav-text">页面交换守护进程kswapd</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#kswapd"><span class="nav-number">3.6.2.1.</span> <span class="nav-text">kswapd()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kswapd-balance-%E5%87%BD%E6%95%B0"><span class="nav-number">3.6.2.2.</span> <span class="nav-text">kswapd_balance()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#try-to-free-pages"><span class="nav-number">3.6.2.3.</span> <span class="nav-text">try_to_free_pages()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="nav-number">3.6.2.4.</span> <span class="nav-text">页面置换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.6.3.</span> <span class="nav-text">交换空间的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">3.6.4.</span> <span class="nav-text">交换空间的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4"><span class="nav-number">3.6.4.1.</span> <span class="nav-text">建立交换空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4"><span class="nav-number">3.6.4.2.</span> <span class="nav-text">使用交换空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4"><span class="nav-number">3.6.4.3.</span> <span class="nav-text">分配交换空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%92%8C%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">3.7.</span> <span class="nav-text">缓存和刷新机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98"><span class="nav-number">3.7.1.</span> <span class="nav-text">Linux使用的缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">3.7.1.1.</span> <span class="nav-text">缓冲区高速缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">3.7.1.2.</span> <span class="nav-text">页面高速缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">3.7.1.3.</span> <span class="nav-text">交换高速缓存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98-1"><span class="nav-number">3.7.2.</span> <span class="nav-text">缓冲区高速缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E7%9A%84%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0"><span class="nav-number">3.7.2.1.</span> <span class="nav-text">页面缓存的详细描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%85%B3%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">3.7.2.2.</span> <span class="nav-text">有关页面缓存的函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BF%BB%E8%AF%91%E5%90%8E%E6%8F%B4%E5%AD%98%E5%82%A8%E5%99%A8-TLB"><span class="nav-number">3.7.3.</span> <span class="nav-text">翻译后援存储器(TLB)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">3.7.4.</span> <span class="nav-text">刷新机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86TLB"><span class="nav-number">3.7.4.1.</span> <span class="nav-text">软件管理TLB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6-1"><span class="nav-number">3.7.4.2.</span> <span class="nav-text">刷新机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E5%B8%B8%E5%BD%93%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98%E6%97%B6%EF%BC%8C%E8%B0%83%E7%94%A8%E9%80%82%E5%BD%93%E7%9A%84%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6%E6%9D%A5%E6%8F%8F%E8%BF%B0%E7%8A%B6%E6%80%81%E7%9A%84%E6%94%B9%E5%8F%98"><span class="nav-number">3.7.4.3.</span> <span class="nav-text">通常当地址空间的状态改变时，调用适当的刷新机制来描述状态的改变</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81%E7%AE%80%E4%BB%8B"><span class="nav-number">3.7.4.4.</span> <span class="nav-text">函数代码简介</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%89%A7%E8%A1%8C"><span class="nav-number">3.8.</span> <span class="nav-text">进程的创建和执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">3.8.1.</span> <span class="nav-text">进程的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="nav-number">3.8.2.</span> <span class="nav-text">程序执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ELF%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-number">3.8.2.1.</span> <span class="nav-text">ELF可执行文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="nav-number">3.8.3.</span> <span class="nav-text">执行函数</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
