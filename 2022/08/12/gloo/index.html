<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Gloo 是一个集合通信库。它带有许多对机器学习应用有用的集体算法。参与机器之间的数据传输是抽象的，因此可以随时使用 IP，或者在可用时使用 InifiniBand（或 RoCE）。 在后一种情况下，如果使用 InfiniBand 传输，GPUDirect可用于加速跨机器 GPU 到 GPU 的内存传输。 在适用的情况下，算法具有一种适用于系统内存缓冲区的实现，以及一种适用于 NVIDIA GPU">
<meta property="og:type" content="article">
<meta property="og:title" content="gloo介绍">
<meta property="og:url" content="http://yoursite.com/2022/08/12/gloo/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Gloo 是一个集合通信库。它带有许多对机器学习应用有用的集体算法。参与机器之间的数据传输是抽象的，因此可以随时使用 IP，或者在可用时使用 InifiniBand（或 RoCE）。 在后一种情况下，如果使用 InfiniBand 传输，GPUDirect可用于加速跨机器 GPU 到 GPU 的内存传输。 在适用的情况下，算法具有一种适用于系统内存缓冲区的实现，以及一种适用于 NVIDIA GPU">
<meta property="og:locale" content="zn_CH">
<meta property="article:published_time" content="2022-08-12T04:52:00.000Z">
<meta property="article:modified_time" content="2022-08-18T13:01:35.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="积累">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2022/08/12/gloo/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>gloo介绍 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/resume.pdf" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/08/12/gloo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          gloo介绍
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-12 12:52:00" itemprop="dateCreated datePublished" datetime="2022-08-12T12:52:00+08:00">2022-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-18 21:01:35" itemprop="dateModified" datetime="2022-08-18T21:01:35+08:00">2022-08-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Gloo 是一个集合通信库。它带有许多对机器学习应用有用的集体算法。参与机器之间的数据传输是抽象的，因此可以随时使用 IP，或者在可用时使用 InifiniBand（或 RoCE）。 在后一种情况下，如果使用 InfiniBand 传输，GPUDirect可用于加速跨机器 GPU 到 GPU 的内存传输。</p>
<p>在适用的情况下，算法具有一种适用于系统内存缓冲区的实现，以及一种适用于 NVIDIA GPU 内存缓冲区的实现。 在后一种情况下，主机和设备之间不需要复制内存； 这是由算法实现处理的。</p>
<h1 id="aligned-allocator"><a href="#aligned-allocator" class="headerlink" title="aligned_allocator"></a>aligned_allocator</h1><p>将分配的内存区域对齐到32字节。使用了using和模板。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Align buffers to 32 bytes to support vectorized code</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> kBufferAlignment = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">int</span> ALIGNMENT = kBufferAlignment&gt;</span><br><span class="line"><span class="keyword">class</span> aligned_allocator &#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(</span><br><span class="line">      !(ALIGNMENT &amp; (ALIGNMENT - <span class="number">1</span>)),</span><br><span class="line">      <span class="string">&quot;alignment must be a power of 2&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> pointer = value_type*;</span><br><span class="line">  <span class="keyword">using</span> const_pointer = <span class="type">const</span> value_type*;</span><br><span class="line">  <span class="keyword">using</span> reference = value_type&amp;;</span><br><span class="line">  <span class="keyword">using</span> const_reference = <span class="type">const</span> value_type&amp;;</span><br><span class="line">  <span class="keyword">using</span> size_type = std::<span class="type">size_t</span>;</span><br><span class="line">  <span class="keyword">using</span> difference_type = std::<span class="type">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">rebind</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> other = aligned_allocator&lt;U, ALIGNMENT&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">explicit</span> <span class="title">aligned_allocator</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">  <span class="keyword">inline</span> ~<span class="built_in">aligned_allocator</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">explicit</span> <span class="title">aligned_allocator</span><span class="params">(<span class="type">const</span> aligned_allocator&amp; a)</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> pointer <span class="title">address</span><span class="params">(reference r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> const_pointer <span class="title">address</span><span class="params">(const_reference r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> pointer <span class="title">allocate</span><span class="params">(size_type sz)</span> </span>&#123;</span><br><span class="line">    pointer p;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">posix_memalign</span>(</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(&amp;p), ALIGNMENT, <span class="built_in">sizeof</span>(T) * sz)) &#123;</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer p, size_type <span class="comment">/*sz*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>posix_memalign(void **memptr, size_t alignment, size_t size)</code>成功时会返回size字节的动态内存，并且这块内存的地址是alignment的倍数。参数alignment必须是2的幂，还是void指针的大小的倍数。返回的内存块的地址放在了memptr里面，函数返回值是0。调用失败时，没有内存会被分配，memptr的值没有被定义，返回如下错误码之一：</p>
<ul>
<li>EINVAL：参数不是2的幂，或者不是void指针的倍数。</li>
<li>ENOMEM：没有足够的内存去满足函数的请求。</li>
</ul>
<h1 id="transport"><a href="#transport" class="headerlink" title="transport"></a>transport</h1><p>一个样例是这样调用mpi的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> <span class="comment">/*argc*/</span>, <span class="type">char</span>** <span class="comment">/*argv*/</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We&#x27;ll use the TCP transport in this example</span></span><br><span class="line">  <span class="keyword">auto</span> dev = gloo::transport::tcp::<span class="built_in">CreateDevice</span>(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create Gloo context and delegate management of MPI_Init/MPI_Finalize</span></span><br><span class="line">  <span class="keyword">auto</span> context = gloo::mpi::Context::<span class="built_in">createManaged</span>();</span><br><span class="line">  context-&gt;<span class="built_in">connectFullMesh</span>(dev);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create and run simple allreduce</span></span><br><span class="line">  <span class="type">int</span> rank = context-&gt;rank;</span><br><span class="line">  <span class="function">gloo::AllreduceRing&lt;<span class="type">int</span>&gt; <span class="title">allreduce</span><span class="params">(context, &#123;&amp;rank&#125;, <span class="number">1</span>)</span></span>;</span><br><span class="line">  allreduce.<span class="built_in">run</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; rank &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>transport共有三种通信方式：ibverbs、tcp、uv。</p>
<h2 id="ibverbs"><a href="#ibverbs" class="headerlink" title="ibverbs"></a>ibverbs</h2><p>应该是RDMA方式。context应该是上下文，记录通信设备和rank相关信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ibverbs &#123;</span><br><span class="line"></span><br><span class="line">Context::<span class="built_in">Context</span>(std::shared_ptr&lt;Device&gt; device, <span class="type">int</span> rank, <span class="type">int</span> size)</span><br><span class="line">    : ::gloo::transport::<span class="built_in">Context</span>(rank, size), <span class="built_in">device_</span>(device) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Context::~<span class="built_in">Context</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;transport::Pair&gt;&amp; <span class="title">Context::createPair</span><span class="params">(<span class="type">int</span> rank)</span> </span>&#123;</span><br><span class="line">  pairs_[rank] = std::<span class="built_in">unique_ptr</span>&lt;transport::Pair&gt;(</span><br><span class="line">      <span class="keyword">new</span> ibverbs::<span class="built_in">Pair</span>(device_, <span class="built_in">getTimeout</span>()));</span><br><span class="line">  <span class="keyword">return</span> pairs_[rank];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;transport::UnboundBuffer&gt; <span class="title">Context::createUnboundBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">GLOO_THROW_INVALID_OPERATION_EXCEPTION</span>(</span><br><span class="line">      <span class="string">&quot;Unbound buffers not supported yet for ibverbs transport&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;transport::UnboundBuffer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace ibverbs</span></span><br></pre></td></tr></table></figure>
<p>这个pair是不能复制和赋值，避免出现内存问题，感觉应该是通信双方组成一个pair：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> : <span class="keyword">public</span> ::gloo::transport::Pair &#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> kMaxBuffers = <span class="number">8</span>;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> kRecvCompletionQueueCapacity = kMaxBuffers;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> kSendCompletionQueueCapacity = kMaxBuffers;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> kCompletionQueueCapacity =</span><br><span class="line">    kRecvCompletionQueueCapacity + kSendCompletionQueueCapacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The ibv_req_notify(3) function takes an argument called</span></span><br><span class="line">  <span class="comment">// &#x27;solicited_only&#x27; which makes it only trigger a notification for</span></span><br><span class="line">  <span class="comment">// work requests that are flagged as solicited. Every completion</span></span><br><span class="line">  <span class="comment">// should trigger a notification, so always pass 0.</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> kNotifyOnAnyCompletion = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Pair</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::shared_ptr&lt;Device&gt;&amp; dev,</span></span></span><br><span class="line"><span class="params"><span class="function">      std::chrono::milliseconds timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Pair</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Pair</span>(<span class="type">const</span> Pair&amp; that) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  Pair&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Pair&amp; that) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> Address&amp; <span class="title">address</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt;&amp; bytes)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setSync</span><span class="params">(<span class="type">bool</span> enable, <span class="type">bool</span> busyPoll)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;::gloo::transport::Buffer&gt;</span></span><br><span class="line"><span class="function">  <span class="title">createSendBuffer</span><span class="params">(<span class="type">int</span> slot, <span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::unique_ptr&lt;::gloo::transport::Buffer&gt;</span></span><br><span class="line"><span class="function">  <span class="title">createRecvBuffer</span><span class="params">(<span class="type">int</span> slot, <span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Send from the specified buffer to remote side of pair.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">send</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      transport::UnboundBuffer* tbuf,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">uint64_t</span> tag,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">size_t</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">size_t</span> nbytes)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Receive into the specified buffer from the remote side of pair.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">recv</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      transport::UnboundBuffer* tbuf,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">uint64_t</span> tag,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">size_t</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">size_t</span> nbytes)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleCompletionEvent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pollCompletions</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleCompletion</span><span class="params">(<span class="keyword">struct</span> ibv_wc* wc)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(Buffer* buf, <span class="type">size_t</span> offset, <span class="type">size_t</span> length, <span class="type">size_t</span> roffset)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  std::shared_ptr&lt;Device&gt; dev_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether or not this pair is running in sync mode.</span></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; sync_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether or not this pair is busy polling in sync mode.</span></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt; busyPoll_;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> std::chrono::milliseconds timeout_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该pair的完成队列处理的完成事件数。在销毁完成队列之前，需要确认这么多事件。否则，销毁将挂起。</span></span><br><span class="line">  <span class="type">int</span> completionEventsHandled_;</span><br><span class="line"></span><br><span class="line">  Address self_;</span><br><span class="line">  Address peer_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_cq</span>* cq_;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_qp</span>* qp_;</span><br><span class="line"></span><br><span class="line">  std::mutex m_;</span><br><span class="line">  std::condition_variable cv_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For us to copy the remote peer&#x27;s ibv_mr into.</span></span><br><span class="line">  std::map&lt;<span class="type">int</span>, <span class="keyword">struct</span> ibv_mr&gt; peerMemoryRegions_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这些字段存储pair的远程端可以发送到的内存区域以及pair的本地端可以从中发送的内存区域。</span></span><br><span class="line">  <span class="comment">// 注册接收缓冲区时，本地 ibv_mr 被发送到pair的远程端，并且相应的 MemoryRegion 实例保留在 mappedSendRegions_ 列表中，直到发送操作完成。</span></span><br><span class="line">  <span class="comment">// 为了允许pair的远程端发送其内存区域，我们在 mappedRecvRegions_ 中保留了固定数量的 MemoryRegion 实例。</span></span><br><span class="line">  <span class="comment">// 对于每个发布的接收工作请求，这些区域都会被循环引用。</span></span><br><span class="line">  std::map&lt;<span class="type">int</span>, std::unique_ptr&lt;MemoryRegion&gt; &gt; mappedSendRegions_;</span><br><span class="line">  std::array&lt;std::unique_ptr&lt;MemoryRegion&gt;, kMaxBuffers&gt; mappedRecvRegions_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跟踪发布和完成的请求工作请求的数量。 在发布 WR 和完成 WR 时，都需要对 mappedRecvRegions_ 数组进行索引。</span></span><br><span class="line">  <span class="type">uint64_t</span> recvPosted_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Completions on behalf of buffers need to be forwarded to those buffers.</span></span><br><span class="line">  std::map&lt;<span class="type">int</span>, Buffer*&gt; sendCompletionHandlers_;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, Buffer*&gt; recvCompletionHandlers_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">sendMemoryRegion</span><span class="params">(<span class="keyword">struct</span> ibv_mr* mr, <span class="type">int</span> slot)</span></span>;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">ibv_mr</span>* <span class="built_in">getMemoryRegion</span>(<span class="type">int</span> slot);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">postReceive</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  std::<span class="function">chrono::milliseconds <span class="title">getTimeout</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timeout_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> Address&amp; <span class="title">peer</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> peer_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::exception_ptr ex_;</span><br><span class="line">  <span class="type">bool</span> closed_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Used to signal IO exceptions from one thread and propagate onto others.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">signalIoFailure</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">checkErrorState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Buffer</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以下是逐个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">Pair::<span class="built_in">Pair</span>(</span><br><span class="line">    <span class="type">const</span> std::shared_ptr&lt;Device&gt;&amp; dev,</span><br><span class="line">    std::chrono::milliseconds timeout)</span><br><span class="line">    : <span class="built_in">dev_</span>(dev),</span><br><span class="line">      <span class="built_in">sync_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">busyPoll_</span>(<span class="literal">false</span>),</span><br><span class="line">      <span class="built_in">timeout_</span>(timeout),</span><br><span class="line">      <span class="built_in">completionEventsHandled_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">recvPosted_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">ex_</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="type">int</span> rv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create completion queue</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 必须向设备的完成通道注册此完成队列以支持异步完成处理。</span></span><br><span class="line">    <span class="comment">// Pairs 默认使用异步完成处理，因此我们调用 ibv_req_notify_cq(3) 来请求第一个通知。</span></span><br><span class="line">    cq_ = <span class="built_in">ibv_create_cq</span>(</span><br><span class="line">      dev_-&gt;context_,</span><br><span class="line">      kCompletionQueueCapacity,</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      dev_-&gt;comp_channel_,</span><br><span class="line">      <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(cq_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在完成队列 (CQ) 上请求Completion Notification（完成通知）。</span></span><br><span class="line">    rv = <span class="built_in">ibv_req_notify_cq</span>(cq_, kNotifyOnAnyCompletion);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create queue pair</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ibv_qp_init_attr</span> attr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> ibv_qp_init_attr));</span><br><span class="line">    attr.send_cq = cq_;</span><br><span class="line">    attr.recv_cq = cq_;</span><br><span class="line">    attr.cap.max_send_wr = Pair::kSendCompletionQueueCapacity;</span><br><span class="line">    attr.cap.max_recv_wr = Pair::kRecvCompletionQueueCapacity;</span><br><span class="line">    attr.cap.max_send_sge = <span class="number">1</span>;</span><br><span class="line">    attr.cap.max_recv_sge = <span class="number">1</span>;</span><br><span class="line">    attr.qp_type = IBV_QPT_RC;</span><br><span class="line">    qp_ = <span class="built_in">ibv_create_qp</span>(dev-&gt;pd_, &amp;attr);</span><br><span class="line">    <span class="comment">// 创建queue pair</span></span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(qp_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Init queue pair</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ibv_qp_attr</span> attr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> ibv_qp_attr));</span><br><span class="line">    attr.qp_state = IBV_QPS_INIT;</span><br><span class="line">    attr.pkey_index = <span class="number">0</span>;</span><br><span class="line">    attr.port_num = dev_-&gt;attr_.port;</span><br><span class="line">    attr.qp_access_flags = IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE;</span><br><span class="line">    rv = <span class="built_in">ibv_modify_qp</span>(</span><br><span class="line">        qp_,</span><br><span class="line">        &amp;attr,</span><br><span class="line">        IBV_QP_STATE | IBV_QP_PKEY_INDEX | IBV_QP_PORT | IBV_QP_ACCESS_FLAGS);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Populate local address.</span></span><br><span class="line">  <span class="comment">// The Packet Sequence Number field (PSN) is random which makes that</span></span><br><span class="line">  <span class="comment">// the remote end of this pair needs to have the contents of the</span></span><br><span class="line">  <span class="comment">// full address struct in order to connect, and vice versa.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ibv_port_attr</span> attr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> ibv_port_attr));</span><br><span class="line">    rv = <span class="built_in">ibv_query_port</span>(dev_-&gt;context_, dev_-&gt;attr_.port, &amp;attr);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line">    rv = <span class="built_in">ibv_query_gid</span>(</span><br><span class="line">        dev_-&gt;context_,</span><br><span class="line">        dev_-&gt;attr_.port,</span><br><span class="line">        dev_-&gt;attr_.index,</span><br><span class="line">        &amp;self_.addr_.ibv_gid);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line">    self_.addr_.lid = attr.lid;</span><br><span class="line">    self_.addr_.qpn = qp_-&gt;qp_num;</span><br><span class="line">    self_.addr_.psn = <span class="built_in">rand</span>() &amp; <span class="number">0xffffff</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在连接之前发布接收请求。</span></span><br><span class="line">  <span class="comment">// 每当这pair的远程端注册接收缓冲区时，就会触发它们的内存注册被发送到这一端。</span></span><br><span class="line">  <span class="comment">// 由于这些发送是单方面的，我们总是需要一整套接收工作请求。</span></span><br><span class="line">  <span class="comment">// 内存区域接收可以与常规缓冲区写入交错，因此我们主动在每个接收工作请求中包含一个内存区域。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kMaxBuffers; ++i) &#123;</span><br><span class="line">    mappedRecvRegions_[i] = <span class="built_in">make_unique</span>&lt;MemoryRegion&gt;(dev_-&gt;pd_);</span><br><span class="line">    <span class="built_in">postReceive</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pair::~<span class="built_in">Pair</span>() &#123;</span><br><span class="line">  <span class="type">int</span> rv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Acknowledge number of completion events handled by this</span></span><br><span class="line">  <span class="comment">// pair&#x27;s completion queue (also see ibv_get_cq_event(3)).</span></span><br><span class="line">  <span class="built_in">ibv_ack_cq_events</span>(cq_, completionEventsHandled_);</span><br><span class="line"></span><br><span class="line">  rv = <span class="built_in">ibv_destroy_qp</span>(qp_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  rv = <span class="built_in">ibv_destroy_cq</span>(cq_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (closed_) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add proper handling of duplicate closes T21171834</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  closed_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Address&amp; <span class="title">Pair::address</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> self_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>连接函数先获取到对方的地址，更新attr结构体，使用ibv_modify_qp函数修改RDMA通信所需的结构体。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::connect</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt;&amp; bytes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_qp_attr</span> attr;</span><br><span class="line">  <span class="type">int</span> rv;</span><br><span class="line">  <span class="built_in">checkErrorState</span>();</span><br><span class="line"></span><br><span class="line">  peer_ = <span class="built_in">Address</span>(bytes);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="built_in">sizeof</span>(attr));</span><br><span class="line">  attr.qp_state = IBV_QPS_RTR;</span><br><span class="line">  attr.path_mtu = IBV_MTU_1024;</span><br><span class="line">  attr.dest_qp_num = peer_.addr_.qpn;</span><br><span class="line">  attr.rq_psn = peer_.addr_.psn;</span><br><span class="line">  attr.max_dest_rd_atomic = <span class="number">1</span>;</span><br><span class="line">  attr.min_rnr_timer = <span class="number">20</span>;</span><br><span class="line">  attr.ah_attr.is_global = <span class="number">0</span>;</span><br><span class="line">  attr.ah_attr.dlid = peer_.addr_.lid;</span><br><span class="line">  attr.ah_attr.port_num = dev_-&gt;attr_.port;</span><br><span class="line">  <span class="keyword">if</span> (peer_.addr_.ibv_gid.global.interface_id) &#123;</span><br><span class="line">    attr.ah_attr.is_global = <span class="number">1</span>;</span><br><span class="line">    attr.ah_attr.grh.hop_limit = <span class="number">1</span>;</span><br><span class="line">    attr.ah_attr.grh.dgid = peer_.addr_.ibv_gid;</span><br><span class="line">    attr.ah_attr.grh.sgid_index = dev_-&gt;attr_.index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ibv_modify_qp()修改队列对的属性。更改的属性描述了QP的发送和接收属性。</span></span><br><span class="line">  <span class="comment">// ibv_create_qp仅仅分配了资源，要通过这个modify来让硬件进入工作状态。</span></span><br><span class="line">  <span class="comment">// Move to Ready To Receive (RTR) state</span></span><br><span class="line">  rv = <span class="built_in">ibv_modify_qp</span>(</span><br><span class="line">      qp_,</span><br><span class="line">      &amp;attr,</span><br><span class="line">      IBV_QP_STATE | IBV_QP_PATH_MTU | IBV_QP_DEST_QPN | IBV_QP_RQ_PSN |</span><br><span class="line">          IBV_QP_AV | IBV_QP_MAX_DEST_RD_ATOMIC | IBV_QP_MIN_RNR_TIMER);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;attr, <span class="number">0</span>, <span class="built_in">sizeof</span>(attr));</span><br><span class="line">  attr.qp_state = IBV_QPS_RTS;</span><br><span class="line">  attr.sq_psn = self_.addr_.psn;</span><br><span class="line">  attr.ah_attr.is_global = <span class="number">1</span>;</span><br><span class="line">  attr.timeout = <span class="number">14</span>;</span><br><span class="line">  attr.retry_cnt = <span class="number">7</span>;</span><br><span class="line">  attr.rnr_retry = <span class="number">7</span>; <span class="comment">/* infinite */</span></span><br><span class="line">  attr.max_rd_atomic = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Move to Ready To Send (RTS) state</span></span><br><span class="line">  rv = <span class="built_in">ibv_modify_qp</span>(</span><br><span class="line">      qp_,</span><br><span class="line">      &amp;attr,</span><br><span class="line">      IBV_QP_STATE | IBV_QP_TIMEOUT | IBV_QP_RETRY_CNT | IBV_QP_RNR_RETRY |</span><br><span class="line">          IBV_QP_SQ_PSN | IBV_QP_MAX_QP_RD_ATOMIC);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Switches the pair into synchronous mode.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note: busy polling is NOT optional. Currently, since all pairs</span></span><br><span class="line"><span class="comment">// share a single completion channel, busy polling is mandatory</span></span><br><span class="line"><span class="comment">// through ibv_poll_cq(3). If a use case comes up for supporting</span></span><br><span class="line"><span class="comment">// synchronous mode where the calling thread should be suspended, this</span></span><br><span class="line"><span class="comment">// can be revisited and we can add a completion channel per pair.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::setSync</span><span class="params">(<span class="type">bool</span> sync, <span class="type">bool</span> busyPoll)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">checkErrorState</span>();</span><br><span class="line">  <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">    <span class="built_in">GLOO_THROW_INVALID_OPERATION_EXCEPTION</span>(<span class="string">&quot;Can only switch to sync mode&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!busyPoll) &#123;</span><br><span class="line">    <span class="built_in">GLOO_THROW_INVALID_OPERATION_EXCEPTION</span>(</span><br><span class="line">        <span class="string">&quot;The ibverbs transport only supports busy polling in sync mode&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The notification mechanism for this pair&#x27;s completion queue is</span></span><br><span class="line">  <span class="comment">// still armed. This means the device thread will still call</span></span><br><span class="line">  <span class="comment">// handleCompletions() one more time, but this is ignored.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// No need to lock a mutex; these are atomics.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  sync_ = <span class="literal">true</span>;</span><br><span class="line">  busyPoll_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用ibv_post_send函数发送，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::sendMemoryRegion</span><span class="params">(<span class="keyword">struct</span> ibv_mr* src, <span class="type">int</span> slot)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> mr = <span class="built_in">make_unique</span>&lt;MemoryRegion&gt;(dev_-&gt;pd_, src);</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_sge</span> list = mr-&gt;<span class="built_in">sge</span>();</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_send_wr</span> wr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;wr, <span class="number">0</span>, <span class="built_in">sizeof</span>(wr));</span><br><span class="line">  wr.wr_id = slot;</span><br><span class="line">  wr.sg_list = &amp;list;</span><br><span class="line">  wr.num_sge = <span class="number">1</span>;</span><br><span class="line">  wr.opcode = IBV_WR_SEND_WITH_IMM;</span><br><span class="line">  wr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line">  wr.imm_data = slot;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工作请求被序列化并发送到驱动程序，因此它不需要在 ibv_post_send 调用后有效。</span></span><br><span class="line">  <span class="comment">// ibv_post_send和recv用于发送verb，verb承载在一个称为ibv_send_wr或者ibv_recv_wr的数据结构中，里面是verb类型和mr的相关细节。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_send_wr</span>* bad_wr = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">int</span> rv = <span class="built_in">ibv_post_send</span>(qp_, &amp;wr, &amp;bad_wr);</span><br><span class="line">  <span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">signalIoFailure</span>(<span class="built_in">GLOO_ERROR_MSG</span>(<span class="string">&quot;ibv_post_send: &quot;</span>, rv));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(mappedSendRegions_.<span class="built_in">count</span>(slot), <span class="number">0</span>);</span><br><span class="line">  mappedSendRegions_[slot] = std::<span class="built_in">move</span>(mr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先获取到锁，如果是异步的，需要检查是不是超时了；否则就等待。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">ibv_mr</span>* Pair::<span class="built_in">getMemoryRegion</span>(<span class="type">int</span> slot) &#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (sync_) &#123;</span><br><span class="line">    <span class="keyword">auto</span> it = peerMemoryRegions_.<span class="built_in">find</span>(slot);</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">while</span> (it == peerMemoryRegions_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      lock.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="built_in">pollCompletions</span>();</span><br><span class="line">      lock.<span class="built_in">lock</span>();</span><br><span class="line">      <span class="keyword">if</span> (timeout_ != kNoTimeout &amp;&amp;</span><br><span class="line">          (std::chrono::steady_clock::<span class="built_in">now</span>() - start) &gt;= timeout_) &#123;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="built_in">signalIoFailure</span>(</span><br><span class="line">            <span class="built_in">GLOO_ERROR_MSG</span>(</span><br><span class="line">                <span class="string">&quot;Timeout waiting for memory region from &quot;</span>,</span><br><span class="line">                peer_.<span class="built_in">str</span>()));</span><br><span class="line">        <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Unexpected code path&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      it = peerMemoryRegions_.<span class="built_in">find</span>(slot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;it-&gt;second;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> pred = [&amp;]&#123;</span><br><span class="line">      <span class="keyword">return</span> peerMemoryRegions_.<span class="built_in">find</span>(slot) != peerMemoryRegions_.<span class="built_in">end</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (timeout_ == kNoTimeout) &#123;</span><br><span class="line">      <span class="comment">// No timeout set. Wait for read to complete.</span></span><br><span class="line">      cv_.<span class="built_in">wait</span>(lock, pred);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> done = cv_.<span class="built_in">wait_for</span>(lock, timeout_, pred);</span><br><span class="line">      <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        <span class="built_in">signalIoFailure</span>(</span><br><span class="line">            <span class="built_in">GLOO_ERROR_MSG</span>(</span><br><span class="line">                <span class="string">&quot;Timeout waiting for memory region from &quot;</span>,</span><br><span class="line">                peer_.<span class="built_in">str</span>()));</span><br><span class="line">        <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Unexpected code path&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> it = peerMemoryRegions_.<span class="built_in">find</span>(slot);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(it != peerMemoryRegions_.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> &amp;it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::postReceive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; mr = mappedRecvRegions_[recvPosted_++ % kMaxBuffers];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_sge</span> list = mr-&gt;<span class="built_in">sge</span>();</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_recv_wr</span> wr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;wr, <span class="number">0</span>, <span class="built_in">sizeof</span>(wr));</span><br><span class="line">  wr.sg_list = &amp;list;</span><br><span class="line">  wr.num_sge = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工作请求被序列化并发送到驱动程序，因此它不需要在 ibv_post_recv 调用后有效。</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_recv_wr</span>* bad_wr = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">auto</span> rv = <span class="built_in">ibv_post_recv</span>(qp_, &amp;wr, &amp;bad_wr);</span><br><span class="line">  <span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">signalIoFailure</span>(<span class="built_in">GLOO_ERROR_MSG</span>(<span class="string">&quot;ibv_post_recv: &quot;</span>, rv));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;::gloo::transport::Buffer&gt;</span></span><br><span class="line"><span class="function"><span class="title">Pair::createSendBuffer</span><span class="params">(<span class="type">int</span> slot, <span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个buffer</span></span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(sendCompletionHandlers_.<span class="built_in">count</span>(slot), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">auto</span> buffer = <span class="keyword">new</span> <span class="built_in">Buffer</span>(<span class="keyword">this</span>, slot, ptr, size);</span><br><span class="line">  sendCompletionHandlers_[slot] = buffer;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;::gloo::transport::Buffer&gt;(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;::gloo::transport::Buffer&gt;</span></span><br><span class="line"><span class="function"><span class="title">Pair::createRecvBuffer</span><span class="params">(<span class="type">int</span> slot, <span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(recvCompletionHandlers_.<span class="built_in">count</span>(slot), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">auto</span> buffer = <span class="keyword">new</span> <span class="built_in">Buffer</span>(<span class="keyword">this</span>, slot, ptr, size);</span><br><span class="line">  recvCompletionHandlers_[slot] = buffer;</span><br><span class="line">  <span class="built_in">sendMemoryRegion</span>(buffer-&gt;mr_, buffer-&gt;slot_);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;::gloo::transport::Buffer&gt;(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send from the specified buffer to remote side of pair.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::send</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    transport::UnboundBuffer* tbuf,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span> <span class="comment">/* unused */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> <span class="comment">/* unused */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> <span class="comment">/* unused */</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">GLOO_THROW_INVALID_OPERATION_EXCEPTION</span>(</span><br><span class="line">      <span class="string">&quot;Unbound buffers not supported yet for ibverbs transport&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Receive into the specified buffer from the remote side of pair.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::recv</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    transport::UnboundBuffer* tbuf,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span> <span class="comment">/* unused */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> <span class="comment">/* unused */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> <span class="comment">/* unused */</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">GLOO_THROW_INVALID_OPERATION_EXCEPTION</span>(</span><br><span class="line">      <span class="string">&quot;Unbound buffers not supported yet for ibverbs transport&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handleCompletionEvent is called by the device thread when it</span></span><br><span class="line"><span class="comment">// received an event for this pair&#x27;s completion queue on its</span></span><br><span class="line"><span class="comment">// completion channel.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::handleCompletionEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> rv;</span><br><span class="line"></span><br><span class="line">  completionEventsHandled_++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If in sync mode, the pair was just switched and this is</span></span><br><span class="line">  <span class="comment">// the last notification from the device thread because</span></span><br><span class="line">  <span class="comment">// the notification mechanism is not re-armed below.</span></span><br><span class="line">  <span class="keyword">if</span> (sync_) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">checkErrorState</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Arm notification mechanism for completion queue.</span></span><br><span class="line">    rv = <span class="built_in">ibv_req_notify_cq</span>(cq_, kNotifyOnAnyCompletion);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now poll for work completions to drain the completion queue.</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">    <span class="built_in">pollCompletions</span>();</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> ::gloo::IoException&amp;) &#123;</span><br><span class="line">    <span class="comment">// Catch IO exceptions on the event handling thread. The exception has</span></span><br><span class="line">    <span class="comment">// already been saved and user threads signaled.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>轮询这pair的完成队列以获取工作完成情况。当从设备线程调用时，这对的互斥锁已经被获取。从用户线程调用时，不会获取互斥锁（因为只有一个线程使用这对）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::pollCompletions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::array&lt;<span class="keyword">struct</span> ibv_wc, kCompletionQueueCapacity&gt; wc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invoke handler for every work completion.</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">auto</span> nwc = <span class="built_in">ibv_poll_cq</span>(cq_, wc.<span class="built_in">size</span>(), wc.<span class="built_in">data</span>());</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_GE</span>(nwc, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle work completions</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nwc; i++) &#123;</span><br><span class="line">      <span class="built_in">checkErrorState</span>();</span><br><span class="line">      <span class="built_in">handleCompletion</span>(&amp;wc[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Break unless wc was filled</span></span><br><span class="line">    <span class="keyword">if</span> (nwc == <span class="number">0</span> || nwc &lt; wc.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::handleCompletion</span><span class="params">(<span class="keyword">struct</span> ibv_wc* wc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (wc-&gt;opcode == IBV_WC_RECV_RDMA_WITH_IMM) &#123;</span><br><span class="line">    <span class="comment">// Incoming RDMA write completed.</span></span><br><span class="line">    <span class="comment">// Slot is encoded in immediate data on receive work completion.</span></span><br><span class="line">    <span class="comment">// It is set in the Pair::send function.</span></span><br><span class="line">    <span class="keyword">auto</span> slot = wc-&gt;imm_data;</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>( wc-&gt;status, IBV_WC_SUCCESS, <span class="string">&quot;Recv for slot &quot;</span>, slot, <span class="string">&quot;: &quot;</span>, <span class="built_in">ibv_wc_status_str</span>(wc-&gt;status));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(recvCompletionHandlers_[slot] != <span class="literal">nullptr</span>);</span><br><span class="line">    recvCompletionHandlers_[slot]-&gt;<span class="built_in">handleCompletion</span>(wc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Backfill receive work requests.</span></span><br><span class="line">    <span class="built_in">postReceive</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wc-&gt;opcode == IBV_WC_RDMA_WRITE) &#123;</span><br><span class="line">    <span class="comment">// Outbound RDMA write completed.</span></span><br><span class="line">    <span class="comment">// Slot is encoded in wr_id fields on send work request. Unlike</span></span><br><span class="line">    <span class="comment">// the receive work completions, the immediate data field on send</span></span><br><span class="line">    <span class="comment">// work requests are not pass to the respective work completion.</span></span><br><span class="line">    <span class="keyword">auto</span> slot = wc-&gt;wr_id;</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>( wc-&gt;status, IBV_WC_SUCCESS, <span class="string">&quot;Send for slot &quot;</span>, slot, <span class="string">&quot;: &quot;</span>, <span class="built_in">ibv_wc_status_str</span>(wc-&gt;status));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(sendCompletionHandlers_[slot] != <span class="literal">nullptr</span>);</span><br><span class="line">    sendCompletionHandlers_[slot]-&gt;<span class="built_in">handleCompletion</span>(wc);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wc-&gt;opcode == IBV_WC_RECV) &#123;</span><br><span class="line">    <span class="comment">// 内存区域 recv 完成。</span></span><br><span class="line">    <span class="comment">// 仅由pair的远程端用于传递 ibv_mr。</span></span><br><span class="line">    <span class="comment">// 它们以 FIFO 顺序写入，因此我们可以在映射的接收区域列表中选择并使用第一个 MemoryRegion 实例。</span></span><br><span class="line">    <span class="comment">// 尝试写入此插槽的缓冲区可能正在等待该对的另一端发送其内存区域。</span></span><br><span class="line">    <span class="comment">// 锁定访问权限，然后通知任何等待的人。</span></span><br><span class="line">    <span class="comment">// 时隙在接收工作完成后立即编码为数据。 它在 Pair::sendMemoryRegion 函数中设置。</span></span><br><span class="line">    <span class="keyword">auto</span> slot = wc-&gt;imm_data;</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(</span><br><span class="line">      wc-&gt;status,</span><br><span class="line">      IBV_WC_SUCCESS,</span><br><span class="line">      <span class="string">&quot;Memory region recv for slot &quot;</span>,</span><br><span class="line">      slot,</span><br><span class="line">      <span class="string">&quot;: &quot;</span>,</span><br><span class="line">      <span class="built_in">ibv_wc_status_str</span>(wc-&gt;status));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move ibv_mr from memory region &#x27;inbox&#x27; to final slot.</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; mr = mappedRecvRegions_[recvPosted_ % kMaxBuffers];</span><br><span class="line">    peerMemoryRegions_[slot] = mr-&gt;<span class="built_in">mr</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Notify any buffer waiting for the details of its remote peer.</span></span><br><span class="line">    cv_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Backfill receive work requests.</span></span><br><span class="line">    <span class="built_in">postReceive</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wc-&gt;opcode == IBV_WC_SEND) &#123;</span><br><span class="line">    <span class="comment">// Memory region send completed.</span></span><br><span class="line">    <span class="keyword">auto</span> slot = wc-&gt;wr_id;</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(</span><br><span class="line">      wc-&gt;status,</span><br><span class="line">      IBV_WC_SUCCESS,</span><br><span class="line">      <span class="string">&quot;Memory region send for slot &quot;</span>,</span><br><span class="line">      slot,</span><br><span class="line">      <span class="string">&quot;: &quot;</span>,</span><br><span class="line">      <span class="built_in">ibv_wc_status_str</span>(wc-&gt;status));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_GT</span>(mappedSendRegions_.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(mappedSendRegions_.<span class="built_in">count</span>(slot), <span class="number">1</span>);</span><br><span class="line">    mappedSendRegions_.<span class="built_in">erase</span>(slot);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Unexpected completion with opcode: &quot;</span>, wc-&gt;opcode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用一些信息填充结构体，获取到内存区域后发送<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::send</span><span class="params">(Buffer* buffer, <span class="type">size_t</span> offset, <span class="type">size_t</span> length, <span class="type">size_t</span> roffset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_sge</span> list;</span><br><span class="line">  list.addr = (<span class="type">uint64_t</span>)buffer-&gt;ptr_ + offset;</span><br><span class="line">  list.length = length;</span><br><span class="line">  list.lkey = buffer-&gt;mr_-&gt;lkey;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_send_wr</span> wr;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;wr, <span class="number">0</span>, <span class="built_in">sizeof</span>(wr));</span><br><span class="line">  wr.wr_id = buffer-&gt;slot_;</span><br><span class="line">  wr.sg_list = &amp;list;</span><br><span class="line">  wr.num_sge = <span class="number">1</span>;</span><br><span class="line">  wr.opcode = IBV_WR_RDMA_WRITE_WITH_IMM;</span><br><span class="line">  wr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line">  wr.imm_data = buffer-&gt;slot_;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">ibv_mr</span>* peer = <span class="built_in">getMemoryRegion</span>(buffer-&gt;slot_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_NE</span>(peer, (<span class="type">const</span> <span class="keyword">struct</span> ibv_mr*)<span class="literal">nullptr</span>);</span><br><span class="line">  wr.wr.rdma.remote_addr = (<span class="type">uint64_t</span>)peer-&gt;addr + roffset;</span><br><span class="line">  wr.wr.rdma.rkey = peer-&gt;rkey;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">ibv_send_wr</span>* bad_wr;</span><br><span class="line">  <span class="keyword">auto</span> rv = <span class="built_in">ibv_post_send</span>(qp_, &amp;wr, &amp;bad_wr);</span><br><span class="line">  <span class="keyword">if</span> (rv != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">signalIoFailure</span>(<span class="built_in">GLOO_ERROR_MSG</span>(<span class="string">&quot;ibv_post_send: &quot;</span>, rv));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::signalIoFailure</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> ex = ::gloo::<span class="built_in">IoException</span>(msg);</span><br><span class="line">  <span class="keyword">if</span> (ex_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// If we haven&#x27;t seen an error yet, store the exception to throw on future calling threads.</span></span><br><span class="line">    ex_ = std::<span class="built_in">make_exception_ptr</span>(ex);</span><br><span class="line">    <span class="comment">// Loop through the completion handlers and signal that an error has</span></span><br><span class="line">    <span class="comment">// occurred.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : recvCompletionHandlers_) &#123;</span><br><span class="line">      <span class="built_in">GLOO_ENFORCE</span>(it.second != <span class="literal">nullptr</span>);</span><br><span class="line">      it.second-&gt;<span class="built_in">signalError</span>(ex_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : sendCompletionHandlers_) &#123;</span><br><span class="line">      <span class="built_in">GLOO_ENFORCE</span>(it.second != <span class="literal">nullptr</span>);</span><br><span class="line">      it.second-&gt;<span class="built_in">signalError</span>(ex_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Finally, throw the exception on this thread.</span></span><br><span class="line">  <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pair::checkErrorState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// If we previously encountered an error, rethrow here.</span></span><br><span class="line">  <span class="keyword">if</span> (ex_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    std::<span class="built_in">rethrow_exception</span>(ex_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>device 保存了设备信息，以下是构建一个设备<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Device::<span class="built_in">Device</span>(<span class="type">const</span> <span class="keyword">struct</span> attr&amp; attr, ibv_context* context)</span><br><span class="line">    : <span class="built_in">attr_</span>(attr),</span><br><span class="line">      <span class="built_in">pciBusID_</span>(<span class="built_in">infinibandToBusID</span>(attr.name)),</span><br><span class="line">      <span class="built_in">hasNvPeerMem_</span>(<span class="built_in">kernelModules</span>().<span class="built_in">count</span>(<span class="string">&quot;nv_peer_mem&quot;</span>) &gt; <span class="number">0</span>),</span><br><span class="line">      <span class="built_in">context_</span>(context) &#123;</span><br><span class="line">  <span class="type">int</span> rv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Query and store device attributes</span></span><br><span class="line">  rv = <span class="built_in">ibv_query_device</span>(context_, &amp;deviceAttr_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>, <span class="string">&quot;ibv_query_device: &quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Query and store port attributes</span></span><br><span class="line">  rv = <span class="built_in">ibv_query_port</span>(context_, attr_.port, &amp;portAttr_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_EQ</span>(rv, <span class="number">0</span>, <span class="string">&quot;ibv_query_port: &quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Protection domain</span></span><br><span class="line">  pd_ = <span class="built_in">ibv_alloc_pd</span>(context_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(pd_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Completion channel</span></span><br><span class="line">  comp_channel_ = <span class="built_in">ibv_create_comp_channel</span>(context_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(comp_channel_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start thread to poll completion queue and dispatch</span></span><br><span class="line">  <span class="comment">// completions for completed work requests.</span></span><br><span class="line">  done_ = <span class="literal">false</span>;</span><br><span class="line">  loop_.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(&amp;Device::loop, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>buffer分配一个缓冲区<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Buffer::<span class="built_in">Buffer</span>(Pair* pair, <span class="type">int</span> slot, <span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span><br><span class="line">    : ::gloo::transport::<span class="built_in">Buffer</span>(slot, ptr, size),</span><br><span class="line">      <span class="built_in">pair_</span>(pair),</span><br><span class="line">      <span class="built_in">recvCompletions_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">sendCompletions_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">sendPending_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">ex_</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// 注册一个memory region</span></span><br><span class="line">  mr_ = <span class="built_in">ibv_reg_mr</span>(</span><br><span class="line">      pair_-&gt;dev_-&gt;pd_,</span><br><span class="line">      ptr_,</span><br><span class="line">      size_,</span><br><span class="line">      IBV_ACCESS_LOCAL_WRITE | IBV_ACCESS_REMOTE_WRITE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Provide hint if the error is EFAULT and nv_peer_mem is not loaded</span></span><br><span class="line">  <span class="keyword">if</span> (mr_ == <span class="literal">nullptr</span> &amp;&amp; errno == EFAULT) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pair-&gt;dev_-&gt;hasNvPeerMem_) &#123;</span><br><span class="line">      <span class="built_in">GLOO_ENFORCE</span>(</span><br><span class="line">        mr_ != <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="string">&quot;ibv_reg_mr: &quot;</span>,</span><br><span class="line">        <span class="built_in">strerror</span>(errno),</span><br><span class="line">        <span class="string">&quot; (kernel module &#x27;nv_peer_mem&#x27; not loaded;&quot;</span></span><br><span class="line">        <span class="string">&quot; did you specify a pointer to GPU memory?)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Provide hint if the error is ENOMEM</span></span><br><span class="line">  <span class="keyword">if</span> (mr_ == <span class="literal">nullptr</span> &amp;&amp; errno == ENOMEM) &#123;</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(</span><br><span class="line">      mr_ != <span class="literal">nullptr</span>,</span><br><span class="line">      <span class="string">&quot;ibv_reg_mr: &quot;</span>,</span><br><span class="line">      <span class="built_in">strerror</span>(errno),</span><br><span class="line">      <span class="string">&quot; (did you run into the locked memory limit?)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(mr_ != <span class="literal">nullptr</span>, <span class="string">&quot;ibv_reg_mr: &quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>等待接收操作完成。根据是不是异步判断是否需要等待<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::waitRecv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果该pair处于同步模式，则当前线程负责轮询工作完成情况。</span></span><br><span class="line">  <span class="comment">// 由于单个pair可能为多个缓冲区提供服务，因此完成可能旨在用于另一个缓冲区。</span></span><br><span class="line">  <span class="keyword">auto</span> timeout = pair_-&gt;<span class="built_in">getTimeout</span>();</span><br><span class="line">  <span class="keyword">if</span> (pair_-&gt;sync_) &#123;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// We can assume a single pair is never used by more than one</span></span><br><span class="line">    <span class="comment">// thread, so there is no need to acquire the mutex here.</span></span><br><span class="line">    <span class="keyword">while</span> (recvCompletions_ == <span class="number">0</span>) &#123;</span><br><span class="line">      pair_-&gt;<span class="built_in">pollCompletions</span>();</span><br><span class="line">      <span class="keyword">if</span> (timeout != kNoTimeout &amp;&amp;</span><br><span class="line">          (std::chrono::steady_clock::<span class="built_in">now</span>() - start) &gt;= timeout) &#123;</span><br><span class="line">        pair_-&gt;<span class="built_in">signalIoFailure</span>(</span><br><span class="line">          <span class="built_in">GLOO_ERROR_MSG</span>(<span class="string">&quot;Read timeout &quot;</span>, pair_-&gt;<span class="built_in">peer</span>().<span class="built_in">str</span>()));</span><br><span class="line">        <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Unexpected code path&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    recvCompletions_--;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// The device thread will signal completion. If the completion</span></span><br><span class="line">    <span class="comment">// hasn&#x27;t arrived yet, wait until it does.</span></span><br><span class="line">    <span class="keyword">auto</span> pred = [&amp;]&#123;</span><br><span class="line">      <span class="built_in">checkErrorState</span>();</span><br><span class="line">      <span class="keyword">return</span> recvCompletions_ &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (timeout == kNoTimeout) &#123;</span><br><span class="line">      <span class="comment">// No timeout set. Wait for read to complete.</span></span><br><span class="line">      recvCv_.<span class="built_in">wait</span>(lock, pred);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">auto</span> done = recvCv_.<span class="built_in">wait_for</span>(lock, timeout, pred);</span><br><span class="line">      <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        <span class="comment">// Release the mutex before calling into the pair to avoid deadlock.</span></span><br><span class="line">        <span class="comment">// Calling signalIoFailure() will throw, so no need to</span></span><br><span class="line">        <span class="comment">// reacquire.</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        pair_-&gt;<span class="built_in">signalIoFailure</span>(</span><br><span class="line">          <span class="built_in">GLOO_ERROR_MSG</span>(<span class="string">&quot;Read timeout &quot;</span>, pair_-&gt;<span class="built_in">peer</span>().<span class="built_in">str</span>()));</span><br><span class="line">        <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Unexpected code path&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    recvCompletions_--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>等待发送操作完成。根据是不是异步判断是否需要等待<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wait for the previous send operation to finish.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::waitSend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果该pair处于同步模式，则当前线程负责轮询工作完成情况。</span></span><br><span class="line">  <span class="keyword">auto</span> timeout = pair_-&gt;<span class="built_in">getTimeout</span>();</span><br><span class="line">  <span class="keyword">if</span> (pair_-&gt;sync_) &#123;</span><br><span class="line">    <span class="comment">// We can assume a single pair is never used by more than one</span></span><br><span class="line">    <span class="comment">// thread, so there is no need to acquire the mutex here.</span></span><br><span class="line">    <span class="keyword">if</span> (sendCompletions_ == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">GLOO_ENFORCE_GT</span>(sendPending_, <span class="number">0</span>, <span class="string">&quot;No send to wait for&quot;</span>);</span><br><span class="line">      <span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">      <span class="comment">// We can assume a single pair is never used by more than one</span></span><br><span class="line">      <span class="comment">// thread, so there is no need to acquire the mutex here.</span></span><br><span class="line">      <span class="keyword">while</span> (sendCompletions_ == <span class="number">0</span>) &#123;</span><br><span class="line">        pair_-&gt;<span class="built_in">pollCompletions</span>();</span><br><span class="line">        <span class="keyword">if</span> (timeout != kNoTimeout &amp;&amp;</span><br><span class="line">            (std::chrono::steady_clock::<span class="built_in">now</span>() - start) &gt;= timeout) &#123;</span><br><span class="line">          pair_-&gt;<span class="built_in">signalIoFailure</span>(</span><br><span class="line">            <span class="built_in">GLOO_ERROR_MSG</span>(<span class="string">&quot;Send timeout &quot;</span>, pair_-&gt;<span class="built_in">peer</span>().<span class="built_in">str</span>()));</span><br><span class="line">          <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Unexpected code path&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sendCompletions_--;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// The device thread will signal completion. If the completion</span></span><br><span class="line">    <span class="comment">// hasn&#x27;t arrived yet, wait until it does.</span></span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(m_);</span><br><span class="line">    <span class="built_in">checkErrorState</span>();</span><br><span class="line">    <span class="keyword">if</span> (sendCompletions_ == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">GLOO_ENFORCE_GT</span>(sendPending_, <span class="number">0</span>, <span class="string">&quot;No send to wait for&quot;</span>);</span><br><span class="line">      <span class="keyword">auto</span> pred = [&amp;]&#123;</span><br><span class="line">        <span class="built_in">checkErrorState</span>();</span><br><span class="line">        <span class="keyword">return</span> sendCompletions_ &gt; <span class="number">0</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">if</span> (timeout == kNoTimeout) &#123;</span><br><span class="line">        <span class="comment">// No timeout set. Wait for read to complete.</span></span><br><span class="line">        sendCv_.<span class="built_in">wait</span>(lock, pred);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> done = sendCv_.<span class="built_in">wait_for</span>(lock, timeout, pred);</span><br><span class="line">        <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">          <span class="comment">// Release the mutex before calling into the pair to avoid deadlock.</span></span><br><span class="line">          <span class="comment">// Calling signalIoFailure() will throw, so no need to</span></span><br><span class="line">          <span class="comment">// reacquire.</span></span><br><span class="line">          lock.<span class="built_in">unlock</span>();</span><br><span class="line">          pair_-&gt;<span class="built_in">signalIoFailure</span>(</span><br><span class="line">            <span class="built_in">GLOO_ERROR_MSG</span>(<span class="string">&quot;Send timeout &quot;</span>, pair_-&gt;<span class="built_in">peer</span>().<span class="built_in">str</span>()));</span><br><span class="line">          <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Unexpected code path&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sendCompletions_--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Buffer::send</span><span class="params">(<span class="type">size_t</span> offset, <span class="type">size_t</span> length, <span class="type">size_t</span> roffset)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> rv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Can&#x27;t assert on roffset, since we don&#x27;t know the size of</span></span><br><span class="line">  <span class="comment">// the remote buffer. Refactor of initialization code needed</span></span><br><span class="line">  <span class="comment">// to support this.</span></span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_LE</span>(offset + length, size_);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">    <span class="built_in">checkErrorState</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (debug_) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;send &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot; bytes&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Increment number of sends in flight</span></span><br><span class="line">  sendPending_++;</span><br><span class="line"></span><br><span class="line">  pair_-&gt;<span class="built_in">send</span>(<span class="keyword">this</span>, offset, length, roffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h2><p>TCP中包含一个tls层。TLS（Transport Layer Security，安全传输层)，TLS是建立在传输层TCP协议之上的协议，服务于应用层，它的前身是SSL（Secure Socket Layer，安全套接字层），它实现了将应用层的报文进行加密后再交由TCP进行传输的功能。</p>
<h3 id="tls"><a href="#tls" class="headerlink" title="tls"></a>tls</h3><p>上下文：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Context::<span class="built_in">Context</span>(std::shared_ptr&lt;Device&gt; device, <span class="type">int</span> rank, <span class="type">int</span> size)</span><br><span class="line">    : ::gloo::transport::tcp::<span class="built_in">Context</span>(</span><br><span class="line">          std::<span class="built_in">dynamic_pointer_cast</span>&lt;::gloo::transport::tcp::Device&gt;(device),</span><br><span class="line">          rank, size),</span><br><span class="line">      <span class="built_in">ssl_ctx_</span>(<span class="built_in">create_ssl_ctx</span>(<span class="built_in">c_str_or_null</span>(device-&gt;<span class="built_in">getPKeyFile</span>()),</span><br><span class="line">                              <span class="built_in">c_str_or_null</span>(device-&gt;<span class="built_in">getCertFile</span>()),</span><br><span class="line">                              <span class="built_in">c_str_or_null</span>(device-&gt;<span class="built_in">getCAFile</span>()),</span><br><span class="line">                              <span class="built_in">c_str_or_null</span>(device-&gt;<span class="built_in">getCAPath</span>())),</span><br><span class="line">               [](::SSL_CTX *x) &#123; ::_glootls::<span class="built_in">SSL_CTX_free</span>(x); &#125;) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>真正创建ssl context的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SSL_CTX *<span class="title">Context::create_ssl_ctx</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pkey, <span class="type">const</span> <span class="type">char</span> *cert,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> <span class="type">char</span> *ca_file, <span class="type">const</span> <span class="type">char</span> *ca_path)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(pkey != <span class="literal">nullptr</span> &amp;&amp; cert != <span class="literal">nullptr</span>,</span><br><span class="line">               <span class="string">&quot;Private key and certificate location must be specified&quot;</span>);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(ca_file != <span class="literal">nullptr</span> || ca_path != <span class="literal">nullptr</span>,</span><br><span class="line">               <span class="string">&quot;CAfile or CApath must be specified&quot;</span>);</span><br><span class="line">  <span class="type">static</span> std::once_flag ssl_ctx_init_;</span><br><span class="line">  std::<span class="built_in">call_once</span>(ssl_ctx_init_, [] &#123;</span><br><span class="line">    <span class="comment">//    SSL_load_error_strings();</span></span><br><span class="line">    <span class="comment">//    SSL_library_init();</span></span><br><span class="line">    _glootls::<span class="built_in">OPENSSL_init_ssl</span>(</span><br><span class="line">        OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, <span class="literal">NULL</span>);</span><br><span class="line">    _glootls::<span class="built_in">OPENSSL_init_ssl</span>(<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  SSL_CTX *ssl_ctx = _glootls::<span class="built_in">SSL_CTX_new</span>(_glootls::<span class="built_in">TLS_method</span>());</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(ssl_ctx != <span class="literal">nullptr</span>, <span class="built_in">getSSLErrorMessage</span>());</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(</span><br><span class="line">      _glootls::<span class="built_in">SSL_CTX_set_min_proto_version</span>(ssl_ctx, TLS_MAX_VERSION) == <span class="number">1</span>,</span><br><span class="line">      <span class="built_in">getSSLErrorMessage</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// As we don&#x27;t need to handle legacy clients,</span></span><br><span class="line">  <span class="comment">// let&#x27;s remove support for legacy renegotiation:</span></span><br><span class="line">  _glootls::<span class="built_in">SSL_CTX_clear_options</span>(ssl_ctx, SSL_OP_LEGACY_SERVER_CONNECT);</span><br><span class="line"></span><br><span class="line">  _glootls::<span class="built_in">SSL_CTX_set_verify_depth</span>(ssl_ctx, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// To enforcing a higher security level, set it to 3.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 2级</span></span><br><span class="line">  <span class="comment">// 安全级别设置为 112 位安全。 因此，禁止使用短于 2048 位的 RSA、DSA 和 DH 密钥以及短于 224 位的 ECC 密钥。</span></span><br><span class="line">  <span class="comment">// 除了 1 级排除之外，还禁止使用任何使用 RC4 的密码套件。 SSL 版本 3 也是不允许的。 压缩被禁用。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Level 3</span></span><br><span class="line">  <span class="comment">// 安全级别设置为 128 位安全。</span></span><br><span class="line">  <span class="comment">// 因此，禁止使用小于 3072 位的 RSA、DSA 和 DHkey 以及小于 256 位的 ECC 密钥。</span></span><br><span class="line">  <span class="comment">// 除了 2 级排除之外，禁止使用不提供前向保密的密码套件。 不允许使用低于 1.1 的 TLS 版本。 会话票证被禁用。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> should be 3, but it doesn&#x27;t work yet :(</span></span><br><span class="line">  _glootls::<span class="built_in">SSL_CTX_set_security_level</span>(ssl_ctx, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(</span><br><span class="line">      _glootls::<span class="built_in">SSL_CTX_load_verify_locations</span>(ssl_ctx, ca_file, ca_path) == <span class="number">1</span>,</span><br><span class="line">      <span class="built_in">getSSLErrorMessage</span>());</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(_glootls::<span class="built_in">SSL_CTX_use_certificate_chain_file</span>(ssl_ctx, cert) == <span class="number">1</span>,</span><br><span class="line">               <span class="built_in">getSSLErrorMessage</span>());</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(_glootls::<span class="built_in">SSL_CTX_use_PrivateKey_file</span>(ssl_ctx, pkey,</span><br><span class="line">                                                     SSL_FILETYPE_PEM) == <span class="number">1</span>,</span><br><span class="line">               <span class="built_in">getSSLErrorMessage</span>());</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(_glootls::<span class="built_in">SSL_CTX_check_private_key</span>(ssl_ctx) == <span class="number">1</span>,</span><br><span class="line">               <span class="built_in">getSSLErrorMessage</span>());</span><br><span class="line">  <span class="comment">// SSL_VERIFY_PEER</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 服务器模式：服务器向客户端发送客户端证书请求。</span></span><br><span class="line">  <span class="comment">// 检查返回的证书（如果有）。 如果验证过程失败，TLS/SSL 握手会立即终止，并发出一条包含验证失败原因的警报消息。</span></span><br><span class="line">  <span class="comment">// 该行为可以通过附加的 SSL_VERIFY_FAIL_IF_NO_PEER_CERT 和 SSL_VERIFY_CLIENT_ONCE 标志来控制。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 客户端模式：验证服务器证书。</span></span><br><span class="line">  <span class="comment">// 如果验证过程失败，TLS/SSL 握手会立即终止，并发出一条包含验证失败原因的警报消息。</span></span><br><span class="line">  <span class="comment">// 如果没有发送服务器证书，因为使用了匿名密码，SSL_VERIFY_PEER 将被忽略。</span></span><br><span class="line">  _glootls::<span class="built_in">SSL_CTX_set_verify</span>(ssl_ctx,</span><br><span class="line">                               SSL_VERIFY_PEER |</span><br><span class="line">                                   SSL_VERIFY_FAIL_IF_NO_PEER_CERT |</span><br><span class="line">                                   SSL_VERIFY_CLIENT_ONCE,</span><br><span class="line">                               <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">return</span> ssl_ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="正经tcp"><a href="#正经tcp" class="headerlink" title="正经tcp"></a>正经tcp</h3><p>同样需要创建通信对，缓冲区，以及处理通信等。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;transport::Pair&gt;&amp; <span class="title">Context::createPair</span><span class="params">(<span class="type">int</span> rank)</span> </span>&#123;</span><br><span class="line">  pairs_[rank] = std::<span class="built_in">unique_ptr</span>&lt;transport::Pair&gt;(</span><br><span class="line">      <span class="keyword">new</span> tcp::<span class="built_in">Pair</span>(<span class="keyword">this</span>, device_.<span class="built_in">get</span>(), rank, <span class="built_in">getTimeout</span>()));</span><br><span class="line">  <span class="keyword">return</span> pairs_[rank];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;transport::UnboundBuffer&gt; <span class="title">Context::createUnboundBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> buf = <span class="keyword">new</span> tcp::<span class="built_in">UnboundBuffer</span>(<span class="built_in">shared_from_this</span>(), ptr, size);</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;transport::UnboundBuffer&gt;(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是处理通信的过程<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Context::recvFromAny</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    UnboundBuffer* buf,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span> slot,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> nbytes,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::vector&lt;<span class="type">int</span>&gt; srcRanks)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// Find rank of pair we can attempt a recv from</span></span><br><span class="line">    <span class="keyword">auto</span> rank = <span class="built_in">recvFromAnyFindRank</span>(buf, slot, offset, nbytes, srcRanks);</span><br><span class="line">    <span class="keyword">if</span> (rank == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Try recv from returned rank</span></span><br><span class="line">    <span class="keyword">auto</span> ptr = pairs_[rank].<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(ptr != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">auto</span> pair = <span class="built_in">dynamic_cast</span>&lt;Pair*&gt;(ptr);</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE</span>(pair != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (pair-&gt;<span class="built_in">tryRecv</span>(buf, slot, offset, nbytes)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Context::recvFromAnyFindRank</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    UnboundBuffer* buf,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span> slot,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> nbytes,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; srcRanks)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// See if there is a remote pending send that can fulfill this recv.</span></span><br><span class="line">  <span class="keyword">auto</span> it = <span class="built_in">findPendingOperations</span>(slot);</span><br><span class="line">  <span class="keyword">if</span> (it != pendingOperations_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; pendingOperation = *it;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Out of all remote pending sends, find the first one</span></span><br><span class="line">    <span class="comment">// that exists in the set of eligible ranks.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> rank : pendingOperation.<span class="built_in">getSendList</span>()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> srcRank : srcRanks) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rank == srcRank) &#123;</span><br><span class="line">          <span class="comment">// 我们找到了一个可以满足这个recv的等级。</span></span><br><span class="line">          <span class="comment">// 此函数的调用者将尝试进行recv，如果该远程挂起发送操作仍然存在，它将删除它。</span></span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No candidates; register buffer for recv</span></span><br><span class="line">  pendingRecv_[slot].<span class="built_in">emplace_back</span>(</span><br><span class="line">      buf-&gt;<span class="built_in">getWeakNonOwningPtr</span>(),</span><br><span class="line">      offset,</span><br><span class="line">      nbytes,</span><br><span class="line">      std::<span class="built_in">unordered_set</span>&lt;<span class="type">int</span>&gt;(srcRanks.<span class="built_in">begin</span>(), srcRanks.<span class="built_in">end</span>()));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allowed to be called only by ContextMutator::findRecvFromAny,</span></span><br><span class="line"><span class="comment">// where the context lock is already held.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Context::findRecvFromAny</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">uint64_t</span> slot,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> rank,</span></span></span><br><span class="line"><span class="params"><span class="function">    WeakNonOwningPtr&lt;UnboundBuffer&gt;* buf,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span>* offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span>* nbytes)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// See if there is a pending recv for this slot.</span></span><br><span class="line">  <span class="keyword">auto</span> pit = pendingRecv_.<span class="built_in">find</span>(slot);</span><br><span class="line">  <span class="keyword">if</span> (pit != pendingRecv_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; recvs = pit-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over available buffers to find a match.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> rit = recvs.<span class="built_in">begin</span>(); rit != recvs.<span class="built_in">end</span>(); rit++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span>&amp; ranks = std::<span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(*rit);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果此对等点的rank在此插槽的可接受rank集中，我们可以继续并将缓冲区返回到 recv 中。</span></span><br><span class="line">      <span class="keyword">if</span> (ranks.<span class="built_in">count</span>(rank) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Capture values to return.</span></span><br><span class="line">        *buf = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(*rit);</span><br><span class="line">        *offset = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(*rit);</span><br><span class="line">        *nbytes = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(*rit);</span><br><span class="line">        <span class="comment">// Cleanup.</span></span><br><span class="line">        recvs.<span class="built_in">erase</span>(rit);</span><br><span class="line">        <span class="keyword">if</span> (recvs.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">          pendingRecv_.<span class="built_in">erase</span>(pit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>其中包含了epoll的使用方法，单独拿出来</p>
<p>创建一个epoll<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Loop::<span class="built_in">Loop</span>() &#123;</span><br><span class="line">  fd_ = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_NE</span>(fd_, <span class="number">-1</span>, <span class="string">&quot;epoll_create: &quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">  loop_.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(&amp;Loop::run, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>epoll_ctl，用于操作epoll函数所生成的实例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys / epoll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> epoll_ctl（<span class="type">int</span> epfd，<span class="type">int</span> op，<span class="type">int</span> fd，<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> * <span class="title">event</span>）;</span></span><br></pre></td></tr></table></figure><br>该系统调用对文件描述符epfd引用的epoll实例执行控制操作。它要求操作op对目标文件描述符fd执行。op参数的有效值为：</p>
<ul>
<li>EPOLL_CTL_ADD：在文件描述符epfd所引用的epoll实例上注册目标文件描述符fd，并将事件事件与内部文件链接到fd。</li>
<li>EPOLL_CTL_MOD：更改与目标文件描述符fd相关联的事件事件。</li>
<li>EPOLL_CTL_DEL：从epfd引用的epoll实例中删除（注销）目标文件描述符fd。该事件将被忽略，并且可以为NULL。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Loop::registerDescriptor</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> events, Handler* h)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">  ev.events = events;</span><br><span class="line">  ev.data.ptr = h;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> rv = <span class="built_in">epoll_ctl</span>(fd_, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">  <span class="keyword">if</span> (rv == <span class="number">-1</span> &amp;&amp; errno == EEXIST) &#123;</span><br><span class="line">    rv = <span class="built_in">epoll_ctl</span>(fd_, EPOLL_CTL_MOD, fd, &amp;ev);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_NE</span>(rv, <span class="number">-1</span>, <span class="string">&quot;epoll_ctl: &quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Loop::unregisterDescriptor</span><span class="params">(<span class="type">int</span> fd, Handler* h)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> rv = <span class="built_in">epoll_ctl</span>(fd_, EPOLL_CTL_DEL, fd, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_NE</span>(rv, <span class="number">-1</span>, <span class="string">&quot;epoll_ctl: &quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for loop to tick before returning, to make sure the handler</span></span><br><span class="line">  <span class="comment">// for this fd is not called once this function returns.</span></span><br><span class="line">  <span class="keyword">if</span> (std::this_thread::<span class="built_in">get_id</span>() != loop_-&gt;<span class="built_in">get_id</span>()) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_)</span></span>;</span><br><span class="line">    cv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">    <span class="built_in">TSAN_ANNOTATE_HAPPENS_AFTER</span>(h);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等待某个epoll完成<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Loop::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::array&lt;<span class="keyword">struct</span> epoll_event, capacity_&gt; events;</span><br><span class="line">  <span class="type">int</span> nfds;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!done_) &#123;</span><br><span class="line">    <span class="comment">// Wakeup everyone waiting for a loop tick to finish.</span></span><br><span class="line">    cv_.<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for something to happen</span></span><br><span class="line">    nfds = <span class="built_in">epoll_wait</span>(fd_, events.<span class="built_in">data</span>(), events.<span class="built_in">size</span>(), <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nfds == <span class="number">-1</span> &amp;&amp; errno == EINTR) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_NE</span>(nfds, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; i++) &#123;</span><br><span class="line">      Handler* h = <span class="built_in">reinterpret_cast</span>&lt;Handler*&gt;(events[i].data.ptr);</span><br><span class="line">      h-&gt;<span class="built_in">handleEvents</span>(events[i].events);</span><br><span class="line">      <span class="built_in">TSAN_ANNOTATE_HAPPENS_BEFORE</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="mpi"><a href="#mpi" class="headerlink" title="mpi"></a>mpi</h1><p>mpi相关的通信操作，MPIScope应该是MPI的上下文什么的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;MPIScope&gt; <span class="title">getMPIScope</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> std::once_flag once;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use weak pointer so that the initializer is destructed when the</span></span><br><span class="line">  <span class="comment">// last context referring to it is destructed, not when statics</span></span><br><span class="line">  <span class="comment">// are destructed on program termination.</span></span><br><span class="line">  <span class="type">static</span> std::weak_ptr&lt;MPIScope&gt; wptr;</span><br><span class="line">  std::shared_ptr&lt;MPIScope&gt; sptr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create MPIScope only once</span></span><br><span class="line">  std::<span class="built_in">call_once</span>(once, [&amp;]() &#123;</span><br><span class="line">      sptr = std::<span class="built_in">make_shared</span>&lt;MPIScope&gt;();</span><br><span class="line">      wptr = sptr;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create shared_ptr&lt;MPIScope&gt; from weak_ptr</span></span><br><span class="line">  sptr = wptr.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(sptr, <span class="string">&quot;Cannot create MPI context after MPI_Finalize()&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> sptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回MPI上下文（通信域）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Context&gt; <span class="title">Context::createManaged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> mpiScope = <span class="built_in">getMPIScope</span>();</span><br><span class="line">  <span class="keyword">auto</span> context = std::<span class="built_in">make_shared</span>&lt;Context&gt;(MPI_COMM_WORLD);</span><br><span class="line">  context-&gt;mpiScope_ = std::<span class="built_in">move</span>(mpiScope);</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Context::<span class="built_in">Context</span>(<span class="type">const</span> MPI_Comm&amp; comm)</span><br><span class="line">    : ::gloo::<span class="built_in">Context</span>(<span class="built_in">MPICommRank</span>(comm), <span class="built_in">MPICommSize</span>(comm)) &#123;</span><br><span class="line">  <span class="keyword">auto</span> error = <span class="built_in">MPI_Comm_dup</span>(comm, &amp;comm_);</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(error == MPI_SUCCESS, <span class="string">&quot;MPI_Comm_dup: &quot;</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Context::~<span class="built_in">Context</span>() &#123;</span><br><span class="line">  <span class="built_in">MPI_Comm_free</span>(&amp;comm_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为本进程和其他进程创建通信对pair和缓冲区<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Context::connectFullMesh</span><span class="params">(std::shared_ptr&lt;transport::Device&gt;&amp; dev)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::vector&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">addresses</span>(size);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> maxLength = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> rv;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create pair to connect to every other node in the collective</span></span><br><span class="line">  <span class="keyword">auto</span> transportContext = dev-&gt;<span class="built_in">createContext</span>(rank, size);</span><br><span class="line">  transportContext-&gt;<span class="built_in">setTimeout</span>(<span class="built_in">getTimeout</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == rank) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; pair = transportContext-&gt;<span class="built_in">createPair</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store address for pair for this rank</span></span><br><span class="line">    <span class="keyword">auto</span> address = pair-&gt;<span class="built_in">address</span>().<span class="built_in">bytes</span>();</span><br><span class="line">    maxLength = std::<span class="built_in">max</span>(maxLength, address.<span class="built_in">size</span>());</span><br><span class="line">    addresses[i] = std::<span class="built_in">move</span>(address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Agree on maximum length so we can prepare buffers</span></span><br><span class="line">  rv = <span class="built_in">MPI_Allreduce</span>(</span><br><span class="line">    MPI_IN_PLACE, &amp;maxLength, <span class="number">1</span>, MPI_UNSIGNED_LONG, MPI_MAX, comm_);</span><br><span class="line">  <span class="keyword">if</span> (rv != MPI_SUCCESS) &#123;</span><br><span class="line">    <span class="built_in">GLOO_THROW_IO_EXCEPTION</span>(<span class="string">&quot;MPI_Allreduce: &quot;</span>, rv);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prepare input and output</span></span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">in</span><span class="params">(size * maxLength)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">out</span><span class="params">(size * size * maxLength)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == rank) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; address = addresses[i];</span><br><span class="line">    <span class="built_in">memcpy</span>(in.<span class="built_in">data</span>() + (i * maxLength), address.<span class="built_in">data</span>(), address.<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allgather to collect all addresses of all pairs</span></span><br><span class="line">  rv = <span class="built_in">MPI_Allgather</span>(</span><br><span class="line">    in.<span class="built_in">data</span>(), in.<span class="built_in">size</span>(), MPI_BYTE, out.<span class="built_in">data</span>(), in.<span class="built_in">size</span>(), MPI_BYTE, comm_);</span><br><span class="line">  <span class="keyword">if</span> (rv != MPI_SUCCESS) &#123;</span><br><span class="line">    <span class="built_in">GLOO_THROW_IO_EXCEPTION</span>(<span class="string">&quot;MPI_Allgather: &quot;</span>, rv);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Connect every pair</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == rank) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> offset = (rank + i * size) * maxLength;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">address</span><span class="params">(maxLength)</span></span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(address.<span class="built_in">data</span>(), out.<span class="built_in">data</span>() + offset, maxLength);</span><br><span class="line">    transportContext-&gt;<span class="built_in">getPair</span>(i)-&gt;<span class="built_in">connect</span>(address);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  device_ = dev;</span><br><span class="line">  transportContext_ = std::<span class="built_in">move</span>(transportContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><p>首先得获取本进程的左方和右方<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Helper for ring algorithms</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;transport::Pair&gt;&amp; <span class="title">Algorithm::getLeftPair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> rank = (context_-&gt;size + context_-&gt;rank - <span class="number">1</span>) % context_-&gt;size;</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(context_-&gt;<span class="built_in">getPair</span>(rank), <span class="string">&quot;pair missing (index &quot;</span>, rank, <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> context_-&gt;<span class="built_in">getPair</span>(rank);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper for ring algorithms</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;transport::Pair&gt;&amp; <span class="title">Algorithm::getRightPair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> rank = (context_-&gt;rank + <span class="number">1</span>) % context_-&gt;size;</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(context_-&gt;<span class="built_in">getPair</span>(rank), <span class="string">&quot;pair missing (index &quot;</span>, rank, <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> context_-&gt;<span class="built_in">getPair</span>(rank);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>gloo支持reduce的一些操作，对于一些reduce时自定义的方法，gloo也做了兼容：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type of reduction function.</span></span><br><span class="line"><span class="comment">// 如果reduce类型是内置类型之一，则算法实现可以使用加速版本（如果可用）。</span></span><br><span class="line"><span class="comment">// 例如，如果将 ReductionType 等于 SUM 的 ReductionFunction 传递给 CUDA 感知的 Allreduce，它知道它可以使用 NCCL 实现而不是指定的函数。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ReductionType</span> &#123;</span><br><span class="line">  SUM = <span class="number">1</span>,</span><br><span class="line">  PRODUCT = <span class="number">2</span>,</span><br><span class="line">  MAX = <span class="number">3</span>,</span><br><span class="line">  MIN = <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use larger number so we have plenty of room to add built-ins</span></span><br><span class="line">  CUSTOM = <span class="number">1000</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReductionFunction</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Function = <span class="built_in">void</span>(T*, <span class="type">const</span> T*, <span class="type">size_t</span> n);</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> ReductionFunction&lt;T&gt;* sum;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> ReductionFunction&lt;T&gt;* product;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> ReductionFunction&lt;T&gt;* min;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> ReductionFunction&lt;T&gt;* max;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">ReductionFunction</span>(ReductionType type, Function* fn)</span><br><span class="line">      : <span class="built_in">type_</span>(type), <span class="built_in">fn_</span>(fn) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ReductionType <span class="title">type</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">call</span><span class="params">(T* x, <span class="type">const</span> T* y, <span class="type">size_t</span> n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fn_</span>(x, y, n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ReductionType type_;</span><br><span class="line">  Function* fn_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> ReductionFunction&lt;T&gt;* ReductionFunction&lt;T&gt;::sum =</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">ReductionFunction</span>&lt;T&gt;(SUM, &amp;::gloo::sum&lt;T&gt;);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> ReductionFunction&lt;T&gt;* ReductionFunction&lt;T&gt;::product =</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">ReductionFunction</span>&lt;T&gt;(PRODUCT, &amp;::gloo::product&lt;T&gt;);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> ReductionFunction&lt;T&gt;* ReductionFunction&lt;T&gt;::min =</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">ReductionFunction</span>&lt;T&gt;(MIN, &amp;::gloo::min&lt;T&gt;);</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> ReductionFunction&lt;T&gt;* ReductionFunction&lt;T&gt;::max =</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">ReductionFunction</span>&lt;T&gt;(MAX, &amp;::gloo::max&lt;T&gt;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Local operation.</span></span><br><span class="line"><span class="comment">// If an algorithm uses multiple local pointers, local operations</span></span><br><span class="line"><span class="comment">// can be used for local reduction, broadcast, gathering, etc.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LocalOp</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">LocalOp</span>() <span class="built_in">noexcept</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">runAsync</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">wait</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Synchronous run is equal to asynchronous run and wait.</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">runAsync</span>();</span><br><span class="line">    <span class="built_in">wait</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="allgather"><a href="#allgather" class="headerlink" title="allgather"></a>allgather</h1><p>AllgatherRing 类似于 MPI_Allgather，所有进程都从所有其他进程接收缓冲区（inPtrs）。 调用者需要传递一个预先分配的接收缓冲区 (outPtr)，其大小等于[ 上下文大小 x 发送缓冲区的总大小] (inPtrs)，其中 rank = k 的进程的发送缓冲区将被写入 outPtr[k <em> 输入缓冲区数量 </em> count] 连续。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AllgatherRing</span> : <span class="keyword">public</span> Algorithm &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">AllgatherRing</span>(</span><br><span class="line">      <span class="type">const</span> std::shared_ptr&lt;Context&gt;&amp; context,</span><br><span class="line">      <span class="type">const</span> std::vector&lt;<span class="type">const</span> T*&gt;&amp; inPtrs,</span><br><span class="line">      T* outPtr,</span><br><span class="line">      <span class="type">int</span> count)</span><br><span class="line">      : <span class="built_in">Algorithm</span>(context),</span><br><span class="line">        <span class="built_in">inPtrs_</span>(inPtrs),</span><br><span class="line">        <span class="built_in">outPtr_</span>(outPtr),</span><br><span class="line">        <span class="built_in">count_</span>(count),</span><br><span class="line">        <span class="built_in">bytes_</span>(count * <span class="built_in">sizeof</span>(T)),</span><br><span class="line">        <span class="built_in">inputStride_</span>(count_ * inPtrs_.<span class="built_in">size</span>()),</span><br><span class="line">        <span class="built_in">leftPair_</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getLeftPair</span>()),</span><br><span class="line">        <span class="built_in">rightPair_</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getRightPair</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> slot = <span class="keyword">this</span>-&gt;context_-&gt;<span class="built_in">nextSlot</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;transport::Buffer&gt;</span></span><br><span class="line">    sendDataBuf_ = rightPair_-&gt;<span class="built_in">createSendBuffer</span>(</span><br><span class="line">        slot, outPtr_, inPtrs_.<span class="built_in">size</span>() * context_-&gt;size * bytes_);</span><br><span class="line">    recvDataBuf_ = leftPair_-&gt;<span class="built_in">createRecvBuffer</span>(</span><br><span class="line">        slot, outPtr_, inPtrs_.<span class="built_in">size</span>() * context_-&gt;size * bytes_);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> notificationSlot = <span class="keyword">this</span>-&gt;context_-&gt;<span class="built_in">nextSlot</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::unique_ptr&lt;transport::Buffer&gt;</span></span><br><span class="line">    sendNotificationBuf_ =</span><br><span class="line">        leftPair_-&gt;<span class="built_in">createSendBuffer</span>(notificationSlot, &amp;dummy_, <span class="built_in">sizeof</span>(dummy_));</span><br><span class="line">    recvNotificationBuf_ =</span><br><span class="line">        rightPair_-&gt;<span class="built_in">createRecvBuffer</span>(notificationSlot, &amp;dummy_, <span class="built_in">sizeof</span>(dummy_));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>真正运行的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> rank = <span class="keyword">this</span>-&gt;contextRank_;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> numRounds = <span class="keyword">this</span>-&gt;contextSize_ - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy local buffers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inPtrs_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(outPtr_ + rank * inputStride_ + i * count_, inPtrs_[i], bytes_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We send input buffers in order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inPtrs_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="comment">// We start every iteration by sending local buffer.</span></span><br><span class="line">      <span class="type">int</span> inRank = rank;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 10个进程，就是9个round。1号进程，第一个round给0，第二个round给9，第三个round给8...</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> round = <span class="number">0</span>; round &lt; numRounds; round++) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> sendOffset = inRank * inputStride_ + i * count_;</span><br><span class="line">        sendDataBuf_-&gt;<span class="built_in">send</span>(</span><br><span class="line">            sendOffset * <span class="built_in">sizeof</span>(T), bytes_, sendOffset * <span class="built_in">sizeof</span>(T));</span><br><span class="line">        recvDataBuf_-&gt;<span class="built_in">waitRecv</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Nodes receive data from the left node in every round and forward it</span></span><br><span class="line">        <span class="comment">// to the right node.</span></span><br><span class="line">        inRank = (numRounds - round + rank) % <span class="keyword">this</span>-&gt;contextSize_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Send notification to node on the left that this node is ready for an</span></span><br><span class="line">        <span class="comment">// inbox write.</span></span><br><span class="line">        sendNotificationBuf_-&gt;<span class="built_in">send</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait for notification from node on the right.</span></span><br><span class="line">        recvNotificationBuf_-&gt;<span class="built_in">waitRecv</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> std::vector&lt;<span class="type">const</span> T*&gt; inPtrs_;</span><br><span class="line">  T* outPtr_;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> count_;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> bytes_;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> inputStride_;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;transport::Pair&gt;&amp; leftPair_;</span><br><span class="line">  std::unique_ptr&lt;transport::Pair&gt;&amp; rightPair_;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;transport::Buffer&gt; sendDataBuf_;</span><br><span class="line">  std::unique_ptr&lt;transport::Buffer&gt; recvDataBuf_;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> dummy_;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;transport::Buffer&gt; sendNotificationBuf_;</span><br><span class="line">  std::unique_ptr&lt;transport::Buffer&gt; recvNotificationBuf_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="一般的allgather"><a href="#一般的allgather" class="headerlink" title="一般的allgather"></a>一般的allgather</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">allgather</span><span class="params">(AllgatherOptions&amp; opts)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  transport::UnboundBuffer* in = opts.in.<span class="built_in">get</span>();</span><br><span class="line">  transport::UnboundBuffer* out = opts.out.<span class="built_in">get</span>();</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kAllgatherSlotPrefix, opts.tag);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> recvRank = (context-&gt;size + context-&gt;rank - <span class="number">1</span>) % context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> sendRank = (context-&gt;size + context-&gt;rank + <span class="number">1</span>) % context-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> inBytes = out-&gt;size / context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> outBytes = out-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the input buffer is specified, this is NOT an in place operation,</span></span><br><span class="line">  <span class="comment">// and the output buffer needs to be primed with the input.</span></span><br><span class="line">  <span class="keyword">if</span> (in != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out-&gt;ptr) + context-&gt;rank * in-&gt;size,</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(in-&gt;ptr),</span><br><span class="line">        in-&gt;size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Short circuit if there is only a single process.</span></span><br><span class="line">  <span class="keyword">if</span> (context-&gt;size == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The chunk size may not be divisible by 2; use dynamic lookup.</span></span><br><span class="line">  std::array&lt;<span class="type">size_t</span>, 2&gt; chunkSize;</span><br><span class="line">  chunkSize[<span class="number">0</span>] = inBytes / <span class="number">2</span>;</span><br><span class="line">  chunkSize[<span class="number">1</span>] = inBytes - chunkSize[<span class="number">0</span>];</span><br><span class="line">  std::array&lt;<span class="type">size_t</span>, 2&gt; chunkOffset;</span><br><span class="line">  chunkOffset[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  chunkOffset[<span class="number">1</span>] = chunkSize[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 10个进程，1号进程</span></span><br><span class="line">  <span class="comment">// send to 2，recv from 0</span></span><br><span class="line">  <span class="comment">// send seg = 11 11 10 10 9 9 8 8 ...</span></span><br><span class="line">  <span class="comment">// recv seg = 10 10 9  9  8 8 7 7 ...</span></span><br><span class="line">  <span class="comment">// i &amp; 0x1  = 0  1  0  1  0 1 0 1 ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; (context-&gt;size - <span class="number">1</span>) * <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> sendSegment = context-&gt;size + context-&gt;rank - (i / <span class="number">2</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> recvSegment = sendSegment - <span class="number">1</span>;</span><br><span class="line">    <span class="type">size_t</span> sendOffset =</span><br><span class="line">        ((sendSegment * inBytes) + chunkOffset[i &amp; <span class="number">0x1</span>]) % outBytes;</span><br><span class="line">    <span class="type">size_t</span> recvOffset =</span><br><span class="line">        ((recvSegment * inBytes) + chunkOffset[i &amp; <span class="number">0x1</span>]) % outBytes;</span><br><span class="line">    <span class="type">size_t</span> size = chunkSize[i &amp; <span class="number">0x1</span>];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      out-&gt;<span class="built_in">send</span>(sendRank, slot, sendOffset, size);</span><br><span class="line">      out-&gt;<span class="built_in">recv</span>(recvRank, slot, recvOffset, size);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for pending operations to complete to synchronize with the</span></span><br><span class="line">    <span class="comment">// previous iteration. Because we kick off two operations before</span></span><br><span class="line">    <span class="comment">// getting here we always wait for the next-to-last operation.</span></span><br><span class="line">    out-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">    out-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">    out-&gt;<span class="built_in">send</span>(sendRank, slot, sendOffset, size);</span><br><span class="line">    out-&gt;<span class="built_in">recv</span>(recvRank, slot, recvOffset, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for completes</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    out-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">    out-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="allgatherv"><a href="#allgatherv" class="headerlink" title="allgatherv"></a>allgatherv</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">allgatherv</span><span class="params">(AllgathervOptions&amp; opts)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  transport::UnboundBuffer* in = opts.in.<span class="built_in">get</span>();</span><br><span class="line">  transport::UnboundBuffer* out = opts.out.<span class="built_in">get</span>();</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kAllgatherSlotPrefix, opts.tag);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> recvRank = (context-&gt;size + context-&gt;rank - <span class="number">1</span>) % context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> sendRank = (context-&gt;size + context-&gt;rank + <span class="number">1</span>) % context-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算每个进程对应的长度和偏移</span></span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt; byteCounts;</span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt; byteOffsets;</span><br><span class="line">  byteCounts.<span class="built_in">reserve</span>(context-&gt;size);</span><br><span class="line">  byteOffsets.<span class="built_in">reserve</span>(context-&gt;size);</span><br><span class="line">  <span class="type">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elements : opts.elements) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> bytes = elements * opts.elementSize;</span><br><span class="line">    byteCounts.<span class="built_in">push_back</span>(bytes);</span><br><span class="line">    byteOffsets.<span class="built_in">push_back</span>(offset);</span><br><span class="line">    offset += bytes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果指定了输入缓冲区，则需要准备输出缓冲区。</span></span><br><span class="line">  <span class="keyword">if</span> (in != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">GLOO_ENFORCE_EQ</span>(byteCounts[context-&gt;rank], in-&gt;size);</span><br><span class="line">    <span class="keyword">if</span> (byteCounts[context-&gt;rank] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out-&gt;ptr) + byteOffsets[context-&gt;rank],</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(in-&gt;ptr),</span><br><span class="line">          in-&gt;size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Short circuit if there is only a single process.</span></span><br><span class="line">  <span class="keyword">if</span> (context-&gt;size == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> baseIndex = context-&gt;size + context-&gt;rank;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; context-&gt;size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> sendIndex = (baseIndex - i) % context-&gt;size;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> recvIndex = (baseIndex - i - <span class="number">1</span>) % context-&gt;size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      out-&gt;<span class="built_in">send</span>(sendRank, slot, byteOffsets[sendIndex], byteCounts[sendIndex]);</span><br><span class="line">      out-&gt;<span class="built_in">recv</span>(recvRank, slot, byteOffsets[recvIndex], byteCounts[recvIndex]);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for previous operations to complete before kicking off new ones.</span></span><br><span class="line">    out-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">    out-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">    out-&gt;<span class="built_in">send</span>(sendRank, slot, byteOffsets[sendIndex], byteCounts[sendIndex]);</span><br><span class="line">    out-&gt;<span class="built_in">recv</span>(recvRank, slot, byteOffsets[recvIndex], byteCounts[recvIndex]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for final operations to complete.</span></span><br><span class="line">  out-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">  out-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="allreduce"><a href="#allreduce" class="headerlink" title="allreduce"></a>allreduce</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> BufferVector = std::vector&lt;std::unique_ptr&lt;transport::UnboundBuffer&gt;&gt;;</span><br><span class="line"><span class="keyword">using</span> ReductionFunction = AllreduceOptions::Func;</span><br><span class="line"><span class="keyword">using</span> ReduceRangeFunction = std::function&lt;<span class="built_in">void</span>(<span class="type">size_t</span>, <span class="type">size_t</span>)&gt;;</span><br><span class="line"><span class="keyword">using</span> BroadcastRangeFunction = std::function&lt;<span class="built_in">void</span>(<span class="type">size_t</span>, <span class="type">size_t</span>)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Forward declaration of ring algorithm implementation.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ring</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> detail::AllreduceOptionsImpl&amp; opts,</span></span></span><br><span class="line"><span class="params"><span class="function">    ReduceRangeFunction reduceInputs,</span></span></span><br><span class="line"><span class="params"><span class="function">    BroadcastRangeFunction broadcastOutputs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Forward declaration of bcube algorithm implementation.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bcube</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> detail::AllreduceOptionsImpl&amp; opts,</span></span></span><br><span class="line"><span class="params"><span class="function">    ReduceRangeFunction reduceInputs,</span></span></span><br><span class="line"><span class="params"><span class="function">    BroadcastRangeFunction broadcastOutputs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReductionFunction type describes the function to use for element wise reduction.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Its arguments are:</span></span><br><span class="line"><span class="comment">//   1. non-const output pointer</span></span><br><span class="line"><span class="comment">//   2. const input pointer 1 (may be equal to 1)</span></span><br><span class="line"><span class="comment">//   3. const input pointer 2 (may be equal to 1)</span></span><br><span class="line"><span class="comment">//   4. number of elements to reduce.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 请注意，此函数不是严格类型的，并且采用 void 指针。</span></span><br><span class="line"><span class="comment">// 这样做是为了避免需要模板化选项类和模板化算法实现。</span></span><br><span class="line"><span class="comment">// 我们发现这对编译时间和代码大小的增加几乎没有任何价值。s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回计算输入的局部reduce并将其存储在这些缓冲区中给定范围的输出中的函数。</span></span><br><span class="line"><span class="comment">// 这是在向邻居发送区域或reduce从邻居接收的区域之前完成的。</span></span><br><span class="line"><span class="function">ReduceRangeFunction <span class="title">genLocalReduceFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> BufferVector&amp; in, <span class="comment">// UnboundBuffer的unique_ptr的vector</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> BufferVector&amp; out,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> elementSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    ReductionFunction fn)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据传进来的buffer长度，执行reduce函数</span></span><br><span class="line">  <span class="keyword">if</span> (in.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (in.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [&amp;in, &amp;out](<span class="type">size_t</span> offset, <span class="type">size_t</span> length) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(in[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">            length);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> [&amp;in, &amp;out, elementSize, fn](<span class="type">size_t</span> offset, <span class="type">size_t</span> length) &#123;</span><br><span class="line">        <span class="built_in">fn</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">           <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(in[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">           <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(in[<span class="number">1</span>]-&gt;ptr) + offset,</span><br><span class="line">           length / elementSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">2</span>; i &lt; in.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">          <span class="built_in">fn</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">             <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">             <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(in[i]-&gt;ptr) + offset,</span><br><span class="line">             length / elementSize);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [&amp;out, elementSize, fn](<span class="type">size_t</span> offset, <span class="type">size_t</span> length) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; out.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">fn</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">           <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">           <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(out[i]-&gt;ptr) + offset,</span><br><span class="line">           length / elementSize);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对缓冲区中给定范围的输出执行本地广播的函数。 这是在接收到每个全局reduce的块之后执行的。</span></span><br><span class="line"><span class="function">BroadcastRangeFunction <span class="title">genLocalBroadcastFunction</span><span class="params">(<span class="type">const</span> BufferVector&amp; out)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [&amp;out](<span class="type">size_t</span> offset, <span class="type">size_t</span> length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; out.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out[i]-&gt;ptr) + offset,</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + offset,</span><br><span class="line">          length);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allreduce</span><span class="params">(<span class="type">const</span> detail::AllreduceOptionsImpl&amp; opts)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (opts.elements == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  <span class="type">const</span> std::vector&lt;std::unique_ptr&lt;transport::UnboundBuffer&gt;&gt;&amp; in = opts.in;</span><br><span class="line">  <span class="type">const</span> std::vector&lt;std::unique_ptr&lt;transport::UnboundBuffer&gt;&gt;&amp; out = opts.out;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kAllreduceSlotPrefix, opts.tag);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化本地归约和广播功能。</span></span><br><span class="line">  <span class="comment">// 请注意，如果仅指定单个输出并将其用作输入和输出，则这些是无操作的。</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> reduceInputs =</span><br><span class="line">      <span class="built_in">genLocalReduceFunction</span>(in, out, opts.elementSize, opts.reduce);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> broadcastOutputs = <span class="built_in">genLocalBroadcastFunction</span>(out);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Simple circuit if there is only a single process.</span></span><br><span class="line">  <span class="keyword">if</span> (context-&gt;size == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">reduceInputs</span>(<span class="number">0</span>, totalBytes);</span><br><span class="line">    <span class="built_in">broadcastOutputs</span>(<span class="number">0</span>, totalBytes);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (opts.algorithm) &#123;</span><br><span class="line">    <span class="keyword">case</span> detail::AllreduceOptionsImpl::UNSPECIFIED:</span><br><span class="line">    <span class="keyword">case</span> detail::AllreduceOptionsImpl::RING:</span><br><span class="line">      <span class="built_in">ring</span>(opts, reduceInputs, broadcastOutputs);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> detail::AllreduceOptionsImpl::BCUBE:</span><br><span class="line">      <span class="built_in">bcube</span>(opts, reduceInputs, broadcastOutputs);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">GLOO_ENFORCE</span>(<span class="literal">false</span>, <span class="string">&quot;Algorithm not handled.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="allreduce的ring方法"><a href="#allreduce的ring方法" class="headerlink" title="allreduce的ring方法"></a>allreduce的ring方法</h2><p>给定的输入被分成与进程数相等的块数。 算法完成后，每个进程按顺序托管一个reduction输出块（rank 0 具有块 0，rank 1 具有块 1，等等）。由于输入可能不能被进程数整除，因此最终的块有部分输出或可能为空。</p>
<p>当一个块沿着环传递并且包含连续更多rank的reduction时，我们必须在为该块执行 I/O 和计算接收到的块和本地块之间的reduction之间交替。为了避免这种交替模式，我们将一个块分成多个段（&gt; = 2），并确保我们有一个段在运行，同时计算另一个段的reduction。</p>
<p>段大小有一个上限，以最大限度地减少内存使用并避免不良的缓存行为。 这意味着在处理非常大的输入时，每个块可能有很多段。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ring</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> detail::AllreduceOptionsImpl&amp; opts,</span></span></span><br><span class="line"><span class="params"><span class="function">    ReduceRangeFunction reduceInputs,</span></span></span><br><span class="line"><span class="params"><span class="function">    BroadcastRangeFunction broadcastOutputs)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  <span class="type">const</span> std::vector&lt;std::unique_ptr&lt;transport::UnboundBuffer&gt;&gt;&amp; out = opts.out;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kAllreduceSlotPrefix, opts.tag);</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> totalBytes = opts.elements * opts.elementSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: context-&gt;size &gt; 1</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> recvRank = (context-&gt;size + context-&gt;rank + <span class="number">1</span>) % context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> sendRank = (context-&gt;size + context-&gt;rank - <span class="number">1</span>) % context-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保最大段大小是元素大小的倍数。</span></span><br><span class="line">  <span class="comment">// 否则，在向上舍入到元素大小的最接近倍数后，段大小可能会超过最大段大小。</span></span><br><span class="line">  <span class="comment">// 例如，如果maxSegmentSize = 10，而elementSize = 4，则向上取整后：segmentSize = 12；</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> maxSegmentBytes = opts.elementSize *</span><br><span class="line">      std::<span class="built_in">max</span>((<span class="type">size_t</span>)<span class="number">1</span>, opts.maxSegmentSize / opts.elementSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute how many segments make up the input buffer.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 向上舍入到上下文大小的最接近的倍数，以便每个进程有相同数量的段，并且跨进程的执行是对称的。</span></span><br><span class="line">  <span class="comment">// 最小值是上下文大小的两倍，因为下面的算法将发送/接收一个段与计算另一个段的reduction。</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> numSegments = <span class="built_in">roundUp</span>(</span><br><span class="line">      std::<span class="built_in">max</span>(</span><br><span class="line">          (totalBytes + (maxSegmentBytes - <span class="number">1</span>)) / maxSegmentBytes,</span><br><span class="line">          (<span class="type">size_t</span>)context-&gt;size * <span class="number">2</span>),</span><br><span class="line">      (<span class="type">size_t</span>)context-&gt;size);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> numSegmentsPerRank = numSegments / context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> segmentBytes =</span><br><span class="line">      <span class="built_in">roundUp</span>((totalBytes + numSegments - <span class="number">1</span>) / numSegments, opts.elementSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate scratch space to hold two chunks</span></span><br><span class="line">  <span class="function">std::unique_ptr&lt;<span class="type">uint8_t</span>[]&gt; <span class="title">tmpAllocation</span><span class="params">(<span class="keyword">new</span> <span class="type">uint8_t</span>[segmentBytes * <span class="number">2</span>])</span></span>;</span><br><span class="line">  std::unique_ptr&lt;transport::UnboundBuffer&gt; tmpBuffer =</span><br><span class="line">      context-&gt;<span class="built_in">createUnboundBuffer</span>(tmpAllocation.<span class="built_in">get</span>(), segmentBytes * <span class="number">2</span>);</span><br><span class="line">  transport::UnboundBuffer* tmp = tmpBuffer.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用动态查找临时缓冲区中的块偏移量。</span></span><br><span class="line">  <span class="comment">// 在进行两个操作时，我们需要两个偏移量。 可以使用循环计数器对它们进行索引。</span></span><br><span class="line">  std::array&lt;<span class="type">size_t</span>, 2&gt; segmentOffset;</span><br><span class="line">  segmentOffset[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  segmentOffset[<span class="number">1</span>] = segmentBytes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算在reduce/scatter为给定迭代发送和接收的段的偏移量和长度。</span></span><br><span class="line">  <span class="keyword">auto</span> computeReduceScatterOffsets = [&amp;](<span class="type">size_t</span> i) &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      <span class="type">size_t</span> sendOffset;</span><br><span class="line">      <span class="type">size_t</span> recvOffset;</span><br><span class="line">      <span class="type">ssize_t</span> sendLength;</span><br><span class="line">      <span class="type">ssize_t</span> recvLength;</span><br><span class="line">    &#125; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算要发送的段索引（到 rank-1）和要接收的段索引（从 rank+1）。</span></span><br><span class="line">    <span class="comment">// 乘以块中的字节数以获得偏移量。</span></span><br><span class="line">    <span class="comment">// 允许偏移量超出范围（&gt;=totalBytes），计算相关长度时会考虑到这一点。</span></span><br><span class="line">    result.sendOffset =</span><br><span class="line">        ((((context-&gt;rank + <span class="number">1</span>) * numSegmentsPerRank) + i) * segmentBytes) %</span><br><span class="line">        (numSegments * segmentBytes);</span><br><span class="line">    result.recvOffset =</span><br><span class="line">        ((((context-&gt;rank + <span class="number">2</span>) * numSegmentsPerRank) + i) * segmentBytes) %</span><br><span class="line">        (numSegments * segmentBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the segment is entirely in range, the following statement is</span></span><br><span class="line">    <span class="comment">// equal to segmentBytes. If it isn&#x27;t, it will be less, or even</span></span><br><span class="line">    <span class="comment">// negative. This is why the ssize_t typecasts are needed.</span></span><br><span class="line">    result.sendLength = std::<span class="built_in">min</span>(</span><br><span class="line">        (<span class="type">ssize_t</span>)segmentBytes,</span><br><span class="line">        (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)result.sendOffset);</span><br><span class="line">    result.recvLength = std::<span class="built_in">min</span>(</span><br><span class="line">        (<span class="type">ssize_t</span>)segmentBytes,</span><br><span class="line">        (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)result.recvOffset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ring reduce/scatter.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 迭代次数计算如下：</span></span><br><span class="line">  <span class="comment">// - 使用 `numSegments` 作为段的总数，</span></span><br><span class="line">  <span class="comment">// - 减去 `numSegmentsPerRank`，因为最终段包含部分结果，在此阶段不得转发。</span></span><br><span class="line">  <span class="comment">// - 添加 2，因为我们通过管道发送和接收操作（我们在迭代 0 和 1 上发出发送/接收操作并等待它们在迭代 2 和 3 上完成）。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; (numSegments - numSegmentsPerRank + <span class="number">2</span>); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">// 计算两次迭代前的发送和接收偏移量和长度。</span></span><br><span class="line">      <span class="comment">// 需要这样我们知道何时等待操作以及何时忽略（当偏移量超出范围时），并知道在哪里减少临时缓冲区的内容。</span></span><br><span class="line">      <span class="keyword">auto</span> prev = <span class="built_in">computeReduceScatterOffsets</span>(i - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (prev.recvLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Prepare out[0]-&gt;ptr to hold the local reduction</span></span><br><span class="line">        <span class="built_in">reduceInputs</span>(prev.recvOffset, prev.recvLength);</span><br><span class="line">        <span class="comment">// Wait for segment from neighbor.</span></span><br><span class="line">        tmp-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">        <span class="comment">// 对收到的段进行reduce</span></span><br><span class="line">        opts.<span class="built_in">reduce</span>(</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + prev.recvOffset,</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(out[<span class="number">0</span>]-&gt;ptr) + prev.recvOffset,</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tmp-&gt;ptr) + segmentOffset[i &amp; <span class="number">0x1</span>],</span><br><span class="line">            prev.recvLength / opts.elementSize);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (prev.sendLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out[<span class="number">0</span>]-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在最后两次迭代之外的所有迭代中发出新的发送和接收操作。</span></span><br><span class="line">    <span class="comment">// 那时我们已经发送了我们需要的所有数据，只需要等待最终的段被reduce到输出中。</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; (numSegments - numSegmentsPerRank)) &#123;</span><br><span class="line">      <span class="comment">// Compute send and receive offsets and lengths for this iteration.</span></span><br><span class="line">      <span class="keyword">auto</span> cur = <span class="built_in">computeReduceScatterOffsets</span>(i);</span><br><span class="line">      <span class="keyword">if</span> (cur.recvLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        tmp-&gt;<span class="built_in">recv</span>(recvRank, slot, segmentOffset[i &amp; <span class="number">0x1</span>], cur.recvLength);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur.sendLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Prepare out[0]-&gt;ptr to hold the local reduction for this segment</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; numSegmentsPerRank) &#123;</span><br><span class="line">          <span class="built_in">reduceInputs</span>(cur.sendOffset, cur.sendLength);</span><br><span class="line">        &#125;</span><br><span class="line">        out[<span class="number">0</span>]-&gt;<span class="built_in">send</span>(sendRank, slot, cur.sendOffset, cur.sendLength);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Function computes the offsets and lengths of the segments to be</span></span><br><span class="line">  <span class="comment">// sent and received for a given iteration during allgather.</span></span><br><span class="line">  <span class="keyword">auto</span> computeAllgatherOffsets = [&amp;](<span class="type">size_t</span> i) &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      <span class="type">size_t</span> sendOffset;</span><br><span class="line">      <span class="type">size_t</span> recvOffset;</span><br><span class="line">      <span class="type">ssize_t</span> sendLength;</span><br><span class="line">      <span class="type">ssize_t</span> recvLength;</span><br><span class="line">    &#125; result;</span><br><span class="line"></span><br><span class="line">    result.sendOffset =</span><br><span class="line">        ((((context-&gt;rank) * numSegmentsPerRank) + i) * segmentBytes) %</span><br><span class="line">        (numSegments * segmentBytes);</span><br><span class="line">    result.recvOffset =</span><br><span class="line">        ((((context-&gt;rank + <span class="number">1</span>) * numSegmentsPerRank) + i) * segmentBytes) %</span><br><span class="line">        (numSegments * segmentBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the segment is entirely in range, the following statement is</span></span><br><span class="line">    <span class="comment">// equal to segmentBytes. If it isn&#x27;t, it will be less, or even</span></span><br><span class="line">    <span class="comment">// negative. This is why the ssize_t typecasts are needed.</span></span><br><span class="line">    result.sendLength = std::<span class="built_in">min</span>(</span><br><span class="line">        (<span class="type">ssize_t</span>)segmentBytes,</span><br><span class="line">        (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)result.sendOffset);</span><br><span class="line">    result.recvLength = std::<span class="built_in">min</span>(</span><br><span class="line">        (<span class="type">ssize_t</span>)segmentBytes,</span><br><span class="line">        (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)result.recvOffset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ring allgather.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 注意：totalBytes &lt;= (numSegments * segmentBytes)，</span></span><br><span class="line">  <span class="comment">// 这与在进程间贡献相同的通用 allgather 算法不兼容。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; (numSegments - numSegmentsPerRank + <span class="number">2</span>); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">auto</span> prev = <span class="built_in">computeAllgatherOffsets</span>(i - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (prev.recvLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out[<span class="number">0</span>]-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">        <span class="comment">// Broadcast received segments to output buffers.</span></span><br><span class="line">        <span class="built_in">broadcastOutputs</span>(prev.recvOffset, prev.recvLength);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (prev.sendLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out[<span class="number">0</span>]-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在最后两次迭代之外的所有迭代中发出新的发送和接收操作。</span></span><br><span class="line">    <span class="comment">// 那时我们已经发送了我们需要的所有数据，只需要等待最终的段被发送到输出。</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; (numSegments - numSegmentsPerRank)) &#123;</span><br><span class="line">      <span class="keyword">auto</span> cur = <span class="built_in">computeAllgatherOffsets</span>(i);</span><br><span class="line">      <span class="keyword">if</span> (cur.recvLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out[<span class="number">0</span>]-&gt;<span class="built_in">recv</span>(recvRank, slot, cur.recvOffset, cur.recvLength);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur.sendLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out[<span class="number">0</span>]-&gt;<span class="built_in">send</span>(sendRank, slot, cur.sendOffset, cur.sendLength);</span><br><span class="line">        <span class="comment">// Broadcast first segments to outputs buffers.</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; numSegmentsPerRank) &#123;</span><br><span class="line">          <span class="built_in">broadcastOutputs</span>(cur.sendOffset, cur.sendLength);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于给定的上下文大小和所需的组大小，计算每步的实际组大小。</span></span><br><span class="line"><span class="comment">// 请注意，对于所有步骤，每一步的组大小为 n，仅当 n^(#steps) == 大小时。</span></span><br><span class="line"><span class="comment">// 否则，最终组大小为 != n。</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">size_t</span>&gt; <span class="title">computeGroupSizePerStep</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt; result;</span><br><span class="line">  <span class="built_in">GLOO_ENFORCE_GT</span>(n, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> (size % n == <span class="number">0</span>) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(n);</span><br><span class="line">    size /= n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bcube-算法"><a href="#bcube-算法" class="headerlink" title="bcube 算法"></a>bcube 算法</h2><p>bcube 算法实现了一种类似超立方体的reduce策略。约束是进程的数量可以分解。如果分解中的最小分量为 2，并且进程数等于 2 的幂，则该算法与递归减半/加倍相同。</p>
<p>分解中的元素数量决定了算法的步数。分解的每个元素决定了每个进程在算法的特定步骤中与之通信的进程数。如果进程数不可分解，则该算法与直接reduce-scatter 后allgather 相同。</p>
<p>例如，如果#processes == 8，并且我们将其分解为 4 * 2，则算法分 2 步运行。在第一步中，2 组 4 个进程之间交换数据，以使所有进程具有部分结果的 1/4。第二步，4组2个进程交换它们的部分结果，使得所有进程都有1/8的结果。然后，反向执行相同的分解以执行 allgather。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bcube</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> detail::AllreduceOptionsImpl&amp; opts,</span></span></span><br><span class="line"><span class="params"><span class="function">    ReduceRangeFunction reduceInputs,</span></span></span><br><span class="line"><span class="params"><span class="function">    BroadcastRangeFunction broadcastOutputs)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kAllreduceSlotPrefix, opts.tag);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> elementSize = opts.elementSize;</span><br><span class="line">  <span class="keyword">auto</span>&amp; out = opts.out[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">auto</span> n = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 算出这个算法的步数。</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> groupSizePerStep = <span class="built_in">computeGroupSizePerStep</span>(context-&gt;size, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">group</span> &#123;</span><br><span class="line">    <span class="comment">// Distance between peers in this group.</span></span><br><span class="line">    <span class="type">size_t</span> peerDistance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Segment that this group is responsible for reducing.</span></span><br><span class="line">    <span class="type">size_t</span> bufferOffset;</span><br><span class="line">    <span class="type">size_t</span> bufferLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The process ranks that are a member of this group.</span></span><br><span class="line">    std::vector&lt;<span class="type">size_t</span>&gt; ranks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Upper bound of the length of the chunk that each process has the</span></span><br><span class="line">    <span class="comment">// reduced values for by the end of the reduction for this group.</span></span><br><span class="line">    <span class="type">size_t</span> chunkLength;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Chunk within the segment that this process is responsible for reducing.</span></span><br><span class="line">    <span class="type">size_t</span> myChunkOffset;</span><br><span class="line">    <span class="type">size_t</span> myChunkLength;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在每个算法步骤计算组的详细信息。</span></span><br><span class="line">  <span class="comment">// 我们将它保存在一个向量中，因为我们在reduce/scatter阶段以正序迭代它，在全聚集阶段以反向顺序迭代它。</span></span><br><span class="line">  std::vector&lt;<span class="keyword">struct</span> group&gt; groups;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">group</span> group;</span><br><span class="line">    group.peerDistance = <span class="number">1</span>;</span><br><span class="line">    group.bufferOffset = <span class="number">0</span>;</span><br><span class="line">    group.bufferLength = opts.elements;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">size_t</span> groupSize : groupSizePerStep) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> groupRank = (context-&gt;rank / group.peerDistance) % groupSize;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> baseRank = context-&gt;rank - (groupRank * group.peerDistance);</span><br><span class="line">      group.ranks.<span class="built_in">reserve</span>(groupSize);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; groupSize; i++) &#123;</span><br><span class="line">        group.ranks.<span class="built_in">push_back</span>(baseRank + i * group.peerDistance);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 每隔groupSize个进程是一组，也就是说一个组内的rank都隔着groupSize</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Compute the length of the chunk we&#x27;re exchanging at this step.</span></span><br><span class="line">      group.chunkLength = ((group.bufferLength + (groupSize - <span class="number">1</span>)) / groupSize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 此过程正在计算当前段中位于 &lt;rank&gt;/&lt;size&gt; 的块的减少量。</span></span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      group.myChunkOffset =</span><br><span class="line">          group.bufferOffset + (groupRank * group.chunkLength);</span><br><span class="line">      group.myChunkLength = std::<span class="built_in">min</span>(</span><br><span class="line">          <span class="built_in">size_t</span>(group.chunkLength),</span><br><span class="line">          <span class="built_in">size_t</span>(std::<span class="built_in">max</span>(</span><br><span class="line">              <span class="built_in">int64_t</span>(<span class="number">0</span>),</span><br><span class="line">              <span class="built_in">int64_t</span>(group.bufferLength) -</span><br><span class="line">                  <span class="built_in">int64_t</span>(groupRank * group.chunkLength))));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Store a const copy of this group in the vector.</span></span><br><span class="line">      groups.<span class="built_in">push_back</span>(group);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 使用更新的对等距离和段偏移和长度进行初始化。</span></span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">group</span> nextGroup;</span><br><span class="line">      nextGroup.peerDistance = group.peerDistance * groupSize;</span><br><span class="line">      nextGroup.bufferOffset = group.myChunkOffset;</span><br><span class="line">      nextGroup.bufferLength = group.myChunkLength;</span><br><span class="line">      std::<span class="built_in">swap</span>(group, nextGroup);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 块长度向上取整，因此我们需要的最大暂存空间可能大于输出缓冲区的大小。 计算最大值</span></span><br><span class="line">  <span class="type">size_t</span> bufferLength = opts.elements;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; group : groups) &#123;</span><br><span class="line">    bufferLength =</span><br><span class="line">        std::<span class="built_in">max</span>(bufferLength, group.ranks.<span class="built_in">size</span>() * group.chunkLength);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配暂存空间以从对等方接收数据。</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bufferSize = bufferLength * elementSize;</span><br><span class="line">  <span class="function">std::unique_ptr&lt;<span class="type">uint8_t</span>[]&gt; <span class="title">buffer</span><span class="params">(<span class="keyword">new</span> <span class="type">uint8_t</span>[bufferSize])</span></span>;</span><br><span class="line">  std::unique_ptr&lt;transport::UnboundBuffer&gt; tmp =</span><br><span class="line">      context-&gt;<span class="built_in">createUnboundBuffer</span>(buffer.<span class="built_in">get</span>(), bufferSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reduce/scatter.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> step = <span class="number">0</span>; step &lt; groups.<span class="built_in">size</span>(); step++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; group = groups[step];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从对等点发出块的接收操作。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> src = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (src == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tmp-&gt;<span class="built_in">recv</span>(</span><br><span class="line">          src,</span><br><span class="line">          slot,</span><br><span class="line">          i * group.chunkLength * elementSize,</span><br><span class="line">          group.myChunkLength * elementSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向对等方发出本地块的发送操作。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> dst = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (dst == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> currentChunkOffset =</span><br><span class="line">          group.bufferOffset + i * group.chunkLength;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> currentChunkLength = std::<span class="built_in">min</span>(</span><br><span class="line">          <span class="built_in">size_t</span>(group.chunkLength),</span><br><span class="line">          <span class="built_in">size_t</span>(std::<span class="built_in">max</span>(</span><br><span class="line">              <span class="built_in">int64_t</span>(<span class="number">0</span>),</span><br><span class="line">              <span class="built_in">int64_t</span>(group.bufferLength) - <span class="built_in">int64_t</span>(i * group.chunkLength))));</span><br><span class="line">      <span class="comment">// 仅在算法的第一步中计算局部reduce。</span></span><br><span class="line">      <span class="comment">// 在随后的步骤中，我们已经得到了部分reduce的结果。</span></span><br><span class="line">      <span class="keyword">if</span> (step == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">reduceInputs</span>(</span><br><span class="line">            currentChunkOffset * elementSize, currentChunkLength * elementSize);</span><br><span class="line">      &#125;</span><br><span class="line">      out-&gt;<span class="built_in">send</span>(</span><br><span class="line">          dst,</span><br><span class="line">          slot,</span><br><span class="line">          currentChunkOffset * elementSize,</span><br><span class="line">          currentChunkLength * elementSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for send and receive operations to complete.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> peer = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (peer == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      tmp-&gt;<span class="built_in">waitRecv</span>();</span><br><span class="line">      out-&gt;<span class="built_in">waitSend</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步，准备这个进程负责的chunk</span></span><br><span class="line">    <span class="comment">// 使用其输入的简化版本（如果指定了多个）。</span></span><br><span class="line">    <span class="keyword">if</span> (step == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">reduceInputs</span>(</span><br><span class="line">          group.myChunkOffset * elementSize, group.myChunkLength * elementSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reduce chunks from peers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> src = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (src == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      opts.<span class="built_in">reduce</span>(</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out-&gt;ptr) + (group.myChunkOffset * elementSize),</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(out-&gt;ptr) +</span><br><span class="line">              (group.myChunkOffset * elementSize),</span><br><span class="line">          <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tmp-&gt;ptr) +</span><br><span class="line">              (i * group.chunkLength * elementSize),</span><br><span class="line">          group.myChunkLength);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有一个块包含最终结果，并且该块已经可以在本地广播到 out[1..N]（如果适用）。</span></span><br><span class="line">  <span class="comment">// 这样做意味着我们只需要在本地广播到 out[1..N] 所有块，因为我们在 allgather 阶段从对等方接收到它们。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; group = groups.<span class="built_in">back</span>();</span><br><span class="line">    <span class="built_in">broadcastOutputs</span>(</span><br><span class="line">        group.myChunkOffset * elementSize, group.myChunkLength * elementSize);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allgather.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = groups.<span class="built_in">rbegin</span>(); it != groups.<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; group = *it;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Issue receive operations for reduced chunks from peers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> src = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (src == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> currentChunkOffset =</span><br><span class="line">          group.bufferOffset + i * group.chunkLength;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> currentChunkLength = std::<span class="built_in">min</span>(</span><br><span class="line">          <span class="built_in">size_t</span>(group.chunkLength),</span><br><span class="line">          <span class="built_in">size_t</span>(std::<span class="built_in">max</span>(</span><br><span class="line">              <span class="built_in">int64_t</span>(<span class="number">0</span>),</span><br><span class="line">              <span class="built_in">int64_t</span>(group.bufferLength) - <span class="built_in">int64_t</span>(i * group.chunkLength))));</span><br><span class="line">      out-&gt;<span class="built_in">recv</span>(</span><br><span class="line">          src,</span><br><span class="line">          slot,</span><br><span class="line">          currentChunkOffset * elementSize,</span><br><span class="line">          currentChunkLength * elementSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Issue send operations for reduced chunk to peers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> dst = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (dst == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      out-&gt;<span class="built_in">send</span>(</span><br><span class="line">          dst,</span><br><span class="line">          slot,</span><br><span class="line">          group.myChunkOffset * elementSize,</span><br><span class="line">          group.myChunkLength * elementSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for operations to complete.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> peer = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (peer == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      out-&gt;<span class="built_in">waitRecv</span>();</span><br><span class="line">      out-&gt;<span class="built_in">waitSend</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Broadcast result to multiple output buffers, if applicable.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; group.ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> peer = group.ranks[i];</span><br><span class="line">      <span class="keyword">if</span> (peer == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> currentChunkOffset =</span><br><span class="line">          group.bufferOffset + i * group.chunkLength;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> currentChunkLength = std::<span class="built_in">min</span>(</span><br><span class="line">          <span class="built_in">size_t</span>(group.chunkLength),</span><br><span class="line">          <span class="built_in">size_t</span>(std::<span class="built_in">max</span>(</span><br><span class="line">              <span class="built_in">int64_t</span>(<span class="number">0</span>),</span><br><span class="line">              <span class="built_in">int64_t</span>(group.bufferLength) - <span class="built_in">int64_t</span>(i * group.chunkLength))));</span><br><span class="line">      <span class="built_in">broadcastOutputs</span>(</span><br><span class="line">          currentChunkOffset * elementSize, currentChunkLength * elementSize);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="alltoallv"><a href="#alltoallv" class="headerlink" title="alltoallv"></a>alltoallv</h1><p>同alltoall一样，只不过alltoallv的实现多了offset，没有什么高深的算法，只是在send-recv<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">alltoallv</span><span class="params">(AlltoallvOptions&amp; opts)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  transport::UnboundBuffer* in = opts.in.<span class="built_in">get</span>();</span><br><span class="line">  transport::UnboundBuffer* out = opts.out.<span class="built_in">get</span>();</span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt;&amp; inOffsetPerRank = opts.inOffsetPerRank;</span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt;&amp; inLengthPerRank = opts.inLengthPerRank;</span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt;&amp; outOffsetPerRank = opts.outOffsetPerRank;</span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt;&amp; outLengthPerRank = opts.outLengthPerRank;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kAlltoallSlotPrefix, opts.tag);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> myRank = context-&gt;rank;</span><br><span class="line">  <span class="type">int</span> worldSize = context-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Local copy.</span></span><br><span class="line">  <span class="built_in">GLOO_ENFORCE</span>(inLengthPerRank[myRank] == outLengthPerRank[myRank]);</span><br><span class="line">  <span class="type">size_t</span> myInOffset = inOffsetPerRank[myRank];</span><br><span class="line">  <span class="type">size_t</span> myOutOffset = outOffsetPerRank[myRank];</span><br><span class="line">  <span class="type">size_t</span> myChunkSize = inLengthPerRank[myRank];</span><br><span class="line">  <span class="built_in">memcpy</span>(</span><br><span class="line">      <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(out-&gt;ptr) + myOutOffset,</span><br><span class="line">      <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(in-&gt;ptr) + myInOffset,</span><br><span class="line">      myChunkSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remote copy.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; worldSize; i++) &#123;</span><br><span class="line">    <span class="type">int</span> sendRank = (myRank + i) % worldSize;</span><br><span class="line">    <span class="type">int</span> recvRank = (myRank + worldSize - i) % worldSize;</span><br><span class="line">    in-&gt;<span class="built_in">send</span>(</span><br><span class="line">        sendRank, slot, inOffsetPerRank[sendRank], inLengthPerRank[sendRank]);</span><br><span class="line">    out-&gt;<span class="built_in">recv</span>(</span><br><span class="line">        recvRank, slot, outOffsetPerRank[recvRank], outLengthPerRank[recvRank]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; worldSize; i++) &#123;</span><br><span class="line">    in-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">    out-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a>barrier</h1><p>如果是共有16进程的话，</p>
<p>0号进程会与15 1，14 2，12 4，8 8进程recv send</p>
<p>1号进程会与0 2，15 3，13 5，9 9进程recv send</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">barrier</span><span class="params">(BarrierOptions&amp; opts)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  <span class="keyword">auto</span>&amp; buffer = opts.buffer;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kBarrierSlotPrefix, opts.tag);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Below implements a dissemination barrier, described in &quot;Two algorithms</span></span><br><span class="line">  <span class="comment">// for barrier synchronization (1988)&quot; by Hensgen, Finkel and Manber.</span></span><br><span class="line">  <span class="comment">// PDF: https://www.inf.ed.ac.uk/teaching/courses/ppls/BarrierPaper.pdf</span></span><br><span class="line">  <span class="comment">// DOI: 10.1007/BF01379320</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instead of iterating over i up to log2(context-&gt;size), we immediately</span></span><br><span class="line">  <span class="comment">// compute 2^i and compare with context-&gt;size.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> d = <span class="number">1</span>; d &lt; context-&gt;size; d &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    buffer-&gt;<span class="built_in">recv</span>((context-&gt;size + context-&gt;rank - d) % context-&gt;size, slot);</span><br><span class="line">    buffer-&gt;<span class="built_in">send</span>((context-&gt;size + context-&gt;rank + d) % context-&gt;size, slot);</span><br><span class="line">    buffer-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">    buffer-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="broadcast"><a href="#broadcast" class="headerlink" title="broadcast"></a>broadcast</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">broadcast</span><span class="params">(BroadcastOptions&amp; opts)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  transport::UnboundBuffer* in = opts.in.<span class="built_in">get</span>();</span><br><span class="line">  transport::UnboundBuffer* out = opts.out.<span class="built_in">get</span>();</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kBroadcastSlotPrefix, opts.tag);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (context-&gt;rank == opts.root) &#123;</span><br><span class="line">    in = out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将rank映射到根进程rank为 0 的新rank。</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> vsize = context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> vrank = (context-&gt;rank + vsize - opts.root) % vsize;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> dim = <span class="built_in">log2ceil</span>(vsize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跟踪未决发送操作的数量。</span></span><br><span class="line">  <span class="comment">// 发送操作可以异步完成，因为迭代之间存在依赖关系。</span></span><br><span class="line">  <span class="comment">// 这与必须在任何发送操作排队之前完成的 recv 操作不同。</span></span><br><span class="line">  <span class="type">size_t</span> numSends = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建全为 1 的掩码，我们从 LSB 开始逐步将位设置为 0。</span></span><br><span class="line">  <span class="comment">// 当应用于虚拟rank的掩码等于 0 时，我们知道该进程必须参与。</span></span><br><span class="line">  <span class="comment">// 这导致从虚拟rank 0 和 1 开始的指数级参与.</span></span><br><span class="line">  <span class="type">size_t</span> mask = (<span class="number">1</span> &lt;&lt; dim) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; dim; i++) &#123;</span><br><span class="line">    <span class="comment">// Clear bit `i`. 在第一次迭代中，虚拟rank 0 和 1 参与。</span></span><br><span class="line">    <span class="comment">// 在第二次迭代中，0、1、2 和 3 参与，依此类推。</span></span><br><span class="line">    mask ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">if</span> ((vrank &amp; mask) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The virtual rank of the peer in this iteration has opposite bit `i`.</span></span><br><span class="line">    <span class="keyword">auto</span> vpeer = vrank ^ (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    <span class="keyword">if</span> (vpeer &gt;= vsize) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map virtual rank of peer to actual rank of peer.</span></span><br><span class="line">    <span class="keyword">auto</span> peer = (vpeer + opts.root) % vsize;</span><br><span class="line">    <span class="keyword">if</span> ((vrank &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line">      in-&gt;<span class="built_in">send</span>(peer, slot);</span><br><span class="line">      numSends++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      out-&gt;<span class="built_in">recv</span>(peer, slot);</span><br><span class="line">      out-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy local input to output if applicable.</span></span><br><span class="line">  <span class="keyword">if</span> (context-&gt;rank == opts.root &amp;&amp; in != out) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(out-&gt;ptr, in-&gt;ptr, out-&gt;size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait on pending sends.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; numSends; i++) &#123;</span><br><span class="line">    in-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="avx优化"><a href="#avx优化" class="headerlink" title="avx优化"></a>avx优化</h1><p>一些reduce函数使用了avx。<code>_mm256_cvtph_ps</code>将八个半精度（16 位）浮点值转换为单精度浮点值。<code>_mm256_cvtps_ph</code>将八个单精度浮点值转换为半精度（16 位）浮点值。<code>_mm_storeu_si128</code>将计算结果等SSE暂存器的数据保存到内存中。<code>_mm256_mul_ps</code>对第一个源向量 m1 中的八个压缩单精度浮点元素（float32 元素）与第二个源向量 m2 中的八个 float32 元素执行 SIMD 乘法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//假设 x 和 y 要么都对齐到 32 字节，要么未对齐相同的偏移量，就像在对齐缓冲区内的偏移量处减少时会发生的那样</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">sum</span>&lt;float16&gt;(<span class="type">void</span>* c_, <span class="type">const</span> <span class="type">void</span>* a_, <span class="type">const</span> <span class="type">void</span>* b_, <span class="type">size_t</span> n) &#123;</span><br><span class="line">  float16* c = <span class="built_in">static_cast</span>&lt;float16*&gt;(c_);</span><br><span class="line">  <span class="type">const</span> float16* a = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(a_);</span><br><span class="line">  <span class="type">const</span> float16* b = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(b_);</span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (n / <span class="number">8</span>) * <span class="number">8</span>; i += <span class="number">8</span>) &#123;</span><br><span class="line">    __m256 va32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;a[i])));</span><br><span class="line">    __m256 vb32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;b[i])));</span><br><span class="line">    __m128i vc16 = _mm256_cvtps_ph(_mm256_add_ps(va32, vb32), <span class="number">0</span>);</span><br><span class="line">    _mm_storeu_si128((__m128i*)(&amp;c[i]), vc16);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Leftovers</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; i++) &#123;</span><br><span class="line">    c[i] = a[i] + b[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">product</span>&lt;float16&gt;(<span class="type">void</span>* c_, <span class="type">const</span> <span class="type">void</span>* a_, <span class="type">const</span> <span class="type">void</span>* b_, <span class="type">size_t</span> n) &#123;</span><br><span class="line">  float16* c = <span class="built_in">static_cast</span>&lt;float16*&gt;(c_);</span><br><span class="line">  <span class="type">const</span> float16* a = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(a_);</span><br><span class="line">  <span class="type">const</span> float16* b = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(b_);</span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (n / <span class="number">8</span>) * <span class="number">8</span>; i += <span class="number">8</span>) &#123;</span><br><span class="line">    __m256 va32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;a[i])));</span><br><span class="line">    __m256 vb32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;b[i])));</span><br><span class="line">    __m128i vc16 = _mm256_cvtps_ph(_mm256_mul_ps(va32, vb32), <span class="number">0</span>);</span><br><span class="line">    _mm_storeu_si128((__m128i*)(&amp;c[i]), vc16);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Leftovers</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; i++) &#123;</span><br><span class="line">    c[i] = a[i] * b[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">max</span>&lt;float16&gt;(<span class="type">void</span>* c_, <span class="type">const</span> <span class="type">void</span>* a_, <span class="type">const</span> <span class="type">void</span>* b_, <span class="type">size_t</span> n) &#123;</span><br><span class="line">  float16* c = <span class="built_in">static_cast</span>&lt;float16*&gt;(c_);</span><br><span class="line">  <span class="type">const</span> float16* a = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(a_);</span><br><span class="line">  <span class="type">const</span> float16* b = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(b_);</span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (n / <span class="number">8</span>) * <span class="number">8</span>; i += <span class="number">8</span>) &#123;</span><br><span class="line">    __m256 va32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;a[i])));</span><br><span class="line">    __m256 vb32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;b[i])));</span><br><span class="line">    __m128i vc16 = _mm256_cvtps_ph(_mm256_max_ps(va32, vb32), <span class="number">0</span>);</span><br><span class="line">    _mm_storeu_si128((__m128i*)(&amp;c[i]), vc16);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Leftovers</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; i++) &#123;</span><br><span class="line">    c[i] = std::<span class="built_in">max</span>(a[i], b[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">min</span>&lt;float16&gt;(<span class="type">void</span>* c_, <span class="type">const</span> <span class="type">void</span>* a_, <span class="type">const</span> <span class="type">void</span>* b_, <span class="type">size_t</span> n) &#123;</span><br><span class="line">  float16* c = <span class="built_in">static_cast</span>&lt;float16*&gt;(c_);</span><br><span class="line">  <span class="type">const</span> float16* a = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(a_);</span><br><span class="line">  <span class="type">const</span> float16* b = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> float16*&gt;(b_);</span><br><span class="line">  <span class="type">size_t</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (n / <span class="number">8</span>) * <span class="number">8</span>; i += <span class="number">8</span>) &#123;</span><br><span class="line">    __m256 va32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;a[i])));</span><br><span class="line">    __m256 vb32 = _mm256_cvtph_ps(_mm_loadu_si128((__m128i*)(&amp;b[i])));</span><br><span class="line">    __m128i vc16 = _mm256_cvtps_ph(_mm256_min_ps(va32, vb32), <span class="number">0</span>);</span><br><span class="line">    _mm_storeu_si128((__m128i*)(&amp;c[i]), vc16);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Leftovers</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; i++) &#123;</span><br><span class="line">    c[i] = std::<span class="built_in">min</span>(a[i], b[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reduce</span><span class="params">(ReduceOptions&amp; opts)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (opts.elements == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; context = opts.context;</span><br><span class="line">  transport::UnboundBuffer* in = opts.in.<span class="built_in">get</span>();</span><br><span class="line">  transport::UnboundBuffer* out = opts.out.<span class="built_in">get</span>();</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> slot = Slot::<span class="built_in">build</span>(kReduceSlotPrefix, opts.tag);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> recvRank = (context-&gt;size + context-&gt;rank + <span class="number">1</span>) % context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> sendRank = (context-&gt;size + context-&gt;rank - <span class="number">1</span>) % context-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If input buffer is not specified, the output is also the input</span></span><br><span class="line">  <span class="keyword">if</span> (in == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    in = out;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果只有一个进程，则短路。</span></span><br><span class="line">  <span class="keyword">if</span> (context-&gt;size == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (in != out) &#123;</span><br><span class="line">      <span class="built_in">memcpy</span>(out-&gt;ptr, in-&gt;ptr, opts.elements * opts.elementSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The ring algorithm works as follows.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 给定的输入被分成与进程数相等的块数。</span></span><br><span class="line">  <span class="comment">// 算法完成后，每个进程按顺序托管一个reduce输出块（rank 0 具有块 0，rank 1 具有块 1，等等）。</span></span><br><span class="line">  <span class="comment">// 由于输入可能不能被进程数整除，因此最终的块可能有部分输出或可能为空。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 当一个块沿着环传递并包含连续更多rank的reduce时，我们必须在为该块执行 I/O 和计算接收到的块和本地块之间的减少之间交替。</span></span><br><span class="line">  <span class="comment">// 为了避免这种交替模式，我们将一个块分成多个段（&gt; = 2），并确保我们有一个段在运行，同时计算另一个段的reduce。</span></span><br><span class="line">  <span class="comment">// 段大小有一个上限，以最大限度地减少内存使用并避免不良的缓存行为。这意味着在处理非常大的输入时，每个块可能有很多段。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 这里的命名法反映在下面的变量命名中（每个rank一个块，每个块多个段）。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> totalBytes = opts.elements * opts.elementSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保最大段大小是元素大小的倍数。 否则，在向上舍入到元素大小的最接近倍数后，段大小可能会超过最大段大小。 例如，如果maxSegmentSize = 10，而elementSize = 4，则向上取整后：segmentSize = 12；</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> maxSegmentSize =</span><br><span class="line">      opts.elementSize * (opts.maxSegmentSize / opts.elementSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每个段的字节数必须是每个元素的字节数的倍数才能进行缩减； 必要时四舍五入。</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> segmentBytes = <span class="built_in">roundUp</span>(</span><br><span class="line">      std::<span class="built_in">min</span>(</span><br><span class="line">          <span class="comment">// Rounded division to have &gt;= 2 segments per chunk.</span></span><br><span class="line">          (totalBytes + (context-&gt;size * <span class="number">2</span> - <span class="number">1</span>)) / (context-&gt;size * <span class="number">2</span>),</span><br><span class="line">          <span class="comment">// Configurable segment size limit</span></span><br><span class="line">          maxSegmentSize),</span><br><span class="line">      opts.elementSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute how many segments make up the input buffer.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 向上舍入到上下文大小的最接近的倍数，以便每个进程有相同数量的段，并且跨进程的执行是对称的。</span></span><br><span class="line">  <span class="comment">// 最小值是上下文大小的两倍，因为下面的算法将发送/接收一个段与计算另一个段的缩减重叠。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> numSegments = <span class="built_in">roundUp</span>(</span><br><span class="line">      std::<span class="built_in">max</span>(</span><br><span class="line">          (totalBytes + (segmentBytes - <span class="number">1</span>)) / segmentBytes,</span><br><span class="line">          (<span class="type">size_t</span>)context-&gt;size * <span class="number">2</span>),</span><br><span class="line">      (<span class="type">size_t</span>)context-&gt;size);</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> numSegmentsPerRank = numSegments / context-&gt;size;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> chunkBytes = numSegmentsPerRank * segmentBytes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配暂存空间以容纳两个块</span></span><br><span class="line">  <span class="function">std::unique_ptr&lt;<span class="type">uint8_t</span>[]&gt; <span class="title">tmpAllocation</span><span class="params">(<span class="keyword">new</span> <span class="type">uint8_t</span>[segmentBytes * <span class="number">2</span>])</span></span>;</span><br><span class="line">  std::unique_ptr&lt;transport::UnboundBuffer&gt; tmpBuffer =</span><br><span class="line">      context-&gt;<span class="built_in">createUnboundBuffer</span>(tmpAllocation.<span class="built_in">get</span>(), segmentBytes * <span class="number">2</span>);</span><br><span class="line">  transport::UnboundBuffer* tmp = tmpBuffer.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用动态查找临时缓冲区中的块偏移量。</span></span><br><span class="line">  <span class="comment">// 在进行两个操作时，我们需要两个偏移量。</span></span><br><span class="line">  <span class="comment">// 可以使用循环计数器对它们进行索引。</span></span><br><span class="line">  std::array&lt;<span class="type">size_t</span>, 2&gt; segmentOffset;</span><br><span class="line">  segmentOffset[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  segmentOffset[<span class="number">1</span>] = segmentBytes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数计算给定块迭代要发送和接收的块的偏移量和长度。</span></span><br><span class="line">  <span class="keyword">auto</span> computeReduceScatterOffsets = [&amp;](<span class="type">size_t</span> i) &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      <span class="type">size_t</span> sendOffset;</span><br><span class="line">      <span class="type">size_t</span> recvOffset;</span><br><span class="line">      <span class="type">ssize_t</span> sendLength;</span><br><span class="line">      <span class="type">ssize_t</span> recvLength;</span><br><span class="line">    &#125; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算要发送的段索引（到 rank - 1）和要接收的段索引（从 rank + 1）。</span></span><br><span class="line">    <span class="comment">// 乘以块中的字节数以获得偏移量。</span></span><br><span class="line">    <span class="comment">// 允许偏移量超出范围（&gt;=totalBytes），计算相关长度时会考虑到这一点。</span></span><br><span class="line">    result.sendOffset =</span><br><span class="line">        ((((context-&gt;rank + <span class="number">1</span>) * numSegmentsPerRank) + i) * segmentBytes) %</span><br><span class="line">        (numSegments * segmentBytes);</span><br><span class="line">    result.recvOffset =</span><br><span class="line">        ((((context-&gt;rank + <span class="number">2</span>) * numSegmentsPerRank) + i) * segmentBytes) %</span><br><span class="line">        (numSegments * segmentBytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果段完全在范围内，则以下语句等于段字节。</span></span><br><span class="line">    <span class="comment">// 如果不是，它会更少，甚至是负面的。 这就是需要 ssize_t 类型转换的原因。</span></span><br><span class="line">    result.sendLength = std::<span class="built_in">min</span>(</span><br><span class="line">        (<span class="type">ssize_t</span>)segmentBytes,</span><br><span class="line">        (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)result.sendOffset);</span><br><span class="line">    result.recvLength = std::<span class="built_in">min</span>(</span><br><span class="line">        (<span class="type">ssize_t</span>)segmentBytes,</span><br><span class="line">        (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)result.recvOffset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; numSegments; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">// 计算两次迭代前的发送和接收偏移量和长度。</span></span><br><span class="line">      <span class="comment">// 需要这样我们知道何时等待操作以及何时忽略（当偏移量超出范围时），</span></span><br><span class="line">      <span class="comment">// 并知道在哪里减少临时缓冲区的内容。</span></span><br><span class="line">      <span class="keyword">auto</span> prev = <span class="built_in">computeReduceScatterOffsets</span>(i - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (prev.recvLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        tmp-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">        opts.<span class="built_in">reduce</span>(</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(out-&gt;ptr) + prev.recvOffset,</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(in-&gt;ptr) + prev.recvOffset,</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(tmp-&gt;ptr) + segmentOffset[i &amp; <span class="number">0x1</span>],</span><br><span class="line">            prev.recvLength / opts.elementSize);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (prev.sendLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i - <span class="number">2</span>) &lt; numSegmentsPerRank) &#123;</span><br><span class="line">          in-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          out-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在最后两次迭代之外的所有迭代中发出新的发送和接收操作。</span></span><br><span class="line">    <span class="comment">// 那时我们已经发送了我们需要的所有数据，只需要等待最终的段被减少到输出中。</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; (numSegments - <span class="number">2</span>)) &#123;</span><br><span class="line">      <span class="comment">// Compute send and receive offsets and lengths for this iteration.</span></span><br><span class="line">      <span class="keyword">auto</span> cur = <span class="built_in">computeReduceScatterOffsets</span>(i);</span><br><span class="line">      <span class="keyword">if</span> (cur.recvLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        tmp-&gt;<span class="built_in">recv</span>(recvRank, slot, segmentOffset[i &amp; <span class="number">0x1</span>], cur.recvLength);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur.sendLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; numSegmentsPerRank) &#123;</span><br><span class="line">          in-&gt;<span class="built_in">send</span>(sendRank, slot, cur.sendOffset, cur.sendLength);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          out-&gt;<span class="built_in">send</span>(sendRank, slot, cur.sendOffset, cur.sendLength);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Gather to root rank.</span></span><br><span class="line">  <span class="comment">// 注意：totalBytes &lt;= (numSegments * segmentBytes)，</span></span><br><span class="line">  <span class="comment">// 这与在进程间贡献相同的通用聚集算法不兼容。</span></span><br><span class="line">  <span class="keyword">if</span> (context-&gt;rank == opts.root) &#123;</span><br><span class="line">    <span class="type">size_t</span> numRecv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> rank = <span class="number">0</span>; rank &lt; context-&gt;size; rank++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (rank == context-&gt;rank) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">size_t</span> recvOffset = rank * numSegmentsPerRank * segmentBytes;</span><br><span class="line">      <span class="type">ssize_t</span> recvLength = std::<span class="built_in">min</span>(</span><br><span class="line">          (<span class="type">ssize_t</span>)chunkBytes, (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)recvOffset);</span><br><span class="line">      <span class="keyword">if</span> (recvLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out-&gt;<span class="built_in">recv</span>(rank, slot, recvOffset, recvLength);</span><br><span class="line">        numRecv++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; numRecv; i++) &#123;</span><br><span class="line">      out-&gt;<span class="built_in">waitRecv</span>(opts.timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> sendOffset = context-&gt;rank * numSegmentsPerRank * segmentBytes;</span><br><span class="line">    <span class="type">ssize_t</span> sendLength = std::<span class="built_in">min</span>(</span><br><span class="line">        (<span class="type">ssize_t</span>)chunkBytes, (<span class="type">ssize_t</span>)totalBytes - (<span class="type">ssize_t</span>)sendOffset);</span><br><span class="line">    <span class="keyword">if</span> (sendLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      out-&gt;<span class="built_in">send</span>(opts.root, slot, sendOffset, sendLength);</span><br><span class="line">      out-&gt;<span class="built_in">waitSend</span>(opts.timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%A7%AF%E7%B4%AF/" rel="tag"># 积累</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/28/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%E5%8F%91%E5%B8%83%E7%89%88/" rel="prev" title="面经整理">
      <i class="fa fa-chevron-left"></i> 面经整理
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/18/modern-cpp-tutorial/" rel="next" title="modern-cpp-tutorial">
      modern-cpp-tutorial <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#aligned-allocator"><span class="nav-number">1.</span> <span class="nav-text">aligned_allocator</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#transport"><span class="nav-number">2.</span> <span class="nav-text">transport</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ibverbs"><span class="nav-number">2.1.</span> <span class="nav-text">ibverbs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp"><span class="nav-number">2.2.</span> <span class="nav-text">tcp</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tls"><span class="nav-number">2.2.1.</span> <span class="nav-text">tls</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E7%BB%8Ftcp"><span class="nav-number">2.2.2.</span> <span class="nav-text">正经tcp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#loop"><span class="nav-number">2.2.3.</span> <span class="nav-text">loop</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mpi"><span class="nav-number">3.</span> <span class="nav-text">mpi</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1"><span class="nav-number">4.</span> <span class="nav-text">通信</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#allgather"><span class="nav-number">5.</span> <span class="nav-text">allgather</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E7%9A%84allgather"><span class="nav-number">6.</span> <span class="nav-text">一般的allgather</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#allgatherv"><span class="nav-number">7.</span> <span class="nav-text">allgatherv</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#allreduce"><span class="nav-number">8.</span> <span class="nav-text">allreduce</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#allreduce%E7%9A%84ring%E6%96%B9%E6%B3%95"><span class="nav-number">8.1.</span> <span class="nav-text">allreduce的ring方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bcube-%E7%AE%97%E6%B3%95"><span class="nav-number">8.2.</span> <span class="nav-text">bcube 算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#alltoallv"><span class="nav-number">9.</span> <span class="nav-text">alltoallv</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#barrier"><span class="nav-number">10.</span> <span class="nav-text">barrier</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#broadcast"><span class="nav-number">11.</span> <span class="nav-text">broadcast</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#avx%E4%BC%98%E5%8C%96"><span class="nav-number">12.</span> <span class="nav-text">avx优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#reduce"><span class="nav-number">13.</span> <span class="nav-text">reduce</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
