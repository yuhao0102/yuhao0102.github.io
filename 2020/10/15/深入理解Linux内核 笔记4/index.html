<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="系统调用POSIX API和系统调用从编程者的观点看，API和系统调用之间的差别是没有关系的：唯一相关的事情就是函数名、参数类型及返回代码的含义。然而，从内核设计者的观点看，这种差别确实有关系，因为系统调用属于内核，而用户态的库函数不属于内核。 大部分封装返回一个整数，其值的含义依赖于相应的系统调用。返回值-1通常表示内核不能满足进程的请求。每个出错码都定义为一个常量宏。POSIX标准制定了很多出">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Linux内核10-12章">
<meta property="og:url" content="http://yoursite.com/2020/10/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%20%E7%AC%94%E8%AE%B04/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="系统调用POSIX API和系统调用从编程者的观点看，API和系统调用之间的差别是没有关系的：唯一相关的事情就是函数名、参数类型及返回代码的含义。然而，从内核设计者的观点看，这种差别确实有关系，因为系统调用属于内核，而用户态的库函数不属于内核。 大部分封装返回一个整数，其值的含义依赖于相应的系统调用。返回值-1通常表示内核不能满足进程的请求。每个出错码都定义为一个常量宏。POSIX标准制定了很多出">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/1602756711.png">
<meta property="og:image" content="http://yoursite.com/img/1602827720.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602756712.png">
<meta property="og:image" content="http://yoursite.com/img/1602756713.png">
<meta property="og:image" content="http://yoursite.com/img/1602914223.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602914276.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602914819.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602914868.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602915019.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602915046.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602915258.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602915321.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602922244.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602922373.jpg">
<meta property="og:image" content="http://yoursite.com/img/1603005113.jpg">
<meta property="og:image" content="http://yoursite.com/img/1603005706.jpg">
<meta property="og:image" content="http://yoursite.com/img/1603031773.jpg">
<meta property="og:image" content="http://yoursite.com/img/1603036205.jpg">
<meta property="og:image" content="http://yoursite.com/img/1603037026.jpg">
<meta property="og:image" content="http://yoursite.com/img/1603037060.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602756714.png">
<meta property="og:image" content="http://yoursite.com/img/1603101159.jpg">
<meta property="og:image" content="http://yoursite.com/img/1602756715.png">
<meta property="og:image" content="http://yoursite.com/img/1602756716.png">
<meta property="og:image" content="http://yoursite.com/img/1603188017.png">
<meta property="og:image" content="http://yoursite.com/img/1603188019.png">
<meta property="og:image" content="http://yoursite.com/img/1603195761.jpg">
<meta property="og:image" content="http://yoursite.com/img/1603211045.jpg">
<meta property="og:image" content="http://yoursite.com/img/1603211266.jpg">
<meta property="og:image" content="http://yoursite.com/img/1603211439.jpg">
<meta property="og:image" content="http://yoursite.com/img/1603211726.jpg">
<meta property="og:image" content="http://yoursite.com/img/1603188020.png">
<meta property="og:image" content="http://yoursite.com/img/1603188022.png">
<meta property="og:image" content="http://yoursite.com/img/1603284009.jpg">
<meta property="og:image" content="http://yoursite.com/img/1603284172.jpg">
<meta property="og:image" content="http://yoursite.com/img/1603460627.jpg">
<meta property="og:image" content="http://yoursite.com/img/1603464240.jpg">
<meta property="article:published_time" content="2020-10-15T08:00:00.000Z">
<meta property="article:modified_time" content="2020-10-23T15:11:02.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/1602756711.png">

<link rel="canonical" href="http://yoursite.com/2020/10/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%20%E7%AC%94%E8%AE%B04/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>深入理解Linux内核10-12章 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/resume.pdf" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%20%E7%AC%94%E8%AE%B04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入理解Linux内核10-12章
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-15 16:00:00" itemprop="dateCreated datePublished" datetime="2020-10-15T16:00:00+08:00">2020-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-23 23:11:02" itemprop="dateModified" datetime="2020-10-23T23:11:02+08:00">2020-10-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="POSIX-API和系统调用"><a href="#POSIX-API和系统调用" class="headerlink" title="POSIX API和系统调用"></a>POSIX API和系统调用</h2><p>从编程者的观点看，API和系统调用之间的差别是没有关系的：唯一相关的事情就是函数名、参数类型及返回代码的含义。然而，从内核设计者的观点看，这种差别确实有关系，因为系统调用属于内核，而用户态的库函数不属于内核。</p>
<p>大部分封装返回一个整数，其值的含义依赖于相应的系统调用。返回值-1通常表示内核不能满足进程的请求。每个出错码都定义为一个常量宏。POSIX标准制定了很多出错码的宏名。</p>
<h2 id="系统调用处理程序及服务例程"><a href="#系统调用处理程序及服务例程" class="headerlink" title="系统调用处理程序及服务例程"></a>系统调用处理程序及服务例程</h2><p>当用户态的进程调用一个系统调用时，CPU切换到内核态并开始执行一个内核态函数。在80x86体系结构中，可以用两种不同的方式调用linux的系统调用。两种方式的最终结果都是跳转到所谓<strong>系统调用处理程序的汇编语言函数</strong>。</p>
<p>因为内核实现了很多不同的系统调用，因此<strong>进程必须传递一个名为系统调用号的参数来识别所需的系统调用，eax寄存器就用作此目的</strong>。</p>
<p>所有的系统调用都返回一个整数值。这些返回值与封装例程返回值的约定是不同的。在内核中，正数或0表示系统调用成功结束，而负数表示一个出错条件。在后一种情况下，这个值就是存放在error变量中必须返回给应用程序的负出错码。</p>
<p>系统调用处理程序与其他异常处理程序的结构类似，执行下列操作：</p>
<ul>
<li>在内核态栈保存大多数寄存器的内容</li>
<li>调用名为系统调用服务例程</li>
<li>退出系统调用处理程序：用保存在内核栈中的值加载寄存器，CPU从内核态切换回到用户态</li>
</ul>
<p><img src="/img/1602756711.png" alt=""></p>
<p><code>xyz()</code>系统调用对应的服务例程的名字通常是<code>sys_xyz()</code>。不过也有一些例外。为了把系统调用号与相应的服务例程关联起来，内核利用了一个<strong>系统调用分派表</strong>（dispatch table）。这个表存放在<code>sys_call_table</code>数组中，有<code>NR_syscalls</code>个表项：第n个表项包含系统调用号为n的服务例程的地址。</p>
<p><code>NR_syscalls</code>宏只是对可实现的系统调用最大个数的静态限制，并不表示实际已实现的系统调用个数。实际上，分派表中的任意一个表项也可以包含<code>sys_ni_syscall()</code>函数的地址，这个函数是“未实现”系统调用的服务例程，它仅仅返回出错码-ENOSYS。</p>
<h2 id="进入和退出系统调用"><a href="#进入和退出系统调用" class="headerlink" title="进入和退出系统调用"></a>进入和退出系统调用</h2><p>本地应用可以通过两种不同的方式调用系统调用：</p>
<ul>
<li>执行<code>int $0x80</code>汇编语言执行。在Linux内核的老版本中，这是从用户态切换到内核态的唯一方式。</li>
<li>执行<code>sysenter</code>汇编语言执行。</li>
</ul>
<p>同样，内核可以通过两种方式从系统调用退出，从而使CPU切换回到用户态：</p>
<ul>
<li>执行<code>iret</code>汇编语言指令。</li>
<li>执行<code>sysexit</code>汇编语言指令。</li>
</ul>
<p>但是，支持进入内核的两种不同方式并不像看起来那么简单，因为：</p>
<ul>
<li>内核必须即支持只使用<code>int $0x80</code>指令的旧函数库，同时支持也可以使用<code>sysenter</code>指令的新函数库。</li>
<li>使用<code>sysenter</code>指令的标准库必须能处理仅支持<code>int $0x80</code>指令的旧内核。</li>
<li>内核和标准库必须既能运行在不包含<code>sysenter</code>指令的旧处理器上，也能运行在包含它的新处理器上。</li>
</ul>
<h3 id="通过int-0x80指令发出系统调用"><a href="#通过int-0x80指令发出系统调用" class="headerlink" title="通过int $0x80指令发出系统调用"></a>通过int $0x80指令发出系统调用</h3><p>向量128(十六进制0x80)对应于内核入口点。在内核初始化期间调用的函数<code>trap_init()</code>，用下面的方式建立对应于向量128的中断描述符表表项：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_system_gate(<span class="number">0x80</span>, &amp;system_call);</span><br></pre></td></tr></table></figure><br>该调用把下列值存入这个门描述符的相应字段：</p>
<ul>
<li><code>Segmet Selector</code>：内核代码段<code>__KERNEL_CS</code>的段选择符。</li>
<li><code>Offset</code>：指向<code>system_call()</code>系统调用处理程序的指针。</li>
<li><code>Type</code>：置为15。表示这个异常是一个陷阱，相应的处理程序不禁止可屏蔽中断。</li>
<li><code>DPL</code>(描述符特权级)：置为3。这就允许用户态进程调用这个异常处理程序。</li>
</ul>
<p>因此，当用户态进程发出<code>int $0x80</code>指令时，CPU切换到内核态并开始从地址<code>system_call</code>处开始执行指令。</p>
<h3 id="system-call函数"><a href="#system-call函数" class="headerlink" title="system_call函数"></a>system_call函数</h3><p><code>system_call</code>函数首先把系统调用号和这个异常处理程序可以用到的所有CPU寄存器保存到相应的栈中，不包括由控制单元已自动保存的eflags、cs、eip、ss和esp寄存器。“I/O中断处理”讨论的<code>SAVB_ALL</code>宏也在ds和es中装入内核数据段的段选择符:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">system_call:</span><br><span class="line">    pushl %eax</span><br><span class="line">    SAVE_ALL</span><br><span class="line">    movl $0xffffe000, %ebx</span><br><span class="line">    andl %esp, %ebx</span><br></pre></td></tr></table></figure></p>
<p>随后，这个函数在ebx中存放当前进程的<code>thread_info</code>数据结构的地址，通过获得内核栈指针并把它取整到4KB或8KB的倍数完成的。</p>
<p>接下来<code>system_call</code>检査<code>thread_info</code>结构<code>flag</code>字段的<code>TIF_SYSCALL_TRACE</code>和<code>TIF_SYSCALL_AUDIT</code>标志之一是否被设1，是否有某一调试程序正在跟踪执行程序对系统调用的调用。如果是，<code>system_call()</code>两次调<code>do_syscall_trace()</code>：<strong>在这个系统调用服务例程执行之前</strong>，<strong>在其之后</strong>。这个函数停止<code>current</code>，因此允许调试进程收集关于<code>current</code>的信息。</p>
<p>然后对用户态进程传递来的系统调用号有效性检査，如果大于等于系统调用分派表中的表项数，系统调用处理程序就终止。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmpl $NR_syscalls, %rax</span><br><span class="line">jb nobadsys</span><br><span class="line">movl $(-ENOSYS), 24(%esp)</span><br><span class="line">jmp resume_userspace</span><br><span class="line">nobadsys:</span><br></pre></td></tr></table></figure></p>
<p>如果系统调用号无效，就把-ENOSYS存在栈中曾保存eax的单元（从当前栈顶开始偏移量为24的单元），跳到<code>resume_userspace</code>。当进程恢复它在用户态的执行时，会在eax中发现一个负返回码，最后调用与eax中所包含的系统调用号对应的特定服务例程：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call *sys_call_table(0, %eax, 4)</span><br></pre></td></tr></table></figure></p>
<p>分派表中的每表项占4字节，首先把系统调用号乘以4，再加<code>sys_call_table</code>分派表的起始地址，从这个地址单元获取指向服务例程的指针，内核就找到了要调用的服务例程。</p>
<h3 id="从系统调用退出"><a href="#从系统调用退出" class="headerlink" title="从系统调用退出"></a>从系统调用退出</h3><p>当系统调用服务例程结束时，<code>system_call()</code>函数从eax获得它的返回值，并把这个返回值存放在eax寄存器的那个栈单元上：<code>movl %eax, 24(%esp)</code>。因此用户态进程将在eax中找到系统调用的返回码。</p>
<p>然后，<code>system_call()</code>函数关闭本地中断并检查当前进程的<code>thread_info</code>结构中的标志。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cli</span><br><span class="line">movl 8(%ebp), %ecx</span><br><span class="line">testw $oxffff, %cx</span><br><span class="line">je restore_all</span><br></pre></td></tr></table></figure><br>如果所有的标志都没有被设置，函数就跳转到<code>restore_all</code>标记处的代码恢复保存在内核栈中的寄存器的值，并执行iret汇编指令以重新开始执行用户态进程。</p>
<p>只要有任何一个标志被设置，那么就要在返回用户态之前完成一些工作。如果<code>TIF_SYSCALL_TRACE</code>标志被设置，<code>system_call()</code>函数就第二次调用<code>do_syscall_trace()</code>函数，然后跳转到<code>resume_userspace</code>标记处。否则，如果<code>TIF_SYSCALL_TRACE</code>标志没有被设置，函数就调转到<code>work_pending</code>标记处。在<code>resume_userspace</code>和<code>work_pending</code>标记处的代码检查重新调度请求，虚拟8086模式，挂起信号和单步执行，最终调转到<code>restore_all</code>标记处以恢复用户态进程的执行。</p>
<h3 id="通过sysenter指令发出系统调用"><a href="#通过sysenter指令发出系统调用" class="headerlink" title="通过sysenter指令发出系统调用"></a>通过sysenter指令发出系统调用</h3><p>在Intel文档中被称为<strong>快速系统调用</strong>的<code>sysenter</code>指令，提供了一种<strong>从用户态到内核态的快速切换方法</strong>。</p>
<h4 id="sysenter指令"><a href="#sysenter指令" class="headerlink" title="sysenter指令"></a>sysenter指令</h4><p>汇编语言指令sysenter使用三种特殊的寄存器，它们必须装入下述信息：</p>
<ul>
<li><code>SYSENTER_CS_MSR</code>：内核代码段的段选择符。</li>
<li><code>SYSENTER_EIP_MSR</code>：内核入口点的线性地址。</li>
<li><code>SYSENTER_ESP_MSR</code>：内核堆栈指针。</li>
</ul>
<p>执行sysenter指令时，CPU控制单元：</p>
<ol>
<li>把<code>SYSENTER_CS_MSR</code>的内核拷贝到cs。</li>
<li>把<code>SYSENTER_EIP_MSR</code>的内容拷贝到eip。</li>
<li>把<code>SYSENTER_ESP_MSR</code>的内容拷贝到esp。</li>
<li>把<code>SYSENTER_CS_MSR</code>加8的值装入ss。</li>
</ol>
<p>因此CPU切换到内核态并开始执行内核入口点的第一条指令。</p>
<p>在内核初始化期间，一旦系统中的每个CPU执行函数<code>enable_sep_cpu()</code>，三个特定于模型的寄存器就由该函数初始化了。<code>enable_sep_cpu()</code>函数执行以下步骤：</p>
<ul>
<li>把内核代码(<code>__KERNEL_CS</code>)的段选择符写入<code>SYSENTER_CS_MSR</code>寄存器。</li>
<li>把下面要说明的函数<code>sysenter_enry()</code>的线性地址写入<code>SYSENTER_CS_EIP</code>寄存器。</li>
<li>计算本地TSS末端的线性地址，并把这个值写入<code>SYSENTER_CS_ESP</code>寄存器。</li>
</ul>
<p>系统调用开始的时候，内核栈是空的，因此 esp 寄存器应该执行 4KB 或 8KB 内存区域的末端，该内存区域包括内核堆栈和当前进程的描述符。因为用户态的封装例程不知道该内存区域的地址，因此不能正确设置该寄存器。但必须在切换到内核态之前设置该寄存器的值，因此，内核初始化该寄存器，以便为本地 CPU 的任务状态段编址。每次进程切换时，内核把当前进程的内核栈指针保存到本地 TSS 的 esp0 字段。这样，系统调用处理程序读 esp 寄存器，计算本地 TSS 的 esp0 字段的地址，然后把正确的内核堆栈指针装入 esp 寄存器。</p>
<h4 id="vsyscall页"><a href="#vsyscall页" class="headerlink" title="vsyscall页"></a>vsyscall页</h4><p>只要 CPU 和 Linux 内核都支持 sysenter 指令，标准库 libc 中的封装函数就可以使用它。</p>
<p>本质上，在初始化阶段，<code>sysenter_setup()</code>建立一个称为<code>vsyscall</code>页的页框，它包括一个小的 EFL 共享对象（一个很小的 EFL 动态链接库）。<br>当进程发出<code>execve()</code>系统调用而开始执行一个 EFL 程序时，<code>vsyscall</code>页中的代码就会自动链接到进程的地址空间。<code>vsyscall</code>页中的代码使用最有用的指令发出系统调用。</p>
<p><code>sysenter_setup()</code>为<code>vsyscall</code>页分配一个新页框，并将它的物理地址与<code>FIX_VSYSCALL</code>固定映射的线性地址相关联。然后把预先定义好的多个 EFL 共享对象拷贝到该页中：</p>
<p>如果 CPU 不支持<code>sysenter</code>，<code>sysenter_setup()</code>建立一个包括下列代码的<code>vsyscall</code>页：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__kernel_vsyscall:</span><br><span class="line">	int $0x80</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure></p>
<p>否则，如果 CPU 的确支持<code>sysenter</code>，<code>sysenter_setup()</code>建立一个包括下列代码的<code>vsyscall</code>页：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__kernel_vsyscall:</span><br><span class="line">	pushl %ecx</span><br><span class="line">	push %edx</span><br><span class="line">	push %ebp</span><br><span class="line">	movl %esp, %ebp</span><br><span class="line">	sysenter</span><br></pre></td></tr></table></figure></p>
<p>当标准库中的封装例程必须调用系统调用时，都调用<code>__kernel_vsyscall()</code>。</p>
<p>如果老版本的Linux内核不支持<code>sysenter</code>指令，内核不建立<code>vsyscall</code>页，而且函数<code>__kernel_vsyscall()</code>不会被链接到用户态进程的地址空间。新的标准库识别出这种状况后，简单地执行<code>int $0x80</code>调用系统调用。</p>
<h4 id="进入系统调用"><a href="#进入系统调用" class="headerlink" title="进入系统调用"></a>进入系统调用</h4><p>当用<code>sysenter</code>指令发出系统调用时，依次执行下述步骤：</p>
<ul>
<li>标准库中的封装例程把系统调用号装入<code>eax</code>寄存器，并调用<code>__kernel_vsyscall()</code>。</li>
<li><code>__kernel_vsyscall()</code>把<code>ebp</code>、<code>edx</code>和<code>ecx</code>的内容保存到用户态堆栈中，把用户栈指针拷贝到<code>ebp</code>中，然后执行<code>sysenter</code>指令。</li>
<li>CPU从用户态切换到内核态，内核态开始执行<code>sysenter_entry()</code>（由<code>SYSENTER_EIP_MSR</code>寄存器指向）。</li>
<li><code>sysenter_entry()</code>汇编指令执行下述步骤：<ul>
<li>建立内核堆栈指针：<code>movl -508(%esp), %esp</code><ul>
<li>开始时，esp 寄存器指向本地 TSS 的第一个位置，本地 TSS 的大小为 512 字节。因此，<code>sysenter</code>指令把本地 TSS 中的偏移量为 4 处的字段的内容（即 esp0 字段的内容）装入 esp。</li>
<li>esp0 字段总是存放当前进程的内核堆栈指针。</li>
</ul>
</li>
<li>打开本地中断：<code>sti</code></li>
<li>把用户数据段的段选择符、当前用户栈指针、eflags 寄存器、用户代码段的段选择符及从系统调用退出时要指向的指令的地址保存到内核堆栈：<ul>
<li><code>pushl $(__USER_DS)</code></li>
<li><code>pushl %ebp</code></li>
<li><code>pushfl</code></li>
<li><code>pushl $(__USER_CS)</code></li>
<li><code>pushl $SYSENTER_RETURN</code></li>
</ul>
</li>
<li>把由封装例程传递的寄存器的值恢复到 ebp 中：<code>movl (%ebp), %ebp</code><ul>
<li>该指令完成恢复的工作，因为<code>__kernel_vsyscall()</code>把ebp的原始值存入用户态堆栈中，并随后把用户堆栈指针的当前值装入 ebp 中。</li>
</ul>
</li>
<li>通过执行一系列指令调用系统调用处理程序，这些指令与<code>system_call</code>标记处开始的指令是一样的。</li>
</ul>
</li>
</ul>
<h4 id="退出系统调用"><a href="#退出系统调用" class="headerlink" title="退出系统调用"></a>退出系统调用</h4><p>当系统调用服务例程结束时，<code>sysenter_entry()</code>函数本质上执行与<code>system_call()</code>函数系统的操作。首先，它从eax获得系统调用服务例程的返回码，并将返回码存入内核栈中保存用户态eax寄存器值的位置。然后，函数禁止本地中断，并检查<code>current</code>的<code>thread_info</code>结构中的标志。</p>
<h4 id="sysexit指令"><a href="#sysexit指令" class="headerlink" title="sysexit指令"></a>sysexit指令</h4><p><code>sysexit</code>是与<code>sysenter</code>配对的汇编语言指令：<strong>它允许从内核态快速切换到用户态</strong>。执行这条指令时，CPU控制单元执行下述步骤：</p>
<ol>
<li>把<code>SYSENTER_CS_MSR</code>寄存器中的值加16所得到的结果加载到cs寄存器。</li>
<li>把<code>edx</code>寄存器的内容拷贝到<code>eip</code>寄存器。</li>
<li>把<code>SYSENTER_CS_MSR</code>寄存器中的值加24所得到的结果加载到ss寄存器。</li>
<li>把<code>ecx</code>寄存器的内容拷贝到<code>esp</code>寄存器。</li>
</ol>
<p>因为<code>SYSENTER_CS_MSR</code>寄存器加载的是内核代码的段选择符，cs寄存器加载的是用户代码的段选择符，而ss寄存器加载的是用户数据段的段选择符。结果，CPU从内核态切换到用户态，并开始执行其地址存在edx中的那条指令。</p>
<h4 id="SYSENTER-RETURN的代码"><a href="#SYSENTER-RETURN的代码" class="headerlink" title="SYSENTER_RETURN的代码"></a>SYSENTER_RETURN的代码</h4><p><code>SYSENTER_RETURN</code>标记处的代码存放在<code>vsyscall</code>页中，当通过<code>sysenter</code>进入的系统调用被<code>iret</code>或<code>sysexit</code>指令终止时，该页框中的代码被执行。</p>
<p>该代码恢复保存在用户态堆栈中的ebp、edx和ecx寄存器的原始内容，并把控制权返回给标准库中的封装例程：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSENTER_RETURN:</span><br><span class="line">    popl %ebp</span><br><span class="line">    popl %edx</span><br><span class="line">    popl %ecx</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure></p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>系统调用的输入/输出参数可能是：</p>
<ul>
<li>实际的值</li>
<li>用户态进程地址空间的变量</li>
<li>指向用户态函数的指针的数据结构地址</li>
</ul>
<p>因为<code>system_call()</code>和<code>sysenter_entry()</code>是 Linux 中所有系统调用的公共入口点，因此每个系统调用至少有一个参数，即通过<code>eax</code>寄存器传递进来的系统调用号。</p>
<p>普通C函数的参数传递时通过把参数值写入活动的程序栈（用户态栈或内核态栈）实现的。而<strong>系统调用是一种横跨用户和内核的特殊函数，所以既不能使用用户态栈也不能使用内核态栈</strong>。<strong>在发出系统调用前，系统调用的参数被写入 CPU 寄存器，然后再调用系统调用服务例程前，内核再把存放在 CPU 中的参数拷贝到内核态堆栈中，因为系统调用服务例程是普通的 C 函数</strong>。</p>
<p>为什么内核不直接把参数从用户态的栈拷贝到内核态的栈？</p>
<ul>
<li>同时操作两个栈比较复杂。</li>
<li>寄存器的使用使得系统调用服务处理程序的结构与其他异常处理程序结构类似。</li>
<li>使用寄存器传递参数时，必须满足两个条件：</li>
</ul>
<p>用寄存器传递参数必须满足：</p>
<ul>
<li>每个参数的长度不能超过寄存器的长度，即 32 位。</li>
<li>参数的个数不能超过 6 个（除 eax 中传递的系统调用号），因为寄存器数量有限。</li>
<li>当确实存在多于 6 个参数的系统调用时，用一个单独的寄存器指向进程地址空间中这些参数值所在的一个内存区。</li>
</ul>
<p>用于存放系统调用号和系统调用参数的寄存器是：<strong>eax（系统调用号）、ebx、ecx、edx、esi、edi 及 ebp</strong>。<code>system_call()</code>和<code>sysenter_entry()</code><strong>使用<code>SAVE_ALL</code>宏将这些寄存器的值保存在内核态堆栈中</strong>。</p>
<p>因此，当系统调用服务例程转到内核态堆栈时，就会找到<code>system_call()</code>或<code>sysenter_entry()</code>的返回地址，紧接着时存放在<code>ebx</code>中的参数（系统调用的第一个参数），存放在<code>ecx</code>中的参数等。这种栈结构与普通函数调用的栈结构完全相同，因此，系统调用服务例程很容易通过使用C语言结构引用它的参数。</p>
<p>有时候，服务例程需要知道在发出系统调用前 CPU 寄存器的内容。类型为<code>pt_regs</code>的参数允许服务例程访问由<code>SAVE_ALL</code>宏保存在内核态堆栈中的值：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_fork</span><span class="params">(<span class="keyword">struct</span> pt_regs regs)</span></span><br></pre></td></tr></table></figure></p>
<p>服务例程的返回值必须写入 eax 寄存器。这在执行<code>return n</code>指令时由 C 编译程序自动完成。</p>
<h3 id="验证参数"><a href="#验证参数" class="headerlink" title="验证参数"></a>验证参数</h3><p>有一种检查对所有的系统调用都是通用的。<strong>只要有一个参数指定的是地址，那么内核必须检查它是否在这个进程的地址空间内</strong>。检查方式：</p>
<ul>
<li>验证这个线性地址是否属于进程的地址空间</li>
<li>仅仅验证该线性地址是否小于<code>PAGE_OFFSET</code>（即没有落在留给内核的线性地址区间内）。</li>
</ul>
<p>这是一种非常错略的检查，<strong>真正的检查推迟到分页单元将线性地址转换为物理地址时</strong>。<strong>该粗略的检查确保了进程地址空间和内核地址空间都不被非法访问</strong>。</p>
<p>对系统调用所传递地址的检测是通过<code>access_ok()</code>宏实现的，它有两个分别为<code>addr</code>和<code>size</code>的参数。该宏检查<code>addr</code>到<code>addr+size-1</code>之间的地址区间：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">access_ok</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> a = (<span class="type">unsigned</span> <span class="type">long</span>)addr;</span><br><span class="line">    <span class="keyword">if</span>(a + size &lt; a || a + size &gt; current_thread_info()-&gt;addr_limit.seg)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>验证<code>addr + size</code>是否大于<code>2^32-1</code>，因为 gcc 编译器用 32 位数表示无符号长整数和类型，所以等价于对溢出条件进行检查，检查<code>addr+size</code>是否超过<code>current</code>的<code>thread_info</code>结构的<code>addr_limit.seg</code>存放的值。普通进程通常存放<code>PAGE_OFFSET</code>，内核线程为<code>0xffffffff</code>。可通过<code>get_fs</code>和<code>set_fs</code>宏动态修改<code>addr_limit.seg</code>。</p>
<h3 id="访问进程地址空间"><a href="#访问进程地址空间" class="headerlink" title="访问进程地址空间"></a>访问进程地址空间</h3><p><code>get_user()</code>和<code>put_user()</code>宏可方便系统调用服务例程读写进程地址空间的数据。</p>
<ul>
<li><code>get_user()</code>宏从一个地址读取 1、2 或 4 个连续字节。</li>
<li><code>put_user()</code>宏把 1、2 或 4 个连续字节的内容写入一个地址。</li>
</ul>
<p>参数：</p>
<ul>
<li>要传送的值<code>x</code></li>
<li>一个变量<code>ptr</code>，决定还有多少字节要传送</li>
</ul>
<p>在<code>get_user(x, ptr)</code>中，由<code>ptr</code>指向的变量大小使该函数展开为<code>__get_user_1()</code>、<code>__get_user_2()</code>或<code>__get_user_4()</code>汇编语言函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__get_user_2:</span><br><span class="line">	addl $1, %eax </span><br><span class="line">	jc bad_get_user</span><br><span class="line">	movl $0xffffe000, %edx</span><br><span class="line">	andl %esp, %edx</span><br><span class="line">	cmpl 24(%edx), %eax </span><br><span class="line">	jae bad_get_user</span><br><span class="line"></span><br><span class="line">2:	movzwl -1(%eax), %edx </span><br><span class="line">	xorl %eax, %eax</span><br><span class="line">	ret  </span><br><span class="line"></span><br><span class="line">bad_get_user:</span><br><span class="line">	xorl %edx, %edx</span><br><span class="line">	movl $-EFAULT, %eax</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure></p>
<p><code>eax</code>寄存器包含要读取的第一个字节的地址<code>ptr</code>，前 6 个指令所执行的检查与<code>access_ok()</code>宏相同，即确保要读取的两个字节的地址小于 4GB 并小于<code>current</code>进程的<code>addr_limit.seg</code>字段，这个字段位于<code>current</code>的<code>thread_info</code>结构中便宜为24处，出现在<code>cmpl</code>指令的第一个操作数处。</p>
<p>如果地址有效，执行<code>movzwl</code>指令，把要读的数据存到<code>edx</code>寄存器的两个低字节，两个高字节置 0，然后在<code>eax</code>中设置返回码0并终止。如果地址无效，清<code>edx</code>并将<code>eax</code>置为-EFAULT。</p>
<p><code>put_user(x, ptr)</code>宏类似于<code>get_user</code>，但把值<code>x</code>写入以地址<code>ptr</code>为起始地址的进程地址空间。根据<code>x</code>的大小，使用<code>__put_user_asm()</code>宏，或<code>__put_user_u64()</code>宏，成功写入则在<code>eax</code>寄存器中返回0，否则返回 -EFAULT。</p>
<p>表中列出了内核态下用来访问进程地址空间的另外几个函数或宏。首部没有下划线的函数或宏要用额外的时间对所请求的线性地址区间进行有效检查，而有下划线的则会跳过检查。<br><img src="/img/1602827720.jpg" alt=""></p>
<h3 id="动态地址检查：修正代码"><a href="#动态地址检查：修正代码" class="headerlink" title="动态地址检查：修正代码"></a>动态地址检查：修正代码</h3><p><code>access_ok()</code>宏仅对以参数传入的线性地址空间进行粗略检查，<strong>保证用户态进程不会试图侵扰内核地址空间</strong>。但线性地址仍然可能不属于进程地址空间，这时，内核使用该地址时，会发生缺页异常。</p>
<p>缺页异常处理程序区分在内核态引起缺页异常的四种情况，并进行相应处理：</p>
<ul>
<li>内核试图访问属于进程地址空间的页，但是，相应的页框可能不存在，或内核试图写一个只读页。此时，处理程序必须分配和初始化一个新的页框（请求调页、写时复制）。</li>
<li>内核试图访问属于内核地址空间的页，但是，相应的页表项还没有初始化（处理非连续内存区访问）。此时，内核必须在当前进程页表中适当建立一些表项。</li>
<li>某一个内核函数包含编程错误，导致函数运行时引起异常；或者，可能由于瞬时的硬件错误引起异常。此时，处理程序必须执行一个内核漏洞（处理地址空间以外的错误地址）。</li>
<li>系统调用服务例程试图读写一个内存区，该内存区的地址以系统调用参数传入，但不属于进程的地址空间。</li>
</ul>
<h2 id="异常表"><a href="#异常表" class="headerlink" title="异常表"></a>异常表</h2><p>只有少数的函数和宏访问进程的地址空间；因此，<strong>如果异常是由一个无效的参数引起的，那么引起异常的指令一定包含在其中一个函数或展开的宏中</strong>。对用户空间寻址的指令非常少。因此，可把访问进程地址空间的每条内核指令的地址放到一个叫<strong>异常表</strong>的结构中。</p>
<p>当内核态发生缺页异常时，<code>do_page_fault()</code>处理程序检查异常表：</p>
<ul>
<li>如果表中包含产生异常的指令地址，则该错误就是由非法的系统调用参数引起的，</li>
<li>否则，就是由某一严重的 bug 引起的。</li>
</ul>
<p>Linux 定义了几个异常表。主要的异常表在建立内核程序映像时，由 C 编译器自动生成。它存放在内核代码段的<code>__ex_table</code>节，起始地址和终止地址由 C 编译器产生的两个符号<code>__start__ex_table</code>和<code>__stop__ex_table</code>标识。</p>
<p>此外，<strong>每个动态装载的内核模块都包含自己的局部异常表</strong>。该表在建立模块映像时，由 C 编译器自动产生，在把模块插入到运行中的内核时，该表被装入内存。</p>
<p>每个异常表的表项是一个<code>exception_table_entry</code>结构，有两个字段：</p>
<ul>
<li><code>insn</code>，访问进程地址空间的指令的线性地址。</li>
<li><code>fixup</code>，存放在<code>insn</code>单元中的指令所触发的缺页异常发生时，<code>fixup</code>就是要调用的汇编语言代码地址。</li>
</ul>
<p>修正代码由几条汇编指令组成，用以解决由缺页异常所引起的问题。<strong>修正通常由插入的一个指令序列组成，该指令序列强制服务例程向用户态进程返回一个出错码</strong>。这些指令通常在访问进程地址空间的同一函数或宏中定义；由 C 编译器把它们放置在内核代码段的一个叫<code>.fixup</code>的独立部分。</p>
<p><code>search_exception_tables()</code>在所有异常表中查找一个指定地址：若该地址在某一个表中，则返回指向相应<code>exception_table_entry</code>结构的指针；否则，返回 NULL。因此，缺页处理程序<code>do_page_fault()</code>执行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fixup = search_exception_tables(regs-&gt;eip))</span><br><span class="line">&#123;</span><br><span class="line">	regs-&gt;eip = fixup-&gt;fixup;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>regs-&gt;eip</code>字段包含异常发生时保存到内核态栈<code>eip</code>寄存器中的值。如果<code>eip</code>寄存器中的该值在某个异常表中，<code>do_page_fault()</code>把<code>regs-&gt;eip</code>保存的值替换为<code>search_exception_tables()</code>的返回地址。缺页处理程序终止，被中断的程序恢复运行。</p>
<h3 id="生成异常表和修正代码"><a href="#生成异常表和修正代码" class="headerlink" title="生成异常表和修正代码"></a>生成异常表和修正代码</h3><p>GNU 汇编程序伪指令<code>.section</code>允许程序员<strong>指定可执行文件的哪部分包含紧接着要执行的代码</strong>。可执行文件包含一个代码段，该代码段可能被划分为节。下边的代码在异常表中加入一个表项：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.section __ex_table, <span class="string">&quot;a&quot;</span></span><br><span class="line">	.<span class="type">long</span> faulty_instruction_address, fixup_code_address</span><br><span class="line">.previous</span><br></pre></td></tr></table></figure><br><code>.previous</code>伪指令强制汇编程序把紧接着的代码插入到遇到上一个<code>.section</code>伪指令时激活的节。</p>
<p>前边讨论过的<code>__get_user_1()</code>、<code>__get_user_2()</code>或<code>__get_user_4()</code>函数，访问进程地址空间的指令用1、2、3标记。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">__get_user_1:</span><br><span class="line">	[...]</span><br><span class="line">1: movzbl (%eax), %edx  </span><br><span class="line">	[...]</span><br><span class="line">	</span><br><span class="line">__get_user_2:</span><br><span class="line">	[...]</span><br><span class="line">2: movzwl -1(%eax), %edx</span><br><span class="line">	[...]</span><br><span class="line">	</span><br><span class="line">__get_user_4:</span><br><span class="line">	[...]</span><br><span class="line">3: 	movl -3(%eax), %edx</span><br><span class="line">	[...]</span><br><span class="line"></span><br><span class="line">bad_get_user:</span><br><span class="line">	xorl %edx, %edx</span><br><span class="line">	movl $-EFAULT, %eax</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">.section __ex_table, &quot;a&quot;</span><br><span class="line">	.long 1b, bad_get_user</span><br><span class="line">	.long 2b, bad_get_user</span><br><span class="line">	.long 3b, bad_get_user</span><br><span class="line">.previous</span><br></pre></td></tr></table></figure></p>
<p>每个异常表项由两个标号组成，第一个是标号，前缀 “b” 表示”向后的”，标号出现在程序的前一行。修正代码对这三个函数是公用的，被标记为<code>bad_get_user</code>，如果缺页异常是由标号 1、2 或 3 处的指令产生的，则修正代码就执行。<code>bad_get_user</code>修正代码给发出系统调用的进程只简单地返回一个出错码 -EFAULT。</p>
<p>其他作用于用户态地址空间的内核函数也使用修正代码技术。比如<code>strlen_user(string)</code>宏，返回系统调用中<code>string</code>参数的长度，<code>string</code>以null结尾；出错时返回 0。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">strlen_user(<span class="built_in">string</span>)：</span><br><span class="line">	mvol $<span class="number">0</span>, %eax</span><br><span class="line">	movl $<span class="number">0x7fffffff</span>, %ecx  </span><br><span class="line">	movl %ecx, %ebx</span><br><span class="line">	movl <span class="built_in">string</span>, %edi</span><br><span class="line"><span class="number">0</span>:	repne; scabsb</span><br><span class="line">	subl %ecx, %ebx</span><br><span class="line">	movl %ebx, %eax</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>:	</span><br><span class="line">.section .fixup, <span class="string">&quot;ax&quot;</span></span><br><span class="line"><span class="number">2</span>:	xorl %eax, %eax  </span><br><span class="line">	jmp <span class="number">1b</span> </span><br><span class="line">	</span><br><span class="line">.previous</span><br><span class="line"></span><br><span class="line">; 在 __ex_table 中增加一个表项</span><br><span class="line">; 内容包括 repne; scasb 指令的地址和相应的修正代码的地址</span><br><span class="line">.section __ex_table, <span class="string">&quot;a&quot;</span></span><br><span class="line">	.<span class="type">long</span> <span class="number">0b</span>, <span class="number">2b</span></span><br><span class="line">	</span><br><span class="line">.previous</span><br></pre></td></tr></table></figure></p>
<p><code>ecx</code>和<code>ebx</code>寄存器的初始值设置为 0x7fffffff，表示用户态地址空间字符串的最大长度。<code>repne; scabsb</code>循环扫描由<code>edi</code>指向的字符串，在<code>eax</code>中查找值为0的字符（字符串的结尾标志 \0）。因为每一次循环<code>scasb</code>都将<code>ecx</code>减1，所以<code>eax</code>中最后存放字符串长度。修正代码被插入到<code>.fixup</code>节。<code>ax</code>属性指定该节必须加载到内存且包含可执行代码。如果缺页异常是由标号为 0 的指令引起，就执行修正代码，它只简单地把<code>eax</code>置为 0，因此强制该宏返回一个出错码 0 而不是字符串长度，然后跳转到标号 1，即宏之后的相应指令。</p>
<p>第二个<code>.section</code>指令在<code>__ex_table</code>中增加一个表项，内容包括<code>repne; scsab</code>指令地址和相应的修正代码地址。</p>
<h2 id="内核封装例程"><a href="#内核封装例程" class="headerlink" title="内核封装例程"></a>内核封装例程</h2><p><strong>系统调用也可以被内核线程调用，内核线程不能使用库函数</strong>。为了简化相应的封装例程的声明，Linux 定义了 7 个从<code>_syscall0</code>到<code>_syscall6</code>的一组宏。</p>
<p>每个宏名字中的数字 0~6 对应着系统调用所用的参数个数（系统调用号除外）。也可以用这些宏来声明没有包含在 libc 标准库中的封装例程。然而，不能用这些宏来为超过 6 个参数（系统调用号除外）的系统调用或返回非标准值的系统调用封装例程。</p>
<p>每个宏严格地需要 2+2*n 个参数，n 是系统调用的参数个数。前两个参数指明返回值类型和名字；后面的每一对附加参数指明参数的类型和名字。以<code>fork()</code>系统调用为例，其封装例程可以通过如下语句产生：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_syscall0(<span class="type">int</span>, fork)</span><br></pre></td></tr></table></figure><br>而<code>write()</code>系统调用的封装例程可通过如下语句产生：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_syscall3(<span class="type">int</span>, write, <span class="type">int</span>, fd, <span class="type">const</span> <span class="type">char</span> *, buf, <span class="type">unsigned</span> <span class="type">int</span>, count)</span><br></pre></td></tr></table></figure><br>展开如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *buf, usninged <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> __res;</span><br><span class="line">	adm(<span class="string">&quot;int $0x80&quot;</span>, </span><br><span class="line">		: <span class="string">&quot;0&quot;</span> (__NR_write), <span class="string">&quot;b&quot;</span> ((<span class="type">long</span>)fd),</span><br><span class="line">		  <span class="string">&quot;c&quot;</span> ((<span class="type">long</span>)buf), <span class="string">&quot;d&quot;</span> ((<span class="type">long</span>)count));</span><br><span class="line">	<span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>)__res &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)<span class="number">-129</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		errno = -__res;</span><br><span class="line">		__res = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">int</span>)__res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>__NR_write</code>宏来自<code>_syscall3</code>的第二个参数；它可展开成 write() 的系统调用号，当编译前面的函数时，产生如下汇编代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">write:</span><br><span class="line">	pushl ebx			; 将 ebx 入栈</span><br><span class="line">	movl 8(%esp), %ebx	; 第一个参数放入 ebx</span><br><span class="line">	movl 12(%esp), %ecx	; 第二个参数放入 ecx</span><br><span class="line">	mvol 16(%esp), %edx	; 第三个参数放入 edx</span><br><span class="line">	movll $4, %eax		; __NR_write 放入 eax</span><br><span class="line">	int $0x80			; 调用系统调用</span><br><span class="line">	cmpl $-125, %eax		; 检测返回码</span><br><span class="line">	jbe .L1				; 如果无错则跳转</span><br><span class="line">	negl %eax			; 求 eax 的补码</span><br><span class="line">	movl %eax, errno		; 结果放入 errno</span><br><span class="line">	movl -1, %eax		; eax 置为 -1</span><br><span class="line">.L1:	popl %ebx		; 从堆栈弹出 ebx</span><br><span class="line">	ret					; 返回调用程序</span><br></pre></td></tr></table></figure></p>
<p>如果 eax 中的返回值在 -1~-129 之间，则被解释为出错码，在 errno 中存放 -eax 的值并返回 -1；否则，返回 eax 中的值。</p>
<h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="信号的作用"><a href="#信号的作用" class="headerlink" title="信号的作用"></a>信号的作用</h2><p>信号是很短的消息，可以被发送到一个进程或一组进程。<strong>发送给进程的唯一信息通常是一个数，来标识信号</strong>。前缀为<code>SIG</code>的一组宏标识信号。如，当一个进程引用无效的内存时，<code>SIGSEGV</code>宏产生发送给进程的信号标识符。</p>
<p>使用信号的两个目的：</p>
<ul>
<li>让进程知道已经发生了一个特定的事件。</li>
<li>强迫进程执行自己代码中的信号处理程序。</li>
</ul>
<p><img src="/img/1602756712.png" alt=""></p>
<p>POSIX 标准还引入了<strong>实时信号</strong>，编码范围为 32~64。不同于常规信号，<strong>它们必须排队，以便发送的多个信号都能被接收到</strong>。而同种类型的常规信号并不排队：<strong>如果一个常规信号被连续发送多次，则只有其中一个发送到接收进程</strong>。Linux 内核不使用实时信号，但通过几个特定的系统调用实现了 POSIX 标准。</p>
<p>许多系统调用允许程序员发送信号并决定他们的进程如何响应接收的信号。<br><img src="/img/1602756713.png" alt=""></p>
<p>信号的一个重要特点是它们可以随时被发送给状态经常不可预知的进程。发送给非运行进程的信号必须由内核保存，直到进程恢复执行。阻塞一个信号会拖延信号的传递，直到阻塞解除。因此，内核区分信号传递的两个不同阶段：</p>
<ul>
<li><strong>信号产生</strong>。内核更新目标进程的数据结构，以表示一个新信号已经被发送。</li>
<li><strong>信号传递</strong>。内核强迫目标进程通过以下方式对信号做出反应：或改变目标进程的执行状态，或开始执行一个特定的信号处理程序，或两者都是。</li>
</ul>
<p>每个产生的信号之多被传递一次。<strong>信号是可消费资源：一旦已经传递出去，进程描述符中有关该信号的所有信息都被取消</strong>。</p>
<p>已经产生但还没有传递的信号被称为<strong>挂起信号</strong>。任何时候，一个进程仅保存特定类型的一个挂起信号，同一进程同种类型的其他信号不被排队，只被简单地丢弃。但对于实时信号，同种类型的挂起信号可以有好几个。</p>
<p>一般，<strong>信号可以保留不可预知的挂起时间</strong>，必须考虑下列因素：</p>
<ul>
<li><strong>信号通常只被当前正在运行的进程（current）传递</strong>。</li>
<li><strong>给定类型的信号可以由进程选择性地阻塞</strong>。此时，在取消阻塞前进程将不接受该信号。</li>
<li><strong>当进程执行一个信号处理程序的函数时，通常“屏蔽”相应的信号，即自动阻塞该信号直到处理程序结束</strong>。</li>
</ul>
<p>因此，所处理的信号另一次出现不能中断信号处理程序，所以<strong>信号处理函数不必是可重入的</strong>。</p>
<p>信号的内核实现比较复杂，内核必须：</p>
<ul>
<li>记住每个进程阻塞哪些信号。</li>
<li>当从内核态切换到用户态时，对任何一个进程都要检查是否有一个信号已经到达。这几乎在每个定时中断时都发生。</li>
<li>确定是否可忽略该信号。发生在下列条件都满足时：<ul>
<li>目标进程没有被另一个进程跟踪（进程描述符中<code>ptrace</code>字段的<code>PT_PTRACED</code>的标志等于 0）。</li>
<li>信号没有被目标进程阻塞。</li>
<li>信号被目标进程忽略。</li>
</ul>
</li>
<li>处理这样的信号，即<strong>信号可能在进程运行期的任意时刻请求把进程切换到一个信号处理函数，并在这个函数返回后恢复原来执行的上下文</strong>。</li>
<li>此外，还需考虑兼容性。</li>
</ul>
<h3 id="传递信号之前所执行的操作"><a href="#传递信号之前所执行的操作" class="headerlink" title="传递信号之前所执行的操作"></a>传递信号之前所执行的操作</h3><p>进程以三种方式对一个信号做出应答：</p>
<ul>
<li>显式地忽略信号。</li>
<li>执行与信号相关的<strong>缺省操作</strong>。由内核预定义的缺省操作取决于信号的类型：<ul>
<li>Terminate，进程被终止</li>
<li>Dump，进程被终止，如果可能，创建包含进程执行上下文的<strong>核心转储文件</strong>，该文件可用于调试。</li>
<li>Ignor，信号被忽略。</li>
<li>Stop，进程被停止，即把进程设置为<code>TASK_STOPPED</code>状态。</li>
<li>Continue，如果进程被停止，就把它设置为<code>TASK_RUNNING</code>状态。</li>
</ul>
</li>
<li>通过调用相应的信号处理函数捕获信号。</li>
</ul>
<p>对一个信号的阻塞和忽略是不同的：</p>
<ul>
<li>只要信号被阻塞，就不被传递；只有在信号解除阻塞后才传递。</li>
<li>而一个被忽略的信号总是被传递，只是没有进一步的操作。</li>
</ul>
<p><code>SIGKILL</code>和<code>SIGSTOP</code>信号不可被显式忽略、捕获或阻塞，因此，通常必须执行它们的缺省操作。因此，<code>SIGKILL</code>和<code>SIGSTOP</code>分别允许<strong>具有适当特权的用户终止、停止任何进程，不管程序执行时采取怎样的防御措施</strong>。</p>
<p>如果某个信号的传递导致内核杀死一个进程，那么该信号对进程就是<strong>致命</strong>的。致命的信号包括：</p>
<ul>
<li>SIGKILL 信号</li>
<li>缺省操作为 Terminate 的每个信号</li>
<li>不被进程捕获的信号对于该进程是致命的</li>
</ul>
<p>如果一个被进程捕获的信号，对应的信号处理函数终止了该进程，那么该信号就不是致命的，因为进程自己选择了终止，而不是被内核杀死。</p>
<h3 id="POSIX-信号和多线程应用"><a href="#POSIX-信号和多线程应用" class="headerlink" title="POSIX 信号和多线程应用"></a>POSIX 信号和多线程应用</h3><p>POSXI 1003.1 标准对多线程应用的信号处理有一些严格的要求：</p>
<ul>
<li>信号处理程序必须在多线程应用的所有线程之间共享；不过，<strong>每个线程必须有自己的挂起信号掩码和阻塞信号掩码</strong>。</li>
<li>POSIX库函数<code>kill()</code>和<code>sigqueue()</code>必须向所有的多线程应用而不是某个特殊的线程发送信号。所有由内核产生的信号同样如此。</li>
<li>每个发送给多线程应用的信号仅传送给一个线程，这个线程是由内核在从不阻塞该信号的线程中随意选择出来的。</li>
<li>如果向多线程应用发送了一个致命的信号，那么内核将被杀死该应用的所有线程，而不仅仅是杀死接收信号的那个线程。</li>
</ul>
<p>为遵循 POSIX 标准，<strong>Linux 内核把多线程应用实现为一组属于同一个线程组的轻量级进程</strong>。</p>
<p>如果一个挂起信号被发送给了某个特定进程，那么该信号是私有的；如果被发送给了整个线程组，它就是共享的。</p>
<h3 id="与信号相关的数据结构"><a href="#与信号相关的数据结构" class="headerlink" title="与信号相关的数据结构"></a>与信号相关的数据结构</h3><p>内核使用几个从处理器描述符可存取的数据结构：<br><img src="/img/1602914223.jpg" alt=""></p>
<p>与信号处理相关的进程描述符中的字段：<br><img src="/img/1602914276.jpg" alt=""></p>
<p>进程描述符中的<code>blocked</code>字段存放<strong>进程当前所屏蔽的信号</strong>。它是一个<code>sigset_t</code>位数组，每种信号类型对应一个元素：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sig[<span class="number">2</span>];</span><br><span class="line">&#125;<span class="type">sigset_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>每个无符号长整数由 32 位组成，所以信号最大数是64，信号的编号对应于<code>sigset_t</code>位数组中相应位的下标 + 1。1 ~ 31 之间的编号对应于常规信号，32 ~ 64之间的编号对应于实时信号。</p>
<h4 id="信号描述符和信号处理程序描述符"><a href="#信号描述符和信号处理程序描述符" class="headerlink" title="信号描述符和信号处理程序描述符"></a>信号描述符和信号处理程序描述符</h4><p>进程描述符的<code>signal</code>字段指向<strong>信号描述符</strong>—一个<code>signal_struct</code>类型的结构，用来跟踪共享挂起信号。信号描述符还包括与信号处理关系不密切的一些字段，如</p>
<ul>
<li><code>rlim</code>，每进程的资源限制数组</li>
<li><code>pgrp</code>，进程的组领头进程 PID</li>
<li><code>session</code>，进程的会话领头进程 PID</li>
</ul>
<p>信号描述符被属于同一线程组的所有进程共享，即被调用<code>clone()</code>系统调用（设置<code>CLONE_SIGHAND</code>标志）创建的所有进程共享，因此，<strong>对属于同一线程组的每个进程而言，信号描述符中的字段必须都是相同的</strong>。<br><img src="/img/1602914819.jpg" alt=""></p>
<p>每个进程还有<strong>信号处理程序描述符</strong>，是一个<code>sighand_struct</code>类型的结构，用来描述每个信号必须如何被线程组处理。<br><img src="/img/1602914868.jpg" alt=""></p>
<p>调用<code>clone()</code>时设置<code>CLONE_SIGHAND</code>标志，信号处理程序描述符就可以被几个进程共享。描述符的<code>count</code>字段表示共享该结构的进程个数。在一个POSIX的多线程应用中，线程组中的所有轻量级进程都应该用相同的信号描述符和信号处理程序描述符。</p>
<h4 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h4><p>信号的特性存放在<code>k_sigaction</code>结构中，既包含对用户态进程所隐藏的特性，也包含<code>sigaction</code>结构。字段：</p>
<ul>
<li><code>sa_handler</code>，指定执行操作的类型。它的值可以是指向信号处理程序的一个指针，<code>SIG_EFL</code>，或<code>SIG_IGN</code>。</li>
<li><code>sa_flags</code>，标志集，指定必须怎样处理信号。</li>
<li><code>sa_mask</code>，类型为<code>sigset_t</code>的变量，指定当运行信号处理程序时要屏蔽的信号。</li>
</ul>
<p><img src="/img/1602915019.jpg" alt=""><br><img src="/img/1602915046.jpg" alt=""></p>
<h4 id="挂起信号队列"><a href="#挂起信号队列" class="headerlink" title="挂起信号队列"></a>挂起信号队列</h4><p>为了跟踪当前的挂起信号是什么，内核把<strong>两个挂起信号队列</strong>与每个进程关联：</p>
<ul>
<li><strong>共享挂起信号队列</strong>，位于信号描述符的<code>shared_pending</code>字段，存放这个线程组的挂起信号。</li>
<li><strong>私有挂起信号队列</strong>，位于进程描述符的<code>pending</code>字段，存放特定进程的挂起信号。</li>
</ul>
<p>挂起信号队列由<code>sigpending</code>数据结构组成，定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">singpengding</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="type">sigset_t</span> signal;  <span class="comment">// 指定挂起信号的位掩码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>signal</code>字段是指定挂起信号的位掩码，而<code>list</code>字段是包含<code>sigqueue</code>的双向链表的头，<code>sigqueue</code>的字段如表：<br><img src="/img/1602915258.jpg" alt=""></p>
<p><code>siginfo_t</code>是一个128字节的数据结构，存放有关出现特定信号的信息，包含下列字段：</p>
<ul>
<li><code>si_signo</code>，信号编号</li>
<li><code>si_errno</code>，引起信号产生的指令的出错码，没有错误则为 0</li>
<li><code>si_code</code>，发送信号者的代码</li>
</ul>
<p><img src="/img/1602915321.jpg" alt=""></p>
<ul>
<li><code>_sifields</code>，依赖于信号类型的信息的联合体，相对于<code>SIGKILL</code>信号，<code>siginfo_t</code>在这里记录发送者进程的PID和UID。</li>
</ul>
<h3 id="在信号数据结构上的操作"><a href="#在信号数据结构上的操作" class="headerlink" title="在信号数据结构上的操作"></a>在信号数据结构上的操作</h3><p>下面的<code>set</code>是指向<code>sigset_t</code>类型变量的一个指针，<code>nsig</code>是信号的编号，<code>mask</code>是无符号长整数的位掩码。</p>
<ul>
<li><code>sigemptyset(set)</code>和<code>sigfillset(set)</code>：把<code>set</code>中的位分别置为 0 或 1。</li>
<li><code>sigaddset(set, nsig)</code>和<code>sigdelset(set, nsig)</code>：把<code>nsig</code>信号在<code>set</code>中对应的位分别置为 1 或 0。<code>sigaddset()</code>简化为：<code>set-&gt;sig[(nsig-1) / 32] |= 1UL &lt;&lt; ((nsig - 1) % 32);</code>，<code>sigdelset()</code>简化为：<code>set-&gt;sig[(nsig-1) / 32] |= ~(1UL &lt;&lt; ((nsig - 1) % 32));</code></li>
<li><code>sigaddsetmask(set, mask)</code>和<code>sigdelsetmask(set, mask)</code>：把<code>mask</code>中的位在<code>set</code>中对应的所有位分别设置为 1 或 0。仅用于编号为 1~32 之间的信号，可分别简化为：<code>set-&gt;sig[0] |= mask;</code>，<code>set-&gt;sig[0] |= ~mask;</code></li>
<li><code>sigismember(set, nsig)</code>：返回<code>nsig</code>信号在<code>set</code>中对应的值。可简化为：<code>return  1 &amp; (set-&gt;sig[(nsig - 1) / 32] &gt;&gt; ((nsig - 1) % 32));</code></li>
<li><code>sigmask(nsig)</code>：产生<code>nsig</code>信号的位索引。如果内核需要设置、清除或测试一个特定信号在<code>sigset_t</code>类型变量中对应的位，可通过该宏得到合适的位。</li>
<li><code>sigandsets(d, s1, s2)</code>、<code>sigoresets(d, s1, s2)</code>和<code>signandsets(d, s1, s2)</code>：在<code>sigset_t</code>类型的s1和s2变量之间分别执行逻辑“与”、逻辑“或”即逻辑“与非”。结果保存在d指向的<code>sigset_t</code>类型的变量中。</li>
<li><code>sigtestsetmask(set, mask)</code>：如果<code>mask</code>在<code>set</code>中对应的任意一位被设置，就返回 1；否则返回 0，只用于编号为 1 ~ 31。</li>
<li><code>siginitset(set, mask)</code>：把<code>mask</code>中的位初始化为 1 ~ 32 之间的信号在<code>set</code>中对应的低位，并把 33 ~ 63 之间信号的对应位清 0。</li>
<li><code>siginitsetinv(set, mask)</code>：用<code>mask</code>中位的补码初始化 1 ~ 32 间的信号在<code>sigset_t</code>类型的变量中对应的低位，并把 33 ~ 63 之间信号的对应位置位。</li>
<li><code>signal_pending(p)</code>：如果<code>*p</code>进程描述符所表示的进程有非阻塞的挂起信号，就返回 1，否则返回 0。通过检查进程的<code>TIF_SIGPENDING</code>标志实现。</li>
<li><code>recalc_sigpending_tsk(t)</code>和<code>recalc_sigpending()</code>：第一个函数检查是<code>*t</code>进程描述符表示的进程有挂起信号（<code>t-&gt;pending-&gt;signa</code>)，还是进程所属的线程组有挂起的信号（<code>t-&gt;signal-&gt;shared_pending-&gt;signal</code>），然后把<code>t-&gt;thread_info-&gt;flags</code>的<code>TIF_SIGPENDING</code>标志置位。第二个函数等价于<code>recalc_sigpending_tsk(current)</code>。</li>
<li><code>rm_from_queue(mask, q)</code>：从挂起信号队列<code>q</code>中删除与<code>mask</code>位掩码相对应的挂起信号。</li>
<li><code>flush_sigqueue(q)</code>：从挂起信号队列<code>q</code>中删除所有的挂起信号。</li>
<li><code>flush_signals(t)</code>：删除发送给<code>*t</code>进程描述符所表示的进程的所有信号。通过清除<code>t-&gt;thread_info-&gt;flags</code>中的<code>TIF_SIGPENDING</code>标志，并在 <code>t-&gt;pending</code>和<code>t-&gt;signal-&gt;shared_pending</code>队列上两次调用<code>flush_sigqueue()</code>实现。</li>
</ul>
<h2 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h2><p>当发送给进程或整个线程组一个信号时，该信号可能来自内核，也可能来自另一个进程。内核通过对表中的某个函数进行调用而产生信号：<br><img src="/img/1602922244.jpg" alt=""></p>
<p>表中的所有函数在结束时都会调用<code>specific_send_sig_info()</code>。</p>
<p>一个信号被发往整个线程组时，这个信号可来自内核，也可能来自另一个进程，内核对表中的函数进行调用来产生这类信号：<br><img src="/img/1602922373.jpg" alt=""></p>
<p>表中的所有函数在结束时都会调用<code>group_send_sig_info()</code>。</p>
<h3 id="specific-send-sig-info"><a href="#specific-send-sig-info" class="headerlink" title="specific_send_sig_info()"></a>specific_send_sig_info()</h3><p>向指定进程发送信号，参数：</p>
<ul>
<li><code>sig</code>，信号编号。</li>
<li><code>info</code>，或者是<code>siginfo_t</code>表的地址，或者是三个特殊值中的一个：<ul>
<li>0：信号由用户态进程发送。</li>
<li>1：信号由内核发送。</li>
<li>2：由内核发送的<code>SIGSTOP</code>或<code>SIGKILL</code>信号。</li>
</ul>
</li>
<li><code>t</code>：指向目标进程描述符的指针。</li>
</ul>
<p>必须在关本地中断和已经获得<code>t-&gt;sighand-&gt;siglock</code>自旋锁的情况下调用该函数，执行下列步骤：</p>
<ul>
<li>检查进程是否忽略信号，如果是就返回 0（不产生信号）。以下三个条件都满足时，信号被忽略：<ul>
<li>进程没有被跟踪（<code>t-&gt;ptrace</code>中的<code>PT_PTRACED</code>标志被清 0）</li>
<li>信号没有被阻塞（<code>sigismember(&amp;t-&gt;blocked, sig)</code>返回 0）</li>
<li>或者显示地忽略信号（<code>t-&gt;sighand-&gt;action[sig-1].sa_handler == SIG_IGN</code>），或者隐含地忽略信号（<code>sa_handler == SIGDFL</code>，且信号是<code>SIGCONT</code>、<code>SIGCHLD</code>、<code>SIGWINCH</code>或<code>SIGURG</code>）</li>
</ul>
</li>
<li>如果信号是非实时的（sig &lt; 32），且在进程的私有挂起信号队列上已经有另外一个相同的挂起信号（<code>sigismember(&amp;t-&gt;pending.signal, sig)</code>返回 1），什么都不需要做，返回0。</li>
<li>调用<code>send_signal(sig, info, t, &amp;t-&gt;pending)</code>把信号添加到进程的挂起信号集合中。</li>
<li>如果<code>send_signal()</code>成功结束，且信号不被阻塞（<code>sigismember(&amp;t-&gt;blocked,sig)</code>返回0），<code>signal_wake_up()</code>通知进程有新的挂起信号，随后，该函数执行下述步骤：</li>
<li>把<code>t-&gt;thread_info-&gt;flags</code>中的<code>TIF_SIGPENDING</code>标志置位。</li>
<li>如果进程处于<code>TASK_INTERRUPTILE</code>或<code>TASK_STOPPED</code>状态，且信号是<code>SIGKILL</code>，<code>try_to_wake_up()</code>唤醒进程。</li>
<li>如果<code>try_to_wake_up()</code>返回 0，说明进程已经是可运行的：检查进程是否已经在另外一个 CPU 上运行，如果是就像那个 CPU 发送一个处理器间中断，以强制当前进程的重新调度。<br>因为从调度函数返回时，每个进程都检查是否存在挂起信号，因此，处理器间中断保证了目标进程能很快注意到新的挂起信号。</li>
<li>返回 1（成功产生信号）。</li>
</ul>
<h3 id="send-signal"><a href="#send-signal" class="headerlink" title="send_signal()"></a>send_signal()</h3><p>在挂起信号队列中插入一个新元素。参数：</p>
<ul>
<li>信号编号<code>sig</code></li>
<li><code>siginfo_t</code>数据结构的地址<code>info</code></li>
<li>目标进程描述符的地址<code>t</code></li>
<li>挂起信号队列的地址<code>signals</code></li>
</ul>
<p>执行下列步骤：</p>
<ol>
<li>如果<code>info == 2</code>，该信号就是<code>SIGKILL</code>或<code>SIGSTOP</code>，且已经由内核通过<code>force_sig_specific()</code>产生：跳到第 9 步，内核立即强制执行与这些信号相关的操作，因此函数不用把信号添加到挂起信号队列中。</li>
<li>如果进程拥有者的挂起信号的数量（<code>t-&gt;user-&gt;sigpending</code>）小于当前进程的资源限制（<code>t-&gt;signal-&gt;rlim[RLIMT_SIGPENDING].rlim_cur</code>），就为新出现的信号分配<code>sigqueue</code>数据结构：<code>q = kmeme_cache_alloc(sigqueue_cachep, GFP_ATOMIC);</code></li>
<li>如果进程拥有者的挂起信号的数量太多，或上一步的内存分配失败，就跳转到到第 9 步。</li>
<li>递增拥有者挂起信号的数量（<code>t-&gt;user-&gt;sigpending</code>）和<code>t-&gt;user</code>所指向的每用户数据结构的引用计数器。</li>
<li>在挂起信号队列<code>signals</code>中增加<code>sigqueue</code>数据机构：<code>list_add_tail(&amp;q-&gt;list, &amp;signals-&gt;list);</code></li>
<li><p>在<code>sigqueue</code>数据结构中填充表<code>siginfo_t</code>：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>)info == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	q-&gt;info.si_signo = sig;</span><br><span class="line">	q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">	q-&gt;info.si_code = SI_USER;</span><br><span class="line">	q-&gt;info._sifields._kill._pid = current-&gt;pid;</span><br><span class="line">	q-&gt;info._sifields._kill._uid = current-&gt;uid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>)info == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	q-&gt;info.si_signo = sig;</span><br><span class="line">	q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">	q-&gt;info.si_code = SI_KERNEL;</span><br><span class="line">	q-&gt;info._sifields._kill._pid = <span class="number">0</span>;</span><br><span class="line">	q-&gt;info._sifiields._kill._uid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	copy_siginfo(&amp;q-&gt;info, info);  <span class="comment">// 复制由调用者传递的 siginfo_t 表</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把队列位掩码中与信号相应的位置 1：<code>sigaddset(&amp;signals-&gt;signal, sig);</code></p>
</li>
<li>返回 0：说明信号已经被成功追加到挂起信号队列中。</li>
<li><p>此时，不再向信号挂起队列中增加元素，因为已经有太多的挂起信号，或已经没有可以分给<code>sigqueue</code>数据结构的空闲空间，或者信号已经由内核强制立即发送。如果信号是实时的，并已经通过内核函数发送给队列排队，则<code>send_signal()</code>返回错误代码 -EAGIN：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sig &gt;= <span class="number">32</span> &amp;&amp; info &amp;&amp; (<span class="type">unsigned</span> <span class="type">long</span>)info != <span class="number">1</span> &amp;&amp; info-&gt;si_code != SI_USER)</span><br><span class="line">	<span class="keyword">return</span> -EAGIN;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置队列的位掩码中与信号相关的位：<code>sigaddset(&amp;signals-&gt;signal, sig);</code></p>
</li>
<li>返回 0：即使信号没有被追加到队列中，挂起信号掩码中相应的位也被设置。</li>
</ol>
<p>即使在挂起队列中没有空间存放相应的挂起信号，让目标进程能接收信号也很重要。假设一个进程正在消耗过多内存，内核必须保证即使没有空闲内存，<code>kill()</code>也能成功执行。</p>
<h3 id="group-send-sig-info"><a href="#group-send-sig-info" class="headerlink" title="group_send_sig_info()"></a>group_send_sig_info()</h3><p>向整个线程组发送信号。参数：</p>
<ul>
<li>信号编号<code>sig</code></li>
<li><code>siginfo_t</code>表的地址<code>info</code></li>
<li>进程描述符的地址<code>p</code></li>
</ul>
<p>执行下列步骤：</p>
<ol>
<li>检查 sig 是否正确 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(sig &lt; 0 || sig &gt; 64)</span><br><span class="line">	return -EINVAL;</span><br></pre></td></tr></table></figure></li>
<li>如果信号是由用户态进程发送的，则确定是否允许该操作。如果不允许用户态进程发送信号，返回 -EPERM。下列条件至少有有一个成立，信号才可被传递：<ol>
<li>发送进程的拥有者拥有适当的权限（通常意味着通过系统管理员发布信号）。</li>
<li>信号为<code>SIGCONT</code>且目标进程与发送进程处于同一个注册会话中。</li>
<li>两个进程属于同一个用户。</li>
</ol>
</li>
<li>如果参数<code>sig == 0</code>，不产生任何信号，立即返回。因为0是无效的信号编码，说明发送进程没有向目标线程组发送信号的特权。如果目标进程正在被杀死（通过检查它的信号处理程序描述符是否被释放得知），那么函数也返回。</li>
<li>获取<code>p-&gt;sighand-&gt;siglock</code>自旋锁并关闭本地中断。</li>
<li><code>handle_stop_signal()</code>检查信号的某些类型，这些类型可能使目标线程组的其他挂起信号无效。<ol>
<li>如果线程组正在被杀死（信号描述符的<code>flags</code>字段的<code>SIGNAL_GROUP_EXIT</code>标志被设置），则返回。</li>
<li>如果<code>sig</code>是<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code>或<code>SIGTTOU</code>信号，<code>rm_from_queue()</code>从共享挂起信号队列<code>p-&gt;signal-&gt;shared_pending</code>和线程组所有成员的私有信号队列中删除<code>SIGCONT</code>信号。</li>
<li>如果<code>sig</code>是<code>SIGCONT</code>信号，<code>rm_from_queue()</code>从共享挂起信号队列<code>p-&gt;signal-&gt;shared_pending</code>中删除所有的<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code>和<code>SIGTTOU</code>信号，然后从属于线程组的进程的私有挂起信号队列中删除上述信号，并唤醒进程：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rm_from_queue(<span class="number">0x003c0000</span>, &amp;p-&gt;signal-&gt;shared_pending);</span><br><span class="line">t = p;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	rm_from_queue(<span class="number">0x003c0000</span>, &amp;t-&gt;pending);</span><br><span class="line">	try_to_wake_up(t, TASK_STOPPED, <span class="number">0</span>);</span><br><span class="line">	t = next_thread(t);   <span class="comment">// 返回线程组中不同轻量级进程的描述符地址</span></span><br><span class="line">&#125;<span class="keyword">while</span>(t != p);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>检查线程组是否忽略信号，如果是就返回 0 值（成功）。如果前一节“信号的作用”中提到的忽略信号的三个条件都满足，就忽略信号。</li>
<li>如果信号是非实时的，并且在线程组的共享挂起信号队列中已经有另外一个相同的信号，就什么都不做，返回 0 值（成功）。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sit &lt; <span class="number">32</span> &amp;&amp; sigismember(&amp;p-&gt;signal-&gt;shared_pending.signal, sig))</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>send_signal()</code>把信号添加到共享挂起信号队列中。如果返回非 0 的错误码，终止并返回相同值。</li>
<li><code>__group_complete_signal()</code>唤醒线程组中的一个轻量级进程。</li>
<li>释放<code>p-&gt;sighand-&gt;siglock</code>自旋锁并打开本地中断。</li>
<li>返回 0（成功）。</li>
</ol>
<p><code>__group_complete_signal()</code>扫描线程组中的进程，查找能接收新信号的进程。满足下述所有条件的进程可能被选中：</p>
<ul>
<li>进程不阻塞信号。</li>
<li>进程的状态不是<code>EXIT_ZOMBIE</code>、<code>EXIT_DEAD</code>、<code>TASK_TRACED</code>或<code>TASK_STOPPED</code>。</li>
<li>进程没有正在被杀死，即它的<code>PF_EXITING</code>标志没有置位。</li>
<li>进程或者当前正在 CPU 上运行，或者它的<code>TIF_SIGPENDING</code>标志还没有设置。</li>
</ul>
<p>线程组可能有很多满足上述条件的进程，函数按照下面的规则选中其中一个进程：</p>
<ul>
<li>如果 p 标识的进程（<code>group_send_sig_info()</code>的参数传递的描述符地址）满足所有的优先准则，函数就选择该进程。</li>
<li>否则，函数通过扫描线程组的成员搜索一个适当的进程，搜索从接收线程组最后一个信号的进程（<code>p-&gt;siganl-&gt;curr_target</code>）开始。</li>
</ul>
<p>如果<code>__group_complete_signal()</code>成功找到一个适当的进程，就开始向被选中的进程传递信号。先检查信号是否是致命的，如果是，通过向线程组中的所有轻量级进程发送<code>SIGKILL</code>信号杀死整个线程组。否则，调用<code>signal_wake_up()</code>通知被选中的进程：有新的挂起信号。</p>
<h2 id="传递信号"><a href="#传递信号" class="headerlink" title="传递信号"></a>传递信号</h2><p>如何确保进程的挂起信号得到处理内核所执行的操作。</p>
<p>在运行进程恢复用户态下的执行前，内核会检查进程<code>TIF_SIGPENDING</code>标志的值。每当内核处理完一个中断或异常时，就检查是否存在挂起信号。</p>
<p>为了处理非阻塞的挂起信号，内核调用<code>do_signal()</code>。参数：</p>
<ul>
<li><code>regs</code>，栈区的地址，当前进程在用户态下寄存器的内容存放在这个栈中。</li>
<li><code>oldset</code>，变量的地址，假设函数把阻塞信号的位掩码数组存放在这个变量中。不需要保存位掩码数组时，置为 NULL。</li>
</ul>
<p>通常只在 CPU 要返回到用户态时才调用<code>do_signal()</code>。因此，如果中断处理程序调用<code>do_signal()</code>，该函数立即返回。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((regs-&gt;xcs &amp; <span class="number">3</span>) != <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果<code>oldset</code>参数为NULL，就用<code>current-&gt;blocked</code>字段的地址对它初始化：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!oldset)</span><br><span class="line">	oldset = &amp;current-&gt;blocked;</span><br></pre></td></tr></table></figure></p>
<p><code>do_signal()</code>的核心是重复调用<code>dequeue_signal()</code>，直到私有挂起信号队列和共享挂起信号队列中都没有非阻塞的挂起信号为止。</p>
<p><code>dequeue_signal()</code>的返回码存放在<code>signr</code>局部变量中，值为：</p>
<ul>
<li>0，所有挂起的信号已全部被处理，且<code>do_signal()</code>可以结束。</li>
<li>非 0，挂起的信号正等待被处理，且<code>do_signal()</code>处理了当前信号后又调用了<code>dequeue_signal()</code>。</li>
</ul>
<p><code>dequeue_signal()</code>首先考虑私有信号队列中的所有信号，并从最低编号的挂起信号开始。然后考虑共享队列中的信号。<strong>它更新数据结构以标识信号不再是挂起的，并返回它的编号</strong>。这就涉及清<code>current-&gt;pending.signal</code>或<code>current-&gt;signal-&gt;shared_pending.signal</code>中对应的位，并调用<code>recalc_sigpending()</code>更新<code>TIF_SIGPEDING</code>标志的值。</p>
<p><code>do_signal()</code>处理每个挂起的信号，并将其编号通过<code>dequeue_signal()</code>返回：</p>
<ul>
<li>首先，检查<code>current</code>接收进程是否正受其他一些进程的监控，如果是，调用<code>do_notify_parent_cldtop()</code>和<code>schedule()</code>让监控进程知道进程的信号处理。</li>
<li>然后，把要处理信号的<code>k_sigaction</code>数据结构的地址赋给局部变量<code>ka</code>：<code>ka = &amp;current-&gt;sig-&gt;action[signr-1];</code></li>
<li>根据<code>ka</code>的内容可以执行三种操作：<strong>忽略信号</strong>、<strong>执行缺省操作</strong>或<strong>执行信号处理程序</strong>。</li>
<li>如果显式忽略被传递的信号，<code>do_signal()</code>仅仅继续执行循环，接着考虑另一个挂起信号：<code>if(ka-&gt;sa.sa_handler == SIG_IGN) continue;</code></li>
</ul>
<h3 id="执行信号的缺省操作"><a href="#执行信号的缺省操作" class="headerlink" title="执行信号的缺省操作"></a>执行信号的缺省操作</h3><p>如果<code>ka-&gt;sa.sa_handler == SIG_DFL</code>，<code>do_signal()</code>就必须执行信号的缺省操作。但当接收进程是<code>init</code>时，该信号被丢弃：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(current-&gt;pid == <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果接收进程是其他进程，对缺省操作是 Ignore 的信号进行简单处理：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(signr == SIGCONT || signr == SIGCHLD || signr == SIGWINCH || signr == SIGURG)</span><br><span class="line">	<span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><br>缺省操作是 Stop 的信号可能停止线程组中的所有进程。</p>
<p>因此，<code>do_singal()</code>把进程的状态都设置为<code>TASK_STOPPED</code>，并随后调用<code>schedule()</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(signr == SIGTOP || signr == SIGTSTP || signr == SIGTTIN || signr = SIGTTOU)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(signr != SIGSTOP &amp;&amp; is_orphaned_pgrp(current-&gt;signal-&gt;pgrp))</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	do_signal_stop(signr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>SIGSTOP</code>与其他信号的差异比较微妙，<code>SIGSTOP</code>总是<strong>停止线程组而其他信号只停止不在“孤儿进程组”中的线程组</strong>。POSIX 标准规定，<strong>只要进程组中有一个进程有父进程，即便父进程处于不同的进程组中，但在同一个会话中，那么该进程组不是孤儿进程组</strong>。因此，如果父进程死亡，但启动该进程的用户仍登录在线，那么该进程组就不是一个孤儿进程组。</p>
<p><code>do_signal_stop()</code>检查<code>current</code>是否是线程组中第一个被停止的进程，如果是，激活“组停止”：本质上，将信号描述符中的<code>group_stop_count</code>字段设为正值，并唤醒线程组中的所有进程。组中的所有进程都检查该字段以确认正在进行“组停止”，然后把进程的状态设置为<code>TASK_STOPPED</code>，并调用<code>schedule()</code>，如果线程组领头进程的父进程没有设置<code>SIGCHLD</code>的<code>SA_NOCLDSTOP</code>标志，还需要向它发送<code>SIGCHLD</code>信号。</p>
<p>缺省操作为 Dump 的信号可以在进程的工作目录中创建一个“转储”文件，该关文件列出进程地址空间和 CPU 寄存器的全部内容。<code>do_signal()</code>创建了转储文件后，就杀死该线程组。</p>
<p>剩余 18 个信号的缺省操作为Terminate，仅仅杀死线程组。为了杀死整个线程组，调用<code>do_group_exit()</code>执行彻底的“组退出”过程。</p>
<h2 id="捕获信号"><a href="#捕获信号" class="headerlink" title="捕获信号"></a>捕获信号</h2><p>如果信号有一个专门的处理程序，<code>do_signal()</code>就执行它。通过调用<code>handle_signal()</code>进行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">handle_signal(signr, &amp;info, &amp;ka, oldset, regs);</span><br><span class="line"><span class="keyword">if</span>(ka-&gt;sa.sa_flags &amp; SA_ONESHOT)</span><br><span class="line">	ka-&gt;sa.sa_handler = SIG_DFL;  </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果所接收信号的<code>SA_ONESHOT</code>标志被置位，就必须重新设置它的缺省操作，以便同一信号的再次出现不会再次触发信号处理程序的执行。<code>do_signal()</code>处理了一个单独的信号后，直到下一次调用<code>do_signal()</code>时才考虑其他挂起的信号，确保了实时信号将以适当的顺序得到处理。</p>
<p>执行一个信号处理程序复杂性一：<strong>在用户态和内核态之间切换时，需要谨慎地处理栈中的内容</strong>。</p>
<p><code>handle_signal()</code>运行在内核态，而信号处理程序运行在用户态，当前进程恢复“正常”执行前，必须首先执行用户态的信号处理程序。此外，当内核打算恢复进程的正常执行时，内核态堆栈不再包含被中断程序的硬件上下文，因为<strong>每当从内核态向用户态转换时，内核态堆栈都被清空</strong>。</p>
<p>执行一个信号处理程序复杂性二：<strong>可以调用系统调用</strong>。这种情况下，执行了系统调用的服务例程后，控制权必须返回到信号处理程序，而不是被中断程序的正常代码流。</p>
<p>Linux 所采用的解决方法是，<strong>把保存在内核态堆栈中的硬件上下文拷贝到当前进程的用户态堆栈中</strong>。用户态堆栈也以同样方式修改：即<strong>当信号处理程序终止时，自动调用<code>sigreturn()</code>把这个硬件上下文拷贝回内核态堆栈中，并恢复用户态堆栈中原来的内容</strong>。</p>
<p>图11-2说明了有关捕获一个信号的函数的执行流：<br><img src="/img/1603005113.jpg" alt=""></p>
<ul>
<li>一个非阻塞的信号发送一个进程。</li>
<li>中断或异常发生时，进程切换到内核态。</li>
<li>内核执行<code>do_signal()</code>，该函数依次处理信号（<code>handle_signal()</code>）和建立用户态堆栈（<code>setup_frame()</code>或<code>setup_rt_frame()</code>）。</li>
<li>进程返回到用户态，因为信号处理程序的起始地址被强制放进程序计数器，因此开始执行信号处理程序。</li>
<li>处理程序终止时，<code>setup_frame()</code>或<code>setup_rt_frame()</code>放在用户态堆栈中的返回代码被执行。该代码调用<code>sig_return()</code>或<code>rt_sigreturn()</code>系统调用，相应的服务例程把正常程序的用户态堆栈硬件上下文拷贝到内核态堆栈，并把用户态堆栈恢复到它原来的样子（<code>restore_sigcontext()</code>）。</li>
<li>普通进程恢复执行。</li>
</ul>
<p>下面详细讨论该种方案。</p>
<h3 id="建立帧"><a href="#建立帧" class="headerlink" title="建立帧"></a>建立帧</h3><p>为建立进程的用户态堆栈，<code>handle_signal()</code>调用<code>setup_frame()</code>或<code>setup_rt_frame()</code>。为了在这两个函数之间进行选择，内核检查与信号相关的<code>sigaction</code>表<code>sa_flags</code>字段的<code>SA_SIGINFO</code>标志。</p>
<p><code>setup_frame()</code>参数：</p>
<ul>
<li><code>sig</code>，信号编号</li>
<li><code>ka</code>，与信号相关的<code>k_sigaction</code>表的地址</li>
<li><code>oldset</code>，阻塞信号的位掩码数组的地址</li>
<li><code>regs</code>，用户态寄存器的内容保存在内核态堆栈区的地址</li>
</ul>
<p><code>setup_frame()</code>把<strong>帧</strong>推入用户态堆栈中，该帧含有处理信号所需的信息，并确保正确返回到<code>handle_signal()</code>。一个帧就是包含下列字段的<code>sigframe</code>表：</p>
<ul>
<li><code>pretcode</code>：信号处理函数的返回地址，它指向<code>__kernel_sigreturn</code>标记处的代码</li>
<li><code>sig</code>：信号编号</li>
<li><code>sc</code>：类型为<code>sigcontext</code>的结构，它包含正好切换到内核态前用户态进程的硬件上下文，还包含进程被阻塞的常规信号的位数组</li>
<li><code>fpstate</code>：类型为<code>_fpstate</code>的结构，用来存放用户态进程的浮点寄存器内容</li>
<li><code>extramask</code>：被阻塞的实时信号的位数组</li>
<li><code>retcode</code>：发出<code>sigreturn()</code>系统调用的8字节代码</li>
</ul>
<p><img src="/img/1603005706.jpg" alt=""></p>
<p><code>setup_frame()</code>执行步骤：</p>
<ul>
<li>调用<code>get_sigframe()</code>计算帧的第一个内存单元，通常在用户态堆栈中：<ul>
<li>因为栈朝低地址方向延伸，所以通过把当前栈顶的地址减去它的大小，使其结果与 8 的倍数对齐，就获得了帧的起始地址</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(rets-&gt;esp - sizeof(struct sigframe)) &amp; 0xfffffff8</span><br></pre></td></tr></table></figure>
<ul>
<li>用<code>access_ok</code>宏对返回地址进行验证。<ul>
<li>如果地址有效，<code>setup_frame()</code>反复调用<code>__put_user()</code>填充帧的所有字段。</li>
<li>帧的<code>pretcode</code>初始化为<code>&amp;__kernel_sigreturn</code>，一些粘合代码的地址存放在<code>vsyscall</code>页中。</li>
<li>修改内核态堆栈的<code>regs</code>区，保证了当<code>current</code>恢复在用户态的执行时，控制权将传递给信号处理程序。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">regs-&gt;esp = (<span class="type">unsigned</span> <span class="type">long</span>)frame;  <span class="comment">// 而 esp 指向已推进用户态堆栈顶的帧的第一个内存单元</span></span><br><span class="line">regs-&gt;eip = (<span class="type">unsigned</span> <span class="type">long</span>)ka-&gt;sa.sa_handler; <span class="comment">//  eip 寄存器执行信号处理程序的第一条指令</span></span><br><span class="line">regs-&gt;eax = (<span class="type">unsigned</span> <span class="type">long</span>)sig;</span><br><span class="line">regs-&gt;edx = regs-&gt;ecx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">regs-&gt;xds = regs-&gt;xes = regs-&gt;xss = __USER_DS;</span><br><span class="line">regs-&gt;xcs = __USER_CS;</span><br></pre></td></tr></table></figure>
<p><code>setup_frame()</code>把保存在内核态堆栈的段寄存器内容重新设置成它们的缺省值，现在，信号处理程序所需的信息就在用户态堆栈的顶部。</p>
<p><code>setup_rt_frame()</code>与<code>setup_frame()</code>非常相似，但它把用户态堆栈存放在一个扩展帧中（<code>rt_sigframe</code>数据结构中），该帧包含了与信号相关的<code>siginfo_t</code>表的内容。此外，该函数设置<code>pretcode</code>字段以使它执行<code>vsyscall</code>页中的<code>__kernel_rt_sigreturn</code>代码。</p>
<h3 id="检查信号标志"><a href="#检查信号标志" class="headerlink" title="检查信号标志"></a>检查信号标志</h3><p>建立用户态堆栈后，<code>handle_signal()</code>检查与信号相关的标志值。如果信号没有设置<code>SA_NODEFER</code>标志，在<code>sigaction</code>表中<code>sa_mask</code>字段对应的信号就必须在信号处理程序执行期间被阻塞<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(ka-&gt;sa.sa_flags &amp; SA_NODEFER))</span><br><span class="line">&#123;</span><br><span class="line">	spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">	sigorsets(&amp;current-&gt;blocked, &amp;current-&gt;blocked, &amp;ka-&gt;sa.sa_mask);</span><br><span class="line">	sigaddset(&amp;current-&gt;blocked, sig);  <span class="comment">// sig 为信号编号</span></span><br><span class="line">	</span><br><span class="line">	recalc_sigpending(curent);</span><br><span class="line">	spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>recalc_sigpending()</code>检查进程是否有非阻塞的挂起信号，并因此设置它的<code>TIF_SIGPENDING</code>标志。然后，返回到<code>do_signal()</code>，<code>do_signal()</code>也立即返回。</p>
<h3 id="开始执行信号处理程序"><a href="#开始执行信号处理程序" class="headerlink" title="开始执行信号处理程序"></a>开始执行信号处理程序</h3><p><code>do_signal()</code>返回时，当前进程恢复它在用户态的执行。由于<code>setup_frame()</code>的准备，<code>eip</code>寄存器执行信号处理程序的第一条指令，而<code>esp</code>指向已推进用户态堆栈顶的帧的第一个内存单元。因此，信号处理程序被执行。</p>
<h3 id="终止信号处理程序"><a href="#终止信号处理程序" class="headerlink" title="终止信号处理程序"></a>终止信号处理程序</h3><p>信号处理程序结束时，返回栈顶地址，该地址指向帧的<code>pretcode</code>字段所引用的<code>vsyscall</code>页中的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__kernel_sigreturn:</span><br><span class="line">	popl %eax</span><br><span class="line">	movl $__NR_sigreturn, %eax</span><br><span class="line">	<span class="type">int</span> $<span class="number">0x80</span></span><br></pre></td></tr></table></figure></p>
<p>信号编号（即帧的<code>sig</code>字段）被从栈中丢弃，然后调用<code>sigreturn()</code>。</p>
<p><code>sys_sigreturn()</code>函数：</p>
<ul>
<li><p>计算类型为<code>pt_regs</code>的<code>regs</code>的地址，<code>pt_regs</code>包含用户态进程的硬件上下文。根据存放在<code>esp</code>字段中的地址，导出并检查帧在用户态堆栈内的地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame = (<span class="keyword">struct</span> sigframe *)(regs.esp - <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span>(verify_area(VERIFY_READ, frame, <span class="keyword">sizeof</span>(*frame))</span><br><span class="line">&#123;</span><br><span class="line">	force_sig(SIGSEGV, current);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把调用信号处理程序前所阻塞的信号的位数组从帧的<code>sc</code>字段拷贝到<code>current</code>的<code>blocked</code>字段。结果，为信号处理函数的执行而屏蔽的所有信号解除阻塞。</p>
</li>
<li>调用<code>recalc_sigpending()</code>。</li>
<li>把来自帧的<code>sc</code>字段的进程硬件上下文拷贝到内核态堆栈中，并从用户态堆栈中删除帧，这两个任务通过调用<code>restore_sigcontext()</code>完成。</li>
<li><code>rt_sigqueueinfo()</code>需要与信号相关的<code>siginfo_t</code>表。</li>
<li>扩展帧的<code>pretcode</code>指向<code>vsyscall</code>页中的<code>__kernel_rt_sigturn</code>代码，它调用<code>rt_sigreturn()</code>，相应的<code>sys_rt_sigreturn()</code>服务例程把来自扩展帧的进程硬件上下文拷贝到内核态堆栈，并通过从用户态堆栈删除扩展帧以恢复用户态堆栈原来的内容。</li>
</ul>
<h3 id="系统调用的重新执行"><a href="#系统调用的重新执行" class="headerlink" title="系统调用的重新执行"></a>系统调用的重新执行</h3><p>内核不总是能立即满足系统调用发出的请求，这时，把发出系统调用的进程置为<code>TASK_INTERRUPTIBLE</code>或<code>TASK_UNINTERRUPTIBLE</code>状态。</p>
<p>如果进程处于<code>TASK_INTERRUPTIBLE</code>状态，并且某个进程向它发送了一个信号，则内核不完成系统调用就把进程置成<code>TASK_RUNNING</code>状态。当切换回用户态时信号被传递给进程。这时，系统调用服务例程没有完成，但返回<code>EINTR</code>、<code>ERESTARTNOHAND</code>、<code>ERESTART_RESTARTBLOCK</code>、<code>ERESTARTSYS</code>或<code>ERESTARTNOINTR</code>错误码。</p>
<p>实际上，用户态进程获得的唯一错误码是 EINTR，表示系统调用还没有执行完。内核内部使用剩余的错误码来<strong>指定信号处理程序结束后是否自动重新执行系统调用</strong>。</p>
<p>表中列出了与未完成的系统调用相关的出错码以及这些出错码对信号三种可能的操作产生的影响。<br><img src="/img/1603031773.jpg" alt=""></p>
<ul>
<li><code>Terminate</code>，不会自动重新执行系统调用：进程在<code>int $0x80</code>或<code>sysenter</code>指令紧接着的那条指令将恢复它在用户态的执行，这时<code>eax</code>寄存器包含的值为 -EINTR。</li>
<li><code>Reexecute</code>，内核强迫用户态进程把系统调用号重新装入<code>eax</code>寄存器，并重新执行<code>int $0x80</code>或<code>sysenter</code>指令。进程意识不到这种重新执行，出错码也不传递给进程。</li>
<li><code>Depends</code>，只有被传递信号的<code>SA_RESTART</code>标志被设置，才重新执行系统调用；否则，系统调用以 -EINTR 出错码结束。</li>
</ul>
<p>传递信号时，内核在试图重新执行一个系统调用前，必须确定进程确实发出过该系统调用。<code>regs</code>硬件上下文的<code>orig_eax</code>字段起该作用。中断或异常处理程序开始时初始化该字段：</p>
<ul>
<li>中断，与中断相关的<code>IRQ</code>号减去 256</li>
<li><code>0x80</code>或<code>sysenter</code>，系统调用号</li>
<li>其他异常，-1</li>
</ul>
<p>因此，<code>orig_eax</code>字段中的非负数意味着信号已经唤醒了在系统调用上睡眠的<code>TASK_INTERRUPTIBLE</code>进程。服务例程认识到系统调用曾被中断，并返回前面提到的某个错误码。</p>
<h3 id="重新执行被未捕获信号中断的系统调用"><a href="#重新执行被未捕获信号中断的系统调用" class="headerlink" title="重新执行被未捕获信号中断的系统调用"></a>重新执行被未捕获信号中断的系统调用</h3><p>如果信号被显式忽略，或者它的缺省操作被强制执行，<code>do_signal()</code>就分析系统调用的出错码，并确定是否重新自动执行未完成的系统调用。如果必须重新开始执行系统调用，<code>do_signal()</code>就修改<code>regs</code>硬件上下文，以便在进程返回用户态时，<code>eip</code>指向<code>int $0x80</code>或<code>sysenter</code>指令，且<code>eax</code>包含系统调用号：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(regs-&gt;orig_eax &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(regs-&gt;eax == -ERESTARTNOHAND || regs-&gt;eax == -ERESTARTSYS || regs-&gt;eax == -ERESTARTNOINTR)</span><br><span class="line">	&#123;</span><br><span class="line">		regs-&gt;eax = regs-&gt;orig_eax;</span><br><span class="line">		regs-&gt;eip -= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(regs-&gt;eax == -ERESTART_RESTARTBLOCK)  </span><br><span class="line">	&#123;</span><br><span class="line">		regs-&gt;eax = __NR_restart_syscall;</span><br><span class="line">		regs-&gt;eip -= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把系统调用服务例程的返回码赋给<code>regs-&gt;eax</code>，<code>int $0x80</code>和<code>sysreturn</code>的长度都是两个字节，<code>eip</code>减 2 后，指向引起系统调用的指令。<code>ERESTART_RESTARTBLOCK</code>错误码是特殊的，因为<code>eax</code>寄存器存放了<code>restart_syscall()</code>的系统调用号，因此，用户态进程不会重新指向被信号中断的同一系统调用，该错误码仅用于与时间相关的系统调用，重新指向这些系统调用时，应该调整它们的用户态参数。</p>
<h3 id="为所捕获的信号重新执行系统调用"><a href="#为所捕获的信号重新执行系统调用" class="headerlink" title="为所捕获的信号重新执行系统调用"></a>为所捕获的信号重新执行系统调用</h3><p>如果信号被捕获，那么<code>handle_signal()</code>可能分析出错码，也可能分析<code>sigaction</code>表的<code>SA_RESTART</code>标志，来决定是否必须重新执行未完成的系统调用。如果系统调用必须被重新开始执行，<code>handle_signal()</code>就与<code>do_signal()</code>完全一样继续执行；否则，向用户态进程返回一个出错码 -EINTR。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(regs-&gt;orig_eax &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span>(regs-&gt;eax)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> -ERESTART_RESTARTBLOCK:</span><br><span class="line">	<span class="keyword">case</span> -ERESTARTNOHAND:</span><br><span class="line">		regs-&gt;eax = -EINTR;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> -ERESTARTSYS:</span><br><span class="line">		<span class="keyword">if</span>(!(ka-&gt;sa.sa_flags &amp; SA_RESTART))</span><br><span class="line">		&#123;</span><br><span class="line">			regs-&gt;eax = -EINTR;</span><br><span class="line">			brea;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> -ERESTARTNOINTR:</span><br><span class="line">		regs-&gt;eax = regs-&gt;orig_eax;</span><br><span class="line">		regs-&gt;eip -= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="与信号处理相关的系统调用"><a href="#与信号处理相关的系统调用" class="headerlink" title="与信号处理相关的系统调用"></a>与信号处理相关的系统调用</h2><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p><code>kill(pid, sig)</code>向普通进程或多线程应用发送信号，其服务例程是<code>sys_kill()</code>。<code>pid</code>参数的含义取决于它的值：</p>
<ul>
<li><code>pid &gt; 0</code>，把<code>sig</code>信号发送到<code>PID</code>等于<code>pid</code>的进程所属的线程组。</li>
<li><code>pid = 0</code>，把<code>sig</code>信号发送到与调用进程同组的进程的所有线程组。</li>
<li><code>pid = -1</code>，把信号发送到所有进程，除了<code>swapper</code>（PID = 0)，<code>init</code>（PID = 1）和<code>current</code>。</li>
<li><code>pid &lt; -1</code>，把信号发送到进程组 -pid 中进程的所有线程组。</li>
</ul>
<p><code>sys_kill()</code>为信号建立最小的<code>siginfo_t</code>表，然后调用<code>kill_something_info()</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">info.si_signo = sig;</span><br><span class="line">info.si_errno = <span class="number">0</span>;</span><br><span class="line">info.si_code = SI_USER;</span><br><span class="line">info._sifields._kill._pid = current-&gt;tgid;</span><br><span class="line">info._sifields._kill._uid = current-&gt;uid;</span><br><span class="line"><span class="keyword">return</span> kill_something_info(sig, &amp;info, pid);  </span><br></pre></td></tr></table></figure></p>
<p><code>kill_something_info</code>还依次调用<code>kill_proc_info()</code>（通过<code>group_send_sig_info()</code>向一个单独的线程组发送信号），或调用<code>kill_pg_info()</code>（扫描目标进程组的所有进程，并为目标进程组中的所有进程调用<code>send_sig_info()</code>），或为系统中的所有进程反复调用<code>group_send_sig_info()</code>（如果<code>pid</code>等于 -1）。</p>
<p><code>kill()</code>能发送任何信号，包括 32 ~ 64 间的实时信号，但不能确保一个新的元素加入到目标进程的挂起信号队列，因此，挂起信号的多个实例可能被丢失。实时信号应当通过<code>rt_sigqueueinfo()</code>进程发送。</p>
<h3 id="tkill-和-tgkill"><a href="#tkill-和-tgkill" class="headerlink" title="tkill() 和 tgkill()"></a>tkill() 和 tgkill()</h3><p>向线程组中的指定进程发送信号。</p>
<p><code>tkill()</code>的两个参数：</p>
<ul>
<li><code>PID</code>，信号接收进程的<code>pid</code></li>
<li><code>sig</code>，信号编号</li>
</ul>
<p><code>sys_tkill()</code>服务例程为<code>siginfo</code>表赋值、获取进程描述符地址、进行许可性检查，并调用<code>specific_send_sig_info()</code>发送信号。</p>
<p><code>tgkill()</code>还需要第三个参数：</p>
<ul>
<li><code>tgid</code>，信号接收进程组所在线程组的线程组 ID</li>
</ul>
<p><code>sys_tgkill()</code>服务例程执行的操作与<code>sys_tkill()</code>一样，但还需要检查信号接收进程是否确实属于线程组<code>tgid</code>。<strong>该附加的检查解决了向一个正在被杀死的进程发送消息时出现的竞争条件的问题</strong>：</p>
<ul>
<li>如果另外一个多线程应用正以足够快的速度创建轻量级级进程，信号就可能被传递给一个错误的进程。</li>
<li>因为线程组 ID 在多线程应用的整个生存期中是不会改变的。</li>
</ul>
<h3 id="改变信号的操作"><a href="#改变信号的操作" class="headerlink" title="改变信号的操作"></a>改变信号的操作</h3><p><code>sigaction(sig, act, oact)</code>允许<strong>用户为信号指定一个操作</strong>。如果没有自定义的信号操作，则执行与传递的信号相关的缺省操作。</p>
<p><code>sys_sigaction()</code>服务例程作用于两个参数：</p>
<ul>
<li><code>sig</code>，信号编号</li>
<li><code>act</code>，类型为<code>old_sigaction</code>的<code>act</code>表（表示新的操作）</li>
<li><code>oact</code>，可选的输出参数，获得与信号相关的以前的操作。</li>
</ul>
<p>函数首先检查<code>act</code>地址的有效性。用<code>*act</code>的字段填充类型为<code>k_sigaction</code>的<code>new_ka</code>局部变量的<code>sa_handler</code>、<code>sa_flags</code>和<code>sa_mask</code>字段：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__get_user(new_ka.sa.sa_handler, &amp;act-&gt;sa_handler);</span><br><span class="line">__get_user(new_ka.sa.sa_flags, &amp;act-&gt;sa_flags);</span><br><span class="line">__get_user(mask, &amp;act-&gt;sa_mask);</span><br><span class="line">siginitset(&amp;new_ka.sa.sa_mask, mask);</span><br></pre></td></tr></table></figure></p>
<p>调用<code>do_sigaction()</code>把新的<code>new_ka</code>表拷贝到<code>current-&gt;sig-&gt;action</code>的<code>sig-1</code>位置的表项中（没有 0 信号）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">k = &amp;current-&gt;sig-&gt;action[sig<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(act)</span><br><span class="line">&#123;</span><br><span class="line">	*k = *act;</span><br><span class="line">	</span><br><span class="line">	sigdelsetmask(&amp;k-&gt;sa.sa_mask, sigmask(SIGKILL) | sigmask(SITSTOP));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(k-&gt;sa.sa_handler == SIG_IGN || (k-&gt;sa.sa_handler == SIG_DFL &amp;&amp; </span><br><span class="line">		(sig == SIGCONT || sig == SIGCHLD || sig == SIGWINCH || sig == SIGURG)))</span><br><span class="line">	&#123;</span><br><span class="line">		rm_from_queue(sigmask(sig), &amp;current-&gt;signal-&gt;shared_pendig);</span><br><span class="line">		t = current;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			rm_from_queue(sigmask(sig), &amp;current-&gt;pending);</span><br><span class="line">			recalc_sigpending_tsk(t);</span><br><span class="line">			t = next_thread(t);</span><br><span class="line">		&#125;<span class="keyword">while</span>(t != current);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>信号处理程序从不屏蔽<code>SIGKILL</code>和<code>SIGSTOP</code>。POSIX 标准规定，当缺省操作是<code>Ignore</code>时，把信号操作设置为<code>SIG_IGN</code>或<code>SIG_DFL</code>将引起同类型的任意挂起信号被丢弃。</p>
<p><code>sigaction()</code>还允许用户初始化表<code>sigaction</code>的<code>sa_flags</code>字段。</p>
<p>原来的 System V Unix 变体提供了<code>signal()</code>系统调用，Linux提供了<code>sys_signal()</code>服务例程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new_sa.sa_handler = handler;</span><br><span class="line">new_sa.sa_flags = SA_ONESHOT | SA_NOMASL.</span><br><span class="line">ret = do_sigaction(sig, &amp;new_sa, &amp;old_sa);</span><br><span class="line"><span class="keyword">return</span> ret ? ret : (<span class="type">unsigned</span> <span class="type">long</span>)old_sa.sa.sa_handler;</span><br></pre></td></tr></table></figure></p>
<h3 id="检查挂起的阻塞信号"><a href="#检查挂起的阻塞信号" class="headerlink" title="检查挂起的阻塞信号"></a>检查挂起的阻塞信号</h3><p><code>sigpending()</code>允许进程检查信号被阻塞时已经产生的那些信号。服务例程<code>sys_sigpending()</code>只作用于一个参数<code>set</code>，即用户变量的地址，必须将位数组拷贝到该变量中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigorsets(&amp;pending, &amp;current-&gt;pending.signal, &amp;current-&gt;signal-&gt;shared_pending.signal);</span><br><span class="line">sigandsets(&amp;pending, &amp;current-&gt;blocked, &amp;pending);</span><br><span class="line">copy_to_user(<span class="built_in">set</span>, &amp;pending, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="修改阻塞信号的集合"><a href="#修改阻塞信号的集合" class="headerlink" title="修改阻塞信号的集合"></a>修改阻塞信号的集合</h3><p><code>sigprocmask()</code>允许进程修改阻塞信号的集合，只应用于常规信号（非实时信号）。<code>sys_sigprocmask()</code>服务例程作用于三个参数：</p>
<ul>
<li><code>oset</code>，进程地址空间的一个指针，执行存放以前位掩码的一个位数组。</li>
<li><code>set</code>，进程地址空间的一个指针，执行包含新位掩码的位数组。</li>
<li><code>how</code>，一个标志，可采取如下值：<ul>
<li><code>SIG_BLOCK</code>，<code>*set</code>位掩码数组，指定必须加到阻塞信号的位掩码数组中的信号。</li>
<li><code>SIG_UNBLOCK</code>，<code>*set</code>位掩码数组，指定必须从阻塞信号的位掩码数组中删除的信号。</li>
<li><code>SIG_SETMASK</code>，<code>*set</code>位掩码数组，指定阻塞信号新的位掩码数组。</li>
</ul>
</li>
</ul>
<p><code>sys_sigprocmask()</code>调用<code>copy_from_user()</code>把<code>set</code>参数拷贝到局部变量<code>new_set</code>中，把<code>current</code>标准阻塞信号的位掩码数组拷贝到<code>old_set</code>局部变量中，然后根据<code>how</code>标志进行相应操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(copy_from_user(&amp;new_set, <span class="built_in">set</span>, <span class="keyword">sizeof</span>(*<span class="built_in">set</span>)))</span><br><span class="line">	<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	</span><br><span class="line">new_set &amp;= ~(sigmask(SIGKILL) | sigmask(SIGSTOP));</span><br><span class="line">old_set = current-&gt;blocked.sig[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(how == SIG_BLOCK)</span><br><span class="line">	sigaddsetmask(&amp;current-&gt;blocked, new_set);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(how == SIG_UNBLOCK)</span><br><span class="line">	sigdelsetmask(&amp;current-&gt;blocked, new_set);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(how == SIG_SETMASK)</span><br><span class="line">	current-&gt;blocked.sig[<span class="number">0</span>] = new_set;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	</span><br><span class="line">recalc_sigpending(current);</span><br><span class="line"><span class="keyword">if</span>(oset &amp;&amp; copy_to_user(oset, &amp;old_set, <span class="keyword">sizeof</span>(*oset)))</span><br><span class="line">	<span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="挂起进程"><a href="#挂起进程" class="headerlink" title="挂起进程"></a>挂起进程</h3><p><code>sigsuspend()</code>把进程置为<code>TASK_ITERRUPTIBLE</code>状态，这发生在把<code>mask</code>参数指向的位掩码数组所指定的标准信号阻塞后。只有当一个非忽略、非阻塞的信号发送到进程后，进程才被唤醒。<code>sys_sigsuspend()</code>服务例程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mask&amp;= ~(sigmask(SIGKILL) | sigmask(SIGSTOP));</span><br><span class="line">saveset = current-&gt;blocked;</span><br><span class="line">siginitset(&amp;current-&gt;blocked, mask);</span><br><span class="line">recalc_sigpending(current);</span><br><span class="line">regs-&gt;eax = -EINTR;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line">	schedule();</span><br><span class="line">	<span class="keyword">if</span>(do_signal(regs, &amp;saveset))</span><br><span class="line">		<span class="keyword">return</span> -EINTR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>schedule()</code>选择另一个进程运行，当发出<code>sigsuspend()</code>的进程又开始执行时，<code>sys_sigsuspend()</code>调用<code>do_signal()</code>传递唤醒了该进程的信号，返回值为 1 时，不忽略该信号，因此返回 -EINTR 出错码后终止。</p>
<h3 id="实时信号的系统调用"><a href="#实时信号的系统调用" class="headerlink" title="实时信号的系统调用"></a>实时信号的系统调用</h3><p>实时信号的几个系统调用（<code>rt_sigaction()</code>、<code>rt_sigpending()</code>、<code>rt_sigprocmask()</code>即<code>rt_sigsuspend()</code>）与前面的描述类似。</p>
<p><code>rt_sigqueueinfo()</code>：发送一个实时信号以便把它加入到目标进程的共享信号队列中。一般通过标准库函数<code>sigqueue()</code>调用<code>rt_sigqueueinfo()</code>。</p>
<p><code>rt_sigtimedwait()</code>：把阻塞的挂起信号从队列中删除而不传递它，并向调用者返回信号编号；如果没有阻塞的信号挂起，就把当前进程挂起一个固定的时间间隔。一般通过标准库函数<code>sigwaitinfo()</code>和<code>sigtimedwait()</code>调用<code>rt_sigtimedwait()</code>。</p>
<h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><p>在Linux下可以安装挂载很多格式的文件系统，之所以能实现就是通过<strong>虚拟文件系统</strong>这一中间系统层，虚拟文件系统所隐含的思想是<strong>把表示很多不同种类文件系统的共同信息放入内核；其中有一个字段或函数来支持Linux所支持的所有实际文件系统所提供的任何操作</strong>。</p>
<h2 id="虚拟文件系统的作用"><a href="#虚拟文件系统的作用" class="headerlink" title="虚拟文件系统的作用"></a>虚拟文件系统的作用</h2><p>虚拟文件系统（Virtual Filesystem）也可以称之为虚拟文件系统转换（Virtual Filesystem Switch,VFS）,是一个内核软件层，用来处理与Unix标准文件系统相关的所有系统调用。</p>
<p>VFS支持的文件系统可以划分为三种主要类型：</p>
<ul>
<li><strong>磁盘文件系统</strong>：这些文件系统管理在本地磁盘分区中可用的存储空间或者其他可以起到磁盘作用的设备(比如一个USB闪存)。<ul>
<li>VFS支持的基于磁盘的某些著名文件系统还有：<ul>
<li>Linux使用的文件系统，如广泛使用的第二扩展文件系统(Ext2)，新近的第三扩展文件系统(Third Extended Filesystem, Ext3)及Reiser文件系统(ReiserFS)。</li>
<li>Unix家族的文件系统。</li>
<li>微软公司的文件系统，如MS-DOS、VFAT及NTFS。</li>
<li>ISO9660 CD-ROM文件系统(以前的High Sierra文件系统)和通用磁盘格式(UDF)的DVD文件系统。</li>
<li>其他有专利权的文件系统。HPFS，HFS，AFFS，ADFS</li>
<li>起源于非Linux系统的其他日志文件系统，如IBM的JFS和SGI的XFS。</li>
</ul>
</li>
</ul>
</li>
<li><strong>网络文件系统</strong>：这些文件系统允许轻易地<strong>访问属于其他网络计算机的文件系统所包含的文件</strong>。<ul>
<li>虚拟文件系统所支持的一些著名的网络文件系统有：NFS、Coda、AFS(Andrew文件系统)、CIFS以及NCP。</li>
</ul>
</li>
<li><strong>特殊文件系统</strong>：这些文件系统不管理本地或者远程磁盘空间。/proc文件系统是特殊文件系统的一个典型范例。</li>
</ul>
<p>Unix的目录建立了一颗根目录为“/”的树。根目录包含在<strong>根文件系统</strong>(root filesystem)中，在Linux中这个根文件系统通常就是Ext2或Ext3类型。其他所有的文件系统都可以被<strong>安装</strong>在根文件系统的子目录中。</p>
<h3 id="通用文件模型"><a href="#通用文件模型" class="headerlink" title="通用文件模型"></a>通用文件模型</h3><p>VFS引入一个<strong>通用文件模型</strong>，能够表示所有支持的文件系统。由下列对象类型组成：</p>
<ul>
<li><strong>超级块对象</strong>(superblock object)：存放已安装文件系统有关信息。对基于磁盘的文件系统，这类对象通常对应于存放在磁盘上的文件系统控制块(filesystem control block)。</li>
<li><strong>索引节点对象</strong>(inode object)：存放关于具体文件的一般信息。对基于磁盘的文件系统，这类对象通常对应于存放在磁盘上的<strong>文件控制块</strong>(file control block)。每个索引节点对象都有一个索引节点号，这个节点号唯一地标识文件系统中的文件。</li>
<li><strong>文件对象</strong>(file object)：存放打开文件与进程之间进行交互的有关信息。这类信息仅当进程访问文件期间存在于内核内存中。</li>
<li><strong>目录项对象</strong>(dentry object)：存放目录项(也就是文件的特定名称)与对应文件进行链接的有关信息。每个磁盘文件系统都以自己特有的方式将该类信息存在磁盘上。</li>
</ul>
<p>下图是一个简单的实例，说明进程怎样与文件交互。三个不同的进程打开同一个文件，其中两个进程使用同一个硬链接。每个进程使用自己的文件对象，但只需要两个目录项对象，每个硬链接对应一个目录项对象。<br><img src="/img/1603036205.jpg" alt=""></p>
<p>VFS除了能为所有文件系统的实现提供一个通用接口外，还具有另一个与系统性能相关的重要作用。最近最常用的目录项被放在<strong>目录项高速缓存</strong>(dentry cache)的<strong>磁盘高速缓存</strong>中，以加速从文件路径名到最后一个路径分量的索引节点的转换过程。磁盘高速缓存属于软件机制，它<strong>允许内核将原本存在磁盘上的某些信息保存在RAM中，以便对这些数据的进一步访问能快速进行，而不必慢慢访问磁盘本身</strong>。</p>
<p>注意，磁盘高速缓存不同于硬件高速缓存或内存高速缓存，后两者都与磁盘或其他设备无关。硬件高速缓存是一个快速静态RAM，它加快了直接对慢速动态RAM的请求。内存高速缓存是一种软件机制，引入它是为了绕过内核内存分配器。</p>
<p>除了目录项高速缓存和索引节点高速缓存之外，Linux还使用其他磁盘高速缓存。其中最重要的一种就是所谓的页高速缓存。</p>
<h3 id="VFS所处理的系统调用"><a href="#VFS所处理的系统调用" class="headerlink" title="VFS所处理的系统调用"></a>VFS所处理的系统调用</h3><p><img src="/img/1603037026.jpg" alt=""><br><img src="/img/1603037060.jpg" alt=""></p>
<p>可以把VFS看成通用文件系统，它在必要时依赖某种具体文件系统。</p>
<h2 id="VFS的数据结构"><a href="#VFS的数据结构" class="headerlink" title="VFS的数据结构"></a>VFS的数据结构</h2><p>每个VFS对象都存放在一个适当的数据结构中，其中包括<strong>对象的属性</strong>和<strong>指向对象方法表的指针</strong>。内核可以动态地修改对象的方法，因此可以为对象建立专用的行为。</p>
<h3 id="超级块对象"><a href="#超级块对象" class="headerlink" title="超级块对象"></a>超级块对象</h3><p>超级块对象由<code>super_block</code>结构组成：<br><img src="/img/1602756714.png" alt=""></p>
<p>所有超级块对象都以<strong>双向循环链表</strong>的形式链接在一起。链表中第一个元素用<code>super_blocks</code>变量来表示，而超级块对象的<code>s_list</code>字段存放指向链表相邻元素的指针。<code>sb_lock</code>自旋锁保护链表免受多处理器系统上的同时访问。<code>s_fs_info</code>指向属于具体文件系统的超级块信息。为了效率，由<code>s_fs_info</code>字段所指向的数据被复制到内存，任何基于磁盘的文件系统都需要访问更改自己的磁盘分配位图，以便分配释放磁盘块，VFS支持文件系统对内存超级块的<code>s_fs_info</code>进行操作，无需访问磁盘。这需要引入一个<code>s_dirt</code>表示该超级块是否是脏的，磁盘上的数据是否需要更新。</p>
<p>与超级块关联的方法就是所谓的<strong>超级块操作</strong>。这些操作是由数据结构<code>super_operations</code>来描述的，该结构的起始地址存放在超级块的<code>s_op</code>字段中。</p>
<p>每个具体的文件系统都自定义超级块操作。当VFS需要调用其中一个操作，比如<code>read_inode()</code>，执行下列操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb-&gt;s_op-&gt;read_inode(inode);</span><br></pre></td></tr></table></figure></p>
<p>超级块操作实现了一些高级操作：</p>
<ul>
<li><code>struct inode *(*alloc_inode)(struct super_block *sb);</code>：为索引节点对象分配空间，包括具体文件系统的数据所需要的空间。</li>
<li><code>void (*destroy_inode)(struct inode *);</code>：撤销索引节点对象，包括具体文件系统的数据。</li>
<li><code>void (*read_inode) (struct inode *);</code>：用磁盘上的数据填充以参数传递过来的索引节点对象的字段,索引节点对象的<code>i_ino</code>字段标识从磁盘上要读取的具体文件系统的索引节点。</li>
<li><code>void (*dirty_inode) (struct inode *);</code>：当索引节点标记为修改（脏）时调用。</li>
<li><code>int (*write_inode) (struct inode *, int);</code>：用通过传递参数指定的索引节点对象的内容更新一个文件系统的索引节点。索引节点对象的<code>i_ino</code>字段标识所涉及磁盘上文件系统的索引节点。<code>flag</code>参数表示I/O操作是否应当同步。</li>
<li><code>void (*put_inode) (struct inode *);</code>：释放索引节点时调用（减少该节点引用计数器值）以执行具体文件系统操作。</li>
<li><code>void (*drop_inode) (struct inode *);</code>：在即将撤消索引节点时调用——也就是说， 当最后一个用户释放该索引节点时；实现该方法的文件系统通常使用<code>generic_drop_inode()</code>函数。该函数从VFS数据结构中移走对索引节点的每一个引用， 如果索引节点不再出现在任何目录中，则调用超级块方法<code>delete_inode</code>将它从文件系统中删除。</li>
<li><code>void (*delete_inode) (struct inode *);</code>：在必须撤消索引节点时调用。删除内存中的VFS索引节点和磁盘上的文件数据及元数据。</li>
<li><code>void (*put_super) (struct super_block *);</code>：释放通过传递的参数指定的超级块对象（因为相应的文件系统被卸载）。</li>
<li><code>void (*write_super) (struct super_block *);</code>：用指定对象的内容更新文件系统的超级块。</li>
<li><code>int (*sync_fs)(struct super_block *sb, int wait);</code>：在清除文件系统来更新磁盘上的具体文件系统数据结构时调用（由日志文件系统使用）。</li>
<li><code>void (*write_super_lockfs) (struct super_block *);</code>：阻塞对文件系统的修改并用指定对象的内容更新超级块。当文件系统被冻结时调用该方法，例如，由逻辑卷管理器驱动程序（LVM）调用。</li>
<li><code>void (*unlockfs) (struct super_block *);</code>：取消由<code>write_super_lockfs()</code>超级块方法实现的对文件系统更新的阻塞。</li>
<li><code>int (*statfs) (struct dentry *, struct kstatfs *);</code>：将文件系统的统计信息返回，填写在buf缓冲区中。</li>
<li><code>int (*remount_fs) (struct super_block *, int *, char *);</code>：用新的选项重新安装文件系统（当某个安装选项必须被修改时被调用）。</li>
<li><code>void (*clear_inode) (struct inode *);</code>：当撤消磁盘索引节点执行具体文件系统操作时调用。</li>
<li><code>void (*umount_begin) (struct vfsmount *, int);</code>：中断一个安装操作，因为相应的卸载操作已经开始（只在网络文件系统中使用）。</li>
<li><code>int (*show_options)(struct seq_file *, struct vfsmount *);</code>：用来显示特定文件系统的选项。</li>
<li><code>int (*show_stats)(struct seq_file *, struct vfsmount *);</code>：用来显示特定文件系统的状态。</li>
<li><code>ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);</code>：限额系统使用该方法从文件中读取数据，该文件详细说明了所在文件系统的限制。</li>
<li><code>ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);</code>：限额系统使用该方法将数据写入文件中，该文件详细说明了所在文件系统的限制。</li>
</ul>
<h3 id="索引节点对象"><a href="#索引节点对象" class="headerlink" title="索引节点对象"></a>索引节点对象</h3><p>文件系统处理文件所需要的所有信息都放在一个名为索引节点的数据结构中。文件名可以随时更改，但是索引节点对文件是唯一的，并且随文件的存在而存在。内存中的索引节点对象由一个<code>inode</code>数据结构组成，字段如图。<br><img src="/img/1603101159.jpg" alt=""></p>
<p>每个索引节点对象都会复制磁盘索引节点包含的一些数据，比如分配给文件的磁盘块数。如果<code>i_state</code>字段的值等于<code>I_DIRTY_SYNC</code>、<code>I_DIRTY_DATASYNC</code>或<code>I_DIRTY_PAGES</code>，那么该索引节点就是“脏”的，也就是说，对应的磁盘索引节点必须被更新。<code>I_DIRTY</code>宏可以用来立即检查这三个标志的值。<code>i_state</code>字段的其他值有<code>I_LOCK</code>（涉及的索引节点对象处于I/O传送中）、<code>I_FREEING</code>（索引节点对象正在被释放）、<code>I_CLEAR</code>（索引节点对象的内容不再有意义）以及<code>I_NEW</code>（索引节点对象已经分配但还没有用从磁盘索引节点读取来的数据填充）。</p>
<p>每个索引节点对象总是出现在下列双向循环链表的某个链表中(所有情况下，指向相邻元素的指针存放在i_list字段中)：</p>
<ul>
<li>有效未使用的索引节点链表，典型的如那些镜像有效的磁盘索引节点，且当前未被任何进程使用。这些索引节点不为脏，且它们的<code>i_count</code>字段置为0。链表中的首元素和尾元素是由变量<code>inode_unused</code>的<code>next</code>字段和<code>prev</code>字段分别指向的。这个链表用作磁盘高速缓存。</li>
<li>正在使用的索引节点链表，也就是那些镜像有效的磁盘索引节点，且当前被某些进程使用。这些索引节点不为脏，但它们的<code>i_count</code>字段为正数。链表中的首元素和尾元素是由变量<code>inode_in_use</code>引用的。</li>
<li>脏索引节点的链表。链表中的首元素和尾元素是由相应超级块对象的<code>s_dirty</code>字段引用的。</li>
</ul>
<p>此外，每个索引节点对象也包含在每文件系统（per filesystem）的双向循环链表中，链表的头存放在超级块对象的<code>s_inodes</code>字段中；索引节点对象的<code>i_sb_list</code>字段存放了指向链表相邻元素的指针。</p>
<p>最后，索引节点对象也存放在一个称为<code>inode_hashtable</code>的散列表中。散列表加快了对索引节点对象的搜索，前提是系统内核要知道索引节点号及文件所在文件系统对应的超级块对象的地址。由于散列技术可能引发冲突，所以索引节点对象包含一个<code>i_hash</code>字段，该字段中包含向前和向后的两个指针，分别指向散列到同一地址的前一个索引节点和后一个索引节点；该字段因此创建了由这些索引节点组成的一个<strong>双向链表</strong>。</p>
<p>与索引节点对象关联的方法也叫<strong>索引节点操作</strong>。它们由<code>inode_operations</code>结构来描述，该结构的地址存放在<code>i_op</code>字段中：</p>
<ul>
<li><code>int (*create) (struct inode *,struct dentry *,int, struct nameidata *);</code>：在某一目录下，为与目录项对象相关的普通文件创建一个新的磁盘索引节点。</li>
<li><code>struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);</code>：为包含在一个目录项对象中的文件名对应的索引节点查找目录。</li>
<li><code>int (*link) (struct dentry *,struct inode *,struct dentry *new_dentry);</code>：创建一个新的名为new_dentry的硬链接，它指向dir目录下名为old_dentry的文件。</li>
<li><code>int (*unlink) (struct inode *,struct dentry *);</code>：从一个目录中删除目录项对象所指定文件的硬链接。</li>
<li><code>int (*symlink) (struct inode *,struct dentry *,const char *);</code>：在某个目录下，为与目录项对象相关的符号链接创建一个新的索引节点。</li>
<li><code>int (*mkdir) (struct inode *,struct dentry *,int);</code>：在某个目录下，为与目录项对象相关的目录创建一个新的索引节点。</li>
<li><code>int (*rmdir) (struct inode *,struct dentry *);</code>：从一个目录删除子目录，子目录的名称包含在目录项对象中。</li>
<li><code>int (*mknod) (struct inode *,struct dentry *,int,dev_t);</code>：在某个目录中，为与目录项对象相关的特定文件创建一个新的磁盘索引节点。其中参数mode和rdev分别表示文件的类型和设备的主次设备号。</li>
<li><code>int (*rename) (struct inode *old_dir, struct dentry *old_entry, struct inode *new_dir, struct dentry *new_dentry);</code>：将<code>old_dir</code>目录下由<code>old_entry</code>标识的文件移到<code>new_dir</code>目录下。新文件名包含在<code>new_dentry</code>指向的目录项对象中。</li>
<li><code>int (*readlink) (struct dentry, char *buffer, int len);</code>：将目录项所指定的符号链接中对应的文件路径名拷贝到<code>buffer</code>所指定的用户态内存区。</li>
<li><code>void * (*follow_link) (struct inode *, struct nameidata *);</code>：解析索引节点对象所指定的符号链接；如果该符号链接是一个相对路径名，则从第二个参数所指定的目录开始进行查找。</li>
<li><code>void (*put_link) (struct dentry *, struct nameidata *);</code>：释放由<code>follow_link</code>方法分配的用于解析符号链接的所有临时数据结构。</li>
<li><code>void (*truncate) (struct inode *);</code>：修改与索引节点相关的文件长度。在调用该方法之前，必须将<code>inode</code>对象的<code>i_size</code>字段设置为需要的新长度值。</li>
<li><code>int (*permission) (struct inode *, int, struct nameidata *);</code>：检查是否允许对与索引节点所指的文件进行指定模式的访问。</li>
<li><code>int (*setattr) (struct dentry *, struct iattr *);</code>：在触及索引节点属性后通知一个“修改事件”。</li>
<li><code>int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);</code>：由一些文件系统用于读取索引节点属性。</li>
<li><code>int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);</code>：为索引节点设置“扩展属性”（扩展属性存放在任何索引节点之外的磁盘块中）。</li>
<li><code>ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);</code>：获取索引节点的扩展属性。</li>
<li><code>ssize_t (*listxattr) (struct dentry *, char *, size_t);</code>：获取扩展属性名称的整个链表。</li>
<li><code>int (*removexattr) (struct dentry *, const char *);</code>：删除索引节点的扩展属性。</li>
</ul>
<h3 id="文件对象"><a href="#文件对象" class="headerlink" title="文件对象"></a>文件对象</h3><p>文件对象描述进程怎样与一个打开的文件进行交互。交互对象是在文件被打开时创建的，由一个<code>file</code>结构组成。注意，文件对象在磁盘上没有对应的映像，因此file结构中没有设置“脏”字段来表示文件对象是否已被修改。<br><img src="/img/1602756715.png" alt=""></p>
<p>存放在文件对象中的主要信息是文件指针，即文件中当前的位置，下一个操作将在该位置发生。由于几个进程可能同时访问同一文件，因此<strong>文件指针必须存放在文件对象而不是索引节点对象中</strong>。</p>
<p>文件对象通过一个名为<code>filp</code>的slab高速缓存分配，<code>filp</code>描述符地址存放在<code>filp_cachep</code>变量中。由于分配的文件对象数目是有限的，因此<code>files_stat</code>变量在其<code>max_files</code>字段中指定了可分配文件对象的最大数目，也就是系统可同时访问的最大文件数。</p>
<p>在使用文件对象包含在由具体文件系统的超级块所确立的几个链表中。每个超级块对象把文件对象链表的头存放在<code>s_files</code>字段中；因此，属于不同文件系统的文件对象就包含在不同的链表中。链表中分别指向前一个元素和后一个元素的指针都存放在文件对象的<code>f_list</code>字段中。<code>files_lock</code>自旋锁保护超级块的<code>s_files</code>链表免受多处理器系统上的同时访问。</p>
<p>文件对象的<code>f_count</code>字段是一个引用计数器：它记录使用文件对象的进程数(记住，以<code>CLONE_FILES</code>标志创建的轻量级进程共享打开文件表，因此它们可以使用相同的文件对象)。当内核本身使用该文件对象时也要增加计数器的值—例如，把对象插入链表中或发出<code>dup()</code>系统调用时。</p>
<p>当VFS代表进程必须打开一个文件时，它调用<code>get_empty_filp()</code>函数来分配一个新的文件对象。该函数调用<code>kmem_cache_alloc()</code>从filp高速缓存中获得一个空闲的文件对像，然后初始化这个对象的字段，如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f = kmem_cache_alloc(filp_cachep, GFP_KERNEL);</span><br><span class="line">percpu_counter_inc(&amp;nr_files);</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(*f));</span><br><span class="line">tsk = current;</span><br><span class="line">INIT_LIST_HEAD(&amp;f-&gt;f_u.fu_list);</span><br><span class="line"><span class="type">atomic_set</span>(&amp;f-&gt;f_count, <span class="number">1</span>);</span><br><span class="line">rwlock_init(&amp;f-&gt;f_owner.lock);</span><br><span class="line">f-&gt;f_uid = tsk-&gt;fsuid;</span><br><span class="line">f-&gt;f_gid = tsk-&gt;fsgid;</span><br></pre></td></tr></table></figure><br>每个文件系统都有其自己的文件操作集合，执行诸如读写文件这样的操作。当内核将一个索引节点从磁盘装入内存时，就会把指向这些文件操作的指针存放在<code>file_operations</code>结构中，而该结构的地址存放在该索引节点对象的<code>i_fop</code>字段中。当进程打开这个文件时，VFS就用存放在索引节点中的这个地址初始化新文件对象的<code>f_op</code>字段，使得对文件操作的后续调用能够使用这些函数。如果需要，VFS随后也可以通过在<code>f_op</code>字段存放一个新值而修改文件操作的集合。</p>
<p>下面的列表描述了文件的操作：</p>
<ul>
<li><code>struct module *owner;</code>：指向一个模块的拥有者，该字段主要应用于那些有模块产生的文件系统</li>
<li><code>loff_t (*llseek) (file, offset, origin);</code>：更新文件指针。</li>
<li><code>ssize_t (*read) (file, buf, count, offset);</code>：从文件的<code>*offset</code>处开始读出<code>count</code>个字节；然后增加<code>*offset</code>的值（一般与文件指针对应）。</li>
<li><code>ssize_t (*aio_read) (req, buf, len, pos);</code>：启动一个异步I/O操作，从文件的<code>pos</code>处开始读出<code>len</code>个字节的数据并将它们放入<code>buf</code>中（引入它是为了支持<code>io_submit()</code>系统调用）。 </li>
<li><code>ssize_t (*write) (file, buf, count, offset);</code>：从文件的<code>*offset</code>处开始写入<code>count</code>个字节，然后增加<code>*offset</code>的值（一般与文件指针对应）。 </li>
<li><code>ssize_t (*aio_write) (req, buf, len, pos);</code>：启动一个异步I/O操作，从<code>buf</code>中取<code>len</code>个字节写入文件<code>pos</code>处。 </li>
<li><code>int (*readdir) (dir, dirent, filldir);</code>：返回一个目录的下一个目录项，返回值存人参数<code>dirent</code>；参数<code>filldir</code>存放一个辅助函数的地址，该函数可以提取目录项的各个字段。</li>
<li><p><code>unsigned int (*poll) (file, poll_table);</code>：检查是否在一个文件上有操作发生，如果没有则睡眠，直到该文件上有操作发生。</p>
</li>
<li><p><code>int (*ioctl) (inode, file, cmd, args);</code>：向一个基本硬件设备发送命令。该方法只适用于设备文件。</p>
</li>
<li><code>long (*unlocked_ioctl) (file, cmd, args);</code>：与<code>ioctl</code>方法类似，但是它不用获得大内核锁。我们认为所有的设备驱动程序和文件系统都将使用这个新方法而不是<code>loctl</code>方法。 </li>
<li><code>long (*compat_ioctl) (file, cmd, args);</code>：64位的内核使用该方法执行32位的系统调用<code>ioctl()</code>。</li>
<li><code>int (*mmap) (file, vm_area_struct);</code>：执行文件的内存映射，并将映射放入进程的地址空间。</li>
<li><code>int (*open) (inode, file);</code>：通过创建一个新的文件对象而打开一个文件，并把它链接到相应的索引节点对象。 </li>
<li><code>int (*flush) (file);</code>：当打开文件的引用被关闭时调用该方法。该方法的实际用途取决于文件系统。</li>
<li><code>int (*release) (inode, file);</code>：释放文件对象。当打开文件的最后一个引用被关闭时（即文件对象f_count字段的值变为0时）调用该方法。</li>
<li><code>int (*fsync) (file, dentry, datasync);</code>：将文件所缓存的全部数据写入磁盘。</li>
<li><code>int (*aio_fsync) (req, datasync);</code>：启动一次异步I/O刷新操作。</li>
<li><code>int (*fasync) (fd, file, on);</code>：通过信号来启用或禁止I/O事件通告。</li>
<li><code>int (*lock) (file, cmd, file_lock);</code>：对file文件申请一个锁。</li>
<li><code>ssize_t (*readv) (file, vector, count, offset);</code>：从文件中读字节，并把结果放入<code>vector</code>描述的缓冲区中；缓冲区的个数由<code>count</code>指定。</li>
<li><code>ssize_t (*writev) (file, vector,  count, offset);</code>：把vector描述的缓冲区中的字节写人文件；缓冲区的个数由<code>count</code>指定。</li>
<li><code>ssize_t (*sendfile) (in_file,  count, offset, read_actor_t, out_file);</code>：把数据从<code>in_file</code>传送到<code>out_file</code>（引人它是为了支持<code>sendfile()</code>系统调用）。 </li>
<li><code>ssize_t (*sendpage) (file, page, offset, size, pointer, fill);</code>：把数据从文件传送到页高速缓存的页；这个低层方法由<code>sendfile()</code>和用于套接字的网络代码使用。</li>
<li><code>unsigned long (*get_unmapped_area)(file, addr, len, offset, flag);</code>：获得一个未用的地址范围来映射文件。</li>
<li><code>int (*check_flags)(flags);</code>：当设置文件的状态标志（<code>F_SETFL</code>命令）时，<code>fcntl()</code>系统调用的服务例程调用该方法执行附加的检查。当前只适用于NFS网络文件系统。</li>
<li><code>int (*dir_notify)(file, arg);</code>：当建立一个目录更改通告（<code>F_NOTIFY</code>命令）时，由<code>fcntl()</code>系统调用的服务例程调用该方法。当前只适用于CIFS（Common Internet File   system，公用互联网文件系统）网络文件系统。</li>
<li><code>int (*flock) (file, falg, file_lock);</code>：用于定制<code>flock()</code>系统调用的行为。官方Linux文件系统不使用该方法。*/</li>
</ul>
<h3 id="目录项对象"><a href="#目录项对象" class="headerlink" title="目录项对象"></a>目录项对象</h3><p><strong>VFS把每个目录看作由若干子目录和文件组成的一个普通文件</strong>。然而目录项不同，一旦目录项被读入内存，VFS就把它转换成<strong>基于dentry结构的一个目录项对象</strong>。对于进程查找的路径名中的每个分量，内核都为其创建一个目录项对象；目录项对象将每个分量与其对应的索引节点相联系。</p>
<p>请注意，<strong>目录项对象在磁盘上并没有对应的映像，因此在dentry结构中不包含指出该对象已被修改的字段</strong>。目录项对象存放在名为<code>dentry_cache</code>的slab分配器高速缓存中。因此，目录项对象的创建和删除是通过调用<code>kmem_cache_alloc()</code>和<code>kmem_cache_free()</code>实现的。<br><img src="/img/1602756716.png" alt=""></p>
<p>每个目录项对象可以处于以下四种状态之一：</p>
<ul>
<li><strong>空闲状态</strong>（free）：处于该状态的目录项对象不包括有效的信息，且还没有被VFS使用。对应的内存区由slab分配器进行处理。</li>
<li><strong>未使用状态</strong>（unused）：处于该状态的目录项对象当前<strong>还没有被内核使用</strong>。该对象的引用计数器<code>d_count</code>的值为0，但其<code>d_inode</code>字段仍然指向关联的索引节点。该目录项对象包含有效的信息，但为了在必要时回收内存，它的内容可能被丢弃。</li>
<li><strong>正在使用状态</strong>（in use）：处于该状态的目录项对象当前<strong>正在被内核使用</strong>。该对象的引用计数器<code>d_count</code>的值为正数，其<code>d_inode</code>字段指向关联的索引节点对象。该目录项对象包含有效的信息，并且不能被丢弃。</li>
<li><strong>负状态</strong>（negative）：<strong>与目录项关联的索引节点不复存在</strong>，那是因为相应的磁盘索引节点已被删除，或者因为目录项对象是通过解析一个不存在文件的路径名创建的。目录项对象的<code>d_inode</code>字段被置为NULL，但该对象仍然被保存在目录项高速缓存中，以便后续对同一文件目录名的查找操作能够快速完成。术语“负状态”容易使人误解，因为根本不涉及任何负值。</li>
</ul>
<p>与目录项对象关联的方法称为<strong>目录项操作</strong>。这些方法由<code>dentry_operations</code>结构加以描述，该结构的地址存放在目录项对象的<code>d_op</code>字段中。尽管一些文件系统定义了它们自己的目录项方法，但是这些字段通常为NULL，而VFS使用缺省函数代替这些方法：</p>
<ul>
<li><code>int (*d_revalidate)(struct dentry *, struct nameidata *);</code>：在把目录项对象转换为一个文件路径名之前，判定该目录项对象是否仍然有效。缺省的VFS函数什么也不做，而网络文件系统可以指定自己的函数。</li>
<li><code>int (*d_hash) (struct dentry *, struct qstr *);</code>：生成一个散列值；这是用于目录项散列表的、特定干具体文件系统的散列函数。参数dentry标识包含路径分量的目录。参数name指向一个结构，该结构包含要查找的路径名分量以及由散列函数生成的散列值。</li>
<li><code>int (*d_compare) (struct dentry *, struct qstr *, struct qstr *);</code>：比较两个文件名。name1应该属于dir所指的目录。缺省的VFS函数是常用的字符串匹配函数。不过，每个文件系统可用自己的方式实现这一方法。例如，MS.DOS文件系统不区分大写和小写字母。</li>
<li><code>int (*d_delete)(struct dentry *);</code>：当对目录项对象的最后一个引用被删除（<code>d_count</code>变为“0”）时，调用该方法。缺省的VFS函数什么也不做。</li>
<li><code>void (*d_release)(struct dentry *);</code>：当要释放一个目录项对象时（放入slab分配器），调用该方法。缺省的VFS函数什么也不做。</li>
<li><code>void (*d_iput)(struct dentry *, struct inode *);</code>：当一个目录项对象变为“负”状态（即丢弃它的索引节点）时，调用该方法。缺省的VFS函数调用<code>iput()</code>释放索引节点对象。<br>};</li>
</ul>
<h3 id="目录项高速缓存"><a href="#目录项高速缓存" class="headerlink" title="目录项高速缓存"></a>目录项高速缓存</h3><p>为了最大限度地提高处理同一个文件需要被反复访问的这些目录项对象的效率，Linux使用目录项高速缓存，它由两种类型的数据结构组成：</p>
<ul>
<li>一个<strong>处于正在使用、未使用或负状态的目录项对象的集合</strong>。</li>
<li>一个<strong>散列表，从中能够快速获取与给定的文件名和目录名对应的目录项对象</strong>。同样，如果访问的对象不在目录项高速缓存中，则散列表函数返回一个空值。</li>
</ul>
<p>目录项高速缓存的作用还相当于<strong>索引节点高速缓存(inode cache)的控制器</strong>。在内核内存中，并不丢弃与未用目录项相关的索引节点，这是由于目录项高速缓存仍在使用它们。因此，这些索引节点对象保存在RAM中，并能够借助相应的目录项快速引用它们。</p>
<p>所有“未使用”目录项对象都存放在一个<strong>最近最少使用(Least Recently used, LRU)</strong>的双向链表中，该链表按照插入的时间顺序。换句话说，最后释放的目录项对象放在链表的首部，所以最近最少使用的目录项对象总是靠近链表的尾部。一旦目录项高速缓存的空间开始变小，内核就从链表的尾部删除元素，使得最近最常使用的对象得以保留。</p>
<p>LRU链表的首元素和尾元素地址存放在<code>list_head</code>类型的<code>dentry_unused</code>变量的<code>next</code>和<code>prev</code>字段中。目录项对象的<code>d_lru</code>字段包含指向链表中相邻目录项的指针。</p>
<p>每个正在使用的目录项对象都被插入一个双向链表中，该链表由相应索引节点对象的<code>i_dentry</code>字段指向。目录项对象的<code>d_alias</code>字段存放链表中相邻元素的地址。指向相应文件的最后一个硬链接被删除之后，一个正在使用的目录项可能会变成负状态。这时该目录项对象被移动到未使用目录项对象组成的LRU链表中。这些对象就逐渐被释放。</p>
<h2 id="与进程相关的文件"><a href="#与进程相关的文件" class="headerlink" title="与进程相关的文件"></a>与进程相关的文件</h2><p>每个进程都有它自己当前的工作目录和它自己的根目录。这仅仅是内核用来表示进程与文件系统相互作用所必须维护的数据中的两个例子。类型为<code>fs_struct</code>的整个数据结构就用于此目的，且每个进程描述符的<code>fs</code>字段就指向进程的<code>fs_struct</code>结构。<br><img src="/img/1603188017.png" alt=""></p>
<p>第二个表表示进程当前打开的文件，表的地址存放于进程描述符的<code>files</code>字段，类型为<code>files_struct</code>。<br><img src="/img/1603188019.png" alt=""></p>
<p><code>fd</code>字段指向<strong>文件对象的指针数组</strong>。该数组的长度存放在<code>max_fds</code>字段中。通常，<code>fd</code>字段指向<code>files_struct</code>结构的<code>fd_array</code>字段，该字段包括32个文件对象指针。如果进程打开的文件数目多余32，内核就分配一个新的、更大的文件指针数组，并将其地址存放在<code>fd</code>字段中，内核同时也更新<code>max_fds</code>字段的值。</p>
<p>对于在fd数组中有元素的每个文件来说，数组的索引就是<strong>文件描述符</strong>(file descriptor)。通常，数组的第一个元素(索引为0)是进程的标准输入文件，数组的第二个元素(索引为1)是进程的标准输出文件，数组的第三个元素(索引为2)是进程的标准错误文件。两个文件描述符可以指向同一个文件。进程不能使用多于<code>NR_OPEN</code>个文件描述符。内核也在进程描述符的<code>signal-&gt;rlim[RLIMIT_NOFILE]</code>结构上强制动态限制文件描述符的最大数。</p>
<p><code>open_fds</code>字段最初包含<code>open_fds_init</code>的地址，<code>open_fds_init</code>表示当前已打开文件的文件描述符的位图。<code>max_fdset</code>存放位图中的位数。当内核开始使用一个文件对象时，内核提供<code>fget()</code>函数。这个函数接收文件描述符<code>fd</code>作为参数，返回在<code>current-&gt;files-&gt;fd[fd]</code>中的地址，即对应文件对象的地址，如果没有任何文件与fd对应，则返回NULL。<br><img src="/img/1603195761.jpg" alt=""></p>
<p>当内核控制路径完成对文件对象的使用时，调用内核提供的<code>fput()</code>函数。该函数将文件对象的地址作为参数，并递减文件对象引用计数器<code>f_count</code>的值，另外，如果这个域变为0，该函数就调用文件操作的release方法（如果已定义），释放相应的目录项对象，并递减对应索引节点对象的i_write域的值（如果该文件是写打开），最后，将该文件对象从“正在使用”链表移到“未使用”链表。　</p>
<h2 id="文件系统类型"><a href="#文件系统类型" class="headerlink" title="文件系统类型"></a>文件系统类型</h2><p><strong>文件系统注册</strong>——也就是通常在系统初始化期间并且在使用文件系统类型之前必须执行的基本操作。一旦文件系统被注册，其特定的函数对内核就是可用的，因此文件系统类型可以安装在系统的目录树上。</p>
<h3 id="特殊文件系统"><a href="#特殊文件系统" class="headerlink" title="特殊文件系统"></a>特殊文件系统</h3><p><strong>特殊文件系统</strong>为系统程序员和管理员提供一种容易的方式来<strong>操作内核的数据结构并实现系统的特殊特征</strong>。常用特殊文件系统如表，有几个文件系统没有固定的安装点，可以自由安装使用。一些文件系统不是用于与用户交互，所以没有安装点。<br><img src="/img/1603211045.jpg" alt=""></p>
<p>特殊文件系统不限于物理设备。然而，内核给每个安装的特殊文件系统分配一个虚拟的块设备，让其主设备号是0，而次设备号具有任意值（每个特定文件系统具有不同的值）。<code>set_anon_super()</code>函数用于<strong>初始化特殊文件系统的超级块</strong>；该函数本质上获得一个未使用的次设备号<code>dev</code>，然后用主设备号0和次设备号<code>dev</code>设置新超级块的<code>s_dev</code>字段。而另一个<code>kill_anon_super()</code>函数<strong>移走特殊文件系统的超级块</strong>。<code>unnamed_dev_ida</code>变量包含一个辅助结构（记录当前在用的次设备号）的指针。</p>
<h3 id="文件系统类型注册"><a href="#文件系统类型注册" class="headerlink" title="文件系统类型注册"></a>文件系统类型注册</h3><p>文件系统的源代码实际上要么包含在内核映像中，要么作为一个模块被动态装入。VFS必须对代码目前已经在内核中的所有文件系统的类型进行跟踪，这是通过进行文件系统类型注册实现的。注册的文件系统用<code>file_system_type</code>类型表示。<br><img src="/img/1603211266.jpg" alt=""></p>
<p>所有文件系统类型的对象都插入到一个单向链表中。由变量<code>file_systems</code>指向链表的第一个元素，而结构中的<code>next</code>字段指向链表的下一个元素。<code>file_systems_lock</code>读/写自旋锁保护整个链表免受同时访问。<code>fs_supers</code>表示给定类型的已安装文件系统所对应的超级块链表的头。链表元素的向后和向前链接存放在超级块对象的<code>s_instances</code>字段中。<code>get_sb</code>指向依赖于文件系统类型的函数，该函数分配一个新的超级块对象并初始化。<code>kill_sb</code>指向删除超级块的函数。<code>fs_flags</code>存放几个标志：<br><img src="/img/1603211439.jpg" alt=""></p>
<p>在系统初始化期间，调用<code>register_filesystem()</code>函数来注册编译时指定的每个文件系统；该函数把相应的<code>file_system_type</code>对象插入到文件系统类型的链表中。当实现了文件系统的模块被装入时，也要调用<code>register_filesystem()</code>函数。在这种情况下，当该模块被卸载时，对应的文件系统也可以被注销(调用<code>unregister_filesystem()</code>函数)。</p>
<p><code>get_fs_type()</code>函数扫描已注册的文件系统链表以查找文件系统类型的<code>name</code>字段，并返回指向相应的<code>file_system_type</code>对象的指针。</p>
<h2 id="文件系统处理"><a href="#文件系统处理" class="headerlink" title="文件系统处理"></a>文件系统处理</h2><p>就像每个传统的Unix系统一样，Linux也使用<strong>系统的根文件系统</strong>(system’s root filesystem)：<strong>它由内核在引导阶段直接安装，并拥有系统初始化脚本以及最基本的系统程序</strong>。</p>
<p>其他文件系统要么由初始化脚本安装，要么由用户直接安装在已安装文件系统的目录上。<strong>作为一个目录树，每个文件系统都拥有自己的根目录</strong>(root directory)。安装文件系统的这个目录称之为<strong>安装点</strong>(mount point)。<strong>已安装文件系统属于安装点目录的一个子文件系统</strong>。例如，<code>/proc</code>虚拟文件系统是系统的根文件系统的孩子(且系统的根文件系统是<code>/proc</code>的父亲)。已安装文件系统的根目录隐藏了父文件系统的安装点目录原来的内容，而且父文件系统的整个子树位于安装点之下。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在传统的Unix系统中，只有一个已安装文件系统树：从系统的根文件系统开始，<strong>每个进程通过指定合适的路径名可以访问已安装文件系统中的任何文件</strong>。从这个方面考虑，Linux2.6更加的精确：每个进程可拥有自己的已安装文件系统树——叫做<strong>进程的命令空间</strong>(namespace)。</p>
<p>通常大多数进程共享同一个命名空间，即<strong>位于系统的根文件系统且被init进程使用的已安装文件系统树</strong>。不过，如果<code>clone()</code>系统调用以<code>CLONE_NEWNS</code>标志创建一个新进程，那么进程将获取一个新的命名空间。这个新的命名空间随后由子进程继承(如果父进程没有以<code>CLONE_NEWNS</code>标志创建这些子进程)。</p>
<p>当进程安装或卸载一个文件系统时，仅修改它的命名空间。因此，所做的修改对共享同一命名空间的所有进程都是可见的，并且也只对它们可见。进程甚至可通过使用Linux特有的<code>pivot_root()</code>系统调用来改变它的命名空间的根文件系统。</p>
<p>进程的命名空间由进程描述符的<code>namespace</code>字段指向的<code>namespace</code>结构描述。<code>root</code>表示已安装文件系统。<br><img src="/img/1603211726.jpg" alt=""></p>
<h3 id="文件系统安装"><a href="#文件系统安装" class="headerlink" title="文件系统安装"></a>文件系统安装</h3><p>当一个文件系统被安装了n次时，它的根目录可通过n个安装点访问。不管一个文件系统被安装了多少次，都仅有一个超级块对象。</p>
<p><strong>安装的文件系统形成一个层次</strong>：一个文件系统的安装点可能成为第二个文件系统的目录，而第二个文件系统又安装在第三个文件系统之上。</p>
<p>把多个安装堆叠在一个单独的安装上也是可能的。尽管已经使用先前安装下的文件和目录的进程可以继续使用，但在同一安装点上的新安装隐藏前一个安装的文件系统。当最顶层的安装被删除时，下一层的安装再一次变为可见的。</p>
<p>对每个安装操作，内核必须在内存中保存安装点和安装标志，以及要安装文件系统与其他已安装文件系统之间的关系。每个描述符是一个具有<code>vfsmount</code>类型的数据结构。<br><img src="/img/1603188020.png" alt=""></p>
<p><code>vfsmount</code>结构会被保存在几个双向循环链表中：</p>
<ul>
<li>由父文件系统<code>vfsmount</code>描述符的地址和挂载点目录的目录项对象的地址索引的散列表。散列表存放在<code>mount_hashtable</code>数组（<code>fs/namespace.c</code>, <code>static struct list_head *mount_hashtable __read_mostly;</code>）中，其大小取决于系统中RAM的容量。表中每一项是具有同一散列值的所有描述符形成的双向循环链表的头。描述符的<code>mnt_hash</code>字段包含指向链表中相邻元素的指针。</li>
<li>对于每一个命名空间，所有属于此命名空间的已挂载文件系统描述符形成了一个双向链表。<code>namespace</code>结构的<code>list</code>字段存放链表的头，<code>vfsmount</code>描述符的<code>mnt_list</code>字段包含链表中指向相邻元素的指针。</li>
<li>对于每一个已安装的文件系统，所有已安装的子文件系统形成了一个双向循环链表。链表的头存放在<code>vfsmount</code>描述符的<code>mnt_mounts</code>字段；子描述符的<code>mnt_child</code>字段存放指向链表中相邻元素的指针。</li>
</ul>
<p><code>vfsmount_lock</code>自旋锁（<code>fs/namespace.c</code>, <code>__cacheline_aligned_in_smp DEFINE_SPINLOCK(vfsmount_lock);</code>）保护<code>vfsmount</code>对象的链表免受同时访问。</p>
<p>描述符的<code>mnt_flags</code>字段存放几个标志的值，用以指定如何处理已安装文件系统中的某些种类的文件。这些标志可通过<code>mount</code>命令的选项进行设置。所有的标志定义如下：</p>
<ul>
<li><code>MNT_NOSUID</code>：在已安装的文件系统中禁止<code>setuid</code>和<code>setgid</code>标志</li>
<li><code>MNT_NODEV</code>：在已安装的文件系统中禁止访问设备文件</li>
<li><code>MNT_NOEXEC</code>：在已安装文件系统中禁止程序执行</li>
</ul>
<p>内核提供了几个用以处理<code>vfsmount</code>描述符的函数：</p>
<ul>
<li><code>struct vfsmount *alloc_vfsmnt(const char *name)</code>：分配和初始化一个<code>vfsmount</code>描述符</li>
<li><code>void free_vfsmnt(struct vfsmount *mnt)</code>：释放由<code>mnt</code>指向的<code>vfsmount</code>描述符</li>
<li><code>struct vfsmount *lookup_mnt(struct path *path)</code>：在散列表中查找一个<code>vfsmount</code>并返回它的地址</li>
</ul>
<h3 id="安装普通文件系统"><a href="#安装普通文件系统" class="headerlink" title="安装普通文件系统"></a>安装普通文件系统</h3><p><code>mount()</code>系统调用被用来安装一个普通文件系统；它的服务例程<code>sys_mount()</code>作用于以下参数：</p>
<ul>
<li>文件系统所在的设备文件的路径名，或者如果不需要的话就为NULL。</li>
<li>文件系统被安装其上的某个目录的目录路径名(安装点)。</li>
<li>文件系统的类型，必须是已注册文件系统的名字。</li>
<li>安装标志(见表格)。</li>
<li>指向一个与文件系统相关的数据结构的指针(也许为NULL)。</li>
</ul>
<p><img src="/img/1603188022.png" alt=""></p>
<p><code>sys_mount()</code>函数把参数拷贝到临时内核缓冲区，获取大内核锁，并调用<code>do_mount()</code>函数。一旦<code>do_mount()</code>返回，释放大内核锁并释放临时缓冲区。</p>
<p>do_mount()步骤：</p>
<ol>
<li>检查安装标志<code>MS_NOSUID</code>，<code>MS_NODEV</code>或<code>MS_NOEXEC</code>，并在<code>vfsmount</code>对象中设置相应标志</li>
<li>调用<code>path_lookup()</code>查找安装点路径名</li>
<li>检查安装标志：<ol>
<li>如果<code>MS_REMOUNT</code>，其目的是改变超级块对象<code>s_flags</code>的安装标志，以及已安装文件系统对象<code>mnt_flags</code>的安装文件系统标志。<code>do_remount()</code>执行这些改变；</li>
<li>否则检查<code>MS_BIND</code>，用户要求在系统目录树的另一个安装点上的文件或目录能够可见</li>
<li>否则检查<code>MS_MOVE</code>，用户要求改变安装点，<code>do_move_mount()</code></li>
<li>否则，<code>do_new_mount()</code>，当用户安装一个特殊文件系统或存放在磁盘分区中的普通文件系统时触发该函数。它调用<code>do_kern_mount()</code>。它出击时机的安装操作并返回一个新安装文件系统描述符的地址。然后<code>do_new_mount()</code>调用<code>do_add_mount()</code>，后者执行：<ol>
<li>获得当前进程的写信号量<code>namespace-&gt;sem</code></li>
<li>验证在安装点上最近安装的文件系统是否仍指向当前的namespace，不是释放sem，返回错误码</li>
<li>如果要安装的文件系统已经被安装在由系统调用的参数所指定的安装点上，或该安装点是一个符号链接，则释放sem，返回错误码</li>
<li>初始化<code>do_kernel_mount()</code>分配的新的安装文件系统对象的<code>mnt_flags</code>字段的标志</li>
<li>调用<code>graft_tree()</code>把新安装的文件系统对象插入到<code>namespace</code>链表、散列表以及父文件系统的子链表中</li>
<li>释放sem，返回。</li>
</ol>
</li>
</ol>
</li>
<li>调用<code>path_release()</code>终止安装点路径名查找，并返回0.</li>
</ol>
<h3 id="do-kern-mount-函数："><a href="#do-kern-mount-函数：" class="headerlink" title="do_kern_mount()函数："></a>do_kern_mount()函数：</h3><p>安装操作的核心是<code>do_kern_mount()</code>，他检查文件系统类型以决定安装操作是如何完成的。参数：</p>
<ol>
<li><code>fstype</code>：要安装文件系统类型名</li>
<li><code>flags</code>：安装标志</li>
<li><code>name</code>：存放文件系统的块设备路径名</li>
<li><code>data</code>：指向传递给文件系统<code>read_super</code>方法的附加数据指针</li>
</ol>
<p>该函数通过下列操作实现安装：</p>
<ol>
<li>调用<code>get_fs_type()</code>在文件系统列表中搜索并确定放在<code>fstype</code>参数中的名字的位置；返回局部变量<code>type</code>中对应的<code>file_system_type</code>描述符的位置</li>
<li>调用<code>alloc_vfsmnt()</code>分配<code>vfsmount</code>描述符，并给<code>mnt</code>局部变量赋值</li>
<li>调用<code>type-&gt;get_sb()</code>分配并初始化一个新的超级块</li>
<li>用新的超级块给<code>mnt-&gt;mnt-sb</code>赋值</li>
<li>将<code>mnt-&gt;mnt_root</code>字段初始化为与文件系统根目录对应的目录项对象的地址，存在于<code>super_block</code>中的<code>s_root</code>字段中，并增加该目录项对象引用计数器值。</li>
<li>用<code>mnt</code>中的值初始化<code>mnt-&gt;mnt_parent</code>字段，</li>
<li>用<code>current-&gt;namespace</code>初始化<code>mnt-&gt;mnt_namespace</code></li>
<li>释放超级块的读写信号量<code>s_unmont</code></li>
<li>返回已安装文件系统对象的地址<code>mnt</code></li>
</ol>
<h3 id="分配超级块对象"><a href="#分配超级块对象" class="headerlink" title="分配超级块对象"></a>分配超级块对象</h3><p>文件系统对象的<code>get_sb</code>方法由单行函数实现的。</p>
<p><code>get_sb_bdev()</code>VFS函数分配并初始化一个新的适合于磁盘文件系统的超级块；<code>get_sb_pseudo()</code>针对没有安装点的特殊文件系统如pipefs；<code>get_sb_single()</code>针对具有唯一安装点的特殊文件系统如sysfs；<code>get_sb_nodev()</code>针对可以安装多次的特殊文件系统如tmpfs</p>
<p><code>get_sb_bdev()</code>步骤：</p>
<ol>
<li>调用<code>open_bdev_excl()</code>打开设备文件名为<code>dev_name</code>的块设备</li>
<li>调用<code>sget()</code>搜索文件系统的超级块链表（<code>type-&gt;fs_supers</code>）。如果找到一个与块设备相关的超级块，则返回它的地址；否则分配并初始化一个新的超级块，将其插入到文件系统链表和超级块全局链表中，并返回其地址</li>
<li>如果不是新的超级块，则跳6</li>
<li>把参数<code>flags</code>中的值拷贝到超级块的<code>s_flags</code>中，并将<code>s_id</code>、<code>s_old_blocksize</code>以及<code>s_blocksize</code>字段置为块设备的合适值</li>
<li>调用以来文件系统的函数访问磁盘上超级块的信息，并填充新超级块对象的其他字段</li>
<li>返回新超级块对象的地址</li>
</ol>
<h3 id="安装根文件系统"><a href="#安装根文件系统" class="headerlink" title="安装根文件系统"></a>安装根文件系统</h3><p>安装根文件系统是系统初始化的关键部分。当编译内核时，或者向最初的启动装入程序传递一个合适的“root”选项时，根文件系统可以被指定为<code>/dev</code>目录下的一个设备文件。类似地，根文件系统的安装标志存放在<code>root_mountflags</code>变量中。用户可以指定这些标志，或者通过对已编译的内核映像使用<code>rdev</code>外部程序，或者向最初的启动装入程序传递一个合适的<code>rootflags</code>选项来达到。</p>
<p>安装根文件系统分为两个阶段：</p>
<ul>
<li>内核安装特殊rootfs文件系统，该文件系统仅提供一个作为初始安装点的空目录。</li>
<li>内核在空目录上安装实际的根文件系统。</li>
</ul>
<p><strong>rootfs文件系统允许内核容易地改变实际根文件系统</strong>。实际上，在大多数情况下，系统初始化是内核会逐个地安装和卸载几个根文件系统。</p>
<h4 id="阶段1：安装rootfs文件系统"><a href="#阶段1：安装rootfs文件系统" class="headerlink" title="阶段1：安装rootfs文件系统"></a>阶段1：安装rootfs文件系统</h4><p>第一阶段由<code>init_rootfs()</code>和<code>init_mount_tree()</code>函数完成，他们在系统初始化过程中执行。</p>
<p><code>init_rootfs()</code>函数注册特殊文件系统类型rootfs：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">rootfs_fs_type</span> =</span> &#123;</span><br><span class="line">	.name = <span class="string">&quot;rootfs&quot;</span>;</span><br><span class="line">	.get_sb = rootfs_get_sb;</span><br><span class="line">	.kill_sb = kill_litter_super;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>init_mount_tree()</code>执行如下操作：</p>
<ul>
<li>调用<code>do_kern_mount()</code>函数，把字符串”rootfs”作为文件系统类型和设备名参数传递给它，把该函数返回的新安装文件系统描述符的地址保存在<code>mnt</code>局部变量中。如前面所说，<code>do_kern_mount()</code>调用<code>get_sb</code>，也就是<code>get_fs_type()</code>。<ul>
<li><code>get_sb_nodev()</code>则执行操作：</li>
<li>调用<code>sget()</code>函数分配新的超级块，传递<code>set_anon_super()</code>函数的地址作为参数，用合适的方式设置超级块的<code>s_dev</code>字段，主设备号为0，次设备号不同于其他已安装的特殊文件系统的次设备号。</li>
<li>将<code>flags</code>参数的值拷贝到超级块的<code>s_flags</code>字段中</li>
<li>调用<code>ramfs_fill_super()</code>函数分配索引节点对象和对应的目录项对象，并填充超级块字段值。</li>
<li>返回新超级块的地址</li>
</ul>
</li>
<li>为进程0的已挂载文件系统命名空间分配一个<code>namespace</code>对象，并将它插入到由<code>do_kern_mount()</code>函数返回的已安装文件系统描述符中</li>
<li>将系统中其他每个进程的<code>namespace</code>字段设置为<code>namespace</code>对象的地址；同时初始化引用计数器<code>namespace-&gt;count</code></li>
<li>将进程0的根目录和当前工作目录设置为根文件系统。</li>
</ul>
<h4 id="安装实际根文件系统"><a href="#安装实际根文件系统" class="headerlink" title="安装实际根文件系统"></a>安装实际根文件系统</h4><p>根文件系统安装操作的第二阶段是由内核在系统初始化即将结束时进行的。根据内核被编译时所选择的选项，和内核装入程序所传递的启动选项，可以有几种方法安装实际根文件系统。为了简单起见，我们只考虑磁盘文件系统的情况，它的设备文件名已通过“root”启动参数传递给内核。同时我们假定除了 rootfs文件系统外，没有使用其他初始特殊文件系统。</p>
<p><code>prepare_namespace()</code>函数执行如下操作：</p>
<ol>
<li>将<code>root_device_name</code>变量置为从启动参数“root”中获取的设备文件名。同样把<code>ROOT_DEV</code>变量置为同一设备文件的主设备号和次设备号</li>
<li>调用<code>mount_root()</code>函数，依次执行如下操作：<ol>
<li>调用<code>sys_mknod()</code>在rootfs初始化根文件系统中创建设备文件/dev/root，其主次设备号与存放在<code>ROOT_DEV</code>中的一样。</li>
<li>分配一个缓冲区并用文件系统类型名链表填充它。该链表要么通过启动参数“rootfstype”传送给内核，要么通过扫描文件系统类型单向链表中的元素建立</li>
<li>扫描上一步建立的文件系统类型名链表，对每个名字，调用<code>sys_mount()</code>试图在根设备上安装给定的文件系统类型。</li>
<li>调用<code>sys_chdir(&quot;/root&quot;)</code>改变进程的当前目录</li>
</ol>
</li>
<li>移动rootfs文件系统根目录上的已安装文件系统的安装点<code>sys_mount(&quot;.&quot;, &quot;/&quot;, NULL, MS_MOVE, NULL)</code></li>
</ol>
<h3 id="卸载文件系统"><a href="#卸载文件系统" class="headerlink" title="卸载文件系统"></a>卸载文件系统</h3><p><code>umount()</code>系统调用用来卸载一个文件系统。相应的<code>sys_umount()</code>服务例程作用于两个参数：文件名(多是安装点目录或是块设备文件名)和一组标志。</p>
<ol>
<li>调用<code>path_lookup()</code>查找安装点的路径名，将结果存放在<code>nameidata</code>类型的局部变量<code>nd</code>中；</li>
<li>如果查找的最终目录不是文件系统的安装点，则设置<code>retval</code>返回码为-EINVAL并跳到第6步。这种检查是通过验证<code>nd-&gt;mnt-&gt;mnt_root</code>（它包含由<code>nd.dentry</code>指向的目录项对象地址）进行的。</li>
<li>如果要卸载的文件系统还没有安装在命名空间中，则设置<code>retval</code>返回码为-EINVAL并跳到第6步。这种检查是通过在<code>nd-&gt;mnt</code>上调用<code>check_mnt()</code>函数进行的。</li>
<li>如果用户不具有卸载文件系统的特权，则设置<code>retval</code>返回码为-EPERM并跳到第6步。</li>
<li>调用<code>do_umount()</code>，传递给它的参数为<code>nd.mnt</code>（已安装文件系统对象）和<code>flags</code>（一组标志）。该函数执行下列操作：<ol>
<li>从已安装文件系统对象的<code>mnt_sb</code>字段检索超级块对象<code>sb</code>的地址。</li>
<li>如果用户要求强制卸载操作，则调用<code>umount_begin</code>超级块操作中断任何正在进行的安装操作。</li>
<li>如果要卸载的文件系统是根文件系统，且用户并不要求真正地把它卸载下来则调用<code>do_remount_sb()</code>重新安装根文件系统为只读并终止。</li>
<li>为进行写操作而获取当前进程的<code>namespace-&gt;sem</code>读/写信号量和<code>vfsmount_lock</code>自旋锁。</li>
<li>如果已安装文件系统不包含任何子安装文件系统的安装点，或者用户要求强制卸载文件系统，则调用<code>umount_tree()</code>卸载文件系统（及其所有子文件系统）</li>
<li>释放<code>vfsmount_lock</code>自旋锁和当前进程的<code>namespace-&gt;sem</code>读/写信号量。</li>
</ol>
</li>
<li>减少相应文件系统根目录的目录项对象和已安装文件系统描述符的引用计数器值；这些计数器值由<code>path_lookup()</code>增加。</li>
<li>返回<code>retval</code>的值。</li>
</ol>
<h2 id="路径名查找"><a href="#路径名查找" class="headerlink" title="路径名查找"></a>路径名查找</h2><p>当进程必须识别一个文件时，就把它的文件路径名传递给某个VFS系统调用，如<code>open()</code>、<code>mkdir()</code>、<code>rename()</code>或<code>stat()</code>。<br>执行这一任务的标准过程就是分析路径名并把它拆分成一个文件名序列除了最后一个文件名以外，所有的文件名都必定是目录。</p>
<p>如果路径名的第一个字符是“/”，那么这个路径名是<strong>绝对路径</strong>，因此从<code>current-&gt;fs-&gt;root</code>(进程的根目录)所标识的目录开始搜索。否则，路径名是<strong>相对路径</strong>，因此从<code>current-&gt;fs-&gt;pwd</code>(进程的当前目录)所标识的目录开始搜索。</p>
<p>在对初始目录的索引节点进行处理的过程中，代码要检查与第一个名字匹配的目录项，以获得相应的索引节点。然后，从磁盘读出包含那个索引节点的目录文件，并检查与第二个名字匹配的目录项，以获得相应的索引节点。对于包含在路径中的每个名字，这个过程反复执行。</p>
<p>目录项高速缓存极大地加速了这一过程，因为它把最近最常使用的目录项对象保留在内存中。正如我们以前看到的，每个这样的对象使特定目录中的一个文件名与它相应的索引节点相联系，因此在很多情况下，<strong>路径名的分析可以避免从磁盘读取中间目录</strong>。</p>
<p>但是，事情并不像看起来那么简单，因为必须考虑如下的Unix和VFS文件系统的特点：</p>
<ul>
<li><strong>对每个目录的访问权必须进行检查</strong>，以验证是否允许进程读取这一目录的内容。</li>
<li><strong>文件名可能是与任意一个路径名对应的符号链接</strong>；在这种情况下，分析必须扩展到那个路径名的所有分量。</li>
<li><strong>符号链接可能导致循环引用</strong>；内核必须考虑这个可能性，并能在出现这种情况时将循环终止。</li>
<li><strong>文件名可能是一个已安装文件系统的安装点</strong>。这种情况必须检测到，这样，查找操作必须延伸到新的文件系统。</li>
<li><strong>路径名查找应该在发出系统调用的进程的命名空间中完成</strong>。由具有不同命名空间的两个进程使用的相同路径名，可能指定了不同的文件。</li>
</ul>
<p>路径名查找是由<code>path_lookup()</code>函数执行的，它接收三个参数：</p>
<ul>
<li><code>name</code>：指向要解析的文件路径名的指针。</li>
<li><code>flags</code>：标志的值，表示将会怎样访问查找的文件。</li>
<li><code>nd</code>：<code>nameidata</code>数据结构的地址，这个结构存放了查找操作的结果。</li>
</ul>
<p><code>path_lookup</code>返回时，<code>nd</code>指向的<code>nameidata</code>结构用与路径名查找操作有关的数据来填充/<br><img src="/img/1603284009.jpg" alt=""></p>
<p><code>dentry</code>和<code>mnt</code>字段分别指向所解析的最后一个路径分量的目录项对象和已安装文件系统对象。这两个字段“描述”由给定路径名表示的文件。</p>
<p>由于<code>path_lookup()</code>函数返回的<code>nameidata</code>结构中的目录项对象和已安装文件系统对象代表了查找操作的结果，因此在<code>path_lookup()</code>的调用者完成使用查找结果之前，这个两个对象都不能被释放。因此，<code>path_lookup()</code>增加这两个对象引用计数器的值。如果调用者想释放这些对象，则调用<code>path_release()</code>函数，传递给它的参数就是<code>nameidata</code>结构的地址。</p>
<p><code>flags</code>字段存放查找操作中使用的某些标志的值，这些标志中的大部分可由调用者在<code>path_lookup()</code>的<code>flags</code>参数中进行设置：<br><img src="/img/1603284172.jpg" alt=""></p>
<p><code>path_lookup()</code>执行下列步骤：</p>
<ol>
<li>首先，如下初始化nd参数的某些字段：<ol>
<li><code>nd-&gt;last_type = LAST_ROOT;</code></li>
<li>nd-&gt;flags = flags;</li>
<li>nd-&gt;depth = 0;</li>
</ol>
</li>
<li>为进行读操作而获取当前进程的<code>current-&gt;fs-&gt;lock</code>读写信号量</li>
<li>如果路径名的第一个字符是“/”，那么查找操作必须从当前根目录开始：获取相应已安装文件对象(<code>current-&gt;fs-&gt;rootmnt</code>)和目录项对象(<code>current-&gt;fs-&gt;root</code>)的地址，增加引用计数器的值，并把它们的地址分别存放在<code>nd-&gt;mnt</code>和<code>nd-&gt;dentry</code>中。</li>
<li>否则，如果路径名的第一个字符不是“/”，则查找操作必须从当前工作目录开始：获得相应已安装文件系统对象（<code>current-&gt;fs-&gt;mt</code>）和目录项对象（<code>current-&gt;fs-&gt;pwd</code>）的地址，增加引用计数器的值，并把它们的地址分别存放在<code>nd-&gt;mnt</code>和<code>nd-&gt;dentry</code>中。</li>
<li>释放当前进程的<code>current-&gt;fs-&gt;lock</code>读写信号量</li>
<li>把当前进程描述符中的<code>total_link_count</code>字段置为0</li>
<li>调用<code>link_path_walk()</code>函数处理真正进行的查找操作：<code>retval = link_path_walk(name, nd);</code></li>
</ol>
<p>我们现在准备描述路径名查找操作的核心，也就是<code>link_path_walk()</code>函数。它接收的参数为要解析的路径名指针<code>name</code>和拥有目录项信息和安装文件系统信息的<code>nameidata</code>数据结构的地址<code>nd</code>。</p>
<h3 id="标准路径名查找"><a href="#标准路径名查找" class="headerlink" title="标准路径名查找"></a>标准路径名查找</h3><p>当<code>LOOKUP_PARENT</code>标志被清零时，<code>link_path_walk()</code>执行下列步骤：</p>
<ol>
<li>用<code>nd-&gt;flags</code>和<code>nd-&gt;dentry-&gt;d_inode</code>分别初始化<code>lookup_flags</code>和<code>inode</code>局部变量。</li>
<li>跳过路径名第一个分量前的任何斜杠（/）。</li>
<li>如果剩余的路径名为空，则返回0。在<code>nameidata</code>数据结构中，<code>dentry</code>和<code>mnt</code>字段指向原路径名最后一个所解析分量对应的对象。</li>
<li>如果<code>nd</code>描述符中的<code>depth</code>字段的值为正（大于0），则把<code>lookup_flags</code>局部变量置为<code>LOOKUP_FOLLOW</code>标志（这个跟符号链接查找相关）。</li>
<li>执行一个循环，把<code>name</code>参数中传递的路径名分解为分量（中间的“/”被当做文件名分隔符对待）；对于每个找到的分量，该函数：<ol>
<li>从<code>nd-&gt;dentry-&gt;d_inode</code>检索最近一个所解析分量的索引节点对象的地址</li>
<li>检查存放到索引节点中的最近那个所解析分量的许可权是否允许执行（在Unix中，只有目录是可执行的，它才可以被遍历）。执行<code>exec_permission_lite()</code>函数，该函数检查存放在索引节点<code>i_mode</code>字段的访问模式和运行进程的特权。在两种情况中，如果最近所解析分量不允许执行，那么<code>link_path_walk()</code>跳出循环并返回一个错误码：</li>
<li>考虑要解析的下一个分量。从它的名字，函数为目录项高速缓存散列表计算一个32位的散列值</li>
<li>如果“/”终止了要解析的分量名，则跳过“/”之后的任何尾部“/”</li>
<li>如果要解析的分量是原路径名中的最后一个分量，则跳到第6步</li>
<li>如果分量名是一个“.”（单个圆点），则继续下一个分量（“.”指的是当前目录，因此，这个点在目录内没有什么效果）</li>
<li>如果分量名是“..”（两个圆点），则尝试回到父目录：<ol>
<li>如果最近解析的目录是进程的根目录（<code>nd-&gt;dentry</code>等于<code>curren-&gt;fs-&gt;root</code>，而<code>nd-&gt;mnt</code>等于<code>current-&gt;fs-&gt;rootmnt</code>），那么再向上追踪是不允许的：在最近解析的分量上调用<code>follow_mount()</code>（见下面），继续下一个分量。</li>
<li>如果最近解析的目录是<code>nd-&gt;mnt</code>文件系统的根目录（<code>nd-&gt;dentry</code>等于<code>nd-&gt;mnt-&gt;mnt_root</code>)，并且这个文件系统也没有被安装在其他文件系统之上（<code>nd-&gt;mnt</code>等于<code>nd-&gt;mnt-&gt;mnt_parent</code>），那么<code>nd-&gt;mnt</code>文件系统通常就是命名空间的根文件系统：在这种情况下，再向上追踪是不可能的，因此在最近解析的分量上调用<code>follow_mount()</code>（参见下面），继续下一个分量。</li>
<li>如果最近解析的目录是<code>nd-&gt;mnt</code>文件系统的根目录，而这个文件系统被安装在其他文件系统之上，那么就需要文件系统交换。因此，把<code>nd-&gt;dentry</code>置为<code>nd-&gt;mnt-&gt;mnt_mountpoint</code>，且把<code>nd-&gt;mnt</code>置为<code>nd-&gt;mnt-&gt;mnt_parent</code>，然后重新开始第5g步（回想一下，几个文件系统可以安装在同一个安装点上）。</li>
<li>如果最近解析的目录不是已安装文件系统的根目录，那么必须回到父目录：把<code>nd-&gt;dentry</code>置为<code>nd-&gt;dentry-&gt;d_parent</code>，在父目录上调用<code>follow_mount()</code>，继续下一个分量。</li>
<li><code>follow_mount()</code>函数检查<code>nd-&gt;dentry</code>是否是某文件系统的安装点（<code>nd-&gt;dentry-&gt;d_mounted</code>的值大于0）；如果是，则调用<code>lookup_mnt()</code>搜索目录项高速缓存中已安装文件系统的根目录，并把<code>nd-&gt;dentry</code>和<code>nd-&gt;mnt</code>更新为相应已安装文件系统的安装点和安装系统对象的地址；然后重复整个操作（几个文件系统可以安装在同一个安装点上）。从本质上说，由于进程可能从某个文件系统的目录开始路径名的查找，而该目录被另一个安装在其父目录上的文件系统所隐藏，那么当需要回到父目录时，则调用<code>follow_mount()</code>函数。</li>
</ol>
</li>
<li>分量名既不是“.”，也不是“..”，因此函数必须在目录项高速缓存中查找它。如果低级文件系统有一个自定义的<code>d_hash</code>目录项方法，则调用它来修改已在第5b步计算出的散列值。</li>
<li>把<code>nd-&gt;flags</code>中<code>LOOKUP_CONTINUE</code>对应的位置位，这表示还有下一个分量要分析</li>
<li>调用<code>do_lookup()</code>，得到与给定的父目录（<code>nd-&gt;dentry</code>）和文件名（要解析的路径名分量<code>&amp;next</code>结果参数）相关的目录项对象，存放在结果参数next中：<code>err = do_lookup(nd, &amp;this, &amp;next, atomic);</code>。该函数本质上首先调用<code>__d_lookup()</code>在目录项高速缓存中搜索分量的目录项对象。如果没有找到这样的目录项对象，则调用<code>real_lookup()</code>。而<code>real_lookup()</code>执行索引节点的<code>lookup</code>方法从磁盘读取目录，创建一个新的目录项对象并把它插入到目录项高速缓存中，然后创建一个新的索引节点对象并把它插入到索引节点高速缓存中。在这一步结束时，<code>next</code>局部变量中的<code>dentry</code>和<code>mnt</code>字段将分别指向这次循环要解析的分量名的目录项对象和已安装文件系统对象。</li>
<li>调用<code>follow_mount()</code>检查刚解析的分量（<code>next.dentry</code>）是否指向某个文件系统安装点的一个目录（<code>next.dentry-&gt;d_mounted</code>值大于0）。<code>follow_mount()</code>更新<code>next.dentry</code>和<code>next.mnt</code>的值，以使它们指向由这个路径名分量所表示的目录上安装的最上层文件系统的目录项对象和已安装文件系统对象</li>
<li>检查刚解析的分量是否指向一个符号链接（<code>next.dentry-&gt;d_mode</code>具有一个自定义的<code>follow_link</code>方法）。</li>
<li>检查刚解析的分量是否指向一个目录（<code>next.dentry-&gt;d_inode</code>具有一个自定义的<code>lookup</code>方法）。</li>
<li>把<code>nd-&gt;dentry</code>和<code>nd-&gt;mnt</code>分别置为<code>next.dentry</code>和<code>next.mnt</code>，然后继续路径名的下一个分量</li>
</ol>
</li>
<li>除了最后一个分量，原路径名的所有分量都被解析，即循环体的<code>qstr</code>结构的<code>this</code>指向最后一个分量（<code>/test.conf</code>），<code>name</code>内部变量已经是NULL了，<code>nd</code>指向的<code>dentry</code>对应<code>this</code>的前一个分量（<code>/system-configure-ext2/test.conf</code>），此时<code>goto last_component;</code>如果跳出循环的话，那么清除<code>nd-&gt;flags</code>中的<code>LOOKUP_CONTINUE</code>标志</li>
<li>如果路径名尾部有一个“/”，则把<code>lookup_flags</code>局部变量中<code>LOOKUP_FOLLOW</code>和<code>LOOKUP_DIRECTORY</code>标志对应的位置位，以强制后边的函数来解释最后一个作为目录名的分量。</li>
<li>检查<code>lookup_flags</code>变量中<code>LOOKUP_PARENT</code>标志的值。下面假定这个标志被置为0，并把相反的情况推迟到<code>lookup_parent</code>。</li>
<li>如果最后一个分量名是“.”（单个圆点），则终止执行并返回值0（无错误）。在<code>nd</code>指向的<code>nameidata</code>数据结构中，<code>dentry</code>和<code>mnt</code>字段指向路径名中倒数第二个分量对应的对象（<code>/system-configure-ext2/test.conf</code>，任何分量“.”在路径名中没有效果）。</li>
<li>如果最后一个分量名是“..”（两个圆点），则尝试回到父目录：<ol>
<li>如果最后解析的目录是进程的根目录（<code>nd-&gt;dentry</code>等于<code>current-&gt;fs-&gt;root</code>，<code>nd-&gt;mnt</code>等于<code>current-&gt;fs-&gt;rootmnt</code>），则在倒数第二个分量上调用<code>follow_mount()</code>，终止执行并返回值0（无错误）。<code>nd-&gt;dentry</code>和<code>nd-&gt;mnt</code>指向路径名的倒数第二个分量对应的对象，也就是进程的根目录。</li>
<li>如果最后解析的目录是<code>nd-&gt;mnt</code>文件系统的根目录（<code>nd-&gt;dentry</code>等于<code>nd-&gt;mnt-&gt;mnt_root</code>），并且该文件系统没有被安装在另一个文件系统之上（<code>nd-&gt;mnt</code>等于<code>nd-&gt;mnt-&gt;mnt_parent</code>），那么再向上搜索是不可能的，因此在倒数第二个分量上调用<code>follow_mount()</code>，终止执行并返回值0（无错误）。</li>
<li>如果最后解析的目录是<code>nd-&gt;mnt</code>文件系统的根目录，并且该文件系统被安装在其他文件系统之上，那么把<code>nd-&gt;dentry</code>和<code>nd-&gt;mnt</code>分别置为<code>nd-&gt;mnt-&gt;mnt_mountpoint</code>和<code>nd-&gt;mnt_mnt_parent</code>，然后重新执行第10步。</li>
<li>如果最后解析的目录不是已安装文件系统的根目录，则把<code>nd-&gt;dentry</code>置为<code>nd-&gt;dentry-&gt;d_parent</code>，在父目录上调用<code>follow_mount()</code>，终止执行并返回值0（无错误）。<code>nd-&gt;dentry</code>和<code>nd-&gt;mnt</code>指向前一个分量（即路径名倒数第二个分量）对应的对象。</li>
</ol>
</li>
<li>路径名的最后分量名既不是“.”也不是“..”，因此，必须用<code>do_lookup</code>在高速缓存中查找它。如果低级文件系统有自定义的<code>d_hash</code>目录项方法，则该函数调用它来修改在第5c步已经计算出的散列值。</li>
<li>调用<code>do_lookup()</code>得到与父目录和文件名相关的目录项对象。这一步结束时，<code>next</code>局部变量存放的是指向最后分量名对应的目录项和已安装文件系统描述符的指针。</li>
<li>调用<code>follow_mount()</code>检查最后一个分两名是不是一个文件系统的安装点，如果是，则把<code>next</code>局部变量更新为最上层已安装文件系统根目录对应的目录项对象和已安装文件系统对象的地址。</li>
<li>检查在<code>lookup_flags</code>中是否设置了<code>LOOKUP_FOLLOW</code>标志，且索引节点对象<code>next.dentry-&gt;d_inode</code>是否有一个自定义的<code>follow_link</code>方法。如果是，分量就是一个必须进行解释的符号链接。</li>
<li>要解析的分量不是一个符号链接或符号链接不该被解释。把<code>nd-&gt;mnt和nd-&gt;dentry</code>字段分别置为<code>next.mnt</code>和<code>next.dentry</code>的值。最后的目录项对象就是整个查找操作的结果</li>
<li>检查<code>nd-&gt;dentry-&gt;d_inode</code>是否为NULL。这发生在没有索引节点与目录项对象关联时，通常是因为路径名指向一个不存在的文件。在这种情况下，返回一个错误码-ENOENT。</li>
<li>路径名的最后一个分量有一个关联的索引节点。如果在<code>lookup_flags</code>中设置了<code>LOOKUP_DIRECTORY</code>标志，则检查索引节点是否有一个自定义的<code>lookup</code>方法，也就是说它是一个目录。如果没有，则返回一个错误码-ENOTDIR。</li>
<li>返回值0（无错误）。<code>nd-&gt;dentry</code>和<code>nd-&gt;mnt</code>指向路径名的最后分量。</li>
</ol>
<h3 id="父路径名查找"><a href="#父路径名查找" class="headerlink" title="父路径名查找"></a>父路径名查找</h3><p>在很多情况下，查找操作应当取回最后分量的前一个分量的目录项对象。<strong>当查找操作必须解析的是包含路径名最后一个分量的目录而不是最后一个分量本身时，就使用<code>LOOKUP_PARENT</code>标志</strong>。</p>
<p>当<code>LOOKUP_PARENT</code>标志被设置时，<code>link_path_walk()</code>函数也在<code>nameidata</code>数据结构中建立<code>last</code>和<code>last_type</code>字段。<code>last</code>字段存放路径名中的最后一个分量名。last_type字段标识最后一个分量的类型；可以把它置为如下所示的值之一：</p>
<ul>
<li><code>LAST_NORM</code>：最后一个分量是普通文件名</li>
<li><code>LAST_ROOT</code>：最后一个分量是“/”（也就是整个路径名为“/”）</li>
<li><code>LAST_DOT</code>：最后一个分量是“.”</li>
<li><code>LAST_DOTDOT</code>：最后一个分量是“..”</li>
<li><code>LAST_BIND</code>：最后一个分量是链接到特殊文件系统的符号链接</li>
</ul>
<p>当整个路径名的查找操作开始时，<code>LAST_ROOT</code>标志是由<code>path_lookup()</code>设置的缺省值。如果路径名正好是“/”，则内核不改变<code>last_type</code>字段的初始值。</p>
<p><code>last_type</code>字段的其他值在<code>LOOKUP_PARENT</code>标志置位时由<code>link_path_walk()</code>设置；在这种情况下，函数执行直到第8步。不过，从第8步往后，路径名中最后一个分量的查找操作是不同的：</p>
<ol>
<li>把<code>nd-&gt;last</code>置为最后一个分两名</li>
<li>把<code>nd-&gt;last_type</code>初始化为<code>LAST_NORM</code></li>
<li>如果最后一个分量名为“.”（一个圆点），则把nd-&gt;last_type置为LAST_DOT。</li>
<li>如果最后一个分量名为“..”（两个圆点），则把nd-&gt;last_type置为LAST_DOTDOT。</li>
<li>通过返回值0（无错误）终止。</li>
</ol>
<p>你可以看到，最后一个分量根本就没有被解释。因此，当函数终止时，<code>nameidata</code>数据结构的<code>dentry</code>和<code>mnt</code>字段指向最后一个分量所在目录对应的对象。</p>
<h3 id="符号链接的查找"><a href="#符号链接的查找" class="headerlink" title="符号链接的查找"></a>符号链接的查找</h3><p>路径名可以包含符号链接，且必须由内核来解析。内核必须执行两个不同的查找操作：</p>
<ul>
<li>第一个操作解析/foo/bar：当内一核发现bar是一个符号链接名时，就必须提取它的内容并把它解释为另一个路径名；</li>
<li>第二个路径名操作从第一个操作所达到的目录开始，继续到符号链接路径名的最后一个分量被解析。</li>
<li>接下来，原来的查找操作从第二个操作所达到的目录项恢复，且有了原目录名中紧随符号链接的分量。</li>
</ul>
<p>假定一个符号链接指向自己，解析含有这样符号链接的路径名可能导致无休止的<strong>递归调用流</strong>，这又依次引发内核栈的溢出。当前进程的描述符中的<code>link_count</code>字段用来避免这种问题：每次递归执行前增加这个字段的值，执行之后减少其值。如果该字段的值达到6，整个循环操作就以错误码结束。因此，<strong>符号链接嵌套的层数不超过5</strong>。</p>
<p>另外，当前进程的描述符中的<code>total_link_count</code>字段记录在原查找操作中有多少符号链接（甚至非嵌套的）被跟踪。如果这个计数器的值到40，则查找操作中止。没有这个计数器，怀有恶意的用户就可能创建一个病态的路径名，让其中包含很多连续的符号链接，使内核在无休止的查找操作中冻结。</p>
<p>这就是代码基本工作的方式：<strong>一旦<code>link_path_walk()</code>函数检索到与路径名分量相关的录项对象，就检查相应的索引节点对象是否有自定义的<code>follow_link</code>方法</strong>。如果是，索引节点就是一个符号链接，在原路径名的查找操作进行之前就必须先对这个符号链接进行解释。</p>
<p>在这种情况下，<code>link_path_walk()</code>函数调用<code>do_follow_link()</code>，前者传递给后者的参数为符号链接目录项对象的地址<code>dentry</code>和<code>nameidata</code>数据结构的地址<code>nd</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">do_follow_link</span><span class="params">(<span class="keyword">struct</span> path *path, <span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> err = -ELOOP;</span><br><span class="line">     <span class="keyword">if</span> (current-&gt;link_count &gt;= MAX_NESTED_LINKS)</span><br><span class="line">          <span class="keyword">goto</span> loop;</span><br><span class="line">     <span class="keyword">if</span> (current-&gt;total_link_count &gt;= <span class="number">40</span>)</span><br><span class="line">          <span class="keyword">goto</span> loop;</span><br><span class="line">     BUG_ON(nd-&gt;depth &gt;= MAX_NESTED_LINKS);</span><br><span class="line">     cond_resched();</span><br><span class="line">     err = security_inode_follow_link(path-&gt;dentry, nd);</span><br><span class="line">     <span class="keyword">if</span> (err)</span><br><span class="line">          <span class="keyword">goto</span> loop;</span><br><span class="line">     current-&gt;link_count++;</span><br><span class="line">     current-&gt;total_link_count++;</span><br><span class="line">     nd-&gt;depth++;</span><br><span class="line">     err = __do_follow_link(path, nd);</span><br><span class="line">     current-&gt;link_count--;</span><br><span class="line">     nd-&gt;depth--;</span><br><span class="line">     <span class="keyword">return</span> err;</span><br><span class="line">loop:</span><br><span class="line">     dput_path(path, nd);</span><br><span class="line">     path_release(nd);</span><br><span class="line">     <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>do_follow_link()</code>依次执行下列步骤：</p>
<ol>
<li>检查<code>current-&gt;link_count</code>小于<code>MAX_NESTED_LINKS</code>，一般来说是5；否则，返回错误码-ELOOP。</li>
<li>检查<code>current-&gt;total_link_count</code>小于40；否则，返回错误码-ELOOP。</li>
<li>如果当前进程需要，则调用<code>cond_resched()</code>进行进程交换（设置当前进程描述符<code>thread_info</code>中的<code>TIF_NEED_RESCHED</code>标志）。</li>
<li>递增<code>current-&gt;link_count</code>、<code>current-&gt;total_link_count</code>和<code>nd-&gt;depth</code>的值。</li>
<li>更新与要解析的符号链接关联的索引节点的访问时间。</li>
<li>调用与具体文件系统相关的函数来实现<code>follow_link</code>方法，给它传递的参数为<code>dentry</code>和<code>nd</code>。它读取存放在符号链接索引节点中的路径名，并把这个路径名保存在<code>nd-&gt;saved_names</code>数组的合适项中。</li>
<li>通过<code>__do_follow_link</code>调用<code>__vfs_follow_link()</code>函数，给它传递的参数为地址<code>nd</code>和<code>nd-&gt;saved_names</code>数组中路径名的地址：</li>
<li>如果定义了索引节点对象的<code>put_link</code>方法，就执行它，释放由<code>follow_link</code>方法分配的临时数据结构。</li>
<li>减少<code>current-&gt;link_count</code>和<code>nd-&gt;depth</code>字段的值。</li>
<li>返回由<code>__vfs_follow_link()</code>函数返回的错误码（0表示无错误）：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> __do_follow_link(<span class="keyword">struct</span> path *path, <span class="keyword">struct</span> nameidata *nd)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> error;</span><br><span class="line">     <span class="type">void</span> *cookie;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> path-&gt;dentry;</span><br><span class="line"></span><br><span class="line">     touch_atime(path-&gt;mnt, dentry);</span><br><span class="line">     nd_set_link(nd, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (path-&gt;mnt != nd-&gt;mnt) &#123;</span><br><span class="line">          path_to_nameidata(path, nd);</span><br><span class="line">          dget(dentry);</span><br><span class="line">     &#125;</span><br><span class="line">     mntget(path-&gt;mnt);</span><br><span class="line">     cookie = dentry-&gt;d_inode-&gt;i_op-&gt;follow_link(dentry, nd);</span><br><span class="line">     error = PTR_ERR(cookie);</span><br><span class="line">     <span class="keyword">if</span> (!IS_ERR(cookie)) &#123;</span><br><span class="line">          <span class="type">char</span> *s = nd_get_link(nd);</span><br><span class="line">          error = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (s)</span><br><span class="line">               error = __vfs_follow_link(nd, s);</span><br><span class="line">          <span class="keyword">if</span> (dentry-&gt;d_inode-&gt;i_op-&gt;put_link)</span><br><span class="line">               dentry-&gt;d_inode-&gt;i_op-&gt;put_link(dentry, nd, cookie);</span><br><span class="line">     &#125;</span><br><span class="line">     dput(dentry);</span><br><span class="line">     mntput(path-&gt;mnt);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">int</span> __vfs_follow_link(<span class="keyword">struct</span> nameidata *nd, <span class="type">const</span> <span class="type">char</span> *link)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="type">char</span> *name;</span><br><span class="line">     <span class="keyword">if</span> (IS_ERR(link))</span><br><span class="line">          <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (*link == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">          path_release(nd);</span><br><span class="line">          <span class="keyword">if</span> (!walk_init_root(link, nd))</span><br><span class="line">               <span class="comment">/* weird __emul_prefix() stuff did it */</span></span><br><span class="line">               <span class="keyword">goto</span> out;</span><br><span class="line">     &#125;</span><br><span class="line">     res = link_path_walk(link, nd);</span><br><span class="line">out:</span><br><span class="line">     <span class="keyword">if</span> (nd-&gt;depth || res || nd-&gt;last_type!=LAST_NORM)</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * If it is an iterative symlinks resolution in open_namei() we</span></span><br><span class="line"><span class="comment">      * have to copy the last component. And all that crap because of</span></span><br><span class="line"><span class="comment">      * bloody create() on broken symlinks. Furrfu...</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     name = __getname();</span><br><span class="line">     <span class="keyword">if</span> (unlikely(!name)) &#123;</span><br><span class="line">          path_release(nd);</span><br><span class="line">          <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">strcpy</span>(name, nd-&gt;last.name);</span><br><span class="line">     nd-&gt;last.name = name;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">     path_release(nd);</span><br><span class="line">     <span class="keyword">return</span> PTR_ERR(link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>__vfs_follow_link()</code>函数本质上依次执行下列操作：</p>
<ol>
<li>检查符号链接路径名的第一个字符是否是“/”：在这种情况下，已经找到一个绝对路径名，因此没有必要在内存中保留前一个路径的任何信息。如果是，对<code>nameidata</code>数据结构调用<code>path_release()</code>，因此释放由前一个查找步骤产生的对象；然后，设置<code>nameidata</code>数据结构的<code>dentry</code>和<code>mnt</code>字段，以使它们指向当前进程的根目录。</li>
<li>调用<code>link_path_walk()</code>解析符号链的路径名，传递给它的参数为路径名和nd。</li>
<li>返回从<code>link_path_walk()</code>取回的值。</li>
</ol>
<p>当<code>do_follow_link()</code>最后终止时，它把局部变量<code>next</code>的<code>dentry</code>字段设置为目录项对象的地址，而这个地址由符号链接传递给原先就执行的<code>link_path_walk()</code>。<code>link_path_walk()</code>函数然后进行下一步。</p>
<h2 id="VFS系统调用的实现"><a href="#VFS系统调用的实现" class="headerlink" title="VFS系统调用的实现"></a>VFS系统调用的实现</h2><h3 id="open-系统调用"><a href="#open-系统调用" class="headerlink" title="open()系统调用"></a>open()系统调用</h3><p><code>open()</code>系统调用的服务例程为<code>sys_open()</code>函数，该函数接收的参数为：</p>
<ul>
<li>要打开文件的路径名<code>filename</code></li>
<li>访问模式的一些标志<code>flags</code></li>
<li>该文件被创建所需要的许可权位掩码<code>mode</code></li>
</ul>
<p>如果该系统调用成功，就返回一个文件描述符，也就是指向文件对象的指针数组<code>current-&gt;files-&gt;fd</code>中分配给新文件的索引；否则，返回-1。</p>
<p>下面列出了open()系统调用的所有标志：</p>
<ul>
<li><code>O_RDONLY</code>：为读而打开</li>
<li><code>O_WRONLY</code>：为写而打开</li>
<li><code>O_RDWR</code>：为读和写而打开</li>
<li><code>O_CREAT</code>：如果文件不存在，就创建它</li>
<li><code>O_EXCL</code>：对于O_CREAT标志，如果文件已经存在，则失败</li>
<li><code>O_NOCTTY</code>：从不把文件看作控制终端</li>
<li><code>O_TRUNC</code>：截断文件（删除所有现有的内容）</li>
<li><code>O_APPEND</code>：总是在文件末尾写</li>
<li><code>O_NONBLOCK</code>：没有系统调用在文件上阻塞</li>
<li><code>O_NDELAY</code>：与O_NONBLOCK相同</li>
<li><code>O_SYNC</code>：同步写（阻塞，直到物理写终止）</li>
<li><code>FASYNC</code>：通过信号发出I/O事件通告</li>
<li><code>O_DIRECT</code>：直接I/O传送（不使用缓存）</li>
<li><code>O_LARGEFILE</code>：大型文件（长度大于2GB）</li>
<li><code>O_DIRECTORY</code>：如果文件不是一个目录，则失败</li>
<li><code>O_NOFOLLOW</code>：不解释路径名中尾部的符号链接</li>
<li><code>O_NOATIME</code>：不更新索引节点的上次访问时间</li>
</ul>
<p>下面来描述一下<code>sys_open()</code>函数的操作。它执行如下操作：</p>
<ol>
<li>调用<code>getname()</code>从进程地址空间读取该文件的路径名，想查看细节请看博文“文件系统安装预备知识”。</li>
<li>调用<code>get_unused_fd()</code>在<code>current-&gt;files-&gt;fd</code>中查找一个空的位置。相应的索引（新文件描述符）存放在fd局部变量中。</li>
<li>调用<code>do_filp_open()</code>函数，传递给它的参数为路径名、访问模式标志以及许可权位掩码。<ol>
<li>把访问模式标志拷贝到<code>namei_flags</code>标志中，但是，用特殊的格式对访问模式标志。<code>O_RDONLY</code>、<code>O_WRONLY</code>和<code>O_RDWR</code>进行编码：如果文件访问需要读特权，那么只设置<code>namei_flags</code>标志的下标为0的位（最低位）；类似地，如果文件访问需要写特权，就只设置下标为1的位。注意，不可能在<code>open()</code>系统调用中不指定文件访问的读或写特权；不过，这种情况在涉及符号链接的路径名查找中则是有意义的。</li>
<li>调用<code>open_namei()</code>，传递给它的参数为<code>dfd</code>（<code>AT_FDCWD</code>）、路径名、修改的访问模式标志以及局部<code>nameidata</code>数据结构的地址。<code>open_namei</code>，这个函数执行以下流程：<ol>
<li>如果访问模式标志中没有设置<code>O_CREAT</code>，则不设置<code>LOOKUP_PARENT</code>标志而设置<code>LOOKUP_OPEN</code>标志后开始查找操作。此外，只有<code>O_NOFOLLOW</code>被清零，才设置<code>LOOKUP_FOLLOW</code>标志，而只有设置了<code>O_DIRECTORY</code>标志，才设置<code>LOOKUP_DIRECTORY</code>标志。</li>
<li>如果在访问模式标志中设置了<code>O_CREAT</code>，则以<code>LOOKUP_PARENT</code>、<code>LOOKUP_OPEN</code>和<code>LOOKUP_CREATE</code>标志的设置开始查找操作。一旦<code>path_lookup()</code>函数成功返回，则检查请求的文件是否已存在。如果不存在，则调用父索引节点的<code>create</code>方法分配一个新的磁盘索引节点。</li>
<li><code>open_namei()</code>函数也在查找操作确定的文件上执行几个安全检查。例如，该函数检查与已找到的目录项对象关联的索引节点是否存在、它是否是一个普通文件，以及是否允许当前进程根据访问模式标志访问它。如果文件也是为写打开的，则该函数检查文件是否被其他进程加锁。</li>
</ol>
</li>
<li>调用<code>dentry_open()</code>函数，传递给它的参数为访问模式标志、目录项对象的地址以及由查找操作确定的已安装文件系统对象：<ol>
<li>根据传递给<code>open()</code>系统调用的访问模式标志初始化文件对象的<code>f_flags</code>和<code>f_mode</code>字段。</li>
<li>根据作为参数传递来的目录项对象的地址和已安装文件系统对象的地址初始化文件对象的<code>f_fentry</code>和<code>f_vfsmnt</code>字段。</li>
<li>重点步骤：把f_op字段设置为相应索引节点对象<code>i_fop</code>字段的内容。这就为进一步的文件操作建立起所有的方法。</li>
<li>把文件对象插入到文件系统超级块的<code>s_files</code>字段所指向的打开文件的链表。</li>
<li>如果文件操作的<code>open</code>方法被定义，则调用它。</li>
<li>调用<code>file_ra_state_init()</code>初始化预读的数据结构（参见第十六章）。</li>
<li>如果<code>O_DIRECT</code>标志被设置，则检查直接I/O操作是否可以作用于文件（参见第十六章）。</li>
<li>返回文件对象的地址。</li>
</ol>
</li>
<li>返回文件对象的地址</li>
</ol>
</li>
<li>回到<code>do_sys_open</code>，把<code>current-&gt;files-&gt;fd[fd]</code>置为由<code>dentry_open()</code>返回的文件对象的地址：</li>
<li>返回<code>fd</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_unused_fd</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> * <span class="title">files</span> =</span> current-&gt;files;</span><br><span class="line">     <span class="type">int</span> fd, error;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line"></span><br><span class="line">       error = -EMFILE;</span><br><span class="line">     spin_lock(&amp;files-&gt;file_lock);</span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">     fdt = files_fdtable(files);</span><br><span class="line">      fd = find_next_zero_bit(fdt-&gt;open_fds-&gt;fds_bits,</span><br><span class="line">                    fdt-&gt;max_fdset,</span><br><span class="line">                    files-&gt;next_fd);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (fd &gt;= current-&gt;signal-&gt;rlim[RLIMIT_NOFILE].rlim_cur)</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Do we need to expand the fd array or fd set?  */</span></span><br><span class="line">     error = expand_files(files, fd);</span><br><span class="line">     <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * If we needed to expand the fs array we</span></span><br><span class="line"><span class="comment">           * might have blocked - try again.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          error = -EMFILE;</span><br><span class="line">          <span class="keyword">goto</span> repeat;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     FD_SET(fd, fdt-&gt;open_fds);</span><br><span class="line">     FD_CLR(fd, fdt-&gt;close_on_exec);</span><br><span class="line">     files-&gt;next_fd = fd + <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">     <span class="comment">/* Sanity check */</span></span><br><span class="line">     <span class="keyword">if</span> (fdt-&gt;fd[fd] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          printk(KERN_WARNING <span class="string">&quot;get_unused_fd: slot %d not NULL!/n&quot;</span>, fd);</span><br><span class="line">          fdt-&gt;fd[fd] = <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     error = fd;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">     spin_unlock(&amp;files-&gt;file_lock);</span><br><span class="line">     <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> file *<span class="title function_">do_filp_open</span><span class="params">(<span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> namei_flags, error;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> <span class="title">nd</span>;</span></span><br><span class="line"></span><br><span class="line">     namei_flags = flags;</span><br><span class="line">     <span class="keyword">if</span> ((namei_flags+<span class="number">1</span>) &amp; O_ACCMODE)</span><br><span class="line">          namei_flags++;</span><br><span class="line">     error = open_namei(dfd, filename, namei_flags, mode, &amp;nd);</span><br><span class="line">     <span class="keyword">if</span> (!error)</span><br><span class="line">          <span class="keyword">return</span> nameidata_to_filp(&amp;nd, flags);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *__<span class="title">dentry_open</span>(<span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>, <span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">int</span> <span class="title">flags</span>, <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>,</span></span><br><span class="line"><span class="class">                         <span class="title">int</span> (*<span class="title">open</span>)(<span class="keyword">struct</span> <span class="title">inode</span> *, <span class="keyword">struct</span> <span class="title">file</span> *))</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">     <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">     f-&gt;f_flags = flags;</span><br><span class="line">     f-&gt;f_mode = ((flags+<span class="number">1</span>) &amp; O_ACCMODE) | FMODE_LSEEK |</span><br><span class="line">                    FMODE_PREAD | FMODE_PWRITE;</span><br><span class="line">     inode = dentry-&gt;d_inode;</span><br><span class="line">     <span class="keyword">if</span> (f-&gt;f_mode &amp; FMODE_WRITE) &#123;</span><br><span class="line">          error = get_write_access(inode);</span><br><span class="line">          <span class="keyword">if</span> (error)</span><br><span class="line">               <span class="keyword">goto</span> cleanup_file;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     f-&gt;f_mapping = inode-&gt;i_mapping;</span><br><span class="line">     f-&gt;f_dentry = dentry;</span><br><span class="line">     f-&gt;f_vfsmnt = mnt;</span><br><span class="line">     f-&gt;f_pos = <span class="number">0</span>;</span><br><span class="line">     f-&gt;f_op = fops_get(inode-&gt;i_fop);</span><br><span class="line">     file_move(f, &amp;inode-&gt;i_sb-&gt;s_files);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!open &amp;&amp; f-&gt;f_op)</span><br><span class="line">          open = f-&gt;f_op-&gt;open;</span><br><span class="line">     <span class="keyword">if</span> (open) &#123;</span><br><span class="line">          error = open(inode, f);</span><br><span class="line">          <span class="keyword">if</span> (error)</span><br><span class="line">               <span class="keyword">goto</span> cleanup_all;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     f-&gt;f_flags &amp;= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);</span><br><span class="line"></span><br><span class="line">     file_ra_state_init(&amp;f-&gt;f_ra, f-&gt;f_mapping-&gt;host-&gt;i_mapping);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* NB: we&#x27;re sure to have correct a_ops only after f_op-&gt;open */</span></span><br><span class="line">     <span class="keyword">if</span> (f-&gt;f_flags &amp; O_DIRECT) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!f-&gt;f_mapping-&gt;a_ops ||</span><br><span class="line">              ((!f-&gt;f_mapping-&gt;a_ops-&gt;direct_IO) &amp;&amp;</span><br><span class="line">              (!f-&gt;f_mapping-&gt;a_ops-&gt;get_xip_page))) &#123;</span><br><span class="line">               fput(f);</span><br><span class="line">               f = ERR_PTR(-EINVAL);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> f;</span><br><span class="line"></span><br><span class="line">cleanup_all:</span><br><span class="line">     fops_put(f-&gt;f_op);</span><br><span class="line">     <span class="keyword">if</span> (f-&gt;f_mode &amp; FMODE_WRITE)</span><br><span class="line">          put_write_access(inode);</span><br><span class="line">     file_kill(f);</span><br><span class="line">     f-&gt;f_dentry = <span class="literal">NULL</span>;</span><br><span class="line">     f-&gt;f_vfsmnt = <span class="literal">NULL</span>;</span><br><span class="line">cleanup_file:</span><br><span class="line">     put_filp(f);</span><br><span class="line">     dput(dentry);</span><br><span class="line">     mntput(mnt);</span><br><span class="line">     <span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> fastcall <span class="title function_">fd_install</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="keyword">struct</span> file * file)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> =</span> current-&gt;files;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">     spin_lock(&amp;files-&gt;file_lock);</span><br><span class="line">     fdt = files_fdtable(files);</span><br><span class="line">     BUG_ON(fdt-&gt;fd[fd] != <span class="literal">NULL</span>);</span><br><span class="line">     rcu_assign_pointer(fdt-&gt;fd[fd], file);</span><br><span class="line">     spin_unlock(&amp;files-&gt;file_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="read-和write-系统调用"><a href="#read-和write-系统调用" class="headerlink" title="read()和write()系统调用"></a>read()和write()系统调用</h3><p><code>read()</code>和<code>write()</code>系统调用非常相似。它们都需要三个参数：</p>
<ul>
<li>一个文件描述符<code>fd</code></li>
<li>一个内存区的地址<code>buf</code>（该缓冲区包含要传送的数据）</li>
<li>一个数<code>count</code>指定应该传送多少字节</li>
</ul>
<p><code>read()</code>把数据从文件传送到缓冲区，而<code>write()</code>执行相反的操作。两个系统调用都返回所成功传送的字节数，或者发送一个错误条件的信号并返回-1。返回值小于<code>count</code>并不意味着发生了错误。即使请求的字节没有都被传送，也总是允许内核终止系统调用，因此用户应用程序必须检查返回值并重新发出系统调用（如果必要）。</p>
<p>一般会有这几种典型情况下返回小于count的值：当从管道或终端设备读取时，当读到文件的末尾时，或者当系统调用被信号中断时。文件结束条件（EOF）很容易从<code>read()</code>的空返回值中判断出来。这个条件不会与因信号引起的异常终止混淆在一起，因为如果读取数据之前<code>read()</code>被一个信号中断，则发生一个错误。</p>
<p>读或写操作总是发生在由当前文件指针所指定的文件偏移处（文件对象的f_pos字段）。两个系统调用都通过把所传送的字节数加到文件指针上而更新文件指针。</p>
<p>简而言之，<code>sys_read()</code>（<code>read()</code>的服务例程）和<code>sys_write()</code>（<code>write()</code>）的服务例程）几乎都执行相同的步骤：</p>
<ol>
<li>调用<code>fget_light()</code>从<code>fd</code>获取当前进程相应文件对象的地址<code>file</code>：</li>
<li>如果<code>file-&gt;f_mode</code>中的标志不允许所请求的访问（读或写操作），则返回一个错误码-EBADF。</li>
<li>如果文件对象没有<code>read()</code>或<code>aio_read()</code>（<code>write()</code>或<code>aio_write()</code>）文件操作，则返回一个错误码-EINVAL。</li>
<li>调用<code>access_ok()</code>粗略地检查buf和count参数（参见博文“文件系统安装预备知识”）。</li>
<li>调用<code>rw_verify_area()</code>对要访问的文件部分检查是否有冲突的强制锁。如果有，则返回一个错误码，如果该锁已经被<code>F_SETLKW</code>命令请求，那么就挂起当前进程。</li>
<li>调用<code>file-&gt;f_op-&gt;read</code>或<code>file-&gt;f_op-&gt;write</code>方法（如果已定义）来传送数据；否则，调用<code>file-&gt;f_op-&gt;aio_read</code>或<code>file-&gt;f_op-&gt;aio_write</code>方法。所有这些方法都返回实际传送的字节数。另一方面的作用是，文件指针被适当地更新。</li>
<li>调用<code>fput_light()</code>释放文件对象。</li>
<li>返回实际传送的字节数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> file fastcall *<span class="title function_">fget_light</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">int</span> *fput_needed)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span> =</span> current-&gt;files;</span><br><span class="line">  ……</span><br><span class="line">     file = fcheck_files(files, fd);</span><br><span class="line">  ……</span><br><span class="line">     <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> file * <span class="title function_">fcheck_files</span><span class="params">(<span class="keyword">struct</span> files_struct *files, <span class="type">unsigned</span> <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">file</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span> =</span> files_fdtable(files);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (fd &lt; fdt-&gt;max_fds)</span><br><span class="line">          file = rcu_dereference(fdt-&gt;fd[fd]);</span><br><span class="line">     <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="close-系统调用"><a href="#close-系统调用" class="headerlink" title="close()系统调用"></a>close()系统调用</h3><p><code>close()</code>系统调用接收的参数为要关闭文件的文件描述符<code>fd</code>。<code>sys_close()</code>服务例程执行下列操作：</p>
<ol>
<li>获得存放在<code>current-&gt;files-&gt;fd[fd]</code>中的文件对象<code>file</code>的地址；如果它为NULL，则返回一个出错码。</li>
<li>把<code>current-&gt;files-&gt;fd[fd]</code>置为NULL。释放文件描述符<code>fd</code>，这是通过清除<code>current-&gt;files</code>中的<code>open_fds</code>和<code>close_on_exec</code>字段的相应位来进行的。</li>
<li>调用<code>file_close()</code>，该函数执行下列操作：<ol>
<li>调用文件操作的<code>flush</code>方法（如果已定义）。</li>
<li>释放文件上的任何强制锁。</li>
<li>调用<code>fput()</code>释放文件对象。</li>
</ol>
</li>
<li>返回0或一个出错码。出错码可由<code>flush</code>方法或文件中的前一个写操作错误产生</li>
</ol>
<h2 id="文件加锁"><a href="#文件加锁" class="headerlink" title="文件加锁"></a>文件加锁</h2><p>Unix提供了一种允许进程对一个文件区进行加锁的机制，以使同时访问可以很容易的被避免。POSIX标准规定了基于<code>fcntl()</code>系统调用的文件加锁机制。这可以对文件的任意一部分加锁或对整个文件加锁。这种锁并不把不知道加锁的其他进程关到外边，只有在访问文件之前其他进程合作检查锁的存在时，锁才起作用。因此POSIX的锁称为<strong>劝告锁</strong>。传统的BSD变体通过<code>flock()</code>系统调用实现劝告锁，这个调用不允许进程对文件的一个区字段进行加锁，而只能对整个文件加锁。</p>
<p>不管是劝告锁还是强制锁，它们都可以使用共享读锁和独占写锁。在文件的某个区字段上，可以有任意多个进程进行读，但在同一个时刻只能有一个进程进行写。当其他进程对同一个文件都有自己的读锁时，就不可能获得一个写锁。</p>
<h3 id="Linux文件加锁"><a href="#Linux文件加锁" class="headerlink" title="Linux文件加锁"></a>Linux文件加锁</h3><p>Linux支持所有的文件加锁方式：<strong>劝告锁</strong>和<strong>强制锁</strong>，以及<code>fcntl()</code>、<code>flock()</code>和<code>lockf()</code>系统调用。不过，<code>lockf()</code>系统调用仅仅是一个标准的库函数。<code>flock()</code>系统调用不管<code>MS_MANDLOCK</code>安装标志如何设置，只产生劝告锁。这是任何类Unix操作系统所期望的系统调用行为。在Linux中，增加了一种特殊的<code>flock()</code><strong>强制锁</strong>，以允许对专有的网络文件系统的实现提供适当的支持。这就是所谓的<strong>共享模式强制锁</strong>；<strong>当这个锁被设置时，其他任何进程都不能打开与锁访问模式冲突的文件</strong>。</p>
<p>在Linux中还引人了另一种基于<code>fcntl()</code>的强制锁，叫做<strong>租借锁</strong>。当一个进程试图打开由租借锁保护的文件时，它照样被阻塞。然而，拥有锁的进程接收到一个信号。一旦该进程得到通知，它应当首先更新文件，以使文件的内容保持一致，然后释放锁。如果拥有者不在预定的时间间隔内这么做，则租借锁由内核自动删除，且允许阻塞的进程继续执行。</p>
<p>进程可以采用以下两种方式获得或释放一个文件劝告锁：</p>
<ul>
<li>发出<code>flock()</code>系统调用。传递给它的两个参数为文件描述符<code>fd</code>和指定锁操作的命令。该锁应用于整个文件。</li>
<li>使用<code>fcntl()</code>系统调用。传递给它的三个参数为文件描述符<code>fd</code>、指定锁操作的命令以及指向<code>flock</code>结构的指针。<code>flock</code>结构中的几个字段允许进程指定要加锁的文件部分。因此进程可以在同一文件的不同部分保持几个锁。</li>
</ul>
<p><code>fcntl()</code>和<code>flock()</code>系统调用可以在同一文件上同时使用，但是通过<code>fcntl()</code>加锁的文件看起来与通过<code>flock()</code>加锁的文件不一样，反之亦然。这样当应用程序使用一种依赖于某个库的锁，而该库同时使用另一种类型的锁时，可以避免发生死锁。</p>
<p>处理强制文件锁会更复杂:</p>
<ol>
<li>安装文件系统时强制锁是必需的，可使用<code>mount</code>命令的<code>-o mand</code>选项在<code>mount()</code>系统调用中设置<code>MS_MANDLOCK</code>标志，缺省操作是不使用强制锁。</li>
<li>通过设置文件的<code>set-group</code>位和清除<code>group-execute</code>许可权位将他们标记为强制锁的候选者。</li>
<li>使用<code>fcntl()</code>系统调用获得或释放一个文件锁</li>
</ol>
<p>处理租借锁：调用具有<code>F_SETLEASE</code>或<code>F_GETLEASE</code>命令的系统调用<code>fcntl()</code>就足够了。使用另一个带有<code>F_SETSIG</code>命令的<code>fcntl()</code>可以改变传送给租借锁进程拥有者的信号类型。</p>
<h3 id="文件锁的数据结构"><a href="#文件锁的数据结构" class="headerlink" title="文件锁的数据结构"></a>文件锁的数据结构</h3><p>在 Linux 内核中，所有类型的文件锁都是由数据结构<code>file_lock</code>来描述的：<br><img src="/img/1603460627.jpg" alt=""></p>
<p>指向磁盘上相同文件的所有<code>lock_file</code>结构会被链接成一个单链表，索引节点结构中的<code>i_flock</code>字段会指向该单链表结构的首元素，<code>fl_next</code>用于指向该链表中的下一个元素；因为锁被挂起的进程会被插入到由阻塞锁<code>file_lock</code>结构的<code>fl_wait</code>指向的等待队列中。所有的活动锁被链接在<strong>全局文件锁链表</strong>中，该表的首元素存放在<code>file_lock_list</code>中。所有的阻塞锁被链接在<strong>阻塞链表</strong>中，该表的首元素存放在<code>block_list</code>中。<code>fl_link</code>字段指向这两个列表其中一个。</p>
<p><strong>内核必须跟踪所有与给定活动锁关联的阻塞锁</strong>。</p>
<h3 id="FL-FLOCK锁"><a href="#FL-FLOCK锁" class="headerlink" title="FL_FLOCK锁"></a>FL_FLOCK锁</h3><p>FL_FLOCK锁总是与一个文件相关联，因此由一个打开该文件的今晨来维护。当一个锁被请求或允许时，内核就把进程保持在同一个文件对象上的任何其他锁都替换掉。这只发生在进程想把一个已经拥有的读锁改变为一个写锁，或把一个写锁改变为读锁。</p>
<p><code>flock()</code>系统调用允许进程在打开文件上申请或删除劝告锁。它作用于两个参数：要加锁文件的文件描述符<code>fd</code>和指定锁操作的参数<code>cmd</code>。如果<code>cmd</code>参数为<code>LOCK_SH</code>，则请求一个共享的锁，为<code>LOCK_EX</code>则请求一个互斥的锁，为<code>LOCK_UN</code>则释放一个锁。</p>
<p>当<code>sys_flock()</code>例程被调用时，执行下列步骤：</p>
<ol>
<li>检查<code>fd</code>是否是一个有效的文件描述符，如果不是，就返回一个错误码。否则获得相应文件对象<code>flip</code>的地址。</li>
<li>检查进程在打开文件上是否有读和/或写权限；如果没有，就返回一个错误码。</li>
<li>获得一个新的<code>file_lock</code>对象锁并用适当的锁操作初始化它：根据参数<code>cmd</code>的值设置<code>fl_type</code>字段，把<code>fl_file</code>字段设为文件对象<code>filp</code>的地址，<code>fl_flags</code>字段设为<code>FL_FLOCK</code>，<code>fl_pid</code>字段设为<code>current-&gt;tgid</code>，并把<code>fl_end</code>字段设为-1，这表示对整个文件（而不是文件的一部分）加锁的事实。</li>
<li>如果参数<code>cmd</code>不包含<code>LOCK_NB</code>位，则把<code>FL_SLEEP</code>标志加入<code>fl_flags</code></li>
<li>如果文件具有一个<code>flock</code>文件操作，则调用它，传递给它的参数为文件对象指针<code>filp</code>、一个标志（<code>F_SETLKW</code>或<code>F_SETLK</code>，取决于<code>LOCK_NB</code>位的值）以及新的<code>file_lock</code>对象锁的地址。</li>
<li>否则，如果没有定义<code>flock</code>文件操作（通常情况下），则调用<code>flock_lock_file_wait()</code>试图执行请求的锁操作。传递给它的两个参数为：文件对象指针<code>filp</code>和在第3步创建的新的<code>file_lock</code>对象的地址<code>lock</code>。</li>
<li>如果上一步中还没有把<code>file_lock</code>描述符插入活动或阻塞链表中，则释放它。</li>
<li>返回成功</li>
</ol>
<p><code>flock_lock_file_wait()</code>函数执行下列循环操作：</p>
<ol>
<li>调用<code>flock_lock_file()</code>，传递给它的参数为文件对象指针<code>filp</code>和新的<code>file_lock</code>对象锁的地址<code>lock</code>。这个函数依次执行下列操作：<ol>
<li>搜索<code>filp-&gt;f_dentry-&gt;d_inode-&gt;i_flock</code>指向的链表。如果在同一文件对象中找到<code>FL_FLOCK</code>锁，则检查它的类型(<code>LOCK_SH</code>或<code>LOCK_EX</code>)：如果该锁的类型与新锁相同，则返回0（什么也没有做）。否则，从索引节点锁链表和全局文件锁链表中删除这个<code>file_lock</code>元素，唤醒<code>fl_block</code>链表中在该锁的等待队列的所有进程，并释放<code>file_lock</code>结构</li>
<li>如果进程正在执行开锁(LOCK_UN），则什么事情都不需要做：该锁已不存在或已被释放，因此返回0。</li>
<li>如果已经找到同一个文件对象的<code>FL_FLOCK</code>锁——表明进程想把一个已经拥有的读锁改变为一个写锁（反之亦然），那么调用<code>cond_resched()</code>给予其他更高优先级进程（特别是先前在原文件锁上阻塞的任何进程）一个运行的机会。</li>
<li>再次搜索索引节点锁链表以验证现有的<code>FL_FLOCK</code>锁并不与所请求的锁冲突。在索引节点链表中，肯定没有<code>FL_FLOCK</code>写锁，此外，如果进程正在请求一个写锁，那么根本就没有<code>FL_FLOCK</code>锁。</li>
<li>如果不存在冲突锁，则把新的<code>file_lock</code>结构插入索引节点锁链表和全局文件锁链表中，然后返回0（成功）。</li>
<li>发现一个冲突锁：如果<code>fl_flags</code>字段中<code>FL_SLEEP</code>对应的标志位置位，则把新锁(<code>waiter</code>锁）插入到<code>blocker</code>锁循环链表和全局阻塞链表中。</li>
<li>返回一个错误码-EAGAINO</li>
</ol>
</li>
<li>检查<code>flock_lock_file()</code>的返回码：<ol>
<li>如果返回码为0（没有冲突迹象），则返回0（成功）。</li>
<li>不相容的情况。如果<code>fl_flags</code>字段中的<code>FL_SLEEP</code>标志被清除，就释放<code>file_lock</code>锁描述符，并返回一个错误码-EAGAIN。</li>
<li>否则，不相容但进程能够睡眠的情况：调用<code>wait_event_interruptible()</code>把当前进程插入到<code>lock-&gt;fl_wait</code>等待队列中并挂起它。当进程被唤醒时（正好在释放<code>blocker</code>锁后），跳转到第1步再次执行这个操作。</li>
</ol>
</li>
</ol>
<h3 id="FL-POSIX锁"><a href="#FL-POSIX锁" class="headerlink" title="FL_POSIX锁"></a>FL_POSIX锁</h3><p><code>FL_POSIX</code>锁总是<strong>与一个进程和一个索引节点相关联</strong>。当进程死亡或一个文件描述符被关闭时（即使该进程对同一文件打开了两次或复制了一个文件描述符），这种锁会被自动地释放。此外，<code>FL_POSIX</code>锁绝不会被子进程通过<code>fork()</code>继承。</p>
<p>当使用<code>fcntl()</code>系统调用对文件加锁时，该系统调用作用于三个参数：</p>
<ul>
<li>要加锁文件的文件描述符<code>fd</code></li>
<li>指向锁操作的参数<code>cmd</code></li>
<li>指向存放在用户态进程地址空间中的<code>flock</code></li>
</ul>
<p><img src="/img/1603464240.jpg" alt=""></p>
<p><code>sys_fcntl()</code>执行的操作取决于在<code>cmd</code>参数中所设置的标志值。</p>
<ul>
<li><code>F_GETLK</code>：确定由<code>flock</code>结构描述的锁是否与另一个进程已获得的某个<code>FL_POSIX</code>锁互相冲突。冲突时用现有锁的有关信息重写<code>flock</code>结构</li>
<li><code>F_SETLK</code>：设置由<code>flock</code>结构描述的锁，如果不能获得该锁，就返回错误码</li>
<li><code>F_SETLKW</code>：设置由<code>flock</code>结构描述的锁，如果不能获得该锁，则阻塞系统调用，直至该锁可以获取</li>
<li><code>F_GETLK64</code>，<code>F_SETLK64</code>，<code>F_SETLKW64</code>：使用的时<code>flock64</code>而不是<code>flock</code></li>
</ul>
<p><code>sys_fcntl()</code>服务例程首先获取与参数<code>fd</code>对应的文件对象，然后调用<code>fcntl_getlk()</code>或<code>fcntl_setlk()</code>函数（这取决于传递的参数：<code>F_GETLK</code>表示前一个函数，<code>F_SETLK</code>或<code>F_SETLKW</code>表示后一个函数）。我们仅仅考虑第二种情况。</p>
<p><code>fcntl_setlk()</code>函数作用于三个参数：</p>
<ul>
<li>指向文件对象的指针<code>filp</code></li>
<li><code>cmd</code>命令(<code>F_SETLK</code>或<code>F_SETLKW</code>)</li>
<li>指向<code>flock</code>数据结构的指针</li>
</ul>
<p>该函数执行下列操作：</p>
<ol>
<li>读取局部变量中的参数<code>fl</code>所指向的<code>flock</code>结构。</li>
<li>检查这个锁是否应该是一个强制锁，且文件是否有一个共享内存映射。在肯定的情况下，该函数拒绝创建锁并返回-EAGAIN出错码，说明文件正在被另一个进程访问。</li>
<li>根据用户<code>flock</code>结构的内容和存放在文件索引节点中的文件大小，初始化一个新的<code>file_lock</code>结构。</li>
<li>如果命令<code>cmd</code>为<code>F_SETLKW</code>，则该函数把<code>file_lock</code>结构的<code>fl_flags</code>字段设为<code>FL_SLEEP</code>标志对应的位置位。</li>
<li>如果<code>flock</code>结构中的<code>l_type</code>字段为<code>F_RDLCK</code>，则检查是否允许进程从文件读取；类似地，如果<code>l_type</code>为<code>F_WRLCK</code>，则检查是否允许进程写入文件。如果都不是，则返回一个出错码。</li>
<li>调用文件操作的<code>lock</code>方法（如果已定义）。对于磁盘文件系统，通常不定义该方法。</li>
<li>调用<code>__posix_lock_file()</code>函数，传递给它的参数为文件的索引节点对象地址以及<code>file_lock</code>对象地址。该函数依次执行下列操作：<ol>
<li>对于索引节点的锁链表中的每个<code>FL_POSIX</code>锁，调用<code>posix_locks_conflict()</code>。该函数<strong>检查这个锁是否与所请求的锁互相冲突</strong>。从本质上说，在索引节点的链表中，必定没有用于同一区的<code>FL_POSIX</code>写锁，并且，如果进程正在请求一个写锁，那么同一个区字段也可能根本没有<code>FL_POSIX</code>锁。但是，同一个进程所拥有的锁从不会冲突；这就允许进程改变它已经拥有的锁的特性。</li>
<li>如果找到一个冲突锁，则检查是否以<code>F_SETLKW</code>标志调用<code>fcntl()</code>。如果是，当前进程应当被挂起：在这种情况下，调用<code>posix_locks_deadlock()</code>来检查在等待<code>FL_POSIX</code>锁的进程之间没有产生死锁条件，然后把新锁（waiter锁）插入到冲突锁（blocker锁）<code>blocker</code>链表和阻塞链表中，最后返回一个出错码。否则，如果以<code>F_SETLK</code>标志调用<code>fcntl()</code>，则返回出错码。</li>
<li>只要索引节点的锁链表中不包含冲突的锁，就<strong>检查把文件区重叠起来的当前进程的所有<code>FL_POSIX</code>锁，当前进程按需要对文件区中相邻的区字段进行锁定、组合及拆分</strong>。</li>
<li>把新的<code>file_lock</code>结构插入到全局锁链表和索引节点链表中。</li>
<li>返回值0（成功）。</li>
</ol>
</li>
<li>检查<code>__posix_lock_file()</code>的返回码：<ol>
<li>如果返回码为0（没有冲突迹象），则返回0（成功）。</li>
<li>不相容的情况。如果<code>fl_flags</code>字段的<code>FL_SLEEP</code>标志被清除，就释放新的<code>file_lock</code>描述符，并返回一个错误码-EAGAIN。</li>
<li>否则如果不相容但进程能够睡眠时，调用<code>wait_event_interruptible()</code>把当前进程插入到<code>lock-&gt;fl_wait</code>等待队列中并挂起它。当进程被唤醒时（正好在释放blocker锁后），跳转到第7步再次执行这个操作。</li>
</ol>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"># Linux</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%20%E7%AC%94%E8%AE%B03/" rel="prev" title="深入理解Linux内核8-9章">
      <i class="fa fa-chevron-left"></i> 深入理解Linux内核8-9章
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%20%E7%AC%94%E8%AE%B05/" rel="next" title="深入理解Linux内核13-15章">
      深入理解Linux内核13-15章 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#POSIX-API%E5%92%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">POSIX API和系统调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%8F%8A%E6%9C%8D%E5%8A%A1%E4%BE%8B%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">系统调用处理程序及服务例程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E5%92%8C%E9%80%80%E5%87%BA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.3.</span> <span class="nav-text">进入和退出系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87int-0x80%E6%8C%87%E4%BB%A4%E5%8F%91%E5%87%BA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">通过int $0x80指令发出系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#system-call%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.2.</span> <span class="nav-text">system_call函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%80%80%E5%87%BA"><span class="nav-number">1.3.3.</span> <span class="nav-text">从系统调用退出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87sysenter%E6%8C%87%E4%BB%A4%E5%8F%91%E5%87%BA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.3.4.</span> <span class="nav-text">通过sysenter指令发出系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sysenter%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">sysenter指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vsyscall%E9%A1%B5"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">vsyscall页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">进入系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%80%E5%87%BA%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">退出系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sysexit%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.4.5.</span> <span class="nav-text">sysexit指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SYSENTER-RETURN%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">1.3.4.6.</span> <span class="nav-text">SYSENTER_RETURN的代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">1.4.</span> <span class="nav-text">参数传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E5%8F%82%E6%95%B0"><span class="nav-number">1.4.1.</span> <span class="nav-text">验证参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">1.4.2.</span> <span class="nav-text">访问进程地址空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%9C%B0%E5%9D%80%E6%A3%80%E6%9F%A5%EF%BC%9A%E4%BF%AE%E6%AD%A3%E4%BB%A3%E7%A0%81"><span class="nav-number">1.4.3.</span> <span class="nav-text">动态地址检查：修正代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E8%A1%A8"><span class="nav-number">1.5.</span> <span class="nav-text">异常表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%BC%82%E5%B8%B8%E8%A1%A8%E5%92%8C%E4%BF%AE%E6%AD%A3%E4%BB%A3%E7%A0%81"><span class="nav-number">1.5.1.</span> <span class="nav-text">生成异常表和修正代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%B0%81%E8%A3%85%E4%BE%8B%E7%A8%8B"><span class="nav-number">1.6.</span> <span class="nav-text">内核封装例程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">2.</span> <span class="nav-text">信号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.1.</span> <span class="nav-text">信号的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E4%BF%A1%E5%8F%B7%E4%B9%8B%E5%89%8D%E6%89%80%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.1.</span> <span class="nav-text">传递信号之前所执行的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#POSIX-%E4%BF%A1%E5%8F%B7%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8"><span class="nav-number">2.1.2.</span> <span class="nav-text">POSIX 信号和多线程应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8E%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.3.</span> <span class="nav-text">与信号相关的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">信号描述符和信号处理程序描述符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sigaction"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">sigaction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%82%E8%B5%B7%E4%BF%A1%E5%8F%B7%E9%98%9F%E5%88%97"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">挂起信号队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%BF%A1%E5%8F%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.4.</span> <span class="nav-text">在信号数据结构上的操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7"><span class="nav-number">2.2.</span> <span class="nav-text">产生信号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#specific-send-sig-info"><span class="nav-number">2.2.1.</span> <span class="nav-text">specific_send_sig_info()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#send-signal"><span class="nav-number">2.2.2.</span> <span class="nav-text">send_signal()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#group-send-sig-info"><span class="nav-number">2.2.3.</span> <span class="nav-text">group_send_sig_info()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E4%BF%A1%E5%8F%B7"><span class="nav-number">2.3.</span> <span class="nav-text">传递信号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%BC%BA%E7%9C%81%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.1.</span> <span class="nav-text">执行信号的缺省操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E4%BF%A1%E5%8F%B7"><span class="nav-number">2.4.</span> <span class="nav-text">捕获信号</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E5%B8%A7"><span class="nav-number">2.4.1.</span> <span class="nav-text">建立帧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E4%BF%A1%E5%8F%B7%E6%A0%87%E5%BF%97"><span class="nav-number">2.4.2.</span> <span class="nav-text">检查信号标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.4.3.</span> <span class="nav-text">开始执行信号处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.4.4.</span> <span class="nav-text">终止信号处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C"><span class="nav-number">2.4.5.</span> <span class="nav-text">系统调用的重新执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C%E8%A2%AB%E6%9C%AA%E6%8D%95%E8%8E%B7%E4%BF%A1%E5%8F%B7%E4%B8%AD%E6%96%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.4.6.</span> <span class="nav-text">重新执行被未捕获信号中断的系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E6%89%80%E6%8D%95%E8%8E%B7%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.4.7.</span> <span class="nav-text">为所捕获的信号重新执行系统调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.5.</span> <span class="nav-text">与信号处理相关的系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kill"><span class="nav-number">2.5.1.</span> <span class="nav-text">kill</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tkill-%E5%92%8C-tgkill"><span class="nav-number">2.5.2.</span> <span class="nav-text">tkill() 和 tgkill()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%8F%98%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">2.5.3.</span> <span class="nav-text">改变信号的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E6%8C%82%E8%B5%B7%E7%9A%84%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7"><span class="nav-number">2.5.4.</span> <span class="nav-text">检查挂起的阻塞信号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E7%9A%84%E9%9B%86%E5%90%88"><span class="nav-number">2.5.5.</span> <span class="nav-text">修改阻塞信号的集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E8%B5%B7%E8%BF%9B%E7%A8%8B"><span class="nav-number">2.5.6.</span> <span class="nav-text">挂起进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E4%BF%A1%E5%8F%B7%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.5.7.</span> <span class="nav-text">实时信号的系统调用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.</span> <span class="nav-text">虚拟文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text">虚拟文件系统的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.1.1.</span> <span class="nav-text">通用文件模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VFS%E6%89%80%E5%A4%84%E7%90%86%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">3.1.2.</span> <span class="nav-text">VFS所处理的系统调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VFS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">VFS的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E7%BA%A7%E5%9D%97%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.2.1.</span> <span class="nav-text">超级块对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.2.2.</span> <span class="nav-text">索引节点对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.2.3.</span> <span class="nav-text">文件对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.2.4.</span> <span class="nav-text">目录项对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E9%A1%B9%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-number">3.2.5.</span> <span class="nav-text">目录项高速缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.</span> <span class="nav-text">与进程相关的文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.4.</span> <span class="nav-text">文件系统类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.4.1.</span> <span class="nav-text">特殊文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%86%8C"><span class="nav-number">3.4.2.</span> <span class="nav-text">文件系统类型注册</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%84%E7%90%86"><span class="nav-number">3.5.</span> <span class="nav-text">文件系统处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">3.5.1.</span> <span class="nav-text">命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85"><span class="nav-number">3.5.2.</span> <span class="nav-text">文件系统安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.5.3.</span> <span class="nav-text">安装普通文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do-kern-mount-%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">3.5.4.</span> <span class="nav-text">do_kern_mount()函数：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E8%B6%85%E7%BA%A7%E5%9D%97%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.5.5.</span> <span class="nav-text">分配超级块对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.5.6.</span> <span class="nav-text">安装根文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%B6%E6%AE%B51%EF%BC%9A%E5%AE%89%E8%A3%85rootfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.5.6.1.</span> <span class="nav-text">阶段1：安装rootfs文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E5%AE%9E%E9%99%85%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.5.6.2.</span> <span class="nav-text">安装实际根文件系统</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%B8%E8%BD%BD%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.5.7.</span> <span class="nav-text">卸载文件系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E5%90%8D%E6%9F%A5%E6%89%BE"><span class="nav-number">3.6.</span> <span class="nav-text">路径名查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E8%B7%AF%E5%BE%84%E5%90%8D%E6%9F%A5%E6%89%BE"><span class="nav-number">3.6.1.</span> <span class="nav-text">标准路径名查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%B6%E8%B7%AF%E5%BE%84%E5%90%8D%E6%9F%A5%E6%89%BE"><span class="nav-number">3.6.2.</span> <span class="nav-text">父路径名查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">3.6.3.</span> <span class="nav-text">符号链接的查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VFS%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.7.</span> <span class="nav-text">VFS系统调用的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#open-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">3.7.1.</span> <span class="nav-text">open()系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#read-%E5%92%8Cwrite-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">3.7.2.</span> <span class="nav-text">read()和write()系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#close-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">3.7.3.</span> <span class="nav-text">close()系统调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%8A%A0%E9%94%81"><span class="nav-number">3.8.</span> <span class="nav-text">文件加锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E6%96%87%E4%BB%B6%E5%8A%A0%E9%94%81"><span class="nav-number">3.8.1.</span> <span class="nav-text">Linux文件加锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E9%94%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.8.2.</span> <span class="nav-text">文件锁的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FL-FLOCK%E9%94%81"><span class="nav-number">3.8.3.</span> <span class="nav-text">FL_FLOCK锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FL-POSIX%E9%94%81"><span class="nav-number">3.8.4.</span> <span class="nav-text">FL_POSIX锁</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
