<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zn-ch">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode," />










<meta name="description" content="Leetcode1103. Distribute Candies to PeopleWe distribute some number of candies, to a row of n &#x3D; num_people people in the following way: We then give 1 candy to the first person, 2 candies to the secon">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode1101 - 1200">
<meta property="og:url" content="http://yoursite.com/2020/05/05/Leetcode1101_1200/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode1103. Distribute Candies to PeopleWe distribute some number of candies, to a row of n &#x3D; num_people people in the following way: We then give 1 candy to the first person, 2 candies to the secon">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/20190813008.png">
<meta property="og:image" content="http://yoursite.com/img/20220127160100.png">
<meta property="og:image" content="http://yoursite.com/img/20190824001.jpg">
<meta property="og:image" content="http://yoursite.com/img/20200629102800.jpg">
<meta property="og:image" content="http://yoursite.com/img/20200629102801.jpg">
<meta property="og:image" content="http://yoursite.com/img/20200629102802.jpg">
<meta property="article:published_time" content="2020-05-05T07:09:00.000Z">
<meta property="article:modified_time" content="2022-12-26T08:02:41.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/20190813008.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/05/05/Leetcode1101_1200/"/>





  <title>Leetcode1101 - 1200 | Hao Yu's blog</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/05/Leetcode1101_1200/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode1101 - 1200</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-05T15:09:00+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode1103-Distribute-Candies-to-People"><a href="#Leetcode1103-Distribute-Candies-to-People" class="headerlink" title="Leetcode1103. Distribute Candies to People"></a>Leetcode1103. Distribute Candies to People</h1><p>We distribute some number of candies, to a row of n = num_people people in the following way:</p>
<p>We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person.</p>
<p>Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.</p>
<p>This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  The last person will receive all of our remaining candies (not necessarily one more than the previous gift).</p>
<p>Return an array (of length num_people and sum candies) that represents the final distribution of candies.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = 7, num_people = 4</span><br><span class="line">Output: [1,2,3,1]</span><br><span class="line">Explanation:</span><br><span class="line">On the first turn, ans[0] += 1, and the array is [1,0,0,0].</span><br><span class="line">On the second turn, ans[1] += 2, and the array is [1,2,0,0].</span><br><span class="line">On the third turn, ans[2] += 3, and the array is [1,2,3,0].</span><br><span class="line">On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = 10, num_people = 3</span><br><span class="line">Output: [5,2,3]</span><br><span class="line">Explanation: </span><br><span class="line">On the first turn, ans[0] += 1, and the array is [1,0,0].</span><br><span class="line">On the second turn, ans[1] += 2, and the array is [1,2,0].</span><br><span class="line">On the third turn, ans[2] += 3, and the array is [1,2,3].</span><br><span class="line">On the fourth turn, ans[0] += 4, and the final array is [5,2,3].</span><br></pre></td></tr></table></figure><br>只考虑每次分配的糖果数，分配的糖果数为1,2,3,4,5,…, 依次加1。再考虑到分配的轮数，可以利用 i % num_people 来求得第i次应该分配到第几个人。</p>
<p>最后要注意的是，如果当前糖果数小于本应该分配的糖果数，则将当前糖果全部给予，也就是要判断剩余糖果数 candies 与本该分配糖果数 i+1 的大小，谁小分配谁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distributeCandies</span><span class="params">(<span class="type">int</span> candies, <span class="type">int</span> num_people)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(num_people, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> temp = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(candies &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res[i%num_people] += <span class="built_in">min</span>(candies, i+<span class="number">1</span>);</span><br><span class="line">            candies -= <span class="built_in">min</span>(candies, i+<span class="number">1</span>);</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1104-Path-In-Zigzag-Labelled-Binary-Tree"><a href="#Leetcode1104-Path-In-Zigzag-Labelled-Binary-Tree" class="headerlink" title="Leetcode1104. Path In Zigzag Labelled Binary Tree"></a>Leetcode1104. Path In Zigzag Labelled Binary Tree</h1><p>In an infinite binary tree where every node has two children, the nodes are labelled in row order.</p>
<p>In the odd numbered rows (ie., the first, third, fifth,…), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,…), the labelling is right to left.</p>
<p><img src="/img/20190813008.png" alt=""></p>
<p>Given the label of a node in this tree, return the labels in the path from the root of the tree to the node with that label.</p>
<p>Example 1:</p>
<p>Input: label = 14<br>Output: [1,3,4,14]<br>Example 2:</p>
<p>Input: label = 26<br>Output: [1,2,6,10,26]</p>
<p>Constraints:</p>
<p>1 &lt;= label &lt;= 10^6</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pathInZigZagTree</span><span class="params">(<span class="type">int</span> label)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">build</span>(label);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> label)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> level;</span><br><span class="line">        <span class="type">int</span> lastMin;</span><br><span class="line">        res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(), label);</span><br><span class="line">        <span class="keyword">if</span>(label != <span class="number">1</span>)&#123;</span><br><span class="line">            level = (<span class="type">int</span>)(<span class="built_in">log</span>(label)/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line">            lastMin = <span class="built_in">pow</span>(<span class="number">2</span>, level)/<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">build</span>( lastMin + (lastMin*<span class="number">2</span>)<span class="number">-1</span> - label/<span class="number">2</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为不管是奇数行还是偶数行，该行与上一行的方向都是反着来的</p>
<p>可以先求出顺着来时这个结点对应的父结点，再求出对应父结点在它所在行对称的结点</p>
<p>这里有个求对称的方法：按顺序排列且每个数都能找到对称数的一系列数，每一对对陈数的和都相同，所以求某个数的在某一行的对称数，只用找出这一行两端的数，求出和，再减去这个数就能得到这个数的对称数</p>
<p>所以只用从传进来的这个结点递归，每次递归求出自己对应的父结点，递归到1时结束，每次递归记录一次当前结点的号码</p>
<p>最后得到的一系列结点号码就是路径</p>
<h1 id="Leetcode1105-Filling-Bookcase-Shelves"><a href="#Leetcode1105-Filling-Bookcase-Shelves" class="headerlink" title="Leetcode1105. Filling Bookcase Shelves"></a>Leetcode1105. Filling Bookcase Shelves</h1><p>You are given an array books where books[i] = [thicknessi, heighti] indicates the thickness and height of the ith book. You are also given an integer shelfWidth.</p>
<p>We want to place these books in order onto bookcase shelves that have a total width shelfWidth.</p>
<p>We choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to shelfWidth, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.</p>
<p>Note that at each step of the above process, the order of the books we place is the same order as the given sequence of books.</p>
<p>For example, if we have an ordered list of 5 books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.<br>Return the minimum possible height that the total bookshelf can be after placing shelves in this manner.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">The sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.</span><br><span class="line">Notice that book number 2 does not have to be on the first shelf.</span><br></pre></td></tr></table></figure><br><img src="/img/20220127160100.png" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: books = [[1,3],[2,4],[3,2]], shelfWidth = 6</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>这道题说是让用书来填书架，每本书有其固定的宽和高，需要按给定的顺序来排列书，要么排在新的一行，要么排在之前的层，注意每层的宽度不能超过给定的 shelf_width 的限制，每层的高度按照最高的那本书来计算，问怎么安排才能使得整个书架的高度最小。这种数组玩极值的题目，大概率就是贪婪算法或者动态规划 Dynamic Programming，但是这里贪婪算法就不太合适，因为书的高度是不确定的，就算尽量每行尽可能的多放书，并不能保证整体的高度是最小的。所以只能祭出动态规划了，先来定义 DP 数组，这里使用一个一维的 dp 数组，其中<code>dp[i]</code>表示前i本书可以组成的最小高度，大小初始化为<code>n+1</code>。接下来找动态转移方程，对于每一本新的书，最差的结果就是放到新的一行中，这样整个高度就增加了当前书的高度，所以<code>dp[i]</code>可以先赋值为<code>dp[i-1] + height</code>，然后再进行优化。方法是不停加上之前的书，条件是总宽度不能超过给定值，高度选其中最高的一个，每次用<code>dp[j] + height</code>来更新<code>dp[i]</code>，最终返回<code>dp[n]</code>即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minHeightShelves</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; books, <span class="type">int</span> sw)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = books.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len+<span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> h = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j --) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((w += books[j][<span class="number">0</span>]) &gt; sw)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                h = <span class="built_in">max</span>(h, books[j][<span class="number">1</span>]);</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], (j == <span class="number">0</span> ? <span class="number">0</span> : dp[j<span class="number">-1</span>]) + h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1108-Defanging-an-IP-Address"><a href="#Leetcode1108-Defanging-an-IP-Address" class="headerlink" title="Leetcode1108. Defanging an IP Address"></a>Leetcode1108. Defanging an IP Address</h1><p>Given a valid (IPv4) IP address, return a defanged version of that IP address.</p>
<p>A defanged IP address replaces every period “.” with “[.]”.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: address = &quot;1.1.1.1&quot;</span><br><span class="line">Output: &quot;1[.]1[.]1[.]1&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: address = &quot;255.100.50.0&quot;</span><br><span class="line">Output: &quot;255[.]100[.]50[.]0&quot;</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>The given address is a valid IPv4 address.</li>
</ul>
<p>把IP地址中的“.”换成“[.]”，没有难度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">defangIPaddr</span><span class="params">(string address)</span> </span>&#123;</span><br><span class="line">        <span class="function">string <span class="title">answer</span><span class="params">(address.length()+<span class="number">6</span>,<span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;i&lt;address.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(address[i]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                answer[j++]=<span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">                answer[j++]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                answer[j++]=<span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">				answer[j++]=address[i];</span><br><span class="line">	    &#125;</span><br><span class="line">	<span class="keyword">return</span> answer;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1109-Corporate-Flight-Bookings"><a href="#Leetcode1109-Corporate-Flight-Bookings" class="headerlink" title="Leetcode1109. Corporate Flight Bookings"></a>Leetcode1109. Corporate Flight Bookings</h1><p>There are n flights that are labeled from 1 to n.</p>
<p>You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.</p>
<p>Return <em>an array answer of length n, where answer[i] is the total number of seats reserved for flight </em>i.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5</span><br><span class="line">Output: [10,55,45,25,25]</span><br><span class="line">Explanation:</span><br><span class="line">Flight labels:        1   2   3   4   5</span><br><span class="line">Booking 1 reserved:  10  10</span><br><span class="line">Booking 2 reserved:      20  20</span><br><span class="line">Booking 3 reserved:      25  25  25  25</span><br><span class="line">Total seats:         10  55  45  25  25</span><br><span class="line">Hence, answer = [10,55,45,25,25]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: bookings = [[1,2,10],[2,2,15]], n = 2</span><br><span class="line">Output: [10,25]</span><br><span class="line">Explanation:</span><br><span class="line">Flight labels:        1   2</span><br><span class="line">Booking 1 reserved:  10  10</span><br><span class="line">Booking 2 reserved:      15</span><br><span class="line">Total seats:         10  25</span><br><span class="line">Hence, answer = [10,25]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= n &lt;= 2 * 104</li>
<li>1 &lt;= bookings.length &lt;= 2 * 104</li>
<li>bookings[i].length == 3</li>
<li>1 &lt;= firsti &lt;= lasti &lt;= n</li>
<li>1 &lt;= seatsi &lt;= 104</li>
</ul>
<p>这道题说是有n个航班，标号从1到n，每次公司可以连续预定多个航班上的座位，用一个三元数组 [i, j, k]，表示分别预定航班i到j上的k个座位，最后问每个航班上总共被预定了多少个座位。博主先试了一下暴力破解，毫无意外的超时了，想想为啥会超时，因为对于每个预定的区间，都遍历一次的话，最终可能达到n的平方级的复杂度。所以就需要想一些节省运算时间的办法，其实这道的解法很巧妙，先来想想，假如只有一个预定，是所有航班上均订k个座位，那么暴力破解的方法就是从1遍历到n，然后每个都加上k，但还有一种方法，就是只在第一天加上k，然后计算累加和数组，这样之后的每一天都会被加上k。如果是预定前一半的航班，那么暴力破解的方法就是从1遍历到 n/2，而这里的做法是在第一个天加上k，在第 n/2 + 1 天减去k，这样再求累加和数组时，后一半的航班就不会加上k了。对于所有的预定都可以采用这种做法，在起始位置加上k，在结束位置加1处减去k，最后再整体算累加和数组，这样就把平方级的时间复杂度缩小到了线性，完美通过 OJ，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; bookings, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> booking : bookings) &#123;</span><br><span class="line">            res[booking[<span class="number">0</span>] - <span class="number">1</span>] += booking[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (booking[<span class="number">1</span>] &lt; n) res[booking[<span class="number">1</span>]] -= booking[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res[i] += res[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1110-Delete-Nodes-And-Return-Forest"><a href="#Leetcode1110-Delete-Nodes-And-Return-Forest" class="headerlink" title="Leetcode1110. Delete Nodes And Return Forest"></a>Leetcode1110. Delete Nodes And Return Forest</h1><p>Given the root of a binary tree, each node in the tree has a distinct value.</p>
<p>After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).</p>
<p>Return the roots of the trees in the remaining forest. You may return the result in any order.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]</span><br><span class="line">Output: [[1,2,null,4],[6],[7]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,4,null,3], to_delete = [3]</span><br><span class="line">Output: [[1,2,4]]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>The number of nodes in the given tree is at most 1000.</li>
<li>Each node has a distinct value between 1 and 1000.</li>
<li>to_delete.length &lt;= 1000</li>
<li>to_delete contains distinct values between 1 and 1000.</li>
</ul>
<p>这道题给了一棵二叉树，说了每个结点值均不相同，现在让删除一些结点，由于删除某些位置的结点会使原来的二叉树断开，从而会形成多棵二叉树，形成一片森林，让返回森林中所有二叉树的根结点。对于二叉树的题，十有八九都是用递归来做的，这道题也不例外，先来想一下这道题的难点在哪里，去掉哪些点会形成新树，显而易见的是，去掉根结点的话，左右子树若存在的话一定会形成新树，同理，去掉子树的根结点，也可能会形成新树，只有去掉叶结点时才不会生成新树，所以当前结点是不是根结点就很重要了，这个需要当作一个参数传入。由于需要知道当前结点是否需要被删掉，每次都遍历 to_delete 数组显然不高效，那就将其放入一个 HashSet 中，从而到达常数级的搜索时间。这样递归函数就需要四个参数，当前结点，是否是根结点的布尔型变量，HashSet，还有结果数组 res。在递归函数中，首先判空，然后判断当前结点值是否在 HashSet，用一个布尔型变量 deleted 来记录。若当前是根结点，且不需要被删除，则将这个结点加入结果 res 中。然后将左子结点赋值为对左子结点调用递归函数的返回值，右子结点同样赋值为对右子结点调用递归的返回值，最后判断当前结点是否被删除了，是的话返回空指针，否则就返回当前指针，这样的话每棵树的根结点都在递归的过程中被存入结果 res 中了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(to_delete.begin(), to_delete.end())</span></span>;</span><br><span class="line">        <span class="built_in">helper</span>(root, <span class="literal">true</span>, st, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode* node, <span class="type">bool</span> is_root, unordered_set&lt;<span class="type">int</span>&gt;&amp; st, vector&lt;TreeNode*&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">bool</span> deleted = st.<span class="built_in">count</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (is_root &amp;&amp; !deleted) res.<span class="built_in">push_back</span>(node);</span><br><span class="line">        node-&gt;left = <span class="built_in">helper</span>(node-&gt;left, deleted, st, res);</span><br><span class="line">        node-&gt;right = <span class="built_in">helper</span>(node-&gt;right, deleted, st, res);</span><br><span class="line">        <span class="keyword">return</span> deleted ? <span class="literal">nullptr</span> : node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1111-Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings"><a href="#Leetcode1111-Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings" class="headerlink" title="Leetcode1111. Maximum Nesting Depth of Two Valid Parentheses Strings"></a>Leetcode1111. Maximum Nesting Depth of Two Valid Parentheses Strings</h1><p>A string is a valid parentheses string (denoted VPS) if and only if it consists of “(“ and “)” characters only, and:</p>
<p>It is the empty string, or</p>
<ul>
<li>It can be written as AB (A concatenated with B), where A and B are VPS’s, or</li>
<li>It can be written as (A), where A is a VPS.</li>
</ul>
<p>We can similarly define the nesting depth depth(S) of any VPS S as follows:</p>
<ul>
<li>depth(“”) = 0</li>
<li>depth(A + B) = max(depth(A), depth(B)), where A and B are VPS’s</li>
<li>depth(“(“ + A + “)”) = 1 + depth(A), where A is a VPS.</li>
</ul>
<p>For example,  “”, “()()”, and “()(()())” are VPS’s (with nesting depths 0, 1, and 2), and “)(“ and “(()” are not VPS’s.</p>
<p>Given a VPS seq, split it into two disjoint subsequences A and B, such that A and B are VPS’s (and A.length + B.length = seq.length).</p>
<p>Now choose any such A and B such that max(depth(A), depth(B)) is the minimum possible value.</p>
<p>Return an answer array (of length seq.length) that encodes such a choice of A and B:  answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.  Note that even though multiple answers may exist, you may return any of them.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: seq = &quot;(()())&quot;</span><br><span class="line">Output: [0,1,1,1,1,0]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: seq = &quot;()(())()&quot;</span><br><span class="line">Output: [0,0,0,1,1,0,1,1]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= seq.size &lt;= 10000</li>
</ul>
<p>题目很简单，就是将一个集合拆分为两个depth最接近的两个集合。所以我们需要先计算出总的depth(S)是多少，然后将其除2就得到了其中一个集合的depth(A)，然后就可以计算出另外一个集合的depth(B)=depth(S)-depth(A)。</p>
<p>接着考虑如何将两个集合挑选出来，也是非常容易的，我们只需要再次遍历seq，记录遍历的’(‘的数目，如果’(‘的数目超过了As（A集合的depth）的话，我们就将对应的字符标记为B集合的即可（也就是标记为1）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxDepthAfterSplit</span><span class="params">(string seq)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ds=<span class="number">0</span>,cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;seq.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seq[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                cur+=<span class="number">1</span>;</span><br><span class="line">                ds=<span class="built_in">max</span>(ds,cur);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> as=ds/<span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(seq.length(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;seq.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seq[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                cur+=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur&gt;as)</span><br><span class="line">                    res[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur&gt;as)</span><br><span class="line">                    res[i]=<span class="number">1</span>;</span><br><span class="line">                cur-=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1114-Print-in-Order"><a href="#Leetcode1114-Print-in-Order" class="headerlink" title="Leetcode1114. Print in Order"></a>Leetcode1114. Print in Order</h1><p>Suppose we have a class:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Foo &#123;</span><br><span class="line">  public void first() &#123; print(&quot;first&quot;); &#125;</span><br><span class="line">  public void second() &#123; print(&quot;second&quot;); &#125;</span><br><span class="line">  public void third() &#123; print(&quot;third&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>The same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second().</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: &quot;firstsecondthird&quot;</span><br><span class="line">Explanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). &quot;firstsecondthird&quot; is the correct output.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,2]</span><br><span class="line">Output: &quot;firstsecondthird&quot;</span><br><span class="line">Explanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). &quot;firstsecondthird&quot; is the correct output.</span><br></pre></td></tr></table></figure></p>
<p>现在三个线程，每个线程分别调用三个函数中的一个。无论线程的产生和调用关系怎么样，最终输出的结果要求都是”firstsecondthird”。如何设计是三个函数。这个是Leetcode的新题型，也就是说并发类型，我觉得很实用，工作中能用到。一般情况下，最简单的协调不同线程之间的调度关系，都可以使用mutex来做，本质是信号量。</p>
<p><code>std::mutex</code>的成员函数有四个：</p>
<ul>
<li>构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。</li>
<li><code>lock()</code>，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：<ul>
<li>(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。</li>
<li>(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。</li>
<li>(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>
</ul>
</li>
<li><code>unlock()</code>， 解锁，释放对互斥量的所有权。</li>
<li><code>try_lock()</code>，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，<ul>
<li>(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。</li>
<li>(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。</li>
<li>(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</li>
</ul>
</li>
</ul>
<p>也就是说一个锁能控制两个线程的执行顺序。这个题中我们需要保持三个函数是按顺序执行的，则需要两个锁m1和m2。在开始的时候，两个锁都锁起来。first()可以直接执行，second()等待m1释放之后执行，third()等待m2释放之后执行。first()结束之后释放m1，second()结束之后释放m2.因此三个的顺序都协调一致了。C++代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">    mutex m1, m2;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123;</span><br><span class="line">	        m1.<span class="built_in">lock</span>();</span><br><span class="line">	        m2.<span class="built_in">lock</span>();</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printFirst)</span> </span>&#123;</span><br><span class="line">	        <span class="comment">// printFirst() outputs &quot;first&quot;. Do not change or remove this line.</span></span><br><span class="line">	        <span class="built_in">printFirst</span>();</span><br><span class="line">	        m1.<span class="built_in">unlock</span>();</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printSecond)</span> </span>&#123;</span><br><span class="line">	        m1.<span class="built_in">lock</span>();</span><br><span class="line">	        <span class="comment">// printSecond() outputs &quot;second&quot;. Do not change or remove this line.</span></span><br><span class="line">	        <span class="built_in">printSecond</span>();</span><br><span class="line">	        m1.<span class="built_in">unlock</span>();</span><br><span class="line">	        m2.<span class="built_in">unlock</span>();</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="type">void</span>()&gt; printThird)</span> </span>&#123;</span><br><span class="line">	        m2.<span class="built_in">lock</span>();</span><br><span class="line">	        <span class="comment">// printThird() outputs &quot;third&quot;. Do not change or remove this line.</span></span><br><span class="line">	        <span class="built_in">printThird</span>();</span><br><span class="line">	        m2.<span class="built_in">unlock</span>();</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1122-Relative-Sort-Array"><a href="#Leetcode1122-Relative-Sort-Array" class="headerlink" title="Leetcode1122. Relative Sort Array"></a>Leetcode1122. Relative Sort Array</h1><p>Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.</p>
<p>Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2.  Elements that don’t appear in arr2 should be placed at the end of arr1 in ascending order.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]</span><br><span class="line">Output: [2,2,2,1,4,3,3,9,6,7,19] </span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>arr1.length, arr2.length &lt;= 1000</li>
<li>0 &lt;= arr1[i], arr2[i] &lt;= 1000</li>
<li>Each arr2[i] is distinct.</li>
<li>Each arr2[i] is in arr1.</li>
</ul>
<p>arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中，对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。</p>
<p>基本思路是：</p>
<ol>
<li>首先题目的意思是按照arr2的元素顺序返回arr1的元素，假定返回的新数组为arr3，然后把剩余的arr1元素按照升序顺序拼接到arr3后边返回</li>
<li>遍历一遍arr1使用map [Int:Int] 记录每一个元素的次数</li>
<li>遍历arr2，把在arr2出现的元素当做key取出value值，arr3 add value次key值</li>
<li>把剩余的字典键值对所对应的key值排序，添加到arr3后边</li>
<li>时间复杂度 O(nlogn)</li>
<li>空间复杂度 O(n)</li>
</ol>
<p><strong>注意map是有序的，内部是用平衡树存储，而unordered_map是用hash做的，也不能保证插入的顺序</strong>，因此这里使用了大佬的做法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">relativeSortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count_arr[<span class="number">1001</span>];</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">memset</span>(count_arr, <span class="number">0</span>, <span class="built_in">sizeof</span>(count_arr));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr1.<span class="built_in">size</span>();i++)</span><br><span class="line">            count_arr[arr1[i]]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> len = count_arr[arr2[i]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">                ans.<span class="built_in">push_back</span>(arr2[i]);</span><br><span class="line">            count_arr[arr2[i]]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr1.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count_arr[arr1[i]] &gt; <span class="number">0</span>) s.<span class="built_in">push_back</span>(arr1[i]);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1123-Lowest-Common-Ancestor-of-Deepest-Leaves"><a href="#Leetcode1123-Lowest-Common-Ancestor-of-Deepest-Leaves" class="headerlink" title="Leetcode1123. Lowest Common Ancestor of Deepest Leaves"></a>Leetcode1123. Lowest Common Ancestor of Deepest Leaves</h1><p>Given a rooted binary tree, return the lowest common ancestor of its deepest leaves.</p>
<p>Recall that:</p>
<ul>
<li>The node of a binary tree is a leaf if and only if it has no children</li>
<li>The depth of the root of the tree is 0, and if the depth of a node is d, the depth of each of its children is d+1.</li>
<li>The lowest common ancestor of a set S of nodes is the node A with the largest depth such that every node in S is in the subtree with root A.</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3]</span><br><span class="line">Output: [1,2,3]</span><br><span class="line">Explanation: </span><br><span class="line">The deepest leaves are the nodes with values 2 and 3.</span><br><span class="line">The lowest common ancestor of these leaves is the node with value 1.</span><br><span class="line">The answer returned is a TreeNode object (not an array) with serialization &quot;[1,2,3]&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4]</span><br><span class="line">Output: [4]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5]</span><br><span class="line">Output: [2,4,5]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>The given tree will have between 1 and 1000 nodes.</li>
<li>Each node of the tree will have a distinct value between 1 and 1000.</li>
</ul>
<p>写一个递归函数，返回(LCA, 最大深度)，然后对左右子树分别调用这个函数。如果两棵子树的高度不同，则显然最大深度的叶子只存在更深的子树中，那么另一棵子树就不用管了，LCA也不变；否则LCA是当前树根。</p>
<p>就是，他不是要求最大深度公共子树么，就求左右子树的深度，如果相等了，说明找到了，因为是从上往下的，这就是最大的深度；否则的话对左右子树分别搞一搞。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">solve</span>(root-&gt;left), <span class="built_in">solve</span>(root-&gt;right));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">lcaDeepestLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">solve</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">solve</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; r)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lcaDeepestLeaves</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lcaDeepestLeaves</span>(root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1124-Longest-Well-Performing-Interval"><a href="#Leetcode1124-Longest-Well-Performing-Interval" class="headerlink" title="Leetcode1124. Longest Well-Performing Interval"></a>Leetcode1124. Longest Well-Performing Interval</h1><p>We are given hours, a list of the number of hours worked per day for a given employee.</p>
<p>A day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.</p>
<p>A well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.</p>
<p>Return the length of the longest well-performing interval.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: hours = [9,9,6,0,6,6,9]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest well-performing interval is [9,9,6].</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= hours.length &lt;= 10000</li>
<li>0 &lt;= hours[i] &lt;= 16</li>
</ul>
<p>把所有大于8的转成1，小于8的转成-1，找到最长的字串，字串的和大于等于1，<strong>最优解的字串的和肯定是1</strong>，因为如果大于1的话肯定可以往后走。</p>
<p>存储可能的target_sum的序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestWPI</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; hours)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;hours.<span class="built_in">size</span>();i++)</span><br><span class="line">            hours[i]=hours[i]&gt;<span class="number">8</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; idx;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">0</span>,inx=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> last=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;hours.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            r += hours[i];</span><br><span class="line">            <span class="keyword">if</span>(r&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                maxx = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!idx.<span class="built_in">count</span>(r)) </span><br><span class="line">                idx[r] = i;</span><br><span class="line">            <span class="keyword">if</span> (idx.<span class="built_in">count</span>(r - <span class="number">1</span>))</span><br><span class="line">                maxx = <span class="built_in">max</span>(maxx, i - idx[r - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="LeetCode-1125-Smallest-Sufficient-Team"><a href="#LeetCode-1125-Smallest-Sufficient-Team" class="headerlink" title="LeetCode] 1125. Smallest Sufficient Team"></a>LeetCode] 1125. Smallest Sufficient Team</h1><p>In a project, you have a list of required skills req_skills, and a list of people. The ith person people[i] contains a list of skills that the person has.</p>
<p>Consider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.</p>
<p>For example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3].<br>Return any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.</p>
<p>It is guaranteed an answer exists.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: req_skills = [&quot;java&quot;,&quot;nodejs&quot;,&quot;reactjs&quot;], people = [[&quot;java&quot;],[&quot;nodejs&quot;],[&quot;nodejs&quot;,&quot;reactjs&quot;]]</span><br><span class="line">Output: [0,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: req_skills = [&quot;algorithms&quot;,&quot;math&quot;,&quot;java&quot;,&quot;reactjs&quot;,&quot;csharp&quot;,&quot;aws&quot;], people = [[&quot;algorithms&quot;,&quot;math&quot;,&quot;java&quot;],[&quot;algorithms&quot;,&quot;math&quot;,&quot;reactjs&quot;],[&quot;java&quot;,&quot;csharp&quot;,&quot;aws&quot;],[&quot;reactjs&quot;,&quot;csharp&quot;],[&quot;csharp&quot;,&quot;math&quot;],[&quot;aws&quot;,&quot;java&quot;]]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= req_skills.length &lt;= 16</li>
<li>1 &lt;= req_skills[i].length &lt;= 16</li>
<li>req_skills[i] consists of lowercase English letters.</li>
<li>All the strings of req_skills are unique.</li>
<li>1 &lt;= people.length &lt;= 60</li>
<li>0 &lt;= people[i].length &lt;= 16</li>
<li>1 &lt;= people[i][j].length &lt;= 16</li>
<li>people[i][j] consists of lowercase English letters.</li>
<li>All the strings of people[i] are unique.</li>
<li>Every skill in people[i] is a skill in req_skills.</li>
<li>It is guaranteed a sufficient team exists.</li>
</ul>
<p>这道题给了一个技能数组，是完成某一个项目所需要的必备技能。又给了一个候选人的数组，每个人都有不同的技能，现在问最少需要多少人可以完成这个项目。由于每个人的技能点不同，为了能完成这个项目，所选的人的技能点的并集要正好包含所有的项目必备技能，而且还要求人数尽可能的少，这就是一道典型的动态规划 Dynamic Programming 的题。这道题敢标 Hard 是有其一定的道理的，首先 DP 数组的定义就是一个难点，因为我们也不知道最少需要多少个人可以拥有所有的必备技能。另一个难点是如何表示这些技能，总不能每次都跟 req_skills 数组一一对比吧，太不高效了。一个比较好的方法是使用二进制来表示，有多少个技能就对应多少位，某人拥有某技能，则对应位上为1，否则为0。若总共有n个必备技能，实际上只用一个 2^n-1 的数字就可以表示了。这里我们的 dp 数组定义为 HashMap，建立技能集合的位表示数和拥有这些技能的人（最少的人数）的集合之间的映射，那么最终的结果就是 dp[(1&lt;&lt;n)-1] 对应的数组的长度了。首先将 dp[0] 映射为空数组，因为0表示没有任何技能，自然也不需要任何人，这个初始化是一定要做的，之后会讲原因。这里再用另一个 HashMap，将每个技能映射到其在技能数组中的坐标，这样方便之后快速的翻转技能集合二进制的对应位。先用一个 for 循环来建立这个 skillMap 的映射，然后就是遍历每个候选人了，使用一个整型变量 skill，然后根据 skillMap 查找这个人所有的技能，并将其对应位翻为1，这样此时的 skill 就 encode 了该人的所有的技能。现在就该尝试更新 dp 了，遍历此时 dp 的所有映射，此时之前加入的那个初始化的映射就发挥作用了，就像很多其他 DP 的题都要给 dp[0] 初始化一样，没有这个引子，后面的更新都不会发生，整个 for 都进不去。将当前的 key 值或上 skill，则表示将当前这个人加到了某个映射的人的集合中了，这样就可能会生出现一个新的技能集合的位表示数（也可能不出现，即当前这个人的所有技能已经被之前集合中的所有人包括了），此时看若 dp 中不存在这个技能集合的位表示数，或者新的技能集合的位表示数对应的人的集合长度大于原来的人的集合长度加1，说明 dp 需要被更新了，将新的位表示数映射到加入这个人后的新的人的集合，这样更新下来，就能保证最终 dp[(1&lt;&lt;n)-1] 的值最小，因为题目中说了一定会有解，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestSufficientTeam</span><span class="params">(vector&lt;string&gt;&amp; req_skills, vector&lt;vector&lt;string&gt;&gt;&amp; people)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = req_skills.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">1</span> &lt;&lt; n);</span><br><span class="line">        dp[<span class="number">0</span>] = &#123;&#125;;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; skillMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            skillMap[req_skills[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> skill = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (string str : people[i]) &#123;</span><br><span class="line">                skill |= <span class="number">1</span> &lt;&lt; skillMap[str];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> a : dp) &#123;</span><br><span class="line">                <span class="type">int</span> cur = a.first | skill;</span><br><span class="line">                <span class="keyword">if</span> (!dp.<span class="built_in">count</span>(cur) || dp[cur].<span class="built_in">size</span>() &gt; <span class="number">1</span> + dp[a.first].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    dp[cur] = a.second;</span><br><span class="line">                    dp[cur].<span class="built_in">push_back</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestSufficientTeam</span><span class="params">(vector&lt;string&gt;&amp; req_skills, vector&lt;vector&lt;string&gt;&gt;&amp; people)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = req_skills.<span class="built_in">size</span>(), n = people.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxstate = <span class="number">1</span> &lt;&lt; m;</span><br><span class="line">        <span class="comment">// f[i][s] = 考虑前i个人的时候，状态为s所需的最小人数</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(maxstate, <span class="number">1e9</span>));</span><br><span class="line">        <span class="comment">// path[i][s] = 前i个人的时候，选人方案，</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">path</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(maxstate, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="type">int</span> state = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; str : people[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> id = <span class="built_in">find</span>(req_skills.<span class="built_in">begin</span>(), req_skills.<span class="built_in">end</span>(), str) - req_skills.<span class="built_in">begin</span>();</span><br><span class="line">                state |= (<span class="number">1</span> &lt;&lt; id);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; maxstate; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i<span class="number">-1</span>][j] &lt; f[i][j]) &#123;</span><br><span class="line">                    f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">                    path[i][j] = path[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="type">int</span> news = j | state;</span><br><span class="line">                <span class="keyword">if</span> (f[i<span class="number">-1</span>][j] + <span class="number">1</span> &lt; f[i][news]) &#123;</span><br><span class="line">                    f[i][news] = f[i<span class="number">-1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                    path[i][news] = path[i<span class="number">-1</span>][j] | (<span class="number">1LL</span> &lt;&lt; i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">if</span> ((path[n][maxstate<span class="number">-1</span>] &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">                ret.<span class="built_in">push_back</span>(i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1128-Number-of-Equivalent-Domino-Pairs"><a href="#Leetcode1128-Number-of-Equivalent-Domino-Pairs" class="headerlink" title="Leetcode1128. Number of Equivalent Domino Pairs"></a>Leetcode1128. Number of Equivalent Domino Pairs</h1><p>Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a==c and b==d), or (a==d and b==c) - that is, one domino can be rotated to be equal to another domino.</p>
<p>Return the number of pairs (i, j) for which 0 &lt;= i &lt; j &lt; dominoes.length, and dominoes[i] is equivalent to dominoes[j].</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>给你一个由一些多米诺骨牌组成的列表 dominoes。如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d]，等价的前提是 a==c 且 b==d，或是 a==d 且 b==c。在 0 &lt;= i &lt; j &lt; dominoes.length 的前提下，找出满足 dominoes[i] 和 dominoes[j] 等价的骨牌对 (i, j) 的数量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numEquivDominoPairs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dominoes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dominoes.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dominoes[i][<span class="number">0</span>] &gt; dominoes[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                temp = dominoes[i][<span class="number">0</span>];</span><br><span class="line">                dominoes[i][<span class="number">0</span>] = dominoes[i][<span class="number">1</span>];</span><br><span class="line">                dominoes[i][<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = dominoes[i][<span class="number">0</span>]*<span class="number">10</span> + dominoes[i][<span class="number">1</span>];</span><br><span class="line">            mp[temp] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; i : mp) &#123;</span><br><span class="line">            <span class="type">int</span> v = i.second;</span><br><span class="line">            ans += (v*(v<span class="number">-1</span>))/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1129-Shortest-Path-with-Alternating-Colors"><a href="#Leetcode1129-Shortest-Path-with-Alternating-Colors" class="headerlink" title="Leetcode1129. Shortest Path with Alternating Colors"></a>Leetcode1129. Shortest Path with Alternating Colors</h1><p>Consider a directed graph, with nodes labelled 0, 1, …, n-1.  In this graph, each edge is either red or blue, and there could be self-edges or parallel edges.</p>
<p>Each [i, j] in red_edges denotes a red directed edge from node i to node j.  Similarly, each [i, j] in blue_edges denotes a blue directed edge from node i to node j.</p>
<p>Return an array answer of length n, where each answer[X] is the length of the shortest path from node 0 to node X such that the edge colors alternate along the path (or -1 if such a path doesn’t exist).</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3, red_edges = [[0,1],[1,2]], blue_edges = []</span><br><span class="line">Output: [0,1,-1]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]</span><br><span class="line">Output: [0,1,-1]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3, red_edges = [[1,0]], blue_edges = [[2,1]]</span><br><span class="line">Output: [0,-1,-1]</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3, red_edges = [[0,1]], blue_edges = [[1,2]]</span><br><span class="line">Output: [0,1,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]]</span><br><span class="line">Output: [0,1,1]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= n &lt;= 100</li>
<li>red_edges.length &lt;= 400</li>
<li>blue_edges.length &lt;= 400</li>
<li>red_edges[i].length == blue_edges[i].length == 2</li>
<li>0 &lt;= red_edges[i][j], blue_edges[i][j] &lt; n</li>
</ul>
<p>这道题给了一个有向图，跟以往不同的是，这里的边分为两种不同颜色，红和蓝，现在让求从结点0到所有其他结点的最短距离，并且要求路径必须是红蓝交替，即不能有相同颜色的两条边相连。这种遍历图求最短路径的题目的首选解法应该是广度优先遍历 Breadth-first Search，就像迷宫遍历的问题一样，由于其遍历的机制，当其第一次到达某个结点时，当前的步数一定是最少的。不过这道题还有一个难点，就是如何保证路径是红蓝交替的，这就跟以往有些不同了，必须要建立两个图的结构，分别保存红边和蓝边，为了方便起见，使用一个二维数组，最外层用0表示红边，1表示蓝边。内层是一个大小为n的数组，因为有n个结点，数组中的元素是一个 HashSet，因为每个结点可能可以连到多个其他的结点，这个图的结构可以说是相当的复杂了。</p>
<p>接下来就是给图结构赋值了，分别遍历红边和蓝边的数组，将对应的结点连上，就是将相连的结点加到 HashSet 中。由于到达每个结点可能通过红边或者蓝边，所以就有两个状态，这里用一个二维的 dp 数组来记录这些状态，其中 dp[i][j] 表示最后由颜色i的边到达结点j的最小距离，除了结点0之外，均初始化为 2n，因为即便是有向图，到达某个结点的最小距离也不可能大于 2n。由于是 BFS 遍历，需要用到 queue，这里的 queue 中的元素需要包含两个信息，当前的结点值，到达该点的边的颜色，所以初始化时分别将 (0,0) 和 (0,1) 放进去，前一个0表示结点值，后一个表示到达该点的边的颜色。接下来就可以进行 BFS 遍历了，进行 while 循环，将队首元素取出，将结点值 cur 和颜色值 color 取出。由于到达当前结点的边的颜色是 color，接下来就只能选另一种颜色了，则可以用 1-color 来选另一种颜色，并且在该颜色下遍历和 cur 相连的所有结点，若其对应的 dp 值仍为 2n，说明是第一次到达该结点，可用当前 dp 值加1来更新其 dp 值，并且将新的结点值与其颜色加入到队列中以便下次遍历其相连结点。当循环结束之后，只需要遍历一次 dp 值，将每个结点值对应的两个 dp 值中的较小的那个放到结果 res 中即可，注意要进行一下判断，若 dp 值仍为 2n，说明无法到达该结点，需要换成 -1，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shortestAlternatingPaths</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; red_edges, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; blue_edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        vector&lt;vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">graph</span>(<span class="number">2</span>, vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : red_edges) &#123;</span><br><span class="line">            graph[<span class="number">0</span>][edge[<span class="number">0</span>]].<span class="built_in">insert</span>(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;edge : blue_edges) &#123;</span><br><span class="line">            graph[<span class="number">1</span>][edge[<span class="number">0</span>]].<span class="built_in">insert</span>(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">2</span> * n;</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">2</span> * n;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;vector&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> cur = q.<span class="built_in">front</span>()[<span class="number">0</span>], color = q.<span class="built_in">front</span>()[<span class="number">1</span>]; q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> next : graph[<span class="number">1</span> - color][cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[<span class="number">1</span> - color][next] == <span class="number">2</span> * n) &#123;</span><br><span class="line">                    dp[<span class="number">1</span> - color][next] = <span class="number">1</span> + dp[color][cur];</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;next, <span class="number">1</span> - color&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> val = <span class="built_in">min</span>(dp[<span class="number">0</span>][i], dp[<span class="number">1</span>][i]);</span><br><span class="line">            res[i] = val == <span class="number">2</span> * n ? <span class="number">-1</span> : val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1130-Minimum-Cost-Tree-From-Leaf-Values"><a href="#Leetcode1130-Minimum-Cost-Tree-From-Leaf-Values" class="headerlink" title="Leetcode1130. Minimum Cost Tree From Leaf Values"></a>Leetcode1130. Minimum Cost Tree From Leaf Values</h1><p>Given an array arr of positive integers, consider all binary trees such that:</p>
<ul>
<li>Each node has either 0 or 2 children;</li>
<li>The values of arr correspond to the values of each leaf in an in-order traversal of the tree.   (Recall that a node is a leaf if and only if it has 0 children.)</li>
<li>The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.</li>
</ul>
<p>Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node.  It is guaranteed this sum fits into a 32-bit integer.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [6,2,4]</span><br><span class="line">Output: 32</span><br><span class="line">Explanation:</span><br><span class="line">There are two possible trees.  The first has non-leaf node sum 36, and the second has non-leaf node sum 32.</span><br><span class="line"></span><br><span class="line">    24            24</span><br><span class="line">   /  \          /\</span><br><span class="line">  12   4        6    8</span><br><span class="line"> /  \               /\</span><br><span class="line">6    2             2   4</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>2 &lt;= arr.length &lt;= 40</li>
<li>1 &lt;= arr[i] &lt;= 15</li>
<li>It is guaranteed that the answer fits into a 32-bit signed integer (ie. it is less than 2^31).</li>
</ul>
<p>这道题给了一个数组，说是里面都是一棵树的叶结点，说是其组成的树是一棵满二叉树，且这些叶结点值是通过中序遍历得到的，树中的非叶结点值是是其左右子树中最大的两个叶结点值的乘积，满足这些条件的二叉树可能不止一个，现在让找出非叶结点值之和最小的那棵树，并返回这个最小值。</p>
<p>通过观察例子，可以发现叶结点值 6，2，4 的顺序是不能变的，但是其组合方式可能很多，若有很多个叶结点，那么其组合方式就非常的多了。题目中给的提示是用动态规划 Dynamic Programming 来做，用一个二维的 dp 数组，其中 dp[i][j] 表示在区间 [i, j] 内的子数组组成的二叉树得到非叶结点值之和的最小值，接下来想状态转移方程怎么写。首先，若只有一个叶结点的话，是没法形成非叶结点的，所以 dp[i][i] 是0，最少得有两个叶结点，才有非0的值，即<code>dp[i][i+1] = arr[i] * arr[i+1]</code>，而一旦区间再大一些，就要遍历其中所有的小区间的情况，用其中的最小值来更新大区间的 dp 值。</p>
<p>这种用区间dp做，第一层循环是区间长度，第二层枚举起点，第三层枚举终点。这里的区间长度从1到n，长度为1，表示至少有两个叶结点，i从0遍历到 n-len，j可以直接确定出来为 i+len，然后用k来将区间 [i, j] 分为两个部分，由于分开的小区间在之前都已经更新过了，所以其 dp 值可以直接得到，然后再加上这两个区间中各自的最大结点值的乘积。为了不每次都遍历小区间来获得最大值，可以提前计算好任意区间的最大值，保存在 maxVec 中，这样就可以快速获取了，最后返回的结果保存在 dp[0][n-1] 中，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mctFromLeafValues</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">maxVec</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                curMax = <span class="built_in">max</span>(curMax, arr[j]);</span><br><span class="line">                maxVec[i][j] = curMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt; n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + len &lt; n; ++i) &#123;</span><br><span class="line">                <span class="type">int</span> j = i + len;</span><br><span class="line">                dp[i][j] = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; ++k) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + maxVec[i][k] * maxVec[k + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面的这种解法是参见了大神 lee215 的帖子，是一种利用单调栈来解的方法，将时间复杂度优化到了线性，惊为天人。思路是这样的，当两个叶结点生成一个父结点值，较小的那个数字使用过一次之后就不再被使用了，因为之后形成的结点是要子树中最大的那个结点值。所以问题实际上可以转化为在一个数组中，每次选择两个相邻的数字a和b，移除较小的那个数字，代价是 a*b，问当移除到数组只剩下一个数字的最小的代价。Exactly same problem，所以b是有可能复用的，要尽可能的 minimize，数字a可以是一个局部最小值，那么b就是a两边的那个较小的数字，这里使用一个单调栈来做是比较方便的。关于单调栈，博主之前也有写过一篇总结 LeetCode Monotonous Stack Summary 单调栈小结，在 LeetCode 中的应用也非常多，是一种必须要掌握的方法。这里维护一个最小栈，当前栈顶的元素是最小的，一旦遍历到一个较大的数字，此时当前栈顶的元素其实是一个局部最小值，它就需要跟旁边的一个较小的值组成一个左右叶结点，这样形成的父结点才是最小的，然后将较小的那个数字移除，符合上面的分析。然后继续比较新的栈顶元素，若还是小，则继续相同的操作，否则退出循环，将当前的数字压入栈中。最后若栈中还有数字剩余，则一定是从大到小的，只需将其按顺序两两相乘即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mctFromLeafValues</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = arr.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; st&#123;INT_MAX&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">back</span>() &lt;= num) &#123;</span><br><span class="line">                <span class="type">int</span> mid = st.<span class="built_in">back</span>();</span><br><span class="line">                st.<span class="built_in">pop_back</span>();</span><br><span class="line">                res += mid * <span class="built_in">min</span>(st.<span class="built_in">back</span>(), num);</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; st.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            res += st[i] * st[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1137-N-th-Tribonacci-Number"><a href="#Leetcode1137-N-th-Tribonacci-Number" class="headerlink" title="Leetcode1137. N-th Tribonacci Number"></a>Leetcode1137. N-th Tribonacci Number</h1><p>The Tribonacci sequence Tn is defined as follows:  T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &gt;= 0. Given n, return the value of Tn.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">T_3 = 0 + 1 + 1 = 2</span><br><span class="line">T_4 = 1 + 1 + 2 = 4</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 25</span><br><span class="line">Output: 1389537</span><br></pre></td></tr></table></figure><br>类似斐波那契数列。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        v[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> v[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            v[i] = v[i<span class="number">-1</span>] + v[i<span class="number">-2</span>] + v[i<span class="number">-3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1138-Alphabet-Board-Path"><a href="#Leetcode1138-Alphabet-Board-Path" class="headerlink" title="Leetcode1138. Alphabet Board Path"></a>Leetcode1138. Alphabet Board Path</h1><p>On an alphabet board, we start at position (0, 0), corresponding to character board[0][0].</p>
<p>Here, board = [“abcde”, “fghij”, “klmno”, “pqrst”, “uvwxy”, “z”], as shown in the diagram below.</p>
<p>We may make the following moves:</p>
<ul>
<li>‘U’ moves our position up one row, if the position exists on the board;</li>
<li>‘D’ moves our position down one row, if the position exists on the board;</li>
<li>‘L’ moves our position left one column, if the position exists on the board;</li>
<li>‘R’ moves our position right one column, if the position exists on the board;</li>
<li>‘!’ adds the character board[r][c] at our current position (r, c) to the answer.</li>
</ul>
<p>(Here, the only positions that exist on the board are positions with letters on them.)</p>
<p>Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: target = &quot;leet&quot;</span><br><span class="line">Output: &quot;DDR!UURRR!!DDD!&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: target = &quot;code&quot;</span><br><span class="line">Output: &quot;RR!DDRR!UUL!R!&quot;</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= target.length &lt;= 100</li>
<li>target consists only of English lowercase letters.</li>
</ul>
<p>这道题给了一个字母表盘，就是 26 个小写字母按每行五个排列，形成一个二维数组，共有六行，但第六行只有一个字母z。然后给了一个字符串 target，起始位置是在a，现在让分别按顺序走到 target 上的所有字符，问经过的最短路径是什么。</p>
<p>由于表盘上的字母位置是固定的，所以不需要进行遍历来找特定的字母，而是可以根据字母直接确定其在表盘的上的坐标，这样当前字母和目标字母的坐标都确定了，就可以直接找路径了，其实就是个曼哈顿距离。由于路径有很多条，只要保证距离最短都对，那么就可以先走横坐标，或先走纵坐标。其实这里选方向挺重要，因为有个很 tricky 的情况，就是字母z，因为最后一行只有一个字母z，其不能往右走，只能往上走，所以这里定一个规则，就是先往上走，再向右走。同理，从别的字母到z的话，也应该先往左走到头，再往下走。顺序确定好了，就可以想怎么正确的生成路径，往上的走的话，说明目标点在上方，则说明当前的x坐标大，则用 curX - x，由于不一定需要向上走，所以这个差值有可能是负数，则需要跟0比较大小，取较大的那个。其他情况，都是同理的，往右走用目标y坐标减去当前y坐标；往左走，用当前y坐标减去目标y坐标；往下走，用目标x坐标减去当前x坐标，最后再加上感叹号。结束一轮后，别忘了更新 curX 和 curY，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">alphabetBoardPath</span><span class="params">(string target)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> curX = <span class="number">0</span>, curY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : target) &#123;</span><br><span class="line">            <span class="type">int</span> x = (c - <span class="string">&#x27;a&#x27;</span>) / <span class="number">5</span>, y = (c - <span class="string">&#x27;a&#x27;</span>) % <span class="number">5</span>;</span><br><span class="line">            res += <span class="built_in">string</span>(<span class="built_in">max</span>(<span class="number">0</span>, curX - x), <span class="string">&#x27;U&#x27;</span>) + <span class="built_in">string</span>(<span class="built_in">max</span>(<span class="number">0</span>, y - curY), <span class="string">&#x27;R&#x27;</span>) + <span class="built_in">string</span>(<span class="built_in">max</span>(<span class="number">0</span>, curY - y), <span class="string">&#x27;L&#x27;</span>) + <span class="built_in">string</span>(<span class="built_in">max</span>(<span class="number">0</span>, x - curX), <span class="string">&#x27;D&#x27;</span>) + <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">            curX = x;</span><br><span class="line">            curY = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1139-Largest-1-Bordered-Square"><a href="#Leetcode1139-Largest-1-Bordered-Square" class="headerlink" title="Leetcode1139. Largest 1-Bordered Square"></a>Leetcode1139. Largest 1-Bordered Square</h1><p>Given a 2D grid of 0s and 1s, return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn’t exist in the grid.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,1,0,0]]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= grid.length &lt;= 100</li>
<li>1 &lt;= grid[0].length &lt;= 100</li>
<li>grid[i][j] is 0 or 1</li>
</ul>
<p>这道题给了一个只有0和1的二维数组 grid，现在让找出边长均为1的最大正方形的元素个数，实际上就是这个正方形的面积，也就是边长的平方。给定的 grid 不一定是个正方形，首先来想，如何确定一个正方形，由于边长的是相同的，只要知道了边长，和其中的一个顶点，那么这个正方形也就确定了。如何才能快速的知道其边长是否均为1呢，每次都一个一个的遍历检查的确太不高效了，比较好的方法是统计连续1的个数，注意这里不是累加和数组，而且到当前位置为止的连续1的个数，需要分为两个方向，水平和竖直。这里用<code>left</code>表示水平，<code>top</code>表示竖直。若<code>left[i][j]</code>为k，则表示从<code>grid[i][j-k]</code>到<code>grid[i][j]</code>的数字均为1，同理，若<code>top[i][j]</code>为k，则表示<code>grid[i-k][j]</code>到<code>grid[i][j]</code>的数字均为1，则表示找到了一个边长为k的正方形。由于<code>grid</code>不一定是正方形，那么其可以包含的最大的正方形的边长为<code>grid</code>的长和宽中的较小值。边长确定了，只要遍历左上顶点的就行了，然后通过连续1数组<code>top</code>和<code>left</code>来快速判断四条边是否为1，只要找到了这个正方形，就可以直接返回了，否则就将边长减少1，继续查找，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largest1BorderedSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">left</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n)), <span class="built_in">top</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                left[i][j] = j == <span class="number">0</span> ? <span class="number">1</span> : left[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                top[i][j] = i == <span class="number">0</span> ? <span class="number">1</span> : top[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="built_in">min</span>(m, n); len &gt; <span class="number">0</span>; --len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - len + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - len + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (top[i + len - <span class="number">1</span>][j] &gt;= len &amp;&amp; top[i + len - <span class="number">1</span>][j + len - <span class="number">1</span>] &gt;= len &amp;&amp; left[i][j + len - <span class="number">1</span>] &gt;= len &amp;&amp; left[i + len - <span class="number">1</span>][j + len - <span class="number">1</span>] &gt;= len) <span class="keyword">return</span> len * len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>上面的方法是根据边长进行遍历，若数组很大，而其中的1很少，这种遍历方法将不是很高效。我们从 grid 数组的右下角往左上角遍历，即从每个潜在的正方形的右下角开始遍历，根据右下顶点的位置取到的 top 和 left 值，分别是正方形的右边和下边的边长，取其中较小的那个为目标正方形的边长，然后现在就要确定是否存在相应的左边和上边，存在话的更新 mx，否则将目标边长减1，继续查找，直到目标边长小于 mx 了停止。继续这样的操作直至遍历完所有的右下顶点，这种遍历的方法要高效不少，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largest1BorderedSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mx = <span class="number">0</span>, m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">left</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n)), <span class="built_in">top</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                left[i][j] = j == <span class="number">0</span> ? <span class="number">1</span> : left[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                top[i][j] = i == <span class="number">0</span> ? <span class="number">1</span> : top[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="type">int</span> small = <span class="built_in">min</span>(left[i][j], top[i][j]);</span><br><span class="line">                <span class="keyword">while</span> (small &gt; mx) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (top[i][j - small + <span class="number">1</span>] &gt;= small &amp;&amp; left[i - small + <span class="number">1</span>][j] &gt;= small) mx = small;</span><br><span class="line">                    --small;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mx * mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1140-Stone-Game-II"><a href="#Leetcode1140-Stone-Game-II" class="headerlink" title="Leetcode1140. Stone Game II"></a>Leetcode1140. Stone Game II</h1><p>Alice and Bob continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  The objective of the game is to end with the most stones.</p>
<p>Alice and Bob take turns, with Alice starting first.  Initially, M = 1.</p>
<p>On each player’s turn, that player can take all the stones in the first X remaining piles, where 1 &lt;= X &lt;= 2M.  Then, we set M = max(M, X).</p>
<p>The game continues until all the stones have been taken.</p>
<p>Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [2,7,9,4,4]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it&#x27;s larger.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [1,2,3,4,5,100]</span><br><span class="line">Output: 104</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= piles.length &lt;= 100</li>
<li>1 &lt;= piles[i] &lt;= 104</li>
</ul>
<p>这道题是石头游戏系列的第二道，跟之前那道 Stone Game 不同的是终于换回了 Alice 和 Bob！还有就是取石子的方法，不再是只能取首尾两端的石子堆，而是可以取 [1, 2M] 范围内的任意X堆，M是个变化的量，初始化为1，每次取完X堆后，更新为 M = max(M, X)。这种取石子的方法比之前的要复杂很多，由于X的值非常的多，而且其不同的选择还可能影响到M值，那么整体的情况就特别的多，暴力搜索基本上是行不通的。这种不同状态之间转移的问题用动态规划 Dynamic Programming 是比较合适的，首先来考虑 DP 数组的定义，题目要求的是 Alice 最多能拿到的石子个数，拿石子的方式是按顺序的，不能跳着拿，所以决定某个状态的是两个变量，一个是当前还剩多少石子堆，可以通过当前位置坐标i来表示，另一个是当前的m值，只有知道了当前的m值，那么选手才知道能拿的堆数的范围，所以 DP 就是个二维数组，其 dp[i][m] 表示的意义在上面已经解释了。接下来考虑状态转移方程，由于在某个状态时已经知道了m值，则当前选手能拿的堆数在范围 [1, 2m] 之间，为了更新这个 dp 值，所有x的情况都要遍历一遍，即在剩余堆数中拿x堆，但此时x堆必须小于等于剩余的堆数，即 i + x &lt;= n，i为当前的位置。由于每个选手都是默认选最优解的，若能知道下一个选手该拿的最大石子个数，就能知道当前选手能拿的最大石子个数了，因为二者之和为当前剩余的石子个数。由于当前选手拿了x堆，则下个选手的位置是 i+x，且m更新为 max(m,x)，所以其 dp 值为 dp[i + x][max(m, x)])。为了快速得知当前剩余的石子总数，需要建立累加和数组，注意这里是建立反向的累加和数组，其中 sums[i] 表示范围 [i, n-1] 之和。分析到这里就可以写出状态状态转移方程如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][m] = max(dp[i][m], sums[i] - dp[i + x][max(m, x)])</span><br></pre></td></tr></table></figure><br>接下来就是一些初始化和边界定义的问题需要注意的了，dp 数组大小为 n+1 by n+1，因为选手是可能一次将n堆都拿了，比如 n=1 时，所以 dp[i][n] 是存在的，且需要用 sums[i] 来初始化。更新 dp 时需要用三个 for 循环，分别控制i，m，和 x，注意更新从后往前遍历i和m，因为我们要先更新小区间，再更新大区间。x的范围要设定为 x &lt;= 2 * m &amp;&amp; i + x &lt;= n，前面也讲过原因了，最后的答案保存在 dp[0][1] 中返回即可，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">stoneGameII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = piles.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; sums = piles;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            sums[i] += sums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][n] = sums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m = n - <span class="number">1</span>; m &gt;= <span class="number">1</span>; --m) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">2</span> * m &amp;&amp; i + x &lt;= n; ++x) &#123;</span><br><span class="line">                    dp[i][m] = <span class="built_in">max</span>(dp[i][m], sums[i] - dp[i + x][<span class="built_in">max</span>(m, x)]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>我们再来用递归加记忆数组的方式来实现一下，其实核心思想跟上面完全一样，这里就不过多的讲解了，直接看代码吧：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">stoneGameII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = piles.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; sums = piles;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">memo</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            sums[i] += sums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(sums, <span class="number">0</span>, <span class="number">1</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; sums, <span class="type">int</span> i, <span class="type">int</span> m, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">2</span> * m &gt;= sums.<span class="built_in">size</span>()) <span class="keyword">return</span> sums[i];</span><br><span class="line">        <span class="keyword">if</span> (memo[i][m] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[i][m];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= <span class="number">2</span> * m; ++x) &#123;</span><br><span class="line">            <span class="type">int</span> cur = sums[i] - sums[i + x];</span><br><span class="line">            res = <span class="built_in">max</span>(res, cur + sums[i + x] - <span class="built_in">helper</span>(sums, i + x, <span class="built_in">max</span>(x, m), memo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][m] = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1143-Longest-Common-Subsequence"><a href="#Leetcode1143-Longest-Common-Subsequence" class="headerlink" title="Leetcode1143. Longest Common Subsequence"></a>Leetcode1143. Longest Common Subsequence</h1><p>Given two strings text1 and text2, return the length of their longest common subsequence.</p>
<p>A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A common subsequence of two strings is a subsequence that is common to both strings.</p>
<p>If there is no common subsequence, return 0.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;ace&quot; and its length is 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest common subsequence is &quot;abc&quot; and its length is 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no such common subsequence, so the result is 0.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= text1.length &lt;= 1000</li>
<li>1 &lt;= text2.length &lt;= 1000</li>
<li>The input strings consist of lowercase English characters only.</li>
</ul>
<p>这道题让求最长相同的子序列。使用一个二维数组 dp，其中<code>dp[i][j]</code>表示<code>text1</code>的前i个字符和<code>text2</code>的前j个字符的最长相同的子序列的字符个数，这里大小初始化为<code>(m+1)x(n+1)</code>，这里的m和n分别是<code>text1</code>和<code>text2</code>的长度。接下来就要找状态转移方程了，如何来更新<code>dp[i][j]</code>，若二者对应位置的字符相同，表示当前的LCS又增加了一位，所以可以用<code>dp[i-1][j-1] + 1</code>来更新<code>dp[i][j]</code>。否则若对应位置的字符不相同，由于是子序列，还可以错位比较，可以分别从<code>text1</code>或者<code>text2</code>去掉一个当前字符，那么其dp值就是<code>dp[i-1][j]</code>和<code>dp[i][j-1]</code>，取二者中的较大值来更新<code>dp[i][j]</code>即可，最终的结果保存在了<code>dp[m][n]</code>中，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = word1.<span class="built_in">length</span>(), n = word2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) </span><br><span class="line">                <span class="keyword">if</span> (word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1144-Decrease-Elements-To-Make-Array-Zigzag"><a href="#Leetcode1144-Decrease-Elements-To-Make-Array-Zigzag" class="headerlink" title="Leetcode1144. Decrease Elements To Make Array Zigzag"></a>Leetcode1144. Decrease Elements To Make Array Zigzag</h1><p>Given an array nums of integers, a move consists of choosing any element and decreasing it by 1.</p>
<p>An array A is a zigzag array if either:</p>
<p>Every even-indexed element is greater than adjacent elements, ie. A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; …<br>OR, every odd-indexed element is greater than adjacent elements, ie. A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; …<br>Return the minimum number of moves to transform the given array nums into a zigzag array.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We can decrease 2 to 0 or 3 to 1.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [9,6,1,6,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= nums.length &lt;= 1000</li>
<li>1 &lt;= nums[i] &lt;= 1000</li>
</ul>
<p>这道题说是每次可以给数组中的任意数字减小1，现在想将数组变为之字形，就是数字大和小交替出现，有两种，一种是偶数坐标的数字均大于其相邻两个位置的数字，一种是奇数坐标的数字均大于其相邻的两个位置的数字。对于第一种情况来说，其奇数坐标位置的数字就均小于其相邻两个位置的数字，同理，对于第二种情况，其偶数坐标位置的数字就均小于其相邻两个位置的数字。这里我们可以分两种情况来统计减少次数，一种是减小所有奇数坐标上的数字，另一种是减小所有偶数坐标上的数字。减小的方法是找到相邻的两个数字中的较小那个，然后比其小1即可，即可用 nums[i] - min(left, right) + 1 来得到，若得到了个负数，说明当前数字已经比左右的数字小了，不需要再减小了，所以需要跟0比较，取较大值。这里用了一个大小为2的 res 数组，这用直接根据当前坐标i，通过 i%2 就可以更新对应的次数了，最终取二者中的较小值返回即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">movesToMakeZigzag</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), res[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> left = i &gt; <span class="number">0</span> ? nums[i - <span class="number">1</span>] : <span class="number">1001</span>;</span><br><span class="line">            <span class="type">int</span> right = i &lt; n - <span class="number">1</span> ? nums[i + <span class="number">1</span>] : <span class="number">1001</span>;</span><br><span class="line">            res[i % <span class="number">2</span>] += <span class="built_in">max</span>(<span class="number">0</span>, nums[i] - <span class="built_in">min</span>(left, right) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1146-Snapshot-Array"><a href="#Leetcode1146-Snapshot-Array" class="headerlink" title="Leetcode1146. Snapshot Array"></a>Leetcode1146. Snapshot Array</h1><p>Implement a SnapshotArray that supports the following interface:</p>
<p>SnapshotArray(int length) initializes an array-like data structure with the given length.  Initially, each element equals 0.</p>
<ul>
<li><code>void set(index, val)</code> sets the element at the given index to be equal to val.</li>
<li><code>int snap()</code> takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1.</li>
<li><code>int get(index, snap_id)</code> returns the value at the given index, at the time we took the snapshot with the given snap_id</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;SnapshotArray&quot;,&quot;set&quot;,&quot;snap&quot;,&quot;set&quot;,&quot;get&quot;]</span><br><span class="line">[[3],[0,5],[],[0,6],[0,0]]</span><br><span class="line">Output: [null,null,0,null,5]</span><br><span class="line">Explanation:</span><br><span class="line">SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3</span><br><span class="line">snapshotArr.set(0,5);  // Set array[0] = 5</span><br><span class="line">snapshotArr.snap();  // Take a snapshot, return snap_id = 0</span><br><span class="line">snapshotArr.set(0,6);</span><br><span class="line">snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= length &lt;= 50000</li>
<li>At most 50000 calls will be made to set, snap, and get.</li>
<li>0 &lt;= index &lt; length</li>
<li>0 &lt;= snap_id &lt; (the total number of times we call snap())</li>
<li>0 &lt;= val &lt;= 10^9</li>
</ul>
<p>这道题让实现一个 SnapshotArray 的类，具有给数组拍照的功能，就是说在某个时间点<code>spapId</code>拍照后，当前数组的值需要都记录下来，同理，每一次调用<code>snap()</code>函数时，都需要记录整个数组的状态，这是为了之后可以查询任意一个时间点上的任意一个位置上的值。最简单粗暴的方法当前就是用一个二维数组，每次拍照的时候，都把整个数组都存到二维数组中，其坐标就是<code>snapId</code>。但是这种方法不高效，而且占用了巨大的空间，被 OJ 豪不留情的抹杀掉了。来分析一下不高效的原因，这是因为每次拍照时，可能数组的大部分数据并没有变动，每次都再存一遍整个数组是浪费的。这里我们关心的是调用<code>set()</code>函数，因为这会改变数组的值，若能建立<code>snapId</code>和更新值之间的映射，就可以根据二分法来快速定位某一个<code>snapId</code>的值了，因为<code>snapId</code>是按顺序递增的。这样就可以用一个Vector of Map 或者 Map of Map 的数据结构来实现，外层的 TreeMap 是映射建立数组坐标到内层 TreeMap 之间的映射，内层的 TreeMap 是建立 snapId 和更新值之间的映射。初始化时，要将 0-&gt;0 这个映射对儿加到每一个位置，因为初始化时数组的每个元素都是0。在<code>set()</code>函数中就可以更新<code>HashMap</code>中的映射值，<code>snap()</code>就直接累加<code>snapId</code>，比较麻烦的就是<code>get()</code>函数，给定的<code>snapId</code>可能在内层的<code>HashMap</code>中不存在，需要查找第一个不大于给定<code>snapId</code>的映射值，那么就先找第一个大于<code>snapId</code>的位置，再回退一位就好了，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SnapshotArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SnapshotArray</span>(<span class="type">int</span> length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            snapMap[i] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        snapMap[index][snapId] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">snap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> snapId++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> snap_id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = snapMap[index].<span class="built_in">upper_bound</span>(snap_id);</span><br><span class="line">        --it;</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> snapId = <span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>, map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; snapMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1147-Longest-Chunked-Palindrome-Decomposition"><a href="#Leetcode1147-Longest-Chunked-Palindrome-Decomposition" class="headerlink" title="Leetcode1147. Longest Chunked Palindrome Decomposition"></a>Leetcode1147. Longest Chunked Palindrome Decomposition</h1><p>You are given a string text. You should split it to k substrings (subtext1, subtext2, …, subtextk) such that:</p>
<ul>
<li>subtexti is a non-empty string.</li>
<li>The concatenation of all the substrings is equal to text (i.e., subtext1 + subtext2 + … + subtextk == text).</li>
<li>subtexti == subtextk - i + 1 for all valid values of i (i.e., 1 &lt;= i &lt;= k).</li>
</ul>
<p>Return the largest possible value of k.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;ghiabcdefhelloadamhelloabcdefghi&quot;</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: We can split the string on &quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;merchant&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: We can split the string on &quot;(merchant)&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;antaprezatepzapreanta&quot;</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: We can split the string on &quot;(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;aaa&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can split the string on &quot;(a)(a)(a)&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= text.length &lt;= 1000</li>
<li>text consists only of lowercase English characters.</li>
</ul>
<p>这道题是关于段式回文的，想必大家对回文串都不陌生，就是前后字符对应相同的字符串，比如 noon 和 bob。这里的段式回文相等的不一定是单一的字符，而是可以是字串，参见题目中的例子，现在给了一个字符串，问可以得到的段式回文串的最大长度是多少。由于段式回文的特点，你可以把整个字符串都当作一个子串，则可以得到一个长度为1的段式回文，所以答案至少是1，不会为0。而最好情况就是按字符分别相等，那就变成了一般的回文串，则长度就是原字符串的长度。比较的方法还是按照经典的验证回文串的方式，用双指针来做，一前一后。不同的是遇到不相等的字符不是立马退出，而是累加两个子串 left 和 right，每累加一个字符，都比较一下 left 和 right 是否相等，这样可以保证尽可能多的分出来相等的子串，一旦分出了相等的子串，则 left 和 right 重置为空串，再次从小到大比较，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestDecomposition</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = text.<span class="built_in">size</span>();</span><br><span class="line">        string left, right;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            left += text[i], right = text[n - i - <span class="number">1</span>] + right;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                left = right = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以使用递归来做，写法更加简洁一些，i从1遍历到 n/2，代表的是子串的长度，一旦超过一半了，说明无法分为两个了，最终做个判断即可。为了不每次都提取出子串直接进行比较，这里可以先做个快速的检测，即判断两个子串的首尾字符是否对应相等，只有相等了才会提取整个子串进行比较，这样可以省掉一些不必要的计算，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_equal</span><span class="params">(string text, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">            <span class="keyword">if</span> (text[x+i] != text[y+i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestDecomposition</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = text.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n/<span class="number">2</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">is_equal</span>(text, <span class="number">0</span>, n-i, i))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span> + <span class="built_in">longestDecomposition</span>(text.<span class="built_in">substr</span>(i, n-i*<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1154-Day-of-the-Year"><a href="#Leetcode1154-Day-of-the-Year" class="headerlink" title="Leetcode1154. Day of the Year"></a>Leetcode1154. Day of the Year</h1><p>Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: date = &quot;2019-01-09&quot;</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: Given date is the 9th day of the year in 2019.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: date = &quot;2019-02-10&quot;</span><br><span class="line">Output: 41</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: date = &quot;2003-03-01&quot;</span><br><span class="line">Output: 60</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: date = &quot;2004-03-01&quot;</span><br><span class="line">Output: 61</span><br></pre></td></tr></table></figure></p>
<p>判断一个日期是一年中的第几天。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dayOfYear</span><span class="params">(string date)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> days[] = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">        <span class="type">int</span> year = <span class="built_in">stoi</span>(date.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">        <span class="type">int</span> month = <span class="built_in">stoi</span>(date.<span class="built_in">substr</span>(<span class="number">5</span>,<span class="number">7</span>));</span><br><span class="line">        <span class="type">int</span> day = <span class="built_in">stoi</span>(date.<span class="built_in">substr</span>(<span class="number">8</span>, <span class="number">10</span>));</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; month; i ++)</span><br><span class="line">            ans += days[i];</span><br><span class="line">        ans += day;</span><br><span class="line">        <span class="keyword">if</span>((year%<span class="number">100</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">400</span> == <span class="number">0</span>) || (year%<span class="number">100</span> != <span class="number">0</span> &amp;&amp; year%<span class="number">4</span> == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">if</span>(month &gt; <span class="number">2</span>)</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1156-Swap-For-Longest-Repeated-Character-Substring"><a href="#Leetcode1156-Swap-For-Longest-Repeated-Character-Substring" class="headerlink" title="Leetcode1156. Swap For Longest Repeated Character Substring"></a>Leetcode1156. Swap For Longest Repeated Character Substring</h1><p>You are given a string text. You can swap two of the characters in the text.</p>
<p>Return the length of the longest substring with repeated characters.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;ababa&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can swap the first &#x27;b&#x27; with the last &#x27;a&#x27;, or the last &#x27;b&#x27; with the first &#x27;a&#x27;. Then, the longest repeated character substring is &quot;aaa&quot; with length 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;aaabaaa&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Swap &#x27;b&#x27; with the last &#x27;a&#x27; (or the first &#x27;a&#x27;), and we get longest repeated character substring &quot;aaaaaa&quot; with length 6.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;aaaaa&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: No need to swap, longest repeated character substring is &quot;aaaaa&quot; with length is 5.</span><br></pre></td></tr></table></figure></p>
<p>核心是如下几种情况</p>
<ul>
<li>仅有一段连续的字符</li>
<li>两段及以上的连续的字符，它们之间仅有有一个不符合，可以连接在一起</li>
<li>两段及以上的连续的字符，但是中间超过1个，按照要求，没办法连接</li>
</ul>
<p>思路</p>
<ul>
<li>遍历一次字符串，构建不同的连续字符串的起点到终点的数组</li>
<li>按照每个字符去遍历，考虑上面3种情况，同时需要额外考虑</li>
<li>对于情况2，如果有多一个同样的字符，交换后就是a+b+1,额外一个字符交换过来</li>
<li>对于情况3，额外交换一个，即a+1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxRepOpt1</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt; <span class="built_in">mapp</span>(<span class="number">26</span>, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;());;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, n = text.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; text[i] == text[j])</span><br><span class="line">                j ++;</span><br><span class="line">            mapp[text[i]-<span class="string">&#x27;a&#x27;</span>].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i, j<span class="number">-1</span>));</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapp[i].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> len = mapp[i].<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">bool</span> has_equal = len &gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j ++) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, mapp[i][j].second - mapp[i][j].first + <span class="number">1</span> + has_equal);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (len &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                has_equal = len &gt; <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len<span class="number">-1</span>; j ++) </span><br><span class="line">                    <span class="keyword">if</span> (mapp[i][j+<span class="number">1</span>].first - mapp[i][j].second == <span class="number">2</span>)</span><br><span class="line">                        res = <span class="built_in">max</span>(res, mapp[i][j].second-mapp[i][j].first+<span class="number">1</span> + mapp[i][j+<span class="number">1</span>].second-mapp[i][j+<span class="number">1</span>].first+<span class="number">1</span> + has_equal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1155-Number-of-Dice-Rolls-With-Target-Sum"><a href="#Leetcode1155-Number-of-Dice-Rolls-With-Target-Sum" class="headerlink" title="Leetcode1155. Number of Dice Rolls With Target Sum"></a>Leetcode1155. Number of Dice Rolls With Target Sum</h1><p>You have d dice and each die has f faces numbered 1, 2, …, f.</p>
<p>Return the number of possible ways (out of fd total ways) modulo 109 + 7 to roll the dice so the sum of the face-up numbers equals target.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: d = 1, f = 6, target = 3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">You throw one die with 6 faces.  There is only one way to get a sum of 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: d = 2, f = 6, target = 7</span><br><span class="line">Output: 6</span><br><span class="line">Explanation:</span><br><span class="line">You throw two dice, each with 6 faces.  There are 6 ways to get a sum of 7:</span><br><span class="line">1+6, 2+5, 3+4, 4+3, 5+2, 6+1.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: d = 2, f = 5, target = 10</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">You throw two dice, each with 5 faces.  There is only one way to get a sum of 10: 5+5.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: d = 1, f = 2, target = 3</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">You throw one die with 2 faces.  There is no way to get a sum of 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: d = 30, f = 30, target = 500</span><br><span class="line">Output: 222616187</span><br><span class="line">Explanation:</span><br><span class="line">The answer must be returned modulo 10^9 + 7.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= d, f &lt;= 30</li>
<li>1 &lt;= target &lt;= 1000</li>
</ul>
<p>这道题题说是给了d个骰子，每个骰子有f个面，现在给了一个目标值 target，问同时投出这d个骰子，共有多少种组成目标值的不同组合，结果对超大数字 1e9+7 取余。首先来考虑 dp 数组该如何定义，根据硬币找零系列的启发，目标值本身肯定是占一个维度的，因为这个是要求的东西，另外就是当前骰子的个数也是要考虑的因素，所以这里使用一个二维的 dp 数组，其中<code>dp[i][j]</code>表示使用i个骰子组成目标值为j的所有组合个数，大小为<code>d+1 by target+1</code>，并初始化<code>dp[0][0]</code>为1。接下来就是找状态转移方程了，当前某个状态<code>dp[i][k]</code>跟什么相关呢，其表示为使用i个骰子组成目标值k，那么拿最后一个骰子的情况分析，其可能会投出<code>[1,f]</code>中的任意一个数字j，那么之前的目标值就是<code>k-j</code>，且用了<code>i-1</code>个骰子，其<code>dp</code>值就是<code>dp[i-1][k-j]</code>，当前投出的点数可以跟之前所有的情况组成一种新的组合，所以当前的<code>dp[i][k]</code>就要加上<code>dp[i-1][k-j]</code>，那么状态转移方程就呼之欲出了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][k] = (dp[i][k] + dp[i - 1][k - j]) % M;</span><br></pre></td></tr></table></figure><br>其中i的范围是 [1, d]，j的范围是 [1, f]，k的范围是 [j, target]，总共三个 for 循环嵌套在一起，最终返回 dp[d][target] 即可，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> f, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(d + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(target + <span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= d; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= f; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt;= target; ++k) &#123;</span><br><span class="line">                    dp[i][k] = (dp[i][k] + dp[i - <span class="number">1</span>][k - j]) % M;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[d][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们可以进行空间上的优化，由于当前使用i个骰子的状态值依赖于使用 i-1 个骰子的状态，所以没必要保存所有的骰子个数的 dp 值，可以在遍历i的时候，新建一个临时的数组t，来保存使用i个骰子的 dp 值，并在最后交换 dp 和 t 即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> f, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= d; ++i) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">t</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= f; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt;= target; ++k) &#123;</span><br><span class="line">                    t[k] = (t[k] + dp[k - j]) % M;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(dp, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1160-Find-Words-That-Can-Be-Formed-by-Characters"><a href="#Leetcode1160-Find-Words-That-Can-Be-Formed-by-Characters" class="headerlink" title="Leetcode1160. Find Words That Can Be Formed by Characters"></a>Leetcode1160. Find Words That Can Be Formed by Characters</h1><p>You are given an array of strings words and a string chars.</p>
<p>A string is good if it can be formed by characters from chars (each character can only be used once).</p>
<p>Return the sum of lengths of all good strings in words.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: </span><br><span class="line">The strings that can be formed are &quot;cat&quot; and &quot;hat&quot; so the answer is 3 + 3 = 6.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: </span><br><span class="line">The strings that can be formed are &quot;hello&quot; and &quot;world&quot; so the answer is 5 + 5 = 10.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= words.length &lt;= 1000</li>
<li>1 &lt;= words[i].length, chars.length &lt;= 100</li>
<li>All strings contain lowercase English letters only.</li>
</ul>
<p>一道简单题卡了这么久，我真的是太弱鸡了，不过它卡时间很扯淡。。。chars中每个字符出现的次数要大于等于word中每个字符出现的次数，即表示可以组成这个word。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countCharacters</span><span class="params">(vector&lt;string&gt;&amp; words, string chars)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> char_len[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            char_len[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;chars.<span class="built_in">length</span>();i++)</span><br><span class="line">            char_len[chars[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> word_len[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)</span><br><span class="line">                word_len[j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;words[i].<span class="built_in">length</span>();j++)</span><br><span class="line">                <span class="keyword">if</span>(++word_len[words[i][j]-<span class="string">&#x27;a&#x27;</span>] &gt; char_len[words[i][j]-<span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) </span><br><span class="line">                res += words[i].<span class="built_in">length</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1161-Maximum-Level-Sum-of-a-Binary-Tree"><a href="#Leetcode1161-Maximum-Level-Sum-of-a-Binary-Tree" class="headerlink" title="Leetcode1161. Maximum Level Sum of a Binary Tree"></a>Leetcode1161. Maximum Level Sum of a Binary Tree</h1><p>Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.</p>
<p>Return the smallest level X such that the sum of all the values of nodes at level X is maximal.</p>
<p>Example 1:<br><img src="/img/20190824001.jpg" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,7,0,7,-8,null,null]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">Level 1 sum = 1.</span><br><span class="line">Level 2 sum = 7 + 0 = 7.</span><br><span class="line">Level 3 sum = 7 + -8 = -1.</span><br><span class="line">So we return the level with the maximum sum which is level 2.</span><br></pre></td></tr></table></figure>
<p>很简单的层次遍历，就当熟悉一下queue的用法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxLevelSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> maxx = <span class="number">-99999</span>;</span><br><span class="line">        <span class="type">int</span> layer = <span class="number">0</span>, max_layer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            layer++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)&#123;</span><br><span class="line"> 	            TreeNode* temp = q.<span class="built_in">front</span>();</span><br><span class="line">		        q.<span class="built_in">pop</span>();</span><br><span class="line">		        <span class="keyword">if</span>(temp-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">		            q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">			    <span class="keyword">if</span>(temp-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">		            q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">			    sum += temp-&gt;val;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(sum &gt; maxx)&#123;</span><br><span class="line">			    maxx = sum;</span><br><span class="line">			    max_layer = layer;</span><br><span class="line">			&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> max_layer;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1162-As-Far-from-Land-as-Possible"><a href="#Leetcode1162-As-Far-from-Land-as-Possible" class="headerlink" title="Leetcode1162. As Far from Land as Possible"></a>Leetcode1162. As Far from Land as Possible</h1><p>Given an n x n grid containing only values 0 and 1, where 0 represents water and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance. If no land or water exists in the grid, return -1.</p>
<p>The distance used in this problem is the Manhattan distance: the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1|.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,0,1],[0,0,0],[1,0,1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The cell (1, 1) is as far as possible from all the land with distance 2.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,0,0],[0,0,0],[0,0,0]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The cell (2, 2) is as far as possible from all the land with distance 4.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>n == grid.length</li>
<li>n == grid[i].length</li>
<li>1 &lt;= n &lt;= 100</li>
<li>grid[i][j] is 0 or 1</li>
</ul>
<p>这道题给了一个只有0和1的二维数组，说是0表示水，1表示陆地，现在让找出一个0的位置，使得其离最近的1的距离最大，这里的距离用曼哈顿距离表示。这里最暴力的方法就是遍历每个0的位置，对于每个遍历到的0，再遍历每个1的位置，计算它们的距离，找到最小的距离保存为该0位置的距离，然后在所有0位置的距离中找出最大的。这种方法不是很高效，目测无法通过 OJ，博主都没有尝试。其实这道题的比较好的解法是建立距离场，即每个大于1的数字表示该位置到任意一个1位置的最短距离，在之前那道 Shortest Distance from All Buildings 就用过这种方法。建立距离场用 BFS 比较方便，因为其是一层一层往外扩散的遍历，这里需要注意的是要一次把所有1的位置都加入 queue 中一起遍历，而不是对每个1都进行 BFS，否则还是过不了 OJ。这里先把位置1都加入 queue，然后这里先做个剪枝，若位置1的个数为0，或者为 n^2，表示没有陆地，或者没有水，直接返回 -1。否则进行 while 循环，步数 step 加1，然后用 for 循环确保进行层序遍历，一定要将 q.size() 放到初始化中，因为其值可能改变。然后就是标准的 BFS 写法了，取队首元素，遍历其相邻四个结点，若没有越界且值为0，则将当前位置值更新为 step，然后将这个位置加入 queue 中继续遍历。循环退出后返回 step-1 即可，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> step = <span class="number">0</span>, n = grid.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        queue&lt;vector&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(vector&lt;<span class="type">int</span>&gt;&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() == <span class="number">0</span> || q.<span class="built_in">size</span>() == n * n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++step;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = q.<span class="built_in">size</span>(); k &gt; <span class="number">0</span>; --k) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">                    <span class="type">int</span> x = t[<span class="number">0</span>] + dir[<span class="number">0</span>], y = t[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    grid[x][y] = step;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以强行用 DFS 来做，这里对于每一个值为1的点都调用递归函数，更新跟其相连的所有0位置的距离，最终也能算出整个距离场，从而查找出最大的距离，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>, n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">helper</span>(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] &gt; <span class="number">1</span>) res = <span class="built_in">max</span>(res, grid[i][j] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> dist = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= n || j &gt;= n || (grid[i][j] != <span class="number">0</span> &amp;&amp; grid[i][j] &lt;= dist)) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = dist;</span><br><span class="line">        <span class="built_in">helper</span>(grid, i - <span class="number">1</span>, j, dist + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">helper</span>(grid, i + <span class="number">1</span>, j, dist + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">helper</span>(grid, i, j - <span class="number">1</span>, dist + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">helper</span>(grid, i, j + <span class="number">1</span>, dist + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其实这道题的最优解法并不是 BFS 或者 DFS，而是下面这种两次扫描的方法，在之前那道 01 Matrix 中就使用过。有点像动态规划的感觉，还是建立距离场，先从左上遍历到右下，遇到1的位置跳过，然后初始化0位置的值为 201（因为n不超过 100，所以距离不会超过 200），然后用左边和上边的值加1来更新当前位置的，注意避免越界。然后从右边再遍历到左上，还是遇到1的位置跳过，然后用右边和下边的值加1来更新当前位置的，注意避免越界，同时还要更新结果 res 的值。最终若 res 为 201，则返回 -1，否则返回 res-1，参见代码如下：</p>
<p>解法三：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                grid[i][j] = <span class="number">201</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) grid[i][j] = <span class="built_in">min</span>(grid[i][j], grid[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) grid[i][j] = <span class="built_in">min</span>(grid[i][j], grid[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) grid[i][j] = <span class="built_in">min</span>(grid[i][j], grid[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (j &lt; n - <span class="number">1</span>) grid[i][j] = <span class="built_in">min</span>(grid[i][j], grid[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                res = <span class="built_in">max</span>(res, grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == <span class="number">201</span> ? <span class="number">-1</span> : res - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1165-Single-Row-Keyboard"><a href="#Leetcode1165-Single-Row-Keyboard" class="headerlink" title="Leetcode1165. Single-Row Keyboard"></a>Leetcode1165. Single-Row Keyboard</h1><p>There is a special keyboard with all keys in a single row.</p>
<p>Given a string keyboard of length 26 indicating the layout of the keyboard (indexed from 0 to 25), initially your finger is at index 0. To type a character, you have to move your finger to the index of the desired character. The time taken to move your finger from index i to index j is |i - j|.</p>
<p>You want to type a string word. Write a function to calculate how much time it takes to type it with one finger.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: keyboard = &quot;abcdefghijklmnopqrstuvwxyz&quot;, word = &quot;cba&quot;</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The index moves from 0 to 2 to write &#x27;c&#x27; then to 1 to write &#x27;b&#x27; then to 0 again to write &#x27;a&#x27;.</span><br><span class="line">Total time = 2 + 1 + 1 = 4. </span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: keyboard = &quot;pqrstuvwxyzabcdefghijklmno&quot;, word = &quot;leetcode&quot;</span><br><span class="line">Output: 73</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>keyboard.length == 26</li>
<li>keyboard contains each English lowercase letter exactly once in some order.</li>
<li>1 &lt;= word.length &lt;= 10^4</li>
<li>word[i] is an English lowercase letter.</li>
</ul>
<p>简单打表即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateTime</span><span class="params">(string keyboard, string word)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(<span class="number">26</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;keyboard.<span class="built_in">length</span>();i++)</span><br><span class="line">            pos[keyboard[i]-<span class="string">&#x27;a&#x27;</span>] = k++;</span><br><span class="line">        <span class="type">int</span> res=pos[word[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;word.<span class="built_in">length</span>();i++)</span><br><span class="line">            res += <span class="built_in">abs</span>(pos[word[i]-<span class="string">&#x27;a&#x27;</span>]-pos[word[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1170-Compare-Strings-by-Frequency-of-the-Smallest-Character"><a href="#Leetcode1170-Compare-Strings-by-Frequency-of-the-Smallest-Character" class="headerlink" title="Leetcode1170. Compare Strings by Frequency of the Smallest Character"></a>Leetcode1170. Compare Strings by Frequency of the Smallest Character</h1><p>Let’s define a function f(s) over a non-empty string s, which calculates the frequency of the smallest character in s. For example, if s = “dcce” then f(s) = 2 because the smallest character is “c” and its frequency is 2.</p>
<p>Now, given string arrays queries and words, return an integer array answer, where each answer[i] is the number of words such that f(queries[i]) &lt; f(W), where W is a word in words.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: queries = [&quot;cbd&quot;], words = [&quot;zaaaz&quot;]</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: On the first query we have f(&quot;cbd&quot;) = 1, f(&quot;zaaaz&quot;) = 3 so f(&quot;cbd&quot;) &lt; f(&quot;zaaaz&quot;).</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: queries = [&quot;bbb&quot;,&quot;cc&quot;], words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: On the first query only f(&quot;bbb&quot;) &lt; f(&quot;aaaa&quot;). On the second query both f(&quot;aaa&quot;) and f(&quot;aaaa&quot;) are both &gt; f(&quot;cc&quot;).</span><br></pre></td></tr></table></figure><br>定义f(s)为一个字符串中最小的字符(按字母序abcd…xyz)出现的次数。对于每个query的f(query)，求出words中f(word) &gt; f(query)有多少个。</p>
<p>第一步，肯定要把每个query和word的f(s)求出来，求每个字符的次数，然后找出最小的字符出现的次数。<br>第二步，找出words中f(word) &gt; f(query)有多少个时，对于2000*2000的量级，可以暴力两重循环，即对每个query都去遍历一次words的f(word)结果。</p>
<p>时间复杂度O(N^2).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numSmallerByFrequency</span><span class="params">(vector&lt;string&gt;&amp; queries, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; qs, ws;</span><br><span class="line">        <span class="keyword">for</span>(string query : queries) </span><br><span class="line">            qs.<span class="built_in">push_back</span>(<span class="built_in">getfreq</span>(query));</span><br><span class="line">        <span class="keyword">for</span>(string word : words)</span><br><span class="line">            ws.<span class="built_in">push_back</span>(<span class="built_in">getfreq</span>(word));</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : qs) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : ws) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i)</span><br><span class="line">                    count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getfreq</span><span class="params">(string query)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : query)</span><br><span class="line">            q[c-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : q)</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1171-Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List"><a href="#Leetcode1171-Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List" class="headerlink" title="Leetcode1171. Remove Zero Sum Consecutive Nodes from Linked List"></a>Leetcode1171. Remove Zero Sum Consecutive Nodes from Linked List</h1><p>Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences.</p>
<p>After doing so, return the head of the final linked list.  You may return any such answer.</p>
<p>(Note that in the examples below, all sequences are serializations of ListNode objects.)</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2,-3,3,1]</span><br><span class="line">Output: [3,1]</span><br><span class="line">Note: The answer [1,2,1] would also be accepted.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2,3,-3,4]</span><br><span class="line">Output: [1,2,4]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [1,2,3,-3,-2]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure></p>
<p>对于两个前缀和相等部分，表示里面就是0，所以可以消除，在加入map的时候还能把之前的ListNode覆盖掉，达到消除的目标。消除时候就是把next指针指向和的下一个结点。在第二次遍历的时候发现了现在有的sum和表示当前的节点和后边某个节点的前缀和都是sum，中间的和就是0，可以消掉。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeZeroSumSublists</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次遍历构建 前缀和 到 结点的映射</span></span><br><span class="line">        <span class="comment">// 如果有多个，则保存最后一个，即右边界，尽可能覆盖更多</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, ListNode*&gt; sum2node;</span><br><span class="line">        <span class="comment">// 构建个虚结点来解决结点删除边缘情况</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        ListNode* curr = dummy;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += curr-&gt;val;</span><br><span class="line">            sum2node[sum] = curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr = dummy;</span><br><span class="line">        <span class="comment">// 第二次遍历去发现相等为0情况则忽略结点</span></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += curr-&gt;val;</span><br><span class="line">            <span class="comment">// 因为前面计算过没有sum，所以sum必然存在sum2node里</span></span><br><span class="line">            <span class="comment">// 如果正好出现，可能是正常的自己的结点</span></span><br><span class="line">            <span class="comment">// 如果就是下一个相同的结点，那么就是把这一段结点忽略掉</span></span><br><span class="line">            curr-&gt;next = sum2node[sum]-&gt;next;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1175-Prime-Arrangements"><a href="#Leetcode1175-Prime-Arrangements" class="headerlink" title="Leetcode1175. Prime Arrangements"></a>Leetcode1175. Prime Arrangements</h1><p>Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)</p>
<p>(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)</p>
<p>Since the answer may be large, return the answer modulo 10^9 + 7.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 5</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 100</span><br><span class="line">Output: 682289015</span><br></pre></td></tr></table></figure></p>
<p>题目的意思是计算一个由1到n组成的数列中，质数恰好位于质数索引上的排列组合个数，本质上是一个数学问题。结合n = 5的例子来看，1到5中，只有2,3,5是质数，1和4不是质数，因此排列质数就有3<em>2</em>1 = 6种可能，分别是:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2,3,5],[2,5,3],[3,2,5],[3,5,2],[5,2,3],[5,3,2]</span><br></pre></td></tr></table></figure><br>不是质数的1和4，只有两种可能，分别是<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,4],[4,1]</span><br></pre></td></tr></table></figure><br>因此，将质数和非质数组合起来，就是6*2 = 12种可能，分别是<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5],[1,2,5,4,3],[1,3,2,4,5],[1,3,5,4,2],[1,5,2,4,3],[1,5,3,4,2]</span><br><span class="line">[4,2,3,1,5],[4,2,5,1,3],[4,3,2,1,5],[4,3,5,1,2],[4,5,2,1,3],[4,5,3,1,2]</span><br></pre></td></tr></table></figure><br>因此，我们只需要计算出n中有多少个质数和非质数，再计算两者的阶乘即可，为了防止溢出，题目要求我们将计算结果对1000000007取余。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nn = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= nn; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numPrimeArrangements</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count1 = <span class="number">0</span>, count2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isprime</span>(i))</span><br><span class="line">                count1 ++;</span><br><span class="line">        &#125;</span><br><span class="line">        count2 = n - count1;</span><br><span class="line">        <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= count1; i ++)</span><br><span class="line">            res = (res*i)%(<span class="number">1000000007</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= count2; i ++)</span><br><span class="line">            res = (res*i)%(<span class="number">1000000007</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1177-Can-Make-Palindrome-from-Substring"><a href="#Leetcode1177-Can-Make-Palindrome-from-Substring" class="headerlink" title="Leetcode1177. Can Make Palindrome from Substring"></a>Leetcode1177. Can Make Palindrome from Substring</h1><p>Given a string s, we make queries on substrings of s.</p>
<p>For each query queries[i] = [left, right, k], we may rearrange the substring s[left], …, s[right], and then choose up to k of them to replace with any lowercase English letter.</p>
<p>If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false.</p>
<p>Return an array answer[], where answer[i] is the result of the i-th query queries[i].</p>
<p>Note that: Each letter is counted individually for replacement so if for example s[left..right] = “aaa”, and k = 2, we can only replace two of the letters.  (Also, note that the initial string s is never modified by any query.)</p>
<p>Example :<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;abcda&quot;, queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]</span><br><span class="line">Output: [true,false,false,true,true]</span><br><span class="line">Explanation:</span><br><span class="line">queries[0] : substring = &quot;d&quot;, is palidrome.</span><br><span class="line">queries[1] : substring = &quot;bc&quot;, is not palidrome.</span><br><span class="line">queries[2] : substring = &quot;abcd&quot;, is not palidrome after replacing only 1 character.</span><br><span class="line">queries[3] : substring = &quot;abcd&quot;, could be changed to &quot;abba&quot; which is palidrome. Also this can be changed to &quot;baab&quot; first rearrange it &quot;bacd&quot; then replace &quot;cd&quot; with &quot;ab&quot;.</span><br><span class="line">queries[4] : substring = &quot;abcda&quot;, could be changed to &quot;abcba&quot; which is palidrome.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= s.length, queries.length &lt;= 10^5</li>
<li>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; s.length</li>
<li>0 &lt;= queries[i][2] &lt;= s.length</li>
<li>s only contains lowercase English letters.</li>
</ul>
<p>这道题给了一个只有小写字母的字符串s，让对s对子串进行查询。查询块包含三个信息，left，right 和k，其中 left 和 right 定义了子串的范围，k表示可以进行替换字母的个数。这里希望通过替换可以将子串变为回文串。题目中还说了可以事先给子串进行排序，这个条件一加，整个性质就不一样了，若不能排序，那么要替换的字母可能就很多了，因为对应的位置上的字母要相同才行。而能排序之后，只要把相同的字母尽可能的排列到对应的位置上，就可以减少要替换的字母，比如 hunu，若不能重排列，则至少要替换两个字母才行，而能重排顺序的话，可以先变成 uhnu，再替换中间的任意一个字母就可以了。</p>
<p>需要替换的情况都是字母出现次数为奇数的情况，偶数的字母完全不用担心，所以只要统计出出现次数为奇数的字母的个数，其除以2就是要替换的次数。那可能有的童鞋会问了，万一是奇数怎么办，除以2除不尽怎么办，这是个好问题。若出现次数为奇数的字母的个数为奇数，则表明该子串的长度为奇数，而奇数回文串最中间的字母是不需要有对称位置的，所以自然可以少替换一个，所以除不尽的部分就自动舍去了，并不影响最终的结果。</p>
<p>这里是对每个子串都建立字母出现次数的映射，所以这里用一个二维数组，大小为 n+1 by 26，因为限定了只有小写字母。然后遍历字符串s进行更新，每次先将 cnt[i+1] 赋值为 cnt[i]，然后在对应的字母位置映射值自增1。累加好了之后，对于任意区间 [i, j] 的次数映射数组就可以通过 cnt[j+1] - cnt[i] 来表示，但数组之间不好直接做减法，可以再进一步访问每个字母来分别进行处理，快速得到每个字母的出现次数后除以2，将结果累加到 sum 中，就是出现奇数次字母的个数了，再除以2和k比较即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">canMakePaliQueries</span><span class="params">(string s, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt; res;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">cnt</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cnt[i + <span class="number">1</span>] = cnt[i];</span><br><span class="line">            ++cnt[i + <span class="number">1</span>][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;query : queries) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                sum += (cnt[query[<span class="number">1</span>] + <span class="number">1</span>][i] - cnt[query[<span class="number">0</span>]][i]) % <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(sum / <span class="number">2</span> &lt;= query[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1179-Reformat-Department-Table"><a href="#Leetcode1179-Reformat-Department-Table" class="headerlink" title="Leetcode1179. Reformat Department Table"></a>Leetcode1179. Reformat Department Table</h1><p>Table: Department<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| revenue       | int     |</span><br><span class="line">| month         | varchar |</span><br><span class="line">+---------------+---------+</span><br></pre></td></tr></table></figure><br>(id, month) is the primary key of this table.<br>The table has information about the revenue of each department per month.<br>The month has values in [“Jan”,”Feb”,”Mar”,”Apr”,”May”,”Jun”,”Jul”,”Aug”,”Sep”,”Oct”,”Nov”,”Dec”].</p>
<p>Write an SQL query to reformat the table such that there is a department id column and a revenue column for each month.</p>
<p>The query result format is in the following example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Department table:</span><br><span class="line">+------+---------+-------+</span><br><span class="line">| id   | revenue | month |</span><br><span class="line">+------+---------+-------+</span><br><span class="line">| 1    | 8000    | Jan   |</span><br><span class="line">| 2    | 9000    | Jan   |</span><br><span class="line">| 3    | 10000   | Feb   |</span><br><span class="line">| 1    | 7000    | Feb   |</span><br><span class="line">| 1    | 6000    | Mar   |</span><br><span class="line">+------+---------+-------+</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Result table:</span><br><span class="line">+------+-------------+-------------+-------------+-----+-------------+</span><br><span class="line">| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue |</span><br><span class="line">+------+-------------+-------------+-------------+-----+-------------+</span><br><span class="line">| 1    | 8000        | 7000        | 6000        | ... | null        |</span><br><span class="line">| 2    | 9000        | null        | null        | ... | null        |</span><br><span class="line">| 3    | null        | 10000       | null        | ... | null        |</span><br><span class="line">+------+-------------+-------------+-------------+-----+-------------+</span><br></pre></td></tr></table></figure><br>Note that the result table has 13 columns (1 for the department id + 12 for the months).</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"><span class="keyword">select</span> id, <span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span>&quot;Jan&quot; <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Jan_Revenue,    </span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> &quot;Feb&quot; <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Feb_Revenue,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> &quot;Mar&quot; <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Mar_Revenue,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> &quot;Apr&quot; <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Apr_Revenue,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> &quot;May&quot; <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> May_Revenue,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> &quot;Jun&quot; <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Jun_Revenue,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> &quot;Jul&quot; <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Jul_Revenue,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> &quot;Aug&quot; <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Aug_Revenue,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> &quot;Sep&quot; <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Sep_Revenue,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> &quot;Oct&quot; <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Oct_Revenue,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> &quot;Nov&quot; <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Nov_Revenue,</span><br><span class="line"><span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">=</span> &quot;Dec&quot; <span class="keyword">then</span> revenue <span class="keyword">else</span> <span class="keyword">null</span> <span class="keyword">end</span>) <span class="keyword">as</span> Dec_Revenue</span><br><span class="line"><span class="keyword">from</span> Department </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> id </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1184-Distance-Between-Bus-Stops"><a href="#Leetcode1184-Distance-Between-Bus-Stops" class="headerlink" title="Leetcode1184. Distance Between Bus Stops"></a>Leetcode1184. Distance Between Bus Stops</h1><p>A bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n.</p>
<p>The bus goes along both directions i.e. clockwise and counterclockwise.</p>
<p>Return the shortest distance between the given start and destination stops.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: distance = [1,2,3,4], start = 0, destination = 1</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.</span><br></pre></td></tr></table></figure><br><img src="/img/20200629102800.jpg" alt=""></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: distance = [1,2,3,4], start = 0, destination = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3.</span><br></pre></td></tr></table></figure><br><img src="/img/20200629102801.jpg" alt=""></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: distance = [1,2,3,4], start = 0, destination = 3</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4.</span><br></pre></td></tr></table></figure><br><img src="/img/20200629102802.jpg" alt=""></p>
<p>求环状图的最短路，求两个距离并求最小值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distanceBetweenBusStops</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; distance, <span class="type">int</span> start, <span class="type">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = distance.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dis1= <span class="number">0</span>, dis2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start1 = start;</span><br><span class="line">        <span class="keyword">while</span>(start1 != destination) &#123;</span><br><span class="line">            dis1 += distance[start1];</span><br><span class="line">            start1 = (start1 + <span class="number">1</span>) % n;</span><br><span class="line">        &#125;</span><br><span class="line">        start1 = start;</span><br><span class="line">        <span class="keyword">while</span>(start1 != destination) &#123;</span><br><span class="line">            start1 = (start1 - <span class="number">1</span> + n) % n;</span><br><span class="line">            dis2 += distance[start1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dis1, dis2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1185-Day-of-the-Week"><a href="#Leetcode1185-Day-of-the-Week" class="headerlink" title="Leetcode1185. Day of the Week"></a>Leetcode1185. Day of the Week</h1><p>Given a date, return the corresponding day of the week for that date.</p>
<p>The input is given as three integers representing the day, month and year respectively.</p>
<p>Return the answer as one of the following values {“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”}.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: day = 31, month = 8, year = 2019</span><br><span class="line">Output: &quot;Saturday&quot;</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: day = 18, month = 7, year = 1999</span><br><span class="line">Output: &quot;Sunday&quot;</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: day = 15, month = 8, year = 1993</span><br><span class="line">Output: &quot;Sunday&quot;</span><br></pre></td></tr></table></figure><br>判断一个日期是一个周的第几天。直接套公式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">dayOfTheWeek</span><span class="params">(<span class="type">int</span> day, <span class="type">int</span> month, <span class="type">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> t[] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        year -= month &lt; <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// Sakamoto&#x27;s Method: https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week#Sakamoto&#x27;s_methods</span></span><br><span class="line">        <span class="type">int</span> code =  (year + year/<span class="number">4</span> - year/<span class="number">100</span> + year/<span class="number">400</span> + t[month<span class="number">-1</span>] + day) % <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(code)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Sunday&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Monday&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Tuesday&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Wednesday&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Thursday&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Friday&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Saturday&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1186-Maximum-Subarray-Sum-with-One-Deletion-删除一次得到子数组最大和"><a href="#Leetcode1186-Maximum-Subarray-Sum-with-One-Deletion-删除一次得到子数组最大和" class="headerlink" title="Leetcode1186. Maximum Subarray Sum with One Deletion 删除一次得到子数组最大和"></a>Leetcode1186. Maximum Subarray Sum with One Deletion 删除一次得到子数组最大和</h1><p>Given an array of integers, return the maximum sum for a non-empty subarray (contiguous elements) with at most one element deletion. In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the sum of the remaining elements is maximum possible.</p>
<p>Note that the subarray needs to be non-empty after deleting one element.</p>
<p>Example 1:</p>
<p>Input: arr = [1,-2,0,3]<br>Output: 4<br>Explanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the subarray [1, 0, 3] becomes the maximum value.<br>Example 2:</p>
<p>Input: arr = [1,-2,-2,3]<br>Output: 3<br>Explanation: We just choose [3] and it’s the maximum sum.<br>Example 3:</p>
<p>Input: arr = [-1,-1,-1,-1]<br>Output: -1<br>Explanation: The final subarray needs to be non-empty. You can’t choose [-1] and delete -1 from it, then get an empty subarray to make the sum equals to 0.<br>Constraints:</p>
<p>1 &lt;= arr.length &lt;= 105<br>-104 &lt;= arr[i] &lt;= 104</p>
<p>这道题给了一个整型数组，让返回最大的非空子数组之和，应该算是之前那道 Maximum Subarray 的拓展，与之不同的是，这里允许有一次删除某个数字的机会。当然，删除数字操作是可用可不用的，用之的目的也是为了让子数组之和变的更大，所以基本上要删除的数字应该是个负数，毕竟负数才会让和变小。若整个数组都是正数，则完全没有必要删除了。所以这道题还是要像之前那道题的一样，肯定要求出不删除情况下的最大子数组之和。该算法的核心思路是一种动态规划 Dynamic Programming，对于每个位置i，要计算出以该位置为结束位置时的最大子数组的之和，且该位置上的数字一定会被使用。大多情况下，为了节省空间，都用一个变量来代替数组，因为不需要保存之前的状态。而这道题因为允许删除操作的存在，还是要记录每个位置的状态。为啥呢，若将i位置上的数字删除了，实际上原数组就被分为两个部分：<code>[0, i-1]</code>和<code>[i+1, n-1]</code>，由于是子数组，则<code>arr[i-1]</code>和<code>arr[i+1]</code>这两个数字一定要出现在子数组中，用个<code>maxEndHere[i]</code>表示在 [0, i] 范围内以<code>arr[i]</code>结尾的最大子数组之和，用<code>maxStartHere[i]</code>表示在<code>[i, n-1]</code>范围内以<code>arr[i]</code>为起始的最大子数组之和，那么移除数字i的最大子数组之和就是<code>maxEndHere[i-1] + maxStartHere[i+1]</code>了，分析到这里，代码就不难写了吧，注意别忘了统计不需要删除数字时的最大子数组之和，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = arr[<span class="number">0</span>], n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxEndHere</span><span class="params">(n)</span>, <span class="title">maxStartHere</span><span class="params">(n)</span></span>;</span><br><span class="line">        maxEndHere[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            maxEndHere[i] = <span class="built_in">max</span>(arr[i], maxEndHere[i - <span class="number">1</span>] + arr[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, maxEndHere[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        maxStartHere[n - <span class="number">1</span>] = arr[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxStartHere[i] = <span class="built_in">max</span>(arr[i], maxStartHere[i + <span class="number">1</span>] + arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, maxEndHere[i - <span class="number">1</span>] + maxStartHere[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1189-Maximum-Number-of-Balloons"><a href="#Leetcode1189-Maximum-Number-of-Balloons" class="headerlink" title="Leetcode1189. Maximum Number of Balloons"></a>Leetcode1189. Maximum Number of Balloons</h1><p>Given a string text, you want to use the characters of text to form as many instances of the word “balloon” as possible.</p>
<p>You can use each character in text at most once. Return the maximum number of instances that can be formed.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;nlaebolko&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;loonbalxballpoon&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;leetcode&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>判断一个字符串能组成多少个“balloon”，求出text中b,a,l,o,n这五个字符的出现次数的最小值即可。但有两点需要注意，一是text必须同时包含这五个字符，而是l和o是要算双份。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxNumberOfBalloons</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : text)</span><br><span class="line">            mp[c] ++;</span><br><span class="line">        <span class="type">int</span> aa[<span class="number">5</span>] = &#123;mp[<span class="string">&#x27;b&#x27;</span>], mp[<span class="string">&#x27;a&#x27;</span>], mp[<span class="string">&#x27;l&#x27;</span>]/<span class="number">2</span>, mp[<span class="string">&#x27;o&#x27;</span>]/<span class="number">2</span>, mp[<span class="string">&#x27;n&#x27;</span>]&#125;;</span><br><span class="line">        <span class="type">int</span> minn = <span class="number">99999</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)</span><br><span class="line">            minn = <span class="built_in">min</span>(minn, aa[i]);</span><br><span class="line">        <span class="keyword">return</span> minn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses"><a href="#Leetcode1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses" class="headerlink" title="Leetcode1190. Reverse Substrings Between Each Pair of Parentheses"></a>Leetcode1190. Reverse Substrings Between Each Pair of Parentheses</h1><p>You are given a string s that consists of lower case English letters and brackets.</p>
<p>Reverse the strings in each pair of matching parentheses, starting from the innermost one.</p>
<p>Your result should not contain any brackets.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;(abcd)&quot;</span><br><span class="line">Output: &quot;dcba&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;(u(love)i)&quot;</span><br><span class="line">Output: &quot;iloveu&quot;</span><br><span class="line">Explanation: The substring &quot;love&quot; is reversed first, then the whole string is reversed.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;(ed(et(oc))el)&quot;</span><br><span class="line">Output: &quot;leetcode&quot;</span><br><span class="line">Explanation: First, we reverse the substring &quot;oc&quot;, then &quot;etco&quot;, and finally, the whole string.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;a(bcdefghijkl(mno)p)q&quot;</span><br><span class="line">Output: &quot;apmnolkjihgfedcbq&quot;</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>0 &lt;= s.length &lt;= 2000</li>
<li>s only contains lower case English characters and parentheses.</li>
<li>It’s guaranteed that all parentheses are balanced.</li>
</ul>
<p>这道题给了一个只含有小写字母和括号的字符串s，现在让从最内层括号开始，每次都反转括号内的所有字符，然后可以去掉该内层括号，依次向外层类推，直到去掉所有的括号为止。可能有的童鞋拿到题后第一反应可能是递归到最内层，翻转，然后再一层一层的出来。这样的做的话就有点麻烦了，而且保不齐还有可能超时。比较好的做法就是直接遍历这个字符串，当遇到字母时，将其加入结果 res，当遇到左括号时，将当前 res 的长度加入一个数组 pos，当遇到右括号时，取出 pos 数组中的最后一个数字，并翻转 res 中该位置到结尾的所有字母，因为这个区间刚好就是当前最内层的字母，这样就能按顺序依次翻转所有括号中的内容，最终返回结果 res 即可，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> last = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+last+<span class="number">1</span>, s.<span class="built_in">begin</span>()+i);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27;(&#x27;</span> &amp;&amp; s[i] != <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                res += s[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这道题居然还有 O(n) 的解法。这种解法首先要建立每一对括号位置之间的映射，而且是双向映射，即左括号位置映射到右括号位置，同时右括号位置也要映射到左括号位置，这样在第一次遇到左括号时，就可以直接跳到对应的右括号，然后往前遍历，当下次遇到右括号时，就直接跳到其对应的左括号，然后往后遍历，这样实际相当于在嵌套了两层的括号中，是不用翻转的，因为只有奇数嵌套才需要翻转，用这种逻辑遍历，就可以串出最终正确的结果，由于遍历顺序不停在改变，所以用一个变量d来控制方向，初始化为1，当需要变换了就取相反数即可，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; pos, <span class="built_in">pair</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                pos.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> idx = pos.<span class="built_in">back</span>();</span><br><span class="line">                pos.<span class="built_in">pop_back</span>();</span><br><span class="line">                pair[i] = idx;</span><br><span class="line">                pair[idx] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, d = <span class="number">1</span>; i &lt; n; i += d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                i = pair[i];</span><br><span class="line">                d = -d;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1191-K-Concatenation-Maximum-Sum"><a href="#Leetcode1191-K-Concatenation-Maximum-Sum" class="headerlink" title="Leetcode1191. K-Concatenation Maximum Sum"></a>Leetcode1191. K-Concatenation Maximum Sum</h1><p>Given an integer array arr and an integer k, modify the array by repeating it k times.</p>
<p>For example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2].</p>
<p>Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0.</p>
<p>As the answer can be very large, return the answer modulo 109 + 7.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,2], k = 3</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,-2,1], k = 5</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [-1,-2], k = 7</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= arr.length &lt;= 10^5</li>
<li>1 &lt;= k &lt;= 10^5</li>
<li>-10^4 &lt;= arr[i] &lt;= 10^4</li>
</ul>
<p>这道题给了一个数组 arr 和一个正整数k，说是数组可以重复k次，让找出最大的子数组之和。例子1中数组全是正数，则最大和的子数组就是其本身，那么重复几次，就要都加上，就是原数组所有数字之和再乘以k。例子2中由于有负数存在，所以最大和只是某个子数组，这里就是单独的一个1，但是一旦可以重复了，那么首尾的1就可以连在一起，形成一个和为2的子数组了，但也不是连的越多越好，只有有首尾相连才可能使得正数相连，所以最多连2个就行了，因为这里整个数组之和为0，连再多跟没连一样。但如果把数组变为 [1,-2,2] 的话，那就不一样了，虽然说两个为 [1,-2,2,1,-2,2] 的最大子数组之和为3，但是由于原数组之和为1，只要尽可能多的连，就可以得到更大的值，所以这种情况也要考虑到。例子3中数组全是负数，则不管重复多少次，还是取空数组和为0。</p>
<p>根据k的大小，若等于1，则对原数组用 Kadane 算法，若大于1，则只拼接一个数组，那么这里就可以用 min(k, 2) 来合并这两种情况，不过在取数的时候，要用 arr[i % n] 来避免越界，这样就可以得到最大子数组之和了，不过这也还是针对 k 小于等于2的情况，对于 k 大于2的情况，还是要把减去2剩余的次数乘以整个数组之和的值加上，再一起比较，这样最终的结果就是三者之中的最大值了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kConcatenationMaxSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = INT_MIN, curSum = <span class="number">0</span>, n = arr.<span class="built_in">size</span>(), M = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">long</span> total = <span class="built_in">accumulate</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n * <span class="built_in">min</span>(k, <span class="number">2</span>); ++i) &#123;</span><br><span class="line">            curSum = <span class="built_in">max</span>(curSum + arr[i % n], arr[i % n]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, curSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>&lt;<span class="type">long</span>&gt;(&#123;<span class="number">0</span>, res, total * <span class="built_in">max</span>(<span class="number">0</span>, k - <span class="number">2</span>) + res&#125;) % M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1192-Critical-Connections-in-a-Network"><a href="#Leetcode1192-Critical-Connections-in-a-Network" class="headerlink" title="Leetcode1192. Critical Connections in a Network"></a>Leetcode1192. Critical Connections in a Network</h1><p>There are n servers numbered from 0 to n - 1 connected by undirected server-to-server connections forming a network where connections[i] = [ai, bi] represents a connection between servers ai and bi. Any server can reach other servers directly or indirectly through the network.</p>
<p>A critical connection is a connection that, if removed, will make some servers unable to reach some other server.</p>
<p>Return all critical connections in the network in any order.</p>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]</span><br><span class="line">Output: [[1,3]]</span><br><span class="line">Explanation: [[3,1]] is also accepted.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2, connections = [[0,1]]</span><br><span class="line">Output: [[0,1]]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>2 &lt;= n &lt;= 10^5</li>
<li>n - 1 &lt;= connections.length &lt;= 10^5</li>
<li>0 &lt;= ai, bi &lt;= n - 1</li>
<li>ai != bi</li>
<li>There are no repeated connections.</li>
</ul>
<p>这道题说是有n个服务器互相连接，定义了一种关键连接，就是当去掉后，会有一部分服务无法访问另一些服务。说白了，就是让求无向图中的桥，对于求无向图中的割点或者桥的问题，需要使用塔里安算法 Tarjan’s Algorithm。该算法是图论中非常常用的算法之一，能解决强连通分量，双连通分量，割点和桥，求最近公共祖先（LCA）等问题，可以参见知乎上的这个贴子。Tarjan 算法是一种深度优先遍历 Depth-first Search 的算法，而且还带有一点联合查找 Union Find 的影子在里面。和一般的 DFS 遍历不同的是，这里用了一个类似时间戳的概念，就是用一个 time 数组来记录遍历到当前结点的时间，初始化为1，每遍历到一个新的结点，时间值就增加1。这里还用了另一个数组 low，来记录在能够访问到的所有节点中，时间戳最小的值，这样，在一个环上的结点最终 low 值都会被更新成一个最小值，就好像 Union Find 中同一个群组中都有相同的 root 值一样。这是非常重要且聪明的处理方式，因为若当前结点是割点的话，即其实桥一头的端点，当过桥之后，由于不存在其他的路径相连通（假设整个图只有一个桥），那么无法再回溯回来的，所以不管桥另一头的端点 next 的 low 值如何更新，其一定还是会大于 cur 的 low 值的，则桥就找到了。可能干讲不好理解，建议看下上面提到的知乎帖子，里面有图和视频可以很好的帮助理解。</p>
<p>这里首先根据给定的边来建立图的结构，这里使用 HashMap 来建立结点和其所有相连的结点集合之间的映射。对于每条边，由于是无向图，则两个方向都要建立映射，然后就调用递归，要传的参数还真不少，图结构，当前结点，前一个结点，cnt 值，time 和 low 数组，还有结果 res。在递归函数中，首先给当前结点 cur 的 time 和 low 值都赋值为 cnt，然后 cnt 自增1。接下来遍历和当前结点所有相邻的结点，若 next 的时间戳为0，表示这个结点没有被遍历过，则对该结点调用递归，然后用 next 结点的 low 值来更新当前结点的 low 值。若 next 结点已经之前访问过了，但不是前一个结点，则用 next 的 time 值来更新当前结点的 low 值。若回溯回来之后，next 的 low 值仍然大于 cur 的 time 值，说明这两个结点之间没有其他的通路，则一定是个桥，加入到结果 res 中即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">criticalConnections</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; connections) &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">time</span><span class="params">(n)</span>, <span class="title">low</span><span class="params">(n)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> conn : connections) &#123;</span><br><span class="line">            g[conn[<span class="number">0</span>]].<span class="built_in">push_back</span>(conn[<span class="number">1</span>]);</span><br><span class="line">            g[conn[<span class="number">1</span>]].<span class="built_in">push_back</span>(conn[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">helper</span>(g, <span class="number">0</span>, <span class="number">-1</span>, cnt, time, low, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">helper</span><span class="params">(unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt;&amp; g, <span class="type">int</span> cur, <span class="type">int</span> pre, <span class="type">int</span>&amp; cnt, vector&lt;<span class="type">int</span>&gt;&amp; time, vector&lt;<span class="type">int</span>&gt;&amp; low, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        time[cur] = low[cur] = cnt++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> next : g[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (time[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">helper</span>(g, next, cur, cnt, time, low, res);</span><br><span class="line">                low[cur] = <span class="built_in">min</span>(low[cur], low[next]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next != pre) &#123;</span><br><span class="line">                low[cur] = <span class="built_in">min</span>(low[cur], time[next]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (low[next] &gt; time[cur]) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;cur, next&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1200-Minimum-Absolute-Difference"><a href="#Leetcode1200-Minimum-Absolute-Difference" class="headerlink" title="Leetcode1200. Minimum Absolute Difference"></a>Leetcode1200. Minimum Absolute Difference</h1><p>Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements. </p>
<p>Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows</p>
<ul>
<li>a, b are from arr</li>
<li>a &lt; b</li>
<li>b - a equals to the minimum absolute difference of any two elements in arr</li>
</ul>
<p>Example 1:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [4,2,1,3]</span><br><span class="line">Output: [[1,2],[2,3],[3,4]]</span><br><span class="line">Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,3,6,10,15]</span><br><span class="line">Output: [[1,3]]</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [3,8,-10,23,19,-4,-14,27]</span><br><span class="line">Output: [[-14,-10],[19,23],[23,27]]</span><br></pre></td></tr></table></figure><br>首先排序，然后找到最小值及与最小值对应的元组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">minimumAbsDifference</span>(vector&lt;<span class="type">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> minn = <span class="number">99999</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>()<span class="number">-1</span>; i ++)</span><br><span class="line">            minn = <span class="built_in">min</span>(minn, arr[i+<span class="number">1</span>] - arr[i]);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>()<span class="number">-1</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i] == minn)</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;arr[i], arr[i+<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/05/Leetcode101_200/" rel="next" title="Leetcode101 - 200">
                <i class="fa fa-chevron-left"></i> Leetcode101 - 200
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/12/Leetcode701_800/" rel="prev" title="Leetcode701 - 800">
                Leetcode701 - 800 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">130</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1103-Distribute-Candies-to-People"><span class="nav-number">1.</span> <span class="nav-text">Leetcode1103. Distribute Candies to People</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1104-Path-In-Zigzag-Labelled-Binary-Tree"><span class="nav-number">2.</span> <span class="nav-text">Leetcode1104. Path In Zigzag Labelled Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1105-Filling-Bookcase-Shelves"><span class="nav-number">3.</span> <span class="nav-text">Leetcode1105. Filling Bookcase Shelves</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1108-Defanging-an-IP-Address"><span class="nav-number">4.</span> <span class="nav-text">Leetcode1108. Defanging an IP Address</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1109-Corporate-Flight-Bookings"><span class="nav-number">5.</span> <span class="nav-text">Leetcode1109. Corporate Flight Bookings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1110-Delete-Nodes-And-Return-Forest"><span class="nav-number">6.</span> <span class="nav-text">Leetcode1110. Delete Nodes And Return Forest</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1111-Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings"><span class="nav-number">7.</span> <span class="nav-text">Leetcode1111. Maximum Nesting Depth of Two Valid Parentheses Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1114-Print-in-Order"><span class="nav-number">8.</span> <span class="nav-text">Leetcode1114. Print in Order</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1122-Relative-Sort-Array"><span class="nav-number">9.</span> <span class="nav-text">Leetcode1122. Relative Sort Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1123-Lowest-Common-Ancestor-of-Deepest-Leaves"><span class="nav-number">10.</span> <span class="nav-text">Leetcode1123. Lowest Common Ancestor of Deepest Leaves</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1124-Longest-Well-Performing-Interval"><span class="nav-number">11.</span> <span class="nav-text">Leetcode1124. Longest Well-Performing Interval</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode-1125-Smallest-Sufficient-Team"><span class="nav-number">12.</span> <span class="nav-text">LeetCode] 1125. Smallest Sufficient Team</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1128-Number-of-Equivalent-Domino-Pairs"><span class="nav-number">13.</span> <span class="nav-text">Leetcode1128. Number of Equivalent Domino Pairs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1129-Shortest-Path-with-Alternating-Colors"><span class="nav-number">14.</span> <span class="nav-text">Leetcode1129. Shortest Path with Alternating Colors</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1130-Minimum-Cost-Tree-From-Leaf-Values"><span class="nav-number">15.</span> <span class="nav-text">Leetcode1130. Minimum Cost Tree From Leaf Values</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1137-N-th-Tribonacci-Number"><span class="nav-number">16.</span> <span class="nav-text">Leetcode1137. N-th Tribonacci Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1138-Alphabet-Board-Path"><span class="nav-number">17.</span> <span class="nav-text">Leetcode1138. Alphabet Board Path</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1139-Largest-1-Bordered-Square"><span class="nav-number">18.</span> <span class="nav-text">Leetcode1139. Largest 1-Bordered Square</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1140-Stone-Game-II"><span class="nav-number">19.</span> <span class="nav-text">Leetcode1140. Stone Game II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1143-Longest-Common-Subsequence"><span class="nav-number">20.</span> <span class="nav-text">Leetcode1143. Longest Common Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1144-Decrease-Elements-To-Make-Array-Zigzag"><span class="nav-number">21.</span> <span class="nav-text">Leetcode1144. Decrease Elements To Make Array Zigzag</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1146-Snapshot-Array"><span class="nav-number">22.</span> <span class="nav-text">Leetcode1146. Snapshot Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1147-Longest-Chunked-Palindrome-Decomposition"><span class="nav-number">23.</span> <span class="nav-text">Leetcode1147. Longest Chunked Palindrome Decomposition</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1154-Day-of-the-Year"><span class="nav-number">24.</span> <span class="nav-text">Leetcode1154. Day of the Year</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1156-Swap-For-Longest-Repeated-Character-Substring"><span class="nav-number">25.</span> <span class="nav-text">Leetcode1156. Swap For Longest Repeated Character Substring</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1155-Number-of-Dice-Rolls-With-Target-Sum"><span class="nav-number">26.</span> <span class="nav-text">Leetcode1155. Number of Dice Rolls With Target Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1160-Find-Words-That-Can-Be-Formed-by-Characters"><span class="nav-number">27.</span> <span class="nav-text">Leetcode1160. Find Words That Can Be Formed by Characters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1161-Maximum-Level-Sum-of-a-Binary-Tree"><span class="nav-number">28.</span> <span class="nav-text">Leetcode1161. Maximum Level Sum of a Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1162-As-Far-from-Land-as-Possible"><span class="nav-number">29.</span> <span class="nav-text">Leetcode1162. As Far from Land as Possible</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1165-Single-Row-Keyboard"><span class="nav-number">30.</span> <span class="nav-text">Leetcode1165. Single-Row Keyboard</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1170-Compare-Strings-by-Frequency-of-the-Smallest-Character"><span class="nav-number">31.</span> <span class="nav-text">Leetcode1170. Compare Strings by Frequency of the Smallest Character</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1171-Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List"><span class="nav-number">32.</span> <span class="nav-text">Leetcode1171. Remove Zero Sum Consecutive Nodes from Linked List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1175-Prime-Arrangements"><span class="nav-number">33.</span> <span class="nav-text">Leetcode1175. Prime Arrangements</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1177-Can-Make-Palindrome-from-Substring"><span class="nav-number">34.</span> <span class="nav-text">Leetcode1177. Can Make Palindrome from Substring</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1179-Reformat-Department-Table"><span class="nav-number">35.</span> <span class="nav-text">Leetcode1179. Reformat Department Table</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1184-Distance-Between-Bus-Stops"><span class="nav-number">36.</span> <span class="nav-text">Leetcode1184. Distance Between Bus Stops</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1185-Day-of-the-Week"><span class="nav-number">37.</span> <span class="nav-text">Leetcode1185. Day of the Week</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1186-Maximum-Subarray-Sum-with-One-Deletion-%E5%88%A0%E9%99%A4%E4%B8%80%E6%AC%A1%E5%BE%97%E5%88%B0%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">38.</span> <span class="nav-text">Leetcode1186. Maximum Subarray Sum with One Deletion 删除一次得到子数组最大和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1189-Maximum-Number-of-Balloons"><span class="nav-number">39.</span> <span class="nav-text">Leetcode1189. Maximum Number of Balloons</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1190-Reverse-Substrings-Between-Each-Pair-of-Parentheses"><span class="nav-number">40.</span> <span class="nav-text">Leetcode1190. Reverse Substrings Between Each Pair of Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1191-K-Concatenation-Maximum-Sum"><span class="nav-number">41.</span> <span class="nav-text">Leetcode1191. K-Concatenation Maximum Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1192-Critical-Connections-in-a-Network"><span class="nav-number">42.</span> <span class="nav-text">Leetcode1192. Critical Connections in a Network</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1200-Minimum-Absolute-Difference"><span class="nav-number">43.</span> <span class="nav-text">Leetcode1200. Minimum Absolute Difference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
