<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="实验一操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)用make “V&#x3D;”看到了所有的编译命令 第178行 create ucore.img，可以看到call函数，   totarget &#x3D; $(addprefix $(BINDIR)$(SLASH),$(1))   这样就调用了addprefix">
<meta property="og:type" content="article">
<meta property="og:title" content="清华大学操作系统课程实验">
<meta property="og:url" content="http://yoursite.com/2019/06/29/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="实验一操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)用make “V&#x3D;”看到了所有的编译命令 第178行 create ucore.img，可以看到call函数，   totarget &#x3D; $(addprefix $(BINDIR)$(SLASH),$(1))   这样就调用了addprefix">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/20190629002.png">
<meta property="og:image" content="http://yoursite.com/img/20190629004.png">
<meta property="article:published_time" content="2019-06-29T15:56:00.000Z">
<meta property="article:modified_time" content="2022-01-06T11:31:19.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/20190629002.png">

<link rel="canonical" href="http://yoursite.com/2019/06/29/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>清华大学操作系统课程实验 | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/29/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          清华大学操作系统课程实验
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-29 23:56:00" itemprop="dateCreated datePublished" datetime="2019-06-29T23:56:00+08:00">2019-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-06 19:31:19" itemprop="dateModified" datetime="2022-01-06T19:31:19+08:00">2022-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h1><h2 id="操作系统镜像文件ucore-img是如何一步一步生成的？-需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果"><a href="#操作系统镜像文件ucore-img是如何一步一步生成的？-需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果" class="headerlink" title="操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)"></a>操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</h2><p>用<em>make “V=”</em>看到了所有的编译命令</p>
<p>第178行 create ucore.img，可以看到call函数，  </p>
<p>totarget = $(addprefix $(BINDIR)$(SLASH),$(1))  </p>
<p>这样就调用了addprefix，把$(BINDIR)$(SLASH)变成$(1)的前缀，在makefile里再把$(1)调用call变成要生成的文件，这里需要bootblock和kernel。  </p>
<p>bootblock需要一些.o文件，makefile里的foreach有如下格式：$(foreach &lt; var &gt;,&lt; list &gt;,&lt; text &gt;)  </p>
<p>这个函数的意思是，把参数&lt; list &gt;;中的单词逐一取出放到参数&lt; var &gt;所指定的变量中，然后再执行&lt; text&gt;;所包含的表达式。每一次&lt; text &gt;会返回一个字符串，循环过程中，&lt; text &gt;的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&lt; text &gt;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p>
<ul>
<li>通过看makefile生成的编译命令，生成bootasm.o需要bootasm.S</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li>-ggdb  生成可供gdb使用的调试信息。这样才能用qemu+gdb来调试bootloader or ucore。  </li>
<li>-m32  生成适用于32位环境的代码。我们用的模拟硬件是32bit的80386，所以ucore也要是32位。  </li>
<li>-gstabs  生成stabs格式的调试信息。这样要ucore的monitor可以显示出便于开发者阅读的函数调用  </li>
<li>-nostdinc  不使用标准库。标准库是给应用程序用的，我们是编译ucore内核，OS内核是提供服务的，所以所有的服务要自给自足。  </li>
<li>-fno-stack-protector  不生成用于检测缓冲区溢出的代码。这是for 应用程序的，我们是编译内核，ucore内核好像还用不到此功能。  </li>
<li>-Os  为减小代码大小而进行优化。根据硬件spec，主引导扇区只有512字节，我们写的简单bootloader的最终大小不能大于510字节。  </li>
<li>-I&lt; dir &gt;  添加搜索头文件的路径</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li>-m <emulation>  模拟为i386上的连接器  </li>
<li>-nostdlib  不使用标准库  </li>
<li>-N  设置代码段和数据段均可读写  </li>
<li>-e <entry>  指定入口  </li>
<li>-Ttext  制定代码段开始位置  </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kernel = $(call totarget,kernel)</span><br><span class="line"></span><br><span class="line">$(kernel): tools/kernel.ld</span><br><span class="line"></span><br><span class="line">$(kernel): $(KOBJS)</span><br><span class="line">	@echo + ld $@</span><br><span class="line">	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)</span><br><span class="line">	@$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel)</span><br><span class="line">	@$(OBJDUMP) -t $@ | $(SED) &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; $(call symfile,kernel)</span><br><span class="line"></span><br><span class="line">$(call create_target,kernel)</span><br></pre></td></tr></table></figure>
<p>编译命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trapentry.S -o obj/kern/（o文件）</span><br></pre></td></tr></table></figure><br>链接器：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o obj/kern/mm/pmm.o  obj/libs/string.o obj/libs/printfmt.o</span><br></pre></td></tr></table></figure></p>
<p>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p>
<p>注意：指定数字的地方若以下列字符结尾，则乘以相应的数字：b=512；c=1；k=1024；w=2<br>参数注释：</p>
<ul>
<li>if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;</li>
<li>of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;</li>
<li>ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。</li>
<li>obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。</li>
<li>bs=bytes：同时设置读入/输出的块大小为bytes个字节。</li>
<li>cbs=bytes：一次转换bytes个字节，即指定转换缓冲区大小。</li>
<li>skip=blocks：从输入文件开头跳过blocks个块后再开始复制。</li>
<li>seek=blocks：从输出文件开头跳过blocks个块后再开始复制。<ul>
<li>注意：通常只用当输出文件是磁盘或磁带时才有效，即备份到磁盘或磁带时才有效。</li>
</ul>
</li>
<li>count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</li>
<li>conv=conversion：用指定的参数转换文件。<ul>
<li>ascii：转换ebcdic为ascii</li>
<li>ebcdic：转换ascii为ebcdic</li>
<li>ibm：转换ascii为alternate ebcdic</li>
<li>block：把每一行转换为长度为cbs，不足部分用空格填充</li>
<li>unblock：使每一行的长度都为cbs，不足部分用空格填充</li>
<li>lcase：把大写字符转换为小写字符</li>
<li>ucase：把小写字符转换为大写字符</li>
<li>swab：交换输入的每对字节</li>
<li>noerror：出错时不停止</li>
<li>notrunc：不截短输出文件</li>
<li>sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</li>
</ul>
</li>
</ul>
<p>生成一个有10000个块的文件，用0填充（答案中说，每个块默认512字节，但是可能要有bs参数指定或者bs默认就是512？）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/zero of=bin/ucore.img count=10000</span><br></pre></td></tr></table></figure></p>
<p>把bootblock中的内容写到第一个块<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=bin/bootblock of=bin/ucore.img conv=notrunc</span><br></pre></td></tr></table></figure></p>
<p>从第二个块开始写kernel中的内容<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br></pre></td></tr></table></figure></p>
<h2 id="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h2><p>上课讲过，合法的主引导扇区最后两个字节有特定值<br>0x55、0xAA<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buf一共512个字节</span><br><span class="line">buf[510] = 0x55;</span><br><span class="line">buf[511] = 0xAA;</span><br></pre></td></tr></table></figure></p>
<h2 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a>练习2：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file bin/kernel</span><br><span class="line">set architecture i8086</span><br><span class="line">target remote :1234</span><br><span class="line">b *0x7c00</span><br><span class="line">continue</span><br></pre></td></tr></table></figure>
<p>在gdb中输入命令，输出2条instruction<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /2i $pc</span><br></pre></td></tr></table></figure><br>跟bootasm.S里的汇编代码一致！amazing<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x /2i $pc</span><br><span class="line">=&gt; 0x7c00:	cli    </span><br><span class="line">   0x7c01:	cld    </span><br><span class="line">(gdb) x /10i $pc</span><br><span class="line">=&gt; 0x7c00:	cli    </span><br><span class="line">   0x7c01:	cld    </span><br><span class="line">   0x7c02:	xor    %ax,%ax</span><br><span class="line">   0x7c04:	mov    %ax,%ds</span><br><span class="line">   0x7c06:	mov    %ax,%es</span><br><span class="line">   0x7c08:	mov    %ax,%ss</span><br><span class="line">   0x7c0a:	in     $0x64,%al</span><br><span class="line">   0x7c0c:	test   $0x2,%al</span><br><span class="line">   0x7c0e:	jne    0x7c0a</span><br><span class="line">   0x7c10:	mov    $0xd1,%al</span><br></pre></td></tr></table></figure></p>
<p>在Makefile的debug选项中加入<em>-d in_asm -D q.log</em>，可以生成一个q.log里边是执行的汇编命令（部分）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0xfffffff0:  ljmp   $0xf000,$0xe05b</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x000fe05b:  cmpl   $0x0,%cs:0x6c48</span><br><span class="line">0x000fe062:  jne    0xfd2e1</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x000fe066:  xor    %dx,%dx</span><br><span class="line">0x000fe068:  mov    %dx,%ss</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x000fe06a:  mov    $0x7000,%esp</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x000fe070:  mov    $0xf3691,%edx</span><br><span class="line">0x000fe076:  jmp    0xfd165</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h2><p>分析bootloader进入保护模式的过程。（要求在报告中写出分析）<br>BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。请分析bootloader是如何完成从实模式进入保护模式的。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lab1/boot/bootasm.S</span><br></pre></td></tr></table></figure><br>类似之前，从0x7c00进入，首先<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        .code16</span><br><span class="line">            cli				;禁止中断发生</span><br><span class="line">            cld				;CLD与STD是用来操作方向标志位DF。CLD使DF复位，即D</span><br><span class="line">            				  ;F=0，STD使DF置位，即DF=1.用于串操作指令中。</span><br><span class="line">            xorw %ax, %ax   ;ax置0</span><br><span class="line">            movw %ax, %ds   ;其他寄存器也清空</span><br><span class="line">            movw %ax, %es</span><br><span class="line">            movw %ax, %ss</span><br></pre></td></tr></table></figure><br>.globl指示告诉汇编器，_start这个符号要被链接器用到，所以要在目标文件的符号表中标记它是一个全局符号（在第 5.1 节 “目标文件”详细解释）。_start就像C程序的main函数一样特殊，是整个程序的入口，链接器在链接时会查找目标文件中的_start符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编程序都要提供一个_start符号并且用.globl声明。如果一个符号没有用.globl声明，就表示这个符号不会被链接器用到。</p>
<p>开启A20：到了80286，系统的地址总线有原来的20根发展为24根，这样能够访问的内存可以达到2^24=16M。Intel在设计80286时提出的目标是向下兼容。所以，在实模式下，系统所表现的行为应该和8086/8088所表现的完全一样，也就是说，在实模式下，80286以及后续系列，应该和8086/8088完全兼容。但最终，80286芯片却存在一个BUG：因为有了80286有A20线，如果程序员访问100000H-10FFEFH之间的内存，系统将实际访问这块内存，而不是象8086/8088一样从0开始。为了解决上述兼容性问题，IBM使用键盘控制器上剩余的一些输出线来管理第21根地址线（从0开始数是第20根） 的有效性，被称为A20 Gate:</p>
<blockquote>
<p>如果A20 Gate被打开，则当程序员给出100000H-10FFEFH之间的地址的时候，系统将真正访问这块内存区域； </p>
<p>如果A20 Gate被禁止，则当程序员给出100000H-10FFEFH之间的地址的时候，系统仍然使用8086/8088的方式即取模方式（8086仿真）。绝大多数IBM PC兼容机默认的A20 Gate是被禁止的。现在许多新型PC上存在直接通过BIOS功能调用来控制A20 Gate的功能。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:               </span><br><span class="line">    inb $0x64, %al      ;0x64里的数据放到al中，即从I/O端口读取一个字节(BYTE,;HALF-WORD)</span><br><span class="line">    testb $0x2, %al     ;检测</span><br><span class="line">    jnz seta20.1        ;等到这个端口不忙，没有东西传进来</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al     ; 0xd1 写到 0x64</span><br><span class="line">    outb %al, $0x64     ;写8042输出端口</span><br><span class="line"></span><br><span class="line">seta20.2:                </span><br><span class="line">    inb $0x64, %al      </span><br><span class="line">    testb $0x2, %al     </span><br><span class="line">    jnz seta20.2		;等不忙</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al     ;打开A20 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60     ;0xdf = 11011111</span><br></pre></td></tr></table></figure><br>初始化GDT表并打开保护模式<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lgdt gdtdesc		   ;让CPU读取gdtr_addr所指向内存内容保存到GDT内存当中</span><br><span class="line">movl %cr0, %eax		   ;cr0寄存器PE位or置1</span><br><span class="line">orl $CR0_PE_ON, %eax   </span><br><span class="line">movl %eax, %cr0</span><br><span class="line">ljmp $PROT_MODE_CSEG, $protcseg ;长跳改cs，基于段机制的寻址</span><br></pre></td></tr></table></figure><br>最后初始化堆栈、寄存器，调用bootmain<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protcseg:</span><br><span class="line">    # 初始化寄存器</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line"></span><br><span class="line">    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    call bootmain</span><br></pre></td></tr></table></figure></p>
<h2 id="练习四"><a href="#练习四" class="headerlink" title="练习四"></a>练习四</h2><p>对于bootmain.c，它唯一的工作就是从硬盘的第一个扇区启动格式为ELF的内核镜像；控制从boot.S文件开始—这个文件设置了保护模式和一个栈，这样C代码就可以运行了，然后再调用bootmain()。  </p>
<p>对x86.h头文件有：<a href="http://www.codeforge.cn/read/234474/x86.h__html">http://www.codeforge.cn/read/234474/x86.h__html</a><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static inline uchar</span><br><span class="line">inb(ushort port)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">  uchar data;</span><br><span class="line"> </span><br><span class="line">  asm volatile(&quot;in %1,%0&quot; : &quot;=a&quot; (data) : &quot;d&quot; (port));</span><br><span class="line">  //对应 in port,data</span><br><span class="line">  return data;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>0x1F7：读 用来存放读操作后的状态</p>
</blockquote>
<p>readsect(void *dst, uint32_t secno)从secno扇区读取数据到dst  </p>
<ul>
<li>用汇编的方式实现读取1000号逻辑扇区开始的8个扇区  </li>
<li>IDE通道的通讯地址是0x1F0 - 0x1F7  </li>
<li>其中0x1F3 - 0x1F6 4个字节的端口是用来写入LBA地址的  </li>
<li>LBA就是 logical Block Address  </li>
<li>1000的16进制就是0x3E8  </li>
<li>向0x1F3 - 0x1F6写入 0x3E8  </li>
<li>向0x1F2这个地址写入扇区数量，也就是8  </li>
<li>向0X1F7写入要执行的操作命令码，对读操作的命令码是 0x20  </li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">out 0x1F3 0x00</span><br><span class="line">out 0x1F4 0x00</span><br><span class="line">out 0x1F5 0x03</span><br><span class="line">out 0x1F6 0xE8</span><br><span class="line">out 0x1F2 0x08</span><br><span class="line">out 0x1F7 0x20</span><br></pre></td></tr></table></figure>
<p>outb的定义在x86.h中，封装out命令，将data输出到port端口<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">outb</span><span class="params">(ushort port, uchar data)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;out %0,%1&quot;</span> : : <span class="string">&quot;a&quot;</span> (data), <span class="string">&quot;d&quot;</span> (port))</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>业界共同推出了 LBA48，采用 48 个比特来表示逻辑扇区号。如此一来，就可以管理131072 TB 的硬盘容量了。在这里我们采用将采用 LBA28 来访问硬盘。<br>第1步：设置要读取的扇区数量。这个数值要写入0x1f2端口。这是个8位端口，因此每次只能读写255个扇区：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,0x1f2</span><br><span class="line">mov al,0x01    ;1 个扇区</span><br><span class="line">out dx,al</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：如果写入的值为 0，则表示要读取 256 个扇区。每读一个扇区，这个数值就减一。因此，如果在读写过程中发生错误，该端口包含着尚未读取的扇区数。   </p>
</blockquote>
<p>第2步：设置起始LBA扇区号。扇区的读写是连续的，因此只需要给出第一个扇区的编号就可以了。28 位的扇区号太长，需要将其分成 4 段，分别写入端口 0x1f3、0x1f4、0x1f5 和 0x1f6 号端口。其中，0x1f3 号端口存放的是 0～7 位；0x1f4 号端口存放的是 8～15 位；0x1f5 号端口存放的是 16～23 位，最后 4 位在 0x1f6 号端口。  </p>
<p>第3步:<br>向端口 0x1f7 写入 0x20，请求硬盘读。  </p>
<p>第4步:等待读写操作完成。端口0x1f7既是命令端口，又是状态端口。在通过这个端口发送读写命令之后，硬盘就忙乎开了。在它内部操作期间，它将 0x1f7 端口的第7位置“1”，表明自己很忙。一旦硬盘系统准备就绪，它再将此位清零，说明自己已经忙完了，同时将第3位置“1”，意思是准备好了，请求主机发送或者接收数据。  </p>
<p>第5步:连续取出数据。0x1f0 是硬盘接口的数据端口，而且还是一个16位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">outb(0x1F2, 1);                         // 读取第一个数据块</span><br><span class="line">outb(0x1F3, secno &amp; 0xFF);</span><br><span class="line">outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);</span><br><span class="line">outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);</span><br><span class="line">outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);</span><br><span class="line">outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors</span><br><span class="line"></span><br><span class="line">insl(0x1F0, dst, SECTSIZE / 4)          // 第五步</span><br></pre></td></tr></table></figure>
<p>readseg函数简单包装了readsect，可以从设备读取任意长度的内容。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void readseg(uintptr_t va, uint32_t count, uint32_t offset) &#123;</span><br><span class="line">  uintptr_t end_va = va + count;</span><br><span class="line">  va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">  uint32_t secno = (offset / SECTSIZE) + 1;</span><br><span class="line">  // 看是第几块，加1因为0扇区被引导占用,ELF文件从1扇区开始</span><br><span class="line"></span><br><span class="line">  for (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">    readsect((void *)va, secno);//调用之前的封装函数对每一块进行处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对不同的文件，执行file命令如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file link.o </span><br><span class="line">link.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br><span class="line"> </span><br><span class="line">file libfoo.so </span><br><span class="line">libfoo.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=871ecaf438d2ccdcd2e54cd8158b9d09a9f971a7, not stripped</span><br><span class="line"> </span><br><span class="line">file p1</span><br><span class="line">p1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=37f75ef01273a9c77f4b4739bcb7b63a4545d729, not stripped</span><br><span class="line"> </span><br><span class="line">file libfoo.so </span><br><span class="line">libfoo.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=871ecaf438d2ccdcd2e54cd8158b9d09a9f971a7, stripped</span><br></pre></td></tr></table></figure><br>以下是主函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bootmain(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="comment">// read the 1st page off disk</span></span><br><span class="line">    readseg((<span class="type">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看是不是标准的elf</span></span><br><span class="line">    <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// elf头中有elf文件应该加载到什么位置，将表头地址存在ph中</span></span><br><span class="line">    ph = (<span class="keyword">struct</span> proghdr *)((<span class="type">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到内核的入口，这个函数不返回</span></span><br><span class="line">    ((<span class="type">void</span> (*)(<span class="type">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">    outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般的 ELF 文件包括三个索引表：ELF header，Program header table，Section header table。</p>
<ul>
<li>ELF header：在文件的开始，保存了路线图，描述了该文件的组织情况。  </li>
<li>Program header table：告诉系统如何创建进程映像。用来构造进程映像的目标文件必须具有程序头部表，可重定位文件不需要这个表。  </li>
<li>Section header table：包含了描述文件节区的信息，每个节区在表中都有一项，每一项给出诸如节区名称、节区大小这类信息。用于链接的目标文件必须包含节区头部表，其他目标文件可以有，也可以没有这个表。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT]; <span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Half    e_type;         <span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Half    e_machine;      <span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Word    e_version;      <span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addr    e_entry;        <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Off e_phoff;        <span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Off e_shoff;        <span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Word    e_flags;        <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Half    e_ehsize;       <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Half    e_phentsize;        <span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Half    e_phnum;        <span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Half    e_shentsize;        <span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Half    e_shnum;        <span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Half    e_shstrndx;     <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>
<p>ELF文件中有很多段，段表（Section Header Table）就是保存这些段的基本信息的结构，包括了段名、段长度、段在文件中的偏移位置、读写权限和其他段属性。<br>objdump工具可以查看ELF文件基本的段结构<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word    sh_name;        <span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf64_Word    sh_type;        <span class="comment">/* Section type */</span></span><br><span class="line">  Elf64_Xword   sh_flags;       <span class="comment">/* Section flags */</span></span><br><span class="line">  Elf64_Addr    sh_addr;        <span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off sh_offset;      <span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xword   sh_size;        <span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf64_Word    sh_link;        <span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf64_Word    sh_info;        <span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword   sh_addralign;       <span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xword   sh_entsize;     <span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure></p>
<h2 id="练习五"><a href="#练习五" class="headerlink" title="练习五"></a>练习五</h2><p>一个比较简单但很绕的逻辑，找到每个函数调用压栈时的指针，找到这个指针也就找到了上一个函数的部分，再找它之前的函数调用压栈的内容。主要问题是忘记了ebp!=0这个条件，忽视了要用16进制。</p>
<ul>
<li>eip是寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，从eip寄存器中读取下一条指令的内存地址，然后继续执行；  </li>
<li>esp是寄存器存放当前线程的栈顶指针；  </li>
<li>ebp存放一个指针，该指针指向系统栈最上面一个栈帧的底部。即EBP寄存器存储的是栈底地址，而这个地址是由ESP在函数调用前传递给EBP的。等到调用结束，EBP会把其地址再次传回给ESP。所以ESP又一次指向了函数调用结束后，栈顶的地址。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void print_stackframe(void) &#123;</span><br><span class="line">     /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span><br><span class="line">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span><br><span class="line">      * (3) from 0 .. STACKFRAME_DEPTH</span><br><span class="line">      *    (3.1) printf value of ebp, eip</span><br><span class="line">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]</span><br><span class="line">      *    (3.3) cprintf(&quot;\n&quot;);</span><br><span class="line">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span><br><span class="line">      *    (3.5) popup a calling stackframe</span><br><span class="line">      *           NOTICE: the calling funciton&#x27;s return addr eip  = ss:[ebp+4]</span><br><span class="line">      *                   the calling funciton&#x27;s ebp = ss:[ebp]</span><br><span class="line">      */</span><br><span class="line">        uint32_t my_ebp = read_ebp();</span><br><span class="line">        uint32_t my_eip = read_eip();//读取当前的ebp和eip</span><br><span class="line">        int i,j;</span><br><span class="line">        for(i = 0; my_ebp!=0 &amp;&amp; i&lt; STACKFRAME_DEPTH; i++)&#123;</span><br><span class="line">                cprintf(&quot;%0x %0x\n&quot;,my_ebp,my_eip);</span><br><span class="line">                for(j=0;j&lt;4;j++)&#123;</span><br><span class="line">                        cprintf(&quot;%0x\t&quot;,((uint32_t*)my_ebp+2)[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(&quot;\n&quot;);</span><br><span class="line">                print_debuginfo(my_eip-1);</span><br><span class="line">                my_ebp = ((uint32_t*)my_ebp)[0];</span><br><span class="line">                my_eip = ((uint32_t*)my_ebp)[1];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ebp（基指针）寄存器主要通过软件约定与堆栈相关联。 在进入C函数时，函数的初始代码通常将先前函数的基本指针推入堆栈来保存，然后在函数持续时间内将当前esp值复制到ebp中。 如果程序中的所有函数都遵循这个约定，那么在程序执行期间的任何给定点，都可以通过跟踪保存的ebp指针链并确切地确定嵌套的函数调用序列引起这个特定的情况来追溯堆栈。 指向要达到的函数。 例如，当某个特定函数导致断言失败时，因为错误的参数传递给它，但您不确定是谁传递了错误的参数。 堆栈回溯可找到有问题的函数。</p>
<p>最后一行对应的是第一个使用堆栈的函数，所以在栈的最深一层，就是bootmain.c中的bootmain。 bootloader起始的堆栈从0x7c00开始，使用”call bootmain”转入bootmain函数。 call指令压栈，所以bootmain中ebp为0x7bf8。</p>
<h2 id="练习六"><a href="#练习六" class="headerlink" title="练习六"></a>练习六</h2><p>一个表项的结构如下:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*lab1/kern/mm/mmu.h*/</span><br><span class="line">/* Gate descriptors for interrupts and traps */</span><br><span class="line">struct gatedesc &#123;</span><br><span class="line">    unsigned gd_off_15_0 : 16;        // low 16 bits of offset in segment</span><br><span class="line">    unsigned gd_ss : 16;            // segment selector</span><br><span class="line">    unsigned gd_args : 5;            // # args, 0 for interrupt/trap gates</span><br><span class="line">    unsigned gd_rsv1 : 3;            // reserved(should be zero I guess)</span><br><span class="line">    unsigned gd_type : 4;            // type(STS_&#123;TG,IG32,TG32&#125;)</span><br><span class="line">    unsigned gd_s : 1;                // must be 0 (system)</span><br><span class="line">    unsigned gd_dpl : 2;            // descriptor(meaning new) privilege level</span><br><span class="line">    unsigned gd_p : 1;                // Present</span><br><span class="line">    unsigned gd_off_31_16 : 16;        // high bits of offset in segment</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>一个表项占用8字节，其中2-3字节是段选择子，0-1字节和6-7字节拼成位移， 两者联合便是中断处理程序的入口地址。(copy from answer)  </p>
<p>pic_init：中断控制器的初始化；idt_init：建立中断描述符表，并使能中断，intr_enable()</p>
<p>中断向量表可以认为是一个大数组，产生中断时生成一个中断号，来查这个idt表，找到中断服务例程的地址（段选择子加offset）。</p>
<p>主要是调用SETGATE这个宏对interrupt descriptor table进行初始化，是之前看到的对每个字节进行操作。然后调用lidt进行load idt（sti：使能中断）</p>
<p>建立一个中断描述符</p>
<ul>
<li>istrap: 1 是一个trap, 0 代表中断</li>
<li>sel: 中断处理代码段</li>
<li>off: 中断处理代码段偏移</li>
<li>dpl: 描述符的优先级</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SETGATE(gate, istrap, sel, off, dpl)</span><br></pre></td></tr></table></figure>
<p>除了系统调用中断(T_SYSCALL)使用陷阱门描述符且权限为用户态权限以外，其它中断均使用特权级(DPL)为0的中断门描述符，权限为内核态权限；</p>
<ol>
<li>中断描述符表（Interrupt Descriptor Table）中断描述符表把每个中断或异常编号和一个指向中断服务例程的描述符联系起来。同GDT一样，IDT是一个8字节的描述符数组，但IDT的第一项可以包含一个描述符。CPU把中断（异常）号<em>乘以8</em>做为IDT的索引。IDT可以位于内存的任意位置，CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址。指令LIDT和SIDT用来操作IDTR。两条指令都有一个显示的操作数：一个6字节表示的内存地址。在保护模式下，最多会存在256个Interrupt/Exception Vectors。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        extern uintptr_t __vectors[];</span><br><span class="line">        int i;</span><br><span class="line">        //for(i=0;i&lt;256;i++)</span><br><span class="line">        for(i=0;i&lt; sizeof(idt) / sizeof(struct gatedesc); i++)&#123;</span><br><span class="line">                SETGATE(idt[i],0,GD_KTEXT,__vectors[i],DPL_KERNEL);</span><br><span class="line">        &#125;</span><br><span class="line">//      SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br><span class="line">        SETGATE(idt[T_SWITCH_TOK], 1, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br><span class="line">        lidt(&amp;idt_pd);</span><br></pre></td></tr></table></figure>
<p>对idt中的每一项，调用SETGATE进行设置，第二个是0表明是一个中断，如果是1表明是一个陷阱；GD_KTEXT是SEG_KTEXT（1，全局段编号）乘8，是处理中断的代码段编号，__vectors[i]是作为在代码段中的偏移量，vectors[i]在kern/trap/vectors.S中定义，定义了255个中断服务例程的地址，这里才是入口，且都跳转到__alltraps。在trap中调用了trap_dispatch，这样就根据传进来的进行switch处理。  </p>
<p>用户态设置在特权级3，内核态设置在特权级0。</p>
<h2 id="练习七"><a href="#练习七" class="headerlink" title="练习七"></a>练习七</h2><p>这个实验实现用户态和内核态的转换，通过看代码基本明白。在init.c中的lab1_switch_to_user函数时一段汇编代码， 触发中断的话，有‘int %0’，就把第二个冒号（输入的数，T_SWITCH_TOK）替换%0， 这样中断号就是T_SWITCH_TOK。  </p>
<p>SETGATE设置中断向量表将每个中断处理例程的入口设成<strong>vector[i]的值，然后在有中断时，找到中断向量表中这个中断的处理例程，都是跳到</strong>alltraps，__alltraps把寄存器（ds es fs gs）压栈，把esp压栈，这样假装构造一个trapframe然后调用trap，trap调用了trap_dispatch</p>
<p>在trap_dispatch中，对从堆栈弹出的段寄存器进行修改，转成User时和转成Kernel时不一样，分别赋值，同时需要修改之前的trapframe，实现中断的恢复。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.</span><br><span class="line">case T_SWITCH_TOU:</span><br><span class="line">    if(tf-&gt;tf_cs != USER_CS)&#123;</span><br><span class="line">            tf-&gt;tf_cs = USER_CS;</span><br><span class="line">            tf-&gt;tf_ds = USER_DS;</span><br><span class="line">            tf-&gt;tf_es = USER_DS;</span><br><span class="line">            tf-&gt;tf_ss = USER_DS;</span><br><span class="line">            tf-&gt;tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">            *((uint32_t*)tf - 1) = (uint32_t)tf;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">case T_SWITCH_TOK:</span><br><span class="line">    if(tf-&gt;tf_cs != KERNEL_CS) &#123;</span><br><span class="line">    tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">    tf-&gt;tf_ds = KERNEL_DS;</span><br><span class="line">    tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">    tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">    struct trapframe *switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (sizeof(struct trapframe) - 8));</span><br><span class="line">    memmove(switchu2k,tf,sizeof(struct trapframe)-8);</span><br><span class="line">    *((uint32_t *)tf-1)=(uint32_t)switchu2k;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure>
<h1 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h1><h2 id="读代码"><a href="#读代码" class="headerlink" title="读代码"></a>读代码</h2><p>在bootloader进入保护模式前进行探测物理内存分布和大小，基本方式是通过BIOS中断调用，在实模式下完成，在boot/bootasm.S中从probe_memory处到finish_probe处的代码部分完成。以下应该是检测到的物理内存信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">memory management: default_pmm_manager</span><br><span class="line">e820map:</span><br><span class="line">  memory: 0009fc00, [00000000, 0009fbff], type = 1.</span><br><span class="line">  memory: 00000400, [0009fc00, 0009ffff], type = 2.</span><br><span class="line">  memory: 00010000, [000f0000, 000fffff], type = 2.</span><br><span class="line">  memory: 07ee0000, [00100000, 07fdffff], type = 1.</span><br><span class="line">  memory: 00020000, [07fe0000, 07ffffff], type = 2.</span><br><span class="line">  memory: 00040000, [fffc0000, ffffffff], type = 2.</span><br></pre></td></tr></table></figure></p>
<p>参考：type是物理内存空间的类型，1是可以使用的，2是暂时不能够使用的。</p>
<p>之前是开启A20的16位地址线，实现20位地址访问。通过写键盘控制器8042的64h端口与60h端口。先转成实模式！<br>获取的物理内存信息是用这种结构存的（内存映射地址描述符），一共20字节：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> nr_map;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint64_t</span> addr;    <span class="comment">//8字节，unsigned long long，基地址？</span></span><br><span class="line">        <span class="type">uint64_t</span> size;    <span class="comment">//8字节，unsigned long long，大小</span></span><br><span class="line">        <span class="type">uint32_t</span> type;    <span class="comment">//4字节，unsigned long，内存类型</span></span><br><span class="line">    &#125; __attribute__((packed)) <span class="built_in">map</span>[E820MAX];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每探测到一块内存空间，对应的内存映射描述符被写入指定表，以下是通过向INT 15h中断传入e820h参数来探测物理内存空间的信息。”$”美元符号修饰立即数，”%”修饰寄存器。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">probe_memory:</span><br><span class="line">    movl $0, 0x8000     #把0这个立即数写入0x8000地址，</span><br><span class="line">    xorl %ebx, %ebx     #相当于我们设置在0x8000处存放struct e820map, 并清除e820map中的nr_map置0</span><br><span class="line">    movw $0x8004, %di   #0x8004正好就是第一个内存映射地址描述符的地址，因为nr_map是四个字节</span><br><span class="line">start_probe:</span><br><span class="line">    movl $0xE820, %eax  #传入0xE820作为参数，</span><br><span class="line">    movl $20, %ecx      #内存映射地址描述符的大小是20个字节</span><br><span class="line">    movl $SMAP, %edx    #SMAP之前定义是0x534d4150，不知道何用</span><br><span class="line">    int $0x15           #调用INT 15H中断</span><br><span class="line">    jnc cont            #CF=0,则跳转到cont</span><br><span class="line">    movw $12345, 0x8000 </span><br><span class="line">    jmp finish_probe</span><br><span class="line">cont:</span><br><span class="line">    addw $20, %di       #设置下一个内存映射地址描述符的地址</span><br><span class="line">    incl 0x8000         #E820map中的nr_map加一</span><br><span class="line">    cmpl $0, %ebx       #如果INT0x15返回的ebx为零，表示探测结束，如果还有就继续找</span><br><span class="line">    jnz start_probe</span><br><span class="line">finish_probe:</span><br></pre></td></tr></table></figure></p>
<p>调用中断int 15h 之前，需要填充如下寄存器：  </p>
<ul>
<li>eax  int 15h 可以完成许多工作，主要有ax的值决定，我们想要获取内存信息，需要将ax赋值为0E820H。  </li>
<li>ebx  放置着“后续值(continuation value)”，第一次调用时ebx必须为0.  </li>
<li>es:di 指向一个地址范围描述结构 ARDS(Address Range Descriptor Structure), BIOS将会填充此结构。</li>
<li>ecx  es:di所指向的地址范围描述结构的大小，以字节为单位。无论es:di所指向的结构如何设置，BIOS最多将会填充ecx字节。不过，通常情况下无论ecx为多大，BIOS只填充20字节，有些BIOS忽略ecx的值，总是填充20字节。  </li>
<li>edx  0534D4150h(‘SMAP’)——BIOS将会使用此标志，对调用者将要请求的系统映像信息进行校验，这些信息被BIOS放置到es:di所指向的结构中。  </li>
</ul>
<p>中断调用之后，结果存放于下列寄存器之中。  </p>
<ul>
<li>CF  CF=0表示没有错误，否则存在错误。  </li>
<li>eax   0534D4150h(‘SMAP’)  </li>
<li>es:di  返回的地址范围描述符结构指针，和输入值相同。  </li>
<li>ecx BIOS填充在地址范围描述符中的字节数量，被BIOS所返回的最小值是20字节。  </li>
<li>ebx  这里放置着为等到下一个地址描述符所需要的后续值，这个值得实际形势依赖于具体的BIOS的实现，调用者不必关心它的具体形式，自需在下一次迭代时将其原封不动地放置到ebx中，就可以通过它获取下一个地址范围描述符。如果它的值为0，并且CF没有进位，表示它是最后一个地址范围描述符。  </li>
</ul>
<p>由于一个物理页需要占用一个Page结构的空间，Page结构在设计时须尽可能小，以减少对内存的占用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span>                       <span class="comment">// 描述了一个Page</span></span><br><span class="line">    <span class="type">int</span> ref;                        <span class="comment">// 这一页被页表的引用计数，一个页表项设置了一个虚拟页的映射</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;                 <span class="comment">// 描述这个Page的状态，可能每个位表示不同的意思</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> property;          <span class="comment">// property表示这个块中空闲页的数量，用到此成员变量的这个Page比较特殊，</span></span><br><span class="line">                                    <span class="comment">// 是这个连续内存空闲块地址最小的一页（即头一页， Head Page）。</span></span><br><span class="line">    <span class="type">list_entry_t</span> page_link;         <span class="comment">// 链接比它地址小和大的其他连续内存空闲块。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>flag用到了两个bit<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PG_reserved       0       <span class="comment">// 表明了是否被保留，如果被保留，则bit 0会设置位1，且不能放到空闲列表里</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PG_property       1       <span class="comment">// bit 1表示此页是否是free的，如果设置为1，表示这页是free的，可以被分配；如果设置为0，表示这页已经被分配出去了，不能被再二次分配。</span></span></span><br></pre></td></tr></table></figure><br>总结来说：一个页，里边有各种属性和双向链表的指针段</p>
<ul>
<li>ref表示这个页被页表的引用记数，是映射此物理页的虚拟页个数。一旦某页表中有一个页表项设置了虚拟页到这个Page管理的物理页的映射关系，就会把Page的ref加一。反之，若是解除，那就减一。</li>
<li>flags表示此物理页的状态标记，有两个标志位，第一个表示是否被保留，如果被保留了则设为1（比如内核代码占用的空间）。第二个表示此页是否是free的。如果设置为1，表示这页是free的，可以被分配；如果设置为0，表示这页已经被分配出去了，不能被再二次分配。</li>
<li>property用来记录某连续内存空闲块的大小，这里需要注意的是用到此成员变量的这个Page一定是连续内存块的开始地址（第一页的地址）。</li>
<li>page_link是便于把多个连续内存空闲块链接在一起的双向链表指针，连续内存空闲块利用第一个页的成员变量page_link来链接比它地址小和大的其他连续内存空闲块，用到这个成员变量的是这个块的地址最小的一页。</li>
</ul>
<p>下面简单看看mm/pmm.c中的pmm_init()<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pmm_init - initialize the physical memory management */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> *<span class="title">memmap</span> =</span> (<span class="keyword">struct</span> e820map *)(<span class="number">0x8000</span> + KERNBASE);</span><br><span class="line">    <span class="type">uint64_t</span> maxpa = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;e820map:\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; memmap-&gt;nr_map; i ++) &#123;</span><br><span class="line">        <span class="type">uint64_t</span> begin = memmap-&gt;<span class="built_in">map</span>[i].addr, end = begin + memmap-&gt;<span class="built_in">map</span>[i].size;</span><br><span class="line">        cprintf(<span class="string">&quot;  memory: %08llx, [%08llx, %08llx], type = %d.\n&quot;</span>,</span><br><span class="line">                memmap-&gt;<span class="built_in">map</span>[i].size, begin, end - <span class="number">1</span>, memmap-&gt;<span class="built_in">map</span>[i].type);</span><br><span class="line">        <span class="keyword">if</span> (memmap-&gt;<span class="built_in">map</span>[i].type == E820_ARM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxpa &lt; end &amp;&amp; begin &lt; KMEMSIZE) &#123;</span><br><span class="line">                maxpa = end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxpa &gt; KMEMSIZE) &#123;</span><br><span class="line">        maxpa = KMEMSIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line"></span><br><span class="line">    npage = maxpa / PGSIZE;</span><br><span class="line">    <span class="comment">//起始物理内存地址位0，所以需要管理的页个数为npage，需要管理的所有页的大小位sizeof(struct Page)*npage</span></span><br><span class="line">    pages = (<span class="keyword">struct</span> Page *)ROUNDUP((<span class="type">void</span> *)end, PGSIZE);</span><br><span class="line">    <span class="comment">// pages的地址，最末尾地址按照页大小取整。</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npage; i ++) &#123;</span><br><span class="line">        SetPageReserved(pages + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前的这些页设置为已占用的</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uintptr_t</span> freemem = PADDR((<span class="type">uintptr_t</span>)pages + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page) * npage);</span><br><span class="line">    <span class="comment">// 之前设置了占用的页，那空闲的页就是从（pages+sizeof(struct Page)*npage）以上开始的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; memmap-&gt;nr_map; i ++) &#123;</span><br><span class="line">        <span class="type">uint64_t</span> begin = memmap-&gt;<span class="built_in">map</span>[i].addr, end = begin + memmap-&gt;<span class="built_in">map</span>[i].size;</span><br><span class="line">        <span class="keyword">if</span> (memmap-&gt;<span class="built_in">map</span>[i].type == E820_ARM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; freemem) &#123;</span><br><span class="line">                begin = freemem;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (end &gt; KMEMSIZE) &#123;</span><br><span class="line">                end = KMEMSIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">                begin = ROUNDUP(begin, PGSIZE);</span><br><span class="line">                end = ROUNDDOWN(end, PGSIZE);</span><br><span class="line">                <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);</span><br><span class="line">                    <span class="comment">// 通过调用本函数进行空闲的标记</span></span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>SetPageReserved表示把物理地址对应的Page结构中的flags标志设置为PG_reserved ，表示这些页已经被使用了，将来不能被用于分配。而init_memmap函数把空闲物理页对应的Page结构中的flags和引用计数ref清零，并加到free_area.free_list指向的双向列表中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pmm_manager</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;                                 <span class="comment">//物理内存页管理器的名字</span></span><br><span class="line">    <span class="type">void</span> (*init)(<span class="type">void</span>);                               <span class="comment">//初始化内存管理器</span></span><br><span class="line">    <span class="type">void</span> (*init_memmap)(<span class="keyword">struct</span> Page *base, <span class="type">size_t</span> n); <span class="comment">//初始化管理空闲内存页的数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *(*<span class="title">alloc_pages</span>)(<span class="title">size_t</span> <span class="title">n</span>);</span>            <span class="comment">//分配n个物理内存页</span></span><br><span class="line">    <span class="type">void</span> (*free_pages)(<span class="keyword">struct</span> Page *base, <span class="type">size_t</span> n);  <span class="comment">//释放n个物理内存页</span></span><br><span class="line">    <span class="type">size_t</span> (*nr_free_pages)(<span class="type">void</span>);                    <span class="comment">//返回当前剩余的空闲页数</span></span><br><span class="line">    <span class="type">void</span> (*check)(<span class="type">void</span>);                              <span class="comment">//用于检测分配/释放实现是否正确</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">free_area_t</span> - 维护一个双向链表记录没有用到的Page。</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">list_entry_t</span> free_list;         <span class="comment">// 整个双向链表的头节点</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr_free;           <span class="comment">// 表示空闲页的数量</span></span><br><span class="line">&#125; <span class="type">free_area_t</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> <span class="title">list_entry_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">类似Linux里的双向链表，这只是指针部分，数据部分在其他定义里</span><br></pre></td></tr></table></figure>
<h2 id="练习1-实现first-fit连续物理内存分配算法"><a href="#练习1-实现first-fit连续物理内存分配算法" class="headerlink" title="练习1 实现first-fit连续物理内存分配算法"></a>练习1 实现first-fit连续物理内存分配算法</h2><p>重写函数: default_init, default_init_memmap,default_alloc_pages, default_free_pages。<br>在实现first_fit的回收函数时，注意连续地址空间之间的合并操作。在遍历空闲页块链表时，需要按照空闲块起始地址来排序，形成一个有序的的链表。</p>
<p>首次适应算法（First Fit）：该算法从空闲分区链首开始查找，直至找到一个能满足其大小要求的空闲分区为止。然后再按照需求的大小，从该分区中划出一块内存分配给请求者，余下的空闲分区仍留在空闲分区链中。多使用内存中低地址部分的空闲区，在高地址部分的空闲区很少被利用，从而保留了高地址部分的空闲区。显然为以后到达的大作业分配大的内存空间创造了条件。但是低地址部分不断被划分，留下许多难以利用、很小的空闲区，每次查找又都从低地址部分开始，会增加查找的开销。  </p>
<p>在First Fit算法中，分配器维护一个空闲块列表（free表）。一旦收到内存分配请求，<br>它遍历列表找到第一个满足的块。如果所选块明显大于请求的块，则分开，其余的空间将被添加到列表中下一个free块中。</p>
<ul>
<li>准备：实现First Fit我们需要使用链表管理空闲块，free_area_t被用来管理free块，首先，找到list.h中的”struct list”。结构”list”是一个简单的双向链表实现。使用”list_init”，”list_add”（”list_add_after”和”list_add_before”），”list_del”，<br>“list_next”，”list_prev”。有一个棘手的方法是将一般的”list”结构转换为一个特殊结构（如struct”page”），使用以下宏：”le2page”（在memlayout.h中）。</li>
<li>“default_init”：重用例子中的”default_init”函数来初始化”free_list”并将”nr_free”设置为0。”free_list”用于记录空闲内存块，”nr_free”是可用内存块的总数。</li>
<li>“default_init_memmap”：调用栈为”kern_init” -&gt; “pmm_init” -&gt; “page_init” -&gt; “init_memmap” -&gt; “pmm_manager” -&gt; “init_memmap”。此函数用于初始化空闲块（使用参数”addr_base”，”page_mumber”）。为了初始化一个空闲块，首先，应该在这个空闲块中初始化每个页面（在memlayout.h中定义）。这个程序包括：<ul>
<li>设置”p -&gt; flags”的’PG_property’位，表示该页面为有效。在函数”pmm_init”（在pmm.c中），”p-&gt; flags”的位’PG_reserved”已经设置好了。</li>
<li>如果此页面是free的且不是free区块的第一页，”p-&gt; property”应该设置为0。</li>
<li>如果此页面是free的且是free区块的第一页，”p-&gt; property”应该设置为本空闲块的总页数。</li>
</ul>
</li>
<li>“default_alloc_pages”：在空闲列表中搜索第一个空闲块（块大小&gt;=n），返回该块的地址作为所需的地址.</li>
</ul>
<p>空闲页管理链表的初始化：把free_list的双向链表中的指针都指向自己，且计数器为0<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">default_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;free_list);</span><br><span class="line">    nr_free = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_init</span><span class="params">(<span class="type">list_entry_t</span> *elm)</span> &#123;</span><br><span class="line">    elm-&gt;prev = elm-&gt;next = elm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化空闲页链表，初始化每一个空闲页，然后计算空闲页的总数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">default_init_memmap</span><span class="params">(<span class="keyword">struct</span> Page *base, <span class="type">size_t</span> n)</span> &#123;   </span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> base;</span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123;</span><br><span class="line">        assert(PageReserved(p));</span><br><span class="line">        <span class="comment">//这个页是否为保留页,PageReserved(p)返回true才会继续，如果返回true了，说明是保留页</span></span><br><span class="line">        <span class="comment">//设置标志位</span></span><br><span class="line">        p-&gt;flags = <span class="number">0</span>；</span><br><span class="line">        SetPageProperty(p);</span><br><span class="line">        p-&gt;property = <span class="number">0</span>;    <span class="comment">//应该只有第一个页的这个参数有用</span></span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);<span class="comment">//清空引用，现在是没有虚拟内存引用它的</span></span><br><span class="line">        list_add_before(&amp;free_list, &amp;(p-&gt;page_link));<span class="comment">//插入空闲页的链表里面</span></span><br><span class="line">    &#125;</span><br><span class="line">    nr_free += n;  <span class="comment">//连续有n个空闲块，空闲链表的个数加n</span></span><br><span class="line">    base-&gt;property=n; <span class="comment">//连续内存空闲块的大小为n，属于物理页管理链表</span></span><br><span class="line">    <span class="comment">//所有的页都在这个双向链表里且只有第0个页有这个块的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>default_alloc_pages从空闲页链表中查找n个空闲页，如果成功，返回第一个页表的地址。遍历空闲链表，一旦发现有大于等于n的连续空闲页块，便将这n个页从空闲页链表中取出，同时使用SetPageReserved和ClearPageProperty表示该页为使用状态，同时如果该连续页的数目大于n，则从第n+1开始截断，之后为截断的块，重新计算相应的property的值。在贴代码之前先说说几个宏。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将这个le转换成一个Page */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> le2page(le, member)                 \</span></span><br><span class="line"><span class="meta">    to_struct((le), struct Page, member)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * to_struct - get the struct from a ptr</span></span><br><span class="line"><span class="comment"> * @ptr:    a struct pointer of member</span></span><br><span class="line"><span class="comment"> * @type:   the type of the struct this is embedded in</span></span><br><span class="line"><span class="comment"> * @member: the name of the member within the struct</span></span><br><span class="line"><span class="comment"> * 一般用的时候传进来的type是Page类型的，ptr是这个（Page+双向链表的两个指针）块的双向链表指针的开始地址。offsetof算出了page_link在Page中的偏移值，ptr减去双向链表第一个指针的偏移量得到了这个Page的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> to_struct(ptr, type, member)                               \</span></span><br><span class="line"><span class="meta">    ((type *)((char *)(ptr) - offsetof(type, member)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the offset of &#x27;member&#x27; relative to the beginning of a struct type */</span></span><br><span class="line"><span class="number">0</span>不代表具体地址，这个offsetof代表这个member在这个type中的偏移值</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(type, member)                                      \</span></span><br><span class="line"><span class="meta">    ((size_t)(&amp;((type *)0)-&gt;member))</span></span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> Page * <span class="title function_">default_alloc_pages</span><span class="params">(<span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; nr_free) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n 一定要大于0，且n要小于当前可用的空闲块数</span></span><br><span class="line">    <span class="type">list_entry_t</span> *le, *len;</span><br><span class="line">    le = &amp;free_list;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>=</span><span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>((le=list_next(le)) != &amp;free_list) &#123;</span><br><span class="line">        p = le2page(le, page_link);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;property&gt;=n)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在free_list里遍历每一页，用le2page转换成Page</span></span><br><span class="line">    <span class="comment">//如果找到了一个property大于n的就说明找到了这个符合要求的块</span></span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            len = list_next(le);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span> =</span> le2page(le, page_link);</span><br><span class="line">            SetPageReserved(pp);</span><br><span class="line">            ClearPageProperty(pp);</span><br><span class="line">            list_del(le);</span><br><span class="line">            le = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果我现在找到的块是大于n的，那就拆开</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;property&gt;n)&#123;</span><br><span class="line">            (le2page(le,page_link))-&gt;property = p-&gt;property - n;</span><br><span class="line">        &#125;</span><br><span class="line">        ClearPageProperty(p);</span><br><span class="line">        SetPageReserved(p);</span><br><span class="line">        nr_free -= n;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>default_free_pages将base为起始地址的n个页面放回到free_list中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">default_free_pages</span><span class="params">(<span class="keyword">struct</span> Page *base, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="type">list_entry_t</span> *le = &amp;free_list;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> base;</span><br><span class="line">    <span class="comment">//找到比base大的页面地址</span></span><br><span class="line">    <span class="keyword">while</span>((le=list_next(le)) != &amp;free_list)&#123;</span><br><span class="line">        p = le2page(le,page_link);</span><br><span class="line">        <span class="keyword">if</span>(p &gt; base)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在找到的p之前逐个插入</span></span><br><span class="line">    <span class="keyword">for</span>(p = base; p &lt; base + n; p ++)&#123;</span><br><span class="line">       list_add_before(le,&amp;(p-&gt;page_link));</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;flags=<span class="number">0</span>;</span><br><span class="line">    set_page_ref(base,<span class="number">0</span>);</span><br><span class="line">    ClearPageProperty(base);</span><br><span class="line">    SetPageProperty(base);</span><br><span class="line">    base-&gt;property = n;</span><br><span class="line">    <span class="comment">// 清空flag的信息，清空引用的信息，清空property信息，设置这个Page又是可以被引用的了</span></span><br><span class="line">    <span class="comment">// 当前的base又是n个空闲块的头</span></span><br><span class="line">    p = le2page(le,page_link);</span><br><span class="line">    <span class="keyword">if</span>(base+n==p)&#123;</span><br><span class="line">        base-&gt;property+=p-&gt;property;</span><br><span class="line">        p-&gt;property=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看是不是可以跟后边的块恰好连在一起，如果连在一起的话就可以合并了</span></span><br><span class="line">    le=list_prev(&amp;(base-&gt;page_link));</span><br><span class="line">    p = le2page(le, page_link);</span><br><span class="line">    <span class="comment">//看是不是可以跟前边的连在一起，如果可以的话这个base就可以把property设成0了</span></span><br><span class="line">    <span class="keyword">if</span>(le!=&amp;free_list &amp;&amp; p==base<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(le!=&amp;free_list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;property)&#123;</span><br><span class="line">                p-&gt;property+=base-&gt;property;</span><br><span class="line">                base-&gt;property=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            le = list_prev(le);</span><br><span class="line">            p=le2page(le,page_link);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nr_free +=n;</span><br><span class="line">    cprintf(<span class="string">&quot;release %d page,last %d.\n&quot;</span>,n,nr_free);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行中出现提示，表明本题成功：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">release 1 page,last 1.</span><br><span class="line">release 1 page,last 2.</span><br><span class="line">release 1 page,last 3.</span><br><span class="line">release 1 page,last 1.</span><br><span class="line">release 1 page,last 32291.</span><br><span class="line">release 1 page,last 32292.</span><br><span class="line">release 1 page,last 32293.</span><br><span class="line">release 3 page,last 3.</span><br><span class="line">release 1 page,last 1.</span><br><span class="line">release 3 page,last 4.</span><br><span class="line">release 1 page,last 4.</span><br><span class="line">release 2 page,last 4.</span><br><span class="line">release 1 page,last 5.</span><br><span class="line">release 5 page,last 32293.</span><br><span class="line">check_alloc_page() succeeded!</span><br></pre></td></tr></table></figure><br>first_fit有一种改进，next_fit，第一次找到之后不暂停，第二次找到之后才真正给分配空间。修改比较简单，第一次找到之后记一个flag，下次再找到就可以分配了。</p>
<h2 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h2><h3 id="系统执行中的地址映射。"><a href="#系统执行中的地址映射。" class="headerlink" title="系统执行中的地址映射。"></a>系统执行中的地址映射。</h3><p>mooc中讲到了在段页式管理机制下运行这整个过程中，虚拟地址到物理地址的映射产生了多次变化，实现了最终的段页式映射关系：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virt addr = linear addr = phy addr + 0xC0000000  </span><br></pre></td></tr></table></figure></p>
<p>第一个阶段（<strong>开启保护模式，创建启动段表</strong>）是bootloader阶段，即从bootloader的start函数（在boot/bootasm.S中）到执行ucore kernel的kern_entry函数之前，其虚拟地址、线性地址以及物理地址之间的映射关系与lab1的一样，即：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virt addr = linear addr = phy addr  </span><br></pre></td></tr></table></figure></p>
<p>第二个阶段（<strong>创建初始页目录表，开启分页模式</strong>）从kern_entry函数开始，到pmm_init函数被执行之前。通过几条汇编指令（在kern/init/entry.S中）使能分页机制，主要做了两件事：</p>
<ul>
<li>通过movl %eax, %cr3指令把页目录表的起始地址存入CR3寄存器中；</li>
<li>通过movl %eax, %cr0指令把cr0中的CR0_PG标志位设置上。</li>
</ul>
<p>在此之后，进入了分页机制，地址映射关系如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virt addr = linear addr = phy addr # 线性地址在0~4MB之内三者的映射关系</span><br><span class="line">virt addr = linear addr = phy addr + 0xC0000000 # 线性地址在0xC0000000~0xC0000000+4MB之内三者的映射关系</span><br></pre></td></tr></table></figure><br>仅仅比第一个阶段增加了下面一行的0xC0000000偏移的映射，并且作用范围缩小到了0~4M。在下一个节点，会将作用范围继续扩充到0~KMEMSIZE。<br>此时的内核（EIP）还在0~4M的低虚拟地址区域运行，而在之后，这个区域的虚拟内存是要给用户程序使用的。为此，需要使用一个绝对跳转来使内核跳转到高虚拟地址（代码在kern/init/entry.S中）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    # update eip</span><br><span class="line">    # now, eip = 0x1.....</span><br><span class="line">    leal next, %eax</span><br><span class="line">    # set eip = KERNBASE + 0x1.....</span><br><span class="line">    jmp *%eax</span><br><span class="line">next:</span><br></pre></td></tr></table></figure><br>跳转完毕后，通过把boot_pgdir[0]对应的第一个页目录表项（0~4MB）清零来取消了临时的页映射关系：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># unmap va 0 ~ 4M, it&#x27;s temporary mapping</span><br><span class="line">xorl %eax, %eax</span><br><span class="line">movl %eax, __boot_pgdir</span><br></pre></td></tr></table></figure><br>最终的地址映射关系如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lab2 stage 2: virt addr = linear addr = phy addr + 0xC0000000 # 线性地址在0~4MB之内三者的映射关系</span><br></pre></td></tr></table></figure><br>第三个阶段（<strong>完善段表和页表</strong>）从pmm_init函数被调用开始。pmm_init函数将页目录表项补充完成（从0~4M扩充到0~KMEMSIZE）。然后，更新了段映射机制，使用了一个新的段表。这个新段表除了包括内核态的代码段和数据段描述符，还包括用户态的代码段和数据段描述符以及TSS（段）的描述符。理论上可以在第一个阶段，即bootloader阶段就将段表设置完全，然后在此阶段继续使用，但这会导致内核的代码和bootloader的代码产生过多的耦合，于是就有了目前的设计。<br>这时形成了我们期望的虚拟地址、线性地址以及物理地址之间的映射关系：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lab2 stage 3: virt addr = linear addr = phy addr + 0xC0000000</span><br></pre></td></tr></table></figure></p>
<p>请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。</p>
<p>页目录项（Pag Director Entry）每一位的含义：</p>
<ul>
<li>前20位表示4K对齐的该PDE对应的页表起始位置（物理地址，该物理地址的高20位即PDE中的高20位，低12位为0）；</li>
<li>第9-11位未被CPU使用，可保留给OS使用；</li>
<li>接下来的第8位可忽略；</li>
<li>第7位用于设置Page大小，0表示4KB；</li>
<li>第6位恒为0；</li>
<li>第5位用于表示该页是否被使用过；</li>
<li>第4位设置为1则表示不对该页进行缓存；</li>
<li>第3位设置是否使用write through缓存写策略；</li>
<li>第2位表示该页的访问需要的特权级；</li>
<li>第1位表示是否允许读写；</li>
<li>第0位为该PDE的存在位；</li>
</ul>
<p>页表项（PTE）中的每项的含义：</p>
<ul>
<li>高20位与PDE相似的，用于表示该PTE指向的物理页的物理地址；</li>
<li>9-11位保留给OS使用；</li>
<li>7-8位恒为0；</li>
<li>第6位表示该页是否为dirty，即是否需要在swap out的时候写回外存；</li>
<li>第5位表示是否被访问；</li>
<li>3-4位恒为0；</li>
<li>0-2位分别表示存在位、是否允许读写、访问该页需要的特权级；</li>
</ul>
<p>PTE和PDE都有一些保留位供操作系统使用，ucore利用保留位来完成一些其他的内存管理相关的算法。</p>
<p>当ucore执行过程中出现了页访问异常，硬件需要完成的事情分别如下：</p>
<ul>
<li>将发生错误的线性地址保存在cr2寄存器中;</li>
<li>在中断栈中依次压入EFLAGS，CS, EIP，以及页访问异常码error code，如果pgfault是发生在用户态，则还需要先压入ss和esp，并且切换到内核栈；</li>
<li>根据中断描述符表查询到对应page fault的处理例程地址如后，跳转到对应处执行。</li>
</ul>
<h3 id="建立虚拟页和物理页帧的地址映射关系"><a href="#建立虚拟页和物理页帧的地址映射关系" class="headerlink" title="建立虚拟页和物理页帧的地址映射关系"></a>建立虚拟页和物理页帧的地址映射关系</h3><p>整个页目录表和页表所占空间大小取决与二级页表要管理和映射的物理页数。<br>假定当前物理内存0~16MB，每物理页（也称Page Frame）大小为4KB，则有4096个物理页，也就意味这有4个页目录项和4096个页表项需要设置。一个页目录项（Page Directory Entry，PDE）和一个页表项（Page Table Entry，PTE）占4B。即使是4个页目录项也需要一个完整的页目录表（占4KB）。而4096个页表项需要16KB（即4096*4B）的空间，也就是4个物理页，16KB的空间。所以对16MB物理页建立一一映射的16MB虚拟页，需要4+1=5个物理页，即20KB的空间来形成二级页表。  </p>
<p>把0~KERNSIZE（明确ucore设定实际物理内存<strong>不能超过KERNSIZE值，即0x38000000字节，896MB，3670016个物理页</strong>）的物理地址一一映射到页目录项和页表项的内容，其大致流程如下：</p>
<ol>
<li>指向页目录表的指针已存储在boot_pgdir变量中。</li>
<li>映射0~4MB的首个页表已经填充好。</li>
<li>调用boot_map_segment函数进一步建立一一映射关系，具体处理过程以页为单位进行设置，即:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linear addr = phy addr + 0xC0000000</span><br></pre></td></tr></table></figure>
<p>设一个32bit线性地址la有一个对应的32bit物理地址pa，如果在以la的高10位为索引值的页目录项中的存在位（PTE_P）为0，表示缺少对应的页表空间，则可通过alloc_page获得一个空闲物理页给页表，页表起始物理地址是按4096字节对齐的，这样填写页目录项的内容为：</p>
<blockquote>
<p>页目录项内容 = (页表起始物理地址 &amp; ~0x0FFF) | PTE_U | PTE_W | PTE_P</p>
</blockquote>
<p>进一步对于页表中以线性地址la的中10位为索引值对应页表项的内容为：</p>
<blockquote>
<p>页表项内容 = (pa &amp; ~0x0FFF) | PTE_P | PTE_W</p>
</blockquote>
<p>其中：</p>
<blockquote>
<p>PTE_U：位3，表示用户态的软件可以读取对应地址的物理内存页内容<br>PTE_W：位2，表示物理内存页内容可写<br>PTE_P：位1，表示物理内存页存在  </p>
</blockquote>
<p>ucore的内存管理经常需要查找页表：<br>给定一个虚拟地址，找出这个虚拟地址在二级页表中对应的项。通过更改此项的值可以方便地将虚拟地址映射到另外的页上。可完成此功能的这个函数是get_pte函数。它的原型为<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create)</span><br></pre></td></tr></table></figure></p>
<p>这里涉及到三个类型<strong>pte_t</strong>、<strong>pde_t</strong>和<strong>uintptr_t</strong>。这三个都是unsigned int类型。  </p>
<ul>
<li>pde_t：page directory entry，一级页表的表项。  </li>
<li>pte_t：page table entry，表示二级页表的表项。  </li>
<li>uintptr_t：表示为线性地址，由于段式管理只做直接映射，所以它也是逻辑地址。  </li>
<li>pgdir：给出页表起始地址。通过查找这个页表，我们需要给出二级页表中对应项的地址。  </li>
</ul>
<p>可以在需要时再添加对应的二级页表。如果在查找二级页表项时，发现对应的二级页表不存在，则需要<strong>根据create参数的值来处理是否创建新的二级页表</strong>。如果create参数为0，则get_pte返回NULL；如果create参数不为0，则get_pte需要申请一个新的物理页（通过alloc_page来实现，可在mm/pmm.h中找到它的定义），再在一级页表中添加页目录项指向表示二级页表的新物理页。  </p>
<blockquote>
<p>注意，新申请的页必须全部设定为零，因为这个页所代表的虚拟地址都没有被映射。  </p>
</blockquote>
<p>当建立从一级页表到二级页表的映射时，需要注意设置控制位。这里应该设置同时设置上PTE_U、PTE_W和PTE_P（定义可在mm/mmu.h）。如果原来就有二级页表，或者新建立了页表，则只需返回对应项的地址即可。  </p>
<p>虚拟地址只有映射上了物理页才可以正常的读写。在完成映射物理页的过程中，除了要在页表的对应表项上填上相应的物理地址外，还要设置正确的控制位。  </p>
<p>只有当一级二级页表的项都设置了用户写权限后，用户才能对对应的物理地址进行读写。由于一个物理页可能被映射到不同的虚拟地址上去（譬如一块内存在不同进程间共享），<strong>当这个页需要在一个地址上解除映射时，操作系统不能直接把这个页回收，而是要先看看它还有没有映射到别的虚拟地址上</strong>。这是通过查找管理该物理页的Page数据结构的成员变量ref（用来表示虚拟页到物理页的映射关系的个数）来实现的，如果ref为0了，表示没有虚拟页到物理页的映射关系了，就可以把这个物理页给回收了，从而这个物理页是free的了，可以再被分配。  </p>
<p>page_insert函数将物理页映射在了页表上。可参看page_insert函数的实现来了解ucore内核是如何维护这个变量的。当不需要再访问这块虚拟地址时，可以把这块物理页回收并在将来用在其他地方。取消映射由page_remove来做，这其实是page_insert的逆操作。<br>建立好一一映射的二级页表结构后，由于分页机制在前一节所述的前两个阶段已经开启，分页机制到此初始化完毕。当执行完毕gdt_init函数后，新的段页式映射已经建立好了。</p>
<p>预备知识copy完了，上练习二和练习三</p>
<h3 id="练习二代码"><a href="#练习二代码" class="headerlink" title="练习二代码"></a>练习二代码</h3><p><strong>预备知识不够用了</strong><br>上mmu.h的代码读读<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A linear address &#x27;la&#x27; has a three-part structure as follows:</span><br><span class="line">+--------10------+-------10-------+---------12----------+</span><br><span class="line">| Page Directory |   Page Table   | Offset within Page  |</span><br><span class="line">|      Index     |     Index      |                     |</span><br><span class="line">+----------------+----------------+---------------------+</span><br><span class="line"> \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/</span><br><span class="line"> \----------- PPN(la) -----------/</span><br><span class="line">The PDX, PTX, PGOFF, and PPN macros decompose linear addresses as shown.</span><br><span class="line">To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),</span><br><span class="line">use PGADDR(PDX(la), PTX(la), PGOFF(la)).</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get_pte - get Page Table Entry and return the kernel virtual address of this Page Table Entry for la</span></span><br><span class="line"><span class="comment">//        - if the PT contians this Page Table Entry didn&#x27;t exist, alloc a page for PT</span></span><br><span class="line"><span class="comment">// parameter:</span></span><br><span class="line"><span class="comment">//  pgdir:  the kernel virtual base address of PDT （页目录表的入口）</span></span><br><span class="line"><span class="comment">//  la:     the linear address need to map         （线性地址）</span></span><br><span class="line"><span class="comment">//  create: a logical value to decide if alloc a page for PT</span></span><br><span class="line"><span class="comment">// return vaule: the kernel virtual address of this pte （返回这个页表项的虚拟地址）</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">get_pte</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> la, <span class="type">bool</span> create)</span> &#123;</span><br><span class="line"><span class="comment">/*   *   使用KADDR()获得物理地址</span></span><br><span class="line"><span class="comment">     *   PDX(la) = 虚拟地址la在page directory entry 的 index</span></span><br><span class="line"><span class="comment">     *   KADDR(pa) : takes a physical address and returns the corresponding kernel virtual address.</span></span><br><span class="line"><span class="comment">     *   set_page_ref(page,1) : means the page be referenced by one time，这一页被引用了</span></span><br><span class="line"><span class="comment">     *   page2pa(page): get the physical address of memory which this (struct Page *) page manages</span></span><br><span class="line"><span class="comment">     *                  得到这个页管理的内存的物理地址</span></span><br><span class="line"><span class="comment">     *   struct Page * alloc_page() : allocation a page</span></span><br><span class="line"><span class="comment">     *   memset(void *s, char c, size_t n) : sets the first n bytes of the memory area pointed by s</span></span><br><span class="line"><span class="comment">     *                                       to the specified value c.</span></span><br><span class="line"><span class="comment">     * DEFINEs:</span></span><br><span class="line"><span class="comment">     *   PTE_P           0x001                   // page table/directory entry flags bit : Present</span></span><br><span class="line"><span class="comment">     *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable</span></span><br><span class="line"><span class="comment">     *   PTE_U           0x004                   // page table/directory entry flags bit : User can access</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pde_t</span> *pdep = &amp;pgdir[PDX(la)];       <span class="comment">// (1) find page directory entry</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!(*pdep &amp; PTE_P) ) &#123;             <span class="comment">// (2) check if entry is not present</span></span><br><span class="line">        <span class="keyword">if</span> (!create || (page = alloc_page()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     	&#125;	                             <span class="comment">// (3) check if creating is needed, then alloc page for page table</span></span><br><span class="line">        <span class="comment">// CAUTION: this page is used for page table, not for common data page</span></span><br><span class="line">        set_page_ref(page, <span class="number">1</span>);           <span class="comment">// (4) set page reference</span></span><br><span class="line">        <span class="type">uintptr_t</span> pa = page2pa(page);    <span class="comment">// (5) get linear address of page</span></span><br><span class="line">        <span class="built_in">memset</span>(KADDR(pa),<span class="number">0</span>,PGSIZE);      <span class="comment">// (6) clear page content using memset</span></span><br><span class="line">        *pdep = pa | PTE_U | PTE_W | PTE_P;<span class="comment">// (7) set page directory entry&#x27;s permission</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;((<span class="type">pte_t</span> *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];  <span class="comment">// (8) return page table entry</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习三"><a href="#练习三" class="headerlink" title="练习三"></a>练习三</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//page_remove_pte - free an Page sturct which is related linear address la</span><br><span class="line">//                - and clean(invalidate) pte which is related linear address la</span><br><span class="line">//note: PT is changed, so the TLB need to be invalidate</span><br><span class="line">static inline void</span><br><span class="line">page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) &#123;</span><br><span class="line">    /* LAB2 EXERCISE 3: YOUR CODE</span><br><span class="line">     *</span><br><span class="line">     * Please check if ptep is valid, and tlb must be manually updated if mapping is updated</span><br><span class="line">     *</span><br><span class="line">     * Maybe you want help comment, BELOW comments can help you finish the code</span><br><span class="line">     *</span><br><span class="line">     * Some Useful MACROs and DEFINEs, you can use them in below implementation.</span><br><span class="line">     * MACROs or Functions:</span><br><span class="line">     *   struct Page *page pte2page(*ptep): get the according page from the value of a ptep</span><br><span class="line">     *   free_page : free a page</span><br><span class="line">     *   page_ref_dec(page) : decrease page-&gt;ref. NOTICE: ff page-&gt;ref == 0 , then this page should be free.</span><br><span class="line">     *   tlb_invalidate(pde_t *pgdir, uintptr_t la) : Invalidate a TLB entry, but only if the page tables being</span><br><span class="line">     *                        edited are the ones currently in use by the processor.</span><br><span class="line">     * DEFINEs:</span><br><span class="line">     *   PTE_P           0x001                   // page table/directory entry flags bit : Present</span><br><span class="line">     */</span><br><span class="line">#if 0</span><br><span class="line">    if (0) &#123;                      //(1) check if this page table entry is present</span><br><span class="line">        struct Page *page = NULL; //(2) find corresponding page to pte</span><br><span class="line">                                  //(3) decrease page reference</span><br><span class="line">                                  //(4) and free this page when page reference reachs 0</span><br><span class="line">                                  //(5) clear second page table entry</span><br><span class="line">                                  //(6) flush tlb</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    if (*ptep &amp; PTE_P) &#123; // 确保传进来的二级页表时可用的</span><br><span class="line">        struct Page *page = pte2page(*ptep);// 获取页表项对应的物理页的Page结构</span><br><span class="line">        if (page_ref_dec(page) == 0) &#123;	    // page_ref_dec被用于page-&gt;ref自减1，</span><br><span class="line">        									// 如果返回值是0，那么就说明不存在任何虚拟页指向该物理页，释放该物理页</span><br><span class="line">            free_page(page);</span><br><span class="line">        &#125;</span><br><span class="line">        *ptep = 0;					 // 将PTE的映射关系清空</span><br><span class="line">        tlb_invalidate(pgdir, la);   // 刷新TLB，确保TLB的缓存中不会有错误的映射关系</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？</span><br><span class="line"></span><br><span class="line">存在对应关系：由于页表项中存放着对应的物理页的物理地址，因此可以通过这个物理地址来获取到对应到的Page数组的对应项，具体做法为将物理地址除以一个页的大小，然后乘上一个Page结构的大小获得偏移量，使用偏移量加上Page数组的基地址皆可以或得到对应Page项的地址；</span><br><span class="line"></span><br><span class="line">如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题。</span><br><span class="line"></span><br><span class="line">由于在完全启动了ucore之后，虚拟地址和线性地址相等，都等于物理地址加上0xc0000000，如果需要虚拟地址和物理地址相等，可以考虑更新gdt，更新段映射，使得virtual address = linear address - 0xc0000000，这样的话就可以实现virtual address = physical address；</span><br><span class="line">reference：https://www.jianshu.com/p/abbe81dfe016</span><br></pre></td></tr></table></figure></p>
<h1 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>在实验二的基础上，借助页表机制和实验一中涉及的中断异常处理机制，完成Pgfault异常处理和FIFO页替换算法的实现，结合磁盘提供的缓存空间，从而能够支持虚存管理，提供一个比实际物理内存空间“更大”的虚拟内存空间给系统使用。<br>这个实验与实际操作系统中的实现比较起来要简单，不过需要了解实验一和实验二的具体实现。实际操作系统系统中的虚拟内存管理设计与实现是相当复杂的，涉及到与进程管理系统、文件系统等的交叉访问。</p>
<h2 id="简单原理"><a href="#简单原理" class="headerlink" title="简单原理"></a>简单原理</h2><blockquote>
<p>copy from gitbook<br>通过内存地址虚拟化，可以使得软件在没有访问某虚拟内存地址时不分配具体的物理内存，而只有在实际访问某虚拟内存地址时，操作系统再动态地分配物理内存，建立虚拟内存到物理内存的页映射关系，这种技术称为按需分页（demand paging）。  </p>
<p>把不经常访问的数据所占的内存空间临时写到硬盘上，这样可以腾出更多的空闲内存空间给经常访问的数据；当CPU访问到不经常访问的数据时，再把这些数据从硬盘读入到内存中，这种技术称为页换入换出（page swap in/out）。这种内存管理技术给了程序员更大的内存“空间”，从而可以让更多的程序在内存中并发运行。</p>
</blockquote>
<p>参考ucore总控函数kern_init的代码，在调用完成虚拟内存初始化的vmm_init函数之前，需要首先调用pmm_init函数完成物理内存的管理，调用pic_init函数完成中断控制器的初始化，调用idt_init函数完成中断描述符表的初始化。  </p>
<p>在调用完idt_init函数之后，将进一步调用新函数<strong>vmm_init、ide_init、swap_init</strong>。  </p>
<p>do_pgfault函数会申请一个空闲物理页，并建立好虚实映射关系，从而使得这样的“合法”虚拟页有实际的物理页帧对应。  </p>
<p>ide_init就是完成对用于页换入换出的硬盘（简称swap硬盘）的初始化工作。完成ide_init函数后，ucore就可以对这个swap硬盘进行读写操作了。</p>
<p>vmm设计包括两部分：mm_struct（mm）和vma_struct（vma）。mm是具有相同PDT的连续虚拟内存区域集的内存管理器。 vma是一个连续的虚拟内存区域。 vma中存在线性链接列表，mm的vma的redblack链接列表。（redblack是啥？）</p>
<p>建立mm_struct和vma_struct数据结构。当访问内存产生pagefault异常时，可获得访问的内存的方式（读或写）以及具体的虚拟内存地址，这样ucore就可以查询此地址，看是否属于vma_struct数据结构中描述的合法地址范围中，如果在，则可根据具体情况进行请求调页/页换入换出处理；如果不在，则报错。</p>
<p>两种数据结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 链接所有属于同一页目录表的虚拟内存空间</span></span><br><span class="line">    <span class="type">list_entry_t</span> mmap_list;</span><br><span class="line">    <span class="comment">// 指向当前正在使用的虚拟内存空间，直接使用这个指针就能找到下一次要用到的虚拟空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span></span><br><span class="line">    <span class="type">pde_t</span> *pgdir; <span class="comment">// 第一级页表的起始地址，即页目录表项PDT。通过访问pgdir可以查找某虚拟地址对应的页表项是否存在以及页表项的属性等</span></span><br><span class="line">    <span class="type">int</span> map_count; <span class="comment">// 记录了链接了的vma_struct个数，共享了几次</span></span><br><span class="line">    <span class="type">void</span> *sm_priv; <span class="comment">// 指向记录页访问情况的链表头。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">// 描述应用程序对虚拟内存“需求”</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">// 指向更高抽象层次的数据结构</span></span><br><span class="line">    <span class="comment">// the set of vma using the same PDT</span></span><br><span class="line">    <span class="type">uintptr_t</span> vm_start; <span class="comment">// 连续地址虚拟内存空间的起始位置</span></span><br><span class="line">    <span class="type">uintptr_t</span> vm_end; <span class="comment">// 连续地址虚拟内存空间的结束位置</span></span><br><span class="line">    <span class="type">uint32_t</span> vm_flags; <span class="comment">// 标志属性（读/写/执行）</span></span><br><span class="line">    <span class="comment">//link将一系列虚拟内存空间连接起来</span></span><br><span class="line">    <span class="type">list_entry_t</span> list_link;</span><br><span class="line">&#125;;</span><br><span class="line">vm_flags：</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VM_READ 0x00000001 <span class="comment">//只读</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VM_WRITE 0x00000002 <span class="comment">//可读写</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VM_EXEC 0x00000004 <span class="comment">//可执行</span></span></span><br></pre></td></tr></table></figure></p>
<p>具体函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// mm_create -  alloc a mm_struct &amp; initialize it.</span><br><span class="line">struct mm_struct * mm_create(void) &#123;</span><br><span class="line">    struct mm_struct *mm = kmalloc(sizeof(struct mm_struct));</span><br><span class="line">    if (mm != NULL) &#123;</span><br><span class="line">        list_init(&amp;(mm-&gt;mmap_list));</span><br><span class="line">        mm-&gt;mmap_cache = NULL;</span><br><span class="line">        mm-&gt;pgdir = NULL;</span><br><span class="line">        mm-&gt;map_count = 0;</span><br><span class="line"></span><br><span class="line">        if (swap_init_ok) swap_init_mm(mm);</span><br><span class="line">        else mm-&gt;sm_priv = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return mm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// mm_destroy - free mm and mm internal fields</span><br><span class="line">void mm_destroy(struct mm_struct *mm) &#123;</span><br><span class="line">    list_entry_t *list = &amp;(mm-&gt;mmap_list), *le;</span><br><span class="line">    while ((le = list_next(list)) != list) &#123;</span><br><span class="line">        list_del(le);</span><br><span class="line">        kfree(le2vma(le, list_link),sizeof(struct vma_struct));  //kfree vma</span><br><span class="line">    &#125;</span><br><span class="line">    kfree(mm, sizeof(struct mm_struct)); //kfree mm</span><br><span class="line">    mm=NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>设备驱动程序或者内核模块中动态开辟内存，不是用malloc，而是kmalloc ,vmalloc，<br>释放内存用的是kfree,vfree，kmalloc函数返回的是虚拟地址(线性地址)。</p>
<p>kmalloc特殊之处在于它分配的内存是物理上连续的,这对于要进行DMA的设备十分重要。<br>而用vmalloc分配的内存只是线性地址连续,物理地址不一定连续,不能直接用于DMA。vmalloc函数的工作方式类似于kmalloc，只不过前者分配的内存虚拟地址是连续的，而物理地址则无需连续。</p>
<p>通过vmalloc获得的页必须一个一个地进行映射，效率不高， 因此，只在不得已(一般是为了获得大块内存)时使用。vmalloc函数返回一个指针，指向逻辑上连续的一块内存区，其大小至少为size。在发生错误 时，函数返回NULL。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// vma_create - 新建一个vma_struct并且初始化(地址范围： vm_start~vm_end)</span><br><span class="line">struct vma_struct * vma_create(uintptr_t vm_start, uintptr_t vm_end, uint32_t vm_flags) &#123;</span><br><span class="line">    struct vma_struct *vma = kmalloc(sizeof(struct vma_struct));</span><br><span class="line"></span><br><span class="line">    if (vma != NULL) &#123;</span><br><span class="line">        vma-&gt;vm_start = vm_start;</span><br><span class="line">        vma-&gt;vm_end = vm_end;</span><br><span class="line">        vma-&gt;vm_flags = vm_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    return vma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Page-Fault异常处理"><a href="#Page-Fault异常处理" class="headerlink" title="Page Fault异常处理"></a>Page Fault异常处理</h2><p>处理该异常主要用do_pgfault函数，当启动分页机制以后，如果一条指令或数据的虚拟地址所对应的物理页框不在内存中或者访问的类型有错误（比如写一个只读页或用户态程序访问内核态的数据等），就会发生页访问异常。产生页访问异常的原因主要有：</p>
<blockquote>
<p>目标页帧不存在（页表项全为0，即该线性地址与物理地址尚未建立映射或者已经撤销)；<br>相应的物理页帧不在内存中（页表项非空，但Present标志位=0，比如在swap分区或磁盘文件上)；<br>不满足访问权限（此时页表项P标志=1，但低权限的程序试图访问高权限的地址空间，或者有程序试图写只读页面）。</p>
</blockquote>
<p>当出现上面情况之一，那么就会产生页面page fault（#PF）异常。CPU会把产生异常的线性地址存储在CR2中，并且把表示页访问异常类型的值（简称页访问异常错误码，errorCode）保存在中断栈中。CR2是页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址。CR2用于发生页异常时报告出错信息。产生页访问异常后，CPU把引起页访问异常的线性地址装到寄存器CR2中，并给出了出错码errorCode，说明了页访问异常的类型。操作系统中对应的中断服务例程可以检查CR2的内容，从而查出线性地址空间中的哪个页引起本次异常。</p>
<p>CPU在当前<strong>内核栈</strong>保存当前被打断的程序现场，即依次压入当前被打断程序使用的EFLAGS，CS，EIP，errorCode；由于页访问异常的中断号是0xE，CPU把异常中断号0xE对应的中断服务例程的地址（vectors.S中的标号vector14处）加载到CS和EIP寄存器中，开始执行中断服务例程。</p>
<p>这时ucore开始处理异常中断，首先需要保存硬件没有保存的寄存器。在vectors.S中的标号vector14处先把中断号压入内核栈，然后再在trapentry.S中的标号__alltraps处把DS、ES和其他通用寄存器都压栈。自此，被打断的程序执行现场（context）被保存在内核栈中。接下来，在trap.c的trap函数开始了中断服务例程的处理流程，大致调用关系为：</p>
<blockquote>
<p>trap —&gt; trap_dispatch —&gt; pgfault_handler —&gt; do_pgfault</p>
</blockquote>
<p>ucore中do_pgfault函数是完成页访问异常处理的主要函数，它根据从CPU的控制寄存器CR2中获取的页访问异常的物理地址以及根据errorCode的错误类型来查找此地址是否在某个VMA的地址范围内以及是否满足正确的读写权限，如果在此范围内并且权限也正确，这认为这是一次<strong>合法访问，但没有建立虚实对应关系</strong>。所以需要分配一个空闲的内存页，并修改页表完成虚地址到物理地址的映射，刷新TLB，然后调用iret产生软中断，返回到产生页访问异常的指令处重新执行此指令。如果该虚地址不在某VMA范围内，则认为是一次非法访问。</p>
<h2 id="页面置换机制的实现"><a href="#页面置换机制的实现" class="headerlink" title="页面置换机制的实现"></a>页面置换机制的实现</h2><p>当缺页中断发生时，操作系统把应用程序当前需要的数据或代码放到内存中来，然后重新执行应用程序产生异常的访存指令。如果在把硬盘中对应的数据或代码调入内存前，操作系统发现物理内存已经没有空闲空间了，这时操作系统必须把它认为“不常用”的页换出到磁盘上去，以腾出内存空闲空间给应用程序所需的数据或代码。 </p>
<ul>
<li><p>先进先出：选择在内存中驻留时间最久的页予以淘汰。将调入内存的页按照调入的先后顺序链接成一个队列，队列头指向内存中驻留时间最久的页，队列尾指向最近被调入内存的页。因为那些常被访问的页，往往在内存中也停留得最久，结果它们因变“老”而不得不被置换出去。FIFO算法的另一个缺点是，它有一种异常现象（Belady现象），即在增加放置页的页帧的情况下，反而使页访问异常次数增多。</p>
</li>
<li><p>时钟替换算法：是LRU算法的一种近似实现。时钟页替换算法把各个页面组织成环形链表的形式，类似于一个钟的表面。然后把一个指针（简称当前指针）指向最老的那个页面，即最先进来的那个页面。另外，时钟算法需要在页表项（PTE）中设置了一位访问位来表示此页表项对应的页当前是否被访问过。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当操作系统需要淘汰页时，对当前指针指向的页所对应的页表项进行查询，如果访问位为“0”，则淘汰该页，如果该页被写过，则还要把它换出到硬盘上；如果访问位为“1”，则将该页表项的此位置“0”，继续访问下一个页。该算法近似地体现了LRU的思想，且易于实现，开销少，需要硬件支持来设置访问位。时钟页替换算法在本质上与FIFO算法是类似的，不同之处是在时钟页替换算法中跳过了访问位为1的页。</p>
</li>
<li><p>改进时钟页替换算法：在时钟置换算法中，淘汰一个页面时只考虑了页面是否被访问过，但在实际情况中，还应考虑被淘汰的页面是否被修改过。因为淘汰修改过的页面还需要写回硬盘，使得其置换代价大于未修改过的页面，所以<strong>优先淘汰没有修改的页</strong>，减少磁盘操作次数。改进的时钟置换算法除了<strong>考虑页面的访问情况，还需考虑页面的修改情况</strong>。即该算法不但希望淘汰的页面是最近未使用的页，而且还希望被淘汰的页是在主存驻留期间其页面内容未被修改过的。这需要为每一页的对应页表项内容中增加一位引用位和一位修改位。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当该页被“写”时，CPU中的MMU硬件将把修改位置“1”。这样这两位就存在四种可能的组合情况：（0，0）表示最近未被引用也未被修改，首先选择此页淘汰；（0，1）最近未被使用，但被修改，其次选择；（1，0）最近使用而未修改，再次选择；（1，1）最近使用且修改，最后选择。该算法与时钟算法相比，可进一步减少磁盘的I/O操作次数。</p>
</li>
</ul>
<h2 id="页面置换机制"><a href="#页面置换机制" class="headerlink" title="页面置换机制"></a>页面置换机制</h2><h3 id="可以被换出的页"><a href="#可以被换出的页" class="headerlink" title="可以被换出的页"></a>可以被换出的页</h3><p>只有映射到用户空间且被用户程序直接访问的页面才能被交换，被内核直接使用的内核空间的页面不能被换出！！！操作系统是执行的关键代码，需要保证运行的高效性和实时性，如果在操作系统执行过程中，发生了缺页现象，则操作系统不得不等很长时间（硬盘的访问速度比内存的访问速度慢2到3个数量级），这将导致整个系统运行低效。</p>
<p><strong>当一个Page Table Entry用来描述一般意义上的物理页时，它维护各种权限和映射关系，以及应该有PTE_P标记；但当它用来描述一个被置换出去的物理页时，它被用来维护该物理页与swap磁盘上扇区的映射关系，并且该PTE不应该由MMU将它解释成物理页映射(即没有 PTE_P 标记)</strong>。</p>
<p>与此同时对应的权限则交由mm_struct来维护，当对位于该页的内存地址进行访问的时候，必然导致 page fault，然后ucore能够根据 PTE 描述的swap项将相应的物理页重新建立起来，并根据虚存所描述的权限重新设置好 PTE 使得内存访问能够继续正常进行。</p>
<h3 id="虚存中的页与硬盘上的扇区之间的映射关系"><a href="#虚存中的页与硬盘上的扇区之间的映射关系" class="headerlink" title="虚存中的页与硬盘上的扇区之间的映射关系"></a>虚存中的页与硬盘上的扇区之间的映射关系</h3><p>一个页被换出到硬盘，则PTE最低位present位应该是0，表示虚实地址映射关系不存在，接下来7位为保留位，表示页帧号的24位地址用来表示在硬盘上的地址。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\-----------------------------  </span><br><span class="line">| offset     |       reserved       |       0       |  </span><br><span class="line">\-----------------------------  </span><br><span class="line">24 bits  &amp;nbsp;&amp;nbsp; 7 bits &amp;nbsp;&amp;nbsp; 1 bit  </span><br></pre></td></tr></table></figure></p>
<h3 id="执行换入换出的时机"><a href="#执行换入换出的时机" class="headerlink" title="执行换入换出的时机"></a>执行换入换出的时机</h3><p>当ucore或应用程序访问地址所在的页不在内存时，就会产生page fault异常，引起调用do_pgfault函数，此函数会判断产生访问异常的地址属于check_mm_struct某个vma表示的合法虚拟地址空间，且保存在硬盘swap文件中。</p>
<p>ucore目前大致有两种策略来实现换出操作，即<strong>积极换出策略</strong>和<strong>消极换出策略</strong>。积极换出策略是指操作系统周期性地（或在系统不忙的时候）主动把某些认为“不常用”的页换出到硬盘上，从而确保系统中总有一定数量的空闲页存在，这样当需要空闲页时，基本上能够及时满足需求；消极换出策略是指，只是当试图得到空闲页时，发现当前没有空闲的物理页可供分配，这时才开始查找“不常用”页面，并把一个或多个这样的页换出到硬盘上。</p>
<h3 id="页替换算法的数据结构设计"><a href="#页替换算法的数据结构设计" class="headerlink" title="页替换算法的数据结构设计"></a>页替换算法的数据结构设计</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span>  </span><br><span class="line">……   </span><br><span class="line"><span class="type">list_entry_t</span> pra_page_link;   </span><br><span class="line"><span class="type">uintptr_t</span> pra_vaddr;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>pra_page_link构造了按页的第一次访问时间进行排序的一个链表，这个链表的开始表示第一次访问时间最近的页，链表结尾表示第一次访问时间最远的页。当然链表头可以就可设置为pra_list_head（定义在swap_fifo.c中），构造的时机是在page fault发生后，进行do_pgfault函数时。pra_vaddr可以用来记录此物理页对应的虚拟页起始地址。</p>
<p>当一个物理页（struct Page）需要被swap出去的时候，首先需要确保它已经分配了一个位于磁盘上的swap page（由连续的8个扇区组成）。这里为了简化设计，在swap_check函数中建立了每个虚拟页唯一对应的swap page，其对应关系设定为：<code>虚拟页对应的PTE的索引值 = swap page的扇区起始位置*8</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_manager</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;  </span><br><span class="line">    <span class="comment">/* swap manager 全局初始化 */</span>  </span><br><span class="line">    <span class="type">int</span> (*init) (<span class="type">void</span>);  </span><br><span class="line">    <span class="comment">/* 对mm_struct中的数据进行初始化 */</span>  </span><br><span class="line">    <span class="type">int</span> (*init_mm) (<span class="keyword">struct</span> mm_struct *mm);  </span><br><span class="line">    <span class="comment">/* 时钟中断处理 */</span>  </span><br><span class="line">    <span class="type">int</span> (*tick_event) (<span class="keyword">struct</span> mm_struct *mm);  </span><br><span class="line">    <span class="comment">/* Called when map a swappable page into the mm_struct */</span>  </span><br><span class="line">    <span class="type">int</span> (*map_swappable) (<span class="keyword">struct</span> mm_struct *mm, <span class="type">uintptr_t</span> addr, <span class="keyword">struct</span> Page *page, <span class="type">int</span> swap_in);   </span><br><span class="line">    <span class="comment">/* When a page is marked as shared, this routine is called to delete the addr entry from the swap manager */</span></span><br><span class="line">    <span class="type">int</span> (*set_unswappable) (<span class="keyword">struct</span> mm_struct *mm, <span class="type">uintptr_t</span> addr);  </span><br><span class="line">    <span class="comment">/* Try to swap out a page, return then victim */</span>  </span><br><span class="line">    <span class="type">int</span> (*swap_out_victim) (<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> Page *ptr_page, <span class="type">int</span> in_tick);  </span><br><span class="line">    <span class="comment">/* check the page relpacement algorithm */</span>  </span><br><span class="line">    <span class="type">int</span> (*check_swap)(<span class="type">void</span>);   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>map_swappable函数用于记录页访问情况相关属性，swap_out_vistim函数用于挑选需要换出的页。显然第二个函数依赖于第一个函数记录的页访问情况。tick_event函数指针也很重要，结合定时产生的中断，可以实现一种积极的换页策略。</p>
<ol>
<li>准备：为了实现FIFO置换算法，我们应该管理所有可交换的页面，因此我们可以根据时间顺序将这些页面链接到pra_list_head。 使用list.h中的struct list。 struct list是一个简单的双向链表实现，具体函数包括：list_init，list_add（list_add_after），list_add_before，list_del，list_next，list_prev。 将通用列表结构转换为特殊结构（例如结构页面）。可以找到一些宏：le2page（在memlayout.h中），le2vma（在vmm.h中），le2proc（在proc.h中）等；</li>
<li>_fifo_init_mm：初始化pra_list_head并让mm -&gt; sm_priv指向pra_list_head的addr。 现在，从内存控制struct mm_struct，我们可以调用FIFO算法；</li>
<li>_fifo_map_swappable：将最近访问的页放到 pra_list_head 队列最后；</li>
<li>_fifo_swap_out_victim：最早访问的页面从pra_list_head队列中剔除，然后*ptr_page赋值为这一页。</li>
</ol>
<h2 id="读代码-1"><a href="#读代码-1" class="headerlink" title="读代码"></a>读代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">与虚拟地址范围[VPT，VPT + PTSIZE]对应的页面目录条目(page directory entry,PDE)指向页面目录本身。 因此，页面目录被视为页面表和页面目录。</span><br><span class="line">将页面目录视为页表的一个结果是可以通过虚拟地址VPT处的“虚拟页表(virtual page table,VPT)”访问所有PTE。 数字n的PTE存储在vpt[n]中。</span><br><span class="line">第二个结果是当前页面目录的内容将始终在虚拟地址PGADDR（PDX（VPT），PDX（VPT），0）处可用，vpd设置如下。</span><br><span class="line">*/</span><br><span class="line">pte_t * const vpt = (pte_t *)VPT;</span><br><span class="line">pde_t * const vpd = (pde_t *)PGADDR(PDX(VPT), PDX(VPT), 0);</span><br></pre></td></tr></table></figure>
<h2 id="练习1：给未被映射的地址映射上物理页"><a href="#练习1：给未被映射的地址映射上物理页" class="headerlink" title="练习1：给未被映射的地址映射上物理页"></a>练习1：给未被映射的地址映射上物理页</h2><p>完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限的时候 需要参考页面所在VMA的权限，同时需要注意映射物理页时需要操作内存控制结构所指定的页表，而不是内核的页表。</p>
<p>引入虚拟内存后，可能会出现某一些虚拟内存空间是合法的（在vma中），但是还没有为其分配具体的内存页，这样的话，在访问这些虚拟页的时候就会产生pagefault异常，从而使得OS可以在异常处理时完成对这些虚拟页的物理页分配，在中端返回之后就可以正常进行内存的访问了。将出现了异常的线性地址保存在cr2寄存器中；再到trap_dispatch函数，在该函数中会根据中断号，将page fault的处理交给pgfault_handler函数，进一步交给do_pgfault函数进行处理。产生页面异常的原因主要有:</p>
<ul>
<li>目标页面不存在（页表项全为0，即该线性地址与物理地址尚未建立映射或者已经撤销）；</li>
<li>相应的物理页面不在内存中（页表项非空，但Present标志位=0，比如在swap分区或磁盘文件上）；</li>
<li>访问权限不符合（此时页表项P标志=1，比如企图写只读页面）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do_pgfault - 处理缺页中断的中断处理例程 interrupt handler to process the page fault execption</span><br><span class="line">@mm         : the control struct for a set of vma using the same PDT</span><br><span class="line">@error_code : the error code recorded in trapframe-&gt;tf_err which is setted by x86 hardware</span><br><span class="line">@addr       : the addr which causes a memory access exception, (the contents of the CR2 register)</span><br></pre></td></tr></table></figure>
<p>调用栈： trap—&gt; trap_dispatch—&gt;pgfault_handler—&gt;do_pgfault</p>
<p>处理器为ucore的do_pgfault函数提供了两项信息，以帮助诊断异常并从中恢复。</p>
<p>(1) CR2寄存器的内容。 处理器使用产生异常的32位线性地址加载CR2寄存器。 do_pgfault可以使用此地址来查找相应的页面目录和页表条目。</p>
<p>(2) 在内核栈中的错误码。缺页错误码与其他异常的错误码不同，错误码可以通知中断处理例程以下信息:</p>
<ul>
<li>P flag(bit 0) 表明异常是否是因为一个不存在的页(0)或违反访问权限或使用保留位(1)；</li>
<li>W/R flag(bit 1) 表明引起异常的访存操作是读(0)还是写(1)；</li>
<li>U/S flag (bit 2) 表明引起异常时处理器是在用户态(1)还是内核态(0)</li>
</ul>
<blockquote>
<p><code>do_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr)</code></p>
</blockquote>
<p>第一个是一个mm_struct变量，其中保存了所使用的PDT，合法的虚拟地址空间（使用链表组织），以及与后文的swap机制相关的数据；而第二个参数是产生pagefault的时候硬件产生的error code，可以用于帮助判断发生page fault的原因，而最后一个参数则是出现page fault的线性地址（保存在cr2寄存器中的线性地址）。</p>
<ol>
<li>查询mm_struct中的虚拟地址链表（线性地址对等映射，因此线性地址等于虚拟地址），确定出现page_fault的线性地址是否合法；</li>
<li>使用error code（包含了这次内存访问为读/写，对应物理页是否存在）判断是否出现权限问题，如果出现问题则直接返回；</li>
<li>根据合法虚拟地址（mm_struct中保存的合法虚拟地址链表中）生成对应产生的物理页的权限；</li>
<li>使用get_pte获取出错的线性地址所对应的虚拟页起始地址对应到的页表项，同时使用页表项保存物理地址（P为1）和被换出的物理页在swap中的位置（P为0），并规定swap中第0个页空出来不用于交换。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_pgfault</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="type">uint32_t</span> error_code, <span class="type">uintptr_t</span> addr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据传进的mm和地址addr，找一个vma，这个vma是在mm的mmap_cache中的，find_vma主要是先找mm中的mmap_cache，如果还不存在，就在mm的mmap_list中找，这个vma用le2vma宏进行转换，直到找到一个地址空间合适的vma，把这个vma赋值给mmap_cache。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span> =</span> find_vma(mm, addr);</span><br><span class="line"></span><br><span class="line">    pgfault_num++;</span><br><span class="line">    <span class="comment">//检查找到的vma是否为空或符合地址范围</span></span><br><span class="line">    <span class="keyword">if</span> (vma == <span class="literal">NULL</span> || vma-&gt;vm_start &gt; addr) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;not valid addr %x, and  can not find it in vma\n&quot;</span>, addr);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果present位是0，代表没有映射关系，不存在物理页和虚拟页帧的对应关系</span></span><br><span class="line">    <span class="comment">//error_code在cr2寄存器中的后几位，对这个errorcode进行判断，确定读写权限和p位是否为1</span></span><br><span class="line">    <span class="keyword">switch</span> (error_code &amp; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">/* error code flag : default is 3 ( W/R=1, P=1): write, present */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">/* error code flag : (W/R=1, P=0): write, not present */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;do_pgfault failed: error code flag = write AND not present, but the addr&#x27;s vma cannot write</span></span><br><span class="line"><span class="string">\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">/* error code flag : (W/R=0, P=1): read, present */</span></span><br><span class="line">        cprintf(<span class="string">&quot;do_pgfault failed: error code flag = read AND present\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* error code flag : (W/R=0, P=0): read, not present */</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;do_pgfault failed: error code flag = read AND not present, but the addr&#x27;s vma cannot read or exec\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* IF (write an existed addr ) OR</span></span><br><span class="line"><span class="comment">     *    (write an non_existed addr &amp;&amp; addr is writable) OR</span></span><br><span class="line"><span class="comment">     *    (read  an non_existed addr &amp;&amp; addr is readable)</span></span><br><span class="line"><span class="comment">     * THEN</span></span><br><span class="line"><span class="comment">     *    continue process</span></span><br><span class="line"><span class="comment">     * 写一个存在的地址、写一个不存在的地址但是地址是可写的、读一个不存在的地址但是地址是可读的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">uint32_t</span> perm = PTE_U;</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE) &#123;</span><br><span class="line">        perm |= PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成一个权限控制</span></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    <span class="comment">// 向下舍入到n的最接近的倍数</span></span><br><span class="line"></span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="type">pte_t</span> *ptep=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 1: YOUR CODE</span></span><br><span class="line"><span class="comment">    * 本次实验用到的宏和定义：</span></span><br><span class="line"><span class="comment">    *   get_pte : 获得pte，返回pte的线性地址、虚拟地址</span></span><br><span class="line"><span class="comment">    *             if the PT contians this pte didn&#x27;t exist, alloc a page for PT (notice the 3th parameter &#x27;1&#x27;)</span></span><br><span class="line"><span class="comment">    *   pgdir_alloc_page : 调用alloc_page 和 page_insert 分配一个页大小的内存空间，设置物理地址和线性地址的映射关系</span></span><br><span class="line"><span class="comment">    * DEFINES:</span></span><br><span class="line"><span class="comment">    *   VM_WRITE  : If vma-&gt;vm_flags &amp; VM_WRITE == 1/0, then the vma is writable/non writable</span></span><br><span class="line"><span class="comment">    *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable</span></span><br><span class="line"><span class="comment">    *   PTE_U           0x004                   // page table/directory entry flags bit : User can access</span></span><br><span class="line"><span class="comment">    * VARIABLES:</span></span><br><span class="line"><span class="comment">    *   mm-&gt;pgdir : the PDT of these vma</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 1: YOUR CODE*/</span></span><br><span class="line">    ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 第三个参数create代表是否在查找page_directory的过程中没找到的话要不要创建，在这里要创建</span></span><br><span class="line">    <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;get_pte return a NULL.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(1) 找到一个pte，如果需要的物理页是没有分配而不是被换出到外存中</span></span><br><span class="line">    <span class="comment">//如果物理地址不存在，则分配一个页面并使用逻辑地址映射物理地址，pgdir_alloc_page一个函数就能分配页和设置映射关系</span></span><br><span class="line">    <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">page</span> =</span> pgdir_alloc_page(mm-&gt;pgdir, addr, perm);</span><br><span class="line">        <span class="keyword">if</span>(page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;pgdir_alloc_page return a NULL.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE</span></span><br><span class="line"><span class="comment">    * 现在我们认为这个pte是一个swap的，我们应该将数据从disk加载到带有物理地址的页面，并将物理地址映射到逻辑地址，触发交换管理器来记录该页面的访问情况。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    *  MACROs or Functions:</span></span><br><span class="line"><span class="comment">    *    swap_in(mm, addr, &amp;page) : 分配一个内存页，根据PTE中的swap地址找到磁盘页的地址，读进内存页中</span></span><br><span class="line"><span class="comment">    *    page_insert ： 创建页的物理地址和线性地址的映射关系</span></span><br><span class="line"><span class="comment">    *    swap_map_swappable ： 设置这一个页是可交换的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">if</span>(swap_init_ok) &#123;    <span class="comment">// 判断是否当前交换机制正确被初始化</span></span><br><span class="line">            <span class="keyword">struct</span> Page *page=<span class="literal">NULL</span>;</span><br><span class="line">            ret = swap_in(mm, addr, &amp;page);   <span class="comment">// 将物理页换入到内存中</span></span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">                cprintf(<span class="string">&quot;swap_in failed.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> failed;</span><br><span class="line">            &#125;</span><br><span class="line">            page_insert(mm-&gt;pgdir, page, addr, perm);</span><br><span class="line">            <span class="comment">//(2) According to the mm, addr AND page, setup the map of phy addr &lt;---&gt; logical addr</span></span><br><span class="line">            <span class="comment">// 将物理页与虚拟页建立映射关系</span></span><br><span class="line">            swap_map_swappable(mm, addr, page, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//(3) make the page swappable。设置当前的物理页为可交换的</span></span><br><span class="line">            page-&gt;pra_vaddr = addr;</span><br><span class="line">            <span class="comment">//同时在物理页中维护其对应到的虚拟页的信息；</span></span><br><span class="line">            <span class="comment">//网上有人说这个语句最好应当放置在page_insert函数中，</span></span><br><span class="line">            <span class="comment">//在该建立映射关系的函数外对物理page对应的虚拟地址进行维护显得有些不太合适（感觉好有道理）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cprintf(<span class="string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ret = <span class="number">0</span>;</span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：</p>
<ul>
<li>请描述页目录项（Page Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。</li>
</ul>
<p>首先不妨先分析PDE以及PTE中各个组成部分以及其含义；</p>
<p>接下来先描述页目录项的每个组成部分，PDE（页目录项）的具体组成如下图所示；描述每一个组成部分的含义如下：</p>
<ul>
<li>前20位表示4K对齐的该PDE对应的页表起始位置（物理地址，该物理地址的高20位即PDE中的高20位，低12位为0）；</li>
<li>第9-11位未被CPU使用，可保留给OS使用；</li>
<li>接下来的第8位可忽略；</li>
<li>第7位用于设置Page大小，0表示4KB；</li>
<li>第6位恒为0；</li>
<li>第5位用于表示该页是否被使用过；</li>
<li>第4位设置为1则表示不对该页进行缓存；</li>
<li>第3位设置是否使用write through缓存写策略；</li>
<li>第2位表示该页的访问需要的特权级；</li>
<li>第1位表示是否允许读写；</li>
<li>第0位为该PDE的存在位；</li>
</ul>
<p>接下来描述页表项（PTE）中的每个组成部分的含义，具体组成如下图所示：</p>
<ul>
<li>高20位与PDE相似的，用于表示该PTE指向的物理页的物理地址；</li>
<li>9-11位保留给OS使用；</li>
<li>7-8位恒为0；</li>
<li>第6位表示该页是否为dirty，即是否需要在swap out的时候写回外存；</li>
<li>第5位表示是否被访问；</li>
<li>3-4位恒为0；</li>
<li>0-2位分别表示存在位、是否允许读写、访问该页需要的特权级；</li>
</ul>
<p>可以发现无论是PTE还是TDE，都具有着一些保留的位供操作系统使用，也就是说ucore可以利用这些位来完成一些其他的内存管理相关的算法，比如可以在这些位里保存最近一段时间内该页的被访问的次数（仅能表示0-7次），用于辅助近似地实现虚拟内存管理中的换出策略的LRU之类的算法；也就是说这些保留位有利于OS进行功能的拓展；</p>
<blockquote>
<p>作者：AmadeusChan<br>链接：<a href="https://www.jianshu.com/p/8d6ce61ac678">https://www.jianshu.com/p/8d6ce61ac678</a><br>来源：简书</p>
</blockquote>
<p>如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</p>
<p>考虑到ucore的缺页服务例程如果在访问内容中出现了缺页异常，则会有可能导致ucore最终无法完成缺页的处理，因此一般不应该将缺页的ISR以及OS中的其他一些关键代码或者数据换出到外存中，以确保操作系统的正常运行；如果缺页ISR在执行过程中遇到页访问异常，则最终硬件需要完成的处理与正常出现页访问异常的处理相一致，均为：</p>
<ul>
<li>将发生错误的线性地址保存在cr2寄存器中;</li>
<li>在中断栈中依次压入EFLAGS，CS, EIP，以及页访问异常码errorcode，由于ISR一定是运行在内核态下的，因此不需要压入ss和esp以及进行栈的切换；</li>
<li>根据中断描述符表查询到对应页访问异常的ISR，跳转到对应的ISR处执行，接下来将由软件进行处理；</li>
</ul>
<h2 id="练习2：补充完成基于FIFO的页面替换算法"><a href="#练习2：补充完成基于FIFO的页面替换算法" class="headerlink" title="练习2：补充完成基于FIFO的页面替换算法"></a>练习2：补充完成基于FIFO的页面替换算法</h2><p>维基百科：最简单的页面替换算法（Page Replace Algorithm）是FIFO算法。先进先出页面替换算法是一种低开销算法。这个想法从名称中可以明显看出 - 操作系统跟踪队列中内存中的所有页面，最近到达的放在后面，最早到达的放在前面。当需要更换页面时，会选择队列最前面的页面（最旧的页面）。虽然FIFO开销小且直观，但在实际应用中表现不佳。因此，它很少以未修改的形式使用。该算法存在Belady异常。</p>
<p> FIFO的详细信息</p>
<ol>
<li>准备：为了实现FIFO，我们应该管理所有可交换的页面，这样我们就可以按照时间顺序将这些页面链接到pra_list_head。将通用list换为特殊结构（例如Page）；</li>
<li>_fifo_init_mm：初始化pra_list_head并让mm-&gt; sm_priv指向pra_list_head的addr。 现在，从内存控制struct mm_struct，我们可以访问FIFO；</li>
<li>_fifo_map_swappable: 最近到达的页需要放到pra_list_head队列的最末尾；</li>
<li>_fifo_swap_out_victim: 最早到达的页面在pra_list_head队列最前边，我们应该将它踢出去。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">将当前的物理页面插入到FIFO算法中维护的可被交换出去的物理页面链表中的末尾，从而保证该链表中越接近链表头的物理页面在内存中的驻留时间越长；</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _fifo_map_swappable(<span class="keyword">struct</span> mm_struct *mm, <span class="type">uintptr_t</span> addr, <span class="keyword">struct</span> Page *page, <span class="type">int</span> swap_in)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">list_entry_t</span> *head=(<span class="type">list_entry_t</span>*) mm-&gt;sm_priv;</span><br><span class="line">    <span class="comment">// 找到链表入口</span></span><br><span class="line">    <span class="type">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link); </span><br><span class="line">    <span class="comment">// 找到当前物理页用于组织成链表的list_entry_t</span></span><br><span class="line"></span><br><span class="line">    assert(entry != <span class="literal">NULL</span> &amp;&amp; head != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span></span><br><span class="line">    <span class="comment">// link the most recent arrival page at the back of the pra_list_head qeueue</span></span><br><span class="line">    <span class="comment">// 将当前指定的物理页插入到链表的末尾</span></span><br><span class="line">    list_add(head, entry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)</span><br><span class="line">&#123;</span><br><span class="line">     list_entry_t *head=(list_entry_t*) mm-&gt;sm_priv; </span><br><span class="line">     // 找到链表的入口</span><br><span class="line">     assert(head != NULL);</span><br><span class="line">     assert(in_tick==0);</span><br><span class="line">     /* Select the victim */</span><br><span class="line">     /*LAB3 EXERCISE 2: YOUR CODE*/</span><br><span class="line">     // unlink the earliest arrival page in front of pra_list_head qeueue</span><br><span class="line">     //list_entry_t *le = head-&gt;prev; the given answer</span><br><span class="line">     list_entry_t *le = list_next(head);</span><br><span class="line">     // 取出链表头，即最早进入的物理页面</span><br><span class="line">     assert(le != NULL);</span><br><span class="line">     // 确保链表非空</span><br><span class="line">     struct Page *p = le2page(le,pra_page_link);</span><br><span class="line">     // 找到对应的物理页面的Page结构</span><br><span class="line">     list_del(le);</span><br><span class="line">     // 从链表上删除取出的即将被换出的物理页面</span><br><span class="line">     assert(p != NULL);</span><br><span class="line">     *ptr_page = p;</span><br><span class="line">     // assign the value of *ptr_page to the addr of this page</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在_fifo_map_swappable函数中使用的是list_add_before的话，在_fifo_swap_out_victim中应该使用list_next(head)取得要被删除的页；如果在_fifo_map_swappable函数中使用的是list_add的话，在_fifo_swap_out_victim中应该使用head-&gt;prev取得要被删除的页；这个链表是双向循环链表！</p>
<p>如果要在ucore上实现”extended clock页替换算法”请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题</p>
<p>在现有框架基础上可以支持Extended clock算法。</p>
<p>根据上文中提及到的PTE的组成部分可知，PTE中包含了dirty位和访问位，因此可以确定某一个虚拟页是否被访问过以及写过，但是，考虑到在替换算法的时候是将物理页面进行换出，而可能存在着多个虚拟页面映射到同一个物理页面这种情况，也就是说某一个物理页面是否dirty和是否被访问过是有这些所有的虚拟页面共同决定的，而在原先的实验框架中，物理页的描述信息Page结构中默认只包括了一个对应的虚拟页的地址，应当采用链表的方式，在Page中扩充一个成员，把物理页对应的所有虚拟页都给保存下来；而物理页的dirty位和访问位均为只需要某一个对应的虚拟页对应位被置成1即可置成1；</p>
<p>完成了上述对物理页描述信息的拓展之后，考虑对FIFO算法的框架进行修改得到拓展时钟算法的框架，由于这两种算法都是将所有可以换出的物理页面均按照进入内存的顺序连成一个环形链表，因此初始化，将某个页面置为可以/不可以换出这些函数均不需要进行大的修改(小的修改包括在初始化当前指针等)，唯一需要进行重写的函数是选择换出物理页的函数swap_out_victim，对该函数的修改如下：</p>
<p>从当前指针开始，对环形链表进行扫描，根据指针指向的物理页的状态（表示为(access, dirty)）来确定应当进行何种修改：如果状态是(0, 0)，则将该物理页面从链表上去下，该物理页面记为换出页面，但是由于这个时候这个页面不是dirty的，因此事实上不需要将其写入swap分区；</p>
<p>如果状态是(0,1)，则将该物理页对应的虚拟页的PTE中的dirty位都改成0，并且将该物理页写入到外存中，然后指针跳转到下一个物理页；如果状态是(1, 0), 将该物理页对应的虚拟页的PTE中的访问位都置成0，然后指针跳转到下一个物理页面；如果状态是(1, 1)，则该物理页的所有对应虚拟页的PTE中的访问为置成0，然后指针跳转到下一个物理页面；</p>
<p>需要被换出的页的特征是什么？</p>
<p>该物理页在当前指针上一次扫过之前没有被访问过；<br>该物理页的内容与其在外存中保存的数据是一致的, 即没有被修改过;</p>
<p>在ucore中如何判断具有这样特征的页？</p>
<p>在ucore中判断具有这种特征的页的方式已经在上文设计方案中提及过了，具体为：</p>
<p>假如某物理页对应的所有虚拟页中存在一个dirty的页，则认为这个物理页为dirty，否则不这么认为；<br>假如某物理页对应的所有虚拟页中存在一个被访问过的页，则认为这个物理页为被访问过的，否则不这么认为；</p>
<p>何时进行换入和换出操作？</p>
<p>在产生page fault的时候进行换入操作；<br>换出操作源于在算法中将物理页的dirty从1修改成0的时候，因此这个时候如果不进行写出到外存，就会造成数据的不一致，具体写出内存的时机是比较细节的问题, 可以在修改dirty的时候写入外存，或者是在这个物理页面上打一个需要写出的标记，到了最终删除这个物理页面的时候，如果发现了这个写出的标记，则在这个时候再写入外存；后者使用一个写延迟标记，有利于多个写操作的合并，从而降低缺页的代价；</p>
<h1 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>了解内核线程创建/执行的管理过程<br>了解内核线程的切换和基本调度过程</p>
<h2 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h2><p>当一个程序加载到内存中运行时，首先通过ucore OS的内存管理子系统分配合适的空间，然后就需要考虑如何分时使用CPU来“并发”执行多个程序，让每个运行的程序（这里用线程或进程表示）“感到”它们各自拥有“自己”的CPU。</p>
<p>内核线程是一种特殊的进程，内核线程与用户进程的区别有两个：</p>
<ul>
<li>内核线程只运行在内核态</li>
<li>用户进程会在在用户态和内核态交替运行</li>
<li>所有内核线程共用ucore内核内存空间，不需为每个内核线程维护单独的内存空间</li>
<li>用户进程需要维护各自的用户内存空间</li>
</ul>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="内核线程管理"><a href="#内核线程管理" class="headerlink" title="内核线程管理"></a>内核线程管理</h3><p>本实验实现了让ucore实现分时共享CPU，实现多条控制流能够并发执行。<strong>内核线程</strong>是一种特殊的进程，内核线程与用户进程的区别有两个：</p>
<ul>
<li><strong>内核线程只运行在内核态而用户进程会在在用户态和内核态交替运行</strong>；</li>
<li><strong>所有内核线程直接使用共同的ucore内核内存空间</strong>，不需为每个内核线程维护单独的内存空间而用户进程需要维护各自的用户内存空间。</li>
</ul>
<p>设计管理线程的数据结构，即进程控制块(PCB)。创建内核线程对应的进程控制块，把这些进程控制块通过链表连在一起，便于随时进行插入，删除和查找操作。通过调度器（scheduler）来让不同的内核线程在不同的时间段占用CPU执行，实现对CPU的分时共享。</p>
<p>kern/init/init.c中的kern_init函数中，当完成虚拟内存的初始化工作vmm_init()后，就调用了proc_init函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    list_init(&amp;proc_list);</span><br><span class="line">    <span class="comment">// initialize the process double linked list</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_LIST_SIZE; i ++) &#123;</span><br><span class="line">        list_init(hash_list + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((idleproc = alloc_proc()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;cannot alloc idleproc.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idleproc-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    idleproc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">    idleproc-&gt;kstack = (<span class="type">uintptr_t</span>)bootstack;</span><br><span class="line">    idleproc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 完成了idleproc内核线程创建   </span></span><br><span class="line">    set_proc_name(idleproc, <span class="string">&quot;idle&quot;</span>);</span><br><span class="line">    nr_process ++;</span><br><span class="line"></span><br><span class="line">    current = idleproc;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = kernel_thread(init_main, <span class="string">&quot;Hello world!!&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;create init_main failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initproc = find_proc(pid);</span><br><span class="line">    <span class="comment">// initproc内核线程的创建</span></span><br><span class="line">    set_proc_name(initproc, <span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    assert(idleproc != <span class="literal">NULL</span> &amp;&amp; idleproc-&gt;pid == <span class="number">0</span>);</span><br><span class="line">    assert(initproc != <span class="literal">NULL</span> &amp;&amp; initproc-&gt;pid == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>idleproc内核线程的工作就是不停地查询，看是否有其他内核线程可以执行了，如果有，马上让调度器选择那个内核线程执行（请参考cpu_idle函数的实现）。所以<strong>idleproc内核线程是在ucore操作系统没有其他内核线程可执行的情况下才会被调用</strong>。</p>
<p>接着就是调用kernel_thread函数来创建initproc内核线程。initproc内核线程的工作就是显示“Hello World”，表明自己存在且能正常工作了。<br>调度器会在特定的调度点上执行调度，完成进程切换。</p>
<p>在lab4中，这个调度点就一处，即在cpu_idle函数中，此函数如果发现当前进程（也就是idleproc）的need_resched置为1（在初始化idleproc的进程控制块时就置为1了），则调用schedule函数，完成进程调度和进程切换。进程调度的过程其实比较简单，就是在进程控制块链表中查找到一个“合适”的内核线程，所谓“合适”就是指内核线程处于“PROC_RUNNABLE”状态。</p>
<p>在接下来的switch_to函数(在后续有详细分析，有一定难度，需深入了解一下)完成具体的进程切换过程。一旦切换成功，那么initproc内核线程就可以通过显示字符串来表明本次实验成功。</p>
<p>进程管理信息用struct proc_struct表示，在kern/process/proc.h中定义如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct proc_struct &#123;</span><br><span class="line">    enum proc_state state;        // Process state</span><br><span class="line">    int pid;                      // Process ID</span><br><span class="line">    int runs;                     // the running times of Proces</span><br><span class="line">    uintptr_t kstack;             // Process kernel stack</span><br><span class="line">    volatile bool need_resched;   // need to be rescheduled to release CPU?</span><br><span class="line">    struct proc_struct *parent;   // the parent process</span><br><span class="line">    struct mm_struct *mm;         // Process&#x27;s memory management field</span><br><span class="line">    struct context context;       // Switch here to run process</span><br><span class="line">    struct trapframe *tf;         // Trap frame for current interrupt</span><br><span class="line">    uintptr_t cr3;                // the base addr of Page Directroy Table(PDT)</span><br><span class="line">    uint32_t flags;               // Process flag</span><br><span class="line">    char name[PROC_NAME_LEN + 1]; // Process name</span><br><span class="line">    list_entry_t list_link;       // Process link list</span><br><span class="line">    list_entry_t hash_link;       // Process hash list</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>mm：内存管理的信息。在lab3中有涉及，主要包括内存映射列表、页表指针等。<strong>在实际OS中，内核线程常驻内存，不需要考虑swap page问题</strong>，在用户进程中考虑进程用户内存空间的swap_page问题时mm才会发挥作用。所以在lab4中mm对于内核线程就没有用了，这样内核线程的proc_struct的成员变量<em>mm=0是合理的。mm里有个很重要的项pgdir，记录的是该进程使用的一级页表的物理地址。由于</em>mm=NULL，所以在proc_struct数据结构中需要有一个代替pgdir项来记录页表起始地址，这就是proc_struct数据结构中的<strong>cr3</strong>成员变量。</li>
<li>state：进程所处的状态。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span></span><br><span class="line">    PROC_UNINIT = <span class="number">0</span>,  <span class="comment">// uninitialized</span></span><br><span class="line">    PROC_SLEEPING,    <span class="comment">// sleeping</span></span><br><span class="line">    PROC_RUNNABLE,    <span class="comment">// runnable(maybe running)</span></span><br><span class="line">    PROC_ZOMBIE,      <span class="comment">// almost dead, and wait parent proc to reclaim his resource</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>parent：用户进程的父进程（创建它的进程）。在所有进程中，只有一个进程没有父进程，就是内核创建的第一个内核线程idleproc。内核根据这个父子关系建立一个树形结构，用于维护一些特殊的操作，例如确定某个进程是否可以对另外一个进程进行某种操作等等。</li>
<li>context：进程的上下文，用于进程切换（参见switch.S）。在uCore中，所有的进程在内核中也是相对独立的（例如独立的内核堆栈以及上下文等等）。使用context保存寄存器的目的就在于在内核态中能够进行上下文之间的切换。实际利用context进行上下文切换的函数是在kern/process/switch.S中定义switch_to。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在上下文切换时保存寄存器信息，其中有些寄存器貌似不被保存，为了省事</span><br><span class="line">// The 这个结构体的布局要跟switch.S中的switch_to操作对应。</span><br><span class="line">struct context &#123;</span><br><span class="line">    uint32_t eip;</span><br><span class="line">    uint32_t esp;</span><br><span class="line">    uint32_t ebx;</span><br><span class="line">    uint32_t ecx;</span><br><span class="line">    uint32_t edx;</span><br><span class="line">    uint32_t esi;</span><br><span class="line">    uint32_t edi;</span><br><span class="line">    uint32_t ebp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>tf：中断帧的指针，总是指向内核栈的某个位置：当进程从用户空间跳到内核空间时，<strong>中断帧记录了进程在被中断前的状态</strong>。当内核需要跳回用户空间时，需要调整中断帧以<strong>恢复让进程继续执行的各寄存器值</strong>。除此之外，uCore内核允许嵌套中断。因此为了保证嵌套中断发生时tf总是能够指向当前的trapframe，uCore在内核栈上维护了tf的链。</li>
<li>cr3: cr3 保存页表的物理地址，目的就是进程切换的时候方便直接使用lcr3实现页表切换，避免每次都根据 mm 来计算 cr3。mm数据结构是用来实现用户空间的虚存管理的，但是内核线程没有用户空间，它执行的只是内核中的一小段代码（通常是一小段函数），所以它没有mm结构，也就是NULL。当某个进程是一个普通用户态进程的时候，PCB中的cr3就是mm中页表（pgdir）的物理地址；而当它是内核线程的时候，cr3等于boot_cr3。而boot_cr3指向了uCore启动时建立好的内核虚拟空间的页目录表首地址。</li>
<li>kstack: 每个线程都有一个<strong>内核栈</strong>，并且位于内核地址空间的不同位置。对于内核线程，该栈就是运行时的程序使用的栈；而<strong>对于普通进程，该栈是发生特权级改变的时候使保存被打断的硬件信息用的栈</strong>。uCore在创建进程时分配了 2 个连续的物理页（参见memlayout.h中KSTACKSIZE的定义）作为内核栈的空间。这个栈很小，所以内核中的代码应该尽可能的紧凑，并且避免在栈上分配大的数据结构，以免栈溢出，导致系统崩溃。kstack记录了分配给该进程/线程的内核栈的位置。主要作用有以下几点。</li>
</ul>
<blockquote>
<p>首先，当内核准备从一个进程切换到另一个的时候，需要根据kstack 的值正确的设置好tss，以便在进程切换以后再发生中断时能够使用正确的栈。</p>
<p>其次，内核栈位于内核地址空间，并且是不共享的（每个线程都拥有自己的内核栈），因此不受到 mm 的管理，当进程退出的时候，内核能够根据 kstack 的值快速定位栈的位置并进行回收。uCore 的这种内核栈的设计借鉴的是 linux 的方法（但由于内存管理实现的差异，它实现的远不如 linux 的灵活），它使得每个线程的内核栈在不同的位置，这样从某种程度上方便调试，但同时也使得内核对栈溢出变得十分不敏感，因为一旦发生溢出，它极可能污染内核中其它的数据使得内核崩溃。如果能够通过页表，将所有进程的内核栈映射到固定的地址上去，能够避免这种问题，但又会使得进程切换过程中对栈的修改变得相当繁琐。</p>
</blockquote>
<p>为了管理系统中所有的进程控制块，uCore维护了如下全局变量（位于kern/process/proc.c）：</p>
<ul>
<li>static struct proc *current：当前占用CPU且处于“运行”状态进程控制块指针。通常这个变量是只读的，只有在进程切换的时候才进行修改，并且整个切换和修改过程需要保证操作的原子性，目前至少需要屏蔽中断。可以参考 switch_to 的实现。</li>
<li>static struct proc *initproc：本实验中，指向一个内核线程。本实验以后，此指针将指向第一个用户态进程。</li>
<li>static list_entry_t hash_list[HASH_LIST_SIZE]：所有进程控制块的哈希表，proc_struct中的成员变量hash_link将基于pid链接入这个哈希表中。</li>
<li>list_entry_t proc_list：所有进程控制块的双向线性列表，proc_struct中的成员变量list_link将链接入这个链表中。</li>
</ul>
<h3 id="创建并执行内核线程"><a href="#创建并执行内核线程" class="headerlink" title="创建并执行内核线程"></a>创建并执行内核线程</h3><p>ucore实现了一个简单的进程/线程机制，进程包含独立的地址空间，至少一个线程、内核数据、进程状态、文件等。ucore需要高效地管理所有细节。在ucore，一个线程看成一个特殊的进程（process）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>进程状态</th>
<th>意义</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>PROC_UNINIT</td>
<td>uninitialized</td>
<td>alloc_proc</td>
</tr>
<tr>
<td>PROC_SLEEPING</td>
<td>sleeping</td>
<td>try_free_pages, do_wait, do_sleep</td>
</tr>
<tr>
<td>PROC_RUNNABLE</td>
<td>runnable(maybe running)</td>
<td>proc_init, wakeup_proc,</td>
</tr>
<tr>
<td>PROC_ZOMBIE</td>
<td>almost dead</td>
<td>do_exit</td>
</tr>
</tbody>
</table>
</div>
<p>进程之间的关系：</p>
<ul>
<li>parent:           proc-&gt;parent  (proc is children)</li>
<li>children:         proc-&gt;cptr    (proc is parent)</li>
<li>older sibling:    proc-&gt;optr    (proc is younger sibling)</li>
<li>younger sibling:  proc-&gt;yptr    (proc is older sibling)</li>
</ul>
<p>建立进程控制块（proc.c中的alloc_proc函数）。首先，考虑最简单的内核线程，它通常只是内核中的一小段代码或者函数，没有自己的“专属”空间。这是由于在uCore OS启动后，已经对整个内核内存空间进行了管理，通过设置页表建立了内核虚拟空间（即boot_cr3指向的二级页表描述的空间）。所以uCore OS内核中的所有线程都不需要再建立各自的页表，只需共享这个内核虚拟空间就可以访问整个物理内存了。从这个角度看，内核线程被uCore OS内核这个大“内核进程”所管理。</p>
<h3 id="创建第-0-个内核线程-idleproc"><a href="#创建第-0-个内核线程-idleproc" class="headerlink" title="创建第 0 个内核线程 idleproc"></a>创建第 0 个内核线程 idleproc</h3><p>在init.c中的kern_init函数调用了proc.c中的proc_init函数。proc_init函数启动了创建内核线程的步骤。</p>
<p>首先当前的执行上下文（从kern_init启动至今）就可以看成是uCore内核（也可看做是内核进程）中的一个内核线程的上下文。为此，uCore通过给当前执行的上下文分配一个进程控制块以及对它进行相应初始化，将其打造成第0个内核线程——idleproc。具体步骤如下：</p>
<ul>
<li>首先调用alloc_proc函数来通过kmalloc函数获得proc_struct结构的一块内存块，作为第0个进程控制块，并把proc进行初步初始化（即把proc_struct中的各个成员变量清零）。但有些成员变量设置了特殊的值，比如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proc-&gt;state = PROC_UNINIT;  设置进程为“初始”态</span><br><span class="line">proc-&gt;pid = <span class="number">-1</span>;             设置进程pid的未初始化值</span><br><span class="line">proc-&gt;cr3 = boot_cr3;       由于该内核线程在内核中运行，故采用为uCore内核已经建立的页表，</span><br><span class="line">							即设置为在uCore内核页表的起始地址boot_cr3，使用内核页目录表的基址</span><br></pre></td></tr></table></figure>
<p>内核线程共用一个映射内核空间的页表，这表示内核空间对所有内核线程都是“可见”的，所以更精确地说，这些内核线程都应该是从属于同一个唯一的“大内核进程”—uCore内核。</p>
<ul>
<li>proc_init函数对idleproc内核线程进行进一步初始化：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">idleproc-&gt;pid = <span class="number">0</span>;</span><br><span class="line">idleproc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">idleproc-&gt;kstack = (<span class="type">uintptr_t</span>)bootstack;</span><br><span class="line">idleproc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">set_proc_name(idleproc, <span class="string">&quot;idle&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>第一条将pid赋值为0，表明idleproc是第0个内核线程。</p>
<p>第二条语句改变了idleproc的状态，使其变为“准备工作”，现在只要uCore调度便可执行。</p>
<p>第三条语句设置了idleproc所使用的内核栈的起始地址。<strong>需要注意以后的其他线程的内核栈都需要通过分配获得，因为uCore启动时设置的内核栈就直接分配给idleproc使用了所以这里不用分配</strong>。</p>
<p>第四条把idleproc-&gt;need_resched设置为“1”，在cpu_idle函数中指明如果进程的need_resched为1那么就可以调度执行其他的了，如果当前idleproc在执行，则只要此标志为1，马上就调用schedule函数要求调度器切换其他进程执行。</p>
<h3 id="创建第-1-个内核线程-initproc"><a href="#创建第-1-个内核线程-initproc" class="headerlink" title="创建第 1 个内核线程 initproc"></a>创建第 1 个内核线程 initproc</h3><p>第0个内核线程主要工作是完成内核中各个子系统的初始化。uCore接下来还需创建其他进程来完成各种工作，通过调用kernel_thread函数创建了一个内核线程init_main。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init_main - the second kernel thread used to create user_main kernel threads</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">init_main</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    cprintf(<span class="string">&quot;this initproc, pid = %d, name = \&quot;%s\&quot;\n&quot;</span>, current-&gt;pid, get_proc_name(current));</span><br><span class="line">    cprintf(<span class="string">&quot;To U: \&quot;%s\&quot;.\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)arg);</span><br><span class="line">    cprintf(<span class="string">&quot;To U: \&quot;en.., Bye, Bye. :)\&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面我们来分析一下创建内核线程的函数kernel_thread。kernel_thread函数采用了局部变量tf来放置保存内核线程的临时中断帧，并把中断帧的指针传递给do_fork函数，而do_fork函数会调用copy_thread函数来在新创建的进程内核栈上专门给进程的中断帧分配一块空间。给中断帧分配完空间后，就需要构造新进程的中断帧，具体过程是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kernel_thread(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">uint32_t</span> clone_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    <span class="comment">// 给tf进行清零初始化</span></span><br><span class="line">    tf.tf_cs = KERNEL_CS;</span><br><span class="line">    tf.tf_ds = tf_struct.tf_es = tf_struct.tf_ss = KERNEL_DS;</span><br><span class="line">    <span class="comment">// 设置中断帧的代码段（tf.tf_cs）和数据段(tf.tf_ds/tf_es/tf_ss)为内核空间的段（KERNEL_CS/KERNEL_DS）</span></span><br><span class="line">    tf.tf_regs.reg_ebx = (<span class="type">uint32_t</span>)fn;</span><br><span class="line">    <span class="comment">// fn是函数主体</span></span><br><span class="line">    tf.tf_regs.reg_edx = (<span class="type">uint32_t</span>)arg;</span><br><span class="line">    <span class="comment">// arg是fn函数的参数</span></span><br><span class="line">    tf.tf_eip = (<span class="type">uint32_t</span>)kernel_thread_entry;</span><br><span class="line">    <span class="comment">// tf.tf_eip的指出了initproc内核线程从kernel_thread_entry开始执行</span></span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="number">0</span>, &amp;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>kernel_thread_entry是entry.S中实现的汇编函数，它做的事情很简单：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kernel_thread_entry: <span class="meta"># void kernel_thread(void)</span></span><br><span class="line">pushl %edx <span class="meta"># push arg</span></span><br><span class="line">call *%ebx <span class="meta"># call fn</span></span><br><span class="line">pushl %eax <span class="meta"># save the return value of fn(arg)</span></span><br><span class="line">call do_exit <span class="meta"># call do_exit to terminate current thread</span></span><br></pre></td></tr></table></figure><br>从上可以看出，kernel_thread_entry函数主要为内核线程的主体fn函数做了一个准备开始和结束运行的“壳”：</p>
<ul>
<li>把函数fn的参数arg（保存在edx寄存器中）压栈；</li>
<li>调用fn函数</li>
<li>把函数返回值eax寄存器内容压栈</li>
<li>调用do_exit函数退出线程执行。</li>
</ul>
<p>do_fork是创建线程的主要函数。kernel_thread函数通过调用do_fork函数最终完成了内核线程的创建工作。do_fork函数主要做了以下6件事情：</p>
<ul>
<li>分配并初始化进程控制块（alloc_proc函数）；</li>
<li>分配并初始化内核栈（setup_stack函数）；</li>
<li>根据clone_flag标志复制或共享进程内存管理结构（copy_mm函数）；</li>
<li>设置进程在内核（将来也包括用户态）正常运行和调度所需的中断帧和执行上下文（copy_thread函数）；</li>
<li>把设置好的进程控制块放入hash_list和proc_list两个全局进程链表中；</li>
<li>进程已经准备好执行了，把进程状态设置为“就绪”态；设置返回码为子进程的id号。</li>
</ul>
<p>copy_thread函数代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">copy_thread</span><span class="params">(<span class="keyword">struct</span> proc_struct *proc, <span class="type">uintptr_t</span> esp, <span class="keyword">struct</span> trapframe *tf)</span> &#123;</span><br><span class="line">    proc-&gt;tf = (<span class="keyword">struct</span> trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 在内核堆栈的顶部设置中断帧大小的一块栈空间</span></span><br><span class="line">    *(proc-&gt;tf) = *tf; </span><br><span class="line">    <span class="comment">// 拷贝在kernel_thread函数建立的临时中断帧的初始值</span></span><br><span class="line">    proc-&gt;tf-&gt;tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置子进程/线程执行完do_fork后的返回值</span></span><br><span class="line">    proc-&gt;tf-&gt;tf_esp = esp; </span><br><span class="line">    <span class="comment">// 设置中断帧中的栈指针esp</span></span><br><span class="line">    proc-&gt;tf-&gt;tf_eflags |= FL_IF; </span><br><span class="line">    <span class="comment">// 使能中断</span></span><br><span class="line">    <span class="comment">// 以上两句设置中断帧中的栈指针esp和标志寄存器eflags，特别是eflags设置了FL_IF标志，</span></span><br><span class="line">    <span class="comment">// 这表示此内核线程在执行过程中，能响应中断，打断当前的执行。</span></span><br><span class="line">    proc-&gt;context.eip = (<span class="type">uintptr_t</span>)forkret;</span><br><span class="line">    proc-&gt;context.esp = (<span class="type">uintptr_t</span>)(proc-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于initproc而言，它的中断帧如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所在地址位置</span></span><br><span class="line">initproc-&gt;tf= (proc-&gt;kstack+KSTACKSIZE) – <span class="keyword">sizeof</span> (<span class="keyword">struct</span> trapframe);</span><br><span class="line"><span class="comment">//具体内容</span></span><br><span class="line">initproc-&gt;tf.tf_cs = KERNEL_CS;</span><br><span class="line">initproc-&gt;tf.tf_ds = initproc-&gt;tf.tf_es = initproc-&gt;tf.tf_ss = KERNEL_DS;</span><br><span class="line">initproc-&gt;tf.tf_regs.reg_ebx = (<span class="type">uint32_t</span>)init_main;</span><br><span class="line">initproc-&gt;tf.tf_regs.reg_edx = (<span class="type">uint32_t</span>) ADDRESS of <span class="string">&quot;Helloworld!!&quot;</span>;</span><br><span class="line">initproc-&gt;tf.tf_eip = (<span class="type">uint32_t</span>)kernel_thread_entry;</span><br><span class="line">initproc-&gt;tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">initproc-&gt;tf.tf_esp = esp;</span><br><span class="line">initproc-&gt;tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure></p>
<p>设置好中断帧后，最后就是设置initproc的进程上下文。uCore调度器选择了initproc执行，需要根据initproc-&gt;context中保存的执行现场来恢复initproc的执行。这里设置了initproc的执行现场中主要的两个信息：</p>
<ul>
<li>上次停止执行时的下一条指令地址context.eip</li>
<li>上次停止执行时的堆栈地址context.esp。</li>
</ul>
<p>可以看出，由于initproc的中断帧占用了实际给initproc分配的栈空间的顶部，所以initproc就只能把栈顶指针context.esp设置在initproc的中断帧的起始位置。根据context.eip的赋值，可以知道initproc实际开始执行的地方在forkret函数（主要完成do_fork函数返回的处理工作）处。至此，initproc内核线程已经做好准备执行了。</p>
<h3 id="调度并执行内核线程-initproc"><a href="#调度并执行内核线程-initproc" class="headerlink" title="调度并执行内核线程 initproc"></a>调度并执行内核线程 initproc</h3><p>在uCore执行完proc_init函数后，就创建好了两个内核线程：<code>idleproc</code>和<code>initproc</code>，这时uCore当前的执行现场就是idleproc，等到执行到init函数的最后一个函数cpu_idle之前，uCore的所有初始化工作就结束了，idleproc将通过执行cpu_idle函数让出CPU，给其它内核线程执行，具体过程如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">cpu_idle</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;need_resched) &#123;</span><br><span class="line">            schedule();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先，判断当前内核线程idleproc的need_resched是否不为0，idleproc中的need_resched本就置为1，所以会马上调用schedule函数找其他处于“就绪”态的进程执行。uCore的调度器为FIFO调度器，其核心就是schedule函数。它的执行逻辑很简单：</p>
<ul>
<li>设置当前内核线程current-&gt;need_resched为0；</li>
<li>在proc_list队列中查找下一个处于“就绪”态的线程或进程；</li>
<li>找到这样的进程后，就调用proc_run函数，保存当前进程current的上下文，恢复新进程的执行现场，完成进程切换。</li>
</ul>
<p>uCore通过proc_run和进一步的switch_to函数完成两个执行现场的切换，具体流程如下：</p>
<ul>
<li>让current指向next内核线程initproc；</li>
<li>设置任务状态段ts中特权态0下的栈顶指针esp0为next内核线程initproc的内核栈的栈顶，即next-&gt;kstack + KSTACKSIZE；</li>
<li>设置CR3寄存器的值为next内核线程initproc的页目录表起始地址next-&gt;cr3，这实际上是完成进程间的页表切换；</li>
<li>由switch_to函数完成具体的两个线程的执行现场切换，即切换各个寄存器，当switch_to函数执行完“ret”指令后，就切换到initproc执行了。</li>
</ul>
<p>注意，在第二步设置任务状态段ts中特权态0下的栈顶指针esp0的目的是<strong>建立好内核线程</strong>或<strong>将来用户线程在执行特权态切换（从特权态0&lt;—&gt;特权态3，或从特权态3&lt;—&gt;特权态0）时能够正确定位处于特权态0时进程的内核栈的栈顶</strong>，而这个栈顶其实放了一个trapframe结构的内存空间。如果是在特权态3发生了中断/异常/系统调用，则CPU会从特权态3—&gt;特权态0，且CPU从此栈顶（当前被打断进程的内核栈顶）开始压栈来保存被中断/异常/系统调用打断的用户态执行现场；如果是在特权态0发生了中断/异常/系统调用，则CPU会从从当前内核栈指针esp所指的位置开始压栈保存被中断/异常/系统调用打断的内核态执行现场。反之，当执行完对中断/异常/系统调用打断的处理后，最后会执行一个“iret”指令。在执行此指令之前，CPU的当前栈指针esp一定指向上次产生中断/异常/系统调用时CPU保存的被打断的指令地址CS和EIP，“iret”指令会根据ESP所指的保存的址CS和EIP恢复到上次被打断的地方继续执行。</p>
<p>第四步proc_run函数调用switch_to函数，参数是前一个进程和后一个进程的执行现场。</p>
<p>switch.S中的switch_to函数的执行流程：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.globl switch_to</span><br><span class="line">switch_to: # switch_to(from, to)</span><br><span class="line">### save from&#x27;s registers ###</span><br><span class="line">movl 4(%esp), %eax # eax points to from</span><br><span class="line">popl 0(%eax)</span><br><span class="line"># esp--&gt; return address, so save return addr in FROM’s context</span><br><span class="line">保存前一个进程的执行现场，前两条汇编指令保存了进程在返回switch_to函数后的指令地址到context.eip中</span><br><span class="line"></span><br><span class="line">movl %esp, 4(%eax)</span><br><span class="line">……</span><br><span class="line">movl %ebp, 28(%eax)</span><br><span class="line"> 7条汇编指令完成了保存前一个进程的其他7个寄存器到context中的相应成员变量中</span><br><span class="line"></span><br><span class="line">### restore to&#x27;s registers ###</span><br><span class="line"> 恢复下一个进程的执行现场，这其实就是上述保存过程的逆执行过程</span><br><span class="line">movl 4(%esp), %eax # not 8(%esp): popped return address already</span><br><span class="line"># eax now points to to</span><br><span class="line"></span><br><span class="line">movl 28(%eax), %ebp</span><br><span class="line">……</span><br><span class="line">movl 4(%eax), %esp</span><br><span class="line"> 从context的高地址的成员变量ebp开始，逐一把相关成员变量的值赋值给对应的寄存器</span><br><span class="line"></span><br><span class="line">pushl 0(%eax) </span><br><span class="line"># push TO’s context’s eip, so return addr = TO’s eip</span><br><span class="line"> 把context中保存的下一个进程要执行的指令地址context.eip放到了堆栈顶</span><br><span class="line"></span><br><span class="line">ret </span><br><span class="line"> after ret, eip= TO’s eip</span><br><span class="line"> 把栈顶的内容赋值给EIP寄存器，这样就切换到下一个进程执行了，即当前进程已经是下一个进程了</span><br></pre></td></tr></table></figure><br>uCore会执行进程切换，让initproc执行。在对initproc进行初始化时，设置了initproc-&gt;context.eip = (uintptr_t)forkret，这样，当执行switch_to函数并返回后，initproc将执行其实际上的执行入口地址forkret。而forkret会调用位于kern/trap/trapentry.S中的forkrets函数执行，具体代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.globl __trapret</span><br><span class="line"> __trapret:</span><br><span class="line"> # restore registers from stack</span><br><span class="line"> popal</span><br><span class="line"> # restore %ds and %es</span><br><span class="line"> popl %es</span><br><span class="line"> popl %ds</span><br><span class="line"> # get rid of the trap number and error code</span><br><span class="line"> addl $0x8, %esp</span><br><span class="line"> iret</span><br><span class="line"></span><br><span class="line"> .globl forkrets</span><br><span class="line"> forkrets:</span><br><span class="line"> # set stack to this new process trapframe</span><br><span class="line"> movl 4(%esp), %esp </span><br><span class="line"> 把esp指向当前进程的中断帧，esp指向了current-&gt;tf.tf_eip</span><br><span class="line"> </span><br><span class="line"> jmp __trapret</span><br></pre></td></tr></table></figure><br>如果此时执行的是initproc，则current-&gt;tf.tf_eip=kernel_thread_entry，initproc-&gt;tf.tf_cs = KERNEL_CS，所以当执行完iret后，就开始在内核中执行kernel_thread_entry函数了。</p>
<p>而initproc-&gt;tf.tf_regs.reg_ebx = init_main，所以在kernl_thread_entry中执行“call %ebx”后，就开始执行initproc的主体了。Initprocde的主体函数很简单就是输出一段字符串，然后就返回到kernel_tread_entry函数，并进一步调用do_exit执行退出操作了。</p>
<h2 id="练习1：分配并初始化一个进程控制块"><a href="#练习1：分配并初始化一个进程控制块" class="headerlink" title="练习1：分配并初始化一个进程控制块"></a>练习1：分配并初始化一个进程控制块</h2><p>alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结 构，用于存储新建立的内核线程的管理信息。比较简单，state、pid和cr3需要考虑，其他的无脑赋0和memset一波带走就行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static struct proc_struct *</span><br><span class="line">alloc_proc(void) &#123;</span><br><span class="line">    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));</span><br><span class="line">    if (proc != NULL) &#123;</span><br><span class="line">    //LAB4:EXERCISE1 YOUR CODE</span><br><span class="line">    /*</span><br><span class="line">     * below fields in proc_struct need to be initialized</span><br><span class="line">     *       enum proc_state state;                      // Process state</span><br><span class="line">     *       int pid;                                    // Process ID</span><br><span class="line">     *       int runs;                                   // the running times of Proces</span><br><span class="line">     *       uintptr_t kstack;                           // Process kernel stack</span><br><span class="line">     *       volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?</span><br><span class="line">     *       struct proc_struct *parent;                 // the parent process</span><br><span class="line">     *       struct mm_struct *mm;                       // Process&#x27;s memory management field</span><br><span class="line">     *       struct context context;                     // Switch here to run process</span><br><span class="line">     *       struct trapframe *tf;                       // Trap frame for current interrupt</span><br><span class="line">     *       uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)</span><br><span class="line">     *       uint32_t flags;                             // Process flag</span><br><span class="line">     *       char name[PROC_NAME_LEN + 1];               // Process name</span><br><span class="line">     */</span><br><span class="line">        proc-&gt;state = PROC_UNINIT;</span><br><span class="line">        proc-&gt;pid = -1;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line">       </span><br><span class="line">        proc-&gt;runs = 0;</span><br><span class="line">        proc-&gt;kstack = 0;</span><br><span class="line">        proc-&gt;need_resched = 0;</span><br><span class="line">        proc-&gt;parent = NULL;</span><br><span class="line">        proc-&gt;mm = NULL;</span><br><span class="line">        memset(&amp;proc-&gt;context, 0, sizeof(struct context)); </span><br><span class="line">        proc-&gt;tf = NULL;</span><br><span class="line">        proc-&gt;flags = 0;</span><br><span class="line">        memset(proc-&gt;name, 0, PROC_NAME_LEN);		</span><br><span class="line">    &#125;</span><br><span class="line">    return proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？</p>
<p>结构体中存储了除eax之外的所有通用寄存器以及eip的数值，保存了线程运行的上下文信息；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> eip;</span><br><span class="line">    <span class="type">uint32_t</span> esp;</span><br><span class="line">    <span class="type">uint32_t</span> ebx;</span><br><span class="line">    <span class="type">uint32_t</span> ecx;</span><br><span class="line">    <span class="type">uint32_t</span> edx;</span><br><span class="line">    <span class="type">uint32_t</span> esi;</span><br><span class="line">    <span class="type">uint32_t</span> edi;</span><br><span class="line">    <span class="type">uint32_t</span> ebp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>context用于内核线程之间切换时，保存原先线程运行的上下文</p>
<p><code>struct trapframe *tf</code>的作用：</p>
<ul>
<li>在copy_thread函数中对tf进行了设置。在这个函数中，把context变量的esp设置成tf变量的地址，把eip设置成forkret函数指针。</li>
<li>forkret函数调用了__trapret进行中断返回，tf变量用于构造出新线程时，正确地将控制权转交给新的线程。</li>
</ul>
<h2 id="练习2：为新创建的内核线程分配资源"><a href="#练习2：为新创建的内核线程分配资源" class="headerlink" title="练习2：为新创建的内核线程分配资源"></a>练习2：为新创建的内核线程分配资源</h2><p>创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_fork函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。</p>
<p>ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是：</p>
<blockquote>
<p>创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。为内核线程创建新的线程控制块，并且对控制块中的每个成员变量进行正确的设置，使得之后可以正确切换到对应的线程中执行。练习2完成了在kern/process/proc.c中的do_fork函数中的处理过程。它的大致执行步骤包括：</p>
</blockquote>
<ul>
<li>调用alloc_proc，首先获得一块用户信息块。</li>
<li>为进程分配一个内核栈。</li>
<li>复制原进程的内存管理信息到新进程（但内核线程不必做此事）</li>
<li>复制原进程上下文到新进程</li>
<li>将新进程添加到进程列表</li>
<li>唤醒新进程</li>
<li>返回新进程号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* do_fork -     parent process for a new child process</span></span><br><span class="line"><span class="comment"> * @clone_flags: used to guide how to clone the child process</span></span><br><span class="line"><span class="comment"> * @stack:       the parent&#x27;s user stack pointer. if stack==0, It means to fork a kernel thread.</span></span><br><span class="line"><span class="comment"> * @tf:          the trapframe info, which will be copied to child process&#x27;s proc-&gt;tf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">do_fork</span><span class="params">(<span class="type">uint32_t</span> clone_flags, <span class="type">uintptr_t</span> <span class="built_in">stack</span>, <span class="keyword">struct</span> trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">//LAB4:EXERCISE2 YOUR CODE</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)</span></span><br><span class="line"><span class="comment">     *                 创建进程并初始化</span></span><br><span class="line"><span class="comment">     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack</span></span><br><span class="line"><span class="comment">     *                 创建页，大小为KSTACKPAGE，并作为进程的内核栈</span></span><br><span class="line"><span class="comment">     *   copy_mm:      process &quot;proc&quot; duplicate OR share process &quot;current&quot;&#x27;s mm according clone_flags</span></span><br><span class="line"><span class="comment">     *                 if clone_flags &amp; CLONE_VM, then &quot;share&quot; ; else &quot;duplicate&quot;</span></span><br><span class="line"><span class="comment">     *                 进程复制memory manager，根据clone_flag不同决定不同操作</span></span><br><span class="line"><span class="comment">     *   copy_thread:  setup the trapframe on the  process&#x27;s kernel stack top and</span></span><br><span class="line"><span class="comment">     *                 setup the kernel entry point and stack of process</span></span><br><span class="line"><span class="comment">     *                 在进程内核栈顶建立trapframe</span></span><br><span class="line"><span class="comment">     *   hash_proc:    add proc into proc hash_list</span></span><br><span class="line"><span class="comment">     *                 添加进程到hash_list中</span></span><br><span class="line"><span class="comment">     *   get_pid:      alloc a unique pid for process</span></span><br><span class="line"><span class="comment">     *                 为进程分配一个独特的pid</span></span><br><span class="line"><span class="comment">     *   wakeup_proc:  set proc-&gt;state = PROC_RUNNABLE</span></span><br><span class="line"><span class="comment">     * VARIABLES:</span></span><br><span class="line"><span class="comment">     *   proc_list:    the process set&#x27;s list</span></span><br><span class="line"><span class="comment">     *   nr_process:   the number of process set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. call alloc_proc to allocate a proc_struct</span></span><br><span class="line">    <span class="comment">// 为要创建的新的线程分配线程控制块的空间</span></span><br><span class="line">    proc = alloc_proc();</span><br><span class="line">    <span class="keyword">if</span>(proc == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    <span class="comment">// 判断是否分配到内存空间</span></span><br><span class="line">    <span class="comment">// 2. call setup_kstack to allocate a kernel stack for child process</span></span><br><span class="line">    <span class="comment">// 为新的线程设置栈，在本实验中，每个线程的栈的大小初始均为2个Page, 即8KB</span></span><br><span class="line">    <span class="type">int</span> status = setup_kstack(proc);</span><br><span class="line">    <span class="keyword">if</span>(status != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    <span class="comment">// 3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line">    <span class="comment">// 对虚拟内存空间进行拷贝，由于在本实验中，内核线程之间共享一个虚拟内存空间，因此实际上该函数不需要进行任何操作</span></span><br><span class="line">    status = copy_mm(clone_flags, proc);</span><br><span class="line">    <span class="keyword">if</span>(status != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    <span class="comment">// 4. call copy_thread to setup tf &amp; context in proc_struct</span></span><br><span class="line">    <span class="comment">// 在新创建的内核线程的栈上面设置伪造好的中端帧，便于后文中利用iret命令将控制权转移给新的线程</span></span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line">    <span class="comment">// 5. insert proc_struct into hash_list &amp;&amp; proc_list</span></span><br><span class="line">    <span class="comment">// 为新的线程创建pid</span></span><br><span class="line">    proc-&gt;pid = get_pid();</span><br><span class="line">    hash_proc(proc);</span><br><span class="line">    <span class="comment">// 将线程放入使用hash组织的链表中，便于加速以后对某个指定的线程的查找</span></span><br><span class="line">    nr_process ++;</span><br><span class="line">    <span class="comment">// 将全局线程的数目加1</span></span><br><span class="line">    list_add(&amp;proc_list, &amp;proc-&gt;list_link);</span><br><span class="line">    <span class="comment">// 将线程加入到所有线程的链表中，便于进行调度</span></span><br><span class="line">    <span class="comment">// 6. call wakeup_proc to make the new child process RUNNABLE</span></span><br><span class="line">    <span class="comment">// 唤醒该线程，即将该线程的状态设置为可以运行</span></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line">    <span class="comment">// 7. set ret vaule using child proc&#x27;s pid</span></span><br><span class="line">    <span class="comment">// 返回新线程的pid</span></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">fork_out:     </span><br></pre></td></tr></table></figure>
<p>请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。</p>
<p>可以。ucore中为fork的线程分配pid的函数为get_pid：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get_pid - alloc a unique pid for process</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_pid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(MAX_PID &gt; MAX_PROCESS);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="type">list_entry_t</span> *<span class="built_in">list</span> = &amp;proc_list, *le;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> next_safe = MAX_PID, last_pid = MAX_PID;</span><br><span class="line">    <span class="keyword">if</span> (++ last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">        last_pid = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> inside;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (last_pid &gt;= next_safe) &#123;</span><br><span class="line">    inside:</span><br><span class="line">        next_safe = MAX_PID;</span><br><span class="line">    repeat:</span><br><span class="line">        le = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">while</span> ((le = list_next(le)) != <span class="built_in">list</span>) &#123;</span><br><span class="line">            proc = le2proc(le, list_link);</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;pid == last_pid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++ last_pid &gt;= next_safe) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">                        last_pid = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    next_safe = MAX_PID;</span><br><span class="line">                    <span class="keyword">goto</span> repeat;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid) &#123;</span><br><span class="line">                next_safe = proc-&gt;pid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last_pid;</span><br><span class="line">&#125;            	</span><br></pre></td></tr></table></figure><br>如果有严格的next_safe &gt; last_pid + 1，那么可以直接取last_pid + 1作为新的pid（需要last_pid没有超出MAX_PID从而变成1），</p>
<p>如果在进入函数的时候，这两个变量之后没有合法的取值，也就是说next_safe &gt; last_pid + 1不成立，那么进入循环，在循环之中首先通过if(proc-&gt;pid == last_pid)这一分支确保了不存在任何进程的pid与last_pid重合，然后再通过if (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid)这一判断语句保证了不存在任何已经存在的pid满足：last_pid&lt; pid &lt; next_safe，这样就确保了最后能够找到这么一个满足条件的区间，获得合法的pid；</p>
<h2 id="练习3：阅读代码，理解-proc-run-函数和它调用的函数如何完成进程切换的。"><a href="#练习3：阅读代码，理解-proc-run-函数和它调用的函数如何完成进程切换的。" class="headerlink" title="练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。"></a>练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。</h2><p>唯一调用到这个函数是在线程调度器的schedule函数中，proc_run将proc加载到CPU<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proc_run - make process &quot;proc&quot; running on cpu</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> before call switch_to, should load  base addr of &quot;proc&quot;&#x27;s new PDT</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_run</span><span class="params">(<span class="keyword">struct</span> proc_struct *proc)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断需要运行的线程是否是正在运行的线程</span></span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123; </span><br><span class="line">        <span class="type">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> =</span> current, *next = proc;</span><br><span class="line">        <span class="comment">//如果不是的话，获取到切换前后的两个线程</span></span><br><span class="line">        local_intr_save(intr_flag);</span><br><span class="line">        <span class="comment">// 关闭中断</span></span><br><span class="line">        &#123;</span><br><span class="line">            current = proc;</span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE);</span><br><span class="line">            lcr3(next-&gt;cr3);</span><br><span class="line">            <span class="comment">// 设置了TSS和cr3，相当于是切换了页表和栈</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</span><br><span class="line">            <span class="comment">// switch_to恢复要运行的线程的上下文，然后由于恢复的上下文中已经将返回地址（copy_thread函数中完成）修改成了forkret函数的地址(如果这个线程是第一运行的话，否则就是切换到这个线程被切换出来的地址)，也就是会跳转到这个函数，最后进一步跳转到了__trapsret函数，调用iret最终将控制权切换到新的线程；</span></span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">        <span class="comment">// 使能中断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>forkret函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forkret -- the first kernel entry point of a new thread/process</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> the addr of forkret is setted in copy_thread function</span></span><br><span class="line"><span class="comment">//       after switch_to, the current proc will execute here.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">forkret</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    forkrets(current-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在本实验的执行过程中，创建且运行了几个内核线程？</p>
<p>总共创建了两个内核线程，分别为：</p>
<ul>
<li>idleproc: 最初的内核线程，在完成新的内核线程的创建以及各种初始化工作之后，进入死循环，用于调度其他线程；</li>
<li>initproc: 被创建用于打印”Hello World”的线程；</li>
</ul>
<p>语句 local_intr_save(intr_flag);….local_intr_restore(intr_flag);说明理由在这里有何作用? 请说明理由。</p>
<ul>
<li>关闭中断，使得在这个语句块内的内容不会被中断打断，是一个原子操作；</li>
<li>在proc_run函数中，将current指向了要切换到的线程，但是此时还没有真正将控制权转移过去，如果在这个时候出现中断打断这些操作，就会出现current中保存的并不是正在运行的线程的中断控制块，从而出现错误。</li>
</ul>
<h1 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h1><h2 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h2><p>了解第一个用户进程创建过程<br>了解系统调用框架的实现机制<br>了解ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理  </p>
<h2 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h2><p>实验4的线程运行都在内核态。实验5创建了用户进程，让用户进程在用户态执行，且在需要ucore支持时，可通过系统调用来让ucore提供服务。为此需要构造出第一个用户进程，并通过系统调用sys_fork/sys_exec/sys_exit/sys_wait来支持运行不同的应用程序，完成对用户进程的执行过程的基本管理。</p>
<h2 id="预备知识-1"><a href="#预备知识-1" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="实验执行流程概述"><a href="#实验执行流程概述" class="headerlink" title="实验执行流程概述"></a>实验执行流程概述</h3><p>提供各种操作系统功能的<strong>内核线程只能在CPU核心态运行是操作系统自身的要求</strong>，操作系统就要呆在核心态，才能管理整个计算机系统。ucore提供了用户态进程的创建和执行机制，给应用程序执行提供一个用户态运行环境。显然，由于进程的执行空间扩展到了用户态空间，且出现了创建子进程执行应用程序等与lab4有较大不同的地方，所以具体实现的不同主要集中在<strong>进程管理</strong>和<strong>内存管理部分</strong>。</p>
<p>首先，我们从ucore的初始化部分来看，kern_init中调用的物理内存初始化，进程管理初始化等都有一定的变化。在内存管理部分，与lab4最大的区别就是<strong>增加用户态虚拟内存的管理</strong>。</p>
<ul>
<li>首先为了管理用户态的虚拟内存，需要对页表的内容进行扩展，能够<strong>把部分物理内存映射为用户态虚拟内存</strong>。如果某进程执行过程中，CPU在用户态下执行（在CS段寄存器最低两位包含有一个2位的优先级域，如果为0，表示CPU运行在特权态；如果为3，表示CPU运行在用户态。），则可以访问本进程页表描述的用户态虚拟内存，但由于权限不够，不能访问内核态虚拟内存。</li>
<li>另一方面，在用户态内存空间和内核态内核空间之间需要拷贝数据，让<strong>CPU处在内核态才能完成对用户空间的读或写</strong>，为此需要设计专门的拷贝函数（copy_from_user和copy_to_user）完成。但反之则会导致违反CPU的权限管理，导致内存访问异常。</li>
<li>在进程管理方面，主要涉及到的是进程控制块中与内存管理相关的部分，包括建立进程的页表和维护进程可访问空间（可能还没有建立虚实映射关系）的信息；</li>
<li>加载一个ELF格式的程序到进程控制块管理的内存中的方法；</li>
<li>在进程复制（fork）过程中，把父进程的内存空间拷贝到子进程内存空间的技术；</li>
<li>另外一部分与用户态进程生命周期管理相关，包括让进程放弃CPU而睡眠等待某事件、让父进程等待子进程结束、一个进程杀死另一个进程、给进程发消息、建立进程的血缘关系链表。</li>
</ul>
<p>在用户进程管理中，首先，构造出第一个进程idle_proc，作为所有后续进程的祖先；然后，在proc_init函数中，对idle_proc进行进一步初始化，通过alloc把当前ucore的执行环境转变成idle内核线程的执行现场；然后调用kernl_thread来创建第二个内核线程init_main，而init_main内核线程有创建了user_main内核线程。到此，内核线程创建完毕。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proc_init - set up the first kernel thread idleproc &quot;idle&quot; by itself and</span></span><br><span class="line"><span class="comment">//           - create the second kernel thread init_main</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    list_init(&amp;proc_list);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HASH_LIST_SIZE; i ++) &#123;</span><br><span class="line">        list_init(hash_list + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((idleproc = alloc_proc()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;cannot alloc idleproc.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idleproc-&gt;pid = <span class="number">0</span>;</span><br><span class="line">    idleproc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">    idleproc-&gt;kstack = (<span class="type">uintptr_t</span>)bootstack;</span><br><span class="line">    idleproc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">    set_proc_name(idleproc, <span class="string">&quot;idle&quot;</span>);</span><br><span class="line">    nr_process ++;</span><br><span class="line"></span><br><span class="line">    current = idleproc;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = kernel_thread(init_main, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;create init_main failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initproc = find_proc(pid);</span><br><span class="line">    set_proc_name(initproc, <span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line">    assert(idleproc != <span class="literal">NULL</span> &amp;&amp; idleproc-&gt;pid == <span class="number">0</span>);</span><br><span class="line">    assert(initproc != <span class="literal">NULL</span> &amp;&amp; initproc-&gt;pid == <span class="number">1</span>);</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure></p>
<p>接下来是用户进程的创建过程。第一步实际上是通过user_main函数调用kernel_tread创建子进程，通过kernel_execve调用来把某一具体程序的执行内容放入内存。</p>
<p>具体的放置方式是根据<strong>ld在此文件上的地址分配</strong>为基本原则，把程序的不同部分放到某进程的用户空间中，从而通过此进程来完成程序描述的任务。一旦执行了这一程序对应的进程，就会从内核态切换到用户态继续执行。</p>
<p>以此类推：</p>
<blockquote>
<p><strong>CPU在用户空间执行的用户进程，其地址空间不会被其他用户的进程影响，但由于系统调用（用户进程直接获得操作系统服务的唯一通道）、外设中断和异常中断的会随时产生，从而间接推动了用户进程实现用户态到到内核态的切换工作。当进程执行结束后，需回收进程占用和没消耗完毕的设备整个过程，且为新的创建进程请求提供服务。</strong></p>
</blockquote>
<h3 id="创建用户进程"><a href="#创建用户进程" class="headerlink" title="创建用户进程"></a>创建用户进程</h3><h4 id="应用程序的组成和编译"><a href="#应用程序的组成和编译" class="headerlink" title="应用程序的组成和编译"></a>应用程序的组成和编译</h4><p>lab5中新增了一个文件夹user，其中是用于本实验的用户程序。如hello.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ulib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    cprintf(<span class="string">&quot;Hello world!!.\n&quot;</span>);</span><br><span class="line">    cprintf(<span class="string">&quot;I am process %d.\n&quot;</span>, getpid());</span><br><span class="line">    cprintf(<span class="string">&quot;hello pass.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>按照手册，注释掉Makefile的第六行，编译，（部分）输出如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">gcc -Iuser/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  </span><br><span class="line">-fno-stack-protector -Ilibs/ -Iuser/include/ -Iuser/libs/ -c user/pgdir.c -o obj/user/pgdir.o</span><br><span class="line"></span><br><span class="line">ld -m    elf_i386 -nostdlib -T tools/user.ld -o obj/__user_pgdir.out  </span><br><span class="line">  obj/user/libs/panic.o obj/user/libs/syscall.o obj/user/libs/ulib.o </span><br><span class="line">  obj/user/libs/initcode.o obj/user/libs/stdio.o obj/user/libs/umain.o  </span><br><span class="line">  obj/libs/string.o obj/libs/printfmt.o obj/libs/hash.o obj/libs/rand.o obj/user/pgdir.o</span><br><span class="line"></span><br><span class="line">+ ld bin/kernel</span><br><span class="line">ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  </span><br><span class="line">  obj/kern/init/entry.o obj/kern/init/init.o obj/kern/libs/stdio.o </span><br><span class="line">  obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o</span><br><span class="line">  obj/kern/debug/kmonitor.o obj/kern/driver/ide.o obj/kern/driver/clock.o </span><br><span class="line">  obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o </span><br><span class="line">  obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o </span><br><span class="line">  obj/kern/mm/pmm.o obj/kern/mm/swap_fifo.o obj/kern/mm/vmm.o obj/kern/mm/kmalloc.o </span><br><span class="line">  obj/kern/mm/swap.o obj/kern/mm/default_pmm.o obj/kern/fs/swapfs.o obj/kern/process/entry.o </span><br><span class="line">  obj/kern/process/switch.o obj/kern/process/proc.o obj/kern/schedule/sched.o </span><br><span class="line">  obj/kern/syscall/syscall.o  obj/libs/string.o obj/libs/printfmt.o obj/libs/hash.o obj/libs/rand.o </span><br><span class="line">  -b binary  obj/__user_badarg.out obj/__user_forktree.out obj/__user_faultread.out obj/__user_divzero.out </span><br><span class="line">  obj/__user_exit.out obj/__user_hello.out obj/__user_waitkill.out obj/__user_softint.out obj/__user_spin.out</span><br><span class="line">  obj/__user_yield.out obj/__user_badsegment.out obj/__user_testbss.out obj/__user_faultreadkernel.out </span><br><span class="line">  obj/__user_forktest.out obj/__user_pgdir.out</span><br></pre></td></tr></table></figure><br>从中可以看出，hello应用程序不仅仅是hello.c，还包含了支持hello应用程序的用户态库：</p>
<ul>
<li>user/libs/initcode.S：所有应用程序的起始用户态执行地址“_start”，调整了EBP和ESP后，调用umain函数。</li>
<li>user/libs/umain.c：实现了umain函数，这是所有应用程序执行的第一个C函数，它将调用应用程序的main函数，并在main函数结束后调用exit函数，而exit函数最终将调用sys_exit系统调用，让操作系统回收进程资源。</li>
<li>user/libs/ulib.[ch]：实现了最小的C函数库，除了一些与系统调用无关的函数，其他函数是对访问系统调用的包装。</li>
<li>user/libs/syscall.[ch]：用户层发出系统调用的具体实现。</li>
<li>user/libs/stdio.c：实现cprintf函数，通过系统调用sys_putc来完成字符输出。</li>
<li>user/libs/panic.c：实现__panic/__warn函数，通过系统调用sys_exit完成用户进程退出。</li>
</ul>
<p>在make的最后一步执行了一个ld命令，把hello应用程序的执行码obj/__user_hello.out连接在了ucore kernel的末尾。且ld命令会在kernel中会把__user_hello.out的位置和大小记录在全局变量<strong>_binary_obj___user_hello_out_start</strong>和<strong>_binary_obj___user_hello_out_size</strong>中，这样这个hello用户程序就能够和ucore内核一起被 bootloader加载到内存里中，并且通过这两个全局变量定位hello用户程序执行码的起始位置和大小。</p>
<h4 id="用户进程的虚拟地址空间"><a href="#用户进程的虚拟地址空间" class="headerlink" title="用户进程的虚拟地址空间"></a>用户进程的虚拟地址空间</h4><p>在tools/user.ld描述了用户程序的用户虚拟空间的执行入口虚拟地址：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    /* Load programs at this address: &quot;.&quot; means the current address */</span><br><span class="line">    . = 0x800020;</span><br></pre></td></tr></table></figure></p>
<p>在tools/kernel.ld描述了操作系统的内核虚拟空间的起始入口虚拟地址：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    /* Load the kernel at this address: &quot;.&quot; means the current address */</span><br><span class="line">    . = 0xC0100000;</span><br></pre></td></tr></table></figure><br>这样ucore把用户进程的虚拟地址空间分了两块:</p>
<ul>
<li>一块与内核线程一样，是所有用户进程都共享的内核虚拟地址空间，映射到同样的物理内存空间中，这样在物理内存中只需放置一份内核代码，使得用户进程从用户态进入核心态时，内核代码可以统一应对不同的内核程序；</li>
<li>另外一块是用户虚拟地址空间，虽然虚拟地址范围一样，但映射到不同且没有交集的物理内存空间中。这样当ucore把用户进程的执行代码（即应用程序的执行代码）和数据（即应用程序的全局变量等）放到用户虚拟地址空间中时，确保了各个进程不会“非法”访问到其他进程的物理内存空间。</li>
</ul>
<p>这样ucore给一个用户进程具体设定的虚拟内存空间（kern/mm/memlayout.h）如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> Virtual memory map:                                          Permissions</span><br><span class="line">                                                              kernel/user</span><br><span class="line"></span><br><span class="line">     4G ------------------&gt; +---------------------------------+</span><br><span class="line">                            |                                 |</span><br><span class="line">                            |         Empty Memory (*)        |</span><br><span class="line">                            |                                 |</span><br><span class="line">                            +---------------------------------+ 0xFB000000</span><br><span class="line">                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span><br><span class="line">     VPT -----------------&gt; +---------------------------------+ 0xFAC00000</span><br><span class="line">                            |        Invalid Memory (*)       | --/--</span><br><span class="line">     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000</span><br><span class="line">                            |                                 |</span><br><span class="line">                            |    Remapped Physical Memory     | RW/-- KMEMSIZE</span><br><span class="line">                            |                                 |</span><br><span class="line">     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000</span><br><span class="line">                            |        Invalid Memory (*)       | --/--</span><br><span class="line">     USERTOP -------------&gt; +---------------------------------+ 0xB0000000</span><br><span class="line">                            |           User stack            |</span><br><span class="line">                            +---------------------------------+</span><br><span class="line">                            |                                 |</span><br><span class="line">                            :                                 :</span><br><span class="line">                            |         ~~~~~~~~~~~~~~~~        |</span><br><span class="line">                            |         ~~~~~~~~~~~~~~~~        |</span><br><span class="line">                            :                                 :</span><br><span class="line">                            |                                 |</span><br><span class="line">                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">                            |       User Program &amp; Heap       |</span><br><span class="line">     UTEXT ---------------&gt; +---------------------------------+ 0x00800000</span><br><span class="line">                            |        Invalid Memory (*)       | --/--</span><br><span class="line">                            |  - - - - - - - - - - - - - - -  |</span><br><span class="line">                            |    User STAB Data (optional)    |</span><br><span class="line">     USERBASE, USTAB------&gt; +---------------------------------+ 0x00200000</span><br><span class="line">                            |        Invalid Memory (*)       | --/--</span><br><span class="line">     0 -------------------&gt; +---------------------------------+ 0x00000000</span><br><span class="line">(*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="line">    &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="line">    there if desired.</span><br><span class="line"></span><br><span class="line">*/                            </span><br></pre></td></tr></table></figure></p>
<h4 id="创建并执行用户进程"><a href="#创建并执行用户进程" class="headerlink" title="创建并执行用户进程"></a>创建并执行用户进程</h4><p>在确定了用户进程的执行代码和数据，以及用户进程的虚拟空间布局后，我们可以来创建用户进程了。在本实验中第一个用户进程是由第二个内核线程initproc通过把hello应用程序执行码覆盖到initproc的用户虚拟内存空间来创建的，相关代码如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// kernel_execve - do SYS_exec syscall to exec a user program called by user_main kernel_thread</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span></span><br><span class="line">    <span class="title function_">kernel_execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">char</span> *binary, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret, len = <span class="built_in">strlen</span>(name);</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;int %1;&quot;</span></span></span><br><span class="line"><span class="params">        : <span class="string">&quot;=a&quot;</span> (ret)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;i&quot;</span> (T_SYSCALL), <span class="string">&quot;0&quot;</span> (SYS_exec), <span class="string">&quot;d&quot;</span> (name), <span class="string">&quot;c&quot;</span> (len), <span class="string">&quot;b&quot;</span> (binary), <span class="string">&quot;D&quot;</span> (size)</span></span><br><span class="line"><span class="params">        : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> __KERNEL_EXECVE(name, binary, size) (&#123;                          \</span></span><br><span class="line"><span class="meta">            cprintf(<span class="string">&quot;kernel_execve: pid = %d, name = \&quot;%s\&quot;.\n&quot;</span>,        \</span></span><br><span class="line"><span class="meta">                    current-&gt;pid, name);                                \</span></span><br><span class="line"><span class="meta">            kernel_execve(name, binary, (size_t)(size));                \</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KERNEL_EXECVE(x) (&#123;                                             \</span></span><br><span class="line"><span class="meta">            extern unsigned char _binary_obj___user_##x##_out_start[],  \</span></span><br><span class="line"><span class="meta">                _binary_obj___user_##x##_out_size[];                    \</span></span><br><span class="line"><span class="meta">            __KERNEL_EXECVE(#x, _binary_obj___user_##x##_out_start,     \</span></span><br><span class="line"><span class="meta">                            _binary_obj___user_##x##_out_size);         \</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br><span class="line">……</span><br><span class="line"><span class="comment">// init_main - the second kernel thread used to create kswapd_main &amp; user_main kernel threads</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">init_main</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> TEST</span></span><br><span class="line">    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    KERNEL_EXECVE(hello);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    panic(<span class="string">&quot;kernel_execve failed.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>##的作用是参数的连接，把“exit”这个字符串连接到这个宏中的x对应位置</strong><br><strong>#的作用是使一个东西字符串化</strong></p>
<p>Initproc的执行主体是init_main函数，这个函数在缺省情况下是执行宏KERNEL_EXECVE(hello)，而这个宏最终是调用kernel_execve函数来调用SYS_exec系统调用，由于ld在链接hello应用程序执行码时定义了两全局变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_binary_obj___user_hello_out_start：hello执行码的起始位置</span><br><span class="line">_binary_obj___user_hello_out_size中：hello执行码的大小</span><br></pre></td></tr></table></figure></p>
<p>kernel_execve把这两个变量作为SYS_exec系统调用的参数，让ucore来创建此用户进程。当ucore收到此系统调用后，将依次调用如下函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector128(vectors.S) --&gt;</span><br><span class="line">__alltraps(trapentry.S) --&gt; trap(trap.c) --&gt; trap_dispatch(trap.c) --&gt; syscall(syscall.c) --&gt; sys_exec（syscall.c）--&gt; do_execve(proc.c)</span><br></pre></td></tr></table></figure><br>最终通过do_execve函数来完成用户进程的创建工作。此函数的主要工作流程如下：</p>
<ul>
<li>为加载新的执行码做好<strong>用户态内存空间清空</strong>准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的initproc是内核线程，所以mm为NULL，整个处理都不会做。</li>
<li><strong>加载应用程序执行码到当前进程的新创建的用户态虚拟空间中</strong>。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。load_icode函数完成了整个复杂的工作。</li>
<li>load_icode函数的主要工作就是给用户进程建立一个能够让用户进程正常运行的用户环境。此函数有一百多行，完成了如下重要工作：</li>
</ul>
<ol>
<li>调用mm_create函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化；</li>
<li>调用setup_pgdir来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（boot_pgdir所指）的内容拷贝到此新目录表中，最后让mm-&gt;pgdir指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核虚空间；</li>
<li>根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用mm_map函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等）的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间；</li>
<li>调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；</li>
</ol>
<ul>
<li>需要<strong>给用户进程设置用户栈</strong>，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址&lt;—&gt;物理地址映射关系；</li>
<li>至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把<strong>mm-&gt;pgdir赋值到cr3寄存器中</strong>，即<strong>更新了用户进程的虚拟内存空间</strong>，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；</li>
<li>先清空进程的中断帧，再<strong>重新设置进程的中断帧</strong>，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断；</li>
<li>至此，用户进程的用户环境已经搭建完毕。此时initproc将按产生系统调用的函数调用路径原路返回，执行中断返回指令“iret”（位于trapentry.S的最后一句）后，将切换到用户进程hello的第一条语句位置_start处（位于user/libs/initcode.S的第三句）开始执行。</li>
</ul>
<h4 id="进程退出和等待进程"><a href="#进程退出和等待进程" class="headerlink" title="进程退出和等待进程"></a>进程退出和等待进程</h4><p>ucore分了两步来完成进程退出工作，首先，进程本身完成大部分资源的占用内存回收工作，然后父进程完成剩余资源占用内存的回收工作。为何不让进程本身完成所有的资源回收工作呢？这是因为进程要执行回收操作，就表明此进程还存在，还在执行指令，这就需要内核栈的空间不能释放，且表示进程存在的进程控制块不能释放。所以需要父进程来帮忙释放子进程无法完成的这两个资源回收工作。</p>
<p>为此在用户态的函数库中提供了exit函数，此函数最终访问sys_exit系统调用接口让操作系统来帮助当前进程执行退出过程中的部分资源回收。</p>
<p>首先，exit函数会把一个退出码error_code传递给ucore，ucore通过执行内核函数do_exit来完成对当前进程的退出处理，主要工作是回收当前进程所占的大部分内存资源，并通知父进程完成最后的回收工作，具体流程如下：</p>
<ol>
<li>如果current-&gt;mm != NULL，表示是用户进程，则开始回收此用户进程所占用的用户态虚拟内存空间；</li>
</ol>
<ul>
<li>首先执行“lcr3(boot_cr3)”，切换到内核态的页表上，这样当前用户进程目前只能在内核虚拟地址空间执行了，这是为了确保后续释放用户态内存和进程页表的工作能够正常执行；</li>
<li>如果当前进程控制块的成员变量mm的成员变量mm_count减1后为0（表明这个mm没有再被其他进程共享，可以彻底释放进程所占的用户虚拟空间了。），则开始回收用户进程所占的内存资源：</li>
<li>调用exit_mmap函数释放current-&gt;mm-&gt;vma链表中每个vma描述的进程合法空间中实际分配的内存，然后把对应的页表项内容清空，最后还把页表所占用的空间释放并把对应的页目录表项清空；</li>
<li>调用put_pgdir函数释放当前进程的页目录所占的内存；</li>
<li>调用mm_destroy函数释放mm中的vma所占内存，最后释放mm所占内存；</li>
<li>此时设置current-&gt;mm为NULL，表示与当前进程相关的用户虚拟内存空间和对应的内存管理成员变量所占的内核虚拟内存空间已经回收完毕；</li>
</ul>
<ol>
<li>这时，设置当前进程的执行状态<code>current-&gt;state=PROC_ZOMBIE</code>，当前进程的退出码current-&gt;exit_code=error_code。此时当前进程已经不能被调度了，需要此进程的父进程来做最后的回收工作（即回收描述此进程的内核栈和进程控制块）；</li>
<li>如果当前进程的父进程current-&gt;parent处于等待子进程状态：<br><code>current-&gt;parent-&gt;wait_state==WT_CHILD</code>，<br>则唤醒父进程（即执行“<code>wakup_proc(current-&gt;parent)</code>”），让父进程帮助自己完成最后的资源回收；</li>
<li>如果当前进程还有子进程，则需要把这些子进程的父进程指针设置为内核线程initproc，且各个子进程指针需要插入到initproc的子进程链表中。如果某个子进程的执行状态是PROC_ZOMBIE，则需要唤醒initproc来完成对此子进程的最后回收工作。</li>
<li>执行schedule()函数，选择新的进程执行。</li>
</ol>
<p>那么父进程如何完成对子进程的最后回收工作呢？这要求父进程要执行wait用户函数或wait_pid用户函数，这两个函数的区别是，<strong>wait函数等待任意子进程的结束通知</strong>，而<strong>wait_pid函数等待进程id号为pid的子进程结束通知</strong>。这两个函数最终访问sys_wait系统调用接口让ucore来完成对子进程的最后回收工作，即回收子进程的内核栈和进程控制块所占内存空间，具体流程如下：</p>
<ol>
<li>如果pid!=0，表示只找一个进程id号为pid的退出状态的子进程，否则找任意一个处于退出状态的子进程；</li>
<li>如果此子进程的执行状态不为PROC_ZOMBIE，表明此子进程还没有退出，则当前进程只好设置自己的执行状态为PROC_SLEEPING，睡眠原因为WT_CHILD（即等待子进程退出），调用schedule()函数选择新的进程执行，自己睡眠等待，如果被唤醒，则重复跳回步骤1处执行；</li>
<li>如果此子进程的执行状态为PROC_ZOMBIE，表明此子进程处于退出状态，需要当前进程（即子进程的父进程）完成对子进程的最终回收工作，即首先把子进程控制块从两个进程队列proc_list和hash_list中删除，并释放子进程的内核堆栈和进程控制块。自此，子进程才彻底地结束了它的执行过程，消除了它所占用的所有资源。</li>
</ol>
<h4 id="系统调用实现"><a href="#系统调用实现" class="headerlink" title="系统调用实现"></a>系统调用实现</h4><p>用户进程只能在操作系统给它圈定好的“用户环境”中执行，但“用户环境”限制了用户进程能够执行的指令，即用户进程只能执行一般的指令，无法执行特权指令。如果用户进程想执行一些需要特权指令的任务，比如通过网卡发网络包等，只能让操作系统来代劳了。于是就需要一种机制来确保用户进程不能执行特权指令，但能够请操作系统“帮忙”完成需要特权指令的任务，这种机制就是系统调用。</p>
<p>采用系统调用机制为用户进程提供一个获得操作系统服务的统一接口层：</p>
<ul>
<li>一来可简化用户进程的实现，把一些共性的、繁琐的、与硬件相关、与特权指令相关的任务放到操作系统层来实现，但提供一个简洁的接口给用户进程调用；</li>
<li>二来这层接口事先可规定好，且严格检查用户进程传递进来的参数和操作系统要返回的数据，使得让操作系统给用户进程服务的同时，保护操作系统不会被用户进程破坏。</li>
</ul>
<p>从硬件层面上看，需要硬件能够支持在用户态的用户进程通过某种机制切换到内核态。</p>
<h5 id="初始化系统调用对应的中断描述符"><a href="#初始化系统调用对应的中断描述符" class="headerlink" title="初始化系统调用对应的中断描述符"></a>初始化系统调用对应的中断描述符</h5><p>在ucore初始化函数kern_init中调用了idt_init函数来初始化中断描述符表，并设置一个特定中断号的中断门，专门用于用户进程访问系统调用。此事由ide_init函数完成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">idt_init(void) &#123;</span><br><span class="line">    extern uintptr_t __vectors[];</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; sizeof(idt) / sizeof(struct gatedesc); i ++) &#123;</span><br><span class="line">        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，可以看到在执行加载中断描述符表lidt指令前，专门设置了一个特殊的中断描述符idt[T_SYSCALL]，它的特权级设置为DPL_USER，中断向量处理地址在<strong>vectors[T_SYSCALL]处。这样建立好这个中断描述符后，一旦用户进程执行“INT T_SYSCALL”后，由于此中断允许用户态进程产生（注意它的特权级设置为DPL_USER），所以CPU就会从用户态切换到内核态，保存相关寄存器，并跳转到</strong>vectors[T_SYSCALL]处开始执行，形成如下执行路径：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector128(vectors.S) --&gt; </span><br><span class="line">__alltraps(trapentry.S) --&gt; trap(trap.c) --&gt; trap_dispatch(trap.c) --&gt; syscall(syscall.c)</span><br></pre></td></tr></table></figure></p>
<h5 id="建立系统调用的用户库准备"><a href="#建立系统调用的用户库准备" class="headerlink" title="建立系统调用的用户库准备"></a>建立系统调用的用户库准备</h5><p>在操作系统中初始化好系统调用相关的中断描述符、中断处理起始地址等后，还需在用户态的应用程序中初始化好相关工作，简化应用程序访问系统调用的复杂性。为此在用户态建立了一个中间层，即简化的libc实现，在user/libs/ulib.[ch]和user/libs/syscall.[ch]中完成了对访问系统调用的封装。用户态最终的访问系统调用函数是syscall，实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static inline int</span><br><span class="line">syscall(int num, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, num);</span><br><span class="line">    uint32_t a[MAX_ARGS];</span><br><span class="line">    int i, ret;</span><br><span class="line">    for (i = 0; i &lt; MAX_ARGS; i ++) &#123;</span><br><span class="line">        a[i] = va_arg(ap, uint32_t);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    asm volatile (</span><br><span class="line">        &quot;int %1;&quot;</span><br><span class="line">        : &quot;=a&quot; (ret)</span><br><span class="line">        : &quot;i&quot; (T_SYSCALL),</span><br><span class="line">          &quot;a&quot; (num),</span><br><span class="line">          &quot;d&quot; (a[0]),</span><br><span class="line">          &quot;c&quot; (a[1]),</span><br><span class="line">          &quot;b&quot; (a[2]),</span><br><span class="line">          &quot;D&quot; (a[3]),</span><br><span class="line">          &quot;S&quot; (a[4])</span><br><span class="line">        : &quot;cc&quot;, &quot;memory&quot;);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从中可以看出，应用程序调用的exit/fork/wait/getpid等库函数最终都会调用syscall函数，只是调用的参数不同而已，如果看最终的汇编代码会更清楚：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">  34:    8b 55 d4               mov    -0x2c(%ebp),%edx</span><br><span class="line">  37:    8b 4d d8               mov    -0x28(%ebp),%ecx</span><br><span class="line">  3a:    8b 5d dc               mov    -0x24(%ebp),%ebx</span><br><span class="line">  3d:    8b 7d e0               mov    -0x20(%ebp),%edi</span><br><span class="line">  40:    8b 75 e4               mov    -0x1c(%ebp),%esi</span><br><span class="line">  43:    8b 45 08               mov    0x8(%ebp),%eax</span><br><span class="line">  46:    cd 80                  int    $0x80</span><br><span class="line">  48:    89 45 f0               mov    %eax,-0x10(%ebp)</span><br><span class="line">……</span><br></pre></td></tr></table></figure></p>
<p>可以看到其实是把系统调用号放到EAX，其他5个参数a[0]~a[4]分别保存到EDX/ECX/EBX/EDI/ESI五个寄存器中，及最多用6个寄存器来传递系统调用的参数，且系统调用的返回结果是EAX。比如对于getpid库函数而言，系统调用号（SYS_getpid=18）是保存在EAX中，返回值（调用此库函数的的当前进程号pid）也在EAX中。</p>
<h5 id="与用户进程相关的系统调用"><a href="#与用户进程相关的系统调用" class="headerlink" title="与用户进程相关的系统调用"></a>与用户进程相关的系统调用</h5><p>在本实验中，与进程相关的各个系统调用属性如下所示：<br>|系统调用名  | 含义 | 具体完成服务的函数 |<br>|——|——|——|<br>|SYS_exit   | process exit  |  do_exit |<br>|SYS_fork   | create child process, dup mm  |  do_fork—&gt;wakeup_proc |<br>|SYS_wait   | wait child process | do_wait |<br>|SYS_exec   | after fork, process execute a new program  | load a program and refresh the mm |<br>|SYS_yield  | process flag itself need resecheduling | proc-&gt;need_sched=1, then scheduler will rescheule this process |<br>|SYS_kill   | kill process  |  do_kill—&gt;proc-&gt;flags |= PF_EXITING, —&gt;wakeup_proc—&gt;do_wait—&gt;do_exit |<br>|SYS_getpid | get the process’s pid |  |</p>
<p>s##### 系统调用的执行过程<br>与用户态的函数库调用执行过程相比，系统调用执行过程的有四点主要的不同：</p>
<ul>
<li>不是通过“CALL”指令而是通过“INT”指令发起调用；</li>
<li>不是通过“RET”指令，而是通过“IRET”指令完成调用返回；</li>
<li>当到达内核态后，操作系统需要严格检查系统调用传递的参数，确保不破坏整个系统的安全性；</li>
<li>执行系统调用可导致进程等待某事件发生，从而可引起进程切换；</li>
</ul>
<p>下面我们以getpid系统调用的执行过程大致看看操作系统是如何完成整个执行过程的。当用户进程调用getpid函数，最终执行到<code>INT T_SYSCALL</code>指令后，CPU根据操作系统建立的系统调用中断描述符，转入内核态，并跳转到vector128处（kern/trap/vectors.S），开始了操作系统的系统调用执行过程，函数调用和返回操作的关系如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector128(vectors.S) --&gt; </span><br><span class="line">__alltraps(trapentry.S) --&gt; trap(trap.c) --&gt; trap_dispatch(trap.c) --&gt; syscall(syscall.c) --&gt; sys_getpid(syscall.c) --&gt; …… --&gt; __trapret(trapentry.S)</span><br></pre></td></tr></table></figure><br>在执行trap函数前，软件还需进一步保存执行系统调用前的执行现场，即把与用户进程继续执行所需的相关寄存器等当前内容保存到当前进程的中断帧trapframe中（注意，在创建进程是，把进程的trapframe放在给进程的内核栈分配的空间的顶部）。软件做的工作在vector128和__alltraps的起始部分：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vectors.S::vector128起始处:</span><br><span class="line">  pushl $0</span><br><span class="line">  pushl $128</span><br><span class="line">......</span><br><span class="line">trapentry.S::__alltraps起始处:</span><br><span class="line">pushl %ds</span><br><span class="line">  pushl %es</span><br><span class="line">  pushal</span><br><span class="line">……</span><br></pre></td></tr></table></figure></p>
<p>自此，用于保存用户态的用户进程执行现场的trapframe的内容填写完毕，操作系统可开始完成具体的系统调用服务。在sys_getpid函数中，简单地把当前进程的pid成员变量做为函数返回值就是一个具体的系统调用服务。完成服务后，操作系统按调用关系的路径原路返回到__alltraps中。然后操作系统开始根据当前进程的中断帧内容做恢复执行现场操作。其实就是把trapframe的一部分内容保存到寄存器内容。恢复寄存器内容结束后，调整内核堆栈指针到中断帧的tf_eip处，这是内核栈的结构如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* below here defined by x86 hardware */</span><br><span class="line">    uintptr_t tf_eip;</span><br><span class="line">    uint16_t tf_cs;</span><br><span class="line">    uint16_t tf_padding3;</span><br><span class="line">    uint32_t tf_eflags;</span><br><span class="line">/* below here only when crossing rings */</span><br><span class="line">    uintptr_t tf_esp;</span><br><span class="line">    uint16_t tf_ss;</span><br><span class="line">    uint16_t tf_padding4;</span><br></pre></td></tr></table></figure><br>这时执行<code>IRET</code>指令后，CPU根据内核栈的情况回复到用户态，并把EIP指向tf_eip的值，即<code>INT T_SYSCALL</code>后的那条指令。这样整个系统调用就执行完毕了。</p>
<h2 id="读load-icode有感"><a href="#读load-icode有感" class="headerlink" title="读load_icode有感"></a>读load_icode有感</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* load_icode - load the content of binary program(ELF format) as the new content of current process</span></span><br><span class="line"><span class="comment"> * @binary:  the memory addr of the content of binary program</span></span><br><span class="line"><span class="comment"> * @size:  the size of the content of binary program</span></span><br><span class="line"><span class="comment"> * 读取一个二进制elf文件并为其设置执行场景，并执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">load_icode</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *binary, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;load_icode: current-&gt;mm must be empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="comment">//(1) create a new mm for current process</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span></span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(3) copy TEXT/DATA section, build BSS parts in binary to memory space of process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="comment">//(3.1) get the file header of the bianry program (ELF format)</span></span><br><span class="line">    <span class="comment">// 将二进制串转成描述elf的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> *<span class="title">elf</span> =</span> (<span class="keyword">struct</span> elfhdr *)binary;</span><br><span class="line">    <span class="comment">//(3.2) get the entry of the program section headers of the bianry program (ELF format)</span></span><br><span class="line">    <span class="comment">// 获取elf头的起始地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span> =</span> (<span class="keyword">struct</span> proghdr *)(binary + elf-&gt;e_phoff);</span><br><span class="line">    <span class="comment">// 代码段的头</span></span><br><span class="line">    <span class="comment">//(3.3) This program is valid?</span></span><br><span class="line">    <span class="comment">// 第一个实验中说了elf的这个域是ELF_MAGIC</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> vm_flags, perm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph_end</span> =</span> ph + elf-&gt;e_phnum;</span><br><span class="line">    <span class="keyword">for</span> (; ph &lt; ph_end; ph ++) &#123;</span><br><span class="line">    <span class="comment">//(3.4) find every program section headers</span></span><br><span class="line">    <span class="comment">// 每一个程序段</span></span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">          <span class="comment">//程序段头里的这个程序段的类型，如可加载的代码、数据、动态链接信息等</span></span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个段的大小</span></span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//(3.5) call mm_map fun to setup the new vma ( ph-&gt;p_va, ph-&gt;p_memsz)</span></span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        <span class="comment">// 可读、可写、可执行？</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        <span class="comment">// 创建一个vma，并把这个vma加入到mm的list中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *from = binary + ph-&gt;p_offset;</span><br><span class="line">        <span class="type">size_t</span> off, size;</span><br><span class="line">        <span class="type">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//(3.6) alloc memory, and  copy the contents of every program section (from, from+end) to process&#x27;s memory</span></span><br><span class="line">(la, la+end)</span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line">     <span class="comment">//(3.6.1) copy TEXT/DATA section of bianry program</span></span><br><span class="line">     <span class="comment">// 分配页</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(page2kva(page) + off, from, size);</span><br><span class="line">            start += size, from += size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//(3.6.2) build BSS section of binary program</span></span><br><span class="line">        end =  ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; la) &#123;</span><br><span class="line">            <span class="comment">/* ph-&gt;p_memsz == ph-&gt;p_filesz */</span></span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(4) build user stack memory</span></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-2</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-3</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-4</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(5) set current process&#x27;s mm, sr3, and set CR3 reg = physical addr of Page Directory</span></span><br><span class="line">    mm_count_inc(mm); <span class="comment">// mm的count加1，计算有多少进程同时使用这个mm</span></span><br><span class="line">    current-&gt;mm = mm; <span class="comment">// 当前进程的mm是这个mm</span></span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir); <span class="comment">// 虚拟地址转换成物理地址</span></span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(6) setup trapframe for user environment</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    <span class="comment">/* LAB5:EXERCISE1 YOUR CODE</span></span><br><span class="line"><span class="comment">     * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags</span></span><br><span class="line"><span class="comment">     * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. S</span></span><br><span class="line"><span class="comment">o</span></span><br><span class="line"><span class="comment">     * tf_cs should be USER_CS segment (see memlayout.h)</span></span><br><span class="line"><span class="comment">     * tf_ds=tf_es=tf_ss should be USER_DS segment        </span></span><br><span class="line"><span class="comment">     * tf_esp should be the top addr of user stack (USTACKTOP)</span></span><br><span class="line"><span class="comment">     * tf_eip should be the entry point of this binary program (elf-&gt;e_entry)</span></span><br><span class="line"><span class="comment">     * tf_eflags should be set to enable computer to produce Interrupt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = USTACKTOP;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = <span class="number">0x00000002</span> | FL_IF; <span class="comment">// to enable interrupt</span></span><br><span class="line">    <span class="comment">//网上这里有的是这么写的，不知道为啥，我觉得应该只要FL_IF就够了，可能是我考虑不周</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #define FL_IF           0x00000200  // Interrupt Flag</span></span><br><span class="line"><span class="comment">    tf-&gt;tf_eflags = FL_IF;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="练习1：加载应用程序并执行"><a href="#练习1：加载应用程序并执行" class="headerlink" title="练习1：加载应用程序并执行"></a>练习1：加载应用程序并执行</h2><p>do_execv函数调用了load_icode函数（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序，并建立了相应的用户内存空间来存放应用程序的代码段、数据段 等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。</p>
<p>load_icode函数是由do_execve函数调用的，而该函数是exec系统调用的最终处理的函数，功能为将某一个指定的ELF可执行二进制文件加载到当前内存中来，然后当前进程执行这个可执行文件（先前执行的内容全部清空），而load_icode函数的功能则在于为执行新的程序初始化好内存空间，在调用该函数之前，do_execve中已经退出了当前进程的内存空间，改使用了内核的内存空间，这样使得对原先用户态的内存空间的操作成为可能；</p>
<p>由于最终是在用户态下运行的，所以需要将段寄存器初始化为用户态的代码段、数据段、堆栈段；<br>esp应当指向先前的步骤中创建的用户栈的栈顶；<br>eip应当指向ELF可执行文件加载到内存之后的入口处；<br>eflags中应当初始化为中断使能，注意eflags的第1位是恒为1的；<br>设置ret为0，表示正常返回；<br>见上边的函数代码。</p>
<p>首先在初始化IDT的时候，设置系统调用对应的中断描述符，使其能够在用户态下被调用，并且设置为trap类型。设置系统调用中断是用户态的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">extern</span> <span class="type">uintptr_t</span> __vectors[];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> gatedesc); i ++) &#123;</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Set up a normal interrupt/trap gate descriptor</span></span><br><span class="line"><span class="comment"> *   - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate</span></span><br><span class="line"><span class="comment"> *   - sel: Code segment selector for interrupt/trap handler</span></span><br><span class="line"><span class="comment"> *   - off: Offset in code segment for interrupt/trap handler</span></span><br><span class="line"><span class="comment"> *   - dpl: Descriptor Privilege Level - the privilege level required</span></span><br><span class="line"><span class="comment"> *          for software to invoke this interrupt/trap gate explicitly</span></span><br><span class="line"><span class="comment"> *          using an int instruction.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETGATE(gate, istrap, sel, off, dpl) &#123;               \</span></span><br><span class="line"><span class="meta">        (gate).gd_off_15_0 = (uint32_t)(off) &amp; 0xffff;      \</span></span><br><span class="line"><span class="meta">        (gate).gd_ss = (sel);                                \</span></span><br><span class="line"><span class="meta">        (gate).gd_args = 0;                                 \</span></span><br><span class="line"><span class="meta">        (gate).gd_rsv1 = 0;                                 \</span></span><br><span class="line"><span class="meta">        (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \</span></span><br><span class="line"><span class="meta">        (gate).gd_s = 0;                                    \</span></span><br><span class="line"><span class="meta">        (gate).gd_dpl = (dpl);                              \</span></span><br><span class="line"><span class="meta">        (gate).gd_p = 1;                                    \</span></span><br><span class="line"><span class="meta">        (gate).gd_off_31_16 = (uint32_t)(off) &gt;&gt; 16;        \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure><br>同样是在trap.c里，设置当计时器到点之后，也就是100个时钟周期之后，这个进程就是可以被重新调度的了，实现多线程的并发执行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks++;</span><br><span class="line">        <span class="keyword">if</span>(ticks&gt;=TICK_NUM)&#123;</span><br><span class="line">            assert(current != <span class="literal">NULL</span>);</span><br><span class="line">            current-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//print_ticks();</span></span><br><span class="line">            ticks=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* LAB5 YOUR CODE */</span></span><br><span class="line">        <span class="comment">/* you should upate you lab1 code (just add ONE or TWO lines of code):</span></span><br><span class="line"><span class="comment">         *    Every TICK_NUM cycle, you should set current process&#x27;s current-&gt;need_resched = 1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">-</span><br></pre></td></tr></table></figure><br>在proc_alloc函数中，额外对进程控制块中新增加的wait_state, cptr, yptr, optr成员变量进行初始化；<br>在alloc_proc(void)函数中，对新增的几个变量初始化<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//LAB5 YOUR CODE : (update LAB4 steps)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * below fields(add in LAB5) in proc_struct need to be initialized</span></span><br><span class="line"><span class="comment"> *       uint32_t wait_state;                        // waiting state</span></span><br><span class="line"><span class="comment"> *       struct proc_struct *cptr, *yptr, *optr;     // relations between processes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><br>在do_fork函数中，使用set_links函数来完成将fork的线程添加到线程链表中的过程，值得注意的是，该函数中就包括了将其加入list和对进程总数加1这一操作，因此需要将原先的这个操作给删除掉；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set_links - set the relation links of process</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">set_links</span><span class="params">(<span class="keyword">struct</span> proc_struct *proc)</span> &#123;</span><br><span class="line">    list_add(&amp;proc_list, &amp;(proc-&gt;list_link));</span><br><span class="line">    proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((proc-&gt;optr = proc-&gt;parent-&gt;cptr) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc-&gt;optr-&gt;yptr = proc;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;parent-&gt;cptr = proc;</span><br><span class="line">    nr_process ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LAB5 YOUR CODE : (update LAB4 steps)</span></span><br><span class="line"><span class="comment">/* Some Functions</span></span><br><span class="line"><span class="comment"> *    set_links:  set the relation links of process.  ALSO SEE: remove_links:  lean the relation links of process</span></span><br><span class="line"><span class="comment"> *    -------------------</span></span><br><span class="line"><span class="comment"> *    update step 1: set child proc&#x27;s parent to current process, make sure current process&#x27;s wait_state is 0</span></span><br><span class="line"><span class="comment"> *    update step 5: insert proc_struct into hash_list &amp;&amp; proc_list, set the relation links of process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 1. call alloc_proc to allocate a proc_struct</span></span><br><span class="line">    proc = alloc_proc();</span><br><span class="line">    <span class="keyword">if</span>(proc == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line"><span class="comment">// 2. call setup_kstack to allocate a kernel stack for child process</span></span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line">    assert(current-&gt;wait_state == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> status = setup_kstack(proc);</span><br><span class="line">    <span class="keyword">if</span>(status != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line"><span class="comment">// 3. call copy_mm to dup OR share mm according clone_flag</span></span><br><span class="line">    status = copy_mm(clone_flags, proc);</span><br><span class="line">    <span class="keyword">if</span>(status != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line"><span class="comment">// 4. call copy_thread to setup tf &amp; context in proc_struct</span></span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line"><span class="comment">// 5. insert proc_struct into hash_list &amp;&amp; proc_list</span></span><br><span class="line">    proc-&gt;pid = get_pid();</span><br><span class="line">    hash_proc(proc);</span><br><span class="line">    set_links(proc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete thses two lines !!!</span></span><br><span class="line">    <span class="comment">//nr_process ++;</span></span><br><span class="line">    <span class="comment">//list_add(&amp;proc_list, &amp;proc-&gt;list_link);</span></span><br><span class="line"><span class="comment">// delete thses two lines !!!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. call wakeup_proc to make the new child process RUNNABLE</span></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line"><span class="comment">// 7. set ret vaule using child proc&#x27;s pid</span></span><br><span class="line">    ret = proc-&gt;pid;</span><br></pre></td></tr></table></figure></p>
<p>请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态） 到具体执行应用程序第一条指令的整个经过。</p>
<ul>
<li>在经过调度器占用了CPU的资源之后，用户态进程调用了exec系统调用，从而转入到了系统调用的处理例程；</li>
<li>调用中断处理例程之后，最终控制权转移到了syscall.c中的syscall函数，然后根据系统调用号转移给了sys_exec函数，在该函数中调用了上文中提及的do_execve函数来完成指定应用程序的加载；</li>
<li>在do_execve中进行了若干设置，包括退出当前进程的页表，换用kernel的PDT之后，使用load_icode函数，完成了对整个用户线程内存空间的初始化，包括堆栈的设置以及将ELF可执行文件的加载，之后通过current-&gt;tf指针修改了当前系统调用的trapframe，使得最终中断返回的时候能够切换到用户态，并且同时可以正确地将控制权转移到应用程序的入口处；</li>
<li>在完成了do_exec函数之后，进行正常的中断返回的流程，由于中断处理例程的栈上面的eip已经被修改成了应用程序的入口处，而cs上的CPL是用户态，因此iret进行中断返回的时候会将堆栈切换到用户的栈，并且完成特权级的切换，并且跳转到要求的应用程序的入口处；</li>
<li>接下来开始具体执行应用程序的第一条指令；</li>
</ul>
<blockquote>
<p>本问题参考：<a href="https://www.jianshu.com/p/8c852af5b403">https://www.jianshu.com/p/8c852af5b403</a></p>
</blockquote>
<h2 id="练习2：父进程复制自己的内存空间给子进程"><a href="#练习2：父进程复制自己的内存空间给子进程" class="headerlink" title="练习2：父进程复制自己的内存空间给子进程"></a>练习2：父进程复制自己的内存空间给子进程</h2><p>创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于 kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。</p>
<ul>
<li>父进程调用fork()，进入中断处理机制，最终交由syscall函数进行处理；</li>
<li>在syscall，根据系统调用号，交由sys_fork函数处理；</li>
<li>进一步调用do_fork函数，这个函数创建了子进程、并且将父进程的内存空间复制给子进程；</li>
<li>在do_fork函数中，调用copy_mm进行内存空间的复制，在该函数中，进一步调用了dup_mmap。dup_mmap中遍历父进程的所有合法虚拟内存空间，并且将这些空间的内容复制到子进程的内存空间中去；</li>
<li>在copy_range函数中，对需要复制的内存空间按照页为单位从父进程的内存空间复制到子进程的内存空间中去；</li>
</ul>
<p>遍历父进程指定的某一段内存空间中的每一个虚拟页，如果这个虚拟页存在，为子进程对应的同一个地址（但是页目录表是不一样的，因此不是一个内存空间）也申请分配一个物理页，然后将前者中的所有内容复制到后者中去，然后为子进程的这个物理页和对应的虚拟地址（事实上是线性地址）建立映射关系；而在本练习中需要完成的内容就是内存的复制和映射的建立，具体流程如下：</p>
<ul>
<li>找到父进程指定的某一物理页对应的内核虚拟地址；</li>
<li>找到需要拷贝过去的子进程的对应物理页对应的内核虚拟地址；</li>
<li>将前者的内容拷贝到后者中去；</li>
<li>为子进程当前分配这一物理页映射上对应的在子进程虚拟地址空间里的一个虚拟页；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/* copy_range - copy content of memory (start, end) of one process A to another process B</span><br><span class="line"> * @to:    the addr of process B&#x27;s Page Directory</span><br><span class="line"> * @from:  the addr of process A&#x27;s Page Directory</span><br><span class="line"> * @share: flags to indicate to dup OR share. We just use dup method, so it didn&#x27;t be used.</span><br><span class="line"> *</span><br><span class="line"> * CALL GRAPH: copy_mm--&gt;dup_mmap--&gt;copy_range</span><br><span class="line"> */</span><br><span class="line">int</span><br><span class="line">copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end, bool share) &#123;</span><br><span class="line">    assert(start % PGSIZE == 0 &amp;&amp; end % PGSIZE == 0);</span><br><span class="line">    assert(USER_ACCESS(start, end));</span><br><span class="line">    // copy content by page unit.</span><br><span class="line">    do &#123;</span><br><span class="line">        //call get_pte to find process A&#x27;s pte according to the addr start</span><br><span class="line">        pte_t *ptep = get_pte(from, start, 0), *nptep;</span><br><span class="line">        if (ptep == NULL) &#123;</span><br><span class="line">            start = ROUNDDOWN(start + PTSIZE, PTSIZE);</span><br><span class="line">            continue ;</span><br><span class="line">        &#125;</span><br><span class="line">        //call get_pte to find process B&#x27;s pte according to the addr start. If pte is NULL, just alloc a PT</span><br><span class="line">        if (*ptep &amp; PTE_P) &#123;</span><br><span class="line">            if ((nptep = get_pte(to, start, 1)) == NULL) &#123;</span><br><span class="line">                return -E_NO_MEM;</span><br><span class="line">            &#125;</span><br><span class="line">        uint32_t perm = (*ptep &amp; PTE_USER);</span><br><span class="line">        //get page from ptep</span><br><span class="line">        struct Page *page = pte2page(*ptep);</span><br><span class="line">        // alloc a page for process B</span><br><span class="line">        struct Page *npage=alloc_page();</span><br><span class="line">        assert(page!=NULL);</span><br><span class="line">        assert(npage!=NULL);</span><br><span class="line">        int ret=0;</span><br><span class="line">        /* LAB5:EXERCISE2 YOUR CODE</span><br><span class="line">         * replicate content of page to npage, build the map of phy addr of nage with the linear addr start</span><br><span class="line">         *</span><br><span class="line">         * Some Useful MACROs and DEFINEs, you can use them in below implementation.</span><br><span class="line">         * MACROs or Functions:</span><br><span class="line">         *    page2kva(struct Page *page): return the kernel vritual addr of memory which page managed (SEE pmm.</span><br><span class="line">h)</span><br><span class="line">         *    page_insert: build the map of phy addr of an Page with the linear addr la</span><br><span class="line">         *    memcpy: typical memory copy function</span><br><span class="line">         *</span><br><span class="line">         * (1) find src_kvaddr: the kernel virtual address of page</span><br><span class="line">         * (2) find dst_kvaddr: the kernel virtual address of npage</span><br><span class="line">         * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE</span><br><span class="line">         * (4) build the map of phy addr of  nage with the linear addr start</span><br><span class="line">         */</span><br><span class="line">         char *src_kvaddr = page2kva(page); </span><br><span class="line">         //找到父进程需要复制的物理页在内核地址空间中的虚拟地址，这是由于这个函数执行的时候使用的时内核的地址空间</span><br><span class="line">         char *dst_kvaddr = page2kva(npage); </span><br><span class="line">         // 找到子进程需要被填充的物理页的内核虚拟地址</span><br><span class="line">        memcpy(dst_kvaddr, src_kvaddr, PGSIZE); </span><br><span class="line">        // 将父进程的物理页的内容复制到子进程中去</span><br><span class="line">        page_insert(to, npage, start, perm); </span><br><span class="line">        // 建立子进程的物理页与虚拟页的映射关系</span><br><span class="line">        assert(ret == 0);</span><br><span class="line">        &#125;</span><br><span class="line">        start += PGSIZE;</span><br><span class="line">    &#125; while (start != 0 &amp;&amp; start &lt; end);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;            </span><br></pre></td></tr></table></figure>
<h2 id="练习3：阅读分析源代码，理解进程执行-fork-exec-wait-exit-的实现，以及系统调用的实现（不需要编码）"><a href="#练习3：阅读分析源代码，理解进程执行-fork-exec-wait-exit-的实现，以及系统调用的实现（不需要编码）" class="headerlink" title="练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）"></a>练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）</h2><ol>
<li><p>fork：在执行了fork系统调用之后，会执行正常的中断处理流程，到中断向量表里查系统调用入口，最终将控制权转移给syscall，之后根据系统调用号执行sys_fork函数，进一步执行了上文中的do_fork函数，新进程的进程控制块进行初始化、设置、以及调用copy_mm将父进程内存中的内容到子进程的内存的复制工作，然后调用wakeup_proc将新创建的进程放入可执行队列（runnable），之后由调度器对子进程进行调度。</p>
</li>
<li><p>exec：在执行了exec系统调用之后，会执行正常的中断处理流程，到中断向量表里查系统调用入口，最终将控制权转移给syscall，之后根据系统调用号执行sys_exec函数，进一步执行了上文中的do_execve函数。在该函数中，会对内存空间进行清空，然后调用load_icode将将要执行的程序加载到内存中，然后调用lcr3(boot_cr4)设置好中断帧，使得最终中断返回之后可以跳转到指定的应用程序的入口处，就可以正确执行了。</p>
</li>
<li><p>wait：在执行了wait系统调用之后，会执行正常的中断处理流程，到中断向量表里查系统调用入口，最终将控制权转移给syscall，之后根据系统调用号执行sys_wait函数，进一步执行了的do_wait函数，在这个函数中，找一个当前进程的处于ZOMBIE状态的子进程，如果有的话直接将其占用的资源释放掉即可；如果找不到，则将我这个进程的状态改成SLEEPING态，并且标记为等待ZOMBIE态的子进程，然后调用schedule函数将其当前线程从CPU占用中切换出去，直到有对应的子进程结束来唤醒这个进程为止。</p>
</li>
<li><p>exit：在执行了exit系统调用之后，会执行正常的中断处理流程，到中断向量表里查系统调用入口，最终将控制权转移给syscall，之后根据系统调用号执行sys_exit函数，进一步执行了的do_exit函数，首先将释放当前进程的大多数资源，然后将其标记为ZOMBIE态，然后调用wakeup_proc函数将其父进程唤醒（如果父进程执行了wait进入SLEEPING态的话），然后调用schedule函数，让出CPU资源，等待父进程进一步完成其所有资源的回收；</p>
</li>
</ol>
<p>问题回答</p>
<p>请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？</p>
<p>fork不会影响当前进程的执行状态，但是会将子进程的状态标记为RUNNALB，使得可以在后续的调度中运行起来；<br>exec不会影响当前进程的执行状态，但是会修改当前进程中执行的程序；<br>wait系统调用取决于是否存在可以释放资源（ZOMBIE）的子进程，如果有的话不会发生状态的改变，如果没有的话会将当前进程置为SLEEPING态，等待执行了exit的子进程将其唤醒；<br>exit会将当前进程的状态修改为ZOMBIE态，并且会将父进程唤醒（修改为RUNNABLE），然后主动让出CPU使用权；</p>
<h1 id="实验六"><a href="#实验六" class="headerlink" title="实验六"></a>实验六</h1><h2 id="实验目的-2"><a href="#实验目的-2" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li>理解操作系统的调度管理机制</li>
<li>熟悉 ucore 的系统调度器框架，以及缺省的Round-Robin 调度算法</li>
<li>基于调度器框架实现一个(Stride Scheduling)调度算法来替换缺省的调度算法</li>
</ul>
<h2 id="实验内容-3"><a href="#实验内容-3" class="headerlink" title="实验内容"></a>实验内容</h2><ul>
<li>实验五完成了用户进程的管理，可在用户态运行多个进程。</li>
<li>之前采用的调度策略是很简单的FIFO调度策略。</li>
<li>本次实验，主要是熟悉ucore的系统调度器框架，以及基于此框架的Round-Robin（RR） 调度算法。</li>
<li>然后参考RR调度算法的实现，完成Stride Scheduling调度算法。</li>
</ul>
<h2 id="调度框架和调度算法设计与实现"><a href="#调度框架和调度算法设计与实现" class="headerlink" title="调度框架和调度算法设计与实现"></a>调度框架和调度算法设计与实现</h2><p>实验六中的kern/schedule/sched.c只实现了调度器框架，而不再涉及具体的调度算法实现，调度算法在单独的文件（default_sched.[ch]）中实现。</p>
<p>在init.c中的kern_init函数中的proc_init之前增加了对sched_init函数的调用。sched_init函数主要完成了对实现特定调度算法的调度类（sched_class，这里是default_sched_class）的绑定，使得ucore在后续的执行中，能够通过调度框架找到实现特定调度算法的调度类并完成进程调度相关工作。</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span>                      <span class="comment">// Process state</span></span><br><span class="line">    <span class="type">int</span> pid;                                    <span class="comment">// Process ID</span></span><br><span class="line">    <span class="type">int</span> runs;                                   <span class="comment">// the running times of Proces</span></span><br><span class="line">    <span class="type">uintptr_t</span> kstack;                           <span class="comment">// Process kernel stack</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">bool</span> need_resched;                 <span class="comment">// bool value: need to be rescheduled to release CPU?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span>                 <span class="comment">// the parent process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>                       <span class="comment">// Process&#x27;s memory management field</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>                     <span class="comment">// Switch here to run process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>                       <span class="comment">// Trap frame for current interrupt</span></span><br><span class="line">    <span class="type">uintptr_t</span> cr3;                              <span class="comment">// CR3 register: the base addr of Page Directroy Table(PDT)</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;                             <span class="comment">// Process flag</span></span><br><span class="line">    <span class="type">char</span> name[PROC_NAME_LEN + <span class="number">1</span>];               <span class="comment">// Process name</span></span><br><span class="line">    <span class="type">list_entry_t</span> list_link;                     <span class="comment">// Process link list</span></span><br><span class="line">    <span class="type">list_entry_t</span> hash_link;                     <span class="comment">// Process hash list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ucore定义的进程控制块struct proc_struct包含了成员变量state,用于描述进程的运行状态，而running和runnable共享同一个状态(state)值(PROC_RUNNABLE。不同之处在于处于running态的进程不会放在运行队列中。进程的正常生命周期如下：</p>
<ul>
<li>进程首先在 cpu 初始化或者 sys_fork 的时候被创建，当为该进程分配了一个进程控制块之后，该进程进入 uninit态(在proc.c 中 alloc_proc)。</li>
<li>当进程完全完成初始化之后，该进程转为runnable态。</li>
<li>当到达调度点时，由调度器<code>sched_class</code>根据运行队列run_queue的内容来判断一个进程是否应该被运行，即把处于runnable态的进程转换成running状态，从而占用CPU执行。</li>
<li>running态的进程通过wait等系统调用被阻塞，进入sleeping态。</li>
<li>sleeping态的进程被wakeup变成runnable态的进程。</li>
<li>running态的进程主动 exit 变成zombie态，然后由其父进程完成对其资源的最后释放，子进程的进程控制块成为unused。</li>
<li>所有从runnable态变成其他状态的进程都要出运行队列，反之，被放入某个运行队列中。</li>
</ul>
<h3 id="进程调度实现"><a href="#进程调度实现" class="headerlink" title="进程调度实现"></a>进程调度实现</h3><h4 id="内核抢占点"><a href="#内核抢占点" class="headerlink" title="内核抢占点"></a>内核抢占点</h4><p>对于用户进程而言，由于有中断的产生，可以随时打断用户进程的执行，转到操作系统内部，从而给了操作系统以调度控制权，让操作系统可以根据具体情况（比如用户进程时间片已经用完了）选择其他用户进程执行。这体现了用户进程的可抢占性。</p>
<p>ucore内核执行是不可抢占的（non-preemptive），即在执行“任意”内核代码时，CPU控制权不可被强制剥夺。这里需要注意，不是在所有情况下ucore内核执行都是不可抢占的，有以下几种“固定”情况是例外：</p>
<ol>
<li>进行同步互斥操作，比如争抢一个信号量、锁（lab7中会详细分析）；</li>
<li>进行磁盘读写等耗时的异步操作，由于等待完成的耗时太长，ucore会调用shcedule让其他就绪进程执行。</li>
</ol>
<p>以上两种是因为某个资源（也可称为事件）无法得到满足，无法继续执行下去，从而不得不主动放弃对CPU的控制权。在lab5中有几种情况是调用了schedule函数的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编号</th>
<th>位置</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>proc.c:do_exit</td>
<td>用户线程执行结束，主动放弃CPU</td>
</tr>
<tr>
<td>2</td>
<td>proc.c:do_wait</td>
<td>用户线程等待着子进程结束，主动放弃CPU</td>
</tr>
<tr>
<td>3</td>
<td>proc.c:init_main</td>
<td>Init_porc内核线程等待所有用户进程结束；所有用户进程结束后回收系统资源</td>
</tr>
<tr>
<td>4</td>
<td>proc.c:cpu_idle</td>
<td>idleproc内核线程等待处于就绪态的进程或线程，如果有选择一个并切换</td>
</tr>
<tr>
<td>5</td>
<td>sync.h:lock</td>
<td>进程无法得到锁，则主动放弃CPU</td>
</tr>
<tr>
<td>6</td>
<td>trap.c:trap</td>
<td>修改当前进程时间片，若时间片用完，则设置need_resched为1，让当前进程放弃CPU</td>
</tr>
</tbody>
</table>
</div>
<p>第1、2、5处的执行位置体现了由于获取某种资源一时等不到满足、进程要退出、进程要睡眠等原因而不得不主动放弃CPU。第3、4处的执行位置比较特殊，initproc内核线程等待用户进程结束而执行schedule函数；idle内核线程在没有进程处于就绪态时才执行，一旦有了就绪态的进程，它将执行schedule函数完成进程调度。这里只有第6处的位置比较特殊：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!in_kernel) &#123;</span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    if (current-&gt;need_resched) &#123;</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有当进程在用户态执行到“任意”某处用户代码位置时发生了中断，且当前进程控制块成员变量need_resched为1（表示需要调度了）时，才会执行shedule函数。这实际上体现了对用户进程的可抢占性。如果没有第一行的if语句，那么就可以体现对内核代码的可抢占性。但如果要把这一行if语句去掉，我们就不得不实现对ucore中的所有全局变量的互斥访问操作，以防止所谓的race-condition现象，这样ucore的实现复杂度会增加不少。</p>
<p>Race condition旨在描述一个系统或者进程的输出依赖于不受控制的事件出现顺序或者出现时机。此词源自于两个信号试着彼此竞争，来影响谁先输出。 举例来说，如果计算机中的两个进程同时试图修改一个共享内存的内容，在没有并发控制的情况下，最后的结果依赖于两个进程的执行顺序与时机。而且如果发生了并发访问冲突，则最后的结果是不正确的。从维基百科的定义来看，race condition不仅仅是出现在程序中。以下讨论的race conditon全是计算机中多个进程同时访问一个共享内存，共享变量的例子。</p>
<p>要阻止出现race condition情况的关键就是不能让多个进程同时访问那块共享内存。访问共享内存的那段代码就是critical section。所有的解决方法都是围绕这个critical section来设计的。想要成功的解决race condition问题，并且程序还可以正确运行，从理论上应该满足以下四个条件： </p>
<ol>
<li>不会有两个及以上进程同时出现在他们的critical section。 </li>
<li>不要做任何关于CPU速度和数量的假设。 </li>
<li>任何进程在运行到critical section之外时都不能阻塞其他进程。 </li>
<li>不会有进程永远等在critical section之前。</li>
</ol>
<h4 id="进程切换过程"><a href="#进程切换过程" class="headerlink" title="进程切换过程"></a>进程切换过程</h4><p>进程调度函数schedule选择了下一个将占用CPU执行的进程后，将调用进程切换，从而让新的进程得以执行。</p>
<p>两个用户进程，在二者进行进程切换的过程中，具体的步骤如下：</p>
<ol>
<li>首先在执行某进程A的用户代码时，出现了一个<code>trap</code>，这个时候就会从进程A的用户态切换到内核态(过程(1))，并且保存好进程A的trapframe；当内核态处理中断时发现需要进行进程切换时，ucore要通过schedule函数选择下一个将占用CPU执行的进程（即进程B），然后会调用proc_run函数，proc_run函数进一步调用switch_to函数，切换到进程B的内核态(过程(2))，继续进程B上一次在内核态的操作，并通过iret指令，最终将执行权转交给进程B的用户空间(过程(3))。</li>
<li>当进程B由于某种原因发生中断之后(过程(4))，会从进程B的用户态切换到<strong>内核态</strong>，并且保存好进程B的trapframe；当内核态处理中断时发现需要进行进程切换时，即需要切换到进程A，ucore再次切换到进程A(过程(5))，会执行进程A上一次在内核调用schedule函数返回后的下一行代码，这行代码当然还是在进程A的上一次中断处理流程中。最后当进程A的中断处理完毕的时候，执行权又会反交给进程A的用户代码(过程(6))。这就是在只有两个进程的情况下，进程切换间的大体流程。</li>
</ol>
<h3 id="调度框架和调度算法"><a href="#调度框架和调度算法" class="headerlink" title="调度框架和调度算法"></a>调度框架和调度算法</h3><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>在操作方面，如果需要选择一个就绪进程，就可以从基于某种组织方式的就绪进程集合中选择出一个进程执行。<strong>选择</strong>是在集合中挑选一个“合适”的进程，<strong>出</strong>意味着离开就绪进程集合。</p>
<p>另外考虑到一个处于运行态的进程还会由于某种原因（比如时间片用完了）回到就绪态而不能继续占用CPU执行，这就会重新进入到就绪进程集合中。这两种情况就形成了调度器相关的三个基本操作：<strong>在就绪进程集合中选择</strong>、<strong>进入就绪进程集合</strong>和<strong>离开就绪进程集合</strong>。这三个操作属于调度器的基本操作。</p>
<p>在进程的执行过程中，<strong>就绪进程的等待时间</strong>和<strong>执行进程的执行时间</strong>是影响调度选择的重要因素。这些进程状态变化的情况需要及时让进程调度器知道，便于选择更合适的进程执行。所以这种进程变化的情况就形成了调度器相关的一个变化感知操作：<strong>timer时间事件感知操作</strong>。这样在进程运行或等待的过程中，调度器可以调整进程控制块中与进程调度相关的属性值（比如消耗的时间片、进程优先级等），并可能导致对进程组织形式的调整（比如以时间片大小的顺序来重排双向链表等），并最终可能导致调选择新的进程占用CPU运行。这个操作属于调度器的进程调度属性调整操作。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li>在 ucore 中，调度器引入 run-queue（简称rq,即运行队列）的概念，通过链表结构管理进程。</li>
<li>由于目前 ucore 设计运行在单CPU上，其内部只有一个全局的运行队列，用来管理系统内全部的进程。</li>
<li>运行队列通过链表的形式进行组织。链表的每一个节点是一个list_entry_t,每个list_entry_t 又对应到了<code>struct proc_struct *</code>，这其间的转换是通过宏<code>le2proc</code>来完成。</li>
<li>具体来说，我们知道在<code>struct proc_struct</code>中有一个叫<code>run_link</code>的<code>list_entry_t</code>，因此可以通过偏移量逆向找到对因某个<code>run_list</code>的<code>struct proc_struct</code>。即进程结构指针<code>proc = le2proc(链表节点指针, run_link)</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The introduction of scheduling classes is borrrowed from Linux, and makes the</span></span><br><span class="line"><span class="comment">// core scheduler quite extensible. These classes (the scheduler modules) encapsulate</span></span><br><span class="line"><span class="comment">// the scheduling policies.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="comment">// the name of sched_class</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="comment">// 初始化运行队列</span></span><br><span class="line">    <span class="type">void</span> (*init)(<span class="keyword">struct</span> run_queue *rq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// put the proc into runqueue, and this function must be called with rq_lock</span></span><br><span class="line">    <span class="comment">// 进程放入运行队列</span></span><br><span class="line">    <span class="type">void</span> (*enqueue)(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the proc out runqueue, and this function must be called with rq_lock</span></span><br><span class="line">    <span class="comment">// 从队列中取出</span></span><br><span class="line">    <span class="type">void</span> (*dequeue)(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// choose the next runnable task</span></span><br><span class="line">    <span class="comment">// 选择下一个可运行的任务</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *(*<span class="title">pick_next</span>)(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dealer of the time-tick</span></span><br><span class="line">    <span class="comment">// 处理tick中断</span></span><br><span class="line">    <span class="type">void</span> (*proc_tick)(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* for SMP support in the future</span></span><br><span class="line"><span class="comment">     *  load_balance</span></span><br><span class="line"><span class="comment">     *     void (*load_balance)(struct rq* rq);</span></span><br><span class="line"><span class="comment">     *  get some proc from this rq, used in load_balance,</span></span><br><span class="line"><span class="comment">     *  return value is the num of gotten proc</span></span><br><span class="line"><span class="comment">     *  int (*get_proc)(struct rq* rq, struct proc* procs_moved[]);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>proc.h 中的 struct proc_struct 中也记录了一些调度相关的信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct proc_struct &#123;</span><br><span class="line">    enum proc_state state;                      // Process state</span><br><span class="line">    int pid;                                    // Process ID</span><br><span class="line">    int runs;                                   // the running times of Proces</span><br><span class="line">    uintptr_t kstack;                           // Process kernel stack</span><br><span class="line">    volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?</span><br><span class="line">    struct proc_struct *parent;                 // the parent process</span><br><span class="line">    struct mm_struct *mm;                       // Process&#x27;s memory management field</span><br><span class="line">    struct context context;                     // Switch here to run process</span><br><span class="line">    struct trapframe *tf;                       // Trap frame for current interrupt</span><br><span class="line">    uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)</span><br><span class="line">    uint32_t flags;                             // Process flag</span><br><span class="line">    char name[PROC_NAME_LEN + 1];               // Process name</span><br><span class="line">    list_entry_t list_link;                     // Process link list</span><br><span class="line">    list_entry_t hash_link;                     // Process hash list</span><br><span class="line">    int exit_code;                              // exit code (be sent to parent proc)</span><br><span class="line">    uint32_t wait_state;                        // waiting state</span><br><span class="line">    struct proc_struct *cptr, *yptr, *optr;     // relations between processes</span><br><span class="line">    struct run_queue *rq;                       // running queue contains Process</span><br><span class="line">    list_entry_t run_link;                      // the entry linked in run queue </span><br><span class="line">    // 该进程的调度链表结构，该结构内部的连接组成了 运行队列 列表</span><br><span class="line"></span><br><span class="line">    int time_slice;                             // time slice for occupying the CPU</span><br><span class="line">    // 进程剩余的时间片</span><br><span class="line">    skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool</span><br><span class="line">    //在优先队列中用到的</span><br><span class="line"></span><br><span class="line">    uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process</span><br><span class="line">    // 步进值</span><br><span class="line"></span><br><span class="line">    uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)</span><br><span class="line">    // 优先级</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>RR调度算法在<code>RR_sched_class</code>调度策略类中实现。<br>通过数据结构 struct run_queue 来描述完整的 run_queue（运行队列）。它的主要结构如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct run_queue &#123;</span><br><span class="line">    //其运行队列的哨兵结构，可以看作是队列头和尾</span><br><span class="line">    list_entry_t run_list;</span><br><span class="line">    //优先队列形式的进程容器，只在 LAB6 中使用</span><br><span class="line">    skew_heap_entry_t *lab6_run_pool;</span><br><span class="line">    //表示其内部的进程总数</span><br><span class="line">    unsigned int proc_num;</span><br><span class="line">    //每个进程一轮占用的最多时间片</span><br><span class="line">    int max_time_slice;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在 ucore 框架中，运行队列存储的是当前可以调度的进程，所以，只有状态为runnable的进程才能够进入运行队列。当前正在运行的进程并不会在运行队列中。</p>
<h4 id="调度点的相关关键函数"><a href="#调度点的相关关键函数" class="headerlink" title="调度点的相关关键函数"></a>调度点的相关关键函数</h4><p>如果我们能够让<code>wakup_proc</code>、<code>schedule</code>、<code>run_timer_list</code>这三个调度相关函数的实现与具体调度算法无关，那么就可以认为ucore实现了一个与调度算法无关的调度框架。</p>
<p><code>wakeup_proc</code>函数完成了把一个就绪进程放入到就绪进程队列中的工作，为此还调用了一个调度类接口函数<code>sched_class_enqueue</code>，这使得<code>wakeup_proc</code>的实现与具体调度算法无关。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void wakeup_proc(struct proc_struct *proc) &#123;</span><br><span class="line">    assert(proc-&gt;state != PROC_ZOMBIE);</span><br><span class="line">    bool intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        if (proc-&gt;state != PROC_RUNNABLE) &#123;</span><br><span class="line">            proc-&gt;state = PROC_RUNNABLE;</span><br><span class="line">            proc-&gt;wait_state = 0;</span><br><span class="line">            if (proc != current) &#123;</span><br><span class="line">                sched_class_enqueue(proc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            warn(&quot;wakeup runnable process.\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>schedule</code>函数完成了与调度框架和调度算法相关三件事情:</p>
<ul>
<li>把当前继续占用CPU执行的运行进程放放入到就绪进程队列中；</li>
<li>从就绪进程队列中选择一个“合适”就绪进程；</li>
<li>把这个“合适”的就绪进程从就绪进程队列中取出；</li>
<li>如果没有的话，说明现在没有合适的进程可以执行，就执行idle_proc；</li>
<li>加了一个runs，表明这个进程运行过几次了；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void schedule(void) &#123;</span><br><span class="line">    bool intr_flag;</span><br><span class="line">    struct proc_struct *next;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;need_resched = 0;</span><br><span class="line">        if (current-&gt;state == PROC_RUNNABLE) &#123;</span><br><span class="line">            sched_class_enqueue(current);</span><br><span class="line">        &#125;</span><br><span class="line">        if ((next = sched_class_pick_next()) != NULL) &#123;</span><br><span class="line">            sched_class_dequeue(next);</span><br><span class="line">        &#125;</span><br><span class="line">        if (next == NULL) &#123;</span><br><span class="line">            next = idleproc;</span><br><span class="line">        &#125;</span><br><span class="line">        next-&gt;runs ++;</span><br><span class="line">        if (next != current) &#123;</span><br><span class="line">            proc_run(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>run_time_list在lab6中并没有涉及，是在lab7中的。</p>
<p>通过调用三个调度类接口函数<code>sched_class_enqueue</code>、<code>sched_class_pick_next</code>、<code>sched_class_enqueue</code>来使得完成这三件事情与具体的调度算法无关。<code>run_timer_list</code>函数在每次timer中断处理过程中被调用，从而可用来调用调度算法所需的timer时间事件感知操作，调整相关进程的进程调度相关的属性值。通过调用调度类接口函数<code>sched_class_proc_tick</code>使得此操作与具体调度算法无关。<br>这里涉及了一系列调度类接口函数：</p>
<ul>
<li>sched_class_enqueue</li>
<li>sched_class_dequeue</li>
<li>sched_class_pick_next</li>
<li>sched_class_proc_tick</li>
</ul>
<p>这4个函数的实现其实就是调用某基于sched_class数据结构的特定调度算法实现的4个指针函数。采用这样的调度类框架后，如果我们需要实现一个新的调度算法，则我们需要定义一个针对此算法的调度类的实例，一个就绪进程队列的组织结构描述就行了，其他的事情都可交给调度类框架来完成。</p>
<h4 id="RR调度算法"><a href="#RR调度算法" class="headerlink" title="RR调度算法"></a>RR调度算法</h4><p>RR调度算法的调度思想是让所有runnable态的进程分时轮流使用CPU时间。</p>
<p>RR调度器维护当前runnable进程的有序运行队列。当前进程的时间片用完之后，调度器将当前进程放置到运行队列的尾部，再从其头部取出进程进行调度。</p>
<p>RR调度算法的就绪队列在组织结构上也是一个双向链表，只是增加了一个成员变量，表明在此就绪进程队列中的最大执行时间片。而且在进程控制块proc_struct中增加了一个成员变量time_slice，用来记录进程当前的可运行时间片段。这是由于RR调度算法需要考虑执行进程的运行时间不能太长。在每个timer到时的时候，操作系统会递减当前执行进程的time_slice，当time_slice为0时，就意味着这个进程运行了一段时间（这个时间片段称为进程的时间片），需要把CPU让给其他进程执行，于是操作系统就需要让此进程重新回到rq的队列尾，且重置此进程的时间片为就绪队列的成员变量最大时间片max_time_slice值，然后再从rq的队列头取出一个新的进程执行。</p>
<p>RR_enqueue的函数实现如下表所示。即把某进程的进程控制块指针放入到rq队列末尾，且如果进程控制块的时间片为0，则需要把它重置为rq成员变量max_time_slice。这表示如果进程在当前的执行时间片已经用完，需要等到下一次有机会运行时，才能再执行一段时间。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void RR_enqueue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    assert(list_empty(&amp;(proc-&gt;run_link)));</span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));</span><br><span class="line">    if (proc-&gt;time_slice == 0 || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;rq = rq;</span><br><span class="line">    rq-&gt;proc_num ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>RR_pick_next的函数实现如下表所示。即选取就绪进程队列rq中的队头队列元素，并把队列元素转换成进程控制块指针。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static struct proc_struct *</span><br><span class="line">RR_pick_next(struct run_queue *rq) &#123;</span><br><span class="line">    list_entry_t *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">    if (le != &amp;(rq-&gt;run_list)) &#123;</span><br><span class="line">        return le2proc(le, run_link);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>RR_dequeue的函数实现如下表所示。即把就绪进程队列rq的进程控制块指针的队列元素删除，并把表示就绪进程个数的proc_num减一。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void RR_dequeue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq == rq);</span><br><span class="line">    list_del_init(&amp;(proc-&gt;run_link));</span><br><span class="line">    rq-&gt;proc_num --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>RR_proc_tick的函数实现如下表所示。每次timer到时后，trap函数将会间接调用此函数来把当前执行进程的时间片time_slice减一。如果time_slice降到零，则设置此进程成员变量need_resched标识为1，这样在下一次中断来后执行trap函数时，会由于当前进程程成员变量need_resched标识为1而执行schedule函数，从而把当前执行进程放回就绪队列末尾，而从就绪队列头取出在就绪队列上等待时间最久的那个就绪进程执行。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">RR_proc_tick(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    if (proc-&gt;time_slice &gt; 0) &#123;</span><br><span class="line">        proc-&gt;time_slice --;</span><br><span class="line">    &#125;</span><br><span class="line">    if (proc-&gt;time_slice == 0) &#123;</span><br><span class="line">        proc-&gt;need_resched = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Stride-Scheduling"><a href="#Stride-Scheduling" class="headerlink" title="Stride Scheduling"></a>Stride Scheduling</h3><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><ol>
<li>为每个runnable的进程设置一个当前状态stride，表示该进程当前的调度权，也可以表示这个进程执行了多久了。另外定义其对应的pass值，表示对应进程在调度后，stride 需要进行的累加值。</li>
<li>每次需要调度时，从当前 runnable 态的进程中选择<strong>stride最小</strong>的进程调度。</li>
<li>对于获得调度的进程P，将对应的stride加上其对应的步长pass（只与进程的优先权有关系）。</li>
<li>在一段固定的时间之后，回到2步骤，重新调度当前stride最小的进程。</li>
</ol>
<p>可以证明，如果令<code>P.pass =BigStride / P.priority</code>，其中<code>P.priority</code>表示进程的优先权（大于 1），而 BigStride 表示一个预先定义的大常数，则该调度方案为每个进程分配的时间将与其优先级成正比。</p>
<p>将该调度器应用到 ucore 的调度器框架中来，则需要将调度器接口实现如下：</p>
<ul>
<li>init:<ul>
<li>初始化调度器类的信息（如果有的话）。</li>
<li>初始化当前的运行队列为一个空的容器结构。（比如和RR调度算法一样，初始化为一个有序列表）</li>
</ul>
</li>
<li>enqueue<ul>
<li>初始化刚进入运行队列的进程 proc的stride属性。</li>
<li>将 proc插入放入运行队列中去（注意：这里并不要求放置在队列头部）。</li>
</ul>
</li>
<li>dequeue<ul>
<li>从运行队列中删除相应的元素。</li>
</ul>
</li>
<li>pick next<ul>
<li>扫描整个运行队列，返回其中stride值最小的对应进程。</li>
<li>更新对应进程的stride值，即pass = BIG_STRIDE / P-&gt;priority; P-&gt;stride += pass。</li>
</ul>
</li>
<li>proc tick:<ul>
<li>检测当前进程是否已用完分配的时间片。如果时间片用完，应该正确设置进程结构的相关标记来引起进程切换。</li>
<li>一个 process 最多可以连续运行 rq.max_time_slice个时间片。</li>
</ul>
</li>
</ul>
<h4 id="使用优先队列实现-Stride-Scheduling"><a href="#使用优先队列实现-Stride-Scheduling" class="headerlink" title="使用优先队列实现 Stride Scheduling"></a>使用优先队列实现 Stride Scheduling</h4><p>使用优化的优先队列数据结构实现该调度。</p>
<p>优先队列是这样一种数据结构：使用者可以快速的插入和删除队列中的元素，并且在预先指定的顺序下快速取得当前在队列中的最小（或者最大）值及其对应元素。可以看到，这样的数据结构非常符合 Stride 调度器的实现。</p>
<p>libs/skew_heap.h中是优先队列的一个实现。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static inline void skew_heap_init(skew_heap_entry_t *a) __attribute__((always_inline));</span><br><span class="line">// 初始化一个队列节点</span><br><span class="line"></span><br><span class="line">static inline skew_heap_entry_t *skew_heap_merge(</span><br><span class="line">     skew_heap_entry_t *a, skew_heap_entry_t *b,</span><br><span class="line">     compare_f comp);</span><br><span class="line">// 合并两个优先队列</span><br><span class="line"></span><br><span class="line">static inline skew_heap_entry_t *skew_heap_insert(</span><br><span class="line">     skew_heap_entry_t *a, skew_heap_entry_t *b,</span><br><span class="line">     compare_f comp) __attribute__((always_inline));</span><br><span class="line">// 将节点 b 插入至以节点 a 为队列头的队列中去，返回插入后的队列</span><br><span class="line"></span><br><span class="line">static inline skew_heap_entry_t *skew_heap_remove(</span><br><span class="line">     skew_heap_entry_t *a, skew_heap_entry_t *b,</span><br><span class="line">     compare_f comp) __attribute__((always_inline));</span><br><span class="line">// 将节点 b 插入从以节点 a 为队列头的队列中去，返回删除后的队列</span><br></pre></td></tr></table></figure><br>当使用优先队列作为Stride调度器的实现方式之后，运行队列结构也需要作相关改变，其中包括：</p>
<ol>
<li><code>struct run_queue</code>中的<code>lab6_run_pool</code>指针，在使用优先队列的实现中表示当前优先队列的头元素，如果优先队列为空，则其指向空指针（NULL）。</li>
<li><code>struct proc_struct</code>中的<code>lab6_run_pool</code>结构，表示当前进程对应的优先队列节点。本次实验已经修改了系统相关部分的代码，使得其能够很好地适应LAB6新加入的数据结构和接口。而在实验中我们需要做的是用优先队列实现一个正确和高效的Stride调度器，如果用较简略的伪代码描述，则有：</li>
</ol>
<ul>
<li>init(rq):<ul>
<li>Initialize rq-&gt;run_list</li>
<li>Set rq-&gt;lab6_run_pool to NULL</li>
<li>Set rq-&gt;proc_num to 0</li>
</ul>
</li>
<li>enqueue(rq, proc)<ul>
<li>Initialize proc-&gt;time_slice</li>
<li>Insert proc-&gt;lab6_run_pool into rq-&gt;lab6_run_pool</li>
<li>rq-&gt;proc_num ++</li>
</ul>
</li>
<li>dequeue(rq, proc)<ul>
<li>Remove proc-&gt;lab6_run_pool from rq-&gt;lab6_run_pool</li>
<li>rq-&gt;proc_num —</li>
</ul>
</li>
<li>pick_next(rq)<ul>
<li>If rq-&gt;lab6_run_pool == NULL, return NULL</li>
<li>Find the proc corresponding to the pointer rq-&gt;lab6_run_pool</li>
<li>proc-&gt;lab6_stride += BIG_STRIDE / proc-&gt;lab6_priority</li>
<li>Return proc</li>
</ul>
</li>
<li>proc_tick(rq, proc):<ul>
<li>If proc-&gt;time_slice &gt; 0, proc-&gt;time_slice —<br>– If proc-&gt;time_slice == 0, set the flag proc-&gt;need_resched    </li>
</ul>
</li>
</ul>
<h2 id="练习1-使用-Round-Robin-调度算法（不需要编码）"><a href="#练习1-使用-Round-Robin-调度算法（不需要编码）" class="headerlink" title="练习1: 使用 Round Robin 调度算法（不需要编码）"></a>练习1: 使用 Round Robin 调度算法（不需要编码）</h2><p>与之前相比，新增了斜堆数据结构的实现；新增了调度算法Round Robin的实现，具体为调用sched.c文件中的<code>sched_class</code>的一系列函数，主要有enqueue、dequeue、pick_next等。之后，这些函数进一步调用调度器中的相应函数，默认该调度器为Round Robin调度器，这是在<code>default_sched.[c|h]</code>中定义的；新增了set_priority，get_time等函数；</p>
<p>首先在init.c中调用了sched_init函数，在这里把sched_class赋值为default_sched_class，也就是RR，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;timer_list);</span><br><span class="line"></span><br><span class="line">    sched_class = &amp;default_sched_class;</span><br><span class="line">    rq = &amp;__rq;</span><br><span class="line">    rq-&gt;max_time_slice = MAX_TIME_SLICE;</span><br><span class="line">    sched_class-&gt;init(rq);</span><br><span class="line">    cprintf(<span class="string">&quot;sched class: %s\n&quot;</span>, sched_class-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>RR_init函数：这个函数会被封装为sched_init函数，用于调度算法的初始化，它是在ucore的init.c里面被调用进行初始化，主要完成了计时器list、run_queue的run_list的初始化；</li>
<li>enqueue函数：将某个进程放入调用算法中的可执行队列中，被封装成sched_class_enqueue函数，这个函数仅在wakeup_proc和schedule函数中被调用，wakeup_proc将某个不是RUNNABLE的进程改成RUNNABLE的并调用enqueue加入可执行队列，而后者是将正在执行的进程换出到可执行队列中去并取出一个可执行进程；</li>
<li>dequeue函数：将某个在队列中的进程取出，sched_class_dequeue将其封装并在schedule中被调用，将调度算法选择的进程从等待的可执行进程队列中取出；</li>
<li>pick_next函数：根据调度算法选择下一个要执行的进程，仅在schedule中被调用；</li>
<li>proc_tick函数：在时钟中断时执行的操作，时间片减一，当时间片为0时，说明这个进程需要重新调度了。仅在进行时间中断的ISR中调用；</li>
</ul>
<blockquote>
<p>请理解并分析sched_calss中各个函数指针的用法，并接合Round Robin 调度算法描述ucore的调度执行过程：</p>
</blockquote>
<ul>
<li>ucore中的调度主要通过schedule和wakeup_proc函数完成，schedule主要把当前执行的进程入队，调用sched_class_pick_next选择下一个执行的进程并将其出队，开始执行。scheduleha函数把当前的进程入队，挑选一个进程将其出队并开始执行。</li>
<li>当需要将某一个进程加入就绪进程队列中，需要调用enqueue，将其插入到使用链表组织run_queue的队尾，将这个进程的能够使用的时间片初始化为max_time_slice；</li>
<li>当需要将某一个进程从就绪队列中取出，需要调用dequeue，调用list_del_init将其直接删除即可；</li>
<li>当需要取出执行的下一个进程时，只需调用pick_next将就绪队列run_queue的队头取出即可；</li>
<li>在一个时钟中断中，调用proc_tick将当前执行的进程的剩余可执行时间减1，一旦减到了0，则这个进程的need_resched为1，设成可以被调度的，这样之后就会调用schedule函数将这个进程切换出去；</li>
</ul>
<blockquote>
<p>请在实验报告中简要说明如何设计实现”多级反馈队列调度算法“，给出概要设计，鼓励给出详细设计;</p>
</blockquote>
<p>调度机制：</p>
<ol>
<li>进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。</li>
<li>设置多个就绪队列。在系统中设置多个就绪队列，并为每个队列赋予不同的优先级，从第一个开始逐个降低。不同队列进程中所赋予的执行时间也不同，优先级越高，时间片越小。</li>
<li>每个队列都采用FCFS（先来先服务）算法。轮到该进程执行时，若在该时间片内完成，便撤离操作系统，否则调度程序将其转入第二队列的末尾等待调度，…….。若进程最后被调到第N队列中时，便采用RR方式运行。</li>
<li>按队列优先级调度。调度按照优先级最高队列中诸进程运行，仅当第一队列空闲时才调度第二队列进程执行。若低优先级队列执行中有优先级高队列进程执行，应立刻将此进程放入队列末尾，把处理机分配给新到高优先级进程。</li>
</ol>
<ul>
<li>设置N个多级反馈队列的入口，Q0，Q1，Q2，Q3，…，编号越靠前的队列优先级越低，优先级越低的队列上时间片的长度越大；</li>
<li>调用sched_init对调度算法初始化的时候需要同时对N个队列进行初始化；</li>
<li>在将进程加入到就绪进程集合的时候，观察这个进程的时间片有没有使用完，如果使用完了，就将所在队列的优先级调低，加入到优先级低一级的队列中去，如果没有使用完时间片，则加入到当前优先级的队列中去；</li>
<li>在同一个优先级的队列内使用时间片轮转算法；</li>
<li>在选择下一个执行的进程的时候，先考虑更高优先级的队列中是否存在任务，如果不存在在去找较低优先级的队列；</li>
<li>从就绪进程集合中删除某一个进程的话直接在对应队列中删除；</li>
</ul>
<h2 id="练习2：实现-Stride-Scheduling-调度算法（需要编码）"><a href="#练习2：实现-Stride-Scheduling-调度算法（需要编码）" class="headerlink" title="练习2：实现 Stride Scheduling 调度算法（需要编码）"></a>练习2：实现 Stride Scheduling 调度算法（需要编码）</h2><p><strong>啊啊啊忘了在trap.c里改怪不得怎么都搞不对啊啊啊啊啊啊啊啊啊这下子总算有170了！！！</strong></p>
<p>还是先看看代码里斜堆（skew heap）的实现吧，好多地方要用到这个结构，具体可以在yuhao0102.github.io里仔细看。<br>在libs/skew.h中定义了skew heap。</p>
<p>猜测这只是一个入口，类似链表那种实现，不包括数据，只有指针。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct skew_heap_entry &#123;</span><br><span class="line">     struct skew_heap_entry *parent, *left, *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>proc_stride_comp_f</code>函数是用来比较这两个进程的stride的，a比b大返回1，相等返回0，a比b小返回-1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The compare function for two skew_heap_node_t&#x27;s and the</span></span><br><span class="line"><span class="comment"> * corresponding procs*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">proc_stride_comp_f</span><span class="params">(<span class="type">void</span> *a, <span class="type">void</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(a, lab6_run_pool);</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> =</span> le2proc(b, lab6_run_pool);</span><br><span class="line">     <span class="type">int32_t</span> c = p-&gt;lab6_stride - q-&gt;lab6_stride;</span><br><span class="line">     <span class="keyword">if</span> (c &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是初始化的函数，把三个指针初始化为NULL<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">skew_heap_init</span><span class="params">(<span class="type">skew_heap_entry_t</span> *a)</span></span><br><span class="line">&#123;</span><br><span class="line">     a-&gt;left = a-&gt;right = a-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个是把两个堆merge在一起的操作，强行内联hhh，这个是递归的！<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">skew_heap_entry_t</span> *</span><br><span class="line"><span class="title function_">skew_heap_merge</span><span class="params">(<span class="type">skew_heap_entry_t</span> *a, <span class="type">skew_heap_entry_t</span> *b,</span></span><br><span class="line"><span class="params">                compare_f comp)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (a == <span class="literal">NULL</span>) <span class="keyword">return</span> b;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="literal">NULL</span>) <span class="keyword">return</span> a;</span><br><span class="line"><span class="comment">// 如果a或b有一个为空，则返回另一个</span></span><br><span class="line"></span><br><span class="line">     <span class="type">skew_heap_entry_t</span> *l, *r;</span><br><span class="line">     <span class="keyword">if</span> (comp(a, b) == <span class="number">-1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          r = a-&gt;left;</span><br><span class="line">          l = skew_heap_merge(a-&gt;right, b, comp);</span><br><span class="line"></span><br><span class="line">          a-&gt;left = l;</span><br><span class="line">          a-&gt;right = r;</span><br><span class="line">          <span class="keyword">if</span> (l) l-&gt;parent = a;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line"><span class="comment">// 否则判断a和b的值哪个大，如果a比b小，则a的右子树和b合并，a作为堆顶        </span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          r = b-&gt;left;</span><br><span class="line">          l = skew_heap_merge(a, b-&gt;right, comp);</span><br><span class="line"></span><br><span class="line">          b-&gt;left = l;</span><br><span class="line">          b-&gt;right = r;</span><br><span class="line">          <span class="keyword">if</span> (l) </span><br><span class="line">          	l-&gt;parent = b;</span><br><span class="line">	      <span class="keyword">return</span> b;</span><br><span class="line"><span class="comment">// 另一种情况	      </span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>insert就是把一个单节点的堆跟大堆合并<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">skew_heap_entry_t</span> *</span><br><span class="line"><span class="title function_">skew_heap_insert</span><span class="params">(<span class="type">skew_heap_entry_t</span> *a, <span class="type">skew_heap_entry_t</span> *b,</span></span><br><span class="line"><span class="params">                 compare_f comp)</span></span><br><span class="line">&#123;</span><br><span class="line">     skew_heap_init(b);</span><br><span class="line">     <span class="keyword">return</span> skew_heap_merge(a, b, comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除就是把节点的左右子树进行merge，比较简单，记得删掉这个节点之后补充它的parent即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">skew_heap_entry_t</span> *</span><br><span class="line"><span class="title function_">skew_heap_remove</span><span class="params">(<span class="type">skew_heap_entry_t</span> *a, <span class="type">skew_heap_entry_t</span> *b,</span></span><br><span class="line"><span class="params">                 compare_f comp)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">skew_heap_entry_t</span> *p   = b-&gt;parent;</span><br><span class="line">     <span class="type">skew_heap_entry_t</span> *rep = skew_heap_merge(b-&gt;left, b-&gt;right, comp);</span><br><span class="line">     <span class="keyword">if</span> (rep) rep-&gt;parent = p;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (p)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span> (p-&gt;left == b)</span><br><span class="line">               p-&gt;left = rep;</span><br><span class="line">          <span class="keyword">else</span> p-&gt;right = rep;</span><br><span class="line">          <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先把default_sched.c中设置RR调度器为默认调度器的部分注释掉，然后把default_sched_stride_c改成default_sched_stride.c，这里对默认调度器进行了重新定义。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">default_sched_class</span> =</span> &#123;</span><br><span class="line">     .name = <span class="string">&quot;stride_scheduler&quot;</span>,</span><br><span class="line">     .init = stride_init,</span><br><span class="line">     .enqueue = stride_enqueue,</span><br><span class="line">     .dequeue = stride_dequeue,</span><br><span class="line">     .pick_next = stride_pick_next,</span><br><span class="line">     .proc_tick = stride_proc_tick,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>针对PCB的初始化，代码如下，综合了几个实验的初始化代码，也是一个总结：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LAB4:EXERCISE1 YOUR CODE</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * below fields in proc_struct need to be initialized</span></span><br><span class="line"><span class="comment"> *       enum proc_state state;                      // Process state</span></span><br><span class="line"><span class="comment"> *       int pid;                                    // Process ID</span></span><br><span class="line"><span class="comment"> *       int runs;                                   // the running times of Proces</span></span><br><span class="line"><span class="comment"> *       uintptr_t kstack;                           // Process kernel stack</span></span><br><span class="line"><span class="comment"> *       volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?</span></span><br><span class="line"><span class="comment"> *       struct proc_struct *parent;                 // the parent process</span></span><br><span class="line"><span class="comment"> *       struct mm_struct *mm;                       // Process&#x27;s memory management field</span></span><br><span class="line"><span class="comment"> *       struct context context;                     // Switch here to run process</span></span><br><span class="line"><span class="comment"> *       struct trapframe *tf;                       // Trap frame for current interrupt</span></span><br><span class="line"><span class="comment"> *       uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)</span></span><br><span class="line"><span class="comment"> *       uint32_t flags;                             // Process flag</span></span><br><span class="line"><span class="comment"> *       char name[PROC_NAME_LEN + 1];               // Process name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        proc-&gt;state = PROC_UNINIT;</span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line"></span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;proc-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//LAB5 YOUR CODE : (update LAB4 steps)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * below fields(add in LAB5) in proc_struct need to be initialized</span></span><br><span class="line"><span class="comment"> *       uint32_t wait_state;                        // waiting state</span></span><br><span class="line"><span class="comment"> *       struct proc_struct *cptr, *yptr, *optr;     // relations between processes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//LAB6 YOUR CODE : (update LAB5 steps)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * below fields(add in LAB6) in proc_struct need to be initialized</span></span><br><span class="line"><span class="comment"> *     struct run_queue *rq;                       // running queue contains Process</span></span><br><span class="line"><span class="comment"> *     list_entry_t run_link;                      // the entry linked in run queue</span></span><br><span class="line"><span class="comment"> *     int time_slice;                             // time slice for occupying the CPU</span></span><br><span class="line"><span class="comment"> *     skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool</span></span><br><span class="line"><span class="comment"> *     uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process</span></span><br><span class="line"><span class="comment"> *     uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        proc-&gt;rq = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;proc-&gt;run_link, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">list_entry_t</span>));</span><br><span class="line">        proc-&gt;time_slice = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;proc-&gt;lab6_run_pool,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">skew_heap_entry_t</span>));</span><br><span class="line">        proc-&gt;lab6_stride=<span class="number">0</span>;</span><br><span class="line">        proc-&gt;lab6_priority=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>主要就是在<code>vim kern/schedule/default_sched_stride.c</code>里的修改。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIG_STRIDE ((uint32_t)(1&lt;&lt;31)-3)</span></span><br></pre></td></tr></table></figure><br>BIG_STRIDE应该设置成小于2^32-1的一个常数。</p>
<p>这个函数用来对run_queue进行初始化等操作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stride_init initializes the run-queue rq with correct assignment for</span></span><br><span class="line"><span class="comment"> * member variables, including:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   - run_list: should be a empty list after initialization.</span></span><br><span class="line"><span class="comment"> *   - lab6_run_pool: NULL</span></span><br><span class="line"><span class="comment"> *   - proc_num: 0</span></span><br><span class="line"><span class="comment"> *   - max_time_slice: no need here, the variable would be assigned by the caller.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hint: see libs/list.h for routines of the list structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stride_init</span><span class="params">(<span class="keyword">struct</span> run_queue *rq)</span> &#123;</span><br><span class="line">     <span class="comment">/* LAB6: YOUR CODE</span></span><br><span class="line"><span class="comment">      * (1) init the ready process list: rq-&gt;run_list</span></span><br><span class="line"><span class="comment">      * (2) init the run pool: rq-&gt;lab6_run_pool</span></span><br><span class="line"><span class="comment">      * (3) set number of process: rq-&gt;proc_num to 0</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      list_init(&amp;rq-&gt;run_list);</span><br><span class="line">      rq-&gt;lab6_run_pool = <span class="literal">NULL</span>;</span><br><span class="line">      rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stride_enqueue inserts the process ``proc&#x27;&#x27; into the run-queue</span></span><br><span class="line"><span class="comment"> * ``rq&#x27;&#x27;. The procedure should verify/initialize the relevant members</span></span><br><span class="line"><span class="comment"> * of ``proc&#x27;&#x27;, and then put the ``lab6_run_pool&#x27;&#x27; node into the</span></span><br><span class="line"><span class="comment"> * queue(since we use priority queue here). The procedure should also</span></span><br><span class="line"><span class="comment"> * update the meta date in ``rq&#x27;&#x27; structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * proc-&gt;time_slice denotes the time slices allocation for the</span></span><br><span class="line"><span class="comment"> * process, which should set to rq-&gt;max_time_slice.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hint: see libs/skew_heap.h for routines of the priority</span></span><br><span class="line"><span class="comment"> * queue structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stride_enqueue</span><span class="params">(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc)</span> &#123;</span><br><span class="line">     <span class="comment">/* LAB6: YOUR CODE</span></span><br><span class="line"><span class="comment">      * (1) insert the proc into rq correctly</span></span><br><span class="line"><span class="comment">      * NOTICE: you can use skew_heap or list. Important functions</span></span><br><span class="line"><span class="comment">      *         skew_heap_insert: insert a entry into skew_heap</span></span><br><span class="line"><span class="comment">      *         list_add_before: insert  a entry into the last of list</span></span><br><span class="line"><span class="comment">      * (2) recalculate proc-&gt;time_slice</span></span><br><span class="line"><span class="comment">      * (3) set proc-&gt;rq pointer to rq</span></span><br><span class="line"><span class="comment">      * (4) increase rq-&gt;proc_num</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      rq-&gt;lab6_run_pool = skew_heap_insert(rq-&gt;lab6_run_pool, &amp;proc-&gt;lab6_run_pool, proc_stride_comp_f);</span><br><span class="line">      <span class="comment">// 做插入操作，把这个进程插到run_pool里。</span></span><br><span class="line">      <span class="keyword">if</span>(proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">          proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果这个进程的时间片不符合要求，就把它初始化成最大值。</span></span><br><span class="line">      proc-&gt;rq = rq;</span><br><span class="line">      rq-&gt;proc_num ++;</span><br><span class="line">      <span class="comment">//run_queue里的进程数++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做删除操作，把这个进程从run_pool里删除，并且将run_queue里的进程数减一。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stride_dequeue removes the process ``proc&#x27;&#x27; from the run-queue</span></span><br><span class="line"><span class="comment"> * ``rq&#x27;&#x27;, the operation would be finished by the skew_heap_remove</span></span><br><span class="line"><span class="comment"> * operations. Remember to update the ``rq&#x27;&#x27; structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hint: see libs/skew_heap.h for routines of the priority</span></span><br><span class="line"><span class="comment"> * queue structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stride_dequeue</span><span class="params">(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc)</span> &#123;</span><br><span class="line">     <span class="comment">/* LAB6: YOUR CODE</span></span><br><span class="line"><span class="comment">      * (1) remove the proc from rq correctly</span></span><br><span class="line"><span class="comment">      * NOTICE: you can use skew_heap or list. Important functions</span></span><br><span class="line"><span class="comment">      *         skew_heap_remove: remove a entry from skew_heap</span></span><br><span class="line"><span class="comment">      *         list_del_init: remove a entry from the  list</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      rq-&gt;lab6_run_pool = skew_heap_remove(rq-&gt;lab6_run_pool, &amp;proc-&gt;lab6_run_pool, proc_stride_comp_f);</span><br><span class="line">      rq-&gt;proc_num --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>pick_next从run_queue中选择stride值最小的进程，即斜堆的根节点对应的进程，并且返回这个proc，同时更新这个proc的stride<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stride_pick_next pick the element from the ``run-queue&#x27;&#x27;, with the</span></span><br><span class="line"><span class="comment"> * minimum value of stride, and returns the corresponding process</span></span><br><span class="line"><span class="comment"> * pointer. The process pointer would be calculated by macro le2proc,</span></span><br><span class="line"><span class="comment"> * see kern/process/proc.h for definition. Return NULL if</span></span><br><span class="line"><span class="comment"> * there is no process in the queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When one proc structure is selected, remember to update the stride</span></span><br><span class="line"><span class="comment"> * property of the proc. (stride += BIG_STRIDE / priority)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * hint: see libs/skew_heap.h for routines of the priority</span></span><br><span class="line"><span class="comment"> * queue structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc_struct *</span><br><span class="line"><span class="title function_">stride_pick_next</span><span class="params">(<span class="keyword">struct</span> run_queue *rq)</span> &#123;</span><br><span class="line">     <span class="comment">/* LAB6: YOUR CODE</span></span><br><span class="line"><span class="comment">      * (1) get a  proc_struct pointer p  with the minimum value of stride</span></span><br><span class="line"><span class="comment">             (1.1) If using skew_heap, we can use le2proc get the p from rq-&gt;lab6_run_poll</span></span><br><span class="line"><span class="comment">             (1.2) If using list, we have to search list to find the p with minimum stride value</span></span><br><span class="line"><span class="comment">      * (2) update p;s stride value: p-&gt;lab6_stride</span></span><br><span class="line"><span class="comment">      * (3) return p</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (rq-&gt;lab6_run_pool == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(rq-&gt;lab6_run_pool, lab6_run_pool);</span><br><span class="line">      p-&gt;lab6_stride += BIG_STRIDE/p-&gt;lab6_priority;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要在trap的时候调用！！！！如果这个proc的时间片还有的话，就减一，如果这个时间片为0了，就把它设成可调度的，参与调度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stride_proc_tick works with the tick event of current process. You</span></span><br><span class="line"><span class="comment"> * should check whether the time slices for current process is</span></span><br><span class="line"><span class="comment"> * exhausted and update the proc struct ``proc&#x27;&#x27;. proc-&gt;time_slice</span></span><br><span class="line"><span class="comment"> * denotes the time slices left for current</span></span><br><span class="line"><span class="comment"> * process. proc-&gt;need_resched is the flag variable for process</span></span><br><span class="line"><span class="comment"> * switching.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stride_proc_tick</span><span class="params">(<span class="keyword">struct</span> run_queue *rq, <span class="keyword">struct</span> proc_struct *proc)</span> &#123;</span><br><span class="line">     <span class="comment">/* LAB6: YOUR CODE */</span></span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                proc-&gt;time_slice --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">                proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="实验七"><a href="#实验七" class="headerlink" title="实验七"></a>实验七</h1><h2 id="实验目的-3"><a href="#实验目的-3" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li>理解操作系统的同步互斥的设计实现；</li>
<li>理解底层支撑技术：禁用中断、定时器、等待队列；</li>
<li>在ucore中理解信号量（semaphore）机制的具体实现；</li>
<li>理解管程机制，在ucore内核中增加基于管程（monitor）的条件变量（condition variable）的支持；</li>
<li>了解经典进程同步问题，并能使用同步机制解决进程同步问题。</li>
</ul>
<h2 id="实验内容-4"><a href="#实验内容-4" class="headerlink" title="实验内容"></a>实验内容</h2><p>lab6已经可以调度运行多个进程，如果多个进程需要协同操作或访问共享资源，则存在如何同步和有序竞争的问题。本次实验，主要是熟悉ucore的进程同步机制—信号量（semaphore）机制，以及基于信号量的哲学家就餐问题解决方案。然后掌握管程的概念和原理，并参考信号量机制，实现基于管程的条件变量机制和基于条件变量来解决哲学家就餐问题。</p>
<p>在本次实验中，在kern/sync/check_sync.c中提供了一个基于信号量的哲学家就餐问题解法。同时还需完成练习，即实现基于管程（主要是灵活运用条件变量和互斥信号量）的哲学家就餐问题解法。</p>
<p>哲学家就餐问题描述如下：有五个哲学家，他们的生活方式是交替地进行思考和进餐。哲学家们公用一张圆桌，周围放有五把椅子，每人坐一把。在圆桌上有五个碗和五根筷子，当一个哲学家思考时，他不与其他人交谈，饥饿时便试图取用其左、右最靠近他的筷子，但他可能一根都拿不到。只有在他拿到两根筷子时，方能进餐，进餐完后，放下筷子又继续思考。</p>
<h2 id="同步互斥的设计与实现"><a href="#同步互斥的设计与实现" class="headerlink" title="同步互斥的设计与实现"></a>同步互斥的设计与实现</h2><h3 id="实验执行流程概述-1"><a href="#实验执行流程概述-1" class="headerlink" title="实验执行流程概述"></a>实验执行流程概述</h3><p><strong>互斥</strong>是指某一资源同时只允许一个进程对其进行访问，具有<strong>唯一性</strong>和<strong>排它性</strong>，但<strong>互斥不用限制进程对资源的访问顺序</strong>，即访问可以是无序的。<strong>同步</strong>是指在进程间的执行必须严格<strong>按照规定的某种先后次序来运行</strong>，即访问是有序的，这种先后次序取决于要系统完成的任务需求。在进程写资源情况下，进程间要求满足互斥条件。在进程读资源情况下，可允许多个进程同时访问资源。</p>
<p>实验七设计实现了多种同步互斥手段，包括时钟中断管理、等待队列、信号量、管程机制（包含条件变量设计）等，并基于信号量实现了哲学家问题的执行过程。而本次实验的练习是要求用管程机制实现哲学家问题的执行过程。在实现信号量机制和管程机制时，需要让无法进入临界区的进程睡眠，为此在ucore中设计了等待队列wait_queue。当进程无法进入临界区（即无法获得信号量）时，可让进程进入等待队列，这时的进程处于等待状态（也可称为阻塞状态），从而会让实验六中的调度器选择一个处于就绪状态（即RUNNABLE_STATE）的进程，进行进程切换，让新进程有机会占用CPU执行，从而让整个系统的运行更加高效。</p>
<p>lab7/kern/sync/check_sync.c中的check_sync函数可以理解为是实验七的起始执行点，是实验七的总控函数。进一步分析此函数，可以看到这个函数主要分为了两个部分，第一部分是实现基于信号量的哲学家问题，第二部分是实现基于管程的哲学家问题。</p>
<ul>
<li>对于check_sync函数的第一部分，首先实现初始化了一个互斥信号量，然后创建了对应5个哲学家行为的5个信号量，并创建5个内核线程代表5个哲学家，每个内核线程完成了基于信号量的哲学家吃饭睡觉思考行为实现。</li>
<li>对于check_sync函数的第二部分，首先初始化了管程，然后又创建了5个内核线程代表5个哲学家，每个内核线程要完成基于管程的哲学家吃饭、睡觉、思考的行为实现。</li>
</ul>
<h3 id="同步互斥的底层支撑"><a href="#同步互斥的底层支撑" class="headerlink" title="同步互斥的底层支撑"></a>同步互斥的底层支撑</h3><p>由于调度的存在，且进程在访问某类资源暂时无法满足的情况下会进入等待状态，导致了多进程执行时序的不确定性和潜在执行结果的不确定性。为了确保执行结果的正确性，本试验需要设计更加完善的进程等待和互斥的底层支撑机制，确保能正确提供基于信号量和条件变量的同步互斥机制。</p>
<p>由于有定时器、屏蔽/使能中断、等待队列wait_queue支持test_and_set_bit等原子操作机器指令（在本次实验中没有用到）的存在，使得我们在实现进程等待、同步互斥上得到了极大的简化。下面将对定时器、屏蔽/使能中断和等待队列进行进一步讲解。</p>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>在传统的操作系统中，定时器提供了基于时间事件的调度机制。在ucore中，两次时间中断之间的时间间隔为一个时间片，timer splice。</p>
<p>基于此时间单位，操作系统得以向上提供基于时间点的事件，并实现基于时间长度的睡眠等待和唤醒机制。在每个时钟中断发生时，操作系统产生对应的时间事件。</p>
<p>sched.h, sched.c定义了有关timer的各种相关接口来使用 timer 服务，其中主要包括:</p>
<ul>
<li><code>typedef struct &#123;……&#125; timer_t</code>：定义了 timer_t 的基本结构，其可以用 sched.h 中的timer_init函数对其进行初始化。</li>
<li><code>void timer_init(timer t *timer, struct proc_struct *proc, int expires)</code>: 对某定时器进行初始化，让它在expires时间片之后唤醒proc进程。</li>
<li><code>void add_timer(timer t *timer)</code>：向系统添加某个初始化过的timer_t，该定时器在指定时间后被激活，并将对应的进程唤醒至runnable（如果当前进程处在等待状态）。</li>
<li><code>void del_timer(timer_t *time)</code>：向系统删除（或者说取消）某一个定时器。该定时器在取消后不会被系统激活并唤醒进程。</li>
<li><code>void run_timer_list(void)</code>：更新当前系统时间点，遍历当前所有处在系统管理内的定时器，找出所有应该激活的计数器，并激活它们。该过程在且只在每次定时器中断时被调用。在ucore中，其还会调用调度器事件处理程序。</li>
</ul>
<p>一个 timer_t 在系统中的存活周期可以被描述如下：</p>
<ul>
<li>timer_t在某个位置被创建和初始化，并通过add_timer加入系统管理列表中；</li>
<li>系统时间被不断累加，直到 run_timer_list 发现该 timer_t到期；</li>
<li>run_timer_list更改对应的进程状态，并从系统管理列表中移除该timer_t；</li>
</ul>
<h4 id="屏蔽与使能中断"><a href="#屏蔽与使能中断" class="headerlink" title="屏蔽与使能中断"></a>屏蔽与使能中断</h4><p>之前用过，这里简单看看。</p>
<p>在ucore中提供的底层机制包括中断屏蔽/使能控制等。<code>kern/sync.c</code>有开关中断的控制函数<code>local_intr_save(x)</code>和<code>local_intr_restore(x)</code>，它们是基于<code>kern/driver</code>文件下的<code>intr_enable()</code>、<code>intr_disable()</code>函数实现的。具体调用关系为：</p>
<blockquote>
<p>关中断：<code>local_intr_save</code> —&gt; <code>__intr_save</code> —&gt; <code>intr_disable</code> —&gt; <code>cli</code><br>开中断：<code>local_intr_restore</code> —&gt; <code>__intr_restore</code> —&gt; <code>intr_enable</code> —&gt; <code>sti</code></p>
</blockquote>
<p>最终的cli和sti是x86的机器指令，最终实现了关（屏蔽）中断和开（使能）中断，即设置了eflags寄存器中与中断相关的位。通过关闭中断，可以防止对当前执行的控制流被其他中断事件处理所打断。既然不能中断，那也就意味着在内核运行的当前进程无法被打断或被重新调度，即实现了对临界区的互斥操作。所以在单处理器情况下，可以通过开关中断实现对临界区的互斥保护，需要互斥的临界区代码的一般写法为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local_intr_save(intr_flag);</span><br><span class="line">&#123;</span><br><span class="line">  临界区代码</span><br><span class="line">&#125;</span><br><span class="line">local_intr_restore(intr_flag);</span><br></pre></td></tr></table></figure><br>但是，在多处理器情况下，这种方法是无法实现互斥的，因为屏蔽了一个CPU的中断，只能阻止本地CPU上的进程不会被中断或调度，并不意味着其他CPU上执行的进程不能执行临界区的代码。所以，开关中断只对单处理器下的互斥操作起作用。</p>
<h4 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h4><p>在课程中提到用户进程或内核线程可以转入等待状态以等待某个特定事件（比如睡眠,等待子进程结束,等待信号量等），当该事件发生时这些进程能够被再次唤醒。内核实现这一功能的一个底层支撑机制就是<strong>等待队列wait_queue</strong>，等待队列和每一个事件（睡眠结束、时钟到达、任务完成、资源可用等）联系起来。需要等待事件的进程在转入休眠状态后插入到等待队列中。当事件发生之后，内核遍历相应等待队列，唤醒休眠的用户进程或内核线程，并设置其状态为就绪状态（PROC_RUNNABLE），并将该进程从等待队列中清除。</p>
<p>ucore在<code>kern/sync/&#123; wait.h, wait.c &#125;</code>中实现了等待项wait结构和等待队列wait queue结构以及相关函数），这是实现ucore中的信号量机制和条件变量机制的基础，进入wait queue的进程会被设为等待状态（PROC_SLEEPING），直到他们被唤醒。</p>
<p>数据结构定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span>     <span class="comment">//等待进程的指针</span></span><br><span class="line">    <span class="type">uint32_t</span> wakeup_flags;        <span class="comment">//进程被放入等待队列的原因标记</span></span><br><span class="line">    <span class="type">wait_queue_t</span> *wait_queue;     <span class="comment">//指向此wait结构所属于的wait_queue</span></span><br><span class="line">    <span class="type">list_entry_t</span> wait_link;       <span class="comment">//用来组织wait_queue中wait节点的连接</span></span><br><span class="line">&#125; <span class="type">wait_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">list_entry_t</span> wait_head;       <span class="comment">//wait_queue的队头</span></span><br><span class="line">&#125; <span class="type">wait_queue_t</span>;</span><br><span class="line"></span><br><span class="line">le2wait(le, member)               <span class="comment">//实现wait_t中成员的指针向wait_t 指针的转化</span></span><br></pre></td></tr></table></figure><br>相关函数说明<br>与wait和wait queue相关的函数主要分为两层，底层函数是对wait queue的初始化、插入、删除和查找操作，相关函数如下：</p>
<p><code>wait_init</code>：初始化wait结构，将放入等待队列的原因标记设置为WT_INTERRUPTED，意为可以被打断等待状态<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wait_init</span><span class="params">(<span class="type">wait_t</span> *wait, <span class="keyword">struct</span> proc_struct *proc)</span> &#123;</span><br><span class="line">    wait-&gt;proc = proc;</span><br><span class="line">    wait-&gt;wakeup_flags = WT_INTERRUPTED;</span><br><span class="line">    list_init(&amp;(wait-&gt;wait_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_in_queue</code>：wait是否在wait queue中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">wait_in_queue</span><span class="params">(<span class="type">wait_t</span> *wait)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !list_empty(&amp;(wait-&gt;wait_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_queue_init</code>：初始化wait_queue结构<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">wait_queue_init(wait_queue_t *queue) &#123;</span><br><span class="line">    list_init(&amp;(queue-&gt;wait_head));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_queue_add</code>：设置当前等待项wait的等待队列，并把wait前插到wait queue中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wait_queue_add</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait)</span> &#123;</span><br><span class="line">    assert(list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;proc != <span class="literal">NULL</span>);</span><br><span class="line">    wait-&gt;wait_queue = <span class="built_in">queue</span>;</span><br><span class="line">    list_add_before(&amp;(<span class="built_in">queue</span>-&gt;wait_head), &amp;(wait-&gt;wait_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_queue_del</code>：从wait queue中删除wait<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wait_queue_del</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait)</span> &#123;</span><br><span class="line">    assert(!list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;wait_queue == <span class="built_in">queue</span>);</span><br><span class="line">    list_del_init(&amp;(wait-&gt;wait_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_queue_next</code>：取得wait_queue中wait等待项的后一个链接指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wait_t</span> *</span><br><span class="line"><span class="title function_">wait_queue_next</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait)</span> &#123;</span><br><span class="line">    assert(!list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;wait_queue == <span class="built_in">queue</span>);</span><br><span class="line">    <span class="type">list_entry_t</span> *le = list_next(&amp;(wait-&gt;wait_link));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_queue_prev</code>：取得wait_queue中wait等待项的前一个链接指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wait_t</span> *</span><br><span class="line"><span class="title function_">wait_queue_prev</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait)</span> &#123;</span><br><span class="line">    assert(!list_empty(&amp;(wait-&gt;wait_link)) &amp;&amp; wait-&gt;wait_queue == <span class="built_in">queue</span>);</span><br><span class="line">    <span class="type">list_entry_t</span> *le = list_prev(&amp;(wait-&gt;wait_link));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_queue_first</code>：取得wait queue的第一个wait<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wait_t</span> *</span><br><span class="line"><span class="title function_">wait_queue_first</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="type">list_entry_t</span> *le = list_next(&amp;(<span class="built_in">queue</span>-&gt;wait_head));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_queue_last</code>：取得wait queue的最后一个wait<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wait_t</span> *</span><br><span class="line"><span class="title function_">wait_queue_last</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="type">list_entry_t</span> *le = list_prev(&amp;(<span class="built_in">queue</span>-&gt;wait_head));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(<span class="built_in">queue</span>-&gt;wait_head)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2wait(le, wait_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>bool wait_queue_empty</code>：wait queue是否为空<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool</span><br><span class="line">wait_queue_empty(wait_queue_t *queue) &#123;</span><br><span class="line">    return list_empty(&amp;(queue-&gt;wait_head));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>高层函数基于底层函数实现了让进程进入等待队列—wait_current_set，以及从等待队列中唤醒进程—wakeup_wait，相关函数如下：</p>
<p><code>wait_current_set</code>：进程进入等待队列，当前进程的状态设置成睡眠<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wait_current_set</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait, <span class="type">uint32_t</span> wait_state)</span> &#123;</span><br><span class="line">    assert(current != <span class="literal">NULL</span>);</span><br><span class="line">    wait_init(wait, current);</span><br><span class="line">    current-&gt;state = PROC_SLEEPING;</span><br><span class="line">    current-&gt;wait_state = wait_state;</span><br><span class="line">    wait_queue_add(<span class="built_in">queue</span>, wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wait_current_del</code>：把与当前进程关联的wait从等待队列queue中删除<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> wait_current_del(queue, wait)                                       \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                    \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (wait_in_queue(wait)) &#123;                                          \</span></span><br><span class="line"><span class="meta">            wait_queue_del(queue, wait);                                    \</span></span><br><span class="line"><span class="meta">        &#125;                                                                   \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure></p>
<p><code>wakeup_wait</code>：唤醒等待队列上的wait所关联的进程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup_wait</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait, <span class="type">uint32_t</span> wakeup_flags, <span class="type">bool</span> del)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (del) &#123;</span><br><span class="line">        wait_queue_del(<span class="built_in">queue</span>, wait);</span><br><span class="line">    &#125;</span><br><span class="line">    wait-&gt;wakeup_flags = wakeup_flags;</span><br><span class="line">    wakeup_proc(wait-&gt;proc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>void wakeup_first</code>：唤醒等待队列上第一个的等待的进程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup_first</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">uint32_t</span> wakeup_flags, <span class="type">bool</span> del)</span> &#123;</span><br><span class="line">    <span class="type">wait_t</span> *wait;</span><br><span class="line">    <span class="keyword">if</span> ((wait = wait_queue_first(<span class="built_in">queue</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        wakeup_wait(<span class="built_in">queue</span>, wait, wakeup_flags, del);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>wakeup_queue</code>：唤醒等待队列上的所有等待进程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup_queue</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">uint32_t</span> wakeup_flags, <span class="type">bool</span> del)</span> &#123;</span><br><span class="line">    <span class="type">wait_t</span> *wait;</span><br><span class="line">    <span class="keyword">if</span> ((wait = wait_queue_first(<span class="built_in">queue</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (del) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                wakeup_wait(<span class="built_in">queue</span>, wait, wakeup_flags, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span> ((wait = wait_queue_first(<span class="built_in">queue</span>)) != <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                wakeup_wait(<span class="built_in">queue</span>, wait, wakeup_flags, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span> ((wait = wait_queue_next(<span class="built_in">queue</span>, wait)) != <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是一种同步互斥机制的实现，普遍存在于现在的各种操作系统内核里。相对于spinlock 的应用对象，信号量的应用对象是在临界区中运行的时间较长的进程。等待信号量的进程需要睡眠来减少占用 CPU 的开销。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">semWait</span><span class="params">(semaphore s)</span></span><br><span class="line">&#123;</span><br><span class="line">	s.count--;</span><br><span class="line">	<span class="keyword">if</span> (s.count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* place this process in s.queue */</span>;</span><br><span class="line">		<span class="comment">/* block this process */</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">semSignal</span><span class="params">(semaphore s)</span></span><br><span class="line">&#123;</span><br><span class="line">	s.count++;</span><br><span class="line">	<span class="keyword">if</span> (s.count&lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* remove a process P from s.queue */</span>;</span><br><span class="line">		<span class="comment">/* place process P on ready list */</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>基于上诉信号量实现可以认为，当多个（&gt;1）进程可以进行互斥或同步合作时，一个进程会由于无法满足信号量设置的某条件而在某一位置停止，直到它接收到一个特定的信号（表明条件满足了）。为了发信号，需要使用一个称作信号量的特殊变量。为通过信号量s传送信号，信号量的V操作采用进程可执行原语semSignal(s)；为通过信号量s接收信号，信号量的P操作采用进程可执行原语semWait(s)；如果相应的信号仍然没有发送，则进程被阻塞或睡眠，直到发送完为止。<br>ucore中信号量参照上述原理描述，建立在开关中断机制和wait_queue的基础上进行了具体实现。信号量的数据结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;                   <span class="comment">//信号量的当前值</span></span><br><span class="line">    <span class="type">wait_queue_t</span> wait_queue;     <span class="comment">//信号量对应的等待队列</span></span><br><span class="line">&#125; <span class="type">semaphore_t</span>;</span><br></pre></td></tr></table></figure><br><code>semaphore_t</code>是最基本的记录型信号量（record semaphore)结构，包含了用于计数的整数值value，和一个进程等待队列wait_queue，一个等待的进程会挂在此等待队列上。</p>
<p>在ucore中最重要的信号量操作是P操作函数<code>down(semaphore_t *sem)</code>和V操作函数<code>up(semaphore_t *sem)</code>。但这两个函数的具体实现是<code>__down(semaphore_t *sem, uint32_t wait_state)</code>函数和<code>__up(semaphore_t *sem, uint32_t wait_state)</code>函数，二者的具体实现描述如下：</p>
<p><code>__down(semaphore_t *sem, uint32_t wait_state, timer_t *timer)</code>：具体实现信号量的P操作，首先关掉中断，然后判断当前信号量的value是否大于0。如果是&gt;0，则表明可以获得信号量，故让value减一，并打开中断返回即可；如果不是&gt;0，则表明无法获得信号量，故需要将当前的进程加入到等待队列中，并打开中断，然后运行调度器选择另外一个进程执行。如果被V操作唤醒，则把自身关联的wait从等待队列中删除（此过程需要先关中断，完成后开中断）。</p>
<p><code>__up(semaphore_t *sem, uint32_t wait_state)</code>：具体实现信号量的V操作，首先关中断，如果信号量对应的wait queue中没有进程在等待，直接把信号量的value加一，然后开中断返回；如果有进程在等待且进程等待的原因是semophore设置的，则调用wakeup_wait函数将waitqueue中等待的第一个wait删除，且把此wait关联的进程唤醒，最后开中断返回。</p>
<p>对照信号量的原理性描述和具体实现，可以发现二者在流程上基本一致，只是具体实现采用了关中断的方式保证了对共享资源的互斥访问，通过等待队列让无法获得信号量的进程睡眠等待。另外，我们可以看出信号量的计数器value具有有如下性质：</p>
<ul>
<li>value&gt;0，表示共享资源的空闲数</li>
<li>vlaue&lt;0，表示该信号量的等待队列里的进程数</li>
<li>value=0，表示等待队列为空</li>
</ul>
<h3 id="管程和条件变量"><a href="#管程和条件变量" class="headerlink" title="管程和条件变量"></a>管程和条件变量</h3><h4 id="原理回顾"><a href="#原理回顾" class="headerlink" title="原理回顾"></a>原理回顾</h4><p>引入了管程是为了将对共享资源的所有访问及其所需要的同步操作集中并封装起来。Hansan为管程所下的定义：“一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据”。有上述定义可知，管程由四部分组成：</p>
<ul>
<li>管程内部的共享变量；</li>
<li>管程内部的条件变量；</li>
<li>管程内部并发执行的进程；</li>
<li>对局部于管程内部的共享数据设置初始值的语句。</li>
</ul>
<p>局限在管程中的数据结构，只能被局限在管程的操作过程所访问，任何管程之外的操作过程都不能访问它；另一方面，局限在管程中的操作过程也主要访问管程内的数据结构。由此可见，管程相当于一个<strong>隔离区</strong>，它把共享变量和对它进行操作的若干个过程围了起来，所有进程要访问临界资源时，都必须经过管程才能进入，而管程每次只允许一个进程进入管程，从而需要确保进程之间互斥。</p>
<p>但在管程中仅仅有互斥操作是不够用的。进程可能需要等待某个条件Cond为真才能继续执行。如果采用忙等(busy waiting)方式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while not( Cond ) do &#123;&#125;</span><br></pre></td></tr></table></figure><br>在单处理器情况下，将会导致所有其它进程都无法进入临界区使得该条件Cond为真，该管程的执行将会发生死锁。为此，可引入条件变量（Condition Variables，简称CV）。一个条件变量CV可理解为一个进程的等待队列，队列中的进程正等待某个条件Cond变为真。每个条件变量关联着一个条件，如果条件Cond不为真，则进程需要等待，如果条件Cond为真，则进程可以进一步在管程中执行。需要注意当一个进程等待一个条件变量CV（即等待Cond为真），该进程需要退出管程，这样才能让其它进程可以进入该管程执行，并进行相关操作，比如设置条件Cond为真，改变条件变量的状态，并唤醒等待在此条件变量CV上的进程。因此对条件变量CV有两种主要操作：</p>
<ul>
<li>wait_cv： 被一个进程调用，以等待断言Pc被满足后该进程可恢复执行. 进程挂在该条件变量上等待时，不被认为是占用了管程。</li>
<li>signal_cv：被一个进程调用，以指出断言Pc现在为真，从而可以唤醒等待断言Pc被满足的进程继续执行。</li>
</ul>
<p>“哲学家就餐”实例<br>有了互斥和信号量支持的管程就可用用了解决各种同步互斥问题。“用管程解决哲学家就餐问题”如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">monitor dp</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>THINKING, HUNGRY, EATING&#125; state[<span class="number">5</span>];</span><br><span class="line">    condition self[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">pickup</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        state[i] = HUNGRY;</span><br><span class="line">        test(i);</span><br><span class="line">        <span class="keyword">if</span> (state[i] != EATING)</span><br><span class="line">            self[i].wait_cv();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">putdown</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        state[i] = THINKING;</span><br><span class="line">        test((i + <span class="number">4</span>) % <span class="number">5</span>);</span><br><span class="line">        test((i + <span class="number">1</span>) % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((state[(i + <span class="number">4</span>) % <span class="number">5</span>] != EATING) &amp;&amp;</span><br><span class="line">           (state[i] == HUNGRY) &amp;&amp;</span><br><span class="line">           (state[(i + <span class="number">1</span>) % <span class="number">5</span>] != EATING)) &#123;</span><br><span class="line">              state[i] = EATING;</span><br><span class="line">              self[i].signal_cv();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initialization <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        state[i] = THINKING;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="关键数据结构"><a href="#关键数据结构" class="headerlink" title="关键数据结构"></a>关键数据结构</h4><p>虽然大部分教科书上说明管程适合在语言级实现比如java等高级语言，没有提及在采用C语言的OS中如何实现。下面我们将要尝试在ucore中用C语言实现采用基于互斥和条件变量机制的管程基本原理。<br>ucore中的管程机制是基于信号量和条件变量来实现的。ucore中的管程的数据结构monitor_t定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span>&#123;</span></span><br><span class="line">    <span class="type">semaphore_t</span> mutex;      <span class="comment">// the mutex lock for going into the routines in monitor, should be initialized to 1</span></span><br><span class="line">    <span class="comment">// the next semaphore is used to </span></span><br><span class="line">    <span class="comment">//    (1) procs which call cond_signal funciton should DOWN next sema after UP cv.sema</span></span><br><span class="line">    <span class="comment">// OR (2) procs which call cond_wait funciton should UP next sema before DOWN cv.sema</span></span><br><span class="line">    <span class="type">semaphore_t</span> next;        </span><br><span class="line">    <span class="type">int</span> next_count;         <span class="comment">// the number of of sleeped procs which cond_signal funciton</span></span><br><span class="line">    <span class="type">condvar_t</span> *cv;          <span class="comment">// the condvars in monitor</span></span><br><span class="line">&#125; <span class="type">monitor_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>管程中的成员变量mutex是一个二值信号量，是实现每次只允许一个进程进入管程的关键元素，确保了互斥访问性质。管程中的条件变量cv通过执行wait_cv，会使得等待某个条件Cond为真的进程能够离开管程并睡眠，且让其他进程进入管程继续执行；而进入管程的某进程设置条件Cond为真并执行signal_cv时，能够让等待某个条件Cond为真的睡眠进程被唤醒，从而继续进入管程中执行。</p>
<p>注意：管程中的成员变量信号量next和整型变量next_count是配合进程对条件变量cv的操作而设置的，这是由于发出signal_cv的进程A会唤醒由于wait_cv而睡眠的进程B，由于管程中只允许一个进程运行，所以进程B执行会导致唤醒进程B的进程A睡眠，直到进程B离开管程，进程A才能继续执行，这个同步过程是通过信号量next完成的；而next_count表示了由于发出singal_cv而睡眠的进程个数。<br>管程中的条件变量的数据结构condvar_t定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span></span><br><span class="line">    <span class="type">semaphore_t</span> sem;     <span class="comment">// the sem semaphore is used to down the waiting proc, and the signaling proc should up the waiting proc</span></span><br><span class="line">    <span class="type">int</span> count;       　    <span class="comment">// the number of waiters on condvar</span></span><br><span class="line">    <span class="type">monitor_t</span> * owner;     <span class="comment">// the owner(monitor) of this condvar</span></span><br><span class="line">&#125; <span class="type">condvar_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>条件变量的定义中也包含了一系列的成员变量，信号量sem用于让发出wait_cv操作的等待某个条件Cond为真的进程睡眠，而让发出signal_cv操作的进程通过这个sem来唤醒睡眠的进程。count表示等在这个条件变量上的睡眠进程的个数。owner表示此条件变量的宿主是哪个管程。</p>
<h4 id="条件变量的signal和wait的设计"><a href="#条件变量的signal和wait的设计" class="headerlink" title="条件变量的signal和wait的设计"></a>条件变量的signal和wait的设计</h4><p>理解了数据结构的含义后，我们就可以开始管程的设计实现了。ucore设计实现了条件变量<code>wait_cv</code>操作和<code>signal_cv</code>操作对应的具体函数，即<code>cond_wait</code>函数和<code>cond_signal</code>函数，此外还有<code>cond_init</code>初始化函数。</p>
<p>首先来看wait_cv的原理实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cv.count++;</span><br><span class="line"><span class="keyword">if</span>(monitor.next_count &gt; <span class="number">0</span>)</span><br><span class="line">   sem_signal(monitor.next);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   sem_signal(monitor.mutex);</span><br><span class="line">sem_wait(cv.sem);</span><br><span class="line">cv.count -- ;</span><br></pre></td></tr></table></figure><br>对照着可分析出cond_wait函数的具体执行过程。可以看出如果进程A执行了cond_wait函数，表示此进程等待某个条件Cond不为真，需要睡眠。因此表示等待此条件的睡眠进程个数cv.count要加一。接下来会出现两种情况。</p>
<p>情况一：如果monitor.next_count如果大于0，表示有大于等于1个进程执行cond_signal函数且睡了，就睡在了monitor.next信号量上（假定这些进程挂在monitor.next信号量相关的等待队列Ｓ上），因此需要唤醒等待队列Ｓ中的一个进程B；然后进程A睡在cv.sem上。如果进程A醒了，则让cv.count减一，表示等待此条件变量的睡眠进程个数少了一个，可继续执行了！</p>
<p>这里隐含这一个现象，即某进程A在时间顺序上先执行了cond_signal，而另一个进程B后执行了cond_wait，这会导致进程A没有起到唤醒进程B的作用。</p>
<p>问题: 在cond_wait有sem_signal(mutex)，但没有看到哪里有sem_wait(mutex)，这好像没有成对出现，是否是错误的？ 答案：其实在管程中的每一个函数的入口处会有wait(mutex)，这样二者就配好对了。</p>
<p>情况二：如果monitor.next_count如果小于等于0，表示目前没有进程执行cond_signal函数且睡着了，那需要唤醒的是由于互斥条件限制而无法进入管程的进程，所以要唤醒睡在monitor.mutex上的进程。然后进程A睡在cv.sem上，如果睡醒了，则让cv.count减一，表示等待此条件的睡眠进程个数少了一个，可继续执行了！<br>然后来看signal_cv的原理实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( cv.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   monitor.next_count ++;</span><br><span class="line">   sem_signal(cv.sem);</span><br><span class="line">   sem_wait(monitor.next);</span><br><span class="line">   monitor.next_count -- ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对照着可分析出cond_signal函数的具体执行过程。首先进程B判断cv.count，如果不大于0，则表示当前没有执行cond_wait而睡眠的进程，因此就没有被唤醒的对象了，直接函数返回即可；如果大于0，这表示当前有执行cond_wait而睡眠的进程A，因此需要唤醒等待在cv.sem上睡眠的进程A。由于只允许一个进程在管程中执行，所以一旦进程B唤醒了别人（进程A），那么自己就需要睡眠。故让monitor.next_count加一，且让自己（进程B）睡在信号量monitor.next上。如果睡醒了，这让monitor.next_count减一。</p>
<h4 id="管程中函数的入口出口设计"><a href="#管程中函数的入口出口设计" class="headerlink" title="管程中函数的入口出口设计"></a>管程中函数的入口出口设计</h4><p>为了让整个管程正常运行，还需在管程中的每个函数的入口和出口增加相关操作，即：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function_in_monitor （…）</span><br><span class="line">&#123;</span><br><span class="line">  sem.wait(monitor.mutex);</span><br><span class="line">//-----------------------------</span><br><span class="line">  the real body of function;</span><br><span class="line">//-----------------------------</span><br><span class="line">  if(monitor.next_count &gt; 0)</span><br><span class="line">     sem_signal(monitor.next);</span><br><span class="line">  else</span><br><span class="line">     sem_signal(monitor.mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样带来的作用有两个，（1）只有一个进程在执行管程中的函数。（2）避免由于执行了cond_signal函数而睡眠的进程无法被唤醒。对于第二点，如果进程A由于执行了cond_signal函数而睡眠（这会让monitor.next_count大于0，且执行sem_wait(monitor.next)），则其他进程在执行管程中的函数的出口，会判断monitor.next_count是否大于0，如果大于0，则执行sem_signal(monitor.next)，从而执行了cond_signal函数而睡眠的进程被唤醒。上诉措施将使得管程正常执行。</p>
<h2 id="练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题"><a href="#练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题" class="headerlink" title="练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题"></a>练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题</h2><p>首先把trap.c中处理时钟中断的时候调用的sched_class_proc_tick函数替换为run_timer_list函数（后者中已经包括了前者），用于支持定时器机制；</p>
<p>在sem.c定义了内核级信号量机制的函数，先来学习这个文件。sem.h中是定义，这个semphore_t结构体就是信号量的定义了。里边有一个value和一个队列。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KERN_SYNC_SEM_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KERN_SYNC_SEM_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;defs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">wait_queue_t</span> wait_queue;</span><br><span class="line">&#125; <span class="type">semaphore_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">semaphore_t</span> *sem, <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">try_down</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !__KERN_SYNC_SEM_H__ */</span></span></span><br></pre></td></tr></table></figure><br>sem_init对信号量进行初始化，信号量包括了一个整型数值变量和一个等待队列，该函数将该变量设置为指定的初始值（有几个资源），并且将等待队列初始化即可；wait_queue_init是把这个队列初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sem_init</span><span class="params">(<span class="type">semaphore_t</span> *sem, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    sem-&gt;value = value;</span><br><span class="line">    wait_queue_init(&amp;(sem-&gt;wait_queue));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wait_queue_init</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;(<span class="built_in">queue</span>-&gt;wait_head));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>__up</code>: 这个函数是<strong>释放</strong>一个该信号量对应的资源，如果它的等待队列中没有等待的请求，则直接把资源数加一，返回即可；如果在等待队列上有等在这个信号量上的进程，则调用<code>wakeup_wait</code>将其唤醒执行；在函数中禁用了中断，保证了操作的原子性，函数中操作的具体流程为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __noinline <span class="type">void</span> __up(<span class="type">semaphore_t</span> *sem, <span class="type">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">wait_t</span> *wait;</span><br><span class="line">        <span class="comment">//查询等待队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sem-&gt;value ++;</span><br><span class="line">            <span class="comment">//如果是空的话，没有等待的线程，给整型变量加1；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">//如果等待队列非空，有等待的线程，取出其中的一个进程唤醒；</span></span><br><span class="line">            assert(wait-&gt;proc-&gt;wait_state == wait_state);</span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//这个函数找到等待的线程并唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>__down</code>: 是原理课中的P操作，表示请求一个该信号量对应的资源，同样禁用中断，保证原子性。首先查询整型变量看是否大于0，如果大于0则表示存在可分配的资源，整型变量减1，直接返回；如果整型变量小于等于0，表示没有可用的资源，那么当前进程的需求得不到满足，因此在<code>wait_current_set</code>中将其状态改为SLEEPING态，然后调用<code>wait_queue_add</code>将其挂到对应信号量的等待队列中，调用schedule函数进行调度，让出CPU，在资源得到满足，重新被唤醒之后，将自身从等待队列上删除掉；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __noinline <span class="type">uint32_t</span> __down(<span class="type">semaphore_t</span> *sem, <span class="type">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sem-&gt;value --;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state);</span><br><span class="line">    <span class="comment">// 挂起这个等待线程并加入等待队列</span></span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    schedule();</span><br><span class="line"></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    wait_current_del(&amp;(sem-&gt;wait_queue), wait);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"><span class="comment">// 有可能当前线程被唤醒的原因跟之前等待的原因不一致</span></span><br><span class="line"><span class="comment">// 要把原因返回，由高层判断是否是合理状态。</span></span><br><span class="line">    <span class="keyword">if</span> (wait-&gt;wakeup_flags != wait_state) &#123;</span><br><span class="line">        <span class="keyword">return</span> wait-&gt;wakeup_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wait_current_set</span><span class="params">(<span class="type">wait_queue_t</span> *<span class="built_in">queue</span>, <span class="type">wait_t</span> *wait, <span class="type">uint32_t</span> wait_state)</span> &#123;</span><br><span class="line">    assert(current != <span class="literal">NULL</span>);</span><br><span class="line">    wait_init(wait, current);</span><br><span class="line">    current-&gt;state = PROC_SLEEPING;</span><br><span class="line">    current-&gt;wait_state = wait_state;</span><br><span class="line">    wait_queue_add(<span class="built_in">queue</span>, wait);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>try_down</code>: 简化版的P操作，如果资源数大于0则分配，资源数小于0也不进入等待队列，即使获取资源失败也不会堵塞当前进程；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">try_down</span><span class="params">(<span class="type">semaphore_t</span> *sem)</span> &#123;</span><br><span class="line">    <span class="type">bool</span> intr_flag, ret = <span class="number">0</span>;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sem-&gt;value --, ret = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。</p>
<p>用于保证操作原子性的禁用中断机制、以及CPU提供的Test and Set指令机制都只能在用户态下运行，为了方便起见，可以将信号量机制的实现放在OS中来提供，然后使用系统调用的方法统一提供出若干个管理信号量的系统调用，分别如下所示：</p>
<ul>
<li>申请创建一个信号量的系统调用，可以指定初始值，返回一个信号量描述符(类似文件描述符)；</li>
<li>将指定信号量执行P操作；</li>
<li>将指定信号量执行V操作；</li>
<li>将指定信号量释放掉；</li>
</ul>
<p>给内核级线程提供信号量机制和给用户态进程/线程提供信号量机制的异同点在于：</p>
<blockquote>
<p>相同点：<br>提供信号量机制的代码实现逻辑是相同的；<br>不同点：<br>由于实现原子操作的中断禁用、Test and Set指令等均需要在内核态下运行，因此提供给用户态进程的信号量机制是通过系统调用来实现的，而内核级线程只需要直接调用相应的函数就可以了；</p>
</blockquote>
<h2 id="练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题"><a href="#练习2-完成内核级条件变量和基于内核级条件变量的哲学家就餐问题" class="headerlink" title="练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题"></a>练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题</h2><p>首先掌握管程机制，然后基于信号量实现完成条件变量实现，然后用管程机制实现哲学家就餐问题的解决方案（基于条件变量）。</p>
<p>In [OS CONCEPT] 7.7 section, the accurate define and approximate implementation of MONITOR was introduced.</p>
<p>通常，管程是一种语言结构，编译器通常会强制执行互斥。 将其与信号量进行比较，信号量通常是OS构造。</p>
<ul>
<li>DEFNIE &amp; CHARACTERISTIC:</li>
<li>管程是组合在一起的过程、变量和数据结构的集合。</li>
<li>进程可以调用监视程序但无法访问内部数据结构。</li>
<li>管程中一次只能有一个进程处于活动状态。</li>
<li>条件变量允许阻塞和解除阻塞。<ul>
<li>cv.wait() 阻塞一个进程<ul>
<li>该过程等待条件变量cv。</li>
</ul>
</li>
<li>cv.signal() (也视为 cv.notify) 解除一个等待条件变量cv的进程的阻塞状态。<br>发生这种情况时，我们仍然需要在管程中只有一个进程处于活动状态。 这可以通过以下几种方式完成：<ul>
<li>在某些系统上，旧进程（执行信号的进程）离开管程，新进程进入</li>
<li>在某些系统上，信号必须是管程内执行的最后一个语句。</li>
<li>在某些系统上，旧进程将阻塞，直到管程再次可用。</li>
<li>在某些系统上，新进程（未被信号阻止的进程）将保持阻塞状态，直到管程再次可用。</li>
</ul>
</li>
</ul>
</li>
<li>如果在没有人等待的情况下发出条件变量信号，则信号丢失。 将此与信号量进行比较，其中信号将允许将来执行等待的进程无阻塞。</li>
<li>不应该将条件变量视为传统意义上的变量。</li>
<li>它没有价值。</li>
<li>将其视为OOP意义上的对象。</li>
<li>它有两种方法，wait和signal来操纵调用过程。</li>
<li>定义如下，mutex保证对操作的互斥访问，这些访问主要是对共享变量的访问，所以需要互斥；cv是条件变量。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">monitor mt &#123;</span><br><span class="line">    ----------------variable------------------</span><br><span class="line">    semaphore mutex;</span><br><span class="line">    semaphore next;</span><br><span class="line">    <span class="type">int</span> next_count;</span><br><span class="line">    condvar &#123;<span class="type">int</span> count, sempahore sem&#125;  cv[N];</span><br><span class="line">    other variables in mt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span></span><br><span class="line">    <span class="type">semaphore_t</span> sem;        <span class="comment">// the sem semaphore is used to down the waiting proc, </span></span><br><span class="line">                            <span class="comment">// and the signaling proc should up the waiting proc</span></span><br><span class="line">    <span class="type">int</span> count;              <span class="comment">// the number of waiters on condvar</span></span><br><span class="line">    <span class="type">monitor_t</span> * owner;      <span class="comment">// the owner(monitor) of this condvar</span></span><br><span class="line">&#125; <span class="type">condvar_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span>&#123;</span></span><br><span class="line">    <span class="type">semaphore_t</span> mutex;      <span class="comment">// the mutex lock for going into the routines in monitor, should be initialized to 1    semaphore_t next;       // the next semaphore is used to down the signaling proc itself, </span></span><br><span class="line">                            <span class="comment">// and the other OR wakeuped waiting proc should wake up the sleeped signaling proc.</span></span><br><span class="line">    <span class="type">int</span> next_count;         <span class="comment">// the number of of sleeped signaling proc</span></span><br><span class="line">    <span class="type">condvar_t</span> *cv;          <span class="comment">// the condvars in monitor</span></span><br><span class="line">&#125; <span class="type">monitor_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>这是一个管程里的操作，首先在操作开始和结束有wait和signal，保证对中间的访问是互斥的，条件不满足则执行wait执行等待。特殊信号量next和后边的if-else是有对应关系的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--------routines in monitor---------------</span><br><span class="line">routineA_in_mt () &#123;</span><br><span class="line">   wait(mt.mutex);</span><br><span class="line">   ...</span><br><span class="line">   real body of routineA</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span>(next_count&gt;<span class="number">0</span>)</span><br><span class="line">       signal(mt.next);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       signal(mt.mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>条件变量是管程的重要组成部分。<br>cond_wait: 一个条件得不到满足，则睡眠，如果这个条件得到满足，则另一个进程调用signal唤醒这个进程。该函数的功能为将当前进程等待在指定信号量上。等待队列的计数加1，然后释放管程的锁或者唤醒一个next上的进程来释放锁（否则会造成管程被锁死无法继续访问，同时这个操作不能和前面的等待队列计数加1的操作互换顺序，要不不能保证共享变量访问的互斥性），然后把自己等在条件变量的等待队列上，直到有signal信号将其唤醒，正常退出函数；<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--------condvar wait/signal---------------</span><br><span class="line">cond_wait (cv) &#123;</span><br><span class="line">    cv.count ++;</span><br><span class="line">    <span class="keyword">if</span>(mt.next_count&gt;<span class="number">0</span>)</span><br><span class="line">       signal(mt.next)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       signal(mt.mutex);</span><br><span class="line">    wait(cv.sem);<span class="comment">//由于条件不满足，则wait，这里时cv的sem</span></span><br><span class="line">    cv.count --;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Suspend calling thread on a condition variable waiting for condition Atomically unlocks</span></span><br><span class="line"><span class="comment">// mutex and suspends calling thread on conditional variable after waking up locks mutex. Notice: mp is mutex semaphore for monitor&#x27;s procedures</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">cond_wait</span> <span class="params">(<span class="type">condvar_t</span> *cvp)</span> &#123;</span><br><span class="line">    <span class="comment">//LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">    cprintf(<span class="string">&quot;cond_wait begin:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner</span><br><span class="line">-&gt;next_count);</span><br><span class="line">    cvp-&gt;count ++;</span><br><span class="line">    <span class="keyword">if</span> (cvp-&gt;owner-&gt;next_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        up(&amp;cvp-&gt;owner-&gt;next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        up(&amp;cvp-&gt;owner-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    down(&amp;cvp-&gt;sem);</span><br><span class="line">    cvp-&gt;count --;</span><br><span class="line">    cprintf(<span class="string">&quot;cond_wait end:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;</span><br><span class="line">next_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>cond_signal: 将指定条件变量上等待队列中的一个线程进行唤醒，并且将控制权转交给这个进程。判断当前的条件变量的等待队列是否大于0，即队列上是否有正在等待的进程，如果没有则不需要进行任何操作；如果有正在等待的进程，则将其中的一个唤醒，这里的等待队列是使用了一个信号量来进行实现的，由于信号量中已经包括了对等待队列的操作，因此要进行唤醒只需要对信号量执行up操作即可；接下来当前进程为了将控制权转交给被唤醒的进程，将自己等待到了这个条件变量所述的管程的next信号量上，这样的话就可以切换到被唤醒的进程。</p>
<p>有线程处于等待时，它的cv.count大于0，会有进一步的操作，唤醒其他进程，自身处于睡眠状态。上边的wait如果A进程中monitor.next_count大于0，那么可以唤醒monitor.next，正好与这里的wait对应。</p>
<p>如果cv.count大于0，有线程正在等待，把线程A从等待队列中移除，并唤醒线程A。在A的real_body之后的那个signal是唤醒B的实际函数。这里的next_count是发出条件变量signal的线程的个数。当B发出了条件变量signal操作，且把自身置成睡眠状态，使得被唤醒的A有机会在它自己退出的时候唤醒B。这是因为A和B都是在管程中执行的函数，都会涉及到对共享变量的访问，但是只允许一个进程对共享变量访问，保证互斥！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cond_signal(cv) &#123;</span><br><span class="line">    <span class="keyword">if</span>(cv.count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">       mt.next_count ++;</span><br><span class="line">       signal(cv.sem);</span><br><span class="line">       wait(mt.next);</span><br><span class="line">       mt.next_count--;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Unlock one of threads waiting on the condition variable.</span><br><span class="line">void</span><br><span class="line">cond_signal (condvar_t *cvp) &#123;</span><br><span class="line">   //LAB7 EXERCISE1: YOUR CODE</span><br><span class="line">   cprintf(&quot;cond_signal begin: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;, cvp, cvp-&gt;count, cvp-&gt;owner</span><br><span class="line">-&gt;next_count);</span><br><span class="line">   if(cvp-&gt;count&gt;0) &#123;</span><br><span class="line">       cvp-&gt;owner-&gt;next_count ++;</span><br><span class="line">       up(&amp;cvp-&gt;sem);</span><br><span class="line">       down(&amp;cvp-&gt;owner-&gt;next);</span><br><span class="line">       cvp-&gt;owner-&gt;next_count --;</span><br><span class="line">   &#125;</span><br><span class="line">   cprintf(&quot;cond_signal end: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;</span><br><span class="line">next_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>哲学家就餐问题：<br>phi_take_forks_condvar表示指定的哲学家尝试获得自己所需要进餐的两把叉子，如果不能获得则阻塞。首先给管程上锁，将哲学家的状态修改为HUNGER，判断当前哲学家是否可以获得足够的资源进行就餐，即判断与之相邻的哲学家是否正在进餐；如果能够进餐，将自己的状态修改成EATING，然后释放锁，离开管程即可；如果不能进餐，等待在自己对应的条件变量上，等待相邻的哲学家释放资源的时候将自己唤醒；<br>最终具体的代码实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void phi_take_forks_condvar(int i) &#123;</span><br><span class="line">//--------into routine in monitor--------------</span><br><span class="line">     // LAB7 EXERCISE1: YOUR CODE</span><br><span class="line">     // I am hungry</span><br><span class="line">     // try to get fork</span><br><span class="line">//--------leave routine in monitor--------------</span><br><span class="line">      down(&amp;(mtp-&gt;mutex));</span><br><span class="line">      state_condvar[i]=HUNGRY;</span><br><span class="line">      if(state_condvar[(i+4)%5]!=EATING &amp;&amp; state_condvar[(i+1)%5]!=EATING)&#123;</span><br><span class="line">          state_condvar[i]=EATING;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">          cprintf(&quot;phi_take_forks_condvar: %d didn’t get fork and will wait\n&quot;, i);</span><br><span class="line">          cond_wait(mtp-&gt;cv + i);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if(mtp-&gt;next_count&gt;0)</span><br><span class="line">         up(&amp;(mtp-&gt;next));</span><br><span class="line">      else</span><br><span class="line">         up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>phi_put_forks_condvar函数则是释放当前哲学家占用的叉子，并且唤醒相邻的因为得不到资源而进入等待的哲学家。首先获取管程的锁，将自己的状态修改成THINKING，检查相邻的哲学家是否在自己释放了叉子的占用之后满足了进餐的条件，如果满足，将其从等待中唤醒（使用cond_signal）；释放锁，离开管程；<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void phi_put_forks_condvar(int i) &#123;</span><br><span class="line">//--------into routine in monitor--------------</span><br><span class="line">     // LAB7 EXERCISE1: YOUR CODE</span><br><span class="line">     // I ate over</span><br><span class="line">     // test left and right neighbors</span><br><span class="line">//--------leave routine in monitor--------------</span><br><span class="line">    down(&amp;(mtp-&gt;mutex));</span><br><span class="line">    state_condvar[i] = THINKING;</span><br><span class="line">    cprintf(&quot;phi_put_forks_condvar: %d finished eating\n&quot;, i);</span><br><span class="line">    phi_test_condvar((i + N - 1) % N);</span><br><span class="line">    phi_test_condvar((i + 1) % N);</span><br><span class="line">    if(mtp-&gt;next_count&gt;0)</span><br><span class="line">       up(&amp;(mtp-&gt;next));</span><br><span class="line">    else</span><br><span class="line">       up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>phi_test_sema检查了第i个哲学家左右两边的人是不是处于EATING状态，如果都不是的话，而且第i个人又是HUNGRY的，则唤醒第i个。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define LEFT (i-1+N)%N /* i的左邻号码 */</span><br><span class="line">#define RIGHT (i+1)%N /* i的右邻号码 */</span><br><span class="line">void phi_test_sema(i) /* i：哲学家号码从0到N-1 */</span><br><span class="line">&#123;</span><br><span class="line">    if(state_sema[i]==HUNGRY&amp;&amp;state_sema[LEFT]!=EATING</span><br><span class="line">            &amp;&amp;state_sema[RIGHT]!=EATING)</span><br><span class="line">    &#123;</span><br><span class="line">        state_sema[i]=EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级 提供条件变量机制的异同。</p>
<p>本实验中管程的实现中互斥访问的保证是完全基于信号量的，如果根据上文中的说明使用系统调用实现用户态的信号量的实现机制，那么就可以按照相同的逻辑在用户态实现管程机制和条件变量机制；</p>
<h1 id="实验八"><a href="#实验八" class="headerlink" title="实验八"></a>实验八</h1><h2 id="实验目的-4"><a href="#实验目的-4" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过完成本次实验，希望能达到以下目标：</p>
<ul>
<li>了解基本的文件系统系统调用的实现方法；</li>
<li>了解一个基于索引节点组织方式的Simple FS文件系统的设计与实现；</li>
<li>了解文件系统抽象层-VFS的设计与实现；</li>
</ul>
<h2 id="实验内容-5"><a href="#实验内容-5" class="headerlink" title="实验内容"></a>实验内容</h2><p>本次实验涉及的是文件系统，通过分析了解ucore文件系统的总体架构设计，完善读写文件操作，从新实现基于文件系统的执行程序机制（即改写do_execve），从而可以完成执行存储在磁盘上的文件和实现文件读写等功能。</p>
<h2 id="文件系统设计与实现"><a href="#文件系统设计与实现" class="headerlink" title="文件系统设计与实现"></a>文件系统设计与实现</h2><h3 id="ucore-文件系统总体介绍"><a href="#ucore-文件系统总体介绍" class="headerlink" title="ucore 文件系统总体介绍"></a>ucore 文件系统总体介绍</h3><p>UNIX提出了四个文件系统抽象概念：文件(file)、目录项(dentry)、索引节点(inode)和安装点(mount point)</p>
<ul>
<li>文件：文件中的内容可理解为是一有序字节，文件有一个方便应用程序识别的文件名称（也称文件路径名）。典型的文件操作有读、写、创建和删除等。</li>
<li>目录项：目录项不是目录（又称文件路径），而是<strong>目录的组成部分</strong>。在UNIX中目录被看作一种特定的文件，而目录项是文件路径中的一部分。如一个文件路径名是“/test/testfile”，则包含的目录项为：<ul>
<li>根目录“/”，</li>
<li>目录“test”和文件“testfile”</li>
<li>这三个都是目录项。</li>
<li>一般而言，目录项包含目录项的名字（文件名或目录名）和目录项的索引节点位置。</li>
</ul>
</li>
<li>索引节点：UNIX将文件的相关元数据信息（如访问控制权限、大小、拥有者、创建时间、数据内容等等信息）存储在一个单独的数据结构中，该结构被称为索引节点。</li>
<li>安装点：在UNIX中，文件系统被安装在一个特定的文件路径位置，这个位置就是安装点。所有的已安装文件系统都作为<strong>根文件系统树中的叶子</strong>出现在系统中。</li>
</ul>
<p>ucore模仿了UNIX的文件系统设计，ucore的文件系统架构主要由四部分组成：</p>
<ul>
<li><strong>通用文件系统访问接口层</strong>：该层提供了一个从用户空间到文件系统的标准访问接口。这一层访问接口让应用程序能够通过一个简单的接口获得ucore内核的文件系统服务。</li>
<li><strong>文件系统抽象层</strong>：向上提供一个一致的接口给内核其他部分（文件系统相关的系统调用实现模块和其他内核功能模块）访问。向下提供一个同样的抽象函数指针列表和数据结构屏蔽不同文件系统的实现细节。</li>
<li><strong>Simple FS文件系统层</strong>：一个基于索引方式的简单文件系统实例。向上通过各种具体函数实现以对应文件系统抽象层提出的抽象函数。向下访问外设接口</li>
<li><strong>外设接口层</strong>：向上提供device访问接口屏蔽不同硬件细节。向下实现访问各种具体设备驱动的接口，比如disk设备接口/串口设备接口/键盘设备接口等。</li>
</ul>
<p>假如应用程序操作文件（打开/创建/删除/读写）：</p>
<ol>
<li>通过文件系统的通用文件系统访问接口层为用户空间提供的访问接口进入文件系统内部；</li>
<li>文件系统抽象层把访问请求转发给某一具体文件系统（比如SFS文件系统）；</li>
<li>具体文件系统（Simple FS文件系统层）把应用程序的访问请求转化为对磁盘上的block的处理请求，并通过外设接口层交给磁盘驱动例程来完成具体的磁盘操作。</li>
</ol>
<ul>
<li>通用文件系统访问接口<ul>
<li>文件系统相关用户库<ul>
<li>write::usr/libs/file.c</li>
</ul>
</li>
<li>用户态文件系统相关系统调用访问接口<ul>
<li>sys_write/sys_call::/usr/libs/syscall.c</li>
</ul>
</li>
<li>内核态文件系统相关系统调用实现<ul>
<li>sys_write::/kern/syscall/syscall.c</li>
</ul>
</li>
</ul>
</li>
<li>文件系统抽象层VFS<ul>
<li>dir接口</li>
<li>file接口</li>
<li>inode接口</li>
<li>etc…</li>
<li>sysfile_write::kern/fs/sysfile.c </li>
<li>file_write::/kern/fs/file.c </li>
<li>vop_write::/kern/fs/vfs/inode.h</li>
</ul>
</li>
<li>Simple FS文件系统实现<ul>
<li>sfs的inode实现</li>
<li>sfs的外设访问接口</li>
<li>sfs_write::kern/fs/sfs/sfs_inode.c</li>
<li>sfs_wbuf::/kern/fs/sfs/sfs_io.c</li>
</ul>
</li>
<li>文件系统IO设备接口<ul>
<li>device访问接口</li>
<li>stdin/stdout访问接口</li>
<li>etc…</li>
<li>dop_io::/kern/fs/devs/dev.h</li>
<li>disk0_io::/kern/fs/devs/dev_disk0.c</li>
</ul>
</li>
<li>硬盘驱动、串口驱动<ul>
<li>ide_write_secs::/kern/driver/ide.c</li>
</ul>
</li>
</ul>
<h4 id="ucore文件系统总体结构"><a href="#ucore文件系统总体结构" class="headerlink" title="ucore文件系统总体结构"></a>ucore文件系统总体结构</h4><p>从ucore操作系统不同的角度来看，ucore中的文件系统架构包含四类主要的数据结构, 它们分别是：</p>
<ul>
<li>超级块（SuperBlock），它主要从<strong>文件系统的全局角度</strong>描述特定文件系统的全局信息。它的作用范围是整个OS空间。</li>
<li>索引节点（inode）：它主要从<strong>文件系统的单个文件的角度</strong>描述了文件的各种属性和数据所在位置。它的作用范围是整个OS空间。</li>
<li>目录项（dentry）：它主要从<strong>文件系统的文件路径的角度</strong>描述了文件路径中的一个特定的目录项（注：一系列目录项形成目录/文件路径）。它的作用范围是整个OS空间。<ul>
<li>对于SFS而言，inode(具体为struct sfs_disk_inode)对应于物理磁盘上的具体对象，</li>
<li>dentry（具体为struct sfs_disk_entry）是一个内存实体，其中的ino成员指向对应的inode number，另外一个成员是file name(文件名).</li>
</ul>
</li>
<li>文件（file），它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。它的作用范围是某一具体进程。</li>
</ul>
<p><img src="/img/20190629002.png" alt="ucore中文件相关关键数据结构及其关系"></p>
<h3 id="通用文件系统访问接口"><a href="#通用文件系统访问接口" class="headerlink" title="通用文件系统访问接口"></a>通用文件系统访问接口</h3><h4 id="文件和目录相关用户库函数"><a href="#文件和目录相关用户库函数" class="headerlink" title="文件和目录相关用户库函数"></a>文件和目录相关用户库函数</h4><p>在文件操作方面，最基本的相关函数是open、close、read、write。</p>
<ul>
<li>在读写一个文件之前，首先要用open系统调用将其打开。<ul>
<li>open的第一个参数指定文件的路径名，可使用绝对路径名；</li>
<li>第二个参数指定打开的方式，可设置为O_RDONLY、O_WRONLY、O_RDWR，分别表示只读、只写、可读可写。</li>
<li>在打开一个文件后，就可以使用它返回的文件描述符fd对文件进行相关操作。</li>
</ul>
</li>
<li>在使用完一个文件后，还要用close系统调用把它关闭，其参数就是文件描述符fd。这样它的文件描述符就可以空出来，给别的文件使用。</li>
<li>读写文件内容的系统调用是read和write。read系统调用有三个参数：<ul>
<li>一个指定所操作的文件描述符，一个指定读取数据的存放地址，最后一个指定读多少个字节。在C程序中调用该系统调用的方法如下：<code>count = read(filehandle, buffer, nbytes);</code>。</li>
<li>该系统调用会把实际读到的字节数返回给count变量。在正常情形下这个值与nbytes相等，但有时可能会小一些。例如，在读文件时碰上了文件结束符，从而提前结束此次读操作。</li>
</ul>
</li>
</ul>
<p>对于目录而言，最常用的操作是跳转到某个目录，这里对应的用户库函数是<code>chdir</code>。然后就需要读目录的内容了，即列出目录中的文件或目录名，这在处理上与读文件类似，即需要：通过opendir函数打开目录，通过readdir来获取目录中的文件信息，读完后还需通过closedir函数来关闭目录。由于在ucore中把目录看成是一个特殊的文件，所以opendir和closedir实际上就是调用与文件相关的open和close函数。只有readdir需要调用获取目录内容的特殊系统调用sys_getdirentry。而且这里没有写目录这一操作。在目录中增加内容其实就是在此目录中创建文件，需要用到创建文件的函数。</p>
<h4 id="文件和目录访问相关系统调用"><a href="#文件和目录访问相关系统调用" class="headerlink" title="文件和目录访问相关系统调用"></a>文件和目录访问相关系统调用</h4><p>与文件相关的open、close、read、write用户库函数对应的是sys_open、sys_close、sys_read、sys_write四个系统调用接口。与目录相关的readdir用户库函数对应的是sys_getdirentry系统调用。这些系统调用函数接口将通过syscall函数来获得ucore的内核服务。当到了ucore内核后，在调用文件系统抽象层的file接口和dir接口。</p>
<h3 id="文件系统抽象层-VFS"><a href="#文件系统抽象层-VFS" class="headerlink" title="文件系统抽象层 - VFS"></a>文件系统抽象层 - VFS</h3><p>文件系统抽象层是把不同文件系统的对外共性接口提取出来，形成一个<strong>函数指针数组</strong>，这样，通用文件系统访问接口层只需访问文件系统抽象层，而不需关心具体文件系统的实现细节和接口。</p>
<h4 id="file-amp-dir接口"><a href="#file-amp-dir接口" class="headerlink" title="file &amp; dir接口"></a>file &amp; dir接口</h4><p>file&amp;dir接口层定义了进程在内核中直接访问的文件相关信息，这定义在file数据结构中，具体描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;                   <span class="comment">//访问文件的执行状态</span></span><br><span class="line">    <span class="type">bool</span> readable;              <span class="comment">//文件是否可读</span></span><br><span class="line">    <span class="type">bool</span> writable;              <span class="comment">//文件是否可写</span></span><br><span class="line">    <span class="type">int</span> fd;                     <span class="comment">//文件在filemap中的索引值</span></span><br><span class="line">    <span class="type">off_t</span> pos;                  <span class="comment">//访问文件的当前位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span>         <span class="comment">//该文件对应的内存inode指针</span></span><br><span class="line">    <span class="type">int</span> open_count;             <span class="comment">//打开此文件的次数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>而在kern/process/proc.h中的proc_struct结构中描述了进程访问文件的数据接口files_struct，其数据结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>           <span class="comment">//进程当前执行目录的内存inode指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>       <span class="comment">//进程打开文件的数组</span></span><br><span class="line">    <span class="type">atomic_t</span> files_count;        <span class="comment">//访问此文件的线程个数</span></span><br><span class="line">    <span class="type">semaphore_t</span> files_sem;       <span class="comment">//确保对进程控制块中fs_struct的互斥访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当创建一个进程后，该进程的files_struct将会被初始化或复制父进程的files_struct。当用户进程打开一个文件时，将从fd_array数组中取得一个空闲file项，然后会把此file的成员变量node指针指向一个代表此文件的inode的起始地址。</p>
<h4 id="inode-接口"><a href="#inode-接口" class="headerlink" title="inode 接口"></a>inode 接口</h4><p>index node是位于内存的索引节点，它是VFS结构中的重要数据结构，因为它实际负责把不同文件系统的特定索引节点信息（甚至不能算是一个索引节点）统一封装起来，避免了进程直接访问具体文件系统。其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>                                   <span class="comment">//包含不同文件系统特定inode信息的union成员变量</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span>          <span class="comment">//设备文件系统内存inode信息</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span>    <span class="comment">//SFS文件系统内存inode信息</span></span><br><span class="line">    &#125; in_info;   </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;                          <span class="comment">//此inode所属文件系统类型</span></span><br><span class="line">    <span class="type">atomic_t</span> ref_count;                 <span class="comment">//此inode的引用计数</span></span><br><span class="line">    <span class="type">atomic_t</span> open_count;                <span class="comment">//打开此inode对应文件的个数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span>                   <span class="comment">//抽象的文件系统，包含访问文件系统的函数指针</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span>     <span class="comment">//抽象的inode操作，包含访问inode的函数指针     </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>在inode中，有一成员变量为in_ops，这是对此inode的<strong>操作函数指针列表</strong>，其数据结构定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vop_magic;</span><br><span class="line">    <span class="type">int</span> (*vop_open)(<span class="keyword">struct</span> inode *node, <span class="type">uint32_t</span> open_flags);</span><br><span class="line">    <span class="type">int</span> (*vop_close)(<span class="keyword">struct</span> inode *node);</span><br><span class="line">    <span class="type">int</span> (*vop_read)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob);</span><br><span class="line">    <span class="type">int</span> (*vop_write)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob);</span><br><span class="line">    <span class="type">int</span> (*vop_getdirentry)(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob);</span><br><span class="line">    <span class="type">int</span> (*vop_create)(<span class="keyword">struct</span> inode *node, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">bool</span> excl, <span class="keyword">struct</span> inode **node_store);</span><br><span class="line">    <span class="type">int</span> (*vop_lookup)(<span class="keyword">struct</span> inode *node, <span class="type">char</span> *path, <span class="keyword">struct</span> inode **node_store);</span><br><span class="line">……</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><br>参照上面对SFS中的索引节点操作函数的说明，可以看出inode_ops是<strong>对常规文件、目录、设备文件所有操作的一个抽象函数表示</strong>。对于某一具体的文件系统中的文件或目录，只需实现相关的函数，就可以被用户进程访问具体的文件了，且用户进程无需了解具体文件系统的实现细节。</p>
<h3 id="Simple-FS-文件系统"><a href="#Simple-FS-文件系统" class="headerlink" title="Simple FS 文件系统"></a>Simple FS 文件系统</h3><p>ucore内核把所有文件都看作是字节流，任何内部逻辑结构都是专用的，由应用程序负责解释。但是ucore区分文件的物理结构。ucore目前支持如下几种类型的文件：</p>
<ul>
<li>常规文件：文件中包括的内容信息是由应用程序输入。SFS文件系统在普通文件上不强加任何内部结构，把其文件内容信息看作为字节。</li>
<li>目录：包含一系列的entry，每个entry包含文件名和指向与之相关联的索引节点（index node）的指针。目录是按层次结构组织的。</li>
<li>链接文件：实际上一个链接文件是一个已经存在的文件的另一个可选择的文件名。</li>
<li>设备文件：不包含数据，但是提供了一个映射物理设备（如串口、键盘等）到一个文件名的机制。可通过设备文件访问外围设备。</li>
<li>管道：管道是进程间通讯的一个基础设施。管道缓存了其输入端所接受的数据，以便在管道输出端读的进程能一个先进先出的方式来接受数据。</li>
</ul>
<p>SFS文件系统中目录和常规文件具有共同的属性，而这些属性保存在索引节点中。SFS通过索引节点来管理目录和常规文件，索引节点包含操作系统所需要的关于某个文件的关键信息，比如文件的属性、访问许可权以及其它控制信息都保存在索引节点中。可以有多个文件名可指向一个索引节点。</p>
<h4 id="文件系统的布局"><a href="#文件系统的布局" class="headerlink" title="文件系统的布局"></a>文件系统的布局</h4><p>文件系统通常保存在磁盘上。在本实验中，第三个磁盘（即disk0，前两个磁盘分别是<code>ucore.img</code>和<code>swap.img</code>）用于存放一个SFS文件系统（Simple Filesystem）。通常文件系统中，磁盘的使用是以扇区（Sector）为单位的，但是为了实现简便，SFS 中以 block （4K，与内存 page 大小相等）为基本单位。<br>SFS文件系统的布局如下图所示。<br><code>superblock -&gt; root-dir inode -&gt; freemap -&gt; inode/file_data/dir_data_blocks</code></p>
<p>第0个块（4K）是超级块（superblock），它包含了关于文件系统的所有关键参数，当计算机被启动或文件系统被首次接触时，超级块的内容就会被装入内存。其定义如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct sfs_super &#123;</span><br><span class="line">    uint32_t magic;                                  /* magic number, should be SFS_MAGIC */</span><br><span class="line">    uint32_t blocks;                                 /* # of blocks in fs */</span><br><span class="line">    uint32_t unused_blocks;                         /* # of unused blocks in fs */</span><br><span class="line">    char info[SFS_MAX_INFO_LEN + 1];                /* infomation for sfs  */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>可以看到，包含：</p>
<ul>
<li>成员变量魔数magic，其值为<code>0x2f8dbe2a</code>，内核通过它来检查磁盘镜像是否是合法的 SFS img；</li>
<li>成员变量blocks记录了SFS中所有block的数量，即 img 的大小；</li>
<li>成员变量unused_block记录了SFS中还没有被使用的block的数量；</li>
<li>成员变量info包含了字符串”simple file system”。</li>
</ul>
<p>第1个块放了一个root-dir的inode，用来记录根目录的相关信息。有关inode还将在后续部分介绍。通过这个root-dir的inode信息就可以定位并查找到根目录下的所有文件信息。</p>
<p>从第2个块开始，根据SFS中所有块的数量，用1个bit来表示一个块的占用和未被占用的情况。这个区域称为SFS的freemap区域，这将占用若干个块空间。为了更好地记录和管理freemap区域，专门提供了两个文件kern/fs/sfs/bitmap.[ch]来完成根据一个块号查找或设置对应的bit位的值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct bitmap &#123;</span><br><span class="line">    uint32_t nbits;</span><br><span class="line">    uint32_t nwords;</span><br><span class="line">    WORD_TYPE *map;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>最后在剩余的磁盘空间中，存放了所有其他目录和文件的inode信息和内容数据信息。需要注意的是虽然inode的大小小于一个块的大小（4096B），但为了实现简单，每个 inode 都占用一个完整的 block。<br>在sfs_fs.c文件中的sfs_do_mount函数中，完成了加载位于硬盘上的SFS文件系统的超级块superblock和freemap的工作。这样，在内存中就有了SFS文件系统的全局信息。</p>
<p>在fs_init中分别调用了<code>vfs_init()</code>，<code>dev_init()</code>和<code>sfs_init()</code>，<code>sfs_init()</code>中调用了<code>sfs_mount(&quot;disk0&quot;)</code>，<code>sfs_mount</code>中调用了<code>vfs_mount(devname, sfs_do_mount);</code>，<code>vfs_mount()</code>中从设备列表中找到一个名字相同的设备，这个设备的fs应该是NULL，即它是没有被挂载到某个文件系统的。找到这个设备的inode中in_info，调用传进来的mountfunc，即sfs_do_mount<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_do_mount - mount sfs file system.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @dev:        the block device contains sfs file system</span></span><br><span class="line"><span class="comment"> * @fs_store:   the fs struct in memroy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sfs_do_mount</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> fs **fs_store)</span> &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(SFS_BLKSIZE &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sfs_super));</span><br><span class="line">    <span class="keyword">static_assert</span>(SFS_BLKSIZE &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sfs_disk_inode));</span><br><span class="line">    <span class="keyword">static_assert</span>(SFS_BLKSIZE &gt;= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sfs_disk_entry));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;d_blocksize != SFS_BLKSIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NA_DEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配一个fs的结构 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((fs = alloc_fs(sfs)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取这个sfs的sfs_fs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> *<span class="title">sfs</span> =</span> fsop_info(fs, sfs);</span><br><span class="line">    sfs-&gt;dev = dev;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="type">void</span> *sfs_buffer;</span><br><span class="line">    <span class="keyword">if</span> ((sfs-&gt;sfs_buffer = sfs_buffer = kmalloc(SFS_BLKSIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_fs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 专门用来读超级块的 */</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_init_read(dev, SFS_BLKN_SUPER, sfs_buffer)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> *<span class="title">super</span> =</span> sfs_buffer;</span><br><span class="line">    <span class="keyword">if</span> (super-&gt;magic != SFS_MAGIC) &#123;</span><br><span class="line">    	<span class="comment">// 开头一定要是魔数</span></span><br><span class="line">        cprintf(<span class="string">&quot;sfs: wrong magic in superblock. (%08x should be %08x).\n&quot;</span>,</span><br><span class="line">                super-&gt;magic, SFS_MAGIC);</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (super-&gt;blocks &gt; dev-&gt;d_blocks) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;sfs: fs has %u blocks, device has %u blocks.\n&quot;</span>,</span><br><span class="line">                super-&gt;blocks, dev-&gt;d_blocks);</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    super-&gt;info[SFS_MAX_INFO_LEN] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sfs-&gt;super = *super;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* alloc and initialize hash list, 用于inode */</span></span><br><span class="line">    <span class="type">list_entry_t</span> *hash_list;</span><br><span class="line">    <span class="keyword">if</span> ((sfs-&gt;hash_list = hash_list = kmalloc(<span class="keyword">sizeof</span>(<span class="type">list_entry_t</span>) * SFS_HLIST_SIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SFS_HLIST_SIZE; i ++) &#123;</span><br><span class="line">        list_init(hash_list + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* load and check freemap */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span></span><br><span class="line">    <span class="type">uint32_t</span> freemap_size_nbits = sfs_freemap_bits(super);</span><br><span class="line">    <span class="keyword">if</span> ((sfs-&gt;freemap = freemap = bitmap_create(freemap_size_nbits)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_hash_list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">uint32_t</span> freemap_size_nblks = sfs_freemap_blocks(super);</span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_init_freemap(dev, freemap, SFS_BLKN_FREEMAP, freemap_size_nblks, sfs_buffer)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_freemap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> blocks = sfs-&gt;super.blocks, unused_blocks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; freemap_size_nbits; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bitmap_test(freemap, i)) &#123;</span><br><span class="line">            unused_blocks ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(unused_blocks == sfs-&gt;super.unused_blocks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* and other fields */</span></span><br><span class="line">    sfs-&gt;super_dirty = <span class="number">0</span>;</span><br><span class="line">    sem_init(&amp;(sfs-&gt;fs_sem), <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;(sfs-&gt;io_sem), <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;(sfs-&gt;mutex_sem), <span class="number">1</span>);</span><br><span class="line">    list_init(&amp;(sfs-&gt;inode_list));</span><br><span class="line">    cprintf(<span class="string">&quot;sfs: mount: &#x27;%s&#x27; (%d/%d/%d)\n&quot;</span>, sfs-&gt;super.info,</span><br><span class="line">            blocks - unused_blocks, unused_blocks, blocks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* link addr of sync/get_root/unmount/cleanup funciton  fs&#x27;s function pointers*/</span></span><br><span class="line">    fs-&gt;fs_sync = sfs_sync;</span><br><span class="line">    fs-&gt;fs_get_root = sfs_get_root;</span><br><span class="line">    fs-&gt;fs_unmount = sfs_unmount;</span><br><span class="line">    fs-&gt;fs_cleanup = sfs_cleanup;</span><br><span class="line">    *fs_store = fs;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">failed_cleanup_freemap:</span><br><span class="line">    bitmap_destroy(freemap);</span><br><span class="line">failed_cleanup_hash_list:</span><br><span class="line">    kfree(hash_list);</span><br><span class="line">failed_cleanup_sfs_buffer:</span><br><span class="line">    kfree(sfs_buffer);</span><br><span class="line">failed_cleanup_fs:</span><br><span class="line">    kfree(fs);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h4><p>在SFS文件系统中，需要记录文件内容的存储位置以及文件名与文件内容的对应关系。</p>
<ul>
<li>sfs_disk_inode记录了文件或目录的内容存储的索引信息，该数据结构在硬盘里储存，需要时读入内存。</li>
<li>sfs_disk_entry表示一个目录中的一个文件或目录，包含该项所对应inode的位置和文件名，同样也在硬盘里储存，需要时读入内存。</li>
</ul>
<h5 id="磁盘索引节点"><a href="#磁盘索引节点" class="headerlink" title="磁盘索引节点"></a>磁盘索引节点</h5><p>SFS中的磁盘索引节点代表了一个实际位于磁盘上的文件。首先我们看看在硬盘上的索引节点的内容：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> size;                          如果inode表示常规文件，则size是文件大小</span><br><span class="line">    <span class="type">uint16_t</span> type;                          inode的文件类型</span><br><span class="line">    <span class="type">uint16_t</span> nlinks;                        此inode的硬链接数</span><br><span class="line">    <span class="type">uint32_t</span> blocks;                        此inode的数据块数的个数</span><br><span class="line">    <span class="type">uint32_t</span> direct[SFS_NDIRECT];           此inode的直接数据块索引值（有SFS_NDIRECT个）</span><br><span class="line">    <span class="type">uint32_t</span> indirect;                      此inode的一级间接数据块索引值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过上表可以看出，如果inode表示的是文件，则成员变量direct[]直接指向了保存文件内容数据的数据块索引值。indirect间接指向了保存文件内容数据的数据块，indirect指向的是间接数据块（indirect_block），此数据块实际存放的全部是数据块索引，这些数据块索引指向的数据块才被用来存放文件内容数据。</p>
<p>默认的，ucore 里 SFS_NDIRECT 是 12，即直接索引的数据页大小为 12 <em> 4k = 48k；当使用一级间接数据块索引时，ucore 支持最大的文件大小为 12 </em> 4k + 1024 * 4k = 48k + 4m。数据索引表内，0 表示一个无效的索引，inode 里 blocks 表示该文件或者目录占用的磁盘的 block 的个数。indiret 为 0 时，表示不使用一级索引块。（因为 block 0 用来保存 super block，它不可能被其他任何文件或目录使用，所以这么设计也是合理的）。</p>
<p>对于普通文件，索引值指向的 block 中保存的是文件中的数据。而对于目录，索引值指向的数据保存的是目录下所有的文件名以及对应的索引节点所在的索引块（磁盘块）所形成的数组。数据结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file entry (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> ino;                                   索引节点所占数据块索引值</span><br><span class="line">    <span class="type">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];               文件名</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>操作系统中，每个文件系统下的 inode 都应该分配唯一的 inode 编号。SFS 下，为了实现的简便，每个 inode 直接用他所在的磁盘 block 的编号作为 inode 编号。比如，root block 的 inode 编号为 1；每个 sfs_disk_entry 数据结构中，name 表示目录下文件或文件夹的名称，ino 表示磁盘 block 编号，通过读取该 block 的数据，能够得到相应的文件或文件夹的 inode。ino 为0时，表示一个无效的 entry。<br>此外，和 inode 相似，每个 sfs_dirent_entry 也占用一个 block。</p>
<h4 id="内存中的索引节点"><a href="#内存中的索引节点" class="headerlink" title="内存中的索引节点"></a>内存中的索引节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* inode for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span>;</span>                     <span class="comment">/* on-disk inode */</span></span><br><span class="line">    <span class="type">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;                                 <span class="comment">/* inode flags */</span></span><br><span class="line">    <span class="type">bool</span> dirty;                                     <span class="comment">/* true if inode modified */</span></span><br><span class="line">    <span class="type">int</span> reclaim_count;                              <span class="comment">/* kill inode if it hits zero */</span></span><br><span class="line">    <span class="type">semaphore_t</span> sem;                                <span class="comment">/* semaphore for din */</span></span><br><span class="line">    <span class="type">list_entry_t</span> inode_link;                        <span class="comment">/* entry for linked-list in sfs_fs */</span></span><br><span class="line">    <span class="type">list_entry_t</span> hash_link;                         <span class="comment">/* entry for hash linked-list in sfs_fs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到SFS中的内存inode包含了SFS的硬盘inode信息，而且还增加了其他一些信息，这属于是便于进行是判断否改写、互斥操作、回收和快速地定位等作用。需要注意，一个内存inode是在打开一个文件后才创建的，如果关机则相关信息都会消失。而硬盘inode的内容是保存在硬盘中的，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据</p>
<p>为了方便实现上面提到的多级数据的访问以及目录中 entry 的操作，对 inode SFS实现了一些辅助的函数：</p>
<ul>
<li>sfs_bmap_load_nolock：将对应 sfs_inode 的第 index 个索引指向的 block 的索引值取出存到相应的指针指向的单元（ino_store）。该函数只接受 index &lt;= inode-&gt;blocks 的参数。当 index == inode-&gt;blocks 时，该函数理解为需要为 inode 增长一个 block。并标记 inode 为 dirty（所有对 inode 数据的修改都要做这样的操作，这样，当 inode 不再使用的时候，sfs 能够保证 inode 数据能够被写回到磁盘）。sfs_bmap_load_nolock 调用的 sfs_bmap_get_nolock 来完成相应的操作，阅读 sfs_bmap_get_nolock，了解他是如何工作的。（sfs_bmap_get_nolock 只由 sfs_bmap_load_nolock 调用）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_bmap_load_nolock - according to the DIR&#x27;s inode and the logical index of block in inode, find the NO. of</span></span><br><span class="line"><span class="comment">disk block.</span></span><br><span class="line"><span class="comment"> * @sfs:      sfs file system</span></span><br><span class="line"><span class="comment"> * @sin:      sfs inode in memory</span></span><br><span class="line"><span class="comment"> * @index:    the logical index of disk block in inode</span></span><br><span class="line"><span class="comment"> * @ino_store:the NO. of disk block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sfs_bmap_load_nolock</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="keyword">struct</span> sfs_inode *<span class="built_in">sin</span>, <span class="type">uint32_t</span> index, <span class="type">uint32_t</span> *ino_store)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    assert(index &lt;= din-&gt;blocks);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">uint32_t</span> ino;</span><br><span class="line">    <span class="type">bool</span> create = (index == din-&gt;blocks);</span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_bmap_get_nolock(sfs, <span class="built_in">sin</span>, index, create, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(sfs_block_inuse(sfs, ino));</span><br><span class="line">    <span class="keyword">if</span> (create) &#123;</span><br><span class="line">        din-&gt;blocks ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ino_store != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *ino_store = ino;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_bmap_get_nolock - according sfs_inode and index of block, find the NO. of disk block</span></span><br><span class="line"><span class="comment"> *                       no lock protect</span></span><br><span class="line"><span class="comment"> * @sfs:      sfs file system</span></span><br><span class="line"><span class="comment"> * @sin:      sfs inode in memory</span></span><br><span class="line"><span class="comment"> * @index:    the index of block in inode</span></span><br><span class="line"><span class="comment"> * @create:   BOOL, if the block isn&#x27;t allocated, if create = 1 the alloc a block,  otherwise just do nothing</span></span><br><span class="line"><span class="comment"> * @ino_store: 0 OR the index of already inused block or new allocated block.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sfs_bmap_get_nolock</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="keyword">struct</span> sfs_inode *<span class="built_in">sin</span>, <span class="type">uint32_t</span> index, <span class="type">bool</span> create, <span class="type">uint32_t</span> *ino_store)</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">uint32_t</span> ent, ino;</span><br><span class="line">    <span class="comment">// the index of disk block is in the fist SFS_NDIRECT direct blocks</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; SFS_NDIRECT) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ino = din-&gt;direct[index]) == <span class="number">0</span> &amp;&amp; create) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ret = sfs_block_alloc(sfs, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            din-&gt;direct[index] = ino;</span><br><span class="line">            <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the index of disk block is in the indirect blocks.</span></span><br><span class="line">    index -= SFS_NDIRECT;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; SFS_BLK_NENTRY) &#123;</span><br><span class="line">        ent = din-&gt;indirect;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_get_sub_nolock(sfs, &amp;ent, index, create, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ent != din-&gt;indirect) &#123;</span><br><span class="line">            assert(din-&gt;indirect == <span class="number">0</span>);</span><br><span class="line">            din-&gt;indirect = ent;</span><br><span class="line">            <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        panic (<span class="string">&quot;sfs_bmap_get_nolock - index out of range&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    assert(ino == <span class="number">0</span> || sfs_block_inuse(sfs, ino));</span><br><span class="line">    *ino_store = ino;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>sfs_bmap_truncate_nolock：将多级数据索引表的最后一个 entry 释放掉。他可以认为是 sfs_bmap_load_nolock 中，index == inode-&gt;blocks 的逆操作。当一个文件或目录被删除时，sfs 会循环调用该函数直到 inode-&gt;blocks 减为 0，释放所有的数据页。函数通过 sfs_bmap_free_nolock 来实现，他应该是 sfs_bmap_get_nolock 的逆操作。和 sfs_bmap_get_nolock 一样，调用 sfs_bmap_free_nolock 也要格外小心。</li>
<li>sfs_dirent_read_nolock：将目录的第 slot 个 entry 读取到指定的内存空间。他通过上面提到的函数来完成。</li>
<li>sfs_dirent_search_nolock：是常用的查找函数。他在目录下查找 name，并且返回相应的搜索结果（文件或文件夹）的 inode 的编号（也是磁盘编号），和相应的 entry 在该目录的 index 编号以及目录下的数据页是否有空闲的 entry。（SFS 实现里文件的数据页是连续的，不存在任何空洞；而对于目录，数据页不是连续的，当某个 entry 删除的时候，SFS 通过设置 entry-&gt;ino 为0将该 entry 所在的 block 标记为 free，在需要添加新 entry 的时候，SFS 优先使用这些 free 的 entry，其次才会去在数据页尾追加新的 entry。</li>
</ul>
<p>注意，这些后缀为 nolock 的函数，只能在已经获得相应 inode 的semaphore才能调用。</p>
<p>inode的文件操作函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_fileops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_openfile,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_read                       = sfs_read,</span><br><span class="line">    .vop_write                      = sfs_write,</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>上述sfs_openfile、sfs_close、sfs_read和sfs_write分别对应用户进程发出的open、close、read、write操作。其中sfs_openfile不用做什么事；sfs_close需要把对文件的修改内容写回到硬盘上，这样确保硬盘上的文件内容数据是最新的；sfs_read和sfs_write函数都调用了一个函数sfs_io，并最终通过访问硬盘驱动来完成对文件内容数据的读写。</p>
<h5 id="inode的目录操作函数"><a href="#inode的目录操作函数" class="headerlink" title="inode的目录操作函数"></a>inode的目录操作函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_dirops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_opendir,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_getdirentry                = sfs_getdirentry,</span><br><span class="line">    .vop_lookup                     = sfs_lookup,                           </span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于目录操作而言，由于目录也是一种文件，所以sfs_opendir、sys_close对应户进程发出的open、close函数。相对于sfs_open，sfs_opendir只是完成一些open函数传递的参数判断，没做其他更多的事情。目录的close操作与文件的close操作完全一致。由于目录的内容数据与文件的内容数据不同，所以读出目录的内容数据的函数是sfs_getdirentry，其主要工作是获取目录下的文件inode信息。</p>
<h3 id="设备层文件-IO-层"><a href="#设备层文件-IO-层" class="headerlink" title="设备层文件 IO 层"></a>设备层文件 IO 层</h3><p>在本实验中，为了统一地访问设备，我们可以把一个设备看成一个文件，通过访问文件的接口来访问设备。目前实现了stdin设备文件文件、stdout设备文件、disk0设备。stdin设备就是键盘，stdout设备就是CONSOLE（串口、并口和文本显示器），而disk0设备是承载SFS文件系统的磁盘设备。下面我们逐一分析ucore是如何让用户把设备看成文件来访问。</p>
<h4 id="关键数据结构-1"><a href="#关键数据结构-1" class="headerlink" title="关键数据结构"></a>关键数据结构</h4><p>为了表示一个设备，需要有对应的数据结构，ucore为此定义了<code>struct device</code>，其描述如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> d_blocks;    <span class="comment">//设备占用的数据块个数            </span></span><br><span class="line">    <span class="type">size_t</span> d_blocksize;  <span class="comment">//数据块的大小</span></span><br><span class="line">    <span class="type">int</span> (*d_open)(<span class="keyword">struct</span> device *dev, <span class="type">uint32_t</span> open_flags);  <span class="comment">//打开设备的函数指针</span></span><br><span class="line">    <span class="type">int</span> (*d_close)(<span class="keyword">struct</span> device *dev); <span class="comment">//关闭设备的函数指针</span></span><br><span class="line">    <span class="type">int</span> (*d_io)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> iobuf *iob, <span class="type">bool</span> write); <span class="comment">//读写设备的函数指针</span></span><br><span class="line">    <span class="type">int</span> (*d_ioctl)(<span class="keyword">struct</span> device *dev, <span class="type">int</span> op, <span class="type">void</span> *data); <span class="comment">//用ioctl方式控制设备的函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个数据结构能够支持对块设备（比如磁盘）、字符设备（比如键盘、串口）的表示，完成对设备的基本操作。ucore虚拟文件系统为了把这些设备链接在一起，还定义了一个设备链表，即双向链表vdev_list，这样通过访问此链表，可以找到ucore能够访问的所有设备文件。</p>
<p>但这个设备描述没有与文件系统以及表示一个文件的inode数据结构建立关系，为此，还需要另外一个数据结构把device和inode联通起来，这就<br>是vfs_dev_t数据结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// device info entry in vdev_list </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *devname;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">devnode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span></span><br><span class="line">    <span class="type">bool</span> mountable;</span><br><span class="line">    <span class="type">list_entry_t</span> vdev_link;</span><br><span class="line">&#125; <span class="type">vfs_dev_t</span>;</span><br></pre></td></tr></table></figure><br>利用vfs_dev_t数据结构，就可以让文件系统通过一个链接vfs_dev_t结构的双向链表找到device对应的inode数据结构，一个inode节点的成员变量in_type的值是0x1234，则此 inode的成员变量in_info将成为一个device结构。这样inode就和一个设备建立了联系，这个inode就是一个设备文件。</p>
<h4 id="stdout设备文件"><a href="#stdout设备文件" class="headerlink" title="stdout设备文件"></a>stdout设备文件</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>既然stdout设备是设备文件系统的文件，自然有自己的inode结构。在系统初始化时，即只需如下处理过程<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kern_init ——&gt;</span><br><span class="line"> fs_init ——&gt; </span><br><span class="line"> dev_init ——&gt; </span><br><span class="line"> dev_init_stdout ——&gt;</span><br><span class="line"> dev_create_inode ——&gt; </span><br><span class="line"> stdout_device_init ——&gt; </span><br><span class="line"> vfs_add_dev</span><br></pre></td></tr></table></figure><br>在dev_init_stdout中完成了对stdout设备文件的初始化。即首先创建了一个inode，然后通过<code>stdout_device_init</code>完成对inode中的成员变量<code>inode-&gt;__device_info</code>进行初始：<br>这里的stdout设备文件实际上就是指的console外设（它其实是串口、并口和CGA的组合型外设）。这个设备文件是一个只写设备，如果读这个设备，就会出错。接下来我们看看stdout设备的相关处理过程。</p>
<h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p>stdout设备文件的初始化过程主要由<code>stdout_device_init</code>完成，其具体实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stdout_device_init</span><span class="params">(<span class="keyword">struct</span> device *dev)</span> &#123;</span><br><span class="line">    dev-&gt;d_blocks = <span class="number">0</span>;</span><br><span class="line">    dev-&gt;d_blocksize = <span class="number">1</span>;</span><br><span class="line">    dev-&gt;d_open = stdout_open;</span><br><span class="line">    dev-&gt;d_close = stdout_close;</span><br><span class="line">    dev-&gt;d_io = stdout_io;</span><br><span class="line">    dev-&gt;d_ioctl = stdout_ioctl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，stdout_open函数完成设备文件打开工作，如果发现用户进程调用open函数的参数flags不是只写（O_WRONLY），则会报错。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">stdout_open</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">uint32_t</span> open_flags)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (open_flags != O_WRONLY) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="访问操作实现"><a href="#访问操作实现" class="headerlink" title="访问操作实现"></a>访问操作实现</h5><p>stdout_io函数完成设备的写操作工作，具体实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">stdout_io</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> iobuf *iob, <span class="type">bool</span> write)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (write) &#123;</span><br><span class="line">        <span class="type">char</span> *data = iob-&gt;io_base;</span><br><span class="line">        <span class="keyword">for</span> (; iob-&gt;io_resid != <span class="number">0</span>; iob-&gt;io_resid --) &#123;</span><br><span class="line">            cputchar(*data ++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，要写的数据放在iob-&gt;io_base所指的内存区域，一直写到iob-&gt;io_resid的值为0为止。每次写操作都是通过cputchar来完成的，此函数最终将通过console外设驱动来完成把数据输出到串口、并口和CGA显示器上过程。另外，也可以注意到，如果用户想执行读操作，则stdout_io函数直接返回错误值-E_INVAL。</p>
<h4 id="stdin-设备文件"><a href="#stdin-设备文件" class="headerlink" title="stdin 设备文件"></a>stdin 设备文件</h4><p>这里的stdin设备文件实际上就是指的键盘。这个设备文件是一个只读设备，如果写这个设备，就会出错。接下来我们看看stdin设备的相关处理过程。</p>
<h5 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h5><p>stdin设备文件的初始化过程主要由stdin_device_init完成了主要的初始化工作，具体实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">stdin_device_init</span><span class="params">(<span class="keyword">struct</span> device *dev)</span> &#123;</span><br><span class="line">    dev-&gt;d_blocks = <span class="number">0</span>;</span><br><span class="line">    dev-&gt;d_blocksize = <span class="number">1</span>;</span><br><span class="line">    dev-&gt;d_open = stdin_open;</span><br><span class="line">    dev-&gt;d_close = stdin_close;</span><br><span class="line">    dev-&gt;d_io = stdin_io;</span><br><span class="line">    dev-&gt;d_ioctl = stdin_ioctl;</span><br><span class="line"></span><br><span class="line">    p_rpos = p_wpos = <span class="number">0</span>;</span><br><span class="line">    wait_queue_init(wait_queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>相对于stdout的初始化过程，stdin的初始化相对复杂一些，<strong>多了一个stdin_buffer缓冲区</strong>，描述缓冲区读写位置的变量p_rpos、p_wpos以及用于等待缓冲区的等待队列wait_queue。在stdin_device_init函数的初始化中，也完成了对p_rpos、p_wpos和wait_queue的初始化。</p>
<h5 id="访问操作实现-1"><a href="#访问操作实现-1" class="headerlink" title="访问操作实现"></a>访问操作实现</h5><p>stdin_io函数负责完成设备的读操作工作，具体实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">stdin_io(struct device *dev, struct iobuf *iob, bool write) &#123;</span><br><span class="line">    if (!write) &#123;</span><br><span class="line">        int ret;</span><br><span class="line">        if ((ret = dev_stdin_read(iob-&gt;io_base, iob-&gt;io_resid)) &gt; 0) &#123;</span><br><span class="line">            iob-&gt;io_resid -= ret;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    return -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看到，如果是写操作，则stdin_io函数直接报错返回。所以这也进一步说明了此设备文件是只读文件。如果此读操作，则此函数进一步调用dev_stdin_read函数完成对键盘设备的读入操作。dev_stdin_read函数的实现相对复杂一些，主要的流程如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">dev_stdin_read</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ret &lt; len; ret ++, p_rpos ++) &#123;</span><br><span class="line">        try_again:</span><br><span class="line">            <span class="keyword">if</span> (p_rpos &lt; p_wpos) &#123;</span><br><span class="line">                *buf ++ = stdin_buffer[p_rpos % stdin_BUFSIZE];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">                wait_current_set(wait_queue, wait, WT_KBD);</span><br><span class="line">                local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">                schedule();</span><br><span class="line"></span><br><span class="line">                local_intr_save(intr_flag);</span><br><span class="line">                wait_current_del(wait_queue, wait);</span><br><span class="line">                <span class="keyword">if</span> (wait-&gt;wakeup_flags == WT_KBD) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> try_again;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在上述函数中可以看出，如果p_rpos &lt; p_wpos，则表示有键盘输入的新字符在stdin_buffer中，于是就从stdin_buffer中取出新字符放到iobuf指向的缓冲区中；如果p_rpos &gt;=p_wpos，则表明没有新字符，这样调用read用户态库函数的用户进程就需要采用等待队列的睡眠操作进入睡眠状态，等待键盘输入字符的产生。</p>
<p>当识别出中断是键盘中断（中断号为IRQ_OFFSET + IRQ_KBD）时，会调用dev_stdin_write函数，来把字符写入到stdin_buffer中，且会通过等待队列的唤醒操作唤醒正在等待键盘输入的用户进程。</p>
<h3 id="实验执行流程概述-2"><a href="#实验执行流程概述-2" class="headerlink" title="实验执行流程概述"></a>实验执行流程概述</h3><p>kern_init函数增加了对fs_init函数的调用。fs_init函数就是文件系统初始化的总控函数，它进一步调用了虚拟文件系统初始化函数vfs_init，与文件相关的设备初始化函数dev_init和Simple FS文件系统的初始化函数sfs_init。这三个初始化函数联合在一起，协同完成了整个虚拟文件系统、SFS文件系统和文件系统对应的设备（键盘、串口、磁盘）的初始化工作。其函数调用关系图如下所示：<br><img src="/img/20190629004.png" alt=""></p>
<p>vfs_init如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vfs_init -  vfs initialize</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vfs_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    sem_init(&amp;bootfs_sem, <span class="number">1</span>);</span><br><span class="line">    vfs_devlist_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>sem_init函数主要是初始化了信号量和等待队列：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sem_init</span><span class="params">(<span class="type">semaphore_t</span> *sem, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    sem-&gt;value = value;</span><br><span class="line">    wait_queue_init(&amp;(sem-&gt;wait_queue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>vfs_devlist_init主要是初始化设备列表，建立了一个device list双向链表vdev_list，为后续具体设备（键盘、串口、磁盘）以文件的形式呈现建立查找访问通道<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vfs_devlist_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    list_init(&amp;vdev_list);</span><br><span class="line">    sem_init(&amp;vdev_list_sem, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dev_init函数通过进一步调用disk0/stdin/stdout_device_init完成对具体设备的初始化，把它们抽象成一个设备文件，并建立对应的inode数据结构，最后把它们链入到vdev_list中。这样通过虚拟文件系统就可以方便地以文件的形式访问这些设备了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> init_device(x)                                  \</span></span><br><span class="line"><span class="meta">    do &#123;                                                \</span></span><br><span class="line"><span class="meta">        extern void dev_init_##x(void);                 \</span></span><br><span class="line"><span class="meta">        dev_init_##x();                                 \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* dev_init - Initialization functions for builtin vfs-level devices. */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">dev_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// init_device(null);</span></span><br><span class="line">    init_device(<span class="built_in">stdin</span>);</span><br><span class="line">    init_device(<span class="built_in">stdout</span>);</span><br><span class="line">    init_device(disk0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">dev_init_disk0</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((node = dev_create_inode()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;disk0: dev_create_node.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    disk0_device_init(vop_info(node, device));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_add_dev(<span class="string">&quot;disk0&quot;</span>, node, <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;disk0: vfs_add_dev: %e.\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dev_init_stdin(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((node = dev_create_inode()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;stdin: dev_create_node.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stdin_device_init(vop_info(node, device));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_add_dev(<span class="string">&quot;stdin&quot;</span>, node, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;stdin: vfs_add_dev: %e.\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">dev_init_stdout</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((node = dev_create_inode()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;stdout: dev_create_node.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stdout_device_init(vop_info(node, device));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_add_dev(<span class="string">&quot;stdout&quot;</span>, node, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;stdout: vfs_add_dev: %e.\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>sfs_init是完成对Simple FS的初始化工作，并把此实例文件系统挂在虚拟文件系统中，从而让ucore的其他部分能够通过访问虚拟文件系统的接口来进一步访问到SFS实例文件系统。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_init - mount sfs on disk0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CALL GRAPH:</span></span><br><span class="line"><span class="comment"> *   kern_init--&gt;fs_init--&gt;sfs_init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sfs_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_mount(<span class="string">&quot;disk0&quot;</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;failed: sfs: sfs_mount: %e.\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在sfs_init中调用了sfs_mount —&gt; vfs_mount 进行挂载：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sfs_mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> vfs_mount(devname, sfs_do_mount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>vfs_mount把一个文件系统挂载到系统上<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vfs_mount - Mount a filesystem. Once we&#x27;ve found the device, call MOUNTFUNC to</span></span><br><span class="line"><span class="comment"> *             set up the filesystem and hand back a struct fs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The DATA argument is passed through unchanged to MOUNTFUNC.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vfs_mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *devname, <span class="type">int</span> (*mountfunc)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> fs **fs_store))</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    lock_vdev_list();</span><br><span class="line">    <span class="comment">// 信号量操作</span></span><br><span class="line">    <span class="type">vfs_dev_t</span> *vdev;</span><br><span class="line">    <span class="keyword">if</span> ((ret = find_mount(devname, &amp;vdev)) != <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 找一个同名设备</span></span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vdev-&gt;fs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -E_BUSY;</span><br><span class="line">        <span class="comment">// 如果这个设备已经被挂载到一个文件系统上了，就不能被再挂载</span></span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(vdev-&gt;devname != <span class="literal">NULL</span> &amp;&amp; vdev-&gt;mountable);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> vop_info(vdev-&gt;devnode, device);</span><br><span class="line">    <span class="keyword">if</span> ((ret = mountfunc(dev, &amp;(vdev-&gt;fs))) == <span class="number">0</span>) &#123;</span><br><span class="line">        assert(vdev-&gt;fs != <span class="literal">NULL</span>);</span><br><span class="line">        cprintf(<span class="string">&quot;vfs: mount %s.\n&quot;</span>, vdev-&gt;devname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    unlock_vdev_list();</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于vop_info：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __vop_info(node, type)                                      \</span></span><br><span class="line"><span class="meta">    (&#123;                                                              \</span></span><br><span class="line"><span class="meta">        struct inode *__node = (node);                              \</span></span><br><span class="line"><span class="meta">        assert(__node != NULL &amp;&amp; check_inode_type(__node, type));   \</span></span><br><span class="line"><span class="meta">        &amp;(__node-&gt;in_info.__##type##_info);                         \</span></span><br><span class="line"><span class="meta">     &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vop_info(node, type)                                        __vop_info(node, type)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><code>__##type##_info</code>是一个<code>struct device</code>或<code>struct sfs_inode</code>的结构体，一般调用vop_info的时候都是给一个变量赋值为一个设备的结构体。</p>
<p><code>mountfunc</code>竟然是一个参数，流批流批。。。溯源的话有<code>sfs_do_mount</code>作为参数，下文介绍sfs_do_mount，太多了。。。</p>
<h3 id="文件操作实现"><a href="#文件操作实现" class="headerlink" title="文件操作实现"></a>文件操作实现</h3><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>有了上述分析后，我们可以看看如果一个用户进程打开文件会做哪些事情？首先假定用户进程需要打开的文件已经存在在硬盘上。以user/sfs_filetest1.c为例，首先用户进程会调用在main函数中的如下语句：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fd1 = safe_open(&quot;sfs\_filetest1&quot;, O_RDONLY);</span><br></pre></td></tr></table></figure><br>如果ucore能够正常查找到这个文件，就会返回一个代表文件的文件描述符fd1，这样在接下来的读写文件过程中，就直接用这样fd1来代表就可以了。</p>
<p>safe_open实现如下，在open中调用了sys_open，接着调用了syscall，执行系统调用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int safe_open(const char *path, int open_flags)</span><br><span class="line">&#123;</span><br><span class="line">        int fd = open(path, open_flags);</span><br><span class="line">        printf(&quot;fd is %d\n&quot;,fd);</span><br><span class="line">        assert(fd &gt;= 0);</span><br><span class="line">        return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="通用文件访问接口层的处理流程"><a href="#通用文件访问接口层的处理流程" class="headerlink" title="通用文件访问接口层的处理流程"></a>通用文件访问接口层的处理流程</h5><p>进一步调用如下用户态函数： <code>open-&gt;sys_open</code>-&gt;<code>syscall</code>，从而引起系统调用进入到内核态。到了内核态后，通过中断处理例程，会调用到<code>sys_open</code>内核函数，并进一步调用<code>sysfile_open</code>内核函数。到了这里，需要把位于用户空间的字符串”sfs_filetest1”拷贝到内核空间中的字符串path中，这里copy_path完成了本功能，这里不再列出。进入到文件系统抽象层的处理流程完成进一步的打开文件操作中。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">sys_open(uint32_t arg[]) &#123;</span><br><span class="line">    const char *path = (const char *)arg[0];</span><br><span class="line">    uint32_t open_flags = (uint32_t)arg[1];</span><br><span class="line">    return sysfile_open(path, open_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* sysfile_open - open file */</span><br><span class="line">int</span><br><span class="line">sysfile_open(const char *__path, uint32_t open_flags) &#123;</span><br><span class="line">    int ret;</span><br><span class="line">    char *path;</span><br><span class="line">    if ((ret = copy_path(&amp;path, __path)) != 0) &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = file_open(path, open_flags);</span><br><span class="line">    kfree(path);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="文件系统抽象层的处理流程"><a href="#文件系统抽象层的处理流程" class="headerlink" title="文件系统抽象层的处理流程"></a>文件系统抽象层的处理流程</h5><ul>
<li><p>分配一个空闲的file数据结构变量file。</p>
<ul>
<li>在文件系统抽象层的处理中，首先调用的是file_open函数，它要给这个即将打开的文件分配一个file数据结构的变量，这个变量其实是当前进程的打开文件数组<code>current-&gt;fs_struct-&gt;filemap[]</code>中的一个空闲元素（即还没用于一个打开的文件），而这个元素的索引值就是最终要返回到用户进程并赋值给变量fd1。到了这一步还仅仅是给当前用户进程分配了一个file数据结构的变量，还没有找到对应的文件索引节点。</li>
</ul>
</li>
<li><p>调用<code>vfs_open</code>函数来找到path指出的文件所对应的基于inode数据结构的VFS索引节点node。</p>
<ul>
<li><code>vfs_open</code>函数需要完成：<ul>
<li>确定读写权限；</li>
<li>通过vfs_lookup找到path对应文件的inode；首先是调用get_device，先对路径字符串进行判断，看是不是声明了设备（有：）或者是绝对路径（有/）。如果是相对路径，调用vfs_get_curdir获得当前的路径。如果有设备名，则根据路径中的设备名在设备list中找到这个设备，返回一个inode。如果是绝对路径，则返回根目录。如果开头有个‘:’，说明是在当前文件系统中，返回的是当前目录。</li>
<li>找到文件设备的根目录“/”的索引节点需要注意，这里的<code>vfs_lookup</code>函数是一个针对目录的操作函数，它会调用<code>vop_lookup</code>函数来找到SFS文件系统中的“/”目录下的“sfs_filetest1”文件。为此，<code>vfs_lookup</code>函数首先调用<code>get_device</code>函数，并进一步调用<code>vfs_get_bootfs</code>函数来找到根目录“/”对应的inode。这个inode就是位于vfs.c中的inode变量bootfs_node。这个变量在init_main函数（位于kern/process/proc.c）执行时获得了赋值。</li>
<li>通过调用vop_lookup函数来查找到根目录“/”下对应文件sfs_filetest1的索引节点，如果找到就返回此索引节点。</li>
</ul>
</li>
<li>调用vop_open函数打开文件。</li>
<li>调用了vop_truncate（应该是这个sfs_truncfile），调整文件大小到适当的大小（按照块个数计算）</li>
<li>调用了vfs_fsync，如果发生了什么使得这个块变成dirty了，就调用d_io把它写进去。</li>
</ul>
</li>
<li><p>把file和node建立联系，设置file的读写权限，如果是append模式的话还要把file的pos设置到末尾。完成后，将返回到file_open函数中，通过执行语句“file-&gt;node=node;”，就把当前进程的current-&gt;fs_struct-&gt;filemap[fd]（即file所指变量）的成员变量node指针指向了代表sfs_filetest1文件的索引节点inode。</p>
</li>
<li>这时返回fd。经过重重回退，通过系统调用返回，用户态的syscall-&gt;sys_open-&gt;open-&gt;safe_open等用户函数的层层函数返回，最终把fd赋值给fd1。自此完成了打开文件操作。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// open file</span><br><span class="line">int</span><br><span class="line">file_open(char *path, uint32_t open_flags) &#123;</span><br><span class="line">    bool readable = 0, writable = 0;</span><br><span class="line">    switch (open_flags &amp; O_ACCMODE) &#123;</span><br><span class="line">        case O_RDONLY: readable = 1; break;</span><br><span class="line">        case O_WRONLY: writable = 1; break;</span><br><span class="line">        case O_RDWR:</span><br><span class="line">            readable = writable = 1;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            return -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ret;</span><br><span class="line">    struct file *file;</span><br><span class="line">    if ((ret = fd_array_alloc(NO_FD, &amp;file)) != 0) &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">//分配一个file数据结构的变量</span><br><span class="line"></span><br><span class="line">    struct inode *node;</span><br><span class="line">    if ((ret = vfs_open(path, open_flags, &amp;node)) != 0) &#123;</span><br><span class="line">        fd_array_free(file);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">//找到path指出的文件所对应的基于inode数据结构的VFS索引节点node</span><br><span class="line"></span><br><span class="line">    file-&gt;pos = 0;</span><br><span class="line">    if (open_flags &amp; O_APPEND) &#123;</span><br><span class="line">        struct stat __stat, *stat = &amp;__stat;</span><br><span class="line">        if ((ret = vop_fstat(node, stat)) != 0) &#123;</span><br><span class="line">            vfs_close(node);</span><br><span class="line">            fd_array_free(file);</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">        file-&gt;pos = stat-&gt;st_size;</span><br><span class="line">    &#125;</span><br><span class="line">// 根据open_flags找当前指针应该指在文件的什么位置</span><br><span class="line"></span><br><span class="line">    file-&gt;node = node;</span><br><span class="line">    file-&gt;readable = readable;</span><br><span class="line">    file-&gt;writable = writable;</span><br><span class="line">    fd_array_open(file);</span><br><span class="line">    return file-&gt;fd;</span><br><span class="line">&#125;    	</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="SFS文件系统层的处理流程"><a href="#SFS文件系统层的处理流程" class="headerlink" title="SFS文件系统层的处理流程"></a>SFS文件系统层的处理流程</h5><p>在sfs_inode.c中的<code>sfs_node_dirops</code>变量定义了“.vop_lookup = sfs_lookup”，所以我们重点分析sfs_lookup的实现。</p>
<p>sfs_lookup有三个参数：node，path，node_store。其中node是根目录“/”所对应的inode节点；path是文件sfs_filetest1的绝对路径/sfs_filetest1，而node_store是经过查找获得的sfs_filetest1所对应的inode节点。<br>sfs_lookup函数以“/”为分割符，从左至右逐一分解path获得各个子目录和最终文件对应的inode节点。在本例中是调用sfs_lookup_once查找以根目录下的文件sfs_filetest1所对应的inode节点。当无法分解path后，就意味着找到了sfs_filetest1对应的inode节点，就可顺利返回了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * sfs_lookup - Parse path relative to the passed directory</span><br><span class="line"> *              DIR, and hand back the inode for the file it</span><br><span class="line"> *              refers to.</span><br><span class="line"> */</span><br><span class="line">static int</span><br><span class="line">sfs_lookup(struct inode *node, char *path, struct inode **node_store) &#123;</span><br><span class="line">    struct sfs_fs *sfs = fsop_info(vop_fs(node), sfs);</span><br><span class="line">    assert(*path != &#x27;\0&#x27; &amp;&amp; *path != &#x27;/&#x27;);</span><br><span class="line">    vop_ref_inc(node);</span><br><span class="line">    struct sfs_inode *sin = vop_info(node, sfs_inode);</span><br><span class="line">    // 找到sfs_inode __sfs_inode_info。</span><br><span class="line">    if (sin-&gt;din-&gt;type != SFS_TYPE_DIR) &#123;</span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">        return -E_NOTDIR;</span><br><span class="line">    &#125;</span><br><span class="line">    struct inode *subnode;</span><br><span class="line">    int ret = sfs_lookup_once(sfs, sin, path, &amp;subnode, NULL);</span><br><span class="line">    // 找到与路径相符的inode并加载到subnode里。</span><br><span class="line">    vop_ref_dec(node);</span><br><span class="line">    if (ret != 0) &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    *node_store = subnode;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>用户进程有如下语句：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(fd, data, len);</span><br></pre></td></tr></table></figure><br>即读取fd对应文件，读取长度为len，存入data中。下面来分析一下读文件的实现。</p>
<h5 id="通用文件访问接口层的处理流程-1"><a href="#通用文件访问接口层的处理流程-1" class="headerlink" title="通用文件访问接口层的处理流程"></a>通用文件访问接口层的处理流程</h5><p>进一步调用如下用户态函数：<code>read-&gt;sys_read-&gt;syscall</code>，从而引起系统调用进入到内核态。到了内核态以后，通过中断处理例程，会调用到<code>sys_read</code>内核函数，并进一步调用<code>sysfile_read</code>内核函数，进入到文件系统抽象层处理流程完成进一步读文件的操作。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">sys_read(uint32_t arg[]) &#123;</span><br><span class="line">    int fd = (int)arg[0];</span><br><span class="line">    void *base = (void *)arg[1];</span><br><span class="line">    size_t len = (size_t)arg[2];</span><br><span class="line">    return sysfile_read(fd, base, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="文件系统抽象层的处理流程-1"><a href="#文件系统抽象层的处理流程-1" class="headerlink" title="文件系统抽象层的处理流程"></a>文件系统抽象层的处理流程</h5><ul>
<li>检查错误，即检查读取长度是否为0和文件是否可读。</li>
<li>分配buffer空间，即调用kmalloc函数分配4096字节的buffer空间。</li>
<li>读文件过程<ul>
<li>实际读文件。<ul>
<li>循环读取文件，每次读取buffer大小。</li>
<li>每次循环中，先检查剩余部分大小，若其小于4096字节，则只读取剩余部分的大小。</li>
<li>调用file_read函数（详细分析见后）将文件内容读取到buffer中，alen为实际大小。</li>
<li>调用copy_to_user函数将读到的内容拷贝到用户的内存空间中。</li>
<li>调整各变量以进行下一次循环读取，直至指定长度读取完成。</li>
<li>最后函数调用层层返回至用户程序，用户程序收到了读到的文件内容。</li>
</ul>
</li>
<li>file_read函数<ul>
<li>这个函数是读文件的核心函数。函数有4个参数，<ul>
<li>fd是文件描述符，</li>
<li>base是缓存的基地址，</li>
<li>len是要读取的长度，</li>
<li>copied_store存放实际读取的长度。</li>
</ul>
</li>
<li>函数首先调用<code>fd2file</code>函数找到对应的file结构，并检查是否可读。</li>
<li>调用<code>filemap_acquire</code>函数使打开这个文件的计数加1。</li>
<li>调用vop_read函数将文件内容读到iob中（详细分析见后）。</li>
<li>调整文件指针偏移量pos的值，使其向后移动实际读到的字节数iobuf_used(iob)。</li>
<li>调用filemap_release函数使打开这个文件的计数减1，若打开计数为0，则释放file。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/* sysfile_read - read file */</span><br><span class="line">int</span><br><span class="line">sysfile_read(int fd, void *base, size_t len) &#123;</span><br><span class="line">    struct mm_struct *mm = current-&gt;mm;</span><br><span class="line">    if (len == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!file_testfd(fd, 1, 0)) &#123;</span><br><span class="line">        return -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">// 检查读取长度是否为0和文件是否可读</span><br><span class="line"></span><br><span class="line">    void *buffer;</span><br><span class="line">    if ((buffer = kmalloc(IOBUF_SIZE)) == NULL) &#123;</span><br><span class="line">        return -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">// 调用kmalloc函数分配4096字节的buffer空间</span><br><span class="line"></span><br><span class="line">    int ret = 0;</span><br><span class="line">    size_t copied = 0, alen;</span><br><span class="line">    while (len != 0) &#123;</span><br><span class="line">        if ((alen = IOBUF_SIZE) &gt; len) &#123;</span><br><span class="line">            alen = len;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = file_read(fd, buffer, alen, &amp;alen);</span><br><span class="line">        // 将文件内容读取到buffer中，alen为实际大小       </span><br><span class="line">        if (alen != 0) &#123;</span><br><span class="line">            lock_mm(mm);</span><br><span class="line">            &#123;</span><br><span class="line">                if (copy_to_user(mm, base, buffer, alen)) &#123;</span><br><span class="line">                    // copy_to_user在vmm.c中，检查权限后memcpy</span><br><span class="line">                    assert(len &gt;= alen);</span><br><span class="line">                    base += alen, len -= alen, copied += alen;</span><br><span class="line">                &#125;</span><br><span class="line">                // 调用copy_to_user函数将读到的内容拷贝到用户的内存空间中</span><br><span class="line">                // 调整各变量以进行下一次循环读取，直至指定长度读取完成</span><br><span class="line">                else if (ret == 0) &#123;</span><br><span class="line">                    ret = -E_INVAL;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            unlock_mm(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ret != 0 || alen == 0) &#123;</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    kfree(buffer);</span><br><span class="line">    if (copied != 0) &#123;</span><br><span class="line">        return copied;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;                    </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// read file</span><br><span class="line">int</span><br><span class="line">file_read(int fd, void *base, size_t len, size_t *copied_store) &#123;</span><br><span class="line">    int ret;</span><br><span class="line">    struct file *file;</span><br><span class="line">    *copied_store = 0;</span><br><span class="line">    if ((ret = fd2file(fd, &amp;file)) != 0) &#123;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    // 找到对应的file结构</span><br><span class="line"></span><br><span class="line">    if (!file-&gt;readable) &#123;</span><br><span class="line">        return -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    fd_array_acquire(file);</span><br><span class="line">    // 打开这个文件的计数加1</span><br><span class="line"></span><br><span class="line">    struct iobuf __iob, *iob = iobuf_init(&amp;__iob, base, len, file-&gt;pos);</span><br><span class="line">    ret = vop_read(file-&gt;node, iob);</span><br><span class="line">    // 文件内容读到iob中，通过sfs_read --&gt; sfs_io，获取到inode，执行sfs_io_nolock。</span><br><span class="line"></span><br><span class="line">    size_t copied = iobuf_used(iob);</span><br><span class="line">    if (file-&gt;status == FD_OPENED) &#123;</span><br><span class="line">        file-&gt;pos += copied;</span><br><span class="line">    &#125;</span><br><span class="line">    *copied_store = copied;</span><br><span class="line">    fd_array_release(file);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="SFS文件系统层的处理流程-1"><a href="#SFS文件系统层的处理流程-1" class="headerlink" title="SFS文件系统层的处理流程"></a>SFS文件系统层的处理流程</h5><p><code>vop_read</code>函数实际上是对<code>sfs_read</code>的包装。在sfs_inode.c中<code>sfs_node_fileops</code>变量定义了<code>.vop_read = sfs_read</code>，所以下面来分析sfs_read函数的实现。</p>
<ul>
<li>sfs_read函数调用sfs_io函数。<ul>
<li>它有三个参数，node是对应文件的inode，iob是缓存，write表示是读还是写的布尔值（0表示读，1表示写），这里是0。</li>
<li>函数先找到inode对应sfs和sin，</li>
<li>然后调用sfs_io_nolock函数进行读取文件操作，</li>
<li>最后调用iobuf_skip函数调整iobuf的指针。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_io - Rd/Wr file. the wrapper of sfs_io_nolock</span></span><br><span class="line"><span class="comment">            with lock protect</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sfs_io</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> iobuf *iob, <span class="type">bool</span> write)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> *<span class="title">sfs</span> =</span> fsop_info(vop_fs(node), sfs);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> *<span class="title">sin</span> =</span> vop_info(node, sfs_inode);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    lock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> alen = iob-&gt;io_resid;</span><br><span class="line">        ret = sfs_io_nolock(sfs, <span class="built_in">sin</span>, iob-&gt;io_base, iob-&gt;io_offset, &amp;alen, write);</span><br><span class="line">        <span class="keyword">if</span> (alen != <span class="number">0</span>) &#123;</span><br><span class="line">            iobuf_skip(iob, alen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * iobuf_skip - change the current position of io buffer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">iobuf_skip</span><span class="params">(<span class="keyword">struct</span> iobuf *iob, <span class="type">size_t</span> n)</span> &#123;</span><br><span class="line">    assert(iob-&gt;io_resid &gt;= n);</span><br><span class="line">    iob-&gt;io_base += n, iob-&gt;io_offset += n, iob-&gt;io_resid -= n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="练习1-完成读文件操作的实现"><a href="#练习1-完成读文件操作的实现" class="headerlink" title="练习1: 完成读文件操作的实现"></a>练习1: 完成读文件操作的实现</h3><p>首先完成proc.c中process控制块的初始化，在<code>static struct proc_struct *alloc_proc(void)</code>中添加：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc-&gt;filesp = NULL;</span><br></pre></td></tr></table></figure></p>
<p>如果调用了read系统调用，继续调用sys_read函数，和sysfile_read函数，在这个函数中，创建了缓冲区，进一步复制到用户空间的指定位置去；从文件读取数据的函数是file_read。</p>
<p>在file_read函数中，通过文件描述符找到相应文件对应的内存中的inode信息，调用vop_read进行读取处理，vop_read继续调用sfs_read函数，然后调用sfs_io函数和sfs_io_nolock函数。</p>
<ul>
<li>在sfs_io_nolock函数中，<ul>
<li>先计算一些辅助变量，并处理一些特殊情况（比如越界），</li>
<li>然后有<code>sfs_buf_op = sfs_rbuf</code>，<code>sfs_block_op = sfs_rblock</code>，设置读取的函数操作。</li>
<li>先处理起始的没有对齐到块的部分，再以块为单位循环处理中间的部分，最后处理末尾剩余的部分。</li>
<li>每部分中都调用sfs_bmap_load_nolock函数得到blkno对应的inode编号，</li>
<li>并调用<code>sfs_rbuf</code>或<code>sfs_rblock</code>函数读取数据（中间部分调用sfs_rblock，起始和末尾部分调用sfs_rbuf），调整相关变量。</li>
<li>完成后如果<code>offset + alen &gt; din-&gt;fileinfo.size</code>（写文件时会出现这种情况，读文件时不会出现这种情况，alen为实际读写的长度），则调整文件大小为<code>offset + alen</code>并设置dirty变量。</li>
</ul>
</li>
<li><code>sfs_bmap_load_nolock</code>函数将对应<code>sfs_inode</code>的第index个索引指向的block的索引值取出存到相应的指针指向的单元（ino_store）。<ul>
<li>调用sfs_bmap_get_nolock来完成相应的操作。</li>
<li>sfs_rbuf和sfs_rblock函数最终都调用sfs_rwblock_nolock函数完成操作，</li>
<li>而sfs_rwblock_nolock函数调用dop_io-&gt;disk0_io-&gt;disk0_read_blks_nolock-&gt;ide_read_secs完成对磁盘的操作。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_io_nolock - Rd/Wr a file contentfrom offset position to offset+ length  disk blocks&lt;--&gt;buffer (in memroy) * * @sfs:      sfs file system</span></span><br><span class="line"><span class="comment"> * @sin:      sfs inode in memory</span></span><br><span class="line"><span class="comment"> * @buf:      the buffer Rd/Wr</span></span><br><span class="line"><span class="comment"> * @offset:   the offset of file</span></span><br><span class="line"><span class="comment"> * @alenp:    the length need to read (is a pointer). and will RETURN the really Rd/Wr lenght</span></span><br><span class="line"><span class="comment"> * @write:    BOOL, 0 read, 1 write</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sfs_io_nolock</span><span class="params">(<span class="keyword">struct</span> sfs_fs *sfs, <span class="keyword">struct</span> sfs_inode *<span class="built_in">sin</span>, <span class="type">void</span> *buf, <span class="type">off_t</span> offset, <span class="type">size_t</span> *alenp, <span class="type">bool</span> write)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    assert(din-&gt;type != SFS_TYPE_DIR);</span><br><span class="line">    <span class="type">off_t</span> endpos = offset + *alenp, blkoff;</span><br><span class="line">    *alenp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算出读写的长度，从初始偏移量走到文件的哪个位置</span></span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt;= SFS_MAX_FILE_SIZE || offset &gt; endpos) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (offset == endpos) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endpos &gt; SFS_MAX_FILE_SIZE) &#123;</span><br><span class="line">        endpos = SFS_MAX_FILE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 文件过大，到了最大支持的文件长度了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!write) &#123;</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= din-&gt;size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (endpos &gt; din-&gt;size) &#123;</span><br><span class="line">            endpos = din-&gt;size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果end position超过了文件大小，就把它移动到这个文件的末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> (*sfs_buf_op)(<span class="keyword">struct</span> sfs_fs *sfs, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">uint32_t</span> blkno, <span class="type">off_t</span> offset);</span><br><span class="line">    <span class="type">int</span> (*sfs_block_op)(<span class="keyword">struct</span> sfs_fs *sfs, <span class="type">void</span> *buf, <span class="type">uint32_t</span> blkno, <span class="type">uint32_t</span> nblks);</span><br><span class="line">    <span class="keyword">if</span> (write) &#123;</span><br><span class="line">        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置读取/写入的函数操作</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> size, alen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> ino;</span><br><span class="line">    <span class="type">uint32_t</span> blkno = offset / SFS_BLKSIZE;          <span class="comment">// 起始的block序号</span></span><br><span class="line">    <span class="type">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno;  <span class="comment">// 一共要读写多少个block？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//LAB8:EXERCISE1 YOUR CODE </span></span><br><span class="line"><span class="comment">//HINT: call sfs_bmap_load_nolock, sfs_rbuf, sfs_rblock,etc. </span></span><br><span class="line"><span class="comment">// read different kind of blocks in file</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * (1) If offset isn&#x27;t aligned with the first block, Rd/Wr some content from offset to the end of the first block</span></span><br><span class="line"><span class="comment">  * NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op</span></span><br><span class="line"><span class="comment">  * Rd/Wr size = (nblks != 0) ? (SFS_BLKSIZE - blkoff) : (endpos - offset)</span></span><br><span class="line"><span class="comment">  * (2) Rd/Wr aligned blocks</span></span><br><span class="line"><span class="comment">  * NOTICE: useful function: sfs_bmap_load_nolock, sfs_block_op</span></span><br><span class="line"><span class="comment">  * (3) If end position isn&#x27;t aligned with the last block, Rd/Wr some content from begin to the (endpos % SFS_BLKSIZE) of the last block</span></span><br><span class="line"><span class="comment">  * NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">if</span> (offset % SFS_BLKSIZE != <span class="number">0</span> || endpos / SFS_BLKSIZE == offset / SFS_BLKSIZE)&#123;</span><br><span class="line">        blkoff = offset % SFS_BLKSIZE;</span><br><span class="line">        size = (nblks != <span class="number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="number">0</span>) <span class="keyword">goto</span> out;</span><br><span class="line">        alen += size;</span><br><span class="line">        buf += size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理如果不是从块的开头开始写的情况，如果偏移量%块大小不是0则是从块内部开始写的。如果nblks是0的话说明只有一个块里的一部分需要写。先把这个写了。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> my_nblks = nblks;</span><br><span class="line">    <span class="keyword">if</span> (offset % SFS_BLKSIZE != <span class="number">0</span> &amp;&amp; my_nblks &gt; <span class="number">0</span>)</span><br><span class="line">        my_nblks --;</span><br><span class="line">    <span class="comment">// 如果是从一个块的一部分开始写的，那在总的块数上需要减一。</span></span><br><span class="line">    <span class="keyword">if</span> (my_nblks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> temp_blkno = (offset % SFS_BLKSIZE == <span class="number">0</span>) ? blkno: blkno + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, temp_blkno, &amp;ino)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, my_nblks)) != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这里的sfs_block_op是一个循环，把mu_nblks个块进行读写，跟开头和结尾的那个sfs_buf_op不一样</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        size = SFS_BLKSIZE * my_nblks;</span><br><span class="line">        alen += size;</span><br><span class="line">        buf += size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下边就是处理如果最后一部分是最后一块的一部分的了，ino存储了disk上的inode的编号，然后在下边的sfs_buf_op中，处理最后一小块</span></span><br><span class="line">    <span class="keyword">if</span> (endpos % SFS_BLKSIZE != <span class="number">0</span> &amp;&amp; endpos / SFS_BLKSIZE != offset / SFS_BLKSIZE) &#123;</span><br><span class="line">            size = endpos % SFS_BLKSIZE;</span><br><span class="line">            <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, endpos / SFS_BLKSIZE, &amp;ino) == <span class="number">0</span>) != <span class="number">0</span>) <span class="keyword">goto</span> out;</span><br><span class="line">            <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="number">0</span>)) != <span class="number">0</span>) <span class="keyword">goto</span> out;</span><br><span class="line">            alen += size;</span><br><span class="line">            buf += size;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;size = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<ul>
<li>请在实验报告中给出设计实现”UNIX的PIPE机制“的概要设方案，鼓励给出详细设计方案。<ul>
<li>PIPE机制可以看成是一个缓冲区，可以在磁盘上（或内存中？）保留一部分空间作为pipe机制的缓冲区。当两个进程之间要求建立pipe时，在两个进程的进程控制块上修改某些属性表明这个进程是管道数据的发送方还是接受方，这样就可以将stdin或stdout重定向到生成的临时文件里，在两个进程中打开这个临时文件。</li>
<li>当进程A使用stdout写时，查询PCB中的相关变量，把这些stdout数据输出到临时文件中；</li>
<li>当进程B使用stdin的时候，查询PCB中的信息，从临时文件中读取数据；</li>
</ul>
</li>
</ul>
<h3 id="练习2-完成基于文件系统的执行程序机制的实现"><a href="#练习2-完成基于文件系统的执行程序机制的实现" class="headerlink" title="练习2: 完成基于文件系统的执行程序机制的实现"></a>练习2: 完成基于文件系统的执行程序机制的实现</h3><p>改写proc.c中的load_icode函数和其他相关函数，实现基于文件系统的执行程序机制。首先是在do_execve中进行文件名和命令行参数的复制，执行sysfie_open打开相关文件，fd是已经打开的这个文件。执行： make qemu。如果能看看到sh用户程序的执行界面，则基本成功了。如果在sh用户界面上可 以执行”ls”,”hello”等其他放置在sfs文件系统中的其他执行程序，则可以认为本实验基本成功。</p>
<ul>
<li>给要执行的用户进程创建一个新的内存管理结构mm，</li>
<li>创建用户内存空间的新的页目录表；</li>
<li>将磁盘上的ELF文件的TEXT/DATA/BSS段正确地加载到用户空间中；</li>
<li>从磁盘中读取elf文件的header；</li>
<li>根据elfheader中的信息，获取到磁盘上的program header；</li>
<li>对于每一个program header:<ul>
<li>为TEXT/DATA段在用户内存空间上的保存分配物理内存页，同时建立物理页和虚拟页的映射关系；</li>
<li>从磁盘上读取TEXT/DATA段，并且复制到用户内存空间上去；</li>
<li>根据program header得知是否需要创建BBS段，如果是，则分配相应的内存空间，并且全部初始化成0，并且建立物理页和虚拟页的映射关系；</li>
</ul>
</li>
<li>将用户栈的虚拟空间设置为合法，并且为栈顶部分先分配4个物理页，建立好映射关系；</li>
<li>切换到用户地址空间；</li>
<li>设置好用户栈上的信息，即需要传递给执行程序的参数；</li>
<li>设置好中断帧；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">load_icode</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> argc, <span class="type">char</span> **kargv)</span> &#123;</span><br><span class="line">    <span class="comment">/* LAB8:EXERCISE2 YOUR CODE  HINT:how to load the file with handler fd  in to process&#x27;s memory? how to setup argc/argv?</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *  mm_create        - create a mm</span></span><br><span class="line"><span class="comment">     *  setup_pgdir      - setup pgdir in mm</span></span><br><span class="line"><span class="comment">     *  load_icode_read  - read raw data content of program file</span></span><br><span class="line"><span class="comment">     *  mm_map           - build new vma</span></span><br><span class="line"><span class="comment">     *  pgdir_alloc_page - allocate new memory for  TEXT/DATA/BSS/stack parts</span></span><br><span class="line"><span class="comment">     *  lcr3             - update Page Directory Addr Register -- CR3</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * (1) create a new mm for current process</span></span><br><span class="line"><span class="comment">     * (2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span></span><br><span class="line"><span class="comment">     * (3) copy TEXT/DATA/BSS parts in binary to memory space of process</span></span><br><span class="line"><span class="comment">     *    (3.1) read raw data content in file and resolve elfhdr</span></span><br><span class="line"><span class="comment">     *    (3.2) read raw data content in file and resolve proghdr based on info in elfhdr</span></span><br><span class="line"><span class="comment">     *    (3.3) call mm_map to build vma related to TEXT/DATA</span></span><br><span class="line"><span class="comment">     *    (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span></span><br><span class="line"><span class="comment">     *          and copy them into the new allocated pages</span></span><br><span class="line"><span class="comment">     *    (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span></span><br><span class="line"><span class="comment">     * (4) call mm_map to setup user stack, and put parameters into user stack</span></span><br><span class="line"><span class="comment">     * (5) setup current process&#x27;s mm, cr3, reset pgidr (using lcr3 MARCO)</span></span><br><span class="line"><span class="comment">     * (6) setup uargc and uargv in user stacks</span></span><br><span class="line"><span class="comment">     * (7) setup trapframe for user environment</span></span><br><span class="line"><span class="comment">     * (8) if up steps failed, you should cleanup the env.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;load_icode: current-&gt;mm must be empty.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="comment">//(1) create a new mm for current process</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span></span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(3) copy TEXT/DATA section, build BSS parts in binary to memory space of process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="comment">//(3.1) get the file header of the bianry program (ELF format)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf</span>;</span></span><br><span class="line">    <span class="type">off_t</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((ret = load_icode_read(fd, (<span class="type">void</span>*)&amp;elf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> elfhdr), <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// elf header读取到elf中，这里的参数比较复杂需要先取地址再类型转换</span></span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">if</span> (elf.e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        <span class="comment">//检查是不是魔数，如果是的话才是对的elf文件</span></span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    offset += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> elfhdr);</span><br><span class="line">    <span class="comment">// 这个文件已经读取到elf header 之后了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> vm_flags, perm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> <span class="title">ph</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; elf.e_phnum; i ++) &#123;</span><br><span class="line">    <span class="comment">// e_phnum is number of entries in program header.</span></span><br><span class="line">    <span class="comment">//(3.4) find every program section headers</span></span><br><span class="line">    <span class="comment">// 第二三个参数分别是读取的长度和在文件中的偏移量。</span></span><br><span class="line">    	<span class="type">off_t</span> phoff = elf.e_phoff + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> proghdr) * i;</span><br><span class="line">        load_icode_read(fd, (<span class="type">void</span>*)&amp;ph, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> proghdr), phoff);</span><br><span class="line">        <span class="keyword">if</span> (ph.p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph.p_filesz &gt; ph.p_memsz) &#123;</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph.p_filesz == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// call mm_map fun to setup the new vma ( ph-&gt;p_va, ph-&gt;p_memsz)</span></span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph.p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph.p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph.p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph.p_va, ph.p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 虚拟内存管理的权限控制，并设置映射</span></span><br><span class="line">        </span><br><span class="line">	    offset = ph.p_offset;</span><br><span class="line">        <span class="type">size_t</span> off, size;</span><br><span class="line">        <span class="type">uintptr_t</span> start = ph.p_va, end=ph.p_va+ph.p_filesz, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line">        <span class="comment">// start 和 end 是vma中的segment的起始和结尾</span></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            	ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">	        load_icode_read(fd, page2kva(page)+off, size, offset);</span><br><span class="line">            <span class="comment">//memcpy(page2kva(page) + off, from, size);</span></span><br><span class="line">            start += size, offset += size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// build BSS section of binary program</span></span><br><span class="line">        end = ph.p_va + ph.p_memsz;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; la) &#123;</span><br><span class="line">            <span class="comment">/* ph-&gt;p_memsz == ph-&gt;p_filesz */</span></span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            	ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page), <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sysfile_close(fd);</span><br><span class="line">    <span class="comment">//(4) build user stack memory</span></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> stacktop = USTACKTOP;</span><br><span class="line">    <span class="type">uint32_t</span> argsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt; argc ; j++)</span><br><span class="line">        argsize += (<span class="number">1</span> + <span class="built_in">strlen</span>(kargv[j]));</span><br><span class="line">    <span class="comment">// 计算传进来的参数的大小和长度，并进行取整</span></span><br><span class="line">    argsize = (argsize / <span class="keyword">sizeof</span>(<span class="type">long</span>)+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">    argsize += (<span class="number">2</span>+argc)*<span class="keyword">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">    stacktop = USTACKTOP - argsize;</span><br><span class="line">    <span class="type">uint32_t</span> pagen = argsize / PGSIZE + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; ++ j) &#123;</span><br><span class="line">        assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE*j , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//(5) set current process&#x27;s mm, sr3, and set CR3 reg = physical addr of Page Directory</span></span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(6) setup trapframe for user environment</span></span><br><span class="line">    <span class="type">uint32_t</span> now_pos = stacktop, argvp;</span><br><span class="line">    *((<span class="type">uint32_t</span>*)now_pos) = argc;</span><br><span class="line">    now_pos += <span class="number">4</span>;</span><br><span class="line">    *((<span class="type">uint32_t</span> *) now_pos) = argvp = now_pos + <span class="number">4</span>;</span><br><span class="line">    now_pos += <span class="number">4</span>;</span><br><span class="line">    now_pos += argc*<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//压栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; argc; ++ j) &#123;</span><br><span class="line">        argsize = <span class="built_in">strlen</span>(kargv[j]) + <span class="number">1</span>; </span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="type">void</span> *) now_pos, kargv[j], argsize);</span><br><span class="line">        *((<span class="type">uint32_t</span> *) (argvp + j * <span class="number">4</span>)) = now_pos;</span><br><span class="line">        now_pos += argsize;</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* LAB5:EXERCISE1 YOUR CODE</span></span><br><span class="line"><span class="comment">     * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags</span></span><br><span class="line"><span class="comment">     * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So</span></span><br><span class="line"><span class="comment">     *          tf_cs should be USER_CS segment (see memlayout.h)</span></span><br><span class="line"><span class="comment">     *          tf_ds=tf_es=tf_ss should be USER_DS segment</span></span><br><span class="line"><span class="comment">     *          tf_esp should be the top addr of user stack (USTACKTOP)</span></span><br><span class="line"><span class="comment">     *          tf_eip should be the entry point of this binary program (elf-&gt;e_entry)</span></span><br><span class="line"><span class="comment">     *          tf_eflags should be set to enable computer to produce Interrupt</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = stacktop;</span><br><span class="line">    tf-&gt;tf_eip = elf.e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = <span class="number">0x2</span> | FL_IF; <span class="comment">// to enable interrupt</span></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>UNIX的硬链接和软链接机制：</p>
<p>硬链接：</p>
<ul>
<li>文件有相同的 inode 及 data block；</li>
<li>只能对已存在的文件进行创建；</li>
<li>不能交叉文件系统进行硬链接的创建；</li>
<li>不能对目录进行创建，只可对文件创建；</li>
<li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</li>
</ul>
<p>软链接：</p>
<ul>
<li>软链接有自己的文件属性及权限等；</li>
<li>可对不存在的文件或目录创建软链接；</li>
<li>软链接可交叉文件系统；</li>
<li>软链接可对文件或目录创建；</li>
<li>创建软链接时，链接计数 i_nlink 不会增加；</li>
<li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接</li>
</ul>
<p>硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块<br>软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径。</p>
<p>sfs_disk_inode结构体中有一个nlinks变量，如果要创建一个文件的软链接，这个软链接也要创建inode，只是它的类型是链接，找一个域设置它所指向的文件inode，如果文件是一个链接，就可以通过保存的inode位置进行操作；当删除一个软链接时，直接删掉inode即可；</p>
<p>硬链接与文件是共享inode的，如果创建一个硬链接，需要将源文件中的被链接的计数加1；当删除一个硬链接的时候，除了需要删掉inode之外，还需要将硬链接指向的文件的被链接计数减1，如果减到了0，则需要将A删除掉；</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/06/27/golang%E5%AD%A6%E4%B9%A0/" rel="prev" title="golang学习">
      <i class="fa fa-chevron-left"></i> golang学习
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/06/29/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="next" title="清华大学操作系统课程笔记">
      清华大学操作系统课程笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%80"><span class="nav-number">1.</span> <span class="nav-text">实验一</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6ucore-img%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%94%9F%E6%88%90%E7%9A%84%EF%BC%9F-%E9%9C%80%E8%A6%81%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E5%9C%B0%E8%A7%A3%E9%87%8AMakefile%E4%B8%AD%E6%AF%8F%E4%B8%80%E6%9D%A1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%92%8C%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E7%9A%84%E5%90%AB%E4%B9%89%EF%BC%8C%E4%BB%A5%E5%8F%8A%E8%AF%B4%E6%98%8E%E5%91%BD%E4%BB%A4%E5%AF%BC%E8%87%B4%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-number">1.1.</span> <span class="nav-text">操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E8%A2%AB%E7%B3%BB%E7%BB%9F%E8%AE%A4%E4%B8%BA%E6%98%AF%E7%AC%A6%E5%90%88%E8%A7%84%E8%8C%83%E7%9A%84%E7%A1%AC%E7%9B%98%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E7%9A%84%E7%89%B9%E5%BE%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A02%EF%BC%9A"><span class="nav-number">1.3.</span> <span class="nav-text">练习2：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A03"><span class="nav-number">1.4.</span> <span class="nav-text">练习3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E5%9B%9B"><span class="nav-number">1.5.</span> <span class="nav-text">练习四</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E4%BA%94"><span class="nav-number">1.6.</span> <span class="nav-text">练习五</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E5%85%AD"><span class="nav-number">1.7.</span> <span class="nav-text">练习六</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E4%B8%83"><span class="nav-number">1.8.</span> <span class="nav-text">练习七</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%8C"><span class="nav-number">2.</span> <span class="nav-text">实验二</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E4%BB%A3%E7%A0%81"><span class="nav-number">2.1.</span> <span class="nav-text">读代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A01-%E5%AE%9E%E7%8E%B0first-fit%E8%BF%9E%E7%BB%AD%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">练习1 实现first-fit连续物理内存分配算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E4%BA%8C"><span class="nav-number">2.3.</span> <span class="nav-text">练习二</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%89%A7%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E3%80%82"><span class="nav-number">2.3.1.</span> <span class="nav-text">系统执行中的地址映射。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%92%8C%E7%89%A9%E7%90%86%E9%A1%B5%E5%B8%A7%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.3.2.</span> <span class="nav-text">建立虚拟页和物理页帧的地址映射关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E4%BA%8C%E4%BB%A3%E7%A0%81"><span class="nav-number">2.3.3.</span> <span class="nav-text">练习二代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E4%B8%89"><span class="nav-number">2.3.4.</span> <span class="nav-text">练习三</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%89"><span class="nav-number">3.</span> <span class="nav-text">实验三</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="nav-number">3.1.</span> <span class="nav-text">实验内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%8E%9F%E7%90%86"><span class="nav-number">3.2.</span> <span class="nav-text">简单原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-Fault%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text">Page Fault异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.4.</span> <span class="nav-text">页面置换机制的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E6%9C%BA%E5%88%B6"><span class="nav-number">3.5.</span> <span class="nav-text">页面置换机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%8D%A2%E5%87%BA%E7%9A%84%E9%A1%B5"><span class="nav-number">3.5.1.</span> <span class="nav-text">可以被换出的页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%AD%98%E4%B8%AD%E7%9A%84%E9%A1%B5%E4%B8%8E%E7%A1%AC%E7%9B%98%E4%B8%8A%E7%9A%84%E6%89%87%E5%8C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.5.2.</span> <span class="nav-text">虚存中的页与硬盘上的扇区之间的映射关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%8D%A2%E5%85%A5%E6%8D%A2%E5%87%BA%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">3.5.3.</span> <span class="nav-text">执行换入换出的时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.5.4.</span> <span class="nav-text">页替换算法的数据结构设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E4%BB%A3%E7%A0%81-1"><span class="nav-number">3.6.</span> <span class="nav-text">读代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A01%EF%BC%9A%E7%BB%99%E6%9C%AA%E8%A2%AB%E6%98%A0%E5%B0%84%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8A%E7%89%A9%E7%90%86%E9%A1%B5"><span class="nav-number">3.7.</span> <span class="nav-text">练习1：给未被映射的地址映射上物理页</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A02%EF%BC%9A%E8%A1%A5%E5%85%85%E5%AE%8C%E6%88%90%E5%9F%BA%E4%BA%8EFIFO%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">3.8.</span> <span class="nav-text">练习2：补充完成基于FIFO的页面替换算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%9B%9B"><span class="nav-number">4.</span> <span class="nav-text">实验四</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84"><span class="nav-number">4.1.</span> <span class="nav-text">实验目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-1"><span class="nav-number">4.2.</span> <span class="nav-text">实验内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="nav-number">4.3.</span> <span class="nav-text">预备知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">4.3.1.</span> <span class="nav-text">内核线程管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.3.2.</span> <span class="nav-text">创建并执行内核线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%AC%AC-0-%E4%B8%AA%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B-idleproc"><span class="nav-number">4.3.3.</span> <span class="nav-text">创建第 0 个内核线程 idleproc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%AC%AC-1-%E4%B8%AA%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B-initproc"><span class="nav-number">4.3.4.</span> <span class="nav-text">创建第 1 个内核线程 initproc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B-initproc"><span class="nav-number">4.3.5.</span> <span class="nav-text">调度并执行内核线程 initproc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A01%EF%BC%9A%E5%88%86%E9%85%8D%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="nav-number">4.4.</span> <span class="nav-text">练习1：分配并初始化一个进程控制块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A02%EF%BC%9A%E4%B8%BA%E6%96%B0%E5%88%9B%E5%BB%BA%E7%9A%84%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%88%86%E9%85%8D%E8%B5%84%E6%BA%90"><span class="nav-number">4.5.</span> <span class="nav-text">练习2：为新创建的内核线程分配资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A03%EF%BC%9A%E9%98%85%E8%AF%BB%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%90%86%E8%A7%A3-proc-run-%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%83%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E3%80%82"><span class="nav-number">4.6.</span> <span class="nav-text">练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%BA%94"><span class="nav-number">5.</span> <span class="nav-text">实验五</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84-1"><span class="nav-number">5.1.</span> <span class="nav-text">实验目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-2"><span class="nav-number">5.2.</span> <span class="nav-text">实验内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-1"><span class="nav-number">5.3.</span> <span class="nav-text">预备知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">5.3.1.</span> <span class="nav-text">实验执行流程概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.3.2.</span> <span class="nav-text">创建用户进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%84%E6%88%90%E5%92%8C%E7%BC%96%E8%AF%91"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">应用程序的组成和编译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">5.3.2.2.</span> <span class="nav-text">用户进程的虚拟地址空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E6%89%A7%E8%A1%8C%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.3.2.3.</span> <span class="nav-text">创建并执行用户进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E5%92%8C%E7%AD%89%E5%BE%85%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.3.2.4.</span> <span class="nav-text">进程退出和等待进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.3.2.5.</span> <span class="nav-text">系统调用实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">5.3.2.5.1.</span> <span class="nav-text">初始化系统调用对应的中断描述符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E7%94%A8%E6%88%B7%E5%BA%93%E5%87%86%E5%A4%87"><span class="nav-number">5.3.2.5.2.</span> <span class="nav-text">建立系统调用的用户库准备</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8E%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">5.3.2.5.3.</span> <span class="nav-text">与用户进程相关的系统调用</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BBload-icode%E6%9C%89%E6%84%9F"><span class="nav-number">5.4.</span> <span class="nav-text">读load_icode有感</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A01%EF%BC%9A%E5%8A%A0%E8%BD%BD%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%B9%B6%E6%89%A7%E8%A1%8C"><span class="nav-number">5.5.</span> <span class="nav-text">练习1：加载应用程序并执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A02%EF%BC%9A%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%A4%8D%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E7%BB%99%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-number">5.6.</span> <span class="nav-text">练习2：父进程复制自己的内存空间给子进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A03%EF%BC%9A%E9%98%85%E8%AF%BB%E5%88%86%E6%9E%90%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%90%86%E8%A7%A3%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C-fork-exec-wait-exit-%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8D%E9%9C%80%E8%A6%81%E7%BC%96%E7%A0%81%EF%BC%89"><span class="nav-number">5.7.</span> <span class="nav-text">练习3：阅读分析源代码，理解进程执行 fork&#x2F;exec&#x2F;wait&#x2F;exit 的实现，以及系统调用的实现（不需要编码）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%85%AD"><span class="nav-number">6.</span> <span class="nav-text">实验六</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84-2"><span class="nav-number">6.1.</span> <span class="nav-text">实验目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-3"><span class="nav-number">6.2.</span> <span class="nav-text">实验内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%E5%92%8C%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.3.</span> <span class="nav-text">调度框架和调度算法设计与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">6.3.1.</span> <span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.3.2.</span> <span class="nav-text">进程调度实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%8A%A2%E5%8D%A0%E7%82%B9"><span class="nav-number">6.3.2.1.</span> <span class="nav-text">内核抢占点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">6.3.2.2.</span> <span class="nav-text">进程切换过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%E5%92%8C%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.3.</span> <span class="nav-text">调度框架和调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="nav-number">6.3.3.1.</span> <span class="nav-text">设计思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.3.3.2.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%82%B9%E7%9A%84%E7%9B%B8%E5%85%B3%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.3.3.</span> <span class="nav-text">调度点的相关关键函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RR%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.3.4.</span> <span class="nav-text">RR调度算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stride-Scheduling"><span class="nav-number">6.3.4.</span> <span class="nav-text">Stride Scheduling</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="nav-number">6.3.4.1.</span> <span class="nav-text">基本思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0-Stride-Scheduling"><span class="nav-number">6.3.4.2.</span> <span class="nav-text">使用优先队列实现 Stride Scheduling</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A01-%E4%BD%BF%E7%94%A8-Round-Robin-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8D%E9%9C%80%E8%A6%81%E7%BC%96%E7%A0%81%EF%BC%89"><span class="nav-number">6.4.</span> <span class="nav-text">练习1: 使用 Round Robin 调度算法（不需要编码）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A02%EF%BC%9A%E5%AE%9E%E7%8E%B0-Stride-Scheduling-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%88%E9%9C%80%E8%A6%81%E7%BC%96%E7%A0%81%EF%BC%89"><span class="nav-number">6.5.</span> <span class="nav-text">练习2：实现 Stride Scheduling 调度算法（需要编码）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E4%B8%83"><span class="nav-number">7.</span> <span class="nav-text">实验七</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84-3"><span class="nav-number">7.1.</span> <span class="nav-text">实验目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-4"><span class="nav-number">7.2.</span> <span class="nav-text">实验内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.3.</span> <span class="nav-text">同步互斥的设计与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0-1"><span class="nav-number">7.3.1.</span> <span class="nav-text">实验执行流程概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5%E7%9A%84%E5%BA%95%E5%B1%82%E6%94%AF%E6%92%91"><span class="nav-number">7.3.2.</span> <span class="nav-text">同步互斥的底层支撑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">7.3.2.1.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%8F%E8%94%BD%E4%B8%8E%E4%BD%BF%E8%83%BD%E4%B8%AD%E6%96%AD"><span class="nav-number">7.3.2.2.</span> <span class="nav-text">屏蔽与使能中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="nav-number">7.3.2.3.</span> <span class="nav-text">等待队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">7.3.3.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">7.3.4.</span> <span class="nav-text">管程和条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86%E5%9B%9E%E9%A1%BE"><span class="nav-number">7.3.4.1.</span> <span class="nav-text">原理回顾</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">7.3.4.2.</span> <span class="nav-text">关键数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84signal%E5%92%8Cwait%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">7.3.4.3.</span> <span class="nav-text">条件变量的signal和wait的设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%A5%E5%8F%A3%E5%87%BA%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="nav-number">7.3.4.4.</span> <span class="nav-text">管程中函数的入口出口设计</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A01%EF%BC%9A%E7%90%86%E8%A7%A3%E5%86%85%E6%A0%B8%E7%BA%A7%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%BA%A7%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">7.4.</span> <span class="nav-text">练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A02-%E5%AE%8C%E6%88%90%E5%86%85%E6%A0%B8%E7%BA%A7%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%BA%A7%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">7.5.</span> <span class="nav-text">练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%85%AB"><span class="nav-number">8.</span> <span class="nav-text">实验八</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84-4"><span class="nav-number">8.1.</span> <span class="nav-text">实验目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9-5"><span class="nav-number">8.2.</span> <span class="nav-text">实验内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.3.</span> <span class="nav-text">文件系统设计与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ucore-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="nav-number">8.3.1.</span> <span class="nav-text">ucore 文件系统总体介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ucore%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-number">8.3.1.1.</span> <span class="nav-text">ucore文件系统总体结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.3.2.</span> <span class="nav-text">通用文件系统访问接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E7%94%A8%E6%88%B7%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">8.3.2.1.</span> <span class="nav-text">文件和目录相关用户库函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E8%AE%BF%E9%97%AE%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">8.3.2.2.</span> <span class="nav-text">文件和目录访问相关系统调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%BD%E8%B1%A1%E5%B1%82-VFS"><span class="nav-number">8.3.3.</span> <span class="nav-text">文件系统抽象层 - VFS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#file-amp-dir%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.3.3.1.</span> <span class="nav-text">file &amp; dir接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inode-%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.3.3.2.</span> <span class="nav-text">inode 接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Simple-FS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">8.3.4.</span> <span class="nav-text">Simple FS 文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%83%E5%B1%80"><span class="nav-number">8.3.4.1.</span> <span class="nav-text">文件系统的布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="nav-number">8.3.4.2.</span> <span class="nav-text">索引节点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="nav-number">8.3.4.2.1.</span> <span class="nav-text">磁盘索引节点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="nav-number">8.3.4.3.</span> <span class="nav-text">内存中的索引节点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#inode%E7%9A%84%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-number">8.3.4.3.1.</span> <span class="nav-text">inode的目录操作函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%B1%82%E6%96%87%E4%BB%B6-IO-%E5%B1%82"><span class="nav-number">8.3.5.</span> <span class="nav-text">设备层文件 IO 层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">8.3.5.1.</span> <span class="nav-text">关键数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdout%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6"><span class="nav-number">8.3.5.2.</span> <span class="nav-text">stdout设备文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">8.3.5.2.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="nav-number">8.3.5.2.2.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.3.5.2.3.</span> <span class="nav-text">访问操作实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdin-%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6"><span class="nav-number">8.3.5.3.</span> <span class="nav-text">stdin 设备文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="nav-number">8.3.5.3.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">8.3.5.3.2.</span> <span class="nav-text">访问操作实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0-2"><span class="nav-number">8.3.6.</span> <span class="nav-text">实验执行流程概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.3.7.</span> <span class="nav-text">文件操作实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="nav-number">8.3.7.1.</span> <span class="nav-text">打开文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3%E5%B1%82%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">8.3.7.1.1.</span> <span class="nav-text">通用文件访问接口层的处理流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%BD%E8%B1%A1%E5%B1%82%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">8.3.7.1.2.</span> <span class="nav-text">文件系统抽象层的处理流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">8.3.7.1.3.</span> <span class="nav-text">SFS文件系统层的处理流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="nav-number">8.3.7.2.</span> <span class="nav-text">读文件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3%E5%B1%82%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-1"><span class="nav-number">8.3.7.2.1.</span> <span class="nav-text">通用文件访问接口层的处理流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8A%BD%E8%B1%A1%E5%B1%82%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-1"><span class="nav-number">8.3.7.2.2.</span> <span class="nav-text">文件系统抽象层的处理流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-1"><span class="nav-number">8.3.7.2.3.</span> <span class="nav-text">SFS文件系统层的处理流程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A01-%E5%AE%8C%E6%88%90%E8%AF%BB%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.3.8.</span> <span class="nav-text">练习1: 完成读文件操作的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A02-%E5%AE%8C%E6%88%90%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.3.9.</span> <span class="nav-text">练习2: 完成基于文件系统的执行程序机制的实现</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
