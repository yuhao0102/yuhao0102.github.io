<!DOCTYPE html>
<html lang="zn-ch">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="原文：https:&#x2F;&#x2F;www.dingmos.com&#x2F;index.php&#x2F;archives&#x2F;4&#x2F; lab1实验分为三个部分：  熟悉汇编语言、QEMU x86模拟器、PC上电启动过程 检查我们的6.828内核的boot loader程序，它位于lab的boot目录下。 深入研究6.828内核本身的初始模板，位于kernel目录下。  MIT6.828 实验环境配置使用命令行创建了一个目录~&#x2F;6.8">
<meta property="og:type" content="article">
<meta property="og:title" content="6.828 lab">
<meta property="og:url" content="http://yoursite.com/2021/11/16/6.828-lab/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="原文：https:&#x2F;&#x2F;www.dingmos.com&#x2F;index.php&#x2F;archives&#x2F;4&#x2F; lab1实验分为三个部分：  熟悉汇编语言、QEMU x86模拟器、PC上电启动过程 检查我们的6.828内核的boot loader程序，它位于lab的boot目录下。 深入研究6.828内核本身的初始模板，位于kernel目录下。  MIT6.828 实验环境配置使用命令行创建了一个目录~&#x2F;6.8">
<meta property="og:locale" content="zn_CH">
<meta property="og:image" content="http://yoursite.com/img/v2-f322c1238767ca4ae172b69548bd4b08_720w.png">
<meta property="og:image" content="http://yoursite.com/img/v2-e856328378b79f84cedece695adee101_b.gif">
<meta property="og:image" content="http://yoursite.com/img/v2-9a1b68fd5f1fbcf1e163f4811ed576ad_b.gif">
<meta property="og:image" content="http://yoursite.com/img/v2-480829b29d4400a2182dcb58f31603e7_b.gif">
<meta property="og:image" content="http://yoursite.com/img/v2-f00aab967b70bdb3afd7743d902dfbdf_b.gif">
<meta property="og:image" content="http://yoursite.com/img/v2-23f6d73c9f99f646458aac3b79e50e91_b.jpg">
<meta property="og:image" content="http://yoursite.com/img/v2-57da610073dc97659f6a52683438bdd7_b.webp">
<meta property="og:image" content="http://yoursite.com/img/v2-7645f7dc2a45edeef40540938cc55d8c_b.webp">
<meta property="og:image" content="http://yoursite.com/img/4482847-1941fd6b845db3b5.webp">
<meta property="og:image" content="http://yoursite.com/img/201906171933232.png">
<meta property="og:image" content="http://yoursite.com/img/20190617193346641.png">
<meta property="og:image" content="http://yoursite.com/img/20211121113100.png">
<meta property="og:image" content="http://yoursite.com/img/20211121113101.png">
<meta property="og:image" content="http://yoursite.com/img/20211124224000.png">
<meta property="og:image" content="http://yoursite.com/img/20211124224001.png">
<meta property="og:image" content="http://yoursite.com/img/20211128114300.png">
<meta property="og:image" content="http://yoursite.com/img/20211128114301.png">
<meta property="og:image" content="http://yoursite.com/img/20211128114305.png">
<meta property="og:image" content="http://yoursite.com/img/20211129222000.png">
<meta property="og:image" content="http://yoursite.com/img/1638326044.jpg">
<meta property="article:published_time" content="2021-11-16T06:08:00.000Z">
<meta property="article:modified_time" content="2022-12-26T07:33:06.000Z">
<meta property="article:author" content="Hao Yu">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/v2-f322c1238767ca4ae172b69548bd4b08_720w.png">

<link rel="canonical" href="http://yoursite.com/2021/11/16/6.828-lab/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zn-ch'
  };
</script>

  <title>6.828 lab | Hao Yu's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hao Yu's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The program monkey was eaten by the siege lion.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/resume.pdf" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">128</span></a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yuhao0102" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zn-ch">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/16/6.828-lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content="Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          6.828 lab
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-16 14:08:00" itemprop="dateCreated datePublished" datetime="2021-11-16T14:08:00+08:00">2021-11-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-26 15:33:06" itemprop="dateModified" datetime="2022-12-26T15:33:06+08:00">2022-12-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>原文：<a href="https://www.dingmos.com/index.php/archives/4/">https://www.dingmos.com/index.php/archives/4/</a></p>
<h1 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h1><p>实验分为三个部分：</p>
<ul>
<li>熟悉汇编语言、QEMU x86模拟器、PC上电启动过程</li>
<li>检查我们的6.828内核的boot loader程序，它位于lab的boot目录下。</li>
<li>深入研究6.828内核本身的初始模板，位于kernel目录下。</li>
</ul>
<h2 id="MIT6-828-实验环境配置"><a href="#MIT6-828-实验环境配置" class="headerlink" title="MIT6.828 实验环境配置"></a>MIT6.828 实验环境配置</h2><p>使用命令行创建了一个目录<code>~/6.828</code>，在该目录下初始化一个git仓库<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/6.828$ git init</span><br></pre></td></tr></table></figure></p>
<p>把JOS系统源码clone到本地<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/6.828$ git clone https://pdos.csail.mit.edu/6.828/2017/jos.git lab</span><br></pre></td></tr></table></figure></p>
<p>安装QEMU这个仿真器需要先安装包。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libsdl1.2-dev</span><br><span class="line">sudo apt-get install libglib2.0-dev</span><br><span class="line">sudo apt-get install libz-dev</span><br><span class="line">sudo apt-get install libpixman-1-dev</span><br><span class="line">sudo apt-get install libtool*</span><br></pre></td></tr></table></figure></p>
<p>打开qemu所在目录，进行configuration<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --disable-kvm --disable-werror --prefix=$HMOE --target-list=&quot;i386-softmmu x86_64-softmmu&quot;</span><br></pre></td></tr></table></figure></p>
<p>最后进行安装。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>安装包时频繁出现依赖问题，把apt-get换成了aptitude无用；最后是换了源解决的，可能是因为在安装中断后更换了源，换回去就好了。</p>
<p>之后又报了Werror。在配置的时候处理werror解决。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --disable-werror --prefix==/usr/local --target-list=&quot;i386-softmmu x86_64-softmmu&quot;</span><br></pre></td></tr></table></figure></p>
<p>QUMU安装好之后，make lab下的代码报错：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lib/printfmt.c:41: undefined reference to `__udivdi3&#x27;</span><br><span class="line">lib/printfmt.c:49: undefined reference to `__umoddi3&#x27;</span><br></pre></td></tr></table></figure></p>
<p>ARM是精简指令集，对求余和除法操作基本上不支持。linux内核源码<code>linux/arch/arm/lib/lib1funcs.S</code>实现支持除法、求模操作等操作的库函数。本来应该多研究下，但是发现有现成的解决方案，我开发环境是64gcc，但需要的是32位，所以安装32位gcc解决问题。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-multilib</span><br></pre></td></tr></table></figure></p>
<p>再次进行make，成功！<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~/6.828/lab$ sudo make</span><br><span class="line">+ ld obj/kern/kernel</span><br><span class="line">+ as boot/boot.S</span><br><span class="line">+ cc -Os boot/main.c</span><br><span class="line">+ ld boot/boot</span><br><span class="line">boot block is 390 bytes (max 510)</span><br><span class="line">+ mk obj/kern/kernel.img</span><br></pre></td></tr></table></figure></p>
<p>之后需要<code>make qemu</code>，又报错了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh: 1: /home/yuhao/qemu/: Permission denied</span><br><span class="line">/home/yuhao/qemu/ -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000</span><br><span class="line">make: execvp: /home/yuhao/qemu/: Permission denied</span><br><span class="line">GNUmakefile:156: recipe for target &#x27;qemu&#x27; failed</span><br><span class="line">make: *** [qemu] Error 127</span><br></pre></td></tr></table></figure></p>
<p>应该是qemu的可执行文件配置错误，改一下<code>env.mk</code>。在执行启动简单映像的命令后，又有错误：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GLib-WARNING **：21：58：30.131：gmem.c：489：不支持自定义内存分配vtable</span><br><span class="line">(qemu-system-x86_64：23983)：Gtk-WARNING **：21：58：30.175：无法打开显示：</span><br></pre></td></tr></table></figure></p>
<p>出现此问题是因为glib2错误（<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1594304）。">https://bugzilla.redhat.com/show_bug.cgi?id=1594304）。</a></p>
<p>此问题的另一方面是Red Hat和CentOS存储库包含过时的QEMU版本（最近是4）。</p>
<ol>
<li>用qemu-kvm而不是qemu-system-x86_64：<a href="https://www.tecmint.com/install-manage-virtual-machines-in-centos/">https://www.tecmint.com/install-manage-virtual-machines-in-centos/</a></li>
<li>从fedora仓库重新安装/更新所有QEMU软件包（<a href="https://copr-be.cloud.fedoraproject.org/results/fcomida/qemu-4/fedora-30-x86_64/00910942-qemu/）`rpm">https://copr-be.cloud.fedoraproject.org/results/fcomida/qemu-4/fedora-30-x86_64/00910942-qemu/）`rpm</a> -i /path/to/file/file_name.rpm`</li>
<li>自己编译QEMU（<a href="https://www.qemu.org/download/#source）。">https://www.qemu.org/download/#source）。</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.qemu.org/qemu-4.1.0-rc2.tar.xz</span><br><span class="line">tar xvJf qemu-4.1.0-rc2.tar.xz</span><br><span class="line">cd qemu-4.1.0-rc2</span><br><span class="line">sudo ./configure --disable-kvm --disable-werror --prefix=$HMOE --target-list=&quot;i386-softmmu x86_64-softmmu&quot;</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">OR</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>运行成功的话终端就会打印出以下字符：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/home/yuhao/6.828/qemu/i386-softmmu/qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log</span><br><span class="line">VNC server running on 127.0.0.1:5900</span><br><span class="line">6828 decimal is XXX octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">leaving test_backtrace 2</span><br><span class="line">leaving test_backtrace 3</span><br><span class="line">leaving test_backtrace 4</span><br><span class="line">leaving test_backtrace 5</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br></pre></td></tr></table></figure></p>
<p>键入kerninfo，值得注意的是，此内核监视器“直接”在模拟PC的“原始（虚拟）硬件”上运行。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">K&gt; kerninfo</span><br><span class="line">Special kernel symbols:</span><br><span class="line">  _start                  0010000c (phys)</span><br><span class="line">  entry  f010000c (virt)  0010000c (phys)</span><br><span class="line">  etext  f0101acd (virt)  00101acd (phys)</span><br><span class="line">  edata  f0113060 (virt)  00113060 (phys)</span><br><span class="line">  end    f01136a0 (virt)  001136a0 (phys)</span><br><span class="line">Kernel executable memory footprint: 78KB</span><br></pre></td></tr></table></figure></p>
<p>细节记录</p>
<ul>
<li>PC中BIOS大小为64k, 物理地址范围0x000f0000-0x000fffff</li>
<li>PC 开机首先0xfffff0处执行 jmp [0xf000,0xe05b] 指令。在gdb中使用si(Step Instruction)进行跟踪。</li>
</ul>
<p>使用gdb进行调试<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ make gdb</span><br><span class="line">GNU gdb (GDB) 6.8-debian</span><br><span class="line">Copyright (C) 2008 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;i486-linux-gnu&quot;.</span><br><span class="line">+ target remote localhost:26000</span><br><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0] 0xffff0:	ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line"></span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e05b]    0xfe05b:    cmpw   $0xffc8,%cs:(%esi)   # 比较大小，改变PSW</span><br><span class="line">0x0000e05b in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e062]    0xfe062:    jne    0xd241d416           # 不相等则跳转</span><br><span class="line">0x0000e062 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e066]    0xfe066:    xor    %edx,%edx            # 清零edx</span><br><span class="line">0x0000e066 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e068]    0xfe068:    mov    %edx,%ss</span><br><span class="line">0x0000e068 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">[f000:e06a]    0xfe06a:    mov    $0x7000,%sp</span><br><span class="line">0x0000e06a in ?? ()</span><br></pre></td></tr></table></figure></p>
<p>BIOS运行过程中，它设定了中断描述符表，对VGA显示器等设备进行了初始化。在初始化完PCI总线和所有BIOS负责的重要设备后，它就开始搜索软盘、硬盘、或是CD-ROM等可启动的设备。最终，当它找到可引导磁盘时，BIOS从磁盘读取引导加载程序并将控制权转移给它。</p>
<h2 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><p>机器的物理地址空间有如下布局：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure></p>
<p>对于6.828，我们将使用传统的硬盘启动机制，这意味着我们的boot loader必须满足于512字节。</p>
<p>boot loader由一个汇编语言源文件<code>boot/boot.S</code>和一个C源文件<code>boot/main.c</code>组成。</p>
<h3 id="boot-S"><a href="#boot-S" class="headerlink" title="boot.S"></a>boot.S</h3><p>BIOS将<code>boot.S</code>这段代码从硬盘的第一个扇区load到物理地址为0x7c00的位置，同时CPU工作在real mode。</p>
<p><code>boot.S</code>需要将CPU的工作模式从实模式转换到32位的保护模式， 并且 jump 到 C 语言程序。</p>
<p>源码阅读，知识点：</p>
<ul>
<li>cli (clear interrupt)</li>
<li>cld (clear direction flag)</li>
</ul>
<blockquote>
<p>df: 方向标志位。在串处理指令中，控制每次操作后si，di的增减。（df=0，每次操作后si、di递增；df=1，每次操作后si、di递减）。</p>
</blockquote>
<p>为了向前兼容早期的PC机，A20地址线接地，所以当地址大于1M范围时，会默认回滚到0处。所以在转向32位模式之前，需要使能A20。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.1</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line">  outb    %al,$0x60</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>test 逻辑运算指令，对两个操作数进行AND操作，并且修改PSW, test 与 AND 指令唯一不同的地方是，TEST 指令不修改目标操作数。</p>
<ul>
<li><code>test al, 00001001b ;</code>测试位 0 和位 3</li>
</ul>
</li>
<li><p><code>lgdt gdtdesc</code>, 加载全局描述符表，暂时不管全局描述表是如何生成的。</p>
</li>
<li><code>cr0</code>, control register,控制寄存器。<ul>
<li>CR0中包含了6个预定义标志，0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line"># and segment translation that makes virtual addresses</span><br><span class="line"># identical to their physical addresses, so that the</span><br><span class="line"># effective memory map does not change during the switch.</span><br><span class="line">lgdt    gdtdesc</span><br><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $CR0_PE_ON, %eax</span><br><span class="line">movl    %eax, %cr0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="调试boot-S"><a href="#调试boot-S" class="headerlink" title="调试boot.S"></a>调试boot.S</h3><p>设置一个断点在地址0x7c00处，这是boot sector被加载的位置。然后让程序继续运行直到这个断点。跟踪/boot/boot.S文件的每一条指令，同时使用boot.S文件和系统为你反汇编出来的文件obj/boot/boot.asm。你也可以使用GDB的x/i指令来获取去任意一个机器指令的反汇编指令，把源文件boot.S文件和boot.asm文件以及在GDB反汇编出来的指令进行比较。</p>
<p>追踪到bootmain函数中，而且还要具体追踪到<code>readsect()</code>子函数里面。找出和<code>readsect()</code>c语言程序的每一条语句所对应的汇编指令，回到<code>bootmain()</code>，然后找出把内核文件从磁盘读取到内存的那个for循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。</p>
<p>下面我们将分别分析一下这道练习中所涉及到的两个重要文件，它们一起组成了boot loader。分别是<code>/boot/boot.S</code>和<code>/boot/main.c</code>文件。其中前者是一个汇编文件，后者是一个C语言文件。当BIOS运行完成之后，CPU的控制权就会转移到<code>boot.S</code>文件上。所以我们首先看一下<code>boot.S</code>文件。</p>
<p>　　/boot/boot.S：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  .code16                # Assemble for 16-bit mode</span><br><span class="line">  cli                    # Disable interrupts</span><br></pre></td></tr></table></figure></p>
<p>这几条指令就是boot.S最开始的几句，其中cli是boot.S，也是boot loader的第一条指令。这条指令用于把所有的中断都关闭。因为在BIOS运行期间有可能打开了中断。此时CPU工作在实模式下。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cld                         # String operations increment</span><br></pre></td></tr></table></figure><br>这条指令用于指定之后发生的串处理操作的指针移动方向。在这里现在对它大致了解就够了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">xorw    %ax,%ax             # Segment number zero</span><br><span class="line">movw    %ax,%ds             # -&gt; Data Segment</span><br><span class="line">movw    %ax,%es             # -&gt; Extra Segment</span><br><span class="line">movw    %ax,%ss             # -&gt; Stack Segment</span><br></pre></td></tr></table></figure>
<p>这几条命令主要是在把三个段寄存器，ds，es，ss全部清零，因为经历了BIOS，操作系统不能保证这三个寄存器中存放的是什么数。所以这也是为后面进入保护模式做准备。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> # Enable A20:</span><br><span class="line"> #   For backwards compatibility with the earliest PCs, physical</span><br><span class="line"> #   address line 20 is tied low, so that addresses higher than</span><br><span class="line"> #   1MB wrap around to zero by default.  This code undoes this.</span><br><span class="line">seta20.1:</span><br><span class="line"> inb     $0x64,%al               # Wait for not busy</span><br><span class="line"> testb   $0x2,%al</span><br><span class="line"> jnz     seta20.1</span><br><span class="line"></span><br><span class="line"> movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line"> outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line"> inb     $0x64,%al               # Wait for not busy</span><br><span class="line"> testb   $0x2,%al</span><br><span class="line"> jnz     seta20.2</span><br><span class="line"></span><br><span class="line"> movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line"> outb    %al,$0x60</span><br></pre></td></tr></table></figure>
<p>这部分指令就是在准备把CPU的工作模式从实模式转换为保护模式。我们可以看到其中的指令包括inb，outb这样的IO端口命令。所以这些指令都是在对外部设备进行操作。0x64端口属于键盘控制器804x，名称是控制器读取状态寄存器。</p>
<p>不断的检测bit1。bit1的值代表输入缓冲区是否满了，也就是说CPU传送给控制器的数据，控制器是否已经取走了，如果CPU想向控制器传送新的数据的话，必须先保证这一位为0。所以这三条指令会一直等待这一位变为0，才能继续向后运行。</p>
<p>当0x64端口准备好读入数据后，现在就可以写入数据了，所以19~20这两条指令是把0xd1这条数据写入到0x64端口中。当向0x64端口写入数据时，则代表向键盘控制器804x发送指令。这个指令将会被送给0x60端口。</p>
<p>D1指令代表下一次写入0x60端口的数据将被写入给804x控制器的输出端口。可以理解为下一个写入0x60端口的数据是一个控制指令。</p>
<p>然后21~24号指令又开始再次等待，等待刚刚写入的指令D1，是否已经被读取了。</p>
<p>如果指令被读取了，25~26号指令会向控制器输入新的指令，0xdf。这个指令的含义是，使能A20线，代表可以进入保护模式了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">27   # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">28   # and segment translation that makes virtual addresses </span><br><span class="line">29   # identical to their physical addresses, so that the </span><br><span class="line">30   # effective memory map does not change during the switch.</span><br><span class="line">31   lgdt    gdtdesc</span><br><span class="line">32   movl    %cr0, %eax</span><br><span class="line">33   orl     $CR0_PE_ON, %eax</span><br><span class="line">34   movl    %eax, %cr0</span><br></pre></td></tr></table></figure>
<p>首先31号指令<code>lgdt gdtdesc</code>，是把gdtdesc这个标识符的值送入全局映射描述符表寄存器GDTR中。这个GDT表是处理器工作于保护模式下一个非常重要的表。这条指令的功能就是把关于GDT表的一些重要信息存放到CPU的GDTR寄存器中，其中包括GDT表的内存起始地址，以及GDT表的长度。这个寄存器由48位组成，其中低16位表示该表长度，高32位表该表在内存中的起始地址。所以gdtdesc是一个标识符，标识着一个内存地址。从这个内存地址开始之后的6个字节中存放着GDT表的长度和起始地址。我们可以在这个文件的末尾看到gdtdesc，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1 # Bootstrap GDT</span><br><span class="line"> 2 .p2align 2                               # force 4 byte alignment</span><br><span class="line"> 3 gdt:</span><br><span class="line"> 4   SEG_NULL                               # null seg</span><br><span class="line"> 5   SEG(STA_X|STA_R, 0x0, 0xffffffff)      # code seg</span><br><span class="line"> 6   SEG(STA_W, 0x0, 0xffffffff)            # data seg</span><br><span class="line"> 7 </span><br><span class="line"> 8 gdtdesc:</span><br><span class="line"> 9   .word   0x17                           # sizeof(gdt) - 1</span><br><span class="line">10   .long   gdt                            # address gdt</span><br></pre></td></tr></table></figure>
<p>其中第3行的gdt是一个标识符，标识从这里开始就是GDT表了。可见这个GDT表中包括三个表项(4,5,6行)，分别代表三个段，null seg，code seg，data seg。由于xv6其实并没有使用分段机制，也就是说数据和代码都是写在一起的，所以数据段和代码段的起始地址都是0x0，大小都是0xffffffff=4GB。</p>
<p>在第4~6行是调用SEG()子程序来构造GDT表项的。这个子函数定义在mmu.h中，形式如下：　　<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　<span class="meta">#<span class="keyword">define</span> SEG(type,base,lim)                    \</span></span><br><span class="line"><span class="meta">.word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);    \</span></span><br><span class="line"><span class="meta">.byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),        \</span></span><br><span class="line"><span class="meta">(0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</span></span><br></pre></td></tr></table></figure></p>
<p>可见函数需要3个参数，一是type即这个段的访问权限，二是base，这个段的起始地址，三是lim，即这个段的大小界限。gdt表中的每一个表项的结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gdt_entry_struct</span> &#123;</span></span><br><span class="line">    limit_low:    resb <span class="number">2</span></span><br><span class="line">    base_low:     resb <span class="number">2</span></span><br><span class="line">    base_middle : resb <span class="number">1</span></span><br><span class="line">    access:       resb <span class="number">1</span></span><br><span class="line">    granularity:  resb <span class="number">1</span></span><br><span class="line">    base_high:    resb <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每个表项一共8字节，其中<code>limit_low</code>就是limit的低16位。<code>base_low</code>就是base的低16位，依次类推。</p>
<p>然后在<code>gdtdesc</code>处就要存放这个GDT表的信息了，其中0x17是这个表的大小-1 = 0x17 = 23，至于为什么不直接存表的大小24，根据查询是官方规定的。紧接着就是这个表的起始地址gdt。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">27   # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">28   # and segment translation that makes virtual addresses </span><br><span class="line">29   # identical to their physical addresses, so that the </span><br><span class="line">30   # effective memory map does not change during the switch.</span><br><span class="line">31   lgdt    gdtdesc</span><br><span class="line">32   movl    %cr0, %eax</span><br><span class="line">33   orl     $CR0_PE_ON, %eax</span><br><span class="line">34   movl    %eax, %cr0</span><br></pre></td></tr></table></figure>
<p>再回到刚才那里，当加载完GDT表的信息到GDTR寄存器之后。紧跟着3个操作，32~34指令。 这几步操作明显是在修改CR0寄存器的内容。CR0寄存器还有CR1~CR3寄存器都是80x86的控制寄存器。其中$CR0_PE的值定义于”mmu.h”文件中，为0x00000001。可见上面的操作是把CR0寄存器的bit0置1，CR0寄存器的bit0是保护模式启动位，把这一位值1代表保护模式启动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35  ljmp    $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure>
<p>这只是一个简单的跳转指令，这条指令的目的在于把当前的运行模式切换成32位地址模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protcseg:</span><br><span class="line">  # Set up the protected-mode data segment registers</span><br><span class="line">36  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector</span><br><span class="line">37  movw    %ax, %ds                # -&gt; DS: Data Segment</span><br><span class="line">38  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class="line">39  movw    %ax, %fs                # -&gt; FS</span><br><span class="line">40  movw    %ax, %gs                # -&gt; GS</span><br><span class="line">41  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br></pre></td></tr></table></figure>
<p>修改这些寄存器的值。这些寄存器都是段寄存器，如果刚刚加载完GDTR寄存器我们必须要重新加载所有的段寄存器的值，而其中CS段寄存器必须通过长跳转指令，即23号指令来进行加载。这样才能是GDTR的值生效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Set up the stack pointer and call into C.</span><br><span class="line">42  movl    $start, %esp</span><br><span class="line">43  call bootmain</span><br></pre></td></tr></table></figure>
<p>接下来的指令就是要设置当前的esp寄存器的值，然后准备正式跳转到main.c文件中的bootmain函数处。我们接下来分析一下这个函数的每一条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// read 1st page off disk</span><br><span class="line">1 readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);</span><br></pre></td></tr></table></figure>
<p>这里面调用了一个函数<code>readseg</code>，这个函数在<code>bootmain</code>之后被定义了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void readseg(uchar *pa, uint count, uint offset);</span><br></pre></td></tr></table></figure><br>它的功能从注释上来理解应该是，把距离内核起始地址offset个偏移量存储单元作为起始，将它和它之后的count字节的数据读出送入以pa为起始地址的内存物理地址处。</p>
<p>所以这条指令是把内核的第一个页(4MB = 4096 = SECTSIZE<em>8 = 512</em>8)的内容读取的内存地址ELFHDR(0x10000)处。其实完成这些后相当于把操作系统映像文件的elf头部读取出来放入内存中。</p>
<p>读取完这个内核的elf头部信息后，需要对这个elf头部信息进行验证，并且也需要通过它获取一些重要信息。</p>
<blockquote>
<p>elf文件：elf是一种文件格式，主要被用来把程序存放到磁盘上。是在程序被编译和链接后被创建出来的。一个elf文件包括多个段。对于一个可执行程序，通常包含存放代码的文本段(text section)，存放全局变量的data段，存放字符串常量的rodata段。elf文件的头部就是用来描述这个elf文件如何在存储器中存储。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line"><span class="number">3</span>        <span class="keyword">goto</span> bad;</span><br></pre></td></tr></table></figure>
<p>elf头部信息的magic字段是整个头部信息的开端。并且如果这个文件是格式是ELF格式的话，文件的elf-&gt;magic域应该是=ELF_MAGIC的，所以这条语句就是判断这个输入文件是否是合法的elf可执行文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="type">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br></pre></td></tr></table></figure>
<p>我们知道头部中一定包含Program Header Table。这个表格存放着程序中所有段的信息。通过这个表我们才能找到要执行的代码段，数据段等等。所以我们要先获得这个表。</p>
<p>这条指令就可以完成这一点，首先elf是表头起址，而phoff字段代表Program Header Table距离表头的偏移量。所以ph可以被指定为Program Header Table表头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> eph = ph + ELFHDR-&gt;e_phnum;</span><br></pre></td></tr></table></figure>
<p>由于phnum中存放的是Program Header Table表中表项的个数，即段的个数。所以这步操作是吧eph指向该表末尾。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">    <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">    <span class="comment">// as the physical address)</span></span><br><span class="line"><span class="number">7</span>    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></table></figure>
<p>这个for循环就是在加载所有的段到内存中。ph-&gt;paddr根据参考文献中的说法指的是这个段在内存中的物理地址。ph-&gt;off字段指的是这一段的开头相对于这个elf文件的开头的偏移量。ph-&gt;filesz字段指的是这个段在elf文件中的大小。ph-&gt;memsz则指的是这个段被实际装入内存后的大小。通常来说memsz一定大于等于filesz，因为段在文件中时许多未定义的变量并没有分配空间给它们。</p>
<p>所以这个循环就是在把操作系统内核的各个段从外存读入内存中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 ((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br></pre></td></tr></table></figure>
<p>e_entry字段指向的是这个文件的执行入口地址。所以这里相当于开始运行这个文件。也就是内核文件。 自此就把控制权从boot loader转交给了操作系统的内核。</p>
<p>分析完了程序后，来完成Exercise要求我们做的事情：</p>
<p>在一个terminal中cd到lab目录下，执行<code>make qemu-gdb</code>。再开一个 terminal执行<code>make gdb</code>。</p>
<p>因为BIOS会把boot loader加载到0x7c00的位置，因此设置断点b *0x7c00。再执行c，会看到QUMU终端上显示Booting from hard disk。</p>
<p>执行x/30i 0x7c00就能看到与boot.S中类似的汇编代码了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x7c00</span><br><span class="line">Breakpoint 1 at 0x7c00</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[   0:7c00] =&gt; 0x7c00:  cli</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00007c00 in ?? ()</span><br><span class="line">(gdb) x/30i 0x7c00</span><br><span class="line">=&gt; 0x7c00:      cli</span><br><span class="line">   0x7c01:      cld</span><br><span class="line">   0x7c02:      xor    %eax,%eax</span><br><span class="line">   0x7c04:      mov    %eax,%ds</span><br><span class="line">   0x7c06:      mov    %eax,%es</span><br><span class="line">   0x7c08:      mov    %eax,%ss</span><br><span class="line">   0x7c0a:      in     $0x64,%al</span><br><span class="line">   0x7c0c:      test   $0x2,%al</span><br><span class="line">   0x7c0e:      jne    0x7c0a</span><br><span class="line">   0x7c10:      mov    $0xd1,%al</span><br><span class="line">   0x7c12:      out    %al,$0x64</span><br><span class="line">   0x7c14:      in     $0x64,%al</span><br><span class="line">   0x7c16:      test   $0x2,%al</span><br><span class="line">   0x7c18:      jne    0x7c14</span><br><span class="line">   0x7c1a:      mov    $0xdf,%al</span><br><span class="line">   0x7c1c:      out    %al,$0x60</span><br><span class="line">   0x7c1e:      lgdtl  (%esi)</span><br><span class="line">   0x7c21:      fs jl  0x7c33</span><br><span class="line">   0x7c24:      and    %al,%al</span><br><span class="line">   0x7c26:      or     $0x1,%ax</span><br><span class="line">   0x7c2a:      mov    %eax,%cr0</span><br><span class="line">   0x7c2d:      ljmp   $0xb866,$0x87c32</span><br><span class="line">   0x7c34:      adc    %al,(%eax)</span><br></pre></td></tr></table></figure></p>
<p>这条gdb指令是把存放在0x7c00以及之后30字节的内存里面的指令反汇编出来，我们可以拿它直接和<code>boot.S</code>以及在<code>obj/boot/boot.asm</code>进行比较，这三者在指令上没有区别，只不过在源代码中，我们指定了很多标识符比如set20.1，.start，这些标识符在被汇编成机器代码后都会被转换成真实物理地址。比如set20.1就被转换为0x7c0a，那么在<code>obj/boot/boot.asm</code>中还把这种对应关系列出来了，但是在真实执行时，即第一种情况中，就看不到set20.1标识符了，完全是真实物理地址。</p>
<h2 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h2><p>接下来我们分析boot loader的C语言部分。</p>
<p>首先熟悉以下C指针。 编译运行pointer.c结果。 可以发现 a[],b的地址相差很多，因为两者所存放的段不同。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: a = <span class="number">0xbfa8bdbc</span>, b = <span class="number">0x9e3a160</span>, c = (nil)</span><br><span class="line"><span class="number">2</span>: a[<span class="number">0</span>] = <span class="number">200</span>, a[<span class="number">1</span>] = <span class="number">101</span>, a[<span class="number">2</span>] = <span class="number">102</span>, a[<span class="number">3</span>] = <span class="number">103</span></span><br><span class="line"><span class="number">3</span>: a[<span class="number">0</span>] = <span class="number">200</span>, a[<span class="number">1</span>] = <span class="number">300</span>, a[<span class="number">2</span>] = <span class="number">301</span>, a[<span class="number">3</span>] = <span class="number">302</span></span><br><span class="line"><span class="number">4</span>: a[<span class="number">0</span>] = <span class="number">200</span>, a[<span class="number">1</span>] = <span class="number">400</span>, a[<span class="number">2</span>] = <span class="number">301</span>, a[<span class="number">3</span>] = <span class="number">302</span></span><br><span class="line"><span class="number">5</span>: a[<span class="number">0</span>] = <span class="number">200</span>, a[<span class="number">1</span>] = <span class="number">128144</span>, a[<span class="number">2</span>] = <span class="number">256</span>, a[<span class="number">3</span>] = <span class="number">302</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b = a + 4</span></span><br><span class="line"><span class="number">6</span>: a = <span class="number">0xbfa8bdbc</span>, b = <span class="number">0xbfa8bdc0</span>, c = <span class="number">0xbfa8bdbd</span></span><br></pre></td></tr></table></figure></p>
<p>ELF格式非常强大和复杂，但大多数复杂的部分都是为了支持共享库的动态加载，在6.828课程中并不会用到。在本课程中，我们可以把ELF可执行文件简单地看为带有加载信息的标头，后跟几个程序部分，每个程序部分都是一个连续的代码块或数据，其将被加载到指定内存中。</p>
<p>我们所需要关心的Program Section是：</p>
<ul>
<li>.text : 可执行指令</li>
<li>.rodata: 只读数据段,例如字符串常量。（但是，我们不会费心设置硬件来禁止写入。）</li>
<li>.data : 存放已经初始化的数据</li>
<li>.bss ： 存放未初始化的变量， 但是在ELF中只需要记录.bss的起始地址和长度。Loader and program必须自己将.bss段清零。</li>
</ul>
<p>每个程序头的<code>ph-&gt; p_pa</code>字段包含段的目标物理地址（在这种情况下，它实际上是一个物理地址，尽管ELF规范对该字段的实际含义含糊不清）</p>
<p>BIOS会将引导扇区的内容加载到 0x7c00 的位置，引导程序也就从0x7C00的位置开始执行。我们通过-Ttext 0x7C00将链接地址传递给<code>boot / Makefrag</code>中的链接器，因此链接器将在生成的代码中生成正确的内存地址。</p>
<p>除了部分信息之外，ELF头中还有一个对我们很重要的字段，名为<code>e_entry</code>。该字段保存程序中入口点的链接地址：程序应该开始执行的代码段的存储地址。 在反汇编代码中，可以看到最后call 了 0x10018地址。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((void (*)(void)) (ELFHDR-&gt;e_entry))();</span><br><span class="line">    7d6b:    ff 15 18 00 01 00        call   *0x10018</span><br></pre></td></tr></table></figure></p>
<p>在0x7d6b 打断点后，c 再si一次，发现实际跳转地址位0x10000c<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x7d6b</span><br><span class="line">Breakpoint 3 at 0x7d6b</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">=&gt; 0x7d6b:    call   *0x10018</span><br><span class="line"></span><br><span class="line">Breakpoint 3, 0x00007d6b in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x10000c:    movw   $0x1234,0x472</span><br></pre></td></tr></table></figure></p>
<p>与实际执行objdump -f kernel的 结果一致。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">../kern/kernel:     file format elf32-i386</span><br><span class="line">architecture: i386, flags 0x00000112:</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">start address 0x0010000c</span><br></pre></td></tr></table></figure></p>
<h2 id="Part3：The-Kernel"><a href="#Part3：The-Kernel" class="headerlink" title="Part3：The Kernel"></a>Part3：The Kernel</h2><p>我们现在将开始更详细地研究JOS内核。（最后你会写一些代码！）。与引导加载程序一样，内核从一些汇编语言代码开始，这些代码设置可以使C语言代码正确执行。</p>
<h3 id="使用虚拟内存来解决位置依赖问题"><a href="#使用虚拟内存来解决位置依赖问题" class="headerlink" title="使用虚拟内存来解决位置依赖问题"></a>使用虚拟内存来解决位置依赖问题</h3><p>操作系统内核通常被链接到非常高的虚拟地址（例如0xf0100000）下运行，以便留下处理器虚拟地址空间的低地址部分供用户程序使用。 在下一个lab中，这种安排的原因将变得更加清晰。</p>
<p>许多机器在地址范围无法达到0xf0100000，因此我们无法指望能够在那里存储内核。相反，我们将使用处理器的内存管理硬件将虚拟地址0xf0100000（内核代码期望运行的链接地址）映射到物理地址0x00100000（引导加载程序将内核加载到物理内存中）。尽管内核的虚拟地址足够高，可以为用户进程留下大量的内存空间，在物理地址中内核将会被加载到1MB的位置，仅次于BIOS。</p>
<p>现在，我们只需映射前4MB的物理内存，这足以让我们启动并运行。 我们使用kern/entrypgdir.c中手写的，静态初始化的页面目录和页表来完成此操作。 现在，你不必了解其工作原理的细节，只需注意其实现的效果。</p>
<p>实现虚拟地址，有一个很重要的寄存器CR0-PG：</p>
<blockquote>
<p>PG：CR0的位31是分页（Paging）标志。当设置该位时即开启了分页机制；当复位时则禁止分页机制，此时所有线性地址等同于物理地址。在开启这个标志之前必须已经或者同时开启PE标志。即若要启用分页机制，那么PE和PG标志都要置位。</p>
</blockquote>
<h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><ol>
<li>使用QEMU和GDB跟踪到JOS内核并停在<code>movl %eax，%cr0</code>。 检查内存为0x00100000和0xf0100000。 现在，使用stepi GDB命令单步执行该指令。 再次检查内存为0x00100000和0xf0100000。 确保你了解刚刚发生的事情。</li>
</ol>
<p>注意实验文档上所说的，硬件实现的页表转换机制将0xf0000000等那些f打头的16进制地址转到0x00100000。GDB调试设置断点时，设置的是物理地址，不是逻辑地址，所以断点设置为kernel的入口地址。</p>
<p>b *0x10000c<br>1<br>不知为何，断点设置到0x100000不行，可能是因为代码段中那一段标号和段标识我不认识。</p>
<p>0x100000处的反汇编代码如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.globl entry</span><br><span class="line">entry:</span><br><span class="line">	movw	$0x1234,0x472			# warm boot</span><br><span class="line">f0100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh</span><br><span class="line">f0100006:	00 00                	add    %al,(%eax)</span><br><span class="line">f0100008:	fe 4f 52             	decb   0x52(%edi)</span><br><span class="line">f010000b:	e4                   	.byte 0xe4</span><br><span class="line"></span><br><span class="line">f010000c &lt;entry&gt;:</span><br><span class="line">f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472</span><br></pre></td></tr></table></figure></p>
<p>执行过程如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">The target architecture is assumed to be i386</span><br><span class="line">=&gt; 0x10000c:    movw   $0x1234,0x472</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0010000c in ?? ()</span><br><span class="line">(gdb) s</span><br><span class="line">Cannot find bounds of current function</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100015:    mov    $0x112000,%eax</span><br><span class="line">0x00100015 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x10001a:    mov    %eax,%cr3</span><br><span class="line">0x0010001a in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x10001d:    mov    %cr0,%eax</span><br><span class="line">0x0010001d in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100020:    or     $0x80010001,%eax</span><br><span class="line">0x00100020 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100025:    mov    %eax,%cr0</span><br><span class="line">0x00100025 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100028:    mov    $0xf010002f,%eax</span><br><span class="line">0x00100028 in ?? ()</span><br><span class="line">(gdb)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>当执行到<code>movl %eax,%cr0</code>时，停下，此时查看两处内存结果如下。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x100025:    mov    %eax,%cr0</span><br><span class="line">0x00100025 in ?? ()</span><br><span class="line">(gdb) x/1x 0x00100000</span><br><span class="line">0x100000:       0x1badb002</span><br><span class="line">(gdb) x/1x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;: 0x00000000</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure></p>
<p>因为0xf0100000处不是我们真正装载内核的地方，逻辑地址0xf0100000被映射成了0x00100000，所以低地址处有内容，高地址处无内容。</p>
<p>当单步执行完<code>movl %eax,%cr0</code> 时，停下，此时查看两处内存结果如下。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x100028:    mov    $0xf010002f,%eax</span><br><span class="line">0x00100028 in ?? ()</span><br><span class="line">(gdb) x/1x 0x00100000</span><br><span class="line">0x100000:       0x1badb002</span><br><span class="line">(gdb) x/1x 0xf0100000</span><br><span class="line">0xf0100000 &lt;_start+4026531828&gt;: 0x1badb002</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure></p>
<p>可以看到高地址处和低地址处值相同了。</p>
<p>原因其实在实验指导书里写着。</p>
<blockquote>
<p>Once CR0_PG is set, memory references are virtual addresses that get translated by the virtual memory hardware to physical addresses. entry_pgdir translates virtual addresses in the range 0xf0000000 through 0xf0400000 to physical addresses 0x00000000 through 0x00400000, as well as virtual addresses 0x00000000 through 0x00400000 to physical addresses 0x00000000 through 0x00400000.</p>
</blockquote>
<p>首先明确cr0是什么。cr0全称是control register 0.下面是wiki中的解释。</p>
<p>The CR0 register is 32 bits long on the 386 and higher processors. On x86-64 processors in long mode, it (and the other control registers) is 64 bits long. CR0 has various control flags that modify the basic operation of the processor.</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Bit</th>
<th>Name</th>
<th>Full Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>PE</td>
<td>Protected Mode Enable</td>
<td>If 1, system is in protected mode, else system is in real mode</td>
</tr>
<tr>
<td>1</td>
<td>MP</td>
<td>Monitor co-processor</td>
<td>Controls interaction of WAIT/FWAIT instructions with TS flag in CR0</td>
</tr>
<tr>
<td>2</td>
<td>EM</td>
<td>Emulation</td>
<td>If set, no x87 floating-point unit present, if clear, x87 FPU present</td>
</tr>
<tr>
<td>3</td>
<td>TS</td>
<td>Task switched</td>
<td>Allows saving x87 task context upon a task switch only after x87 instruction used</td>
</tr>
<tr>
<td>4</td>
<td>ET</td>
<td>Extension type</td>
<td>On the 386, it allowed to specify whether the external math coprocessor was an 80287 or 80387</td>
</tr>
<tr>
<td>5</td>
<td>NE</td>
<td>Numeric error</td>
<td>Enable internal x87 floating point error reporting when set, else enables PC style x87 error detection</td>
</tr>
<tr>
<td>16</td>
<td>WP</td>
<td>Write protect</td>
<td>When set, the CPU can’t write to read-only pages when privilege level is 0</td>
</tr>
<tr>
<td>18</td>
<td>AM</td>
<td>Alignment mask</td>
<td>Alignment check enabled if AM set, AC flag (in EFLAGS register) set, and privilege level is 3</td>
</tr>
<tr>
<td>29</td>
<td>NW</td>
<td>Not-write through</td>
<td>Globally enables/disable write-through caching</td>
</tr>
<tr>
<td>30</td>
<td>CD</td>
<td>Cache disable</td>
<td>Globally enables/disable the memory cache</td>
</tr>
<tr>
<td>31</td>
<td>PG</td>
<td>Paging</td>
<td>If 1, enable paging and use the § CR3 register, else disable paging.</td>
</tr>
</tbody>
</table>
</div>
<p>把eax赋给cr0时，eax=0x80110001，对应上面的标志位就能知道发出了什么控制信息。最关键的是PG，这个信号打开了页表机制，以后都会自动将 0xf0000000 到 0xf0400000 的虚拟（逻辑）地址转成 0x00000000 到 0x00400000 的物理地址。</p>
<p>所以此处会自动把0xf0100000转换成0x00100000，所以两者的值相等。</p>
<p>如果映射机制失败，我觉得<code>jmp *%eax</code>之后会失败。因为此时eax的值是0xf010002f，如果没有地址映射，那会指向这个物理高地址，而不是本应指向的0x100000附近的低地址，就会出错。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x100025:    mov    $0xf010002c,%eax</span><br><span class="line">0x00100025 in ?? ()</span><br><span class="line">(gdb) </span><br><span class="line">=&gt; 0x10002a:    jmp    *%eax</span><br><span class="line">0x0010002a in ?? ()</span><br><span class="line">(gdb) </span><br><span class="line">=&gt; 0xf010002c &lt;relocated&gt;:      add    %al,(%eax)</span><br><span class="line">relocated () at kern/entry.S:74</span><br><span class="line">74              movl    $0x0,%ebp                       # nuke frame pointer</span><br><span class="line">(gdb) </span><br><span class="line">Remote connection closed</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure></p>
<p>上面是注释掉<code>movl %eax,%cr0</code>之后的调试结果。果然，跳转之后的第一条指令就报错了。</p>
<p>在entry.S中说：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The kernel (this code) is linked at address ~(KERNBASE + 1 Meg),</span><br></pre></td></tr></table></figure><br>在程序编译后，被链接到高地址处。在kernel.ld链接脚本文件里指定了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Link the kernel at this address: &quot;.&quot; means the current address */</span><br><span class="line">    . = 0xF0100000;</span><br></pre></td></tr></table></figure></p>
<p>但是bootloader 实际把kernel加载到了0x100000的位置</p>
<h3 id="格式化输出到控制台"><a href="#格式化输出到控制台" class="headerlink" title="格式化输出到控制台"></a>格式化输出到控制台</h3><p>激动人心的时刻到了，我们终于到了能对设备进行操作的阶段了。能打印出信息，是实现交互的开始，也是我们之后调试的一个重要途径。</p>
<p>大多数人都把<code>printf()</code>这样的函数认为是理所当然的，有时甚至认为它们是C语言的“原语“。但在OS内核中，我们必须自己实现所有I/O.</p>
<p>阅读<code>kern/printf.c</code>，<code>lib/printfmt.c</code>，<code>kern/console.c</code>三个源代码，理清三者之间的关系。</p>
<p><code>printf.c</code>基于<code>printfmt()</code>和 kernel console’s cputchar()；</p>
<h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><p>我们省略了一小段代码 - 使用“％o”形式的模式打印八进制数所需的代码。 查找并填写此代码片段。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case &#x27;o&#x27;:</span><br><span class="line">            // Replace this with your code.</span><br><span class="line">            putch(&#x27;0&#x27;, putdat);</span><br><span class="line">            num = getuint(&amp;ap, lflag);</span><br><span class="line">            base = 8;</span><br><span class="line">            goto number;</span><br></pre></td></tr></table></figure><br>就是把%u的代码复制一遍，base 改为 8 就差不多了，并不复杂。</p>
<blockquote>
<p>Explain the interface between printf.c and console.c. Specifically, what function does console.c export? How is this function used by printf.c?</p>
</blockquote>
<p><code>printf.c</code>中使用了<code>console.c</code>中的<code>cputchar</code>函数，并封装为<code>putch</code>函数。并以函数形参传递到<code>printfmt.c</code>中的<code>vprintfmt</code>函数，用于向屏幕上输出一个字符。</p>
<blockquote>
<p>解释console.c中的一段代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// What is the purpose of this?</span></span><br><span class="line">    <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">    <span class="comment">// 显示字符数超过CRT一屏可显示的字符数</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="comment">// 清除buf中&quot;第一行&quot;的字符</span></span><br><span class="line">        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">        <span class="comment">// CRT显示器需要对其用空格擦写才能去掉本来以及显示了的字符。</span></span><br><span class="line">        <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">            crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="comment">// 显示起点退回到最后一行起始</span></span><br><span class="line">        crt_pos -= CRT_COLS;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>首先理解几个宏定义和函数</p>
<ul>
<li><code>CRT_ROWS</code>，<code>CRT_COLS</code>：CRT显示器行列最大值， 此处是25x80</li>
<li><code>ctr_buf</code>在初始化时指向了显示器I/O地址</li>
</ul>
<p><code>memmove</code>从<code>ctr_buf+CTR_COLS</code>复制到<code>ctr_buf</code>中，就是清除掉第一行的数据，把最后一行给空出来，2~n行的数据（<code>CRT_SIZE - CRT_COLS</code>）个，移动到1~n-1行的位置。</p>
<blockquote>
<p>跟踪执行以下代码，在调用<code>cprintf()</code>时，<code>fmt</code>，<code>ap</code>指向什么？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">cprintf(<span class="string">&quot;x %d, y %x, z %d\n&quot;</span>, x, y, z);</span><br></pre></td></tr></table></figure>
<p>在<code>kern/init.c</code>的<code>i386_init()</code>下加入代码，就可以直接测试；加<code>Lab1_exercise8_3</code>标号的目的是为了在<code>kern/kernel.asm</code>反汇编代码中容易找到添加的代码的位置。可以看到地址在<code>0xf0100080</code>处<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lab1 Exercise_8</span></span><br><span class="line">&#123;</span><br><span class="line">    cprintf(<span class="string">&quot;Lab1_Exercise_8:\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    Lab1_exercise8_3:</span><br><span class="line">    cprintf(<span class="string">&quot;x %d, y %x, z %d\n&quot;</span>, x, y, z);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">    cprintf(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调试过程fmt=0xf010478d ， ap=0xf0118fc4； fmt指向字符串，ap指向栈顶<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf (fmt=0xf010478d &quot;x %d, y %x, z %d\n&quot;) at kern/printf.c:27</span><br></pre></td></tr></table></figure><br>可以看到以上地址处就存了字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0xf010478d</span><br><span class="line">0xf010478d:    &quot;x %d, y %x, z %d\n&quot;</span><br><span class="line"></span><br><span class="line">gdb) si</span><br><span class="line">=&gt; 0xf0102f85 &lt;vcprintf&gt;:    push   %ebp</span><br><span class="line">vcprintf (fmt=0xf010478d &quot;x %d, y %x, z %d\n&quot;, ap=0xf0118fc4 &quot;\001&quot;)</span><br><span class="line">    at kern/printf.c:18</span><br><span class="line">18    &#123;</span><br><span class="line"></span><br><span class="line">(gdb) x/16b 0xf0118fc4</span><br><span class="line">0xf0118fc4:    0x01    0x00    0x00    0x00    0x03    0x00    0x00    0x00</span><br><span class="line">0xf0118fcc:    0x04    0x00    0x00    0x00    0x7b    0x47    0x10    0xf0</span><br></pre></td></tr></table></figure>
<p>引用一段Github上大神做的labclpsz/mit-jos-2014的execise8中的一段话。</p>
<blockquote>
<p>从这个练习可以看出来，正是因为C函数调用实参的入栈顺序是从右到左的，才使得调用参数个数可变的函数成为可能(且不用显式地指出参数的个数)。但是必须有一个方式来告诉实际调用时传入的参数到底是几个，这个是在格式化字符串中指出的。如果这个格式化字符串指出的参数个数和实际传入的个数不一致，比如说传入的参数比格式化字符串指出的要少，就可能会使用到栈上错误的内存作为传入的参数，编译器必须检查出这样的错误。</p>
</blockquote>
<p>4.运行以下代码，输出结果是什么。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i = 0x00646c72;</span><br><span class="line">cprintf(&quot;H%x Wo%s&quot;, 57616, &amp;i);</span><br></pre></td></tr></table></figure>
<p>调试输出了<code>He110 World</code>。<code>57616</code>的十六进制形式为<code>E110</code>，因为是小端机，<code>i</code>的在内存中为<code>0x72</code>，<code>0x6c</code>，<code>0x64</code>，<code>0x00</code>，对应ASCII为<code>rld\0</code>。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>打开文件<code>kern/entry.S</code>，按ctrl+f查找关键字，找找stack这个词出现在哪里，看看每次出现的含义。</p>
<p>77行处将一个宏变量<code>bootstacktop</code>的值赋值给了寄存器<code>esp</code>。而<code>bootstacktop</code>出现在<code>bootstack</code>下，<code>bootstack</code>出现在<code>.data</code>段下，这是数据段。可以肯定，这就是栈了。通过93行<code>.space</code>指令，在<code>bootstack</code>位置处初始化了<code>KSTKSIZE</code>这么多的空间。<code>KSTKSIZE</code>在<code>inc/memlayout.h</code>里面定义，是<code>8*PGSIZE</code>，而<code>PGSIZE</code>在<code>inc/mmu.h</code>中定义，值为4096。</p>
<p>栈在内核入口的汇编代码中初始化，是通过一个汇编指令<code>.space</code>，大小是<code>8 * 4096</code>。接下来看看栈的位置。</p>
<p>查看反汇编代码<code>obj/kern/kernel.asm</code>，<code>bootstacktop</code>的值为<code>0xf010f000</code>。这就是栈的位置，准确来说，是栈顶，栈将向地址值更小的方向生长。</p>
<h3 id="栈的行为"><a href="#栈的行为" class="headerlink" title="栈的行为"></a>栈的行为</h3><p>在正式运行一段代码之前，esp寄存器需要先初始化，正如前文所说。这个初始化可以是手动完成的，如<code>kern/entry.S</code>，也可以是自动完成的，如<code>call</code>指令。程序运行时，esp保存的地址以下的内存，都是栈可以生长，但尚未生长到的。esp表示的是“栈顶地址”stack top。</p>
<p>x86栈指针<code>esp</code>寄存器纸箱栈的最低地址。这个地址之下的都是空闲的。将一个值压入栈需要减小栈指针，同时把值写到栈指针之前指向的地方。在32位机器上，栈只能存储32位的值，<code>esp</code>只能被4整除。</p>
<p>程序“压栈”，就是减小esp，并在刚刚esp指向的位置上写入数据。</p>
<p>还有一个寄存器ebp，意思是base pointer，记录的是当前函数栈的开头。没有指令会自动更新ebp的值，但是任何C编译器都要遵守这个规定，写汇编的程序员也是，调用函数时必须写指令更新ebp寄存器。</p>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>在执行新的函数<code>callee</code>代码之前，先保存旧函数<code>caller</code>的栈的位置。这样一来，<code>callee</code>才可以返回到正确的指令上。通过ebp寄存器的值，Debugger可以迅速找到调用这个函数的函数，一路找到最开始执行这个函数的函数，这种操作称为<code>backtrace</code>。</p>
<p>看到反汇编代码<code>obj/kern/kernel.asm</code>中，所有C函数的第一个指令都是<code>push %ebp</code>，保存了旧的栈地址。第二个指令都是<code>mov %esp, %ebp</code>，将当前栈地址，也就是函数的栈的开头，保存到<code>ebp</code>。</p>
<h3 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h3><p>函数返回时，寄存器<code>eip</code>，也就是Instruction Pointer，跳转到调用本函数的<code>call</code>指令的下一个指令，且esp增加。栈是向下增长的，所以这其实是在“弹出”。调用函数时，函数接受的参数都被压栈，故返回时相应弹出。</p>
<h3 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h3><p>在<code>obj/kern/kernel.asm</code>找到<code>test_backtrace</code>函数，并设置断点。进行调试。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test_backtrace</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	cprintf(<span class="string">&quot;entering test_backtrace %d\n&quot;</span>, x);</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">		test_backtrace(x<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		mon_backtrace(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	cprintf(<span class="string">&quot;leaving test_backtrace %d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>test_backtrace函数对应的汇编代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">f0100040:	55                   	push   %ebp</span><br><span class="line">f0100041:	89 e5                	mov    %esp,%ebp</span><br><span class="line">f0100043:	56                   	push   %esi</span><br><span class="line">f0100044:	53                   	push   %ebx</span><br><span class="line">f0100045:	e8 5b 01 00 00       	call   f01001a5 &lt;\_\_x86.get_pc_thunk.bx&gt;</span><br><span class="line">f010004a:	81 c3 be 12 01 00    	add    $0x112be,%ebx</span><br><span class="line">f0100050:	8b 75 08             	mov    0x8(%ebp),%esi</span><br><span class="line">f0100053:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line">f0100056:	56                   	push   %esi</span><br><span class="line">f0100057:	8d 83 18 07 ff ff    	lea    -0xf8e8(%ebx),%eax</span><br><span class="line">f010005d:	50                   	push   %eax</span><br><span class="line">f010005e:	e8 cf 09 00 00       	call   f0100a32 &lt;cprintf&gt;</span><br><span class="line">f0100063:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f0100066:	85 f6                	test   %esi,%esi</span><br><span class="line">f0100068:	7f 2b                	jg     f0100095 &lt;test\_backtrace+0x55&gt;</span><br><span class="line">f010006a:	83 ec 04             	sub    $0x4,%esp</span><br><span class="line">f010006d:	6a 00                	push   $0x0</span><br><span class="line">f010006f:	6a 00                	push   $0x0</span><br><span class="line">f0100071:	6a 00                	push   $0x0</span><br><span class="line">f0100073:	e8 f4 07 00 00       	call   f010086c &lt;mon\_backtrace&gt;</span><br><span class="line">f0100078:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f010007b:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line">f010007e:	56                   	push   %esi</span><br><span class="line">f010007f:	8d 83 34 07 ff ff    	lea    -0xf8cc(%ebx),%eax</span><br><span class="line">f0100085:	50                   	push   %eax</span><br><span class="line">f0100086:	e8 a7 09 00 00       	call   f0100a32 &lt;cprintf&gt;</span><br><span class="line">&#125;</span><br><span class="line">f010008b:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f010008e:	8d 65 f8             	lea    -0x8(%ebp),%esp</span><br><span class="line">f0100091:	5b                   	pop    %ebx</span><br><span class="line">f0100092:	5e                   	pop    %esi</span><br><span class="line">f0100093:	5d                   	pop    %ebp</span><br><span class="line">f0100094:	c3                   	ret    </span><br><span class="line">f0100095:	83 ec 0c             	sub    $0xc,%esp</span><br><span class="line">f0100098:	8d 46 ff             	lea    -0x1(%esi),%eax</span><br><span class="line">f010009b:	50                   	push   %eax</span><br><span class="line">f010009c:	e8 9f ff ff ff       	call   f0100040 &lt;test\_backtrace&gt;</span><br><span class="line">f01000a1:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f01000a4:	eb d5                	jmp    f010007b &lt;test\_backtrace+0x3b&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="观察test-backtrace函数调用栈"><a href="#观察test-backtrace函数调用栈" class="headerlink" title="观察test_backtrace函数调用栈"></a>观察test_backtrace函数调用栈</h3><p>下面开始观察test_backtrace函数的调用栈。%esp存储栈顶的位置，%ebp存储调用者栈顶的位置，%eax存储x的值，这几个寄存器需要重点关注，因此我使用gdb的display命令设置每次运行完成后自动打印它们的值，此外我也设置了自动打印栈内被用到的那段内存的数据，以便清楚观察栈的变化情况。Let’s go.</p>
<p>进入test_backtrace(5)<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f01000d1:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)</span><br><span class="line">f01000d8:	e8 63 ff ff ff       	call   f0100040 &lt;test\_backtrace&gt;</span><br><span class="line">f01000dd:	83 c4 10             	add    $0x10,%esp</span><br></pre></td></tr></table></figure></p>
<p>test_backtrace函数的调用发生在i386_init函数中，传入的参数x=5.我们将从这里开始跟踪栈内数据的变化情况。各寄存器及栈内的数据如下所示。可见，共有两个4字节的整数被压入栈：</p>
<p>输入参数的值（也就是5）。<br>call指令的下一条指令的地址（也就是f01000dd）。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%esp = 0xf010ffdc</span><br><span class="line">%ebp = 0xf010fff8</span><br><span class="line">// stack info</span><br><span class="line">0xf010ffe0: 0x00000005  // 第1次调用时的输入参数：5</span><br><span class="line">0xf010ffdc: 0xf01000dd  // 第1次调用时的返回地址</span><br></pre></td></tr></table></figure></p>
<p>进入test_backtrace函数后，涉及栈内数据修改的指令可以分为三部分：</p>
<ul>
<li>函数开头，将部分寄存器的值压栈，以便函数结束前可以恢复。</li>
<li>调用cprintf前，将输入参数压入栈。</li>
<li>在第2次调用test_backtrace前，将输入参数压入栈。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// function start</span><br><span class="line">f0100040:	55                   	push   %ebp</span><br><span class="line">f0100041:	89 e5                	mov    %esp,%ebp</span><br><span class="line">f0100043:	56                   	push   %esi</span><br><span class="line">f0100044:	53                   	push   %ebx</span><br><span class="line">// call cprintf</span><br><span class="line">f0100053:	83 ec 08             	sub    $0x8,%esp</span><br><span class="line">f0100056:	56                   	push   %esi</span><br><span class="line">f0100057:	8d 83 18 07 ff ff    	lea    -0xf8e8(%ebx),%eax</span><br><span class="line">f010005d:	50                   	push   %eax</span><br><span class="line">f010005e:	e8 cf 09 00 00       	call   f0100a32 &lt;cprintf&gt;</span><br><span class="line">f0100063:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">// call test_backtrace(x-1)</span><br><span class="line">f0100095:	83 ec 0c             	sub    $0xc,%esp</span><br><span class="line">f0100098:	8d 46 ff             	lea    -0x1(%esi),%eax</span><br><span class="line">f010009b:	50                   	push   %eax</span><br><span class="line">f010009c:	e8 9f ff ff ff       	call   f0100040 &lt;test_backtrace&gt;</span><br></pre></td></tr></table></figure>
<p>进入test_backtrace(4)</p>
<p>在即将进入test_backtrace(4)前，栈内数据如下所示。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%esp = 0xf010ffc0</span><br><span class="line">%ebp = 0xf010ffd8</span><br><span class="line">// stack info</span><br><span class="line">0xf010ffe0: 0x00000005  // 第1次调用时的输入参数：5</span><br><span class="line">0xf010ffdc: 0xf01000dd  // 第1次调用时的返回地址</span><br><span class="line">0xf010ffd8: 0xf010fff8  // 第1次调用时寄存器%ebp的值</span><br><span class="line">0xf010ffd4: 0x10094     // 第1次调用时寄存器%esi的值</span><br><span class="line">0xf010ffd0: 0xf0111308  // 第1次调用时寄存器%ebx的值</span><br><span class="line">0xf010ffcc: 0xf010004a  // 残留数据，不需关注</span><br><span class="line">0xf010ffc8: 0x00000000  // 残留数据，不需关注</span><br><span class="line">0xf010ffc4: 0x00000005  // 残留数据，不需关注</span><br><span class="line">0xf010ffc0: 0x00000004  // 第2次调用时的输入参数</span><br></pre></td></tr></table></figure></p>
<p>进入mon_backtrace(0, 0, 0)</p>
<p>在即将进入mon_backtrace(0, 0, 0)前，栈内数据如下所示。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">%esp = 0xf010ff20</span><br><span class="line">%ebp = 0xf010ff38</span><br><span class="line">// stack info</span><br><span class="line">0xf010ffe0: 0x00000005  // 第1次调用时的输入参数：5</span><br><span class="line">0xf010ffdc: 0xf01000dd  // 第1次调用时的返回地址</span><br><span class="line">0xf010ffd8: 0xf010fff8  // 第1次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ffd4: 0x10094     // 第1次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ffd0: 0xf0111308  // 第1次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ffcc: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ffc8: 0x00000000  // 预留空间，不需关注</span><br><span class="line">0xf010ffc4: 0x00000005  // 预留空间，不需关注</span><br><span class="line">0xf010ffc0: 0x00000004  // 第2次调用时的输入参数：4</span><br><span class="line">0xf010ffbc: 0xf01000a1  // 第2次调用时的返回地址</span><br><span class="line">0xf010ffb8: 0xf010ffd8  // 第2次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ffb4: 0x00000005  // 第2次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ffb0: 0xf0111308  // 第2次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ffac: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ffa8: 0x00000000  // 预留空间，不需关注</span><br><span class="line">0xf010ffa4: 0x00000004  // 预留空间，不需关注</span><br><span class="line">0xf010ffa0: 0x00000003  // 第3次调用时的输入参数：3</span><br><span class="line">0xf010ff9c: 0xf01000a1  // 第3次调用时的返回地址</span><br><span class="line">0xf010ff98: 0xf010ffb8  // 第3次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ff94: 0x00000004  // 第3次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ff90: 0xf0111308  // 第3次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ff8c: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ff88: 0xf010ffb8  // 预留空间，不需关注</span><br><span class="line">0xf010ff84: 0x00000003  // 预留空间，不需关注</span><br><span class="line">0xf010ff80: 0x00000002  // 第4次调用时的输入参数：2</span><br><span class="line">0xf010ff7c: 0xf01000a1  // 第4次调用时的返回地址</span><br><span class="line">0xf010ff78: 0xf010ff98  // 第4次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ff74: 0x00000003  // 第4次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ff70: 0xf0111308  // 第4次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ff6c: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ff68: 0xf010ff98  // 预留空间，不需关注</span><br><span class="line">0xf010ff64: 0x00000002  // 预留空间，不需关注</span><br><span class="line">0xf010ff60: 0x00000001  // 第5次调用时的输入参数：1</span><br><span class="line">0xf010ff5c: 0xf01000a1  // 第5次调用时的返回地址</span><br><span class="line">0xf010ff58: 0xf010ff78  // 第5次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ff54: 0x00000002  // 第5次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ff50: 0xf0111308  // 第5次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ff4c: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ff48: 0xf010ff78  // 预留空间，不需关注</span><br><span class="line">0xf010ff44: 0x00000001  // 预留空间，不需关注</span><br><span class="line">0xf010ff40: 0x00000000  // 第6次调用时的输入参数：0</span><br><span class="line">0xf010ff3c: 0xf01000a1  // 第6次调用时的返回地址</span><br><span class="line">0xf010ff38: 0xf010ff58  // 第6次调用开始时寄存器%ebp的值</span><br><span class="line">0xf010ff34: 0x00000001  // 第6次调用开始时寄存器%esi的值</span><br><span class="line">0xf010ff30: 0xf0111308  // 第6次调用开始时寄存器%ebx的值</span><br><span class="line">0xf010ff2c: 0xf010004a  // 预留空间，不需关注</span><br><span class="line">0xf010ff28: 0x00000000  // 第7次调用时的第1个输入参数：0</span><br><span class="line">0xf010ff24: 0x00000000  // 第7次调用时的第2个输入参数：0</span><br><span class="line">0xf010ff20: 0x00000000  // 第7次调用时的第3个输入参数：0</span><br></pre></td></tr></table></figure></p>
<p>mon_backtrace函数目前内部为空，不需关注。</p>
<p>退出mon_backtrace(0, 0, 0)：通过add $0x10, %esp语句，将输入参数及预留的4字节从栈中清除。此时%esp = 0xf010ff30，%ebp = 0xf010ff38.</p>
<p>退出test_backtrace(0)：连续3个pop语句将ebx, esi和ebp寄存器依次出栈，然后通过ret语句返回。其他1~5的退出过程类似，不再赘述。</p>
<h3 id="实现backtrace"><a href="#实现backtrace" class="headerlink" title="实现backtrace"></a>实现backtrace</h3><p>Lab中的练习要求我们实现一个backtrace函数，能够打印函数调用的地址和传给函数的参数值。其实CLion的Debugger就有这个功能：</p>
<p>我们要实现的函数，就是可以获得函数此时的ebp寄存器的值、返回的地址、和获得参数的值。</p>
<p>查找<code>mon_backtrace</code>，来到已经准备好的一个函数。函数中写了Your code here注释，让我们在这里实现backtrace功能。我的实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> ebp = read_ebp();                <span class="comment">// 拿到ebp的值，类型和函数read_ebp的返回类型一致</span></span><br><span class="line"><span class="type">int</span> *ebp_base_ptr = (<span class="type">int</span> *)ebp;           <span class="comment">// 转化为指针</span></span><br><span class="line"><span class="type">uint32_t</span> eip = ebp_base_ptr[<span class="number">1</span>];   		  <span class="comment">// 拿到返回地址</span></span><br><span class="line">cprintf(<span class="string">&quot;ebp %x, eip %x, args &quot;</span>, ebp, eip);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *args = ebp_base_ptr + <span class="number">2</span>;             <span class="comment">// 拿到进入函数之前的栈地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;             <span class="comment">// 输出参数</span></span><br><span class="line">    cprintf(<span class="string">&quot;%x &quot;</span>, *(args+i));</span><br><span class="line">&#125;</span><br><span class="line">cprintf(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>我们把读取到的ebp的值转化为了int*类型，这样转化使得对指针的加减法步长和栈中元素长度一致。在x86机器中，地址和int类型同质，长度都是4字节。这样转换之后，无论是加法，还是中括号[]索引，改变的地址都是4字节，而不是1字节，可以恰好改变一个元素的长度。</p>
<p>来看打印得到结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ebp f010ef58, eip f01000a1, args 0 0 0 f010004a f0110308 </span><br></pre></td></tr></table></figure></p>
<p>给函数传的3个参数的值均为0，和打印结果一致！</p>
<p>eip的值正是调用完函数mon_backtrace后一个指令的地址，可以查看反汇编代码obj/kern/kernel.asm，调用函数指令如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">		mon_backtrace(0, 0, 0);</span><br><span class="line">f0100093:	83 ec 04             	sub    $0x4,%esp</span><br><span class="line">f0100096:	6a 00                	push   $0x0</span><br><span class="line">f0100098:	6a 00                	push   $0x0</span><br><span class="line">f010009a:	6a 00                	push   $0x0</span><br><span class="line">f010009c:	e8 e1 07 00 00       	call   f0100882 &lt;mon_backtrace&gt;</span><br><span class="line">f01000a1:	83 c4 10             	add    $0x10,%esp</span><br><span class="line">f01000a4:	eb d3                	jmp    f0100079 &lt;test_backtrace+0x39&gt;</span><br></pre></td></tr></table></figure></p>
<p>倒数第二行指令地址正是0xf01000a1！</p>
<h3 id="读取Symbol-Table"><a href="#读取Symbol-Table" class="headerlink" title="读取Symbol Table"></a>读取Symbol Table</h3><p>这个练习要求我们研究函数<code>debuginfo_eip</code>的实现，弄清楚命名为<code>__STAB_*</code>的几个宏的来历和作用，以及将<code>backtrace</code>功能作为命令加入console功能中。</p>
<p>命名为<code>__STAB_*</code>的宏最早在文件<code>kern/kernel.ld</code>中26行出现，<code>__STABSTR_*</code>则在下面一点的34行出现。这个连接器的配置文件，要求连接器生成elf文件时，分配两个segment给到.stab和.stabstr，正如连接器也分配了<code>.data</code>等segment一样。</p>
<p>运行<code>objdump -h obj/kern/kernel</code>查看分配的segment的信息，有关部分如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00001bad  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       000006f4  f0101bc0  00101bc0  00002bc0  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .stab         000043b1  f01022b4  001022b4  000032b4  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .stabstr      00001987  f0106665  00106665  00007665  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .data         00009300  f0108000  00108000  00009000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  5 .got          00000008  f0111300  00111300  00012300  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  6 .got.plt      0000000c  f0111308  00111308  00012308  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  7 .data.rel.local 00001000  f0112000  00112000  00013000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  8 .data.rel.ro.local 00000044  f0113000  00113000  00014000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  9 .bss          00000648  f0113060  00113060  00014060  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 10 .comment      0000002a  00000000  00000000  000146a8  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure></p>
<p>运行<code>objdump -G obj/kern/kernel</code>，查看符号列表Symbol Table，得到有关函数和文件的信息，以下粘贴了部分<code>kern/monitor.c</code>文件有关的信息。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">obj/kern/kernel:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of .stab section:</span><br><span class="line"></span><br><span class="line">Symnum n_type n_othr n_desc n_value  n_strx String</span><br><span class="line">...  </span><br><span class="line">375    FUN    0      0      f0100882 1790   mon_backtrace:F(0,1)</span><br><span class="line">376    PSYM   0      0      00000008 1603   argc:p(0,1)</span><br><span class="line">377    PSYM   0      0      0000000c 1768   argv:p(0,2)</span><br><span class="line">378    PSYM   0      0      00000010 1780   tf:p(0,5)</span><br><span class="line">379    SLINE  0      59     00000000 0      </span><br><span class="line">380    SOL    0      0      f0100896 601    ./inc/x86.h</span><br><span class="line">381    SLINE  0      214    00000014 0      </span><br><span class="line">382    SOL    0      0      f0100898 1541   kern/monitor.c</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>知道了<code>__STAB_*</code>的来历，看看它们的作用。文件<code>kern/kdebug.c</code>中函数<code>debuginfo_eip</code>142行调用了这几个宏，整个函数和同一个文件里面的另一个函数<code>stab_binsearch</code>的目的是从<code>.stab</code>和<code>.stabstr</code>两个<code>segment</code>中读取出想要的debug信息，装进一个Eipdebuginfo结构体中。</p>
<p>按照提示，我们首先可以调用<code>read_ebp</code>函数来获取当前ebp寄存器的值。ebp寄存器的值实际上是一个指针，指向当前函数的栈帧的底部（而esp寄存器指向当前函数的栈顶）。我们可以把整个调用栈看做一个数组，其中每个元素均为4字节的整数，并以ebp指针的值为数组起始地址，那么<code>ebp[1]</code>存储的就是函数返回地址，也就是题目中要求的eip的值，<code>ebp[2]</code>以后存储的是输入参数的值。由于题目要求打印5个输入参数，因此需要获取<code>ebp[2]</code>～<code>ebp[6]</code>的值。这样第一条栈信息便可打印出来。</p>
<p>那么怎么打印下一条栈信息呢？还得从ebp入手。当前ebp指针存储的恰好是调用者的ebp寄存器的值，因此当前ebp指针又可以看做是一个链表头，我们通过链表头就可以遍历整个链表。举个例子：假设有A、B、C三个函数，A调用B，B调用C，每个函数都对应有一个栈帧，栈帧的底部地址均存储在当时的ebp寄存器中，不妨记为a_ebp, b_ebp和c_ebp，那么将有c_ebp -&gt; b_ebp -&gt; a_ebp，用程序语言表示就是：<code>a_ebp = (uint32_t *)*b_ebp</code>和<code>b_ebp = (uint32_t *)*c_ebp</code>。</p>
<p>还有一个问题：怎么知道遍历何时结束呢？题目中提示可以参考kern/entry.S，于是我打开此文件，果然找打答案：内核初始化时会将ebp设置为0，因此当我们检查到ebp为0后就应该结束了。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Clear the frame pointer register (EBP)</span><br><span class="line"># so that once we get into debugging C code,</span><br><span class="line"># stack backtraces will be terminated properly.</span><br><span class="line">movl	$0x0,%ebp			# nuke frame pointer</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> *ebp;</span><br><span class="line"></span><br><span class="line">    ebp = (<span class="type">uint32_t</span> *)read_ebp();</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ebp)</span><br><span class="line">    &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\r\n&quot;</span>, </span><br><span class="line">                ebp, ebp[<span class="number">1</span>], ebp[<span class="number">2</span>], ebp[<span class="number">3</span>], ebp[<span class="number">4</span>], ebp[<span class="number">5</span>], ebp[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">        ebp = (<span class="type">uint32_t</span> *)*ebp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">6828 decimal is 15254 octal!</span><br><span class="line">entering test_backtrace 5</span><br><span class="line">entering test_backtrace 4</span><br><span class="line">entering test_backtrace 3</span><br><span class="line">entering test_backtrace 2</span><br><span class="line">entering test_backtrace 1</span><br><span class="line">entering test_backtrace 0</span><br><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff18  eip f0100078  args 00000000 00000000 00000000 f010004a f0111308</span><br><span class="line">  ebp f010ff38  eip f01000a1  args 00000000 00000001 f010ff78 f010004a f0111308</span><br><span class="line">  ebp f010ff58  eip f01000a1  args 00000001 00000002 f010ff98 f010004a f0111308</span><br><span class="line">  ebp f010ff78  eip f01000a1  args 00000002 00000003 f010ffb8 f010004a f0111308</span><br><span class="line">  ebp f010ff98  eip f01000a1  args 00000003 00000004 00000000 f010004a f0111308</span><br><span class="line">  ebp f010ffb8  eip f01000a1  args 00000004 00000005 00000000 f010004a f0111308</span><br><span class="line">  ebp f010ffd8  eip f01000dd  args 00000005 00001aac f010fff8 f01000bd 00000000</span><br><span class="line">  ebp f010fff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003</span><br><span class="line">leaving test_backtrace 0</span><br><span class="line">leaving test_backtrace 1</span><br><span class="line">leaving test_backtrace 2</span><br><span class="line">leaving test_backtrace 3</span><br><span class="line">leaving test_backtrace 4</span><br><span class="line">leaving test_backtrace 5</span><br></pre></td></tr></table></figure></p>
<h3 id="debuginfo-eip函数实现根据地址寻找行号的功能"><a href="#debuginfo-eip函数实现根据地址寻找行号的功能" class="headerlink" title="debuginfo_eip函数实现根据地址寻找行号的功能"></a>debuginfo_eip函数实现根据地址寻找行号的功能</h3><p>解决这个问题的关键是熟悉stabs每行记录的含义，我折腾了一两小时才搞清楚。首先，使用<code>objdump -G obj/kern/kernel &gt; output.md</code>将内核的符号表信息输出到<code>output.md</code>文件，在<code>output.md</code>文件中可以看到以下片段：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symnum n_type n_othr n_desc n_value  n_strx String</span><br><span class="line">118    FUN    0      0      f01000a6 2987   i386_init:F(0,25)</span><br><span class="line">119    SLINE  0      24     00000000 0      </span><br><span class="line">120    SLINE  0      34     00000012 0      </span><br><span class="line">121    SLINE  0      36     00000017 0      </span><br><span class="line">122    SLINE  0      39     0000002b 0      </span><br><span class="line">123    SLINE  0      43     0000003a 0      </span><br></pre></td></tr></table></figure></p>
<p>这个片段是什么意思呢？首先要理解第一行给出的每列字段的含义：</p>
<ul>
<li><code>Symnum</code>是符号索引，换句话说，整个符号表看作一个数组，Symnum是当前符号在数组中的下标</li>
<li><code>n_type</code>是符号类型，FUN指函数名，SLINE指在text段中的行号</li>
<li><code>n_othr</code>目前没被使用，其值固定为0</li>
<li><code>n_desc</code>表示在文件中的行号</li>
<li><code>n_value</code>表示地址。特别要注意的是，这里只有FUN类型的符号的地址是绝对地址，SLINE符号的地址是偏移量，其实际地址为函数入口地址加上偏移量。比如第3行的含义是地址f01000b8(=0xf01000a6+0x00000012)对应文件第34行。</li>
</ul>
<p>理解stabs每行记录的含义后，调用<code>stab_binsearch</code>便能找到某个地址对应的行号了。由于前面的代码已经找到地址在哪个函数里面以及函数入口地址，将原地址减去函数入口地址即可得到偏移量，再根据偏移量在符号表中的指定区间查找对应的记录即可。代码如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lfun, &amp;rfun, N_SLINE, addr - info-&gt;eip_fn_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lfun &lt;= rfun)</span><br><span class="line">&#123;</span><br><span class="line">    info-&gt;eip_line = stabs[lfun].n_desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="给内核模拟器增加backtrace命令，并在mon-backtrace中增加打印文件名、函数名和行号"><a href="#给内核模拟器增加backtrace命令，并在mon-backtrace中增加打印文件名、函数名和行号" class="headerlink" title="给内核模拟器增加backtrace命令，并在mon_backtrace中增加打印文件名、函数名和行号"></a>给内核模拟器增加backtrace命令，并在mon_backtrace中增加打印文件名、函数名和行号</h3><p>给内核模拟器增加backtrace命令。很简单，在<code>kern/monitor.c</code>文件中模仿已有命令添加即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] =</span> &#123;</span><br><span class="line">	&#123; <span class="string">&quot;help&quot;</span>, <span class="string">&quot;Display this list of commands&quot;</span>, mon_help &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;kerninfo&quot;</span>, <span class="string">&quot;Display information about the kernel&quot;</span>, mon_kerninfo &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;backtrace&quot;</span>, <span class="string">&quot;Display a backtrace of the function stack&quot;</span>, mon_backtrace &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="在mon-backtrace中增加打印文件名、函数名和行号"><a href="#在mon-backtrace中增加打印文件名、函数名和行号" class="headerlink" title="在mon_backtrace中增加打印文件名、函数名和行号"></a>在mon_backtrace中增加打印文件名、函数名和行号</h3><p>经过上面的探索，这个问题就很容易解决了。在<code>mon_backtrace</code>中调用<code>debuginfo_eip</code>来获取文件名、函数名和行号即可。注意，返回的<code>Eipdebuginfo</code>结构体的<code>eip_fn_name</code>字段除了函数名外还有一段尾巴，比如<code>test_backtrace:F(0,25)</code>，需要将”:F(0,25)”去掉，可以使用<code>printf(&quot;%.*s&quot;, length, string)</code>来实现。代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> *ebp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    ebp = (<span class="type">uint32_t</span> *)read_ebp();</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (ebp)</span><br><span class="line">    &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\r\n&quot;</span>, ebp, ebp[<span class="number">1</span>], ebp[<span class="number">2</span>], ebp[<span class="number">3</span>], ebp[<span class="number">4</span>], ebp[<span class="number">5</span>], ebp[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Eipdebuginfo));</span><br><span class="line"></span><br><span class="line">        result = debuginfo_eip(ebp[<span class="number">1</span>], &amp;info);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != result)</span><br><span class="line">            cprintf(<span class="string">&quot;failed to get debuginfo for eip %x.\r\n&quot;</span>, ebp[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cprintf(<span class="string">&quot;\t%s:%d: %.*s+%u\r\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, ebp[<span class="number">1</span>] - info.eip_fn_addr);</span><br><span class="line">        ebp = (<span class="type">uint32_t</span> *)*ebp;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff18  eip f0100078  args 00000000 00000000 00000000 f010004a f0111308</span><br><span class="line">        kern/init.c:16: test_backtrace+56</span><br><span class="line">  ebp f010ff38  eip f01000a1  args 00000000 00000001 f010ff78 f010004a f0111308</span><br><span class="line">        kern/init.c:16: test_backtrace+97</span><br><span class="line">  ebp f010ff58  eip f01000a1  args 00000001 00000002 f010ff98 f010004a f0111308</span><br><span class="line">	    kern/init.c:16: test_backtrace+97</span><br><span class="line">  ebp f010ff78  eip f01000a1  args 00000002 00000003 f010ffb8 f010004a f0111308</span><br><span class="line">	    kern/init.c:16: test_backtrace+97</span><br><span class="line">  ebp f010ff98  eip f01000a1  args 00000003 00000004 00000000 f010004a f0111308</span><br><span class="line">	    kern/init.c:16: test_backtrace+97</span><br><span class="line">  ebp f010ffb8  eip f01000a1  args 00000004 00000005 00000000 f010004a f0111308</span><br><span class="line">	    kern/init.c:16: test_backtrace+97</span><br><span class="line">  ebp f010ffd8  eip f01000dd  args 00000005 00001aac f010fff8 f01000bd 00000000</span><br><span class="line">	    kern/init.c:43: i386_init+55</span><br><span class="line">  ebp f010fff8  eip f010003e  args 00000003 00001003 00002003 00003003 00004003</span><br><span class="line">	    &#123;standard input&#125;:0: &lt;unknown&gt;+0</span><br><span class="line">```:q</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在本实验中，我们将编写操作系统的内存管理代码。 内存管理有两个组成部分。</p>
<p>第一个部分是内核的物理内存分配器，以致于内核可以分配和释放内存。 分配器将以4096字节为操作单位，称为一个页面。 我们的任务是维护一个数据结构，去记录哪些物理页面是空闲的，哪些是已分配的，以及共享每个已分配页面的进程数。 我们还要编写例程来分配和释放内存页面。</p>
<p>内存管理的第二个组件是虚拟内存，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。 当指令使用内存时，x86硬件的内存管理单元（MMU）执行映射，查询一组页表。 我们根据任务提供的规范修改JOS以设置MMU的页面表。</p>
<p>lab2包含的新源文件：</p>
<ul>
<li>inc/memlayout.h</li>
<li>kern/pmap.c</li>
<li>kern/pmap.h</li>
<li>kern/kclock.h</li>
<li>kern/kclock.c</li>
</ul>
<p><code>memlayout.h</code>描述了虚拟地址空间的布局，这是我们需要通过修改<code>pmap.c</code>实现的。<code>memlayout.h</code>和<code>pmap.h</code>定义了<code>PageInfo</code>结构，可以通过这个结构来跟踪那个物理地址是空闲的。<code>kclock.c</code>和<code>kclock.h</code>操作系统的时钟。</p>
<p><code>memlayout.h</code>给贴心的画了个图，很形象的表述了虚拟地址的分布。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Virtual memory <span class="built_in">map</span>:                                Permissions</span><br><span class="line">                                                   kernel/user</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span> Gig --------&gt;  +------------------------------+</span><br><span class="line">                    |                              | RW/--</span><br><span class="line">                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">                    :              .               :</span><br><span class="line">                    :              .               :</span><br><span class="line">                    :              .               :</span><br><span class="line">                    |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</span><br><span class="line">                    |                              | RW/--</span><br><span class="line">                    |   Remapped Physical Memory   | RW/--</span><br><span class="line">                    |                              | RW/--</span><br><span class="line">   KERNBASE, ----&gt;  +------------------------------+ <span class="number">0xf0000000</span>      --+</span><br><span class="line">   KSTACKTOP        |     CPU0<span class="string">&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span></span><br><span class="line"><span class="string">                    | - - - - - - - - - - - - - - -|                   |</span></span><br><span class="line"><span class="string">                    |      Invalid Memory (*)      | --/--  KSTKGAP    |</span></span><br><span class="line"><span class="string">                    +------------------------------+                   |</span></span><br><span class="line"><span class="string">                    |     CPU1&#x27;</span>s Kernel Stack      | RW/--  KSTKSIZE   |</span><br><span class="line">                    | - - - - - - - - - - - - - - -|                 PTSIZE</span><br><span class="line">                    |      Invalid <span class="title function_">Memory</span> <span class="params">(*)</span>      | --/--  KSTKGAP    |</span><br><span class="line">                    +------------------------------+                   |</span><br><span class="line">                    :              .               :                   |</span><br><span class="line">                    :              .               :                   |</span><br><span class="line">   MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span><br><span class="line">                    |       Memory-mapped I/O      | RW/--  PTSIZE</span><br><span class="line">ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span><br><span class="line">                    |  Cur. Page <span class="title function_">Table</span> <span class="params">(User R-)</span>   | R-/R-  PTSIZE</span><br><span class="line">   UVPT      ----&gt;  +------------------------------+ 0xef400000</span><br><span class="line">                    |          RO PAGES            | R-/R-  PTSIZE</span><br><span class="line">   UPAGES    ----&gt;  +------------------------------+ 0xef000000</span><br><span class="line">                    |           RO ENVS            | R-/R-  PTSIZE</span><br><span class="line">UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span><br><span class="line">UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE</span><br><span class="line">                    +------------------------------+ 0xeebff000</span><br><span class="line">                    |       Empty <span class="title function_">Memory</span> <span class="params">(*)</span>       | --/--  PGSIZE</span><br><span class="line">   USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span><br><span class="line">                    |      Normal User Stack       | RW/RW  PGSIZE</span><br><span class="line">                    +------------------------------+ 0xeebfd000</span><br><span class="line">                    |                              |</span><br><span class="line">                    |                              |</span><br><span class="line">                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">                    .                              .</span><br><span class="line">                    .                              .</span><br><span class="line">                    .                              .</span><br><span class="line">                    |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</span><br><span class="line">                    |     Program Data &amp; Heap      |</span><br><span class="line">   UTEXT --------&gt;  +------------------------------+ 0x00800000</span><br><span class="line">   PFTEMP -------&gt;  |       Empty <span class="title function_">Memory</span> <span class="params">(*)</span>       |        PTSIZE</span><br><span class="line">                    |                              |</span><br><span class="line">   UTEMP --------&gt;  +------------------------------+ 0x00400000      --+</span><br><span class="line">                    |       Empty <span class="title function_">Memory</span> <span class="params">(*)</span>       |                   |</span><br><span class="line">                    | - - - - - - - - - - - - - - -|                   |</span><br><span class="line">                    |  User STAB <span class="title function_">Data</span> <span class="params">(optional)</span>   |                 PTSIZE</span><br><span class="line">   USTABDATA ----&gt;  +------------------------------+ 0x00200000        |</span><br><span class="line">                    |       Empty <span class="title function_">Memory</span> <span class="params">(*)</span>       |                   |</span><br><span class="line">   0 ------------&gt;  +------------------------------+                 --+</span><br><span class="line"></span><br><span class="line"><span class="params">(*)</span> Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="line">    &quot;Empty Memory&quot; is normally unmapped, but user programs may <span class="built_in">map</span> pages</span><br><span class="line">    there <span class="keyword">if</span> desired.  JOS user programs <span class="built_in">map</span> pages temporarily at UTEMP.</span><br></pre></td></tr></table></figure></p>
<h3 id="回顾：未初始化完成的内存映射"><a href="#回顾：未初始化完成的内存映射" class="headerlink" title="回顾：未初始化完成的内存映射"></a>回顾：未初始化完成的内存映射</h3><p>在Lab 1中，我们做了一个虚拟内存映射，将0xf0000000-0xf0400000映射到物理地址0x00000000-00400000，总共大小为4MB。如果访问任何超出这个范围的虚拟地址，CPU都会出错。</p>
<p>在之后写代码时，代码中的地址都是虚拟地址，翻译成物理地址的过程是硬件实现的，我们不应该想着如何直接操作物理地址。但是，有时将地址转化物理地址可以方便一些操作，在文件<code>inc/memlayout.h</code>和<code>kern/pmap.h</code>中提供了一些宏和函数，方便我们做这样的地址换算。</p>
<p>首先提供了宏<code>KERNBASE</code>，注释说所有物理地址都被映射到这里，值为0xf0000000，正是我们映射的地址。所谓所有，就是已经映射过的地址，不包括还没映射的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All physical memory mapped at this address</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE        0xF0000000</span></span><br></pre></td></tr></table></figure></p>
<p>宏函数<code>KADDR</code>调用了函数<code>_kaddr</code>，将物理地址转化成内核地址，或称虚拟地址，也就是在物理地址的数值上加上了<code>KERNBAE</code>。此时的“所有”物理地址，范围还很小，因为其它的内存映射还没有建立，故可以这样简单地操作。其它内存映射建立之后，物理地址转化为虚拟地址的过程将很复杂。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This macro takes a physical address and returns the corresponding kernel</span></span><br><span class="line"><span class="comment"> * virtual address.  It panics if you pass an invalid physical address. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KADDR(pa) _kaddr(__FILE__, __LINE__, pa)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>*</span><br><span class="line">_kaddr(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">physaddr_t</span> pa)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (PGNUM(pa) &gt;= npages)</span><br><span class="line">                _panic(file, line, <span class="string">&quot;KADDR called with invalid pa %08lx&quot;</span>, pa);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span> *)(pa + KERNBASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相应的反向过程将虚拟地址转化为物理地址，宏函数<code>PADDR</code>做了这样的事情。也就是在输入的虚拟地址上减去<code>KERNBASE</code>，非常简单。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This macro takes a kernel virtual address -- an address that points above</span></span><br><span class="line"><span class="comment"> * KERNBASE, where the machine&#x27;s maximum 256MB of physical memory is mapped --</span></span><br><span class="line"><span class="comment"> * and returns the corresponding physical address.  It panics if you pass it a</span></span><br><span class="line"><span class="comment"> * non-kernel virtual address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PADDR(kva) _paddr(__FILE__, __LINE__, kva)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">physaddr_t</span></span><br><span class="line">_paddr(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">void</span> *kva)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">uint32_t</span>)kva &lt; KERNBASE)</span><br><span class="line">                _panic(file, line, <span class="string">&quot;PADDR called with invalid kva %08lx&quot;</span>, kva);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">physaddr_t</span>)kva - KERNBASE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下为把页转换为物理地址和把物理地址转成页，或者把页转成虚拟地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">physaddr_t</span></span><br><span class="line"><span class="title function_">page2pa</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> (pp - pages) &lt;&lt; PGSHIFT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> PageInfo*</span><br><span class="line"><span class="title function_">pa2page</span><span class="params">(<span class="type">physaddr_t</span> pa)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (PGNUM(pa) &gt;= npages)</span><br><span class="line">                panic(<span class="string">&quot;pa2page called with invalid pa&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> &amp;pages[PGNUM(pa)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>*</span><br><span class="line"><span class="title function_">page2kva</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> KADDR(page2pa(pp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Part-1任务总览"><a href="#Part-1任务总览" class="headerlink" title="Part 1任务总览"></a>Part 1任务总览</h3><p>Lab 2 Part 1让我们完成内核内存初始化，而用户区User Level内存初始化在后面的part中完成。</p>
<p>初始化操作集中在文件<code>kern/pmap.c</code>的函数<code>mem_init</code>中，在内核初始化函数<code>i386_init</code>中调用。在这个part中，我们开始写这个函数以及它将调用的函数，只需要写到<code>check_page_alloc</code>函数的调用之前即可。<code>check_page_alloc</code>这一行之上进行的操作汇总如下。</p>
<ul>
<li>直接调用硬件查看可以使用的内存大小，也就是函数i386_detect_memory。</li>
<li>创建一个内核初始化时的page目录，并设置权限。</li>
<li>创建用于管理page的数组，初始化page分配器组件。</li>
<li>测试page分配器组件。</li>
</ul>
<p>需要我们写的函数有：</p>
<ul>
<li>boot_alloc，page未初始化时的分配器。</li>
<li>page_init, page_alloc, page_free，page分配器组件。</li>
<li>mem_init，总的内存初始化函数。</li>
</ul>
<p>完成分配器之后，我们的目标是让虚拟地址有基础。进程需要更多内存，向内核发出请求，内核利用分配器，将一个由分配器决定的物理地址和由进程决定的虚拟地址关联到一起，称为映射。这是后面的Lab的内容，本文只关心分配，不关心任何形式的映射。</p>
<h3 id="va-list-va-start等等"><a href="#va-list-va-start等等" class="headerlink" title="va_list va_start等等"></a>va_list va_start等等</h3><p>VA函数（variable argument function），参数可变函数。理解这个操作，头脑中需要有栈的概念，参数按序（从右到左）压栈，第一个参数在低地址位置。函数原型为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* va_list;</span><br><span class="line"><span class="comment">// 以4字节为单位对齐</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INTSIZEOF(n) (sizeof(n)+sizeof(int)-1)&amp; ~(sizeof(int)-1)</span></span><br><span class="line"><span class="comment">// 求得参数栈的第一个参数地址</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap, v) (ap = (va_list)&amp;v + _INTSIZEOF(v)) </span></span><br><span class="line"><span class="comment">// 这里很巧妙，ap+SIZE指向下一个参数地址，再返回总体减去size（即又指回了当前变量） </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap, t)   (*(t *) ((ap+=_INTSIZEOF(t)) - _INTSIZEOF(t)) )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap)  (ap = (va_list) 0)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>va_list ap</code>    定义一个变差变量ap</li>
<li><code>va_start(ap, last)</code>    初始化ap,得到可变参数列表的第一个参数的确切地址。实际就是指向参数堆栈的栈顶</li>
<li><code>va_arg(ap, type)</code>    已知变量类型为type的情况下，获得下一个变参变量</li>
<li><code>va_end(ap)</code>    结束操作</li>
</ul>
<p><code>entry_pgdir</code>的写法也是内存映射的一个重要部分。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line"><span class="type">pde_t</span> entry_pgdir[NPDENTRIES] = &#123;</span><br><span class="line">    <span class="comment">// Map VA&#x27;s [0, 4MB) to PA&#x27;s [0, 4MB)</span></span><br><span class="line">    <span class="comment">// 在数组定义中，这是什么写法？</span></span><br><span class="line">    [<span class="number">0</span>]</span><br><span class="line">        = ((<span class="type">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P,</span><br><span class="line">    <span class="comment">// Map VA&#x27;s [KERNBASE, KERNBASE+4MB) to PA&#x27;s [0, 4MB)</span></span><br><span class="line">    [KERNBASE&gt;&gt;PDXSHIFT]</span><br><span class="line">        = ((<span class="type">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P + PTE_W</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="两个内存分配器"><a href="#两个内存分配器" class="headerlink" title="两个内存分配器"></a>两个内存分配器</h3><p>有两个分配器，一个是正式的Page分配器，在之后的所有情况下我们都使用这个。另一个是在Page分配器初始化完成之前使用的，更加原始、简单。</p>
<p>在page分配器初始化完成之前，内核在初始化的过程中使用<code>boot_alloc</code>函数分配内存，也可称为boot分配器。这个分配器非常原始，在page分配器初始化完成后，务必不可调用<code>boot_alloc</code>分配内存，以免出现莫名其妙的错误。</p>
<h3 id="page分配器"><a href="#page分配器" class="headerlink" title="page分配器"></a>page分配器</h3><p>Page分配器操作内存是以page为单位的，之后几乎所有管理内存的机制都是以page为单位。page就是将所有的内存地址分成长度相同的一个个区块，每个的长度都是4096Bytes。所有可以分配的内存都注册到一个链表中，通过分配器，可以方便地拿到一个未分配的page。</p>
<p>内存管理组件维护一个链表，称为<code>free list</code>，这个链表将所有未分配的page连起来。需要分配内存时，将链表头部对应的page返回，并将链表头部更新为链表中的下一个元素。</p>
<p>在<code>inc/memlayout.h</code>中定义了这样的结构体，<code>pp_ref</code>是指向这个页面的指针数量，指针<code>pp_link</code>就是链表中常用的next指针。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> &#123;</span></span><br><span class="line">    <span class="comment">// Next page on the free list.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp_link</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pp_ref is the count of pointers (usually in page table entries)</span></span><br><span class="line">    <span class="comment">// to this page, for pages allocated using page_alloc.</span></span><br><span class="line">    <span class="comment">// Pages allocated at boot time using pmap.c&#x27;s</span></span><br><span class="line">    <span class="comment">// boot_alloc do not have valid reference count fields.</span></span><br><span class="line">    <span class="type">uint16_t</span> pp_ref;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>创建了一个<code>struct PageInfo</code>的数组，数组中第i个成员代表内存中第i个<code>page</code>。故物理地址和数组索引很方便相换算。初始化时，形成一个链表，所有可分配的<code>page</code>都以<code>struct PageInfo</code>的形式存在于链表上。要通过分配器拿到一个<code>page</code>，也就是读取链表开头的节点，这个节点就对应一个<code>page</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pages</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">size_t</span> npages;</span><br></pre></td></tr></table></figure></p>
<p>初始化函数<code>page_init</code>将所有的<code>pp_link</code>初始化指向与自己相邻的<code>PageInfo</code>，如下，这是初步实现，后续还有更新：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Initialize page structure and memory free list.</span></span><br><span class="line"><span class="comment">// After this is done, NEVER use boot_alloc again.  ONLY use the page</span></span><br><span class="line"><span class="comment">// allocator functions below to allocate and deallocate physical</span></span><br><span class="line"><span class="comment">// memory via the page_free_list.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// The example code here marks all physical pages as free.</span></span><br><span class="line">        <span class="comment">// However this is not truly the case.  What memory is free?</span></span><br><span class="line">        <span class="comment">//  1) Mark physical page 0 as in use.</span></span><br><span class="line">        <span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></span><br><span class="line">        <span class="comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span></span><br><span class="line">        <span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></span><br><span class="line">        <span class="comment">//     is free.</span></span><br><span class="line">        <span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line">        <span class="comment">//     never be allocated.</span></span><br><span class="line">        <span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line">        <span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></span><br><span class="line">        <span class="comment">//     in physical memory?  Which pages are already in use for</span></span><br><span class="line">        <span class="comment">//     page tables and other data structures?</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Change the code to reflect this.</span></span><br><span class="line">        <span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></span><br><span class="line">        <span class="comment">// free pages!</span></span><br><span class="line">        <span class="type">size_t</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npages; i++) &#123;</span><br><span class="line">                pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">                pages[i].pp_link = page_free_list;</span><br><span class="line">                page_free_list = &amp;pages[i];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样初始化的操作是在<code>kern/pmap.c</code>中完成的。大概来说，初始化就是拉了这样一个链表，并且将指针<code>page_free_list</code>指向链表的开头。分配内存时，若读取<code>page_free_list</code>指针得到NULL，则说明分配器已经给完了它能够管理的内存，再也给不出来了。</p>
<p>分配器组件的函数都是在操作<code>PageInfo</code>指针，也就是pages数组中的元素，而不是直接操作每个<code>page</code>的地址。如分配函数<code>page_alloc</code>返回的是一个<code>PageInfo</code>，释放<code>page</code>的函数<code>page_free</code>接受的也是一个<code>PageInfo</code>指针。将这个指针和<code>pages</code>数组开头地址做差，可以得到这个<code>PageInfo</code>在数组中的索引，也就可以换算出相应物理地址。</p>
<p>在文件<code>kern/pmap.h</code>中，已经写好了一个函数<code>page2kva</code>，接受一个<code>PageInfo</code>指针，返回得到相应page的虚拟地址。我们可以直接使用这个函数进行换算，这样得到的是虚拟地址，要得到物理地址，还需要在此基础上将地址的数值减去<code>0xf0000000</code>，宏<code>PADDR</code>做了这件事情。</p>
<p>内核的其他代码通过函数<code>page_alloc</code>从<code>free list</code>取出一个<code>page</code>，返回当前<code>page_free_list</code>指针，并令<code>page_free_list</code>指针指向原链表中的下一个元素。</p>
<p>讲义中要求我们实现文件<code>kern/pmap.c</code>中的函数<code>page_alloc</code>，注释中写的比较清楚，分配一个物理页首先需要判断是否还有free的page，如果没有的话就返回NULL。之后从<code>page_free_list</code>中拿出一个page，因为page的指针还指向下一个<code>free_page</code>，所以<code>free_page_list</code>需要指向<code>target-&gt;pp_link</code>，同时<code>target-&gt;pp_link</code>置空。如果需要把页置为0的话，需要转成物理地址然后调用memset。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocates a physical page.  If (alloc_flags &amp; ALLOC_ZERO), fills the entire</span></span><br><span class="line"><span class="comment">// returned physical page with &#x27;\0&#x27; bytes.  Does NOT increment the reference</span></span><br><span class="line"><span class="comment">// count of the page - the caller must do these if necessary (either explicitly</span></span><br><span class="line"><span class="comment">// or via page_insert).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Be sure to set the pp_link field of the allocated page to NULL so</span></span><br><span class="line"><span class="comment">// page_free can check for double-free bugs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns NULL if out of free memory.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: use page2kva and memset</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_alloc</span><span class="params">(<span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// out of memory</span></span><br><span class="line">	<span class="keyword">if</span> (page_free_list == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    <span class="comment">// no changes made so far of course</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">target</span> =</span> page_free_list;</span><br><span class="line">	page_free_list = page_free_list-&gt;pp_link;     <span class="comment">// update free list pointer</span></span><br><span class="line">    target-&gt;pp_link = <span class="literal">NULL</span>;                       <span class="comment">// set to NULL according to notes</span></span><br><span class="line">	<span class="type">char</span> *space_head = page2kva(target);          <span class="comment">// extract kernel virtual memory</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_ZERO) &#123;</span><br><span class="line">        <span class="comment">// zero the page according to flags</span></span><br><span class="line">        <span class="built_in">memset</span>(space_head, <span class="number">0</span>, PGSIZE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要释放一个<code>page</code>，也就是将这个<code>page</code>放回链表。将<code>page_free_list</code>指针指向这个<code>PageInfo</code>结构体，并设置这个结构体的<code>pp_link</code>为之前的<code>page_free_list</code>指针。放回链表的这个<code>page</code>也就变成了<code>free list</code>的开头。</p>
<p>讲义中要求我们实现文件<code>kern/pmap.c</code>中的函数<code>page_free</code>，给的提示足够多了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a page to the free list.</span></span><br><span class="line"><span class="comment">// (This function should only be called when pp-&gt;pp_ref reaches 0.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Fill this function in</span></span><br><span class="line">        <span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line">        <span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line">        <span class="keyword">if</span> (pp-&gt;pp_ref != <span class="number">0</span> || pp-&gt;pp_link != <span class="literal">NULL</span>)</span><br><span class="line">                panic(<span class="string">&quot;Page double free or freeing a referenced page...\n&quot;</span>);</span><br><span class="line">        pp-&gt;pp_link = page_free_list;</span><br><span class="line">        page_free_list = pp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="page分配器boot-alloc"><a href="#page分配器boot-alloc" class="headerlink" title="page分配器boot_alloc"></a>page分配器boot_alloc</h3><p><code>page</code>分配组件完成初始化之前，使用<code>boot_alloc</code>函数分配内存，<code>pages</code>数组就是这个函数分配的。</p>
<p>函数接受一个参数，代表要多少字节内存。函数将这个字节数上调到<code>page</code>大小的边界，也就是调整为离这个字节数最近的4096的整数倍，以求每次分配都是以<code>page</code>为单位的。这个分配器只能在<code>page</code>分配器初始化完成之前使用，之后一律使用<code>page</code>分配器。</p>
<p>实现非常简单，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">boot_alloc</span><span class="params">(<span class="type">uint32_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *nextfree;	<span class="comment">// virtual address of next byte of free memory</span></span><br><span class="line">	<span class="type">char</span> *result;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">		<span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line">		nextfree = ROUNDUP((<span class="type">char</span> *) end, PGSIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// special case according to notes</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span> nextfree;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// note before update</span></span><br><span class="line">	result = nextfree;</span><br><span class="line">	nextfree = ROUNDUP(n, PGSIZE) + nextfree;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// out of memory panic</span></span><br><span class="line">	<span class="keyword">if</span> (nextfree &gt; (<span class="type">char</span> *)<span class="number">0xf0400000</span>) &#123;</span><br><span class="line">	    panic(<span class="string">&quot;boot_alloc: out of memory, nothing changed, returning NULL...\n&quot;</span>);</span><br><span class="line">	    nextfree = result;    <span class="comment">// reset static data</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一次调用这个函数时，必须初始化nextfree指针。这个初始化也很简单，确定了内核本身在内存中的位置后，让<code>boot_alloc</code>函数在内核所占空间的内存之后的第一个<code>page</code>开始分配。表现为代码，就是从连接器中拿到内核的最后一个字节的地址<code>end</code>，将这个指针的数值上调到4096的整数倍。</p>
<p>其中，需要注意的一个是<code>end</code>到底是什么，另一个是<code>ROUNDUP</code>这个宏。其中，<code>end</code>指向内核的<code>bss</code>段的末尾。利用<code>objdump -h kernel</code>可以看出，<code>bss</code>段已经是内核的最后一段。因此，end 指向的是第一个未使用的虚拟内存地址。而<code>ROUNDUP</code>定义在<code>inc/types.h</code>中。</p>
<p>这个end指针是连接器产生的，可以看连接配置文件<code>kern/kernel.ld</code>的53行左右，end指向内核的最后一个字节的下一个字节。</p>
<h3 id="内核内存布局和分配器初始化"><a href="#内核内存布局和分配器初始化" class="headerlink" title="内核内存布局和分配器初始化"></a>内核内存布局和分配器初始化</h3><p>这里正式讲解page分配器的初始化，也就是<code>page_init</code>函数的实现，正确初始化之后的分配器才可以正确使用<code>page_alloc</code>, <code>page_free</code>等函数。要知道分配器如何初始化，就要理解内核内存的布局Layout。</p>
<h4 id="获得物理内存信息"><a href="#获得物理内存信息" class="headerlink" title="获得物理内存信息"></a>获得物理内存信息</h4><p>在初始化内存组件的函数<code>mem_init</code>中，首先调用了函数<code>i386_detect_memory</code>获得了内存硬件信息。追踪一下这个函数的调用，底层实现在<code>kern/kclock.c</code>中，通过一系列汇编指令向硬件要信息。汇编指令如何执行的，我们暂且不关心。</p>
<p>最终得到的内存信息是两个整数<code>npages</code>, <code>npages_basemem</code>，分别代表现有内存的<code>page</code>个数，以及在拓展内存之前的<code>page</code>个数。这些属于原始硬件信息，获得这个信息是为了确定一段IO映射区的位置。</p>
<p>接着研究现有内存布局。</p>
<h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>在文件<code>kern/memlayout.h</code>中，有一个虚拟内存的布局示意图，这个示意图主要描绘用户区内存分配，而不是指出物理内存分布，故我们暂时不细看它。地址0xf0000000以上的区域，也就是我们现在已经映射的区域，是我们关心的区域。宏<code>KERNBASE</code>就是<code>0xf0000000</code>，同时这个地址也是内核栈的开端。以下为了讲述方便，所有地址都是物理内存。</p>
<p>初始化的重要一步是弄清楚哪些物理地址可以分配，哪些不可以。这也就是弄清楚内存布局的意义所在。</p>
<p>我们从KERNBASE开始想起。回顾Lab 1我们知道，内存0xf0000-0x100000是BIOS映射区，在这之前又是ROM映射区，这段空间不能使用，不能被分配器分配出去。查看讲义，我们知道，地址0xa0000-0x100000是ROM, BIOS等IO使用的内存，不可以被分配，初始化时应排除这部分空间。在文件inc/memlayout.h中，宏IOPHYSMEM定义了这段IO段内存的开头。</p>
<p>在<code>IOPHYSMEM</code>之前还有一些内存没有分配，这部分内存是可以使用的。函数<code>i386_detect_memory</code>得到的<code>npages_basemem</code>就是这一段的长度，初始化<code>page</code>分配器时应该包含这一段。可以验证一下，<code>npages_basemem</code>的值为160，这么多个<code>page</code>总的大小为160 * 4096 = 655360 = 0xa0000，确实是<code>IOPHYSMEM</code></p>
<p>从0x100000开始以上的内存就是内核，可以回顾Lab 1中探索内核结构的结果，内核的<code>.text</code>区的虚拟地址为0xf0100000，物理地址正是0x100000。文件<code>inc/memlayout.h</code>中定义的宏<code>EXTPHYSMEM</code>就是0x100000，意思是BIOS以上的内存，称为拓展区，其上限由RAM硬件大小决定。</p>
<p>如果你不记得内核的装载方式，可以使用指令<code>objdump -h obj/kern/kernel</code>查看。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">% obj/kern/kernel:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00002a4d  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       00000bd0  f0102a60  00102a60  00003a60  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .stab         000050d1  f0103630  00103630  00004630  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .stabstr      00001bc3  f0108701  00108701  00009701  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .data         00009300  f010b000  0010b000  0000c000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  5 .got          00000008  f0114300  00114300  00015300  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  6 .got.plt      0000000c  f0114308  00114308  00015308  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  7 .data.rel.local 00001000  f0115000  00115000  00016000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  8 .data.rel.ro.local 00000060  f0116000  00116000  00017000  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  9 .bss          00000681  f0116060  00116060  00017060  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 10 .comment      00000012  00000000  00000000  000176e1  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure></p>
<p>内核占用了拓展区的开头，这些空间不应该被分配器管辖，不应该初始化到链表上。在初始化<code>page</code>分配器之前，调用了几次<code>boot_alloc</code>，这是内核运行时重要数据，他们占用的空间也不应该被分配器管辖。</p>
<p>分配器应该管辖最后一次调用<code>boot_alloc</code>分配的空间之后的空间，这个空间开头的地址可以直接通过<code>boot_alloc(0)</code>得到。</p>
<p>剩余的内存可以自由使用，分配器初始化是应该把链表拉到剩余的空间去。</p>
<h4 id="分配器初始化"><a href="#分配器初始化" class="headerlink" title="分配器初始化"></a>分配器初始化</h4><p><code>mem_init</code>函数中需要添加以下两行，为所有页分配空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span></span><br><span class="line"><span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line"><span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line"><span class="comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span></span><br><span class="line"><span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">pages = (<span class="keyword">struct</span> PageInfo *) boot_alloc(npages * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo));</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, npages * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo));</span><br></pre></td></tr></table></figure>
<p>初始化就是拉链表，并注意排除不应该纳入分配器管辖的空间。总结上面对内存布局的研究，纳入分配器管辖的总共有两部分，分别是<code>basemem</code>部分，也就是0x0-0xa0000，和<code>boot_alloc</code>最后分配的空间的后面的部分，排除了内核，和一些<code>boot_alloc</code>取得的空间。</p>
<p><code>boot_alloc</code>即将分配的空间可以给函数传0直接得到，这是函数的特殊处理。由于<code>boot_alloc</code>以<code>page</code>为单位分配，这样得到的地址是一个<code>page</code>的首地址，这个<code>page</code>的索引可以轻易获得：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = PADDR(boot_alloc(<span class="number">0</span>)) / PGSIZE;</span><br></pre></td></tr></table></figure></p>
<p>最后分配得到的应该如下图所示，其中basemem部分省略了指针指向。<br><img src="/img/v2-f322c1238767ca4ae172b69548bd4b08_720w.png" alt=""></p>
<p>完整实现如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.mark page 0 as in use</span></span><br><span class="line"><span class="comment">// 这样我们就可以保留实模式IDT和BIOS结构，以备不时之需。</span></span><br><span class="line">pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// pages[0].pp_link = NULL;</span></span><br><span class="line"><span class="comment">// page_free_lis = &amp;pages[0];</span></span><br><span class="line"><span class="comment">// 被注释掉的这两句不对，因为这个开头的页不能放到free_list中被分配。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)is free.</span></span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">    pages[i].pp_link = page_free_list;</span><br><span class="line">    page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Then comes the IO hole[IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line"><span class="comment">//     never be allocated.</span></span><br><span class="line"><span class="keyword">for</span> (; i &lt; EXTPHYSMEM/PGSIZE; i ++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line"><span class="comment">// 还要注意哪些内存已经被内核、页表使用了！</span></span><br><span class="line"><span class="comment">// first需要向上取整对齐。同时此时已经工作在虚拟地址模式（entry.S对内存进行了映射）下，</span></span><br><span class="line"><span class="comment">// 需要求得first的物理地址</span></span><br><span class="line"><span class="type">physaddr_t</span> first_free_addr = PADDR(boot_alloc(<span class="number">0</span>));</span><br><span class="line"><span class="type">size_t</span> first_free_page = first_free_addr/PGSIZE;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; first_free_page; i ++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mark other pages as free</span></span><br><span class="line"><span class="keyword">for</span>(; i &lt; npages; i ++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">    pages[i].pp_link = page_free_list;</span><br><span class="line">    page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以在<code>inc/memlayout.h</code>中找到 IO hole 的定义，可回顾lab 1：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// At IOPHYSMEM (640K) there is a 384K hole for I/O.  From the kernel,</span></span><br><span class="line"><span class="comment">// IOPHYSMEM can be addressed at KERNBASE + IOPHYSMEM.  The hole ends</span></span><br><span class="line"><span class="comment">// at physical address EXTPHYSMEM.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOPHYSMEM   0x0A0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTPHYSMEM  0x100000</span></span><br></pre></td></tr></table></figure></p>
<p>第四种情况略有难度，实际需要利用<code>boot_alloc</code>函数来找到第一个能分配的页面。相同的思想在已经写好的<code>check_free_page_list</code>函数中也可以找到。关键代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> first_free_address = PADDR(boot_alloc(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><br>尤其需要注意的是，由于<code>boot_alloc</code>返回的是内核虚拟地址 (kernel virtual address)，一定要利用 PADDR 转为物理地址。在 kern/pmap.h 中可以找到 PADDR 的定义，实际就是减了一个 F0000000。</p>
<p>完成以上步骤，编译运行，看到<code>check_page_alloc() succeeded!</code>则成功。</p>
<h2 id="Lab-2-Part-2：内核内存映射"><a href="#Lab-2-Part-2：内核内存映射" class="headerlink" title="Lab 2 Part 2：内核内存映射"></a>Lab 2 Part 2：内核内存映射</h2><p>上一篇Part 1实现了分配器，用的是非常简单的链表管理方式。分配器实现的是剩余空间管理Free Space Management，有了剩余空间管理，接下来就是实际使用这些空间了。</p>
<p>这个part帮助我们正式建立虚拟内存Virtual Memory和物理内存Physical Memory之间的关系，明确了概念，完成了实现。在很多操作系统教材中，内存映射放在Free Space Management之前讲。在真正实现内存管理的时候，必须先有分配器、后有其它的，和讲解知识相反。</p>
<h3 id="虚拟地址、线性地址和物理地址"><a href="#虚拟地址、线性地址和物理地址" class="headerlink" title="虚拟地址、线性地址和物理地址"></a>虚拟地址、线性地址和物理地址</h3><p>虚拟地址有段选择器和段内偏移组成，线性地址则是在段地址翻译之后、页地址翻译之前的地址，物理地址则是在段地址翻译、页地址翻译之后的最终的地址，是你从硬件中取数据的地址。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">           Selector  +--------------+         +-----------+</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     | Segmentation |         |  Paging   |</span><br><span class="line">Software             |              |--------&gt;|           |----------&gt;  RAM</span><br><span class="line">            Offset   |  Mechanism   |         | Mechanism |</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     +--------------+         +-----------+</span><br><span class="line">            Virtual                   Linear                Physical</span><br></pre></td></tr></table></figure></p>
<p>C 指针是<strong>虚拟地址的“偏移量”</strong>组件。在<code>boot/boot.S</code>中，我们安装了一个全局描述符表 (GDT)，它通过将所有段基地址设置为 0 并将限制设置为 0xffffffff 来有效地禁用段转换。因此“选择器”不起作用，线性地址总是等于虚拟地址的偏移量。在实验 3 中，我们将不得不与分段进行更多交互以设置权限级别，但是对于记忆翻译，我们可以在整个 JOS 实验中忽略分段，而只关注页面翻译。</p>
<p>回想一下，在实验 1 的第 3 部分中，我们安装了一个简单的页表，以便内核可以在其链接地址 0xf0100000 处运行，即使它实际上加载到 ROM BIOS 上方的物理内存中 0x00100000。这个页表只映射了 4MB 的内存。在本实验中您要为 JOS 设置的虚拟地址空间布局中，我们将扩展它以映射从虚拟地址 0xf0000000 开始的前 256MB 物理内存，并映射虚拟地址空间的许多其他区域。</p>
<h3 id="x86内存管理机制"><a href="#x86内存管理机制" class="headerlink" title="x86内存管理机制"></a>x86内存管理机制</h3><h4 id="虚拟、线性和物理地址"><a href="#虚拟、线性和物理地址" class="headerlink" title="虚拟、线性和物理地址"></a>虚拟、线性和物理地址</h4><ul>
<li>虚拟地址<ul>
<li>最原始的地址，也是 C/C++ 指针使用的地址。由前 16bit 段 (segment) 选择器和后 32bit 段内的偏移 (offset) 组成，显然一个段大小为 4GB。通过虚拟地址可以获得线性地址。</li>
</ul>
</li>
<li>线性地址<ul>
<li>前 10bit 为页目录项(page directory entry, PDE)，即该地址在页目录中的索引。中间 10bit 为页表项(page table entry, PTE)，代表在页表中的索引，最后 12bit 为偏移，也就是每页 4kB。通过线性地址可以获得物理地址。</li>
</ul>
</li>
<li>物理地址<ul>
<li>经过段转换以及页面转换，最终在 RAM 的硬件总线上的地址。</li>
</ul>
</li>
</ul>
<h4 id="两步映射总览"><a href="#两步映射总览" class="headerlink" title="两步映射总览"></a>两步映射总览</h4><p>x86建立了两次映射，程序给出地址，经过这两次翻译之后，才输出从到总线交给内存芯片。这两次映射分别为Segment Translation和Page Translation。</p>
<p>Segment Translation将虚拟地址转化为线性地址Linear Address，Page Translation将线性地址转化为物理地址，也就是真正用来索引内存的地址。</p>
<p>在我们的项目中，还没有对Segment Translation做特殊处理。Lab讲义中说明了，Segment Translation没有映射虚拟地址，线性地址和虚拟地址相同。后文中统一使用“虚拟地址”同时代指虚拟地址和线性地址，因为它们就是一样的。</p>
<p>我们暂时没有使用复杂的Segment Translation，所以Page Translation就是我们的重点，以下简单介绍Segment Translation，着重理解Page Translation。</p>
<h4 id="Segment-Translation"><a href="#Segment-Translation" class="headerlink" title="Segment Translation"></a>Segment Translation</h4><p>Segment Translation的过程可以如下图表示：<br><img src="/img/v2-e856328378b79f84cedece695adee101_b.gif" alt=""></p>
<p>由一个事先指定的selector选择器，从一个描述符表descriptor table中读出一个描述符descriptor。由这个描述符读出一个基地址base address，虚拟地址作为一种偏置offset，加到基地址上，就得到了linear address。</p>
<h4 id="描述符表Descriptor-Table"><a href="#描述符表Descriptor-Table" class="headerlink" title="描述符表Descriptor Table"></a>描述符表Descriptor Table</h4><p>描述符表必须事先指定，虚拟地址中不包含关于描述符表的信息。</p>
<p>有两种描述符表，分别为全局描述符表Global Descriptor Table (GDT)和本地描述符表Local Descriptor Table (LDT)，分别使用寄存器<code>GDTR</code>，<code>LDTR</code>获得。x86有访问这些寄存器的指令，我们没有直接使用，也就不关心了。</p>
<h4 id="描述符Descriptor"><a href="#描述符Descriptor" class="headerlink" title="描述符Descriptor"></a>描述符Descriptor</h4><p>通过selector索引描述符表得到的描述符，除了基地址之外，也包含了其他信息，具体结构如下图：<br><img src="/img/v2-9a1b68fd5f1fbcf1e163f4811ed576ad_b.gif" alt=""></p>
<p>这是两种不同的结构，其中的区别只有DPL和TYPE之间的那个bit，以及TYPE的位置，我们暂时不关心它们的区别。这里需要注意的是P域，也就是Segment Present bit，表示这个segment是否在内存中，之后的Page Translation也有类似机制。</p>
<h4 id="选择符Selector"><a href="#选择符Selector" class="headerlink" title="选择符Selector"></a>选择符Selector</h4><p>选择符不但有描述符表的索引，还有选择描述符表GDT/LDT的bit，以及发出的请求所在的优先级，用于区分User Level Access和Kernel Level Access。我们也暂时不关心它们的区别。结构如下：<br><img src="/img/v2-480829b29d4400a2182dcb58f31603e7_b.gif" alt=""></p>
<h4 id="和segment有关的寄存器"><a href="#和segment有关的寄存器" class="headerlink" title="和segment有关的寄存器"></a>和segment有关的寄存器</h4><p>虚拟地址只是一个segment的偏置，本身不包含和segment有关的信息。当前使用的描述符表、描述符选择符，都要另外存储在一些寄存器里面。当使用和跳转有关的指令call, jmp时，这些寄存器被隐式地访问了，从而帮助计算新的地址。</p>
<p>segment寄存器有两个部分，可以直接操作和读取的是16bit的selector域，修改selector域之后，硬件自动将对应的描述符从描述符表中读取进不显示的descriptor域，这样就方便了后续操作。<br><img src="/img/v2-f00aab967b70bdb3afd7743d902dfbdf_b.gif" alt=""></p>
<h3 id="Page-Translation"><a href="#Page-Translation" class="headerlink" title="Page Translation"></a>Page Translation</h3><p><img src="/img/v2-23f6d73c9f99f646458aac3b79e50e91_b.jpg" alt=""></p>
<p>虚拟地址，也就是线性地址，被拆成了三部分，都是一种索引<code>index</code>，分别索引的是<code>Page Directory</code>, <code>Page Table</code>, <code>Page Frame</code>。从<code>page directory</code>中读出<code>page table</code>的地址，在从读到的<code>page table</code>地址中读到<code>page frame</code>的地址，索引<code>page frame</code>之后，就得到相应物理地址上的内容。</p>
<p>对于开发者来说，<code>page directory</code>, <code>page table</code>都是两个数组，拿到<code>page directory</code>的头部指针，和虚拟地址一起，就可以确定物理地址。</p>
<h4 id="每个域对应长度"><a href="#每个域对应长度" class="headerlink" title="每个域对应长度"></a>每个域对应长度</h4><p>线性地址，也就是虚拟地址，的格式如下：<br><img src="/img/v2-57da610073dc97659f6a52683438bdd7_b.webp" alt=""></p>
<p>每个域包含bit的个数，也就是长度，决定了每个域对应的数组的长度。我们可以很方便地得到每个域对应的长度：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">page_len = <span class="number">2</span> ** <span class="number">12</span> = <span class="number">4096</span>            <span class="comment">// OFFSET</span></span><br><span class="line">page_table_len = <span class="number">2</span> ** <span class="number">10</span> = <span class="number">1024</span>      <span class="comment">// PAGE</span></span><br><span class="line">page_dir_len = <span class="number">2</span> ** <span class="number">10</span> = <span class="number">1024</span>        <span class="comment">// DIR</span></span><br></pre></td></tr></table></figure></p>
<p>如果你不太理解这种计算方法，可以回到最开始的排列组合。每个bit代表两种状态，有n个bit也就有<code>2^n</code>种状态，也就是这个域可以产生多少索引。</p>
<p>以上计算出了每个域的长度，单位不是字节，而是索引个数。</p>
<p>这些长度应该这样看。一个<code>page directory</code>指向1024个<code>page directory entry</code>，一个<code>page directory entry</code>指向了1024个<code>page table</code>，一个<code>page table entry</code>指向了1024个<code>page frame</code>，一个<code>page frame</code>中包含4096Bytes。</p>
<h4 id="Entry格式"><a href="#Entry格式" class="headerlink" title="Entry格式"></a>Entry格式</h4><p>page directory entry, page table entry具有相同格式，如下：<br><img src="/img/v2-7645f7dc2a45edeef40540938cc55d8c_b.webp" alt=""></p>
<p><code>DIR</code>, <code>PAGE</code>域长度相同，而<code>entry</code>的格式也相同，说明<code>page directory</code>和<code>page table</code>其实是相同结构的嵌套。可以把<code>page directory</code>理解为高一级的<code>page table</code>，整个内存管理形成两个层级。一个<code>page table</code>自身就是一个<code>page</code>，是<code>page directory</code>管理的，而<code>page table</code>又管理了<code>page frame</code>。</p>
<p>同理，我们可以把虚拟地址拆得更细，从而创造更多的层级，不过这是CPU设计的事情了。</p>
<p>对于<code>page directory</code>来说，<code>entry</code>中12-31位上的<code>PAGE FRAME ADDRESS</code>就是一个<code>page table</code>的基地址。对于<code>page table</code>来说，这个地址是一个<code>page frame</code>的基地址。通过一个虚拟地址，获得3个索引，一次访问这3个结构，就可以得到物理地址了。</p>
<p>这里还要注意一下，bit 0是Present Bit，表示当前entry中的信息是否可以用于映射。要是<code>Present Bit</code>设置为0，则这个entry不包含有效信息。索引各种<code>page directory/table</code>时，必须先检查这个bit。</p>
<p>entry中的其他部分暂时不使用。</p>
<h3 id="可以使用的工具代码"><a href="#可以使用的工具代码" class="headerlink" title="可以使用的工具代码"></a>可以使用的工具代码</h3><p>在开始写代码之前，需要看看项目中已经提供好了哪些可以使用的工具。</p>
<p>首先是上个part中写好的分配器，<code>boot_alloc</code>已经不使用了，主要是<code>page_alloc/page_free</code>在使用。然后就是三个头文件<code>mmu.h</code>, <code>memlayout.h</code>, <code>pmap.h</code>中的各种小函数了</p>
<p>在 JOS 中，由于只有一个段，所以虚拟地址数值上等于线性地址。</p>
<p>JOS 内核常常需要读取或更改仅知道物理地址的内存。例如，添加一个到页表的映射要求分配物理内存来存储页目录并初始化内存。然而，内核和其他任何程序一样，无法绕过虚拟内存转换这个步骤，因此不能直接使用物理地址。JOS 将从 0x00000000 开始的物理内存映射到 0xf0000000 的其中一个原因就是需要使内核能读写仅知道物理地址的内存。为了把物理地址转为虚拟地址，内核需要给物理地址加上 0xf0000000。这就是 KADDR 函数做的事。</p>
<p>同样，JOS 内核有时也需要从虚拟地址获得物理地址。内核的全局变量和由 boot_alloc 分配的内存都在内核被加载的区域，即从0xf0000000开始的地方。因此，若需要将虚拟地址转为物理地址，直接减去0xf0000000即可。这就是 PADDR 函数做的事。</p>
<h4 id="mmu-h"><a href="#mmu-h" class="headerlink" title="mmu.h"></a>mmu.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性地址 &#x27;la&#x27; 可以被分成三块:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// +--------10------+-------10-------+---------12----------+</span></span><br><span class="line"><span class="comment">// | Page Directory |   Page Table   | Offset within Page  |</span></span><br><span class="line"><span class="comment">// |      Index     |      Index     |                     |</span></span><br><span class="line"><span class="comment">// +----------------+----------------+---------------------+</span></span><br><span class="line"><span class="comment">//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/</span></span><br><span class="line"><span class="comment">//  \---------- PGNUM(la) ----------/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// PDX, PTX, PGOFF, 和 PGNUM 宏将线性地址进行切分</span></span><br><span class="line"><span class="comment">// 如果需要通过PDX(la), PTX(la), and PGOFF(la)组织一个线性地址la的话</span></span><br><span class="line"><span class="comment">// 使用 PGADDR(PDX(la), PTX(la), PGOFF(la)).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page number field of address</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGNUM(la)       (((uintptr_t) (la)) &gt;&gt; PTXSHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page directory index</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDX(la)         ((((uintptr_t) (la)) &gt;&gt; PDXSHIFT) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page table index</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTX(la)         ((((uintptr_t) (la)) &gt;&gt; PTXSHIFT) &amp; 0x3FF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// offset in page</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGOFF(la)       (((uintptr_t) (la)) &amp; 0xFFF)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// construct linear address from indexes and offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGADDR(d, t, o) ((void*) ((d) &lt;&lt; PDXSHIFT | (t) &lt;&lt; PTXSHIFT | (o)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Page directory and page table constants.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPDENTRIES      1024            <span class="comment">// page directory entries per page directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NPTENTRIES      1024            <span class="comment">// page table entries per page table</span></span></span><br></pre></td></tr></table></figure>
<p>还有一些页表以及页目录会用到的标识位，exercise 4 中用得到的用中文注释：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Page table/directory entry flags.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_P       0x001   <span class="comment">// 该项是否存在</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W       0x002   <span class="comment">// 可写入</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U       0x004   <span class="comment">// 用户有权限读取</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PWT     0x008   <span class="comment">// Write-Through</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PCD     0x010   <span class="comment">// Cache-Disable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A       0x020   <span class="comment">// Accessed</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_D       0x040   <span class="comment">// Dirty</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PS      0x080   <span class="comment">// Page Size</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_G       0x100   <span class="comment">// Global</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="根据虚拟地址取出Page-Table-Entry"><a href="#根据虚拟地址取出Page-Table-Entry" class="headerlink" title="根据虚拟地址取出Page Table Entry"></a>根据虚拟地址取出Page Table Entry</h3><p>这里开始实现Lab讲义中指定要实现的函数，先是<code>pgdir_walk</code>函数，在文件<code>kern/pmap.c</code>中。这个函数接受一个<code>page directory</code>和一个虚拟地址，要求得到虚拟地址在这个<code>page directory</code>下对应的<code>page table entry</code>。</p>
<p>先拆分虚拟地址，根据虚拟地址取出<code>page directory/table/frame</code>中的索引。用到的三个宏函数在文件<code>mmu.h</code>中，也就是通过移位&gt;&gt;和与&amp;从一串bit中取出一些bit。需要完成如图的转换，返回对应的页表地址，即红圈圈出的部分的虚拟地址：<br><img src="/img/4482847-1941fd6b845db3b5.webp" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">pgdir_walk</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> create)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数1: 页目录项指针</span></span><br><span class="line">    <span class="comment">// 参数2: 线性地址，JOS 中等于虚拟地址</span></span><br><span class="line">    <span class="comment">// 参数3: 若页目录项不存在是否创建</span></span><br><span class="line">    <span class="comment">// 返回: 页表项指针</span></span><br><span class="line">    <span class="type">uint32_t</span> page_dir_idx = PDX(va);</span><br><span class="line">    <span class="type">uint32_t</span> page_tab_idx = PTX(va);</span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="keyword">if</span> (pgdir[page_dir_idx] &amp; PTE_P) &#123;</span><br><span class="line">        pgtab = KADDR(PTE_ADDR(pgdir[page_dir_idx]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (create) &#123;</span><br><span class="line">            <span class="keyword">struct</span> PageInfo *new_pageInfo = page_alloc(ALLOC_ZERO);</span><br><span class="line">            <span class="keyword">if</span> (new_pageInfo) &#123;</span><br><span class="line">                new_pageInfo-&gt;pp_ref += <span class="number">1</span>;</span><br><span class="line">                pgtab = (<span class="type">pte_t</span> *) page2kva(new_pageInfo);</span><br><span class="line">                <span class="comment">// 修改页目录的flag，根据 check_page 函数中用到的属性。</span></span><br><span class="line">                <span class="comment">// 因为分配以页为单位对齐，必然后 12bit 为0</span></span><br><span class="line">                pgdir[page_dir_idx] = PADDR(pgtab) | PTE_P | PTE_W | PTE_U;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;pgtab[page_tab_idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要将<code>PageInfo</code>结构体的指针转换为物理地址，而不是虚拟地址。这个操作的依据是80386 Programmer’s Reference Manual的规定，在<code>entry</code>中放置的一定是物理地址。更新完<code>page directory entry</code>之后，原函数<code>pgdir_walk</code>根据虚拟地址中的索引，从新的<code>page directory entry</code>中获得新的<code>page table</code>地址，并返回。</p>
<p>通过宏函数<code>KADDR</code>转化为虚拟地址，而不是直接从page directory entry中读取出来的物理地址。</p>
<h3 id="映射一段空间"><a href="#映射一段空间" class="headerlink" title="映射一段空间"></a>映射一段空间</h3><p>第二个要实现的函数是<code>boot_map_region</code>，这个函数将虚拟地址中的几个<code>page</code>映射到连续的物理地址上。代码很简单，利用刚刚写好的函数<code>pgdir_walk</code>，给参数<code>create</code>传1，就可以方便地建立<code>page table</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_map_region</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="type">size_t</span> end_addr = va + size;</span><br><span class="line">    <span class="keyword">for</span> (;va &lt; end_addr; va += PGSIZE, pa += PGSIZE) &#123;</span><br><span class="line">        pgtab = pgdir_walk(pgdir, (<span class="type">void</span> *)va, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!pgtab) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *pgtab = pa | perm | PTE_P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>boot_map_region</code>中的 for 循环一开始就判断<code>va &gt; end_addr</code>。这是显然的，因为<code>end_addr = 0xf0000000 + 0x1000000 = 0x00000000</code>。因此，实际上<code>boot_map_region</code>的更佳实现是直接用页数，避免溢出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_map_region</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="type">size_t</span> pg_num = PGNUM(size);</span><br><span class="line">    cprintf(<span class="string">&quot;map region size = %d, %d pages\n&quot;</span>,size, pg_num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pg_num; i ++) &#123;</span><br><span class="line">        pgtab = pgdir_walk(pgdir, (<span class="type">void</span> *)va, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!pgtab) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *pgtab = pa | perm | PTE_P;</span><br><span class="line">        va += PGSIZE;</span><br><span class="line">        pa += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注释中提示我们，这是静态映射，不要增加每个<code>page</code>对应的<code>PageInfo</code>结构体的引用计数<code>pp_ref</code>。</p>
<p>根据各个函数的依赖关系，下一个编写<code>page_lookup</code>函数。作用是查找虚拟地址对应的物理页描述。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_lookup</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, <span class="type">pte_t</span> **pte_store)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数1: 页目录指针</span></span><br><span class="line">    <span class="comment">// 参数2: 线性地址，JOS 中等于虚拟地址</span></span><br><span class="line">    <span class="comment">// 参数3: 指向页表指针的指针</span></span><br><span class="line">    <span class="comment">// 返回: 页描述结构体指针</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab = pgdir_walk(pgdir, va, <span class="number">0</span>);  <span class="comment">// 不创建，只查找</span></span><br><span class="line">    <span class="keyword">if</span> (!pgtab) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 未找到则返回 NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pte_store) &#123;</span><br><span class="line">        *pte_store = pgtab;  <span class="comment">// 附加保存一个指向找到的页表的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pa2page(PTE_ADDR(*pgtab));  <span class="comment">//  返回页面描述</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处再次用到了<code>PTE_ADDR</code>这个宏。其作用是将页表指针指向的内容转为物理地址。这里还是要注意，从<code>page table</code>中拿出<code>page frame</code>的为物理地址，不是虚拟地址。</p>
<p><code>page_remove</code>函数作用是移除一个虚拟地址与对应的物理页的映射。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_remove</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab;</span><br><span class="line">    <span class="type">pte_t</span> **pte_store = &amp;pgtab;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pInfo</span> =</span> page_lookup(pgdir, va, pte_store);</span><br><span class="line">    <span class="keyword">if</span> (!pInfo) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    page_decref(pInfo);</span><br><span class="line">    *pgtab = <span class="number">0</span>;  <span class="comment">// 将内容清0，即无法再根据页表内容得到物理地址。</span></span><br><span class="line">    tlb_invalidate(pgdir, va);  <span class="comment">// 通知tlb失效。tlb是个高速缓存，用来缓存查找记录增加查找速度。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数还减小了<code>PageInfo</code>结构体的引用计数<code>pp_ref</code>，并让TLB缓存失效了。</p>
<p><code>page_insert</code>函数作用是建立一个虚拟地址与物理页的映射，与<code>page_remove</code>对应。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">page_insert</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="keyword">struct</span> PageInfo *pp, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数1: 页目录指针</span></span><br><span class="line">    <span class="comment">// 参数2: 页描述结构体指针</span></span><br><span class="line">    <span class="comment">// 参数3: 线性地址，JOS 中等于虚拟地址</span></span><br><span class="line">    <span class="comment">// 参数4: 权限</span></span><br><span class="line">    <span class="comment">// 返回: 成功(0)，失败(-E_NO_MEM)</span></span><br><span class="line">    <span class="type">pte_t</span> *pgtab = pgdir_walk(pgdir, va, <span class="number">1</span>);  <span class="comment">// 查找该虚拟地址对应的页表项，不存在则建立。</span></span><br><span class="line">    <span class="keyword">if</span> (!pgtab) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;  <span class="comment">// 空间不足</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*pgtab &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// 页表项已经存在，即该虚拟地址已经映射到物理页了</span></span><br><span class="line">        <span class="keyword">if</span> (page2pa(pp) == PTE_ADDR(*pgtab)) &#123;</span><br><span class="line">            <span class="comment">// 如果映射到与之前相同的页，仅更改权限，不增加引用</span></span><br><span class="line">            *pgtab = page2pa(pp) | perm | PTE_P;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是更新映射的物理页，则要删除之前的映射关系</span></span><br><span class="line">            page_remove(pgdir, va);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *pgtab = page2pa(pp) | perm | PTE_P;</span><br><span class="line">    pp-&gt;pp_ref++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，如果同样的虚拟页映射到了同样的物理页，如果不做特殊处理仍然调用<code>page_remove</code>后再增加引用次数，可能会出现以下情况：</p>
<ul>
<li>当该物理页<code>ref = 1</code>，经过<code>page_remove</code>后会被加入空闲页链表。然而，在函数最后还需要增加其引用计数，导致<code>page_free_list</code>中出现了非空闲页。</li>
</ul>
<p>课程中希望尽量不要做特例处理，即避免使用if，于是可以这么改进：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">page_insert</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="keyword">struct</span> PageInfo *pp, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pte_t</span> *pgtab = pgdir_walk(pgdir, va, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pgtab) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里一定要提前增加引用 </span></span><br><span class="line">    pp-&gt;pp_ref++;</span><br><span class="line">    <span class="keyword">if</span> (*pgtab &amp; PTE_P) &#123;</span><br><span class="line">        page_remove(pgdir, va);</span><br><span class="line">    &#125;</span><br><span class="line">    *pgtab = page2pa(pp) | perm | PTE_P;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上只要区分开了entry中保存的都是物理地址就好弄了。</p>
<h3 id="Page-Table组织总结"><a href="#Page-Table组织总结" class="headerlink" title="Page Table组织总结"></a>Page Table组织总结</h3><p>在Lab 2中，我们让代码跑过了各种<code>check_*</code>函数，但是没有对其中的原理充分深究。这里总结一下。</p>
<p>内核的内存管理是以<code>page</code>为单位的，称为一个<code>Page Frame</code>，一个<code>page</code>的大小是4096Bytes，也就是4KB。内核使用<code>free list</code>链表的方式管理尚未分配的空间，实现非常简单。</p>
<p>要使用内存，必须建立虚拟地址映射。无论是C代码还是汇编代码，要访问内存，都是通过虚拟地址。C代码中，所有指针的值都必须为虚拟地址，代码才能正确执行，否则<code>*</code>访问不到想要的地址。</p>
<p>虚拟地址映射是通过一个<strong>二级table</strong>实现的，两个层级分别被称为<code>Page Directory</code>和<code>Page Table</code>。两者在结构上没有区别，只是相同结构的相互嵌套。虚拟地址不包含任何<code>table</code>的地址，只包含<code>table</code>的索引。必须事先指定好<code>Page Directory</code>的地址，利用这个地址得到<code>Page Directory Entry</code>，从而得到<code>Page Table</code>地址，从而得到<code>Page Frame</code>地址，需要且仅需要指定<code>Page Directory</code>地址。<code>Page Directory</code>地址是寄存器<code>cr3</code>，设置<code>cr3</code>的行为会导致硬件执行切换<code>Page Directory</code>配套的一系列操作。</p>
<p>在函数<code>mem_init</code>之前，内核加载时简单地初始化了一个<code>Page Directory</code>，将<code>0xf0000000</code>开始的一段地址映射到<code>0x0</code>开始的一段地址，以方便正式初始化虚拟地址映射之前的操作。在<code>mem_init</code>函数的最后，我们需要初始化一个真正的<code>kern_pgdir</code>，并将寄存器<code>cr3</code>设置为它的地址。</p>
<p>最终得到的虚拟地址布局为文件<code>memlayout.h</code>中的注释（再来一遍，这个图画的真的太好了）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Virtual memory map:                                Permissions</span><br><span class="line"> *                                                    kernel/user</span><br><span class="line"> *</span><br><span class="line"> *    4 Gig --------&gt;  +------------------------------+</span><br><span class="line"> *                     |                              | RW/--</span><br><span class="line"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"> *                     :              .               :</span><br><span class="line"> *                     :              .               :</span><br><span class="line"> *                     :              .               :</span><br><span class="line"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</span><br><span class="line"> *                     |                              | RW/--</span><br><span class="line"> *                     |   Remapped Physical Memory   | RW/--</span><br><span class="line"> *                     |                              | RW/--</span><br><span class="line"> *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+</span><br><span class="line"> *    KSTACKTOP        |     CPU0&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span><br><span class="line"> *                     | - - - - - - - - - - - - - - -|                   |</span><br><span class="line"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span><br><span class="line"> *                     +------------------------------+                   |</span><br><span class="line"> *                     |     CPU1&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span><br><span class="line"> *                     | - - - - - - - - - - - - - - -|                 PTSIZE</span><br><span class="line"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span><br><span class="line"> *                     +------------------------------+                   |</span><br><span class="line"> *                     :              .               :                   |</span><br><span class="line"> *                     :              .               :                   |</span><br><span class="line"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span><br><span class="line"> *                     |       Memory-mapped I/O      | RW/--  PTSIZE</span><br><span class="line"> * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span><br><span class="line"> *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE</span><br><span class="line"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</span><br><span class="line"> *                     |          RO PAGES            | R-/R-  PTSIZE</span><br><span class="line"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span><br><span class="line"> *                     |           RO ENVS            | R-/R-  PTSIZE</span><br><span class="line"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span><br><span class="line"> * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE</span><br><span class="line"> *                     +------------------------------+ 0xeebff000</span><br><span class="line"> *                     |       Empty Memory (*)       | --/--  PGSIZE</span><br><span class="line"> *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span><br><span class="line"> *                     |      Normal User Stack       | RW/RW  PGSIZE</span><br><span class="line"> *                     +------------------------------+ 0xeebfd000</span><br><span class="line"> *                     |                              |</span><br><span class="line"> *                     |                              |</span><br><span class="line"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"> *                     .                              .</span><br><span class="line"> *                     .                              .</span><br><span class="line"> *                     .                              .</span><br><span class="line"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</span><br><span class="line"> *                     |     Program Data &amp; Heap      |</span><br><span class="line"> *    UTEXT --------&gt;  +------------------------------+ 0x00800000</span><br><span class="line"> *    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE</span><br><span class="line"> *                     |                              |</span><br><span class="line"> *    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+</span><br><span class="line"> *                     |       Empty Memory (*)       |                   |</span><br><span class="line"> *                     | - - - - - - - - - - - - - - -|                   |</span><br><span class="line"> *                     |  User STAB Data (optional)   |                 PTSIZE</span><br><span class="line"> *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        |</span><br><span class="line"> *                     |       Empty Memory (*)       |                   |</span><br><span class="line"> *    0 ------------&gt;  +------------------------------+                 --+</span><br><span class="line"> *</span><br><span class="line"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="line"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="line"> *     there if desired.  JOS user programs map pages temporarily at UTEMP.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
<h3 id="建立映射的函数们"><a href="#建立映射的函数们" class="headerlink" title="建立映射的函数们"></a>建立映射的函数们</h3><p>我们已经写好了很多函数，在把它们用起来之前，再浏览一遍它们的目的。</p>
<p>首先是分配器，对未分配的物理内存进行管理。在初始化函数<code>mem_init</code>中调用<code>page_init</code>初始化了这个分配器，之后通过<code>page_alloc</code>，<code>page_free</code>获取和释放<code>page</code>。</p>
<p>要正确建立映射，首先需要正确方便地索引<code>Page Directory</code>，<code>Page Table</code>。函数<code>pgdir_walk</code>，根据指定<code>Page Directory</code>索引出<code>Page Table Entry</code>。函数<code>page_lookup</code>基于<code>pgdir_walk</code>，进一步得到这个<code>Page Table Entry</code>对应的物理地址。</p>
<p>地址映射可以建立或移除，我们都写好了方便的函数。函数<code>boot_map_region</code>用于给内核做映射，只处理0xf0000000以上虚拟空间。函数<code>page_insert</code>，<code>page_remove</code>处理其他空间的映射，分别建立映射、移除映射。</p>
<p>其他函数对以上起辅助作用。</p>
<h3 id="为内核建立虚拟地址映射"><a href="#为内核建立虚拟地址映射" class="headerlink" title="为内核建立虚拟地址映射"></a>为内核建立虚拟地址映射</h3><p>Lab 2 Part 3要求我们补全函数<code>mem_init</code>后面的部分，也就是给内核配置好<code>kern_pgdir</code>，并设置寄存器<code>cr3</code>。在这里使用的函数都是<code>boot_map_region</code>。</p>
<p>JOS 将处理器的 32 位线性地址空间分为两部分。我们将在 lab3 中开始加载和运行的用户环境（进程）将控制下部的布局和内容，而内核始终保持对上部的完全控制。分隔线由<code>inc/memlayout.h</code>中的符号<code>ULIM</code>随意定义，为内核保留大约 256MB 的虚拟地址空间。这就解释了为什么我们需要在实验室 1 中给内核一个如此高的链接地址：否则内核的虚拟地址空间将没有足够的空间同时映射到它下面的用户环境。</p>
<h4 id="权限和故障隔离"><a href="#权限和故障隔离" class="headerlink" title="权限和故障隔离"></a>权限和故障隔离</h4><p>由于内核和用户内存都存在于每个环境的地址空间中，我们将不得不在 x86 页表中使用权限位来允许用户代码仅访问地址空间的用户部分。否则用户代码中的错误可能会覆盖内核数据，导致崩溃或更微妙的故障；用户代码也可能窃取其他环境的私人数据。请注意，可写权限位<code>PTE_W</code>会影响用户和内核代码！</p>
<p>用户环境将无权访问<code>ULIM</code>之上的任何内存，而内核将能够读写此内存。对于地址范围<code>[UTOP,ULIM)</code>，内核和用户环境都有相同的权限：可以读但不能写这个地址范围。该地址范围用于向用户环境公开某些只读的内核数据结构。最后，UTOP下面的地址空间是供用户环境使用的；用户环境将设置访问此内存的权限。</p>
<p>JOS 将处理器的 32 位线性地址分为用户环境（低位地址）以及内核环境（高位地址）。分界线在<code>inc/memlayout.h</code>中定义为<code>ULIM</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE    0xF0000000</span></span><br><span class="line"><span class="comment">// Kernel stack.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACKTOP   KERNBASE</span></span><br><span class="line"><span class="comment">// Memory-mapped IO.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMIOLIM     (KSTACKTOP - PTSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMIOBASE    (MMIOLIM - PTSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULIM        (MMIOBASE)</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>PTSIZE</code>被定义为一个页目录项映射的 Byte，一个页目录中有1024个页表项，每个页表项可映射一个物理页。故为 4MB。可算得 ULIM = 0xf0000000 - 0x00400000 - 0x00400000 = 0xef800000，可通过查看<code>inc/memlayout</code>确认。</p>
<p>我们还需要给物理页表设置权限以确保用户只能访问用户环境的地址空间。否则，用户的代码可能会覆盖内核数据，造成严重后果。用户环境应该在高于 ULIM 的内存中没有任何权限，而内核则可以读写着部分内存。在 UTOP( 0xeec00000) 到 ULIM 的 12MB 区间中，存储了一些内核数据结构。内核以及用户环境对这部分地址都只具有 read-only 权限。低于 UTOP 的内存则由用户环境自由设置权限使用。</p>
<p>首先是分配器的<code>pages</code>数组，Hints中告诉我们这应该是对用户只读，并映射到<code>UPAGES</code>地址去。<code>UPAGES (0xef000000 ~ 0xef400000)</code>最多4MB，这是 JOS 记录物理页面使用情况的数据结构，即 exercise 1 中完成的东西，只有 kernel 能够访问。由于用户空间同样需要访问这个数据结构，我们将用户空间的一块内存映射到存储该数据结构的物理内存上。很自然联想到了<code>boot_map_region</code>这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line"><span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line"><span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, UPAGES, ROUNDUP((<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo)*npages), PGSIZE),PADDR(pages),PTE_U );</span><br></pre></td></tr></table></figure>
<p>需要注意的是目前只建立了一个页目录，即<code>kernel_pgdir</code>，所以第一个参数显然为<code>kernel_pgdir</code>。第二个参数是虚拟地址，<code>UPAGES</code>本来就是以虚拟地址形式给出的。第三个参数是映射的内存块大小。第四个参数是映射到的物理地址，直接取 pages 的物理地址即可。权限<code>PTE_U</code>表示用户有权限读取。</p>
<p>然后是内核的栈，用户不可读写，映射到<code>bootstack</code>地址。内核栈<code>0xefff8000 ~ 0xf0000000</code>为32kB。<code>bootstack</code>表示的是栈地最低地址，由于栈向低地址生长，实际是栈顶。常数<code>KSTACKTOP = 0xf0000000</code>，<code>KSTKSIZE = 32kB</code>。在此之下是一块未映射到物理内存的地址，所以如果栈溢出时，只会报错而不会覆盖数据。因此我们只用映射<code>[KSTACKTOP-KSTKSIZE, KSTACKTOP)</code>区间内的虚拟地址即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line"><span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE,PADDR(bootstack),PTE_W );</span><br></pre></td></tr></table></figure></p>
<p>这里设置了<code>PTE_W</code>开启了写权限，然而并没有开启<code>PTE_U</code>，于是仅有内核能够读写，用户没有任何权限。</p>
<p>其余的地址全部映射到<code>KERNBASE</code>上，无论物理内存是否有这么大。用户不可读写。内核<code>( 0xf0000000 ~ 0xffffffff )</code>256MB。这里需要映射全部 0xf0000000 至 0xffffffff 共 256MB 的内存地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line"><span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, <span class="number">0x100000000</span> - KERNBASE, <span class="number">0</span>, PTE_U);</span><br></pre></td></tr></table></figure>
<h3 id="为用户建立虚拟地址映射"><a href="#为用户建立虚拟地址映射" class="headerlink" title="为用户建立虚拟地址映射"></a>为用户建立虚拟地址映射</h3><p>这里才是Lab 3的内容。和page类似，内核通过一个<code>struct Env</code>数组<code>envs</code>管理用户环境。函数<code>env_init</code>初始化了这个数组，具体操作和<code>page_init</code>类似，就是拉链表。</p>
<p>函数<code>env_setup_vm</code>为指定的用户环境<code>struct Env</code>初始化虚拟地址映射，得到的是一个<code>pde_t *</code>类型的<code>Page Directory</code>。需要注意以下几点：</p>
<ul>
<li>为<code>Page Directory</code>分配的新<code>page</code>应该增加引用统计次数<code>pp_ref</code>。</li>
<li><code>UTOP</code>以下的地址对用户应该为可读可写的。</li>
<li>可以使用<code>kern_pgdir</code>作为模板，在其基础上更改。</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/176967610">https://zhuanlan.zhihu.com/p/176967610</a></p>
<p><a href="https://www.dingmos.com/index.php/archives/5/">https://www.dingmos.com/index.php/archives/5/</a></p>
<h1 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>lab3 将主要实现能运行被保护的用户模式环境（protected user-mode environment，即 process）的内核服务。我们将增加数据结构来记录进程、创建进程、为其装载一个程序镜像。我们还要让 JOS 内核能够处理进程产生的系统调用和异常。</p>
<p>Lab 3 有如下几个新文件</p>
<ul>
<li><code>inc/env.h</code>：一些用户模式下的环境定义</li>
<li><code>trap.h</code>：trap的定义</li>
<li><code>syscall.h</code>：系统调用的定义，用户空间到内核空间</li>
<li><code>lib.h</code>：用户模式下的定义</li>
<li><code>kern/env.h</code>：内核支持用户模式的一些数据结构定义</li>
<li><code>env.c</code>：内核实现了用户空间</li>
<li><code>trap.h</code>：内核内部实现的处理trap</li>
<li><code>trap.c</code>：trap处理的函数</li>
<li><code>trapentry.S</code>：用汇编实现的进入trap处理的入口</li>
<li><code>syscall.h</code>：内核实现的处理系统调用的函数</li>
<li><code>syscall.c</code>：实现了系统调用</li>
<li><code>lib/Makefrag</code>：生成用户库obj/lib/libjos.a的makefile</li>
<li><code>entry.S</code>：用户环境的入口函数，用汇编实现</li>
<li><code>libmain.c</code>：用户模式的入口</li>
<li><code>syscall.c</code>：用户模式的系统调用入口</li>
<li><code>console.c</code>：putchar和getchar的用户模式下实现，提供了终端的IO</li>
<li><code>exit.c</code>：用户模式下exit的实现</li>
<li><code>panic.c</code>：用户模式下panic的实现</li>
</ul>
<p>在<code>env.h</code>中，定义了<code>envid_t</code>，有三个部分，第一个部分<code>ENVX(eid)</code>环境index与<code>envs[]</code>数组中的环境index一样。<code>uniqueifier</code>用于区分不同情况下创建的环境。第三个部分是用于区分是否是真正的环境、是错误的环境。如果<code>envid_t == 0</code>就是当前的环境。</p>
<p>下边三个宏应该是为env编号以及取出env index用的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int32_t</span> <span class="type">envid_t</span>;</span><br><span class="line"><span class="comment">// An environment ID &#x27;envid_t&#x27; has three parts:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// +1+---------------21-----------------+--------10--------+</span></span><br><span class="line"><span class="comment">// |0|          Uniqueifier             |   Environment    |</span></span><br><span class="line"><span class="comment">// | |                                  |      Index       |</span></span><br><span class="line"><span class="comment">// +------------------------------------+------------------+</span></span><br><span class="line"><span class="comment">//                                       \--- ENVX(eid) --/</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The environment index ENVX(eid) equals the environment&#x27;s index in the</span></span><br><span class="line"><span class="comment">// &#x27;envs[]&#x27; array.  The uniqueifier distinguishes environments that were</span></span><br><span class="line"><span class="comment">// created at different times, but share the same environment index.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All real environments are greater than 0 (so the sign bit is zero).</span></span><br><span class="line"><span class="comment">// envid_ts less than 0 signify errors.  The envid_t == 0 is special, and</span></span><br><span class="line"><span class="comment">// stands for the current environment.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG2NENV                10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NENV                    (1 &lt;&lt; LOG2NENV)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENVX(envid)             ((envid) &amp; (NENV - 1))</span></span><br></pre></td></tr></table></figure></p>
<p><code>Env</code>需要存下当前环境下的寄存器、<code>env_id</code>及生成这个env的父亲的id，并将env组织成一个链表。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>        <span class="comment">// Saved registers</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>           <span class="comment">// Next free Env</span></span><br><span class="line">        <span class="type">envid_t</span> env_id;                 <span class="comment">// Unique environment identifier</span></span><br><span class="line">        <span class="type">envid_t</span> env_parent_id;          <span class="comment">// env_id of this env&#x27;s parent</span></span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> <span class="title">env_type</span>;</span>          <span class="comment">// Indicates special system environments</span></span><br><span class="line">        <span class="type">unsigned</span> env_status;            <span class="comment">// Status of the environment</span></span><br><span class="line">        <span class="type">uint32_t</span> env_runs;              <span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Address space</span></span><br><span class="line">        <span class="type">pde_t</span> *env_pgdir;               <span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>trap.h</code>中除了定义一些错误和异常的id，主要是定义了两个结构，一个是用于在发生中断时把当前寄存器入栈的结构，另一个是记录这个<code>trap</code>的信息，注意到都使用了<code>__attribute__ ((packed))</code>，它的作用就是告诉编译器取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐，应该是为了去掉无意义的<code>padding</code>避免出错。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> &#123;</span></span><br><span class="line">        <span class="comment">/* registers as pushed by pusha */</span></span><br><span class="line">        <span class="type">uint32_t</span> reg_edi;</span><br><span class="line">        <span class="type">uint32_t</span> reg_esi;</span><br><span class="line">        <span class="type">uint32_t</span> reg_ebp;</span><br><span class="line">        <span class="type">uint32_t</span> reg_oesp;              <span class="comment">/* Useless */</span></span><br><span class="line">        <span class="type">uint32_t</span> reg_ebx;</span><br><span class="line">        <span class="type">uint32_t</span> reg_edx;</span><br><span class="line">        <span class="type">uint32_t</span> reg_ecx;</span><br><span class="line">        <span class="type">uint32_t</span> reg_eax;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">        <span class="type">uint16_t</span> tf_es;</span><br><span class="line">        <span class="type">uint16_t</span> tf_padding1;</span><br><span class="line">        <span class="type">uint16_t</span> tf_ds;</span><br><span class="line">        <span class="type">uint16_t</span> tf_padding2;</span><br><span class="line">        <span class="type">uint32_t</span> tf_trapno;</span><br><span class="line">        <span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">        <span class="type">uint32_t</span> tf_err;</span><br><span class="line">        <span class="type">uintptr_t</span> tf_eip;</span><br><span class="line">        <span class="type">uint16_t</span> tf_cs;</span><br><span class="line">        <span class="type">uint16_t</span> tf_padding3;</span><br><span class="line">        <span class="type">uint32_t</span> tf_eflags;</span><br><span class="line">        <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">        <span class="type">uintptr_t</span> tf_esp;</span><br><span class="line">        <span class="type">uint16_t</span> tf_ss;</span><br><span class="line">        <span class="type">uint16_t</span> tf_padding4;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure></p>
<p><code>syscall.h</code>中主要是用<code>enum</code>列举现有的<code>syscall</code>的代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* system call numbers */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        SYS_cputs = <span class="number">0</span>,</span><br><span class="line">        SYS_cgetc,</span><br><span class="line">        SYS_getenvid,</span><br><span class="line">        SYS_env_destroy,</span><br><span class="line">        NSYSCALLS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>lib.h</code>主要定义了用户模式下使用的一些函数和变量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main user program</span></span><br><span class="line"><span class="type">void</span>    <span class="title function_">umain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// libmain.c or entry.S</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *binaryname;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">thisenv</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> <span class="title">envs</span>[<span class="title">NENV</span>];</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> <span class="title">pages</span>[];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// exit.c</span></span><br><span class="line"><span class="type">void</span>    <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readline.c</span></span><br><span class="line"><span class="type">char</span>*   <span class="title function_">readline</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// syscall.c</span></span><br><span class="line"><span class="type">void</span>    <span class="title function_">sys_cputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>, <span class="type">size_t</span> len)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">sys_cgetc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">envid_t</span> <span class="title function_">sys_getenvid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span>     <span class="title function_">sys_env_destroy</span><span class="params">(<span class="type">envid_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* File open modes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_RDONLY        0x0000          <span class="comment">/* open for reading only */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_WRONLY        0x0001          <span class="comment">/* open for writing only */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_RDWR          0x0002          <span class="comment">/* open for reading and writing */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_ACCMODE       0x0003          <span class="comment">/* mask for above modes */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_CREAT         0x0100          <span class="comment">/* create if nonexistent */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_TRUNC         0x0200          <span class="comment">/* truncate to zero length */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_EXCL          0x0400          <span class="comment">/* error if already exists */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_MKDIR         0x0800          <span class="comment">/* create directory, not regular file */</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="Part-A-用户环境和异常处理"><a href="#Part-A-用户环境和异常处理" class="headerlink" title="Part A: 用户环境和异常处理"></a>Part A: 用户环境和异常处理</h2><p>新的头文件<code>inc/env.h</code>包含了一些基础的用户环境的定义。内核可以使用这些<code>Env</code>数据结构来管理每一个用户环境。</p>
<p>在<code>kern/env.c</code>，kenerl维护了一组<code>Env</code>结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span> =</span> <span class="literal">NULL</span>;		<span class="comment">// All environments</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">curenv</span> =</span> <span class="literal">NULL</span>;		<span class="comment">// The current env</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span>	<span class="comment">// Free environment list</span></span><br></pre></td></tr></table></figure></p>
<p>一旦 JOS 启动并运行，<code>envs</code>指针就会指向一个表示系统中所有环境的<code>Env</code>结构数组。 在我们的设计中，JOS 内核将支持最多<code>NENV</code>同时活动的环境，尽管在任何给定时间运行的环境通常要少得多。（<code>NENV</code>是<code>inc/env.h</code>中的常量）。一旦分配，<code>envs</code>数组将包含每个<code>NENV</code>可能环境的<code>Env</code>数据结构的单个实例。</p>
<p>JOS 内核在<code>env_free_list</code>中保留了所有不活动的<code>Env</code>结构。 这种设计允许轻松分配和释放环境，因为它们只需添加到空闲列表或从空闲列表中删除。内核使用<code>curenv</code>符号在任何给定时间跟踪当前正在执行的环境。 在启动期间，在运行第一个环境之前，<code>curenv</code>最初设置为 NULL。</p>
<h3 id="Environment-State"><a href="#Environment-State" class="headerlink" title="Environment State"></a>Environment State</h3><p><code>Env</code>在<code>inc/env.h</code>中定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>	<span class="comment">// Saved registers</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>		<span class="comment">// Next free Env</span></span><br><span class="line">	<span class="type">envid_t</span> env_id;			<span class="comment">// Unique environment identifier</span></span><br><span class="line">	<span class="type">envid_t</span> env_parent_id;		<span class="comment">// env_id of this env&#x27;s parent</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> <span class="title">env_type</span>;</span>		<span class="comment">// Indicates special system environments</span></span><br><span class="line">	<span class="type">unsigned</span> env_status;		<span class="comment">// Status of the environment</span></span><br><span class="line">	<span class="type">uint32_t</span> env_runs;		<span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Address space</span></span><br><span class="line">	<span class="type">pde_t</span> *env_pgdir;		<span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>env_tf</code>:<ul>
<li>在<code>inc/trap.h</code>中定义，在这个环境没有运行时保存了其运行时的寄存器状态。当内核从用户态切换到内核态的时候，会保存当前的环境信息，用于之后切换时的场景恢复。</li>
</ul>
</li>
<li><code>env_link</code>:<ul>
<li>这是<code>env</code>组织起来的链表<code>env_free_list</code>。<code>env_free_list</code>指向链表中的第一个空闲<code>env</code>。<br><code>env_id</code>:</li>
<li>这个值唯一的标识了一个<code>env</code>。一个用户环境结束后，内核可能重新分配这个<code>Env</code>结构给一个不同的环境，但是这个<code>Env</code>就会有不同的<code>env_id</code>，即便这个<code>env_id</code>是复用的。</li>
</ul>
</li>
<li><code>env_parent_id</code>:<ul>
<li>内核存储了创造这个环境的父环境的<code>env_id</code>。这样可以将所有的环境组织成一个环境树，这样就可以方便的决定哪个环境可以对某个结构做什么操作。</li>
</ul>
</li>
<li><code>env_type</code>:<ul>
<li>这用于区分特殊环境。 对于大多数环境，它将是<code>ENV_TYPE_USER</code>。在后面的实验中，我们将针对特殊的系统服务环境再介绍几种类型。</li>
</ul>
</li>
<li><code>env_status</code>: 有如下几种取值:<ul>
<li><code>ENV_FREE</code>: 表示<code>Env</code>结构处于非活动状态，因此在<code>env_free_list</code>上</li>
<li><code>ENV_RUNNABLE</code>: 表示<code>Env</code>结构代表一个正在等待在处理器上运行的环境。</li>
<li><code>ENV_RUNNING</code>: 表示<code>Env</code>结构代表当前运行的环境。</li>
<li><code>ENV_NOT_RUNNABLE</code>: 表示<code>Env</code>结构表示当前活动的环境，但它当前尚未准备好运行：例如，因为它正在等待来自另一个环境的进程间通信 (IPC)。</li>
<li><code>ENV_DYING</code>: 表示<code>Env</code>结构代表僵尸环境。僵尸环境将在下一次陷入内核时被释放。</li>
</ul>
</li>
<li><code>env_pgdir</code>: 这个变量保存了这个环境页面目录的内核虚拟地址。</li>
</ul>
<p>与 Unix 进程一样，JOS 环境将“线程”和“地址空间”的概念结合在一起。线程主要由保存的寄存器（<code>env_tf</code>字段）定义，地址空间由<code>env_pgdir</code>指向的页目录和页表定义。为了运行一个环境，内核必须用保存的寄存器和适当的地址空间设置 CPU。</p>
<p>我们的<code>struct Env</code>类似于 xv6 中的<code>struct proc</code>。两个结构都在<code>Trapframe</code>结构中保存环境（即进程的）用户模式寄存器状态。在 JOS 中，单个环境不像 xv6 中的进程那样拥有自己的内核堆栈。内核中一次只能有一个 JOS 环境处于活动状态，因此 JOS 只需要一个内核堆栈。</p>
<h2 id="分配环境数组"><a href="#分配环境数组" class="headerlink" title="分配环境数组"></a>分配环境数组</h2><p>我们需要将<code>envs</code>指针指向一个由<code>Env</code>结构体组成的数组，就像我们在 lab2 中对<code>pages</code>指针做的一样。同时，JOS 还需要将不活动的<code>Env</code>记录在<code>env_free_list</code>之中，类似于<code>page_free_list。curenv</code>指针记录着现在执行的进程。在第一个进程运行之前，为NULL。<br>在<code>kern/pmap.c</code>中添加以下两行代码，基本就是仿造之前对<code>pages</code>的处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">envs = (<span class="keyword">struct</span> Env*) boot_alloc(NENV * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env));</span><br><span class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env) * NENV);</span><br></pre></td></tr></table></figure></p>
<p>之后进行<code>make;make qemu</code>，如果从Lab 2继承下来，会出现<code>kernel panic at kern/pmap.c:152: PADDR called with invalid kva 00000000</code>的错误！究其原因，链接器提供的<code>end</code>变量并没有指向数据区域的最后，而是指向数据区域内。</p>
<h3 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h3><p>使用<code>objdump -h obj/kern/kernel</code>，得到如下信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00005379  f0100000  00100000  00001000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .rodata       000016b0  f0105380  00105380  00006380  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .stab         000088c9  f0106a30  00106a30  00007a30  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .stabstr      00002a60  f010f2f9  0010f2f9  000102f9  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .data         0007a014  f0112000  00112000  00013000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  5 .got          0000000c  f018c014  0018c014  0008d014  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  6 .got.plt      0000000c  f018c020  0018c020  0008d020  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  7 .data.rel.local 0000100e  f018d000  0018d000  0008e000  2**12</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  8 .data.rel.ro.local 000000cc  f018e020  0018e020  0008f020  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  9 .bss          00000f14  f018e100  0018e100  0008f100  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 10 .comment      0000002b  00000000  00000000  00090014  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure><br>可以看出<code>.bss</code>段的范围为：<code>0xf018e100-0xf018f014</code>，大小为<code>0xf14</code>。将<code>end</code>变量输出，得到：<code>end=0xf018f000</code>。可以看到<code>end</code>在数据段之间。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>修改链接脚本<code>kern/kernel.ld</code>:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.bss : &#123;</span><br><span class="line">	PROVIDE(edata = .);</span><br><span class="line">	*(.bss)</span><br><span class="line">	*(COMMON) </span><br><span class="line">	PROVIDE(end = .);</span><br><span class="line">	BYTE(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>将<code>COMMON</code>添加在end之前即可。</p>
<p>将虚拟内存的 UENVS 段映射到 envs 的物理地址<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map the &#x27;envs&#x27; array read-only by the user at linear address UENVS</span></span><br><span class="line"><span class="comment">// (ie. perm = PTE_U | PTE_P).</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></span><br><span class="line"><span class="comment">//    - envs itself -- kernel RW, user NONE</span></span><br><span class="line">boot_map_region(kern_pgdir, (<span class="type">uintptr_t</span>)UENVS, ROUNDUP(NENV*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env), PGSIZE), PADDR(envs), PTE_U | PTE_P);</span><br></pre></td></tr></table></figure><br>修正这个错误之后，发现代码的顺序也会影响最后check判断，可能是因为如果不在它指定的地方添加代码的话，会影响page分配的顺序，从而影响检查。</p>
<h3 id="创建和运行环境"><a href="#创建和运行环境" class="headerlink" title="创建和运行环境"></a>创建和运行环境</h3><p>在这里，环境和进程是可以对等的，都指程序运行期间的抽象。不直接叫进程是因为jos中实现的系统调用和UNIX是有差别的。</p>
<p>我们需要编写运行用户环境所需的<code>kern/env.c</code>代码。因为我们还没有文件系统，所以我们将设置内核来加载嵌入在内核中的静态二进制映像。JOS将此二进制文件作为ELF可执行映像嵌入内核中。</p>
<p>在<code>kern/Makefrag</code>文件中，使用了一些方法将这些二进制文件直接“链接”到内核可执行文件中。 链接器命令行上的<code>-b binary</code>选项会将这些文件作为“原始”未解释的二进制文件链接，而不是作为编译器生成的常规.o文件链接。（就链接器而言，这些文件根本不必是ELF文件——它们可以是任何格式，例如文本文件或图片）如果在构建内核后查看<code>obj/kern/kernel.sym</code>，你会注意到链接器“神奇地”产生了许多有趣的符号，这些符号具有晦涩的名字，如<code>_binary_obj_user_hello_start，_binary_obj_user_hello_end</code>和<code>_binary_obj_user_hello_size</code>。链接器通过修改二进制文件的文件名来生成这些符号名称; 这些符号为常规内核代码提供了引用嵌入式二进制文件的方法。</p>
<p>在<code>kern/init.c</code>中的<code>i386_init()</code>中我们将会看到运行这些二进制镜像的方法。</p>
<p>一个函数一个函数的看，第一个是<code>env_init</code>，把所有的<code>env</code>组织成一个链表<code>envs_free_list</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将&#x27;envs&#x27;中的所有环境加入到env_free_list中</span></span><br><span class="line"><span class="comment">// 确保环境以相同的顺序加入到空闲列表中</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Set up envs array</span></span><br><span class="line">        <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = NENV<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">                envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">                envs[i].env_link = env_free_list;</span><br><span class="line">                env_free_list = &amp;envs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">        env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数<code>env_setup_vm</code>为指定的用户环境<code>struct Env</code>初始化虚拟地址映射，得到的是一个<code>pde_t *</code>类型的<code>Page Directory</code>。需要注意以下几点：</p>
<ul>
<li>为<code>Page Directory</code>分配的新<code>page</code>应该增加引用统计次数<code>pp_ref</code>。</li>
<li><code>UTOP</code>以下的地址对用户应该为可读可写的。</li>
<li>可以使用<code>kern_pgdir</code>作为模板，在其基础上更改。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allocate a page for the page directory</span></span><br><span class="line">        <span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Hint:</span></span><br><span class="line">        <span class="comment">//    - Can you use kern_pgdir as a template?  Hint: Yes.</span></span><br><span class="line">        <span class="comment">//      (Make sure you got the permissions right in Lab 2.)</span></span><br><span class="line">        <span class="comment">//    - The initial VA below UTOP is empty.</span></span><br><span class="line">        <span class="comment">//    - You do not need to make any more calls to page_alloc.</span></span><br><span class="line">        <span class="comment">//    - Note: In general, pp_ref is not maintained for</span></span><br><span class="line">        <span class="comment">//      physical pages mapped only above UTOP, but env_pgdir</span></span><br><span class="line">        <span class="comment">//      is an exception -- you need to increment env_pgdir&#x27;s</span></span><br><span class="line">        <span class="comment">//      pp_ref for env_free to work correctly.</span></span><br><span class="line">        <span class="comment">//    - The functions in kern/pmap.h are handy.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">        e-&gt;env_pgdir = page2kva(p);</span><br><span class="line">        <span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line">        p-&gt;pp_ref ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">pde_t</span>* pde = page2kva(p); pde &lt; (<span class="type">pde_t</span>*)(page2kva(p)+PGSIZE); pde ++)</span><br><span class="line">            *pde = *pde | PTE_U | PTE_W;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// UVPT maps the env&#x27;s own page table read-only.</span></span><br><span class="line">        <span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">        e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>env_alloc</code>用来分配一个<code>env</code>，并保存到<code>newenv_store</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配并初始化一个新的env，将其存在 *newenv_store.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on failure.  Errors include:</span></span><br><span class="line"><span class="comment">//      -E_NO_FREE_ENV if all NENV environments are allocated</span></span><br><span class="line"><span class="comment">//      -E_NO_MEM on memory exhaustion</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">env_alloc</span><span class="params">(<span class="keyword">struct</span> Env **newenv_store, <span class="type">envid_t</span> parent_id)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int32_t</span> generation;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果env_free_list为空了，说明分配光了</span></span><br><span class="line">        <span class="keyword">if</span> (!(e = env_free_list))</span><br><span class="line">                <span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用这个函数如果返回小于0，则说明没有多余内存了</span></span><br><span class="line">        <span class="keyword">if</span> ((r = env_setup_vm(e)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新生成一个env_id，当前的id加上特定的偏移量，再取低位</span></span><br><span class="line">        generation = (e-&gt;env_id + (<span class="number">1</span> &lt;&lt; ENVGENSHIFT)) &amp; ~(NENV - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (generation &lt;= <span class="number">0</span>)    <span class="comment">// Don&#x27;t create a negative env_id.</span></span><br><span class="line">            generation = <span class="number">1</span> &lt;&lt; ENVGENSHIFT;</span><br><span class="line">        e-&gt;env_id = generation | (e - envs);</span><br><span class="line"></span><br><span class="line">        e-&gt;env_parent_id = parent_id;</span><br><span class="line">        e-&gt;env_type = ENV_TYPE_USER;</span><br><span class="line">        e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">        e-&gt;env_runs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清除之前可能保存的寄存器信息</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;e-&gt;env_tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(e-&gt;env_tf));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为寄存器赋初值</span></span><br><span class="line">        <span class="comment">// GD_UD is the user data segment selector in the GDT</span></span><br><span class="line">        <span class="comment">// GD_UT is the user text segment selector </span></span><br><span class="line">        <span class="comment">// 每个寄存器的最低几位标志了特权级，3是用户态。</span></span><br><span class="line">        <span class="comment">// 当我们转换特权级时，硬件会检查特权级和描述符优先级等</span></span><br><span class="line">        e-&gt;env_tf.tf_ds = GD_UD | <span class="number">3</span>;</span><br><span class="line">        e-&gt;env_tf.tf_es = GD_UD | <span class="number">3</span>;</span><br><span class="line">        e-&gt;env_tf.tf_ss = GD_UD | <span class="number">3</span>;</span><br><span class="line">        e-&gt;env_tf.tf_esp = USTACKTOP;</span><br><span class="line">        e-&gt;env_tf.tf_cs = GD_UT | <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// You will set e-&gt;env_tf.tf_eip later.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// commit the allocation</span></span><br><span class="line">        env_free_list = e-&gt;env_link;</span><br><span class="line">        *newenv_store = e;</span><br><span class="line"></span><br><span class="line">        cprintf(<span class="string">&quot;[%08x] new env %08x\n&quot;</span>, curenv ? curenv-&gt;env_id : <span class="number">0</span>, e-&gt;env_id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>region_alloc()</code>为进程分配内存并完成映射。要利用 lab2 中的<code>page_alloc()</code>完成分配内存页，<code>page_insert()</code>完成虚拟地址到物理页的映射。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为环境env分配len个字节的物理内存，将它映射到物理地址va</span></span><br><span class="line"><span class="comment">// 页需要可被用户和内核写</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">region_alloc</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">void</span> *va, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">uintptr_t</span> va_start = ROUNDDOWN((<span class="type">uintptr_t</span>)va, PGSIZE);</span><br><span class="line">    <span class="type">uintptr_t</span> va_end = ROUNDUP((<span class="type">uintptr_t</span>)va + len, PGSIZE);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pginfo</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur_va=va_start; cur_va&lt;va_end; cur_va+=PGSIZE) &#123;</span><br><span class="line">        pginfo = page_alloc(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!pginfo) &#123;</span><br><span class="line">            <span class="type">int</span> r = -E_NO_MEM;</span><br><span class="line">            panic(<span class="string">&quot;region_alloc: %e&quot;</span> , r);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;insert page at %08x\n&quot;</span>,cur_va);</span><br><span class="line">        page_insert(e-&gt;env_pgdir, pginfo, (<span class="type">void</span> *)cur_va, PTE_U | PTE_W | PTE_P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>load_icode()</code>作用是将 ELF 二进制文件读入内存，由于 JOS 暂时还没有自己的文件系统，实际就是从<code>*binary</code>这个内存地址读取。大概需要做的事：</p>
<ul>
<li>根据<code>ELF header</code>得出<code>Programm header</code>。</li>
<li>遍历所有<code>Programm header</code>，分配好内存，加载类型为<code>ELF_PROG_LOAD</code>的段。</li>
<li>分配用户栈。</li>
</ul>
<p><code>lcr3([页目录物理地址])</code>将页目录地址加载到<code>cr3</code>寄存器。</p>
<p>更改函数入口时，将<code>env-&gt;env_tf.tf_eip</code>设置为<code>elf-&gt;e_entry</code>，等待之后的<code>env_pop_tf()</code>调用。</p>
<p>这里相当于实现一个ELF可执行文件加载器。ELF文件以一个ELF文件头开始，通过<code>ELFHDR-&gt;e_magic</code>字段判断该文件是否是ELF格式的，然后通过<code>ELFHDR-&gt;e_phoff</code>获取程序头距离ELF文件的偏移，<code>ph</code>指向的就是程序头的起始位置，相当于一个数组，程序头记录了有哪些Segment需要加载，加载到线性地址的何处？<code>ph_num</code>保存了总共有多少Segment。遍历<code>ph</code>数组，分配线性地址<code>p_va</code>开始的<code>p_memsz</code>大小的空间。并将ELF文件中<code>binary + ph[i].p_offset</code>偏移处的Segment拷贝到线性地址<code>p_va</code>处。</p>
<p>有一点需要注意，在执行for循环前，需要加载<code>e-&gt;env_pgdir</code>，也就是这句<code>lcr3(PADDR(e-&gt;env_pgdir));</code>，因为我们要将Segment拷贝到用户的线性地址空间内，而不是内核的线性地址空间。<br>加载完Segment后需要设置<code>e-&gt;env_tf.tf_eip = ELFHDR-&gt;e_entry;</code>也就是程序第一条指令的位置。</p>
<p>最后<code>region_alloc(e, (void *) (USTACKTOP - PGSIZE), PGSIZE);</code>为用户环境分配栈空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">uint8_t</span> *binary)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf</span> =</span> (<span class="keyword">struct</span> Elf *)binary;</span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        panic(<span class="string">&quot;load_icode: not an ELF file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过ELF header中保存的Programm header的偏移找到Programm header</span></span><br><span class="line">    ph = (<span class="keyword">struct</span> Proghdr *)(binary + elf-&gt;e_phoff);</span><br><span class="line">    eph = ph + elf-&gt;e_phnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载这个环境自己的页表</span></span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">    <span class="keyword">for</span> (; ph&lt;eph; ph++) &#123;</span><br><span class="line">        <span class="comment">// 如果这个programm header是需要被加载的</span></span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type == ELF_PROG_LOAD) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">                panic(<span class="string">&quot;load_icode: file size is greater than memory size&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 分配一个空间并将所需要的复制过来，将其后填充</span></span><br><span class="line">            region_alloc(e, (<span class="type">void</span> *)ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">            <span class="built_in">memcpy</span>((<span class="type">void</span> *)ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">            <span class="built_in">memset</span>((<span class="type">void</span> *)ph-&gt;p_va + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;env_tf.tf_eip = elf-&gt;e_entry;</span><br><span class="line">    <span class="comment">// Now map one page for the program&#x27;s initial stack</span></span><br><span class="line">    <span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    region_alloc(e, (<span class="type">void</span> *) USTACKTOP-PGSIZE, PGSIZE);</span><br><span class="line">    lcr3(PADDR(kern_pgdir));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>env_create()</code>作用是新建一个进程。调用已经写好的<code>env_alloc()</code>函数即可，之后更改类型并且利用<code>load_icode()</code>读取 ELF。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_create</span><span class="params">(<span class="type">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="type">int</span> r = env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (r&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;env_create: %e&quot;</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;env_type = type;</span><br><span class="line">    load_icode(e, binary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>env_run()</code>启动某个进程。最后调用了<code>env_pop_tf()</code>这个函数。该函数的作用是将<code>struct Trapframe</code>中存储的寄存器状态 pop 到相应寄存器中。查看之前写的<code>load_icode()</code>函数中的<code>e-&gt;env_tf.tf_eip = elf-&gt;e_entry</code>这一句，经过<code>env_pop_tf()</code>之后，指令寄存器的值即设置到了可执行文件的入口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Step 1: If this is a context switch (a new environment is running):</span></span><br><span class="line">    <span class="comment">//     1. Set the current environment (if any) back to</span></span><br><span class="line">    <span class="comment">//        ENV_RUNNABLE if it is ENV_RUNNING (think about</span></span><br><span class="line">    <span class="comment">//        what other states it can be in),</span></span><br><span class="line">    <span class="comment">//     2. Set &#x27;curenv&#x27; to the new environment,</span></span><br><span class="line">    <span class="comment">//     3. Set its status to ENV_RUNNING,</span></span><br><span class="line">    <span class="comment">//     4. Update its &#x27;env_runs&#x27; counter,</span></span><br><span class="line">    <span class="comment">//     5. Use lcr3() to switch to its address space.</span></span><br><span class="line">    <span class="comment">// Step 2: Use env_pop_tf() to restore the environment&#x27;s</span></span><br><span class="line">    <span class="comment">//     registers and drop into user mode in the</span></span><br><span class="line">    <span class="comment">//     environment.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint: This function loads the new environment&#x27;s state from</span></span><br><span class="line">    <span class="comment">//  e-&gt;env_tf.  Go back through the code you wrote above</span></span><br><span class="line">    <span class="comment">//  and make sure you have set the relevant parts of</span></span><br><span class="line">    <span class="comment">//  e-&gt;env_tf to sensible values.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING) &#123;</span><br><span class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    curenv = e;</span><br><span class="line">    e-&gt;env_status = ENV_RUNNING;</span><br><span class="line">    e-&gt;env_runs++;</span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">    </span><br><span class="line">    env_pop_tf(&amp;e-&gt;env_tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Trapframe</code>结构和<code>env_pop_tf()</code>函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> &#123;</span></span><br><span class="line">	<span class="comment">/* registers as pushed by pusha */</span></span><br><span class="line">	<span class="type">uint32_t</span> reg_edi;</span><br><span class="line">	<span class="type">uint32_t</span> reg_esi;</span><br><span class="line">	<span class="type">uint32_t</span> reg_ebp;</span><br><span class="line">	<span class="type">uint32_t</span> reg_oesp;		<span class="comment">/* Useless */</span></span><br><span class="line">	<span class="type">uint32_t</span> reg_ebx;</span><br><span class="line">	<span class="type">uint32_t</span> reg_edx;</span><br><span class="line">	<span class="type">uint32_t</span> reg_ecx;</span><br><span class="line">	<span class="type">uint32_t</span> reg_eax;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">	<span class="type">uint16_t</span> tf_es;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding1;</span><br><span class="line">	<span class="type">uint16_t</span> tf_ds;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding2;</span><br><span class="line">	<span class="type">uint32_t</span> tf_trapno;</span><br><span class="line">	<span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">	<span class="type">uint32_t</span> tf_err;</span><br><span class="line">	<span class="type">uintptr_t</span> tf_eip;</span><br><span class="line">	<span class="type">uint16_t</span> tf_cs;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding3;</span><br><span class="line">	<span class="type">uint32_t</span> tf_eflags;</span><br><span class="line">	<span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">	<span class="type">uintptr_t</span> tf_esp;</span><br><span class="line">	<span class="type">uint16_t</span> tf_ss;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding4;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Restores the register values in the Trapframe with the &#x27;iret&#x27; instruction.</span></span><br><span class="line"><span class="comment">// This exits the kernel and starts executing some environment&#x27;s code.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function does not return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_pop_tf</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tmovl %0,%%esp\n&quot;</span>				<span class="comment">//将%esp指向tf地址处</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tpopal\n&quot;</span>						<span class="comment">//弹出Trapframe结构中的tf_regs值到通用寄存器</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tpopl %%es\n&quot;</span>					<span class="comment">//弹出Trapframe结构中的tf_es值到%es寄存器</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tpopl %%ds\n&quot;</span>					<span class="comment">//弹出Trapframe结构中的tf_ds值到%ds寄存器</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\taddl $0x8,%%esp\n&quot;</span> <span class="comment">/* skip tf_trapno and tf_errcode */</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tiret\n&quot;</span>						<span class="comment">//中断返回指令，具体动作如下：从Trapframe结构中依次弹出tf_eip,tf_cs,tf_eflags,tf_esp,tf_ss到相应寄存器</span></span></span><br><span class="line"><span class="params">		: : <span class="string">&quot;g&quot;</span> (tf) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">	panic(<span class="string">&quot;iret failed&quot;</span>);  <span class="comment">/* mostly to placate the compiler */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>PushRegs</code>结构保存的正是通用寄存器的值，<code>env_pop_tf()</code>第一条指令，将<code>%esp</code>指向<code>tf</code>地址处，也就是将栈顶指向<code>Trapframe</code>结构开始处，<code>Trapframe</code>结构开始处正是一个<code>PushRegs</code>结构，<code>popal</code>将<code>PushRegs</code>结构中保存的通用寄存器值弹出到寄存器中，接着按顺序弹出寄存器<code>%es</code>, <code>%ds</code>。最后执行<code>iret</code>指令，该指令是中断返回指令，具体动作如下：从<code>Trapframe</code>结构中依次弹出<code>tf_eip</code>，<code>tf_cs</code>，<code>tf_eflags</code>，<code>tf_esp</code>，<code>tf_ss</code>到相应寄存器。</p>
<p>至此结束，本次 exercise 结束后运行并不会成功，会报错 Triple fault。然后 gdb 停止在：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x800a1c:    int    $0x30</span><br><span class="line">0x00800a1c in ?? ()</span><br></pre></td></tr></table></figure><br>原因是此时系统已经进入用户空间，执行了 hello 直到使用系统调用。然而由于 JOS 还没有允许从用户态到内核态的切换，CPU 会产生一个保护异常，然而这个异常也没有程序进行处理，于是生成了 double fault 异常，这个异常同样没有处理。所以报错 triple fault。也就是说，看到执行到了 int 这个中断，实际上就是本次 exercise 顺利结束，这个系统调用是为了在终端输出字符。</p>
<h2 id="处理中断和异常"><a href="#处理中断和异常" class="headerlink" title="处理中断和异常"></a>处理中断和异常</h2><p>上一节中，<code>int $0x30</code>这个系统调用指令是一条死路：一旦进程进入用户模式，内核将无法再次获得控制权。异常和中断都是“受保护的控制权转移” (protected control transfers)，使处理器从用户模式转到内核模式，用户模式代码无法干扰内核或者其他进程的运行。区别在于，中断是由处理器外部的异步事件产生；而异常是由目前处理的代码产生，例如除以0。</p>
<p>为保证切换是被保护的，处理器的中断、异常机制使得正在运行的代码无须选择在哪里以什么方式进入内核。相反，处理器将保证内核在严格的限制下才能被进入。在 x86 架构下，一共有两个机制提供这种保护：</p>
<p>中断描述符表(Interrupt Descriptor Table, IDT)：处理器将确保从一些内核预先定义的条目才能进入内核，而不是由中断或异常发生时运行的代码决定。</p>
<p>x86 支持最多 256 个不同中断和异常的条目。每个包含一个中断向量，是一个 0~255 之间的数，代表中断来源：不同的设备以及错误类型。CPU 利用这些向量作为中断描述符表的索引。而这个表是内核定义在私有内存上（用户没有权限），就像全局描述符表(Global Descripter Table, GDT)一样。从表中恰当的条目，处理器可以获得：</p>
<ul>
<li>需要加载到指令指针寄存器(EIP)的值，该值指向内核中处理这类异常的代码。</li>
<li>需要加载到代码段寄存器(CS)的值，其中最低两位表示优先级（这也是为什么说可以寻址 2^46 的空间而不是 2^48)。 在JOS 中，所有的异常都在内核模式处理，优先级为0 (用户模式为3)。</li>
</ul>
<p>任务状态段(Task State Segment, TSS)：处理器需要保存中断和异常出现时的自身状态，例如 EIP 和 CS，以便处理完后能返回原函数继续执行。但是存储区域必须禁止用户访问，避免恶意代码或 bug 的破坏。</p>
<p>因此，当 x86 处理器处理从用户到内核的模式转换时，也会切换到内核栈。而 TSS 指明段选择器和栈地址。处理器将 SS, ESP, EFLAGS, CS, EIP 压入新栈，然后从 IDT 读取 CS 和 EIP，根据新栈设置 ESP 和 SS。</p>
<p>JOS 仅利用 TSS 来定义需要切换的内核栈。由于内核模式在 JOS 优先级是 0，因此处理器用 TSS 的 ESP0 和 SS0 来定义内核栈，无需 TSS 结构体中的其他内容。其中， SS0 种存储的是 GD_KD(0x10)，ESP0 种存储的是 KSTACKTOP(0xf0000000)。相关定义在<code>inc/memlayout.h</code>中可以找到。</p>
<h3 id="中断和异常的类型"><a href="#中断和异常的类型" class="headerlink" title="中断和异常的类型"></a>中断和异常的类型</h3><p>x86 的所有异常可以用中断向量 0~31 表示，对应 IDT 的第 0~31 项。例如，页错误产生一个中断向量为 14 的异常。大于 32 的中断向量表示的都是中断，其中，软件中断用 int 指令产生，而硬件中断则由硬件在需要关注的时候产生。</p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p>通过一个例子来理解上面的知识。假设处理器正在执行用户环境的代码，遇到了”除0”异常。</p>
<p>处理器切换到内核栈，利用了上文<code>TSS</code>中的<code>ESP0</code>和<code>SS0</code>，在JOS中分别是<code>KSTACKTOP</code>和<code>GD_KD</code>。处理器将异常参数<code>push</code>到了内核栈。一般情况下，按顺序push SS, ESP, EFLAGS, CS, EIP<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ KSTACKTOP</span><br><span class="line">| 0x00000 | old SS | &quot; - 4</span><br><span class="line">| old ESP | &quot; - 8</span><br><span class="line">| old EFLAGS | &quot; - 12</span><br><span class="line">| 0x00000 | old CS | &quot; - 16</span><br><span class="line">| old EIP | &quot; - 20 &lt;---- ESP</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure></p>
<p>存储这些寄存器状态的意义是：SS(堆栈选择器) 的低 16 位与 ESP 共同确定当前栈状态；EFLAGS(标志寄存器)存储当前FLAG；CS(代码段寄存器) 和 EIP(指令指针寄存器) 确定了当前即将执行的代码地址，E 代表”扩展”至32位。根据这些信息，就能保证处理中断结束后能够恢复到中断前的状态。</p>
<p>因为我们将处理一个”除0”异常，其对应中断向量是0，因此，处理器读取 IDT 的条目0，设置 CS:EIP 指向该条目对应的处理函数。</p>
<p>处理函数获得程序控制权并且处理该异常。例如，终止进程的运行。</p>
<p>对于某些特殊的 x86 异常，除了以上 5 个参数以外，还需要存储一个 error code。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ KSTACKTOP             </span><br><span class="line">| 0x00000 | old SS   |     &quot; - 4</span><br><span class="line">|      old ESP       |     &quot; - 8</span><br><span class="line">|     old EFLAGS     |     &quot; - 12</span><br><span class="line">| 0x00000 | old CS   |     &quot; - 16</span><br><span class="line">|      old EIP       |     &quot; - 20</span><br><span class="line">|     error code     |     &quot; - 24 &lt;---- ESP</span><br><span class="line">+--------------------+     </span><br></pre></td></tr></table></figure></p>
<p>例如，页错误异常（中断向量=14）就是一个重要的例子，它就需要额外存储一个 error code。</p>
<h3 id="嵌套的异常和中断"><a href="#嵌套的异常和中断" class="headerlink" title="嵌套的异常和中断"></a>嵌套的异常和中断</h3><p>内核和用户进程都会引起异常和中断。然而，仅在从用户环境进入内核时才会切换栈。如果中断发生时已经在内核态了(此时， CS 寄存器的低 2bit 为 00) ，那么 CPU 就直接将状态压入内核栈，不再需要切换栈。这样，内核就能处理内核自身引起的”嵌套异常”，这是实现保护的重要工具。</p>
<p>如果处理器已经处于内核态，然后发生了嵌套异常，由于它并不进行栈切换，所以无须存储 SS 和 ESP 寄存器状态。对于不包含 error code 的异常，在进入处理函数前内核栈状态如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+ &lt;---- old ESP</span><br><span class="line">|     old EFLAGS     |     &quot; - 4</span><br><span class="line">| 0x00000 | old CS   |     &quot; - 8</span><br><span class="line">|      old EIP       |     &quot; - 12</span><br><span class="line">+--------------------+             </span><br></pre></td></tr></table></figure></p>
<p>对于包含了 error code 的异常，则将 error code 继续 push 到 EIP之后。</p>
<p>警告：如果 CPU 处理嵌套异常的时候，无法将状态 push 到内核栈（由于栈空间不足等原因），则 CPU 无法恢复当前状态，只能重启。当然，这是内核设计中必须避免的。</p>
<h3 id="建立中断描述符表-IDT"><a href="#建立中断描述符表-IDT" class="headerlink" title="建立中断描述符表(IDT)"></a>建立中断描述符表(IDT)</h3><p>IDT可以驻留在物理内存中的任何位置。 处理器通过IDT寄存器（IDTR）定位IDT。</p>
<p><img src="/img/201906171933232.png" alt=""></p>
<p>IDT包含了三种描述子</p>
<ul>
<li>任务门</li>
<li>中断门</li>
<li>陷阱门</li>
</ul>
<p><img src="/img/20190617193346641.png" alt=""></p>
<p>每个entry为8bytes，有以下关键bit：</p>
<ul>
<li>16~31：code segment selector</li>
<li>0~15 &amp; 46-64：segment offset （根据以上两项可确定中断处理函数的地址）</li>
<li>Type （8-11）：区分中断门、陷阱门、任务门等</li>
<li>DPL：Descriptor Privilege Level， 访问特权级</li>
<li>P：该描述符是否在内存中</li>
</ul>
<p>通过上文，已经了解到了建立 IDT 以及处理异常所需要的基本信息。头文件<code>inc/trap.h</code>和<code>kern/trap.h</code>包含了与中断和异常相关的定义。</p>
<p>每个异常和中断都应该在<code>trapentry.S</code>和<code>trap_init()</code>有自己的处理函数，并在<code>IDT</code>中将这些处理函数的地址初始化，这也描述了Part A的整个过程。每个处理函数都需要在栈上新建一个<code>struct Trapframe</code>（见<code>inc/trap.h</code>)，以其地址为参数调用<code>trap()</code>函数，然后进行异常处理。</p>
<p>总体的异常处理应该如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">      IDT                   trapentry.S         trap.c</span><br><span class="line">   </span><br><span class="line">+----------------+                        </span><br><span class="line">|   &amp;handler1    |---------&gt; handler1:          trap (struct Trapframe *tf)</span><br><span class="line">|                |             // do stuff      &#123;</span><br><span class="line">|                |             call trap          // handle the exception/interrupt</span><br><span class="line">|                |             // ...           &#125;</span><br><span class="line">+----------------+</span><br><span class="line">|   &amp;handler2    |--------&gt; handler2:</span><br><span class="line">|                |            // do stuff</span><br><span class="line">|                |            call trap</span><br><span class="line">|                |            // ...</span><br><span class="line">+----------------+</span><br><span class="line">       .</span><br><span class="line">       .</span><br><span class="line">       .</span><br><span class="line">+----------------+</span><br><span class="line">|   &amp;handlerX    |--------&gt; handlerX:</span><br><span class="line">|                |             // do stuff</span><br><span class="line">|                |             call trap</span><br><span class="line">|                |             // ...</span><br><span class="line">+----------------+</span><br></pre></td></tr></table></figure></p>
<p>首先第一步是搞明白<code>TRAPHANDLER</code>这段汇编代码的意义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPHANDLER(name, num)  </span></span><br><span class="line">    .globl name;        </span><br><span class="line">    .type name, @function;  </span><br><span class="line">    .align <span class="number">2</span>;</span><br><span class="line">    name:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  pushl $0;    // if no error code </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pushl $(num);                           </span><br><span class="line">    jmp _alltraps</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn&#x27;t push an error code.</span></span><br><span class="line"><span class="comment"> * It pushes a 0 in place of the error code, so the trap frame has the same</span></span><br><span class="line"><span class="comment"> * format in either case.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPHANDLER_NOEC(name, num)</span></span><br><span class="line">    .globl name;</span><br><span class="line">    .type name, @function;</span><br><span class="line">    .align <span class="number">2</span>;</span><br><span class="line">    name:</span><br><span class="line">    pushl $<span class="number">0</span>;</span><br><span class="line">    pushl $(num);</span><br><span class="line">    jmp _alltraps</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>.global/ .globl</code>：用来定义一个全局的符号，格式如下:<ul>
<li><code>.global symbol</code>或者<code>.globl symbol</code></li>
<li>汇编函数如果需要在其他文件调用，需要把函数声明为全局的，此时就会用到<code>.global</code>这个伪操作。</li>
</ul>
</li>
<li><code>.type</code>: 用来指定一个符号的类型是函数类型或者是对象类型,对象类型一般是数据, 格式如下:<ul>
<li><code>.type symbol, @object</code></li>
<li><code>.type symbol, @function</code></li>
</ul>
</li>
<li><code>.align</code>: 用来指定内存对齐方式，格式如下：<ul>
<li><code>.align size</code>表示按 size 字节对齐内存。</li>
</ul>
</li>
</ul>
<p><code>TRAPHANDLER</code>定义了一个全局可见的函数来处理陷阱。它将陷阱编号压入堆栈，然后跳转到<code>_alltraps</code>。将<code>TRAPHANDLER</code>用于 CPU 自动推送错误代码的陷阱。不应该从 C 调用<code>TRAPHANDLER</code>函数，但可能需要在 C 中声明一个（例如，在 IDT 设置期间获取函数指针）。可以使用<code>void NAME();</code>声明函数。<code>TRAPHANDLER_NOEC</code>是没有返回错误码的陷阱。<code>TRAPHANDLER</code>和<code>TRAPHANDLER_NOEC</code>创建的函数都会跳转到<code>_alltraps</code>处，这里参考<code>inc/trap.h</code>中的<code>Trapframe</code>结构，<code>tf_ss</code>，<code>tf_esp</code>，<code>tf_eflags</code>，<code>tf_cs</code>，<code>tf_eip</code>，<code>tf_err</code>在中断发生时由处理器压入，所以现在只需要压入剩下寄存器（%ds,%es,通用寄存器）。然后将<code>%esp</code>压入栈中（也就是压入trap()的参数tf）</p>
<p>之前在<code>inc/trap.h</code>中已经定义了<code>T_*</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Trap numbers</span></span><br><span class="line"><span class="comment">// These are processor defined:</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIVIDE     0          <span class="comment">// divide error</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEBUG      1          <span class="comment">// debug exception</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_NMI        2          <span class="comment">// non-maskable interrupt</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_BRKPT      3          <span class="comment">// breakpoint</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_OFLOW      4          <span class="comment">// overflow</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_BOUND      5          <span class="comment">// bounds check</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_ILLOP      6          <span class="comment">// illegal opcode</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE     7          <span class="comment">// device not available</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DBLFLT     8          <span class="comment">// double fault</span></span></span><br><span class="line"><span class="comment">/* #define T_COPROC  9 */</span>       <span class="comment">// reserved (not generated by recent processors)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_TSS       10          <span class="comment">// invalid task switch segment</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_SEGNP     11          <span class="comment">// segment not present</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_STACK     12          <span class="comment">// stack exception</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_GPFLT     13          <span class="comment">// general protection fault</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_PGFLT     14          <span class="comment">// page fault</span></span></span><br><span class="line"><span class="comment">/* #define T_RES    15 */</span>       <span class="comment">// reserved</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FPERR     16          <span class="comment">// floating point error</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_ALIGN     17          <span class="comment">// aligment check</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_MCHK      18          <span class="comment">// machine check</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_SIMDERR   19          <span class="comment">// SIMD floating point error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// These are arbitrarily chosen, but with care not to overlap</span></span><br><span class="line"><span class="comment">// processor defined exceptions or interrupt vectors.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_SYSCALL   48          <span class="comment">// system call</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEFAULT   500         <span class="comment">// catchall</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_OFFSET      32      <span class="comment">// IRQ 0 corresponds to int IRQ_OFFSET</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hardware IRQ numbers. We receive these as (IRQ_OFFSET+IRQ_WHATEVER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TIMER        0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_KBD          1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_SERIAL       4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_SPURIOUS     7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_IDE         14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_ERROR       19</span></span><br></pre></td></tr></table></figure></p>
<p>通过查询80386手册的9.10可以看到如下关于error code的总结，根据是否有error code进行区分<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Description                       Interrupt     Error Code</span><br><span class="line"></span><br><span class="line">Divide error                       0            No</span><br><span class="line">Debug exceptions                   1            No</span><br><span class="line">Breakpoint                         3            No</span><br><span class="line">Overflow                           4            No</span><br><span class="line">Bounds check                       5            No</span><br><span class="line">Invalid opcode                     6            No</span><br><span class="line">Coprocessor not available          7            No</span><br><span class="line">System error                       8            Yes (always 0)</span><br><span class="line">Coprocessor Segment Overrun        9            No</span><br><span class="line">Invalid TSS                       10            Yes</span><br><span class="line">Segment not present               11            Yes</span><br><span class="line">Stack exception                   12            Yes</span><br><span class="line">General protection fault          13            Yes</span><br><span class="line">Page fault                        14            Yes</span><br><span class="line">Coprocessor error                 16            No</span><br><span class="line">Two-byte SW interrupt             0-255         No</span><br></pre></td></tr></table></figure></p>
<p>所以现在在<code>trapentry.S</code>中需要定义handler：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(divide_handler, T_DIVIDE);</span><br><span class="line">TRAPHANDLER_NOEC(debug_handler, T_DEBUG);</span><br><span class="line">TRAPHANDLER_NOEC(nmi_handler, T_NMI);</span><br><span class="line">TRAPHANDLER_NOEC(brkpt_handler, T_BRKPT);</span><br><span class="line">TRAPHANDLER_NOEC(oflow_handler, T_OFLOW);</span><br><span class="line">TRAPHANDLER_NOEC(bound_handler, T_BOUND);</span><br><span class="line">TRAPHANDLER_NOEC(illop_handler, T_ILLOP);</span><br><span class="line">TRAPHANDLER_NOEC(device_handler, T_DEVICE);</span><br><span class="line">TRAPHANDLER(dblflt_handler, T_DBLFLT);</span><br><span class="line">TRAPHANDLER(tss_handler, T_TSS);</span><br><span class="line">TRAPHANDLER(segnp_handler, T_SEGNP);</span><br><span class="line">TRAPHANDLER(stack_handler, T_STACK);</span><br><span class="line">TRAPHANDLER(gpflt_handler, T_GPFLT);</span><br><span class="line">TRAPHANDLER(pgflt_handler, T_PGFLT);</span><br><span class="line">TRAPHANDLER_NOEC(fperr_handler, T_FPERR);</span><br><span class="line">TRAPHANDLER(align_handler, T_ALIGN);</span><br><span class="line">TRAPHANDLER_NOEC(mchk_handler, T_MCHK);</span><br><span class="line">TRAPHANDLER_NOEC(simderr_handler, T_SIMDERR);</span><br><span class="line">TRAPHANDLER_NOEC(syscall_handler, T_SYSCALL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IRQs</span></span><br><span class="line">TRAPHANDLER_NOEC(timer_handler, IRQ_OFFSET + IRQ_TIMER);</span><br><span class="line">TRAPHANDLER_NOEC(kbd_handler, IRQ_OFFSET + IRQ_KBD);</span><br><span class="line">TRAPHANDLER_NOEC(serial_handler, IRQ_OFFSET + IRQ_SERIAL);</span><br><span class="line">TRAPHANDLER_NOEC(spurious_handler, IRQ_OFFSET + IRQ_SPURIOUS);</span><br><span class="line">TRAPHANDLER_NOEC(ide_handler, IRQ_OFFSET + IRQ_IDE);</span><br><span class="line">TRAPHANDLER_NOEC(error_handler, IRQ_OFFSET + IRQ_ERROR);</span><br></pre></td></tr></table></figure><br>该部分主要作用是<strong>声明函数</strong>。该函数是全局的，但是在 C 文件中使用的时候需要使用<code>void name();</code>再声明一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Your _alltraps should:</span><br><span class="line">	1. push values to make the stack look like a struct Trapframe</span><br><span class="line">	2. load GD_KD into %ds and %es</span><br><span class="line">	3. pushl %esp to pass a pointer to the Trapframe as an argument to trap()</span><br><span class="line">	4. call trap (can trap ever return?)</span><br><span class="line">*/</span><br><span class="line">.globl _alltraps</span><br><span class="line">_alltraps:</span><br><span class="line">pushl %ds</span><br><span class="line">pushl %es</span><br><span class="line">pushal</span><br><span class="line"></span><br><span class="line">movw $GD_KD, %ax</span><br><span class="line">movw %ax, %ds</span><br><span class="line">movw %ax, %es</span><br><span class="line">pushl %esp</span><br><span class="line">call trap</span><br></pre></td></tr></table></figure>
<p>这部分较有难度，首先要搞明白，栈是从高地址向低地址生长，而结构体在内存中的存储是从低地址到高地址。而 cpu 以及TRAPHANDLER宏已经将压栈工作进行到了中断向量部分。</p>
<p>首先需要产生一个<code>struct trapframe</code>结构的栈， 而压参数是从右往左，对应这个结构体就是从下往上对应。注意到<code>tf_esp</code>以及<code>tf_ss</code>只用在发生特权级变化的时候才会有，再往上是由硬件自动产生的。在<code>TRAPHANDLER</code>函数中压入了<code>trapno</code>，同时为了保证没有错误代码的<code>trap</code>能符合这个结构体，使用<code>TRAPHANDLER_NOEC</code>压入0占位<code>err</code>。最后我们的程序只需要压入<code>trapno</code>以上的参数即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="type">uint16_t</span> tf_es;</span><br><span class="line">    <span class="type">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="type">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="type">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="type">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">    <span class="type">uint32_t</span> tf_err;</span><br><span class="line">    <span class="type">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="type">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="type">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="type">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">    <span class="type">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="type">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="type">uint16_t</span> tf_padding4;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure></p>
<p>所以若要形成一个<code>Trapframe</code>，则还应该依次压入<code>ds</code>，<code>es</code>以及<code>struct PushRegs</code>中的各寄存器（倒序，可使用 <code>pusha</code>指令）。此后还需要更改数据段为内核的数据段。注意，不能用立即数直接给段寄存器赋值。因此不能直接写<code>movw $GD_KD, %ds</code>。</p>
<p>在<code>kern/trap.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// You will also need to modify trap_init() to initialize the idt to </span></span><br><span class="line"><span class="comment">// point to each of these entry points defined in trapentry.S;</span></span><br><span class="line"><span class="comment">// the SETGATE macro will be helpful here</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trap_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">divide_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">debug_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">nmi_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">brkpt_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">oflow_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">bound_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">device_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">illop_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">tss_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">segnp_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">stack_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">gpflt_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">pgflt_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">fperr_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">align_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">mchk_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">simderr_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">syscall_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">dblflt_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">timer_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">kbd_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">serial_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">spurious_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">ide_handler</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">error_handler</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// GD_KT 全局描述符， kernel text</span></span><br><span class="line">    SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, divide_handler, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_DEBUG],  <span class="number">0</span>, GD_KT, debug_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_NMI],    <span class="number">0</span>, GD_KT, nmi_handler,    <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_BRKPT],  <span class="number">0</span>, GD_KT, brkpt_handler,  <span class="number">3</span>);</span><br><span class="line">    SETGATE(idt[T_OFLOW],  <span class="number">0</span>, GD_KT, oflow_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_BOUND],  <span class="number">0</span>, GD_KT, bound_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_DEVICE], <span class="number">0</span>, GD_KT, device_handler, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_ILLOP],  <span class="number">0</span>, GD_KT, illop_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_DBLFLT], <span class="number">0</span>, GD_KT, dblflt_handler, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_TSS],    <span class="number">0</span>, GD_KT, tss_handler,    <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SEGNP],  <span class="number">0</span>, GD_KT, segnp_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_STACK],  <span class="number">0</span>, GD_KT, stack_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_GPFLT],  <span class="number">0</span>, GD_KT, gpflt_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_PGFLT],  <span class="number">0</span>, GD_KT, pgflt_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_FPERR],  <span class="number">0</span>, GD_KT, fperr_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_ALIGN],  <span class="number">0</span>, GD_KT, align_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_MCHK],   <span class="number">0</span>, GD_KT, mchk_handler,   <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, simderr_handler, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, syscall_handler, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// IRQ</span></span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_TIMER],    <span class="number">0</span>, GD_KT, timer_handler, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_KBD],      <span class="number">0</span>, GD_KT, kbd_handler,     <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL],   <span class="number">0</span>, GD_KT, serial_handler,  <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], <span class="number">0</span>, GD_KT, spurious_handler, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_IDE],      <span class="number">0</span>, GD_KT, ide_handler,     <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_ERROR],    <span class="number">0</span>, GD_KT, error_handler,   <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Per-CPU setup </span></span><br><span class="line">    trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>SETGATE</code>参见<code>inc/mmu.h</code>中的函数定义。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define SETGATE(gate, istrap, sel, off, dpl)</span><br><span class="line">&#123;</span><br><span class="line">    (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff;</span><br><span class="line">    (gate).gd_sel = (sel);</span><br><span class="line">    (gate).gd_args = 0;</span><br><span class="line">    (gate).gd_rsv1 = 0;</span><br><span class="line">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;</span><br><span class="line">    (gate).gd_s = 0;</span><br><span class="line">    (gate).gd_dpl = (dpl);</span><br><span class="line">    (gate).gd_p = 1;</span><br><span class="line">    (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>gate</code>：这是一个 struct Gatedesc。</li>
<li><code>istrap</code>：该中断是 trap(exception) 则为1，是 interrupt 则为0。</li>
<li><code>sel</code>：代码段选择器。进入内核的话是 GD_KT。</li>
<li><code>off</code>：相对于段的偏移，简单来说就是函数地址。</li>
<li><code>dpl</code>(Descriptor Privileged Level)：权限描述符。</li>
</ul>
<h2 id="Part-B-缺页错误，断点异常以及系统调用"><a href="#Part-B-缺页错误，断点异常以及系统调用" class="headerlink" title="Part B: 缺页错误，断点异常以及系统调用"></a>Part B: 缺页错误，断点异常以及系统调用</h2><h3 id="处理缺页错误"><a href="#处理缺页错误" class="headerlink" title="处理缺页错误"></a>处理缺页错误</h3><p>缺页错误异常，中断向量 14 (<code>T_PGFLT</code>)，是一个非常重要的异常类型。当程序遇到缺页异常时，它将引起异常的虚拟地址存入<code>CR2</code>控制寄存器( control register)。在<code>trap.c</code>中，我们已经提供了<code>page_fault_handler()</code>函数用来处理缺页异常。</p>
<p>修改<code>trap_dispatch()</code>函数比较简单，实际上就是在<code>trap_dispatch()</code>中根据 trap number 进行一个处理分配。目前只需要加入缺页异常即可完成该 exercise。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">trap_dispatch</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Handle processor exceptions.</span></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_PGFLT:</span><br><span class="line">            page_fault_handler(tf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">        print_trapframe(tf);</span><br><span class="line">        <span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">            panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            env_destroy(curenv);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="断点异常"><a href="#断点异常" class="headerlink" title="断点异常"></a>断点异常</h3><p>断点异常，中断向量 3 (<code>T_BRKPT</code>) 允许调试器给程序加上断点。原理是暂时把程序中的某个指令替换为一个 1 字节大小的<code>int3</code>软件中断指令。在 JOS 中，我们将它实现为一个伪系统调用。这样，任何程序（不限于调试器）都能使用断点功能。这个exercise同样也是修改<code>trap_dispatch()</code>函数。另外需要找到在<code>kern/monitor.c</code>中的<code>void monitor(struct TrapFrame *tf)</code>函数，加入断点处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">trap_dispatch</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Handle processor exceptions.</span></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_PGFLT:</span><br><span class="line">            page_fault_handler(tf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_BRKPT:</span><br><span class="line">            monitor(tf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">        print_trapframe(tf);</span><br><span class="line">        <span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">            panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            env_destroy(curenv);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>challenge部分要求，我们修改monitor的代码，使得程序能够继续执行，以及能够逐指令执行。首先，按照题目要求，我们肯定要给monitor增加2个函数，不妨叫做：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mon_continue</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mon_stepi</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span>;</span><br></pre></td></tr></table></figure></p>
<p>把这两行加在头文件中，再在命令序列中加入这两个命令。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Command</span> <span class="title">commands</span>[] =</span> &#123;</span><br><span class="line">        &#123; <span class="string">&quot;help&quot;</span>, <span class="string">&quot;Display this list of commands&quot;</span>, mon_help &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;kerninfo&quot;</span>, <span class="string">&quot;Display information about the kernel&quot;</span>, mon_kerninfo &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;backtrace&quot;</span>, <span class="string">&quot;Display a backtrace of the function stack&quot;</span>, mon_backtrace &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;stepi&quot;</span>, <span class="string">&quot;step instruction&quot;</span>, mon_stepi&#125;,</span><br><span class="line">        &#123; <span class="string">&quot;continue&quot;</span>, <span class="string">&quot;continue instruction&quot;</span>, mon_continue&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其次，根据提示，我们去阅读intel文档中关于EFLAGS寄存器的部分，发现了一个位：<code>Trap Bit</code>。如果这个位被设置位1，那么每次执行一条指令，都会自动触发一次Debug Exception.</p>
<p>那么我们要做的就很简单了：在两个函数中，修改eflags寄存器的值，并返回-1（然后从内核态返回用户态）；同时，我们也要给Debug Exception增加特殊的处理函数，使他能够进入monitor。</p>
<p>注意，因为这些中断都是用户态到内核态的，所以<code>trap_init</code>中要做一些修改。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mon_continue</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Continue exectuion of current env. </span></span><br><span class="line">	<span class="comment">// Because we need to exit the monitor, retrun -1 when we can do so</span></span><br><span class="line">	<span class="comment">// Corner Case: If no trapframe(env context) is given, do nothing</span></span><br><span class="line">	<span class="keyword">if</span>(tf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cprintf(<span class="string">&quot;No Env is Running! This is Not a Debug Monitor!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Because we want the program to continue running; clear the TF bit</span></span><br><span class="line">	tf-&gt;tf_eflags &amp;= ~(FL_TF);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mon_stepi</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Continue exectuion of current env. </span></span><br><span class="line">	<span class="comment">// Because we need to exit the monitor, retrun -1 when we can do so</span></span><br><span class="line">	<span class="comment">// Corner Case: If no trapframe(env context) is given, do nothing</span></span><br><span class="line">	<span class="keyword">if</span>(tf == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cprintf(<span class="string">&quot;No Env is Running! This is Not a Debug Monitor!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Because we want the program to single step, set the TF bit</span></span><br><span class="line">	tf-&gt;tf_eflags |= (FL_TF);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Changes in trap_init</span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">handlerx</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">// Debug Exception could be trap or Fault</span></span><br><span class="line">	SETGATE(idt[T_DEBUG], <span class="number">0</span>, GD_KT, DEBUG, <span class="number">3</span>);</span><br><span class="line">	<span class="type">void</span> <span class="title function_">handlerx</span><span class="params">()</span>;</span><br><span class="line">	SETGATE(idt[T_NMI], <span class="number">0</span>, GD_KT, NMI, <span class="number">0</span>);</span><br><span class="line">	<span class="type">void</span> <span class="title function_">handlerx</span><span class="params">()</span>;</span><br><span class="line">	SETGATE(idt[T_BRKPT], <span class="number">1</span>, GD_KT, BRKPT, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>用户进程通过系统调用来让内核为他们服务。当用户进程召起一次系统调用，处理器将进入内核态，处理器以及内核合作存储用户进程的状态，内核将执行适当的代码来完成系统调用，最后返回用户进程继续执行。实现细节各个系统有所不同。</p>
<p>JOS 内核使用<code>int</code>指令来触发一个处理器中断。特别的，我们使用<code>int $0x30</code>作为系统调用中断。它并不能由硬件产生，因此使用它不会产生歧义。</p>
<p>应用程序会把系统调用号 (与中断向量不是一个东西) 以及系统调用参数传递给寄存器。这样，内核就不用在用户栈或者指令流里查询这些信息。系统调用号将存放于<code>%eax</code>，参数（至多5个）会存放于<code>%edx</code>, <code>%ecx</code>, <code>%ebx</code>, <code>%edi</code>以及<code>%esi</code>，调用结束后，内核将返回值放回到<code>%eax</code>。之所以用<code>%eax</code>来传递返回值，是由于系统调用导致了栈的切换。</p>
<p><code>kern</code>中有一套<code>syscall.h</code>，<code>syscall.c</code>，<code>inc</code>和<code>lib</code>中又有一套<code>syscall.h</code>，<code>syscall.c</code>。需要理清这两者之间的关系。</p>
<p>inc/syscall.h<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_INC_SYSCALL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOS_INC_SYSCALL_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* system call numbers */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    SYS_cputs = <span class="number">0</span>,</span><br><span class="line">    SYS_cgetc,</span><br><span class="line">    SYS_getenvid,</span><br><span class="line">    SYS_env_destroy,</span><br><span class="line">    NSYSCALLS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !JOS_INC_SYSCALL_H */</span></span></span><br></pre></td></tr></table></figure><br>这个头文件主要定义了系统调用号，实际就是一个 enum 而已。</p>
<p>lib/syscall.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call stubs.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int32_t</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> check, <span class="type">uint32_t</span> a1, <span class="type">uint32_t</span> a2, <span class="type">uint32_t</span> a3, <span class="type">uint32_t</span> a4, <span class="type">uint32_t</span> a5)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Generic system call: pass system call number in AX,</span></span><br><span class="line">    <span class="comment">// up to five parameters in DX, CX, BX, DI, SI.</span></span><br><span class="line">    <span class="comment">// Interrupt kernel with T_SYSCALL.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The &quot;volatile&quot; tells the assembler not to optimize</span></span><br><span class="line">    <span class="comment">// this instruction away just because we don&#x27;t use the</span></span><br><span class="line">    <span class="comment">// return value.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The last clause tells the assembler that this can</span></span><br><span class="line">    <span class="comment">// potentially change the condition codes and arbitrary</span></span><br><span class="line">    <span class="comment">// memory locations.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;int %1\n&quot;</span></span></span><br><span class="line"><span class="params">             : <span class="string">&quot;=a&quot;</span> (ret)</span></span><br><span class="line"><span class="params">             : <span class="string">&quot;i&quot;</span> (T_SYSCALL),</span></span><br><span class="line"><span class="params">               <span class="string">&quot;a&quot;</span> (num),</span></span><br><span class="line"><span class="params">               <span class="string">&quot;d&quot;</span> (a1),</span></span><br><span class="line"><span class="params">               <span class="string">&quot;c&quot;</span> (a2),</span></span><br><span class="line"><span class="params">               <span class="string">&quot;b&quot;</span> (a3),</span></span><br><span class="line"><span class="params">               <span class="string">&quot;D&quot;</span> (a4),</span></span><br><span class="line"><span class="params">               <span class="string">&quot;S&quot;</span> (a5)</span></span><br><span class="line"><span class="params">             : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(check &amp;&amp; ret &gt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;syscall %d returned %d (&gt; 0)&quot;</span>, num, ret);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sys_cputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    syscall(SYS_cputs, <span class="number">0</span>, (<span class="type">uint32_t</span>)s, len, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_cgetc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_cgetc, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_destroy</span><span class="params">(<span class="type">envid_t</span> envid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_env_destroy, <span class="number">1</span>, envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">envid_t</span></span><br><span class="line"><span class="title function_">sys_getenvid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> syscall(SYS_getenvid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个里边先定义了一个通用的syscall接口，用于被其他系统调用这个通用的接口。</p>
<h4 id="补充知识：GCC内联汇编"><a href="#补充知识：GCC内联汇编" class="headerlink" title="补充知识：GCC内联汇编"></a>补充知识：GCC内联汇编</h4><p>其语法固定为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">asm volatile (“asm code”：output：input：changed);</span><br><span class="line"></span><br><span class="line">    asm volatile(&quot;int %1\n&quot;</span><br><span class="line">             : &quot;=a&quot; (ret)</span><br><span class="line">             : &quot;i&quot; (T_SYSCALL),</span><br><span class="line">               &quot;a&quot; (num),</span><br><span class="line">               &quot;d&quot; (a1),</span><br><span class="line">               &quot;c&quot; (a2),</span><br><span class="line">               &quot;b&quot; (a3),</span><br><span class="line">               &quot;D&quot; (a4),</span><br><span class="line">               &quot;S&quot; (a5)</span><br><span class="line">             : &quot;cc&quot;, &quot;memory&quot;);</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>限定符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>“m”、”v”、”o”</td>
<td>内存单元</td>
</tr>
<tr>
<td>“r”</td>
<td>任何寄存器</td>
</tr>
<tr>
<td>“q”</td>
<td>寄存器eax、ebx、ecx、edx之一</td>
</tr>
<tr>
<td>“i”、”h”</td>
<td>直接操作数</td>
</tr>
<tr>
<td>“E”、”F”</td>
<td>浮点数</td>
</tr>
<tr>
<td>“g”</td>
<td>任意</td>
</tr>
<tr>
<td>“a”、”b”、”c”、”d”</td>
<td>分别表示寄存器eax、ebx、ecx和edx</td>
</tr>
<tr>
<td>“S”、”D”</td>
<td>寄存器esi、edi</td>
</tr>
<tr>
<td>“I”</td>
<td>常数 (0至31)</td>
</tr>
</tbody>
</table>
</div>
<p>除了这些约束之外，输出值还包含一个约束修饰符:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输出修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>可以读取和写入操作数</td>
</tr>
<tr>
<td>=</td>
<td>只能写入操作数</td>
</tr>
<tr>
<td>%</td>
<td>如果有必要操作数可以和下一个操作数切换</td>
</tr>
<tr>
<td>&amp;</td>
<td>在内联函数完成之前, 可以删除和重新使用操作数</td>
</tr>
</tbody>
</table>
</div>
<p>根据表格内容，可以看出该内联汇编作用就是引发一个int中断，中断向量为立即数<code>T_SYSCALL</code>，同时，对寄存器进行操作。</p>
<p>首先不要忘记在<code>kern/trap.c</code>中的<code>trap_init</code>中设置好入口，并且权限设为3，使得用户进程能够产生这个中断。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, handler48, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>另外就是<code>trap_dispatch</code>函数中加入相应的处理方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_SYSCALL:</span><br><span class="line">    tf-&gt;tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax, </span><br><span class="line">                    tf-&gt;tf_regs.reg_edx,</span><br><span class="line">                    tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">                    tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">                    tf-&gt;tf_regs.reg_edi,</span><br><span class="line">                    tf-&gt;tf_regs.reg_esi);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br>由于已经通过<code>lib/syscall.c</code>处理，<code>tf</code>结构体中存储的寄存器状态已经记录了系统调用号，系统调用参数等等。现在我们就可以利用这些信息调用<code>kern/syscall.c</code>中的函数了。</p>
<p>在函数<code>trap_dispatch</code>中，被分发到函数<code>handle_syscall</code>。在<code>handle_syscall</code>中调用真正的<code>syscall</code>函数，进行二次分发和运行。内核调用的函数<code>syscall</code>和用户调用的不同，前者在<code>kern/syscall.c</code>中，根据<code>syscallno</code>选择处理函数执行，如下：</p>
<p>kern/syscall.h<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">syscall</span><span class="params">(<span class="type">uint32_t</span> num, <span class="type">uint32_t</span> a1, <span class="type">uint32_t</span> a2, <span class="type">uint32_t</span> a3, <span class="type">uint32_t</span> a4, <span class="type">uint32_t</span> a5)</span>;</span><br></pre></td></tr></table></figure><br>用户调用的syscall函数接受6个参数。第一个是系统调用序号，告诉内核要使用那个处理函数，进入寄存器eax。后5个是传递给内核中的处理函数的参数，进入剩下的寄存器edx, ecx, ebx, edi, esi。这些寄存器都在中断产生时被压栈了，可以通过Trapframe访问到。</p>
<p>我们在<code>kern/trap.c</code>中调用的实际上就是这里的<code>syscall</code>函数，而不是<code>lib/syscall.c</code>中的那个。想明白这一点，设置参数也就很简单了，注意返回值的处理。</p>
<p>kern/syscall.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">uint32_t</span> syscallno, <span class="type">uint32_t</span> a1, <span class="type">uint32_t</span> a2, <span class="type">uint32_t</span> a3, <span class="type">uint32_t</span> a4, <span class="type">uint32_t</span> a5)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span></span><br><span class="line">    <span class="comment">// Return any appropriate return value.</span></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// panic(&quot;syscall not implemented&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">    <span class="keyword">case</span> SYS_cputs:</span><br><span class="line">        sys_cputs((<span class="type">const</span> <span class="type">char</span> *)a1, a2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">        retVal = sys_cgetc();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">        retVal = sys_env_destroy(a1);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">        retVal = sys_getenvid() &gt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">        <span class="comment">// retVal = sys_getenvid() &gt;= 0; 错误，应该返回获取的id</span></span><br><span class="line">        <span class="comment">// 返回值不仅是用于判断执行成功与否，也可能携带信息</span></span><br><span class="line">        retVal = sys_getenvid();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        retVal = -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以<code>user/hello.c</code>为例，其中调用了<code>cprintf()</code>，注意这是<code>lib/print.c</code>中的<code>cprintf</code>，该<code>cprintf()</code>最终会调用<code>lib/syscall.c</code>中的<code>sys_cputs()</code>，<code>sys_cputs()</code>又会调用<code>lib/syscall.c</code>中的<code>syscall()</code>，该函数将系统调用号放入<code>%eax</code>寄存器，五个参数依次放入in DX, CX, BX, DI, SI，然后执行指令<code>int 0x30</code>，发生中断后，去IDT中查找中断处理函数，最终会走到<code>kern/trap.c</code>的<code>trap_dispatch()</code>中，我们根据中断号<code>0x30</code>，又会调用<code>kern/syscall.c</code>中的<code>syscall()</code>函数（注意这时候我们已经进入了内核模式CPL=0），在该函数中根据系统调用号调用<code>kern/print.c</code>中的<code>cprintf()</code>函数，该函数最终调用<code>kern/console.c</code>中的<code>cputchar()</code>将字符串打印到控制台。当<code>trap_dispatch()</code>返回后，<code>trap()</code>会调用<code>env_run(curenv);</code>，该函数前面讲过，会将<code>curenv-&gt;env_tf</code>结构中保存的寄存器快照重新恢复到寄存器中，这样又会回到用户程序系统调用之后的那条指令运行，只是这时候已经执行了系统调用并且寄存器eax中保存着系统调用的返回值。任务完成重新回到用户模式CPL=3。</p>
<p>通过 exercise 7，可以看出 JOS系 统调用的步骤为：</p>
<ul>
<li>用户进程使用<code>inc/</code>目录下暴露的接口</li>
<li><code>lib/syscall.c</code>中的函数将系统调用号及必要参数传给寄存器，并引起一次<code>int $0x30</code>中断</li>
<li><code>kern/trap.c</code>捕捉到这个中断，并将<code>TrapFrame</code>记录的寄存器状态作为参数，调用处理中断的函数</li>
<li><code>kern/syscall.c</code>处理中断</li>
</ul>
<p><strong>记住这两个execrise能成功执行的话，需要在SETGATE中把这个设置成用户进程能够调用！！！</strong></p>
<h3 id="用户进程启动"><a href="#用户进程启动" class="headerlink" title="用户进程启动"></a>用户进程启动</h3><p>用户进程从<code>lib/entry.S</code>开始运行。经过一些设置，调用了<code>lib/libmain.c</code>下的<code>libmain()</code>函数。在<code>libmain()</code>中，我们需要把全局指针<code>thisenv</code>指向该程序在<code>envs[]</code>数组中的位置。</p>
<p><code>libmain()</code>会调用<code>umain</code>，即用户进程的<code>main</code>函数。在<code>user/hello.c</code>中，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">umain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    cprintf(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    cprintf(<span class="string">&quot;i am environment %08x\n&quot;</span>, thisenv-&gt;env_id);  <span class="comment">// 之前就在这里报错，因为thisenv = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Exercise 8 中，我们将设置好<code>thisenv</code>，这样就能正常运行用户进程了。这也是我们第一次用到内存的 UENVS 区域。</p>
<p>在<code>lib/libmain.c</code>中把<code>thisenv = 0</code>改为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br></pre></td></tr></table></figure></p>
<h3 id="页错误-amp-内存保护"><a href="#页错误-amp-内存保护" class="headerlink" title="页错误 &amp; 内存保护"></a>页错误 &amp; 内存保护</h3><p>内存保护是操作系统的关键功能，它确保了一个程序中的错误不会导致其他程序或是操作系统自身的崩溃。</p>
<p>操作系统通常依赖硬件的支持来实现内存保护。操作系统会告诉硬件哪些虚拟地址可用哪些不可用。当某个程序想访问不可用的内存地址或不具备权限时，处理器将在出错指令处停止程序，然后陷入内核。如果错误可以处理，内核就处理并恢复程序运行，否则无法恢复。</p>
<p>作为可以修复的错误，设想某个自动生长的栈。在许多系统中内核首先分配一个页面给栈，如果某个程序访问了页面外的空间，内核会自动分配更多页面以让程序继续。这样，内核只用分配程序需要的栈内存给它，然而程序感觉仿佛可以拥有任意大的栈内存。</p>
<p>系统调用也为内存保护带来了有趣的问题。许多系统调用接口允许用户传递指针给内核，这些指针指向待读写的用户缓冲区。内核处理系统调用的时候会对这些指针解引用。这样就带来了两个问题：</p>
<ol>
<li>内核的页错误通常比用户进程的页错误严重得多，如果内核在操作自己的数据结构时发生页错误，这就是一个内核bug，会引起系统崩溃。因此，内核需要记住这个错误是来自用户进程。</li>
<li>内核比用户进程拥有更高的内存权限，用户进程给内核传递的指针可能指向一个只有内核能够读写的区域，内核必须谨慎避免解引用这类指针，因为这样可能导致内核的私有信息泄露或破坏内核完整性。</li>
</ol>
<p>我们将对用户进程传给内核的指针做一个检查来解决这两个问题。内核将检查指针指向的是内存中用户空间部分，页表也允许内存操作。</p>
<p>Exercise 9需要修改<code>kern/trap.c</code>，使得内核态下的缺页能够引起panic。这需要检查<code>tf_cs</code>的地位。在<code>kern/trap.c</code>中加入判断页错误来源。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_fault_handler</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read processor&#x27;s CR2 register to find the faulting address</span></span><br><span class="line">    fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// 在这里判断 cs 的低 2bit</span></span><br><span class="line">    <span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>) panic(<span class="string">&quot;Page fault in kernel-mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line">    <span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">    cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">        curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/pmap.c</code>中修改检查用户内存的部分。需要注意的是由于需要存储第一个访问出错的地址，<code>va</code>所在的页面需要单独处理一下，不能直接对齐。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Check that an environment is allowed to access the range of memory</span></span><br><span class="line"><span class="comment">// [va, va+len) with permissions &#x27;perm | PTE_P&#x27;.</span></span><br><span class="line"><span class="comment">// Normally &#x27;perm&#x27; will contain PTE_U at least, but this is not required.</span></span><br><span class="line"><span class="comment">// &#x27;va&#x27; and &#x27;len&#x27; need not be page-aligned; you must test every page that</span></span><br><span class="line"><span class="comment">// contains any of that range.  You will test either &#x27;len/PGSIZE&#x27;,</span></span><br><span class="line"><span class="comment">// &#x27;len/PGSIZE + 1&#x27;, or &#x27;len/PGSIZE + 2&#x27; pages.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A user program can access a virtual address if (1) the address is below</span></span><br><span class="line"><span class="comment">// ULIM, and (2) the page table gives it permission.  These are exactly</span></span><br><span class="line"><span class="comment">// the tests you should implement here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If there is an error, set the &#x27;user_mem_check_addr&#x27; variable to the first</span></span><br><span class="line"><span class="comment">// erroneous virtual address.</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">user_mem_check</span><span class="params">(<span class="keyword">struct</span> Env *env, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">size_t</span> len, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="type">uintptr_t</span> start_va = ROUNDDOWN((<span class="type">uintptr_t</span>)va, PGSIZE);</span><br><span class="line">    <span class="type">uintptr_t</span> end_va = ROUNDUP((<span class="type">uintptr_t</span>)va + len, PGSIZE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uintptr_t</span> cur_va=start_va; cur_va&lt;end_va; cur_va+=PGSIZE) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *cur_pte = pgdir_walk(env-&gt;env_pgdir, (<span class="type">void</span> *)cur_va, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (cur_pte == <span class="literal">NULL</span> || (*cur_pte &amp; (perm|PTE_P)) != (perm|PTE_P) || cur_va &gt;= ULIM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_va == start_va) &#123;</span><br><span class="line">                user_mem_check_addr = (<span class="type">uintptr_t</span>)va;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                user_mem_check_addr = cur_va;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/syscall.c</code>中的输出字符串部分加入内存检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sys_cputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line">    <span class="comment">// Destroy the environment if not.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    user_mem_assert(curenv, s, len, PTE_U);</span><br><span class="line">    <span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">    cprintf(<span class="string">&quot;%.*s&quot;</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/kdebug.c</code>中的<code>debuginfo_eip</code>函数中加入内存检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Make sure this memory is valid.</span></span><br><span class="line">        <span class="comment">// Return -1 if it is not.  Hint: Call user_mem_check.</span></span><br><span class="line">        <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">        <span class="keyword">if</span> (user_mem_check(curenv, (<span class="type">void</span> *)usd, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UserStabData), PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">        <span class="comment">// Make sure the STABS and string table memory is valid.</span></span><br><span class="line">        <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">        <span class="keyword">if</span> (user_mem_check(curenv, (<span class="type">void</span> *)stabs, stab_end-stabs, PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (user_mem_check(curenv, (<span class="type">void</span> *)stabstr, stabstr_end-stabstr, PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="TA’s-Exercise"><a href="#TA’s-Exercise" class="headerlink" title="TA’s Exercise"></a>TA’s Exercise</h3><p>在 JOS 中添加一个展示进程信息的系统调用 ( 请在<code>inc/syscall.h</code>中定义<code>SYS_show_environments</code>)，该系统调用可打印出所有进程的信息 ( 即<code>struct Env</code>的 内容，只打印<code>env_id</code>，寄存器信息等重要内容即可 )。</p>
<h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><p>在<code>inc/syscall.h</code>中的枚举中定义变量<code>SYS_show_environments</code>，后在<code>kern/syscall.c</code>中定义函数<code>static void sys_show_environments(void)</code>打印<code>envs</code>数组中正在进行的进程的<code>env_id</code>以及状态 ( 不包括<code>env_status == ENV_NOT_RUNNABLE</code>)，并且在文件末尾<code>syscall</code>函数中加入新加<code>system call</code>。到此为止，我们设置完了在 kernel model 下新系统调用的调用过程，之后转向 user model. 在<code>inc/lib</code>中声明刚定义的系统调用，并转到<code>lib/syscall.c</code>下的<code>syscall.c</code>中，利用<code>syscall</code>调用之前定义在<code>kernel</code>中的<code>sys_show_environments(void)</code>，最后在<code>user/hello.c</code>中加入了这个调用就可以看到结果了.</p>
<h4 id="调用过程及代码实现"><a href="#调用过程及代码实现" class="headerlink" title="调用过程及代码实现"></a>调用过程及代码实现</h4><p><code>user/hello.c</code>调用在<code>inc/lib.h</code>中声明的<code>sys_show_environments()</code>，也就是在<code>lib/syscall.c</code>中定义的 ( 面对 user model 的 )<code>sys_show_environments()</code>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// at inc/lib.h:42</span><br><span class="line">void sys_show_environments(void);</span><br></pre></td></tr></table></figure></p>
<p>应用程序调用<code>inc/lib.h</code>中的<code>sys_show_environments()</code>函数，在<code>lib/syscall.c</code>中函数调用<code>syscall()</code>并且传参<code>SYS_show_environments</code>给<code>syscall()</code>。之后<code>syscall()</code>利用内联汇编 trap into the kernel 并将<code>T_SYSCALL</code>，<code>SYS_show_environments</code>这两个参数传给给后续函数 ( 后面虽然还传递了好几个 0 但是这里没有用就当他们不存在，而这里<code>T_SYSCALL</code>( 作为立即数传入 “i” ) 是用来做为索引给<code>IDT</code>找到<code>SystemCall</code>这个<code>Interrupt</code>的<code>Gate</code>( 当然这也是之后<code>trap_dispatch()</code>要用到的参数 )，而之后的<code>SYS_show_environments</code>会被放入<code>%eax</code>中，之后将通过<code>Trapfram</code>进入<code>kernel model</code>下的<code>stack</code>被<code>kernel</code>中的<code>system call</code>识别并调用对应的系统调用。)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// at lib/syscall.c:64</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sys_show_environments</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    syscall(SYS_show_environments, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>trap_dispatch()</code>中选择<code>syscall()</code>函数，并将<code>Trapfram</code>中的”寄存器” ( 其实是在 kernel stack 中 ) 保存的数据作为参数传入，之后在<code>kern/syscall.c</code>中<code>syscall()</code>选择<code>sys_show_environments()</code>函数打印进程相关信息.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sys_show_environments</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NENV; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (envs[i].env_status == ENV_FREE || \</span><br><span class="line">        envs[i].env_status == ENV_NOT_RUNNABLE)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cprintf(<span class="string">&quot;Environment env_id: %x\tstatus: &quot;</span>, envs[i].env_id);</span><br><span class="line">        <span class="keyword">switch</span>(envs[i].env_status)&#123;</span><br><span class="line">            <span class="keyword">case</span> ENV_DYING:</span><br><span class="line">                cprintf(<span class="string">&quot;ENV_DYING\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ENV_RUNNABLE:</span><br><span class="line">                cprintf(<span class="string">&quot;ENV_RUNNABLE\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ENV_RUNNING:</span><br><span class="line">                cprintf(<span class="string">&quot;ENV_RUNNING\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></span><br><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">uint32_t</span> syscallno, <span class="type">uint32_t</span> a1, <span class="type">uint32_t</span> a2, <span class="type">uint32_t</span> a3, <span class="type">uint32_t</span> a4, <span class="type">uint32_t</span> a5)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span></span><br><span class="line">    <span class="comment">// Return any appropriate return value.</span></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">        <span class="keyword">case</span> SYS_cputs:</span><br><span class="line">            sys_cputs((<span class="type">char</span> *)a1, (<span class="type">size_t</span>)a2);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">            <span class="keyword">return</span> sys_cgetc();</span><br><span class="line">        <span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">            <span class="keyword">return</span> sys_getenvid();</span><br><span class="line">        <span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">            <span class="keyword">return</span> sys_env_destroy((<span class="type">envid_t</span>)a1);</span><br><span class="line">        <span class="keyword">case</span> SYS_show_environments:</span><br><span class="line">            sys_show_environments();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> NSYSCALLS:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    panic(<span class="string">&quot;syscall not implemented&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回顾下，本实验大致做了三件事：</p>
<ul>
<li>进程建立，可以加载用户ELF文件并执行。<ul>
<li>内核维护一个名叫<code>envs</code>的<code>Env</code>数组，每个<code>Env</code>结构对应一个进程，<code>Env</code>结构最重要的字段有<code>Trapframe env_tf</code>（该字段中断发生时可以保持寄存器的状态），<code>pde_t *env_pgdir</code>（该进程的页目录地址）。进程对应的内核数据结构可以用下图总结：</li>
<li>定义了<code>env_init()</code>，<code>env_create()</code>等函数，初始化<code>Env</code>结构，将<code>Env</code>结构<code>Trapframe env_tf</code>中的寄存器值设置到寄存器中，从而执行该<code>Env</code>。</li>
</ul>
</li>
</ul>
<p><img src="/img/20211121113100.png" alt=""></p>
<ul>
<li>创建异常处理函数，建立并加载IDT，使JOS能支持中断处理。要能说出中断发生时的详细步骤。需要搞清楚内核态和用户态转换方式：通过中断机制可以从用户环境进入内核态。使用iret指令从内核态回到用户环境。<ul>
<li>新建一个中断的步骤主要有：创建一个define标号，SETGATE注册中断和处理函数、特权级；在trap_dispatch中注册。</li>
<li>中断发生过程以及中断返回过程和系统调用原理可以总结为下图：</li>
</ul>
</li>
</ul>
<p><img src="/img/20211121113101.png" alt=""></p>
<ul>
<li>利用中断机制，使JOS支持系统调用。要能说出遇到int 0x30这条系统调用指令时发生的详细步骤。</li>
</ul>
<h1 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>在 lab4 中我们将实现多个同时运行的用户进程之间的抢占式多任务处理。</p>
<ul>
<li>在 part A 中，我们需要给 JOS 增加多处理器支持。实现轮询( round-robin, RR )调度，并增加基本的用户程序管理系统调用( 创建和销毁进程，分配和映射内存 )。</li>
<li>在 part B 中，我们需要实现一个与 Unix 类似的<code>fork()</code>，允许一个用户进程创建自己的拷贝。</li>
<li>在 part C中，我们会添加对进程间通信 ( IPC ) 的支持，允许不同的用户进程相互通信和同步。还要增加对硬件时钟中断和抢占的支持。</li>
</ul>
<p>Lab 4 包含许多新的源文件：</p>
<ul>
<li><code>kern/cpu.h</code>：多处理器支持的内核私有定义</li>
<li><code>kern/mpconfig.c</code>：读取多处理器配置的代码</li>
<li><code>kern/lapic.c</code>：驱动每个处理器中的本地 APIC 单元的内核代码</li>
<li><code>kern/mpentry.S</code>：非引导 CPU 的汇编语言入口代码</li>
<li><code>kern/spinlock.h</code>：自旋锁的内核私有定义，包括大内核锁</li>
<li><code>kern/spinlock.c</code>：实现自旋锁的内核代码</li>
<li><code>kern/sched.c</code>：将要实现的调度程序的代码框架</li>
</ul>
<h2 id="Part-A-多处理器支持及协同多任务处理"><a href="#Part-A-多处理器支持及协同多任务处理" class="headerlink" title="Part A: 多处理器支持及协同多任务处理"></a>Part A: 多处理器支持及协同多任务处理</h2><p>我们首先需要把 JOS 扩展到在多处理器系统中运行。然后实现一些新的 JOS 系统调用来允许用户进程创建新的进程。我们还要实现协同轮询调度，在当前进程不使用 CPU 时允许内核切换到另一个进程。</p>
<h3 id="多处理器支持"><a href="#多处理器支持" class="headerlink" title="多处理器支持"></a>多处理器支持</h3><p>我们即将使 JOS 能够支持“对称多处理” (Symmetric MultiProcessing, SMP)。这种模式使所有 CPU 能对等地访问内存、I/O 总线等系统资源。虽然 CPU 在 SMP 下以同样的方式工作，在启动过程中他们可以被分为两个类型：</p>
<ul>
<li>引导处理器(BootStrap Processor, BSP) 负责初始化系统以及启动操作系统；</li>
<li>应用处理器( Application Processors, AP ) 在操作系统拉起并运行后由 BSP 激活。</li>
</ul>
<p>哪个 CPU 作为 BSP 由硬件和 BIOS 决定。也就是说目前我们所有的 JOS 代码都运行在 BSP 上。</p>
<p>在 SMP 系统中，每个 CPU 都有一个附属的 (local APIC) LAPIC 单元。LAPIC 单元用于传递中断，并给它所属的 CPU 一个唯一的 ID。在 lab4 中，我们将会用到 LAPIC 单元的以下基本功能 ( 见<code>kern/lapic.c1</code>)：</p>
<ul>
<li>读取 APIC ID 来判断我们的代码运行在哪个 CPU 之上。</li>
<li>从 BSP 发送 STARTUP 跨处理器中断 (InterProcessor Interrupt, IPI) 来启动 AP。</li>
<li>在 part C 中，我们为 LAPIC 的内置计时器编程来触发时钟中断以支持抢占式多任务处理。</li>
</ul>
<p>处理器通过映射在内存上的 I/O (Memory-Mapped I/O, MMIO) 来访问它的 LAPIC。在 MMIO 中，物理内存的一部分被硬连接到一些 I/O 设备的寄存器，因此，访问内存的 load/store 指令可以被用于访问设备的寄存器。实际上，我们在 lab1 中已经接触过这样的 IO hole，如0xA0000被用来写 VGA 显示缓冲。</p>
<p>LAPIC 开始于物理地址 0xFE000000 ( 4GB以下32MB处 )。如果用以前的映射算法（将0xF0000000 映射到 0x00000000，也就是说内核空间最高只能到物理地址0x0FFFFFFF）显然太高了。因此，JOS 在<code>MMIOBASE</code>(即 虚拟地址0xEF800000) 预留了 4MB 来映射这类设备。我们需要写一个函数来分配这个空间并在其中映射设备内存。</p>
<p>exercise1需要实现<code>kern/pmap.c</code>中的<code>mmio_map_region</code>。首先还得去看<code>kern/lapic.c</code>中<code>lapic_init</code>的实现。<code>lapic_init()</code>函数的一开始就调用了该函数，将从<code>lapicaddr</code>开始的 4kB 物理地址映射到虚拟地址，并返回其起始地址。注意到，它是以页为单位对齐的，每次都<code>map</code>一个页的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">lapic_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (!lapicaddr)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lapicaddr is the physical address of the LAPIC&#x27;s 4K MMIO</span></span><br><span class="line">        <span class="comment">// region.  Map it in to virtual memory so we can access it.</span></span><br><span class="line">        lapic = mmio_map_region(lapicaddr, <span class="number">4096</span>);</span><br><span class="line">        .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从基址开始保留大小字节的虚拟内存并将物理页 [pa,pa+size) 映射到虚拟地址 [base,base+size)。 由于这是设备内存而不是常规 DRAM，因此您必须告诉 CPU 缓存访问此内存是不安全的。幸运的是，分页表为此提供了位；除了<code>PTE_W</code>之外，只需使用<code>PTE_PCD|PTE_PWT</code>（缓存禁用和直写）创建映射。</p>
<p>实际就是调用<code>boot_map_region</code>来建立所需要的映射，需要注意的是，每次需要更改base的值，使得每次都是映射到一个新的页面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span></span><br><span class="line"><span class="comment">// location.  Return the base of the reserved region.  size does *not*</span></span><br><span class="line"><span class="comment">// have to be multiple of PGSIZE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">mmio_map_region</span><span class="params">(<span class="type">physaddr_t</span> pa, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">physaddr_t</span> pa_begin = ROUNDDOWN(pa, PGSIZE);</span><br><span class="line">	<span class="type">physaddr_t</span> pa_end = ROUNDUP(pa + size, PGSIZE);</span><br><span class="line">	<span class="keyword">if</span> (pa_end - pa_begin &gt;= MMIOLIM - MMIOBASE) &#123;</span><br><span class="line">	    panic(<span class="string">&quot;mmio_map_region: requesting size too large.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	size = pa_end - pa_begin;</span><br><span class="line">	boot_map_region(kern_pgdir, base, size, pa_begin, PTE_W | PTE_PCD | PTE_PWT);</span><br><span class="line">	<span class="type">void</span> *ret = (<span class="type">void</span> *)base;</span><br><span class="line">	base += size;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="引导应用处理器"><a href="#引导应用处理器" class="headerlink" title="引导应用处理器"></a>引导应用处理器</h3><p>在启动 APs 之前，<code>BSP</code>需要先搜集多处理器系统的信息，例如 CPU 的总数，CPU 各自的 APIC ID，LAPIC 单元的 MMIO 地址。<code>kern/mpconfig.c</code>中的<code>mp_init()</code>函数通过阅读 BIOS 区域内存中的 MP 配置表来获取这些信息。</p>
<p><code>boot_aps()</code>函数驱动了 AP 的引导。APs 从实模式开始，如同<code>boot/boot.S</code>中<code>bootloader</code>的启动过程。因此<code>boot_aps()</code>将 AP 的入口代码 (<code>kern/mpentry.S</code>) 拷贝到实模式可以寻址的内存区域 (0x7000,<code>MPENTRY_PADDR</code>)。</p>
<p>此后，<code>boot_aps()</code>通过发送<code>STARTUP</code>这个跨处理器中断到各 LAPIC 单元的方式，逐个激活 APs。激活方式为：初始化 AP 的<code>CS:IP</code>值使其从入口代码执行（<code>MPENTRY_PADDR</code>）。<code>kern/mpentry.S</code>中的入口代码跟<code>boot/boot.S</code>中的代码相同。通过一些简单的设置，AP 开启分页进入保护模式，然后调用 C 语言编写的<code>mp_main()</code>。<code>boot_aps()</code>等待 AP 发送<code>CPU_STARTED</code>信号，然后再唤醒下一个。</p>
<p>先看<code>boot_aps()</code>，注释比较清楚，将入口代码复制到<code>MPENTRY_PADDR</code>中，遍历cpu，告诉<code>mpentry.S</code>栈的入口在哪，函数<code>lapic_startup</code>向指定处理器发送信号，触发了中断，让处理器从指定地址开始执行。APIC更具体的操作细节我们就不关心了。启动，等待完成。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the non-boot (AP) processors.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_aps</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> mpentry_start[], mpentry_end[];</span><br><span class="line">    <span class="type">void</span> *code;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> *<span class="title">c</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write entry code to unused memory at MPENTRY_PADDR</span></span><br><span class="line">    code = KADDR(MPENTRY_PADDR);</span><br><span class="line">    memmove(code, mpentry_start, mpentry_end - mpentry_start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Boot each AP one at a time</span></span><br><span class="line">    <span class="keyword">for</span> (c = cpus; c &lt; cpus + ncpu; c++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == cpus + cpunum())  <span class="comment">// We&#x27;ve started already.</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell mpentry.S what stack to use</span></span><br><span class="line">        mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;</span><br><span class="line">        <span class="comment">// Start the CPU at mpentry_start</span></span><br><span class="line">        lapic_startap(c-&gt;cpu_id, PADDR(code));</span><br><span class="line">        <span class="comment">// Wait for the CPU to finish some basic setup in mp_main()</span></span><br><span class="line">        <span class="keyword">while</span>(c-&gt;cpu_status != CPU_STARTED)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>mpentry.S</code>中，每一个没有启动的CPU(“AP”)都会因为一个<code>STARTUP</code>中断而启动。AP启动时，<code>CS:IP</code>会被设置成<code>XY00:0000</code>，<code>XY</code>是跟着<code>STARTUP</code>一起送过来的值。</p>
<p>代码中设置<code>DS</code>为0，必须从物理地址中的低2^16字节开始运行。</p>
<p>在系统加载的过程中，<code>boot_aps()</code>被调用，然后按照前文所述使用<code>memmove()</code>函数从<code>mpentry.S</code>中拷贝文件中<code>.global mpentry_start</code>标签处开始的入口代码直到<code>.global mpentry_end</code>结束，代码被拷贝到<code>MPENTRY_PADDR</code>（此处是0x7000的I/O hole）对应的内核虚拟地址（别忘了必须拷贝到内核虚拟地址才可以被内核所操作）。然后<code>boot_aps()</code>根据每一个CPU的栈配置<code>percpu_kstacks[]</code>来为每一个AP设置栈地址<code>mpentry_stack</code>。再之后调用<code>lapic_startup()</code>函数来启动AP，并等待AP的状态变为<code>CPU_STARTED</code>以切换到下一个AP的配置。AP启动后会开启分页机制和保护模式，切换运行栈，然后跳转到<code>mp_main()</code>函数。</p>
<p>在<code>mp_main()</code>函数中，使用<code>lcr3</code>指令切换页目录到<code>kern_pgdir</code>，初始化LAPIC、用户环境和陷阱处理机制。最后设置<code>struct CpuInfo</code>中的<code>cpu_status</code>为<code>CPU_STARTED</code>来告知BPS已经启动成功。</p>
<p>此代码类似于<code>boot/boot.S</code>，不同之处在于</p>
<ul>
<li>不需要启用A20</li>
<li>它使用<code>MPBOOTPHYS</code>计算其绝对地址符号，而不是依赖链接器来填充它们</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">.set PROT_MODE_CSEG, 0x8        ## kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG, 0x10       ## kernel data segment selector</span><br><span class="line"></span><br><span class="line">.code16</span><br><span class="line">.globl mpentry_start</span><br><span class="line">mpentry_start:</span><br><span class="line">        cli</span><br><span class="line"></span><br><span class="line">        xorw    %ax, %ax</span><br><span class="line">        movw    %ax, %ds</span><br><span class="line">        movw    %ax, %es</span><br><span class="line">        movw    %ax, %ss</span><br><span class="line"></span><br><span class="line">        lgdt    MPBOOTPHYS(gdtdesc)</span><br><span class="line">        movl    %cr0, %eax</span><br><span class="line">        orl     $CR0_PE, %eax</span><br><span class="line">        movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line">        ljmpl   $(PROT_MODE_CSEG), $(MPBOOTPHYS(start32))</span><br><span class="line"></span><br><span class="line">.code32</span><br><span class="line">start32:</span><br><span class="line">        movw    $(PROT_MODE_DSEG), %ax</span><br><span class="line">        movw    %ax, %ds</span><br><span class="line">        movw    %ax, %es</span><br><span class="line">        movw    %ax, %ss</span><br><span class="line">        movw    $0, %ax</span><br><span class="line">        movw    %ax, %fs</span><br><span class="line">        movw    %ax, %gs</span><br><span class="line"></span><br><span class="line">        ## Set up initial page table. We cannot use kern_pgdir yet because</span><br><span class="line">        ## we are still running at a low EIP.</span><br><span class="line">        movl    $(RELOC(entry_pgdir)), %eax</span><br><span class="line">        movl    %eax, %cr3</span><br><span class="line">        ## Turn on paging.</span><br><span class="line">        movl    %cr0, %eax</span><br><span class="line">        orl     $(CR0_PE|CR0_PG|CR0_WP), %eax</span><br><span class="line">        movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line">        ## Switch to the per-cpu stack allocated in boot_aps()</span><br><span class="line">        movl    mpentry_kstack, %esp</span><br><span class="line">        movl    $0x0, %ebp       ## nuke frame pointer</span><br><span class="line"></span><br><span class="line">        ## Call mp_main().  (Exercise for the reader: why the indirect call?)</span><br><span class="line">        movl    $mp_main, %eax</span><br><span class="line">        call    *%eax</span><br><span class="line"></span><br><span class="line">        ## If mp_main returns (it shouldn&#x27;t), loop.</span><br><span class="line">spin:</span><br><span class="line">        jmp     spin</span><br><span class="line"></span><br><span class="line">## Bootstrap GDT</span><br><span class="line">.p2align 2                                      ## force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">        SEG_NULL                                ## null seg</span><br><span class="line">        SEG(STA_X|STA_R, 0x0, 0xffffffff)       ## code seg</span><br><span class="line">        SEG(STA_W, 0x0, 0xffffffff)             ## data seg</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">        .word   0x17                            ## sizeof(gdt) - 1</span><br><span class="line">        .long   MPBOOTPHYS(gdt)                 ## address gdt</span><br><span class="line"></span><br><span class="line">.globl mpentry_end</span><br><span class="line">mpentry_end:</span><br><span class="line">        nop</span><br></pre></td></tr></table></figure>
<p>我们修改文件<code>kern/pmap.c</code>中的函数<code>page_init</code>，在构建链表的时候避开AP使用的引导器的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4:</span></span><br><span class="line">    <span class="comment">// Change your code to mark the physical page at MPENTRY_PADDR as in use</span></span><br><span class="line"></span><br><span class="line">    pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> mp_page = MPENTRY_PADDR / PGSIZE;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages_basemem; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == mp_page) &#123; <span class="comment">// lab 4</span></span><br><span class="line">            pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must never be allocated.</span></span><br><span class="line">    <span class="keyword">for</span> (i = IOPHYSMEM/PGSIZE; i &lt; EXTPHYSMEM/PGSIZE; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line">    <span class="type">size_t</span> first_free_address = PADDR(boot_alloc(<span class="number">0</span>)) / PGSIZE;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; first_free_address; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; npages; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在执行<code>make qemu</code>，可以通过<code>check_kern_pgdir()</code>测试，但是不会通过<code>check_kern_pgdir()</code>检查。</p>
<p><code>kern/mpentry.S</code>是运行在<code>KERNBASE</code>之上的，与其他的内核代码一样。也就是说，类似于<code>mpentry_start</code>，<code>mpentry_end</code>，<code>start32</code>这类地址，都位于<code>0xf0000000</code>之上，显然，实模式是无法寻址的。再仔细看<code>MPBOOTPHYS</code>的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR)</span></span><br></pre></td></tr></table></figure></p>
<p>其意义可以表示为，从<code>mpentry_start</code>到<code>MPENTRY_PADDR</code>建立映射，将<code>mpentry_start + offset</code>地址转为<code>MPENTRY_PADDR + offset</code>地址。查看<code>kern/init.c</code>，发现已经完成了这部分地址的内容拷贝。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_aps</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> mpentry_start[], mpentry_end[];</span><br><span class="line">    <span class="type">void</span> *code;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> *<span class="title">c</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write entry code to unused memory at MPENTRY_PADDR</span></span><br><span class="line">    code = KADDR(MPENTRY_PADDR);</span><br><span class="line">    memmove(code, mpentry_start, mpentry_end - mpentry_start);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，实模式下就可以通过<code>MPBOOTPHYS</code>宏的转换，运行这部分代码。<code>boot.S</code>中不需要这个转换是因为代码的本来就被加载在实模式可以寻址的地方。</p>
<h3 id="CPU-状态和初始化"><a href="#CPU-状态和初始化" class="headerlink" title="CPU 状态和初始化"></a>CPU 状态和初始化</h3><p>当写一个多处理器操作系统时，分清 CPU 的私有状态 ( per-CPU state) 及全局状态 (global state) 非常关键。<code>kern/cpu.h</code>定义了大部分的 per-CPU 状态。我们需要注意的 per-CPU 状态有：</p>
<ul>
<li>Per-CPU 内核栈<ul>
<li>因为多 CPU 可能同时陷入内核态，我们需要给每个处理器一个独立的内核栈。<code>percpu_kstacks[NCPU][KSTKSIZE]</code></li>
<li>在 Lab2 中，我们将<code>BSP</code>的内核栈映射到了<code>KSTACKTOP</code>下方。相似地，在 Lab4 中，我们需要把每个 CPU 的内核栈都映射到这个区域，每个栈之间留下一个空页作为缓冲区避免<code>overflow</code>。CPU 0 ，即<code>BSP</code>的栈还是从<code>KSTACKTOP</code>开始，间隔<code>KSTACKGAP</code>的距离就是 CPU 1 的栈，以此类推。</li>
</ul>
</li>
<li>Per-CPU TSS 以及 TSS 描述符<ul>
<li>为了指明每个 CPU 的内核栈位置，需要任务状态段 (Task State Segment, TSS)，其功能在 Lab3 中已经详细讲过。</li>
</ul>
</li>
<li>Per-CPU 当前环境指针<ul>
<li>因为每个 CPU 能够同时运行各自的用户进程，我们重新定义了基于<code>cpus[cpunum()]</code>的<code>curenv</code>。</li>
</ul>
</li>
<li>Per-CPU 系统寄存器<ul>
<li>所有的寄存器，包括系统寄存器，都是 CPU 私有的。因此，初始化这些寄存器的指令，例如<code>lcr3()</code>,<code>ltr()</code>,<code>lgdt()</code>,<code>lidt()</code>等，必须在每个 CPU 都执行一次。</li>
</ul>
</li>
</ul>
<p>在<code>kern/cpu.h</code>中可以找到对<code>NCPU</code>、CPU状态、<code>CpuInfo</code>以及全局变量<code>percpu_kstacks</code>的声明。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum number of CPUs</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NCPU  8</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CPU_UNUSED = <span class="number">0</span>,</span><br><span class="line">    CPU_STARTED,</span><br><span class="line">    CPU_HALTED,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Per-CPU state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> cpu_id;                 <span class="comment">// Local APIC ID; index into cpus[] below</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> cpu_status;   <span class="comment">// The status of the CPU</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">cpu_env</span>;</span>            <span class="comment">// The currently-running environment.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span> <span class="title">cpu_ts</span>;</span>        <span class="comment">// Used by x86 to find stack for interrupt</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Per-CPU kernel stacks</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> percpu_kstacks[NCPU][KSTKSIZE];</span><br></pre></td></tr></table></figure></p>
<p><code>percpu_kstacks</code>的定义在<code>kern/mpconfig.c</code>中可以找到，以<code>PGSIZE</code>对齐：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU kernel stacks</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> percpu_kstacks[NCPU][KSTKSIZE]</span><br><span class="line">__attribute__ ((aligned(PGSIZE)));</span><br></pre></td></tr></table></figure></p>
<p><code>mp_init()</code>是进行初始化的函数，首先设置一个初始cpu，之后对每个CPU进行处理。先通过调用<code>mpconfig()</code>找到<code>struct mpconf</code>然后根据这个结构体内的<code>entries</code>信息对各个ＣＰＵ结构体进行配置．</p>
<p>如果<code>proc-&gt;flag</code>是<code>MPPROC_BOOT</code>，说明这个入口对应的处理器是用于启动的处理器，我们把结构体数组<code>cpus[ncpu]</code>地址赋值给<code>bootcpu</code>指针．注意这里ncpu是个全局变量，那么这里实质上就是把cpus数组的第一个元素的地址给了<code>bootcpu</code>. </p>
<p>那个<code>ismp</code>是个全局变量，默认的初始值为0, 但是我们进行<code>mp_init()</code>的时候，就把这个全局变量置为1了，如果出现任何entries匹配错误(switch找不到对应项，跳进default)，这个时候我们多可处理器的初始化就失败了，不能用多核处理器进行机器的运行，于是<code>ismp</code>置为0<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mp_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mp</span> *<span class="title">mp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mpconf</span> *<span class="title">conf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mpproc</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span> *p;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    bootcpu = &amp;cpus[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> ((conf = mpconfig(&amp;mp)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ismp = <span class="number">1</span>;</span><br><span class="line">    lapicaddr = conf-&gt;lapicaddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = conf-&gt;entries, i = <span class="number">0</span>; i &lt; conf-&gt;entry; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (*p) &#123;</span><br><span class="line">        <span class="keyword">case</span> MPPROC:</span><br><span class="line">            proc = (<span class="keyword">struct</span> mpproc *)p;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;flags &amp; MPPROC_BOOT)</span><br><span class="line">                bootcpu = &amp;cpus[ncpu];</span><br><span class="line">            <span class="keyword">if</span> (ncpu &lt; NCPU) &#123;</span><br><span class="line">                cpus[ncpu].cpu_id = ncpu;</span><br><span class="line">                ncpu++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cprintf(<span class="string">&quot;SMP: too many CPUs, CPU %d disabled\n&quot;</span>,</span><br><span class="line">                       proc-&gt;apicid);</span><br><span class="line">            &#125;</span><br><span class="line">            p += <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mpproc);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> MPBUS:</span><br><span class="line">        <span class="keyword">case</span> MPIOAPIC:</span><br><span class="line">        <span class="keyword">case</span> MPIOINTR:</span><br><span class="line">        <span class="keyword">case</span> MPLINTR:</span><br><span class="line">            p += <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cprintf(<span class="string">&quot;mpinit: unknown config type %x\n&quot;</span>, *p);</span><br><span class="line">            ismp = <span class="number">0</span>;</span><br><span class="line">            i = conf-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bootcpu-&gt;cpu_status = CPU_STARTED;</span><br><span class="line">    <span class="keyword">if</span> (!ismp) &#123;</span><br><span class="line">        <span class="comment">// Didn&#x27;t like what we found; fall back to no MP.</span></span><br><span class="line">        ncpu = <span class="number">1</span>;</span><br><span class="line">        lapicaddr = <span class="number">0</span>;</span><br><span class="line">        cprintf(<span class="string">&quot;SMP: configuration not found, SMP disabled\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;SMP: CPU %d found %d CPU(s)\n&quot;</span>, bootcpu-&gt;cpu_id,  ncpu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mp-&gt;imcrp) &#123;</span><br><span class="line">        <span class="comment">// [MP 3.2.6.1] If the hardware implements PIC mode,</span></span><br><span class="line">        <span class="comment">// switch to getting interrupts from the LAPIC.</span></span><br><span class="line">        cprintf(<span class="string">&quot;SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n&quot;</span>);</span><br><span class="line">        outb(<span class="number">0x22</span>, <span class="number">0x70</span>);   <span class="comment">// Select IMCR</span></span><br><span class="line">        outb(<span class="number">0x23</span>, inb(<span class="number">0x23</span>) | <span class="number">1</span>);  <span class="comment">// Mask external interrupts.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理器同时运行，不能共享一个栈，每个处理器都要有自己的栈。当然，这种区分是在虚拟地址层面上的，不是在物理地址层面上的，不同虚拟地址可以映射到相同物理地址，也可以映射到不同。在这里，我们当然希望能够映射到不同地址上。</p>
<p>主要工作在函数<code>mem_init_mp</code>，这个函数在<code>mem_init</code>初始化完成BSP使用的栈后调用，为各个AP映射栈地址。</p>
<p>讲义和代码注释要求我们给每个栈分配<code>KSTKSIZE</code>大小，中间留出<code>KSTKGAP</code>作为保护，使得一个栈溢出一定不会影响相邻的栈。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modify mappings in kern_pgdir to support SMP</span></span><br><span class="line"><span class="comment">//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init_mp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Map per-CPU stacks starting at KSTACKTOP, for up to &#x27;NCPU&#x27; CPUs.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 对每个CPUi，使用percpu_kstacks[i]所代表的物理地址作为内核栈。</span></span><br><span class="line">        <span class="comment">// CPU i的内核栈从kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP)向下生长</span></span><br><span class="line">        <span class="comment">// 为了避免溢出，还会加上GAP</span></span><br><span class="line">        <span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// LAB 4: Your code here:</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; ++i) &#123;</span><br><span class="line">        boot_map_region(kern_pgdir,</span><br><span class="line">                        KSTACKTOP - i * (KSTKSIZE + KSTKGAP) - KSTKSIZE,</span><br><span class="line">                        KSTKSIZE,</span><br><span class="line">                        (<span class="type">physaddr_t</span>)PADDR(percpu_kstacks[i]),</span><br><span class="line">                        PTE_W);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我看着比较好的一种写法</span></span><br><span class="line">    <span class="comment">//uintptr_t start_addr = KSTACKTOP - KSTKSIZE;</span></span><br><span class="line">    <span class="comment">//   for (size_t i=0; i&lt;NCPU; i++) &#123;</span></span><br><span class="line">    <span class="comment">//       boot_map_region(kern_pgdir, (uintptr_t) start_addr, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W | PTE_P);</span></span><br><span class="line">    <span class="comment">//       start_addr -= KSTKSIZE + KSTKGAP;</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="各处理器中断初始化"><a href="#各处理器中断初始化" class="headerlink" title="各处理器中断初始化"></a>各处理器中断初始化</h3><p>在文件<code>kern/trap.c</code>中函数<code>trap_init_percpu</code>对每个AP的中断进行初始化。上一个Lab留下的版本，不能正确地在多处理器情况下运行。我们需要做一些小更改，让函数正确初始化每个AP的中断。</p>
<p>上一个Lab中，函数<code>trap_init_percpu</code>在函数<code>trap_init</code>中调用，<code>trap_init</code>在<code>i386_init</code>中调用。这是给BSP初始化中断。</p>
<p>AP内核入口函数<code>mp_main</code>调用了<code>trap_init_percpu</code>，这是给各个AP初始化中断。在BSP调用的<code>trap_init</code>函数中，中断描述符表已经初始化完成了，在各个AP中也就没比要再做，故没有调用<code>trap_init</code>。</p>
<p>只需要将<code>trap_init_percpu</code>的变量<code>ts</code>改为当前处理器的<code>Task State Segment</code>就可以，其它操作和上个Lab相同。需要注意计算出当前处理器的栈的正确地址，不再是<code>KSTACKTOP</code>了。</p>
<p>先注释掉<code>ts</code>，再根据单个cpu的代码做改动。在<code>inc/memlayout.h</code>中可以找到<code>GD_TSS0</code>的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GD_TSS0   0x28     <span class="comment">// Task segment selector for CPU 0</span></span></span><br></pre></td></tr></table></figure></p>
<p>但是并没有其他地方说明其他 CPU 的任务段选择器在哪。因此最大的难点就是找到这个值。实际上，偏移就是<code>cpu_id &lt;&lt; 3</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static struct Taskstate ts;</span></span><br><span class="line">...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span>* <span class="title">this_ts</span> =</span> &amp;thiscpu-&gt;cpu_ts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line">    <span class="comment">// when we trap to the kernel.</span></span><br><span class="line">    this_ts-&gt;ts_esp0 = KSTACKTOP - thiscpu-&gt;cpu_id*(KSTKSIZE + KSTKGAP);</span><br><span class="line">    this_ts-&gt;ts_ss0 = GD_KD;</span><br><span class="line">    this_ts-&gt;ts_iomb = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">    gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + thiscpu-&gt;cpu_id] = SEG16(STS_T32A, (<span class="type">uint32_t</span>) (this_ts),</span><br><span class="line">                    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + thiscpu-&gt;cpu_id].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line">    <span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">    ltr(GD_TSS0 + (thiscpu-&gt;cpu_id &lt;&lt; <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load the IDT</span></span><br><span class="line">    lidt(&amp;idt_pd);</span><br></pre></td></tr></table></figure>
<p>运行<code>make qemu CPUS=4</code>成功，输出如下提示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6828 decimal is 15254 octal!</span><br><span class="line">Physical memory: 131072K available, base = 640K, extended = 130432K</span><br><span class="line">check_page_free_list() succeeded!</span><br><span class="line">check_page_alloc() succeeded!</span><br><span class="line">check_page() succeeded!</span><br><span class="line">check_kern_pgdir() succeeded!</span><br><span class="line">check_page_free_list() succeeded!</span><br><span class="line">check_page_installed_pgdir() succeeded!</span><br><span class="line">SMP: CPU 0 found 4 CPU(s)</span><br><span class="line">enabled interrupts: 1 2</span><br><span class="line">SMP: CPU 1 starting</span><br><span class="line">SMP: CPU 2 starting</span><br><span class="line">SMP: CPU 3 starting</span><br></pre></td></tr></table></figure></p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>我们现在的代码在初始化 AP 后就会开始自旋。在进一步操作 AP 之前，我们要先处理几个 CPU 同时运行内核代码的竞争情况。最简单的方法是用一个大内核锁 (big kernel lock)。它是一个全局锁，在某个进程进入内核态时锁定，返回用户态时释放。这种模式下，用户进程可以并发地在 CPU 上运行，但是同一时间仅有一个进程可以在内核态，其他需要进入内核态的进程只能等待。<br><code>kern/spinlock.h</code>声明了一个大内核锁<code>kernel_lock</code>。它提供了<code>lock_kernel()</code>和<code>unlock_kernel()</code>方法用于获得和释放锁。在以下 4 个地方需要使用到大内核锁：</p>
<ul>
<li>在<code>i386_init()</code>，BSP 唤醒其他 CPU 之前获得内核锁</li>
<li>在<code>mp_main()</code>，初始化 AP 之后获得内核锁，之后调用<code>sched_yield()</code>在 AP 上运行进程。</li>
<li>在<code>trap()</code>，当从用户态陷入内核态时获得内核锁，通过检查<code>tf_cs</code>的低 2bit 来确定该 trap 是由用户进程还是内核触发。</li>
<li>在<code>env_run()</code>，在切换回用户模式前释放内核锁。</li>
</ul>
<p>Exercise 5是在合适的地方调用<code>lock_kernel()</code>和<code>unlock_kernel()</code>。在这些函数中，我们需要添加<code>lock/unlock</code>：<code>i386_init</code>, <code>mp_main</code>, <code>trap</code>, <code>env_run</code>。</p>
<p><code>i386_init</code>,<code>mp_main</code>函数的lock都发生在初始化完成，准备通过<code>sched_yield</code>进入用户进程之前。这时候加锁，让处理器依次加载用户进程，保证同一时刻只有一个处理器在内核态运行。</p>
<p>其它操作内核锁发生在进入和退出内核态的时候。处理器进入内核态后处在函数<code>trap</code>，故在<code>trap</code>开头加锁，等待其它处理器退出内核态。处理器要进入用户态时放开锁，也就是在<code>env_run</code>的最后，允许其它处理器进入内核态。</p>
<p>其它加锁方式可能更有效率，但比Spin Lock复杂很多。不论如何，这些lock/unlock操作都是为了保证内核只运行在一个处理器上。</p>
<p>在<code>kern/init.c</code>的<code>i386_init</code>中加锁：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lab 4 multitasking initialization functions</span></span><br><span class="line">pic_init();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Acquire the big kernel lock before waking up APs</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">lock_kernel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Starting non-boot CPUs</span></span><br><span class="line">boot_aps();</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/init.c</code>的<code>mp_main</code>中加锁：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></span><br><span class="line"><span class="comment">// to start running processes on this CPU.  But make sure that</span></span><br><span class="line"><span class="comment">// only one CPU can enter the scheduler at a time!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">lock_kernel();</span><br><span class="line"></span><br><span class="line">sched_yield();</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/trap.c</code>的<code>trap</code>中加锁：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// Trapped from user mode.</span></span><br><span class="line">    <span class="comment">// Acquire the big kernel lock before doing any</span></span><br><span class="line">    <span class="comment">// serious kernel work.</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    lock_kernel();</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/env.c</code>的<code>env_run</code>中解锁：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unlock_kernel();</span><br><span class="line">env_pop_tf(&amp;e-&gt;env_tf);</span><br></pre></td></tr></table></figure></p>
<p>关键要理解两点：</p>
<h4 id="大内核锁的实现"><a href="#大内核锁的实现" class="headerlink" title="大内核锁的实现"></a>大内核锁的实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">spin_lock</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG_SPINLOCK</span></span><br><span class="line">    <span class="keyword">if</span> (holding(lk))</span><br><span class="line">        panic(<span class="string">&quot;CPU %d cannot acquire %s: already holding&quot;</span>, cpunum(), lk-&gt;name);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The xchg is atomic.</span></span><br><span class="line">    <span class="comment">// It also serializes, so that reads after acquire are not</span></span><br><span class="line">    <span class="comment">// reordered before it. </span></span><br><span class="line">    <span class="comment">// 关键代码，体现了循环等待的思想</span></span><br><span class="line">    <span class="keyword">while</span> (xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;pause&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record info about lock acquisition for debugging.</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG_SPINLOCK</span></span><br><span class="line">    lk-&gt;cpu = thiscpu;</span><br><span class="line">    get_caller_pcs(lk-&gt;pcs);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，在<code>inc/x86.h</code>中可以找到<code>xchg()</code>函数的实现，使用它而不是用简单的<code>if + 赋值</code>是因为它是一个原子性的操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">xchg</span><span class="params">(<span class="keyword">volatile</span> <span class="type">uint32_t</span> *addr, <span class="type">uint32_t</span> newval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The + in &quot;+m&quot; denotes a read-modify-write operand.</span></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lock; xchgl %0, %1&quot;</span></span></span><br><span class="line"><span class="params">             : <span class="string">&quot;+m&quot;</span> (*addr), <span class="string">&quot;=a&quot;</span> (result)  <span class="comment">// 输出</span></span></span><br><span class="line"><span class="params">             : <span class="string">&quot;1&quot;</span> (newval)             <span class="comment">//  输入</span></span></span><br><span class="line"><span class="params">             : <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>lock</code>确保了操作的原子性，其意义是将<code>addr</code>存储的值与<code>newval</code>交换，并返回<code>addr</code>中原本的值。于是，如果最初<code>locked = 0</code>，即未加锁，就能跳出这个<code>while</code>循环。否则就会利用<code>pause</code>命令自旋等待。这就确保了当一个 CPU 获得了 BKL，其他 CPU 如果也要获得就只能自旋等待。</p>
<h4 id="为什么要在这几处加大内核锁"><a href="#为什么要在这几处加大内核锁" class="headerlink" title="为什么要在这几处加大内核锁"></a>为什么要在这几处加大内核锁</h4><p>从根本上来讲，其设计的初衷就是保证独立性。由于分页机制的存在，内核以及每个用户进程都有自己的独立空间。而多进程并发的时候，如果两个进程同时陷入内核态，就无法保证独立性了。例如内核中有某个全局变量<code>A</code>，cpu1 让 A=1， 而后 cpu2 却让 A=2，显然会互相影响。最初 Linux 设计者为了使系统尽快支持 SMP，直接在内核入口放了一把大锁，保证其独立性。</p>
<p>其流程大致为：BPS 启动 AP 前，获取内核锁，所以 AP 会在<code>mp_main</code>执行调度之前阻塞，在启动完 AP 后，BPS 执行调度，运行第一个进程，<code>env_run()</code>函数中会释放内核锁，这样一来，其中一个 AP 就可以开始执行调度，运行其他进程。</p>
<p>Q：看起来大内核锁机制保证了同时只能有一个CPU在内核态运行。那为什么我们还需要将每个CPU的内核栈分开？请描述一个场景，我们不分开内核栈而导致错误。</p>
<blockquote>
<p>假设CPU0因中断陷入内核并在内核栈中保留了相关的信息，此时若CPU1也发生中断而陷入内核，在同一个内核栈的情况下，CPU0中的信息将会被覆盖从而导致出现错误。</p>
</blockquote>
<h4 id="为什么要用不同栈"><a href="#为什么要用不同栈" class="headerlink" title="为什么要用不同栈"></a>为什么要用不同栈</h4><p>本标题对应Question 2。如果一次只有一个处理器运行内核，为什么每个处理器都要一个单独的栈？</p>
<p>这是个挺简单的问题。因为并不是真的只有一个处理器运行内核，处理器进入内核态之后才调用lock_kernel，进而抢锁。在中断发生进入trap函数时，这个处理器就已经在使用内核的代码了，只是可能没有运行真正的内核，而是在跑一个while循环，这也还是内核。</p>
<p>要处理这样同时跑内核的情况，自然要多个栈。可以设想，如果只有一个栈，一个处理器正在运行内核，一个处理器发生中断。被中断的处理器压栈，然后等待另一个处理器退出内核。在另一个处理器看来，栈没有变化，接着正常操作，把刚刚压栈的数据覆盖了。</p>
<h3 id="轮询调度"><a href="#轮询调度" class="headerlink" title="轮询调度"></a>轮询调度</h3><p>下一个任务是让 JOS 内核能够以轮询方式在多个任务之间切换。其原理如下：</p>
<ul>
<li><code>kern/sched.c</code>中的<code>sched_yield()</code>函数用来选择一个新的进程运行。它将从上一个运行的进程开始，按顺序循环搜索<code>envs[]</code>数组，选取第一个状态为<code>ENV_RUNNABLE</code>的进程执行。</li>
<li><code>sched_yield()</code>不能同时在两个CPU上运行同一个进程。如果一个进程已经在某个CPU上运行，其状态会变为<code>ENV_RUNNING</code>。</li>
<li>程序中已经实现了一个新的系统调用<code>sys_yield()</code>，进程可以用它来唤起内核的<code>sched_yield()</code>函数，从而将 CPU 资源移交给一个其他的进程。</li>
</ul>
<p>如何找到目前正在运行的进程在<code>envs[]</code>中的序号？在<code>kern/env.h</code>中，可以找到指向<code>struct Env</code>的指针<code>curenv</code>，表示当前正在运行的进程。但是需要注意，不能直接由<code>curenv-&gt;env_id</code>得到其序号。在<code>inc/env.h</code>中有一个宏可以完成这个转换。</p>
<p><code>sched_yield()</code>将找到下一个<code>runable</code>的进程并切换到这个进程上。主要步骤如下:</p>
<ul>
<li>从当前在<code>running</code>的进程 ( 也就是<code>curenv</code>) 开始 ( 如果<code>curenv</code>不存在，则从数组首部开始查找 )，顺序查找在<code>envs</code>数组 ( in circular fashion，也就是要取模做个环状查找 )，取出首个<code>status</code>为<code>ENV_RUNNABLE</code>的进程，并调用<code>env_run()</code>唤醒取出的进程。</li>
<li>如果上述查询中没有找到任何一个<code>ENV_RUNNABLE</code>的进程，则将观测<code>curenv-&gt;env_status</code>若其为<code>ENV_RUNNING</code>则继续运行这个进程。</li>
<li>若以上两种情况都没发生. 则自然的停止调度.</li>
</ul>
<p>这个函数必须阻止同一个进程在两个不同 CPU 上运行的情况 ( 由于正在运行 env 的状态必定是<code>ENV_RUNNING</code>，在前述中不会发生这种事情 )</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The environment index ENVX(eid) equals the environment&#x27;s offset in the &#x27;envs[]&#x27; array.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENVX(envid)     ((envid) &amp; (NENV - 1))</span></span><br></pre></td></tr></table></figure>
<p>查看<code>kern/env.c</code>可以发现<code>curenv</code>可能为NULL。因此要注意特例。</p>
<p>在<code>kern/sched.c</code>中实现轮询调度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched_yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line">    </span><br><span class="line">    idle = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (curenv) &#123;</span><br><span class="line">        <span class="type">size_t</span> eidx = ENVX(curenv-&gt;env_id);</span><br><span class="line">        <span class="type">uint32_t</span> mask = NENV - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = (eidx + <span class="number">1</span>) &amp; mask; i != eidx; i = (i + <span class="number">1</span>) &amp; mask) &#123;</span><br><span class="line">            <span class="keyword">if</span> (envs[i].env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">                idle = &amp;envs[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!idle &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">            idle = curenv;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; NENV; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (envs[i].env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">                idle = &amp;envs[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idle)</span><br><span class="line">        env_run(idle);</span><br><span class="line">    <span class="comment">// sched_halt never returns</span></span><br><span class="line">    sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/syscall.c</code>中添加新的系统调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// syscall()</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> SYS_yield:</span><br><span class="line">        sys_yield();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>将<code>kern/init.c</code>中运行的用户进程改为以下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i386_init()</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(TEST)</span></span><br><span class="line">    <span class="comment">// Don&#x27;t touch -- used by grading script!</span></span><br><span class="line">    ENV_CREATE(TEST, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// Touch all you want.</span></span><br><span class="line">    ENV_CREATE(user_primes, ENV_TYPE_USER);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// TEST*</span></span></span><br><span class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">    ENV_CREATE(user_yield, ENV_TYPE_USER);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>运行<code>make qemu CPUS=2</code>可以看到三个进程通过调用<code>sys_yield</code>切换了5次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Hello, I am environment 00001000.</span><br><span class="line">Hello, I am environment 00001001.</span><br><span class="line">Back in environment 00001000, iteration 0.</span><br><span class="line">Hello, I am environment 00001002.</span><br><span class="line">Back in environment 00001001, iteration 0.</span><br><span class="line">Back in environment 00001000, iteration 1.</span><br><span class="line">Back in environment 00001002, iteration 0.</span><br><span class="line">Back in environment 00001001, iteration 1.</span><br><span class="line">Back in environment 00001000, iteration 2.</span><br><span class="line">Back in environment 00001002, iteration 1.</span><br><span class="line">Back in environment 00001001, iteration 2.</span><br><span class="line">Back in environment 00001000, iteration 3.</span><br><span class="line">Back in environment 00001002, iteration 2.</span><br><span class="line">Back in environment 00001001, iteration 3.</span><br><span class="line">Back in environment 00001000, iteration 4.</span><br><span class="line">Back in environment 00001002, iteration 3.</span><br><span class="line">All done in environment 00001000.</span><br><span class="line">[00001000] exiting gracefully</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Back in environment 00001001, iteration 4.</span><br><span class="line">Back in environment 00001002, iteration 4.</span><br><span class="line">All done in environment 00001001.</span><br><span class="line">All done in environment 00001002.</span><br><span class="line">[00001001] exiting gracefully</span><br><span class="line">[00001001] free env 00001001</span><br><span class="line">[00001002] exiting gracefully</span><br><span class="line">[00001002] free env 00001002</span><br><span class="line">No runnable environments in the system!</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br><span class="line">K&gt; </span><br></pre></td></tr></table></figure>
<p>Q：我们在<code>env_run()</code>的实现中调用了<code>lcr3()</code>。在这个函数的调用之前以及调用之后，你的代码对<code>env_run()</code>的参数<code>e</code>进行了引用。在加载<code>%cr3</code>寄存器之后，MMU的寻址上下文就改变了（页目录切换了）。为什么我们在页目录改变前后都可以对<code>e</code>进行解引用？</p>
<blockquote>
<p>A：在我们lab3实现的过程中，任务的<code>env_pgdir</code>是基于<code>kern_pgdir</code>产生的，也就是说对于<code>UTOP</code>上的地址映射关系在两个页表中是一样的。而<code>e</code>所对应的<code>Env</code>结构由操作系统管理，在虚拟空间地址都是<code>UENVS-UPAGES</code>的范围，因此在所有用户环境的映射也是一样的。</p>
</blockquote>
<p>Q：当内核进行用户环境切换的时候，必须要保证旧的环境的寄存器值被保存起来以便之后恢复。这个过程是在哪里发生的？</p>
<blockquote>
<p>A：用户环境进行环境切换是通过系统调用<code>syscall()</code>，最终通过<code>kern/trap.c</code>中的<code>trap()</code>产生异常然后陷入内核。因而中断触发会进入<code>trapentry.S</code>的代码入口然后调用<code>trap()</code>，系统会在栈上创建一个<code>Trapframe</code>然后赋给用户环境的<code>env_tf</code>从而保护用户环境寄存器。如下所示代码片段：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_alltraps:</span><br><span class="line">	;ds es</span><br><span class="line">	push %ds</span><br><span class="line">	push %es</span><br><span class="line">	pushal   #;其余寄存器</span><br><span class="line"></span><br><span class="line">	#;load DS and ES with GD_KD (不能用立即数设置段寄存器)</span><br><span class="line">	mov $GD_KD, %ax</span><br><span class="line">	mov %ax, %ds</span><br><span class="line">	mov %ax, %es</span><br><span class="line">	pushl %esp</span><br><span class="line">	call trap</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>这里我们将环境的现场全部保护起来压栈使得其结构与<code>Trapframe</code>一样，然后调用<code>trap()</code>就可以使得其作为<code>tf</code>被保存。</p>
<p>恢复：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_pop_tf</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Record the CPU we are running on for user-space debugging</span></span><br><span class="line">    curenv-&gt;env_cpunum = cpunum();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;\tmovl %0,%%esp\n&quot;</span>  <span class="comment">// 恢复栈顶指针</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;\tpopal\n&quot;</span>          <span class="comment">// 恢复其他寄存器</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;\tpopl %%es\n&quot;</span>      <span class="comment">// 恢复段寄存器</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;\tpopl %%ds\n&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;\taddl $0x8,%%esp\n&quot;</span> <span class="comment">/* skip tf_trapno and tf_errcode */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;\tiret\n&quot;</span></span></span><br><span class="line"><span class="params">        : : <span class="string">&quot;g&quot;</span> (tf) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">    panic(<span class="string">&quot;iret failed&quot;</span>);  <span class="comment">/* mostly to placate the compiler */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="系统调用：创建进程"><a href="#系统调用：创建进程" class="headerlink" title="系统调用：创建进程"></a>系统调用：创建进程</h3><p>现在我们的内核已经可以运行多个进程，并在其中切换了。不过，现在它仍然只能运行内核最初设定好的程序<code>kern/init.c</code>。现在我们即将实现一个新的系统调用，它允许进程创建并开始新的进程。</p>
<p>Unix 提供了<code>fork()</code>这个原始的系统调用来创建进程。<code>fork()</code>将会拷贝父进程的整个地址空间来创建子进程。在用户空间里，父子进程之间的唯一区别就是它们的进程ID分别为<code>pid</code>和<code>ppid</code>。<code>fork()</code>在父进程中返回其子进程的进程 ID，而在子进程中返回 0。父子进程之间是完全独立的，任意一方修改内存，另一方都不会受到影响。</p>
<p>默认情况下，每一个进程都有其私有的地址空间，而且任意一个进程对于内核的修改都是对于其他进程而言不可见的。</p>
<p>我们将为 JOS 实现一个更原始的系统调用来创建新的进程。涉及到的系统调用如下：</p>
<ul>
<li><code>sys_exofork</code>：这个系统调用将会创建一个空白进程：在其用户空间中没有映射任何物理内存，并且它是不可运行的。刚开始时，它拥有和父进程相同的寄存器状态。<code>sys_exofork</code>将会在父进程返回其子进程的<code>envid_t</code>，子进程返回 0（当然，由于子进程还无法运行，也无法返回值，直到运行）。由于子环境最初被标记为不可执行，故在子环境中<code>sys_exofork()</code>直到父环境显式标记子环境为可执行，其才会在子环境中返回。</li>
<li><code>sys_env_set_status</code>：设置指定进程的状态为<code>ENV_RUNNABLE</code>或者<code>RUN_NOT_RUNNABLE</code>。这个系统调用通常用于在新进程的地址空间和寄存器初始化完成后，将其标记为可运行。</li>
<li><code>sys_page_alloc</code>：分配一个物理页并将其映射到指定进程的指定虚拟地址上。</li>
<li><code>sys_page_map</code>：从一个进程中拷贝一个页面映射（而非物理页的内容）到另一个。即共享内存。</li>
<li><code>sys_page_unmap</code>：删除到指定进程的指定虚拟地址的映射。</li>
</ul>
<p>上述所有系统调用集都需要接受一个环境ID，jos的内核支持了环境号0代表当前环境。在<code>kern/env.c</code>中的<code>envid2env()</code>实现了这种映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">envid2env</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">struct</span> Env **env_store, <span class="type">bool</span> checkperm)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果envid为零，则返回当前环境.</span></span><br><span class="line">        <span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">                *env_store = curenv;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过envid的索引部分查找Env结构，然后检查该结构Env中的env_id字段以确保envid不是陈旧的</span></span><br><span class="line">        e = &amp;envs[ENVX(envid)];</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;</span><br><span class="line">                *env_store = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查调用环境是否具有操作指定环境的合法权限。</span></span><br><span class="line">        <span class="comment">// 如果设置了 checkperm，则指定的环境必须是当前环境或当前环境的直接子环境。</span></span><br><span class="line">        <span class="keyword">if</span> (checkperm &amp;&amp; e != curenv &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id) &#123;</span><br><span class="line">                *env_store = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *env_store = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现上述在<code>kern/syscall.c</code>中的系统调用集，确保<code>syscall()</code>可以调用它们。你可能需要用到<code>kern/pmap.c</code>和<code>kern/env.c</code>中的一些函数，尤其是<code>envid2env()</code>。</p>
<p>现在你使用<code>envid2env()</code>的时候，将<code>checkperm</code>参数设置为1，确保当你的一些系统调用参数无效的时候会返回<code>-E_INVAL</code>。使用<code>user/dumpfork.c</code>测试你实现的这些系统调用。</p>
<p><code>sys_exofork()</code>的关键点在于如何让子环境对该系统调用返回0。这个用户态的触发系统调用的函数定义实际上在<code>inc/lib.h</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This must be inlined. </span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">envid_t</span> __attribute__((always_inline))</span><br><span class="line">sys_exofork(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">envid_t</span> ret;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;int %2&quot;</span></span></span><br><span class="line"><span class="params">		     : <span class="string">&quot;=a&quot;</span> (ret)</span></span><br><span class="line"><span class="params">		     : <span class="string">&quot;a&quot;</span> (SYS_exofork), <span class="string">&quot;i&quot;</span> (T_SYSCALL))</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整个过程的控制流如下：父环境显式调用该系统调用，通过内联汇编<code>int %2</code>触发中断，然后硬件控制流通过<code>trapentry.S</code>中的入口地址进行保护现场并将控制流转到<code>trap.c</code>最终进入<code>trap_dispatch()</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">trap_dispatch</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_trapno == T_SYSCALL)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int32_t</span> retval = syscall(tf-&gt;tf_regs.reg_eax,</span><br><span class="line">								 tf-&gt;tf_regs.reg_edx,</span><br><span class="line">								 tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">								 tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">								 tf-&gt;tf_regs.reg_edi,</span><br><span class="line">								 tf-&gt;tf_regs.reg_esi);</span><br><span class="line">		<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">			panic(<span class="string">&quot;[trap_dispatch] syscall : %e\n&quot;</span>, retval);</span><br><span class="line">		tf-&gt;tf_regs.reg_eax = retval;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见这里系统调用获取返回值的方式是：<code>env_tf</code>中的<code>reg_eax</code>寄存器设置为将系统调用的返回值。然后回到<code>trap</code>中直接通过调用<code>env_run()</code>来返回用户态：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatch based on what type of trap occurred</span></span><br><span class="line">	trap_dispatch(tf);         <span class="comment">// &lt;-  这里是上面的返回，返回值存在了其tf的reg_eax中</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we made it to this point, then no other environment was</span></span><br><span class="line">	<span class="comment">// scheduled, so we should return to the current environment</span></span><br><span class="line">	<span class="comment">// if doing so makes sense.</span></span><br><span class="line">	<span class="keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">		env_run(curenv);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sched_yield();</span><br></pre></td></tr></table></figure></p>
<p>而在我们的<code>sys_exofork()</code>执行过程中，只有父环境发生了系统调用，在陷入内核之前保护了用户环境的下一条指令<code>eip</code>，子环境是没有产生中断以及系统调用的，子环境会从其地址空间的<code>eip</code>指定的代码处继续执行（别忘了子环境的寄存器实际上就是拷贝父环境的）。因此整个<code>kern/trap.c</code>以及<code>kern/syscall.c</code>并没有影响子环境，子环境只会等待内核调用<code>sched_yield()</code>开始执行，因此返回值就是我们伪造的<code>eax=0</code>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">envid_t</span></span><br><span class="line"><span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;sys_exofork not implemented&quot;);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="type">int</span> r = env_alloc(&amp;e, curenv-&gt;env_id);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_tf = curenv-&gt;env_tf;</span><br><span class="line">    e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该函数中，子进程复制了父进程的<code>trapframe</code>，此后把<code>trapframe</code>中的<code>eax</code>的值设为了0。最后，返回了子进程的<code>id</code>。注意，根据<code>kern/trap.c</code>中的<code>trap_dispatch()</code>函数，这个返回值仅仅是存放在了父进程的<code>trapframe</code>中，还没有返回。而是在返回用户态的时候，即在<code>env_run()</code>中调用<code>env_pop_tf()</code>时，才把<code>trapframe</code>中的值赋值给各个寄存器。这时候<code>lib/syscall.c</code>中的函数<code>syscall()</code>才获得真正的返回值。因此，在这里对子进程<code>trapframe</code>的修改，可以使得子进程返回0。</p>
<p><code>sys_page_alloc()</code>函数在进程<code>envid</code>的目标地址<code>va</code>分配一个权限为<code>perm</code>的页面。</p>
<p>在做这个之前需要看一下<code>duppage()</code>函数，这是对这个系统调用的测试函数，里边列举了一些可能会出现的Corner case。<code>duppage()</code>函数利用<code>sys_page_alloc()</code>为子进程分配空闲物理页，再使用<code>sys_page_map()</code>将该新物理页映射到内核 (内核的<code>env_id = 0</code>) 的交换区<code>UTEMP</code>，方便在内核态进行<code>memmove</code>拷贝操作。在拷贝结束后，利用<code>sys_page_unmap()</code>将交换区的映射删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">duppage</span><span class="params">(<span class="type">envid_t</span> dstenv, <span class="type">void</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is NOT what you should do in your fork.</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(dstenv, addr, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_map(dstenv, addr, <span class="number">0</span>, UTEMP, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;sys_page_map: %e&quot;</span>, r);</span><br><span class="line">    memmove(UTEMP, addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, UTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;sys_page_unmap: %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在写之前也要看一下注释里的提示，注意检查权限位，这个看一下位操作就能搞定。分配了<code>page</code>之后要检查是否没有分配成功，检查能否获得正确的<code>env</code>，检查插入<code>page</code>是否成功，完成这些检查并根据返回值返回相应的错误码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a page of memory and map it at &#x27;va&#x27; with permission</span></span><br><span class="line"><span class="comment">// &#x27;perm&#x27; in the address space of &#x27;envid&#x27;.</span></span><br><span class="line"><span class="comment">// The page&#x27;s contents are set to 0.</span></span><br><span class="line"><span class="comment">// If a page is already mapped at &#x27;va&#x27;, that page is unmapped as a</span></span><br><span class="line"><span class="comment">// side effect.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,</span></span><br><span class="line"><span class="comment">//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//      -E_BAD_ENV if environment envid doesn&#x27;t currently exist,</span></span><br><span class="line"><span class="comment">//              or the caller doesn&#x27;t have permission to change envid.</span></span><br><span class="line"><span class="comment">//      -E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="comment">//      -E_INVAL if perm is inappropriate (see above).</span></span><br><span class="line"><span class="comment">//      -E_NO_MEM if there&#x27;s no memory to allocate the new page,</span></span><br><span class="line"><span class="comment">//              or to allocate any necessary page tables.</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_alloc</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Hint: This function is a wrapper around page_alloc() and</span></span><br><span class="line">        <span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">        <span class="comment">//   Most of the new code you write should be to check the</span></span><br><span class="line">        <span class="comment">//   parameters for correctness.</span></span><br><span class="line">        <span class="comment">//   If page_insert() fails, remember to free the page you</span></span><br><span class="line">        <span class="comment">//   allocated!</span></span><br><span class="line">        <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">        <span class="comment">// panic(&quot;sys_page_alloc not implemented&quot;);</span></span><br><span class="line">        <span class="keyword">if</span> ((~perm &amp; (PTE_U|PTE_P)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="keyword">if</span> ((perm &amp; (~(PTE_U|PTE_P|PTE_AVAIL|PTE_W))) != <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">uintptr_t</span>)va &gt;= UTOP || PGOFF(va) != <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span> =</span> page_alloc(ALLOC_ZERO);</span><br><span class="line">        <span class="keyword">if</span> (!page)</span><br><span class="line">            <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">        <span class="type">int</span> err = envid2env(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">        err = page_insert(e-&gt;env_pgdir, page, va, perm);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            page_free(page);</span><br><span class="line">            <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sys_page_map()</code>函数简单来说，就是建立跨进程的映射。注释中给出了一些需要做的检查，取得src中的页，使用<code>page_insert</code>把这页添加到<code>dst_env-&gt;env_pgdir</code>中即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map the page of memory at &#x27;srcva&#x27; in srcenvid&#x27;s address space</span></span><br><span class="line"><span class="comment">// at &#x27;dstva&#x27; in dstenvid&#x27;s address space with permission &#x27;perm&#x27;.</span></span><br><span class="line"><span class="comment">// Perm has the same restrictions as in sys_page_alloc, except</span></span><br><span class="line"><span class="comment">// that it also must not grant write access to a read-only</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//      -E_BAD_ENV if srcenvid and/or dstenvid doesn&#x27;t currently exist,</span></span><br><span class="line"><span class="comment">//              or the caller doesn&#x27;t have permission to change one of them.</span></span><br><span class="line"><span class="comment">//      -E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span></span><br><span class="line"><span class="comment">//              or dstva &gt;= UTOP or dstva is not page-aligned.</span></span><br><span class="line"><span class="comment">//      -E_INVAL is srcva is not mapped in srcenvid&#x27;s address space.</span></span><br><span class="line"><span class="comment">//      -E_INVAL if perm is inappropriate (see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//      -E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid&#x27;s</span></span><br><span class="line"><span class="comment">//              address space.</span></span><br><span class="line"><span class="comment">//      -E_NO_MEM if there&#x27;s no memory to allocate any necessary page tables.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_map</span><span class="params">(<span class="type">envid_t</span> srcenvid, <span class="type">void</span> *srcva,</span></span><br><span class="line"><span class="params">             <span class="type">envid_t</span> dstenvid, <span class="type">void</span> *dstva, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// Hint: This function is a wrapper around page_lookup() and</span></span><br><span class="line">        <span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">        <span class="comment">//   Again, most of the new code you write should be to check the</span></span><br><span class="line">        <span class="comment">//   parameters for correctness.</span></span><br><span class="line">        <span class="comment">//   Use the third argument to page_lookup() to</span></span><br><span class="line">        <span class="comment">//   check the current permissions on the page.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">        <span class="comment">//      -E_BAD_ENV if srcenvid and/or dstenvid doesn&#x27;t currently exist,</span></span><br><span class="line">        <span class="comment">//              or the caller doesn&#x27;t have permission to change one of them.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">uintptr_t</span>)srcva &gt;= UTOP || PGOFF(srcva) != <span class="number">0</span> || (<span class="type">uintptr_t</span>)dstva &gt;= UTOP || PGOFF(dstva) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="keyword">if</span> ((perm &amp; PTE_U) == <span class="number">0</span> || (perm &amp; PTE_P) == <span class="number">0</span> || (perm &amp; ~PTE_SYSCALL) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">src_env</span>, *<span class="title">dst_env</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (envid2env(srcenvid, &amp;src_env, <span class="number">1</span>) &lt; <span class="number">0</span> || envid2env(dstenvid, &amp;dst_env, <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">        <span class="type">pte_t</span> *src_pte;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">page</span> =</span> page_lookup(src_env-&gt;env_pgdir, srcva, &amp;src_pte);</span><br><span class="line">        <span class="keyword">if</span> ( (*src_pte &amp; PTE_W == <span class="number">0</span>) &amp;&amp; (perm &amp; PTE_W == <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        <span class="keyword">if</span> (page_insert(dst_env-&gt;env_pgdir, page, dstva, perm) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sys_page_unmap()</code>函数取消映射。是对<code>page_remove</code>的封装。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_unmap</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *va)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">uintptr_t</span>)va &gt;= UTOP || PGOFF(va) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;e, <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    page_remove(e-&gt;env_pgdir, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sys_env_set_status()</code>函数设置<code>env</code>的状态，在子进程内存<code>map</code>结束后再使用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_status</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;sys_env_set_status not implemented&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) </span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;e, <span class="number">1</span>) &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    e-&gt;env_status = status;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Part-B-写时拷贝的-Fork"><a href="#Part-B-写时拷贝的-Fork" class="headerlink" title="Part B: 写时拷贝的 Fork"></a>Part B: 写时拷贝的 Fork</h2><p>在 Part A 中，我们通过把父进程的所有内存数据拷贝到子进程实现了<code>fork()</code>，这也是 Unix 系统早期的实现。这个拷贝到过程是<code>fork()</code>时最昂贵的操作。</p>
<p>然而，调用了<code>fork()</code>之后往往立即就会在子进程中调用<code>exec()</code>，将子进程的内存更换为新的程序。这样，复制父进程的内存这个操作就完全浪费了。</p>
<p>因此，后来的 Unix 系统让父、子进程共享同一片物理内存，直到某个进程修改了内存。这被称作 copy-on-write。为了实现它，<code>fork()</code>时内核只拷贝页面的映射关系，而不拷贝其内容，同时将共享的页面标记为只读 (read-only)。当父子进程中任一方向内存中写入数据时，就会触发 page fault。此时，Unix 就知道应该分配一个私有的可写内存给这个进程。</p>
<p>也就是说，这样只有在实际进行修改页面的时候，这个页面的内容才会真正被复制。那么这种机制使得<code>exec()</code>降低了开销：实际上子进程可能只需要在调用<code>exec()</code>之前复制当前栈上的一页。</p>
<p>下面，我们就需要实现一个Unix-like的具有写时复制的<code>fork()</code>，作为用户空间库函数例程。（之所以作为用户库函数而不是内核函数，是为了让内核保持简单，同时能让用户定制自身<code>fork()</code>的实现）</p>
<h3 id="用户级别的页错误处理"><a href="#用户级别的页错误处理" class="headerlink" title="用户级别的页错误处理"></a>用户级别的页错误处理</h3><p>内核必须要记录进程不同区域出现页面错误时的处理方法。例如，一个栈区域的<code>page fault</code>会分配并映射一个新的页。一个<code>BSS</code>区域（用于存放程序中未初始化的全局变量、静态变量）的页错误会分配一个新的页面，初始化为0，再映射。<br>用户级别的页错误处理流程为：</p>
<ul>
<li>页错误异常，陷入内核</li>
<li>内核修改<code>%esp</code>切换到进程的异常栈，修改<code>%eip</code>让进程运行<code>_pgfault_upcall</code></li>
<li><code>_pgfault_upcall</code>将运行 page fault handler，此后不通过内核切换回正常栈</li>
</ul>
<p>用户级的写时复制<code>fork()</code>的第一个关键点，在于能够使得用户发现由写权限问题引发的page fault的能力。</p>
<p>通常来说，是设置一个地址空间用以让page fault来指示发生错误时应该采取哪种行为。比如说，大多数的Unix内核通常会为新的进程的栈区域分配一个页的大小，随着进程栈逐渐增长一直到了未映射分配的区域，就会引发page fault，然后内核再按需分配。这时典型的Unix内核需要追踪进程空间不同区域在发生page fault时应该采取何种措施</p>
<ul>
<li>栈区发生page fault，则表示需要新的页面的分配和映射；</li>
<li>BSS区的page faule，则表示应该分配一个新页面并且填充0再映射；</li>
<li>对于具有可执行文件的系统，text段的page fault则表示从磁盘上的二进制文件中读取页面并映射。</li>
</ul>
<p>和传统的内存追踪大量信息的方法不同，这个实验中我们需要让用户自己决定如何处理用户空间的每个页面错误（这些bug的损害通常不大）。这种设计方式为用户定义储存区域带来了较强的灵活性，我们之后将会使用用户级别的错误处理程序来进行映射以及访问磁盘系统的文件。</p>
<p>为了能够处理页错误，用户环境必须向jos的内核注册一个页错误处理程序入口（page fault handler entrypoint）。用户环境通过系统调用<code>sys_env_set_pgfault_upcall()</code>来注册错误处理程序入口。实验中已经对于<code>Env</code>结构增加了新的成员<code>env_pgfault_upcall</code>来记录该信息。</p>
<p>实现<code>sys_env_set_pgfault_upcall()</code>系统调用，相当简单。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the page fault upcall for &#x27;envid&#x27; by modifying the corresponding struct</span></span><br><span class="line"><span class="comment">// Env&#x27;s &#x27;env_pgfault_upcall&#x27; field.  When &#x27;envid&#x27; causes a page fault, the</span></span><br><span class="line"><span class="comment">// kernel will push a fault record onto the exception stack, then branch to</span></span><br><span class="line"><span class="comment">// &#x27;func&#x27;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn&#x27;t currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn&#x27;t have permission to change envid.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_pgfault_upcall</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *func)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid, &amp;env, <span class="number">1</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	env-&gt;env_pgfault_upcall = func;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="进程的正常栈和异常栈"><a href="#进程的正常栈和异常栈" class="headerlink" title="进程的正常栈和异常栈"></a>进程的正常栈和异常栈</h4><p>正常运行时，JOS 的进程会运行在正常栈上，<code>ESP</code>从<code>USTACKTOP</code>开始往下生长，栈上的数据存放在<code>[USTACKTOP-PGSIZE, USTACKTOP-1]</code>上。当出现页错误时，内核会把进程在一个新的栈（异常栈）上面重启，运行指定的用户级别页错误处理函数。也就是说完成了一次进程内的栈切换。这个过程与<code>trap</code>的过程很相似。</p>
<p>JOS 的异常栈也只有一个物理页大小，并且它的栈顶定义在虚拟内存<code>UXSTACKTOP</code>处。当用户环境在异常处理栈上运行时，用户级别页错误处理程序可以使用jos系统调用来映射新的页面以解决page fault，最终通过一些汇编代码回到正常栈。</p>
<p>每个需要支持用户级页错误处理的函数都需要分配自己的异常栈。可以使用<code>sys_page_alloc()</code>这个系统调用来实现。</p>
<h4 id="用户页错误处理函数"><a href="#用户页错误处理函数" class="headerlink" title="用户页错误处理函数"></a>用户页错误处理函数</h4><p>现在我们需要修改<code>kern/trap.c</code>中的缺页异常处理函数，使其能够按照特定的方式处理用户模式页错误。我们将用户环境发生错误时的状态称为异常状态（trap-time state）。</p>
<p>如果没有注册<code>page fault handler</code>，JOS内核就直接销毁进程。否则，内核就会初始化一个<code>trap frame</code>记录寄存器状态，在异常栈上处理页错误，恢复进程的执行，<code>fault_va</code>是导致页错误发生的虚拟地址。<code>UTrapframe</code>在异常栈栈上如下所示。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                    &lt;-- UXSTACKTOP</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time eflags</span><br><span class="line">trap-time eip</span><br><span class="line">trap-time eax       start of struct PushRegs</span><br><span class="line">trap-time ecx</span><br><span class="line">trap-time edx</span><br><span class="line">trap-time ebx</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time ebp</span><br><span class="line">trap-time esi</span><br><span class="line">trap-time edi       end of struct PushRegs</span><br><span class="line">tf_err (error code)</span><br><span class="line">fault_va            &lt;-- %esp when handler is run</span><br></pre></td></tr></table></figure></p>
<p>相比<code>trap</code>时使用的<code>Trapframe</code>，多了记录错误位置的<code>fault_va</code>，少了段选择器<code>%cs</code>，<code>%ds</code>，<code>%ss</code>。这反映了两者最大的不同：是否发生了进程的切换。</p>
<p>如果异常发生时，进程已经在异常栈上运行了，这就说明 page fault handler 本身出现了问题。这时，我们就应该在<code>tf-&gt;tf_esp</code>处分配新的栈，而不是在<code>UXSTACKTOP</code>。首先需要 push 一个空的 32bit word (4 bytes，所以要减4)作为占位符，然后是一个<code>UTrapframe</code>结构体。</p>
<p>实现<code>kern/trap.c</code>中的<code>page_fault_handler()</code>。注意上述提及的异常处理栈的机制。</p>
<p>为检查<code>tf-&gt;tf_esp</code>是否已经在异常栈上了，只要检查它是否在区间<code>[UXSTACKTOP-PGSIZE, UXSTACKTOP-1]</code>上即可。</p>
<p>再次分析控制流，当用户环境陷入中断时将<code>tf</code>保护起来，这里传递的参数<code>tf</code>实际上就是用户环境的现场。我们在这个系统调用之后需要将控制权还给用户环境，但是需要让用户环境进入页异常处理函数（如果有）并且将栈切换为异常处理栈。也就是说我们需要改变<code>curenv</code>的<code>ip</code>以及<code>esp</code>。同时我们只需要将<code>tf</code>中保护的现场原样传递给<code>utf</code>即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_fault_handler</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read processor&#x27;s CR2 register to find the faulting address</span></span><br><span class="line">	fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">		panic(<span class="string">&quot;[page_fault_handler] Page fault in kernel.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line">	<span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call the environment&#x27;s page fault upcall, if one exists.  Set up a</span></span><br><span class="line">	<span class="comment">// page fault stack frame on the user exception stack (below</span></span><br><span class="line">	<span class="comment">// UXSTACKTOP), then branch to curenv-&gt;env_pgfault_upcall.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The page fault upcall might cause another page fault, in which case</span></span><br><span class="line">	<span class="comment">// we branch to the page fault upcall recursively, pushing another</span></span><br><span class="line">	<span class="comment">// page fault stack frame on top of the user exception stack.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// It is convenient for our code which returns from a page fault</span></span><br><span class="line">	<span class="comment">// (lib/pfentry.S) to have one word of scratch space at the top of the</span></span><br><span class="line">	<span class="comment">// trap-time stack; it allows us to more easily restore the eip/esp. In</span></span><br><span class="line">	<span class="comment">// the non-recursive case, we don&#x27;t have to worry about this because</span></span><br><span class="line">	<span class="comment">// the top of the regular user stack is free.  In the recursive case,</span></span><br><span class="line">	<span class="comment">// this means we have to leave an extra word between the current top of</span></span><br><span class="line">	<span class="comment">// the exception stack and the new stack frame because the exception</span></span><br><span class="line">	<span class="comment">// stack _is_ the trap-time stack.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If there&#x27;s no page fault upcall, the environment didn&#x27;t allocate a</span></span><br><span class="line">	<span class="comment">// page for its exception stack or can&#x27;t write to it, or the exception</span></span><br><span class="line">	<span class="comment">// stack overflows, then destroy the environment that caused the fault.</span></span><br><span class="line">	<span class="comment">// Note that the grade script assumes you will first check for the page</span></span><br><span class="line">	<span class="comment">// fault upcall and print the &quot;user fault va&quot; message below if there is</span></span><br><span class="line">	<span class="comment">// none.  The remaining three checks can be combined into a single test.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hints:</span></span><br><span class="line">	<span class="comment">//   user_mem_assert() and env_run() are useful here.</span></span><br><span class="line">	<span class="comment">//   To change what the user environment runs, modify &#x27;curenv-&gt;env_tf&#x27;</span></span><br><span class="line">	<span class="comment">//   (the &#x27;tf&#x27; variable points at &#x27;curenv-&gt;env_tf&#x27;).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> * <span class="title">utf</span>;</span></span><br><span class="line">	<span class="type">uintptr_t</span> utf_top;</span><br><span class="line">	<span class="comment">//curenv has pg fault handler</span></span><br><span class="line">	<span class="keyword">if</span>(curenv -&gt; env_pgfault_upcall)&#123;</span><br><span class="line">		<span class="comment">//esp already in handler (recursive)</span></span><br><span class="line">		<span class="keyword">if</span> ((tf-&gt;tf_esp &gt;= UXSTACKTOP - PGSIZE) &amp;&amp; (tf-&gt;tf_esp &lt; UXSTACKTOP))&#123;</span><br><span class="line">			<span class="comment">// recursive exception stack</span></span><br><span class="line">			utf_top = tf-&gt;tf_esp - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe) - <span class="number">4</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			utf_top = UXSTACKTOP - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//check permission on exception stack</span></span><br><span class="line">		user_mem_assert(curenv, utf_top, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe), PTE_W | PTE_U);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//push UTrapframe</span></span><br><span class="line">		utf = (<span class="keyword">struct</span> UTrapframe *)utf_top;</span><br><span class="line">		utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">		utf-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">		utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">		utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">		utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">		utf-&gt;utf_esp = tf-&gt;tf_esp;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//modify stack and ip</span></span><br><span class="line">		(&amp;(curenv-&gt;env_tf))-&gt;tf_eip = (<span class="type">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">		(&amp;(curenv-&gt;env_tf))-&gt;tf_esp = utf_top;</span><br><span class="line">		env_run(curenv);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">	cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">		curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用户模式页错误入口"><a href="#用户模式页错误入口" class="headerlink" title="用户模式页错误入口"></a>用户模式页错误入口</h3><p>在处理完页错误之后，现在我们需要编写汇编语句实现从异常栈到正常栈的切换，该例程将会调用C页面错误处理程序（<code>sys_env_set_pgfault_upcall()</code>）。</p>
<p>实现<code>lib/pfentry.S</code>中的<code>_pgfault_upcall</code>例程。这部分最有趣的在于如何返回用户触发page fault的代码。我们在这里将要直接返回而无需再陷入内核。难点在于如何同时切换栈以及重新加载<code>eip</code>。</p>
<ul>
<li><code>_pgfault_upcall()</code>：分析其汇编代码逻辑，我们知道它将<code>_pgfault_handler()</code>这个全局函数指针放入<code>eax</code>中并执行，这个全局函数<code>_pgfault_handler()</code>实际上就是我们的C处理页异常的例程（在<code>pgfault.c</code>中定义并且通过用户环境程序显式调用<code>set_pgfault_handler()</code>去定制该处理函数）。</li>
</ul>
<p>仔细阅读注释，这里有一些坑点：</p>
<p>首先我们要跳转回发生异常的<code>eip</code>时，已经恢复了所有现场（包括<code>esp</code>），这里不能使用<code>jmp</code>进行跳转（因为需要一个目的地址，我们不能用寄存器存了）。而且我们不能直接<code>ret</code>（因为<code>ret</code>会改变<code>esp</code>）。所以我们应该在切换栈之前将异常时的<code>eip</code>装载到异常处理栈的栈顶，切换栈的时候设置<code>esp = esp-4</code>，然后这样使用<code>ret</code>返回时就会取出<code>eip</code>并且返回同时使<code>esp=esp+4</code>。这样做是完全合理的，非嵌套情况下的异常处理栈栈顶之上（更低的地址）是空的，而嵌套情况两个异常处理栈之间会存在32bits的空白空间，因此完全没问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">    // 调用用户定义的页错误处理函数</span><br><span class="line">    // Call the C page fault handler.</span><br><span class="line">    pushl %esp          // function argument: pointer to UTF</span><br><span class="line">    movl _pgfault_handler, %eax</span><br><span class="line">    call *%eax</span><br><span class="line">    addl $4, %esp           // pop function argument</span><br><span class="line"></span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    movl 48(%esp), %ebp</span><br><span class="line">    subl $4, %ebp</span><br><span class="line">    movl %ebp, 48(%esp)</span><br><span class="line">    movl 40(%esp), %eax</span><br><span class="line">    movl %eax, (%ebp)</span><br><span class="line"></span><br><span class="line">    // Restore the trap-time registers.  After you do this, you</span><br><span class="line">    // can no longer modify any general-purpose registers.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    // 跳过 utf_err 以及 utf_fault_va</span><br><span class="line">    addl $8, %esp</span><br><span class="line">    // popal 同时 esp 会增加，执行结束后 %esp 指向 utf_eip</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    // Restore eflags from the stack.  After you do this, you can</span><br><span class="line">    // no longer use arithmetic operations or anything else that</span><br><span class="line">    // modifies eflags.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    // 跳过 utf_eip</span><br><span class="line">    addl $4, %esp</span><br><span class="line">    // 恢复 eflags</span><br><span class="line">    popfl</span><br><span class="line"></span><br><span class="line">    // Switch back to the adjusted trap-time stack.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    // 恢复 trap-time 的栈顶</span><br><span class="line">    popl %esp</span><br><span class="line">    // Return to re-execute the instruction that faulted.</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    // ret 指令相当于 popl %eip</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p>首先必须要理解异常栈的结构，下图所示的是嵌套异常时的情况。其中左边表示内容，右边表示地址。需要注意的是，上一次异常的栈顶之下间隔 4byte，就是一个新的异常。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                 utf_esp</span><br><span class="line">reserved 32 bit  </span><br><span class="line">utf_esp          48(%esp)</span><br><span class="line">utf_eflags       44(%esp)</span><br><span class="line">utf_eip          40(%esp)</span><br><span class="line">utf_regs(end)    36(%esp)</span><br><span class="line">...</span><br><span class="line">utf_regs(start)   8(%esp)</span><br><span class="line">utf_err           4(%esp)</span><br><span class="line">utf_fault_va       (%esp)</span><br></pre></td></tr></table></figure></p>
<p>最难理解的是这一部分：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl 48(%esp), %ebp  // 使 %ebp 指向 utf_esp</span><br><span class="line">subl $4, %ebp        // %ebp-4</span><br><span class="line">movl %ebp, 48(%esp)  // 更新 utf_esp 值为 utf_esp-4</span><br><span class="line">movl 40(%esp), %eax</span><br><span class="line">movl %eax, (%ebp)  // 将 utf_esp-4 地址的内容改为 utf_eip</span><br></pre></td></tr></table></figure></p>
<p>经过这一部分的修改，异常栈更新为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                 utf_esp</span><br><span class="line">utf_eip</span><br><span class="line">utf_esp-4        48(%esp)</span><br><span class="line">utf_eflags       44(%esp)</span><br><span class="line">utf_eip          40(%esp)</span><br><span class="line">utf_regs(end)    36(%esp)</span><br><span class="line">...</span><br><span class="line">utf_regs(start)   8(%esp)</span><br><span class="line">utf_err           4(%esp)</span><br><span class="line">utf_fault_va       (%esp)</span><br></pre></td></tr></table></figure></p>
<p>此后就是恢复各寄存器，最后的<code>ret</code>指令相当于<code>popl %eip</code>，指令寄存器的值修改为<code>utf_eip</code>，达到了返回的效果。</p>
<p>实现<code>set_pgfault_handler()</code>练习是用户用来指定缺页异常处理方式的函数。代码比较简单，但是需要区分清楚<code>handler</code>，<code>_pgfault_handler</code>，<code>_pgfault_upcall</code>三个变量。</p>
<p><code>handler</code>是传入的用户自定义页错误处理函数指针。</p>
<p><code>_pgfault_upcall</code>是一个全局变量，在<code>lib/pfentry.S</code>中完成的初始化。它是页错误处理的总入口，页错误除了运行 page fault handler，还需要切换回正常栈。</p>
<p><code>_pgfault_handler</code>被赋值为<code>handler</code>，会在<code>_pgfault_upcall</code>中被调用，是页错误处理的一部分。具体代码是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">    // Call the C page fault handler.</span><br><span class="line">    pushl %esp          // function argument: pointer to UTF</span><br><span class="line">    movl _pgfault_handler, %eax</span><br><span class="line">    call *%eax</span><br><span class="line">    addl $4, %esp</span><br></pre></td></tr></table></figure></p>
<p>若是第一次调用，需要首先在这个<code>env</code>分配一个页面作为异常栈，并且将该进程的<code>upcall</code>设置为 Exercise 10 中的程序。此后如果需要改变<code>handler</code>，不需要再重复这个工作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">set_pgfault_handler</span><span class="params">(<span class="type">void</span> (*handler)(<span class="keyword">struct</span> UTrapframe *utf))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// First time through!</span></span><br><span class="line">        <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">        <span class="type">envid_t</span> e_id = sys_getenvid();</span><br><span class="line">        r = sys_page_alloc(e_id, (<span class="type">void</span> *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_W | PTE_P);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;pgfault_handler: %e&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// r = sys_env_set_pgfault_upcall(e_id, handler);</span></span><br><span class="line">        r = sys_env_set_pgfault_upcall(e_id, _pgfault_upcall);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;pgfault_handler: %e&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">    _pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>user/faultalloc</code>的部分输出如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">envs: f0292000, e: f0292000, e-&gt;env_id: 1000</span><br><span class="line">env_id, 1000</span><br><span class="line">[00000000] new env 00001000</span><br><span class="line">envs[0].env_status: 2</span><br><span class="line">PAGE FAULT</span><br><span class="line">fault deadbeef</span><br><span class="line">this string was faulted in at deadbeef</span><br><span class="line">PAGE FAULT</span><br><span class="line">fault cafebffe</span><br><span class="line">PAGE FAULT</span><br><span class="line">fault cafec000</span><br><span class="line">this string was faulted in at cafebffe</span><br><span class="line">[00001000] exiting gracefully</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">envs[0].env_status: 0</span><br><span class="line">envs[1].env_status: 0</span><br><span class="line">envs[0].env_status: 0</span><br><span class="line">envs[1].env_status: 0</span><br><span class="line">No runnable environments in the system!</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br></pre></td></tr></table></figure></p>
<p><code>user/faultallocbad</code>的部分输出如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">envs: f0292000, e: f0292000, e-&gt;env_id: 1000</span><br><span class="line">env_id, 1000</span><br><span class="line">[00000000] new env 00001000</span><br><span class="line">envs[0].env_status: 2</span><br><span class="line">[00001000] user_mem_check assertion failure for va deadbeef</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">envs[0].env_status: 0</span><br><span class="line">envs[1].env_status: 0</span><br><span class="line">envs[0].env_status: 0</span><br><span class="line">envs[1].env_status: 0</span><br><span class="line">No runnable environments in the system!</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br></pre></td></tr></table></figure></p>
<p>可以发现两个程序的输出有所不同，但是两者的page fault handler相同，因为一个使用<code>cprintf()</code>输出，一个使用<code>sys_cput()</code>输出。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test user-level fault handler -- alloc pages to fix faults</span></span><br><span class="line"><span class="comment">// faultalloc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">handler</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">void</span> *addr = (<span class="type">void</span>*)utf-&gt;utf_fault_va;</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">&quot;fault %x\n&quot;</span>, addr);</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, ROUNDDOWN(addr, PGSIZE),</span><br><span class="line">				PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;allocating at %x in page fault handler: %e&quot;</span>, addr, r);</span><br><span class="line">	<span class="built_in">snprintf</span>((<span class="type">char</span>*) addr, <span class="number">100</span>, <span class="string">&quot;this string was faulted in at %x&quot;</span>, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">umain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	set_pgfault_handler(handler);</span><br><span class="line">	cprintf(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span>*)<span class="number">0xDeadBeef</span>);</span><br><span class="line">	cprintf(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span>*)<span class="number">0xCafeBffe</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// test user-level fault handler -- alloc pages to fix faults</span></span><br><span class="line"><span class="comment">// doesn&#x27;t work because we sys_cputs instead of cprintf (exercise: why?)</span></span><br><span class="line"><span class="comment">// faultallocbad.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">handler</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">void</span> *addr = (<span class="type">void</span>*)utf-&gt;utf_fault_va;</span><br><span class="line"></span><br><span class="line">	cprintf(<span class="string">&quot;fault %x\n&quot;</span>, addr);</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, ROUNDDOWN(addr, PGSIZE),</span><br><span class="line">				PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;allocating at %x in page fault handler: %e&quot;</span>, addr, r);</span><br><span class="line">	<span class="built_in">snprintf</span>((<span class="type">char</span>*) addr, <span class="number">100</span>, <span class="string">&quot;this string was faulted in at %x&quot;</span>, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">umain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	set_pgfault_handler(handler);</span><br><span class="line">	sys_cputs((<span class="type">char</span>*)<span class="number">0xDEADBEEF</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>sys_cput()</code>的时候会直接通过<code>lib/syscall.c</code>发起系统调用，其在<code>kern/syscall.c</code>中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sys_cputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line">    <span class="comment">// Destroy the environment if not.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    user_mem_assert(curenv, s, len, PTE_U);</span><br><span class="line">    <span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">    cprintf(<span class="string">&quot;%.*s&quot;</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>它检查了内存，因此在这里 panic 了。中途没有触发过页错误。</p>
<p>而<code>cprintf()</code>的实现可以在<code>lib/printf.c</code>中找到：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">vcprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">printbuf</span> <span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    b.idx = <span class="number">0</span>;</span><br><span class="line">    b.cnt = <span class="number">0</span>;</span><br><span class="line">    vprintfmt((<span class="type">void</span>*)putch, &amp;b, fmt, ap);</span><br><span class="line">    sys_cputs(b.buf, b.idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b.cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">cprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    cnt = vcprintf(fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它在调用<code>sys_cputs()</code>之前，首先在用户态执行了<code>vprintfmt()</code>将要输出的字符串存入结构体<code>b</code>中。在此过程中试图访问<code>0xdeadbeef</code>地址，触发并处理了页错误（其处理方式是在错误位置处分配一个字符串，内容是 “this string was faulted in at …”），因此在继续调用<code>sys_cputs()</code>时不会出现 panic。</p>
<h4 id="实现-Copy-on-Write-Fork"><a href="#实现-Copy-on-Write-Fork" class="headerlink" title="实现 Copy-on-Write Fork"></a>实现 Copy-on-Write Fork</h4><p>现在我们已经具备了在用户空间实现<code>copy-on-write fork()</code>的条件。</p>
<p>现在同样在<code>lib/fork.c</code>中给出了<code>fork()</code>的框架。如同<code>dumbfork()</code>一样，<code>fork()</code>也要创建一个新进程，并且在新进程中建立与父进程同样的内存映射。关键的不同点是，<code>dumbfork()</code>拷贝了物理页的内容，而<code>fork()</code>仅拷贝了映射关系，仅在某个进程需要改写某一页的内容时，才拷贝这一页的内容。其基本流程如下：</p>
<ul>
<li>父进程使用<code>set_pgfault_handler</code>将<code>pgfault()</code>设为<code>page fault handler</code></li>
<li>父进程使用<code>sys_exofork()</code>建立一个子进程</li>
<li>对每个在<code>UTOP</code>之下可写页面以及 COW 页面（用<code>PTE_COW</code>标识），父进程调用<code>duppage()</code>将其“映射”到子进程，同时将其权限改为只读，并用<code>PTE_COW</code>位来与一般只读页面区别。<ul>
<li>这个函数的作用是把一个页面以写时复制权限<code>PTE_COW</code>映射到子环境，然后再以写时复制权限映射到父进程（这个顺序很重要）。</li>
<li>以写时复制映射：先取消写权限（如果有），然后再加上写时复制权限用以区分普通只读页面。</li>
<li>异常栈的分配方式与此不同，需要在子进程中分配一个新页面。因为<code>page fault handler</code>会实实在在地向异常栈写入内容，并在异常栈上运行。如果异常栈页面都用<code>COW</code>机制，那就没有能够执行拷贝这个过程的载体了</li>
<li><code>fork()</code>同样需要处理<code>PTE_P</code>权限的页面（非可写或写时复制的）</li>
</ul>
</li>
<li>父进程会为子进程设置用户页错误处理入口。</li>
<li>子进程已经就绪，父进程将其设为<code>runnable</code></li>
</ul>
<p>进程第一次往一个 COW page 写入内容时，会发生 page fault，其流程为：</p>
<ul>
<li>内核将 page fault 传递至<code>_pgfault_upcall</code>，它会调用<code>pgfault() handler</code></li>
<li><code>pgfault()</code>检查错误号（error code）是否为<code>FEC_WR</code>（写操作），即是由于写操作触发了异常。然后检查触发异常的页面是否为写时复制的，如果不是则直接panic内核。</li>
<li><code>pgfault()</code>分配一个新的页面并将 fault page 的内容拷贝进去，然后将旧的映射覆盖，使其以可读可写权限映射到该新页面，并且取代原来的映射。</li>
</ul>
<p>用户级别的<code>lib/fork.c</code>代码需要查看环境的页表（查询某个页面是否为写时复制），这也是内核将环境的页表映射到<code>UVPT</code>位置的原因（因为用户环境不能访问内核，不具备访问<code>kern_pgdir</code>以及使用<code>pgdir_walk</code>的权限）。所以为了能够让用户环境访问到<code>PTE</code>和<code>PDE</code>，jos采取了这种clever mapping trick：UVPT</p>
<h4 id="UVPT"><a href="#UVPT" class="headerlink" title="UVPT"></a>UVPT</h4><p>页表的一个很好的概念模型是一个 2^20 条目的数组，它可以通过物理页号进行索引。x86 2 级分页方案通过将巨型页表分成许多页表和一个页目录来打破这个简单的模型。在内核中，我们使用<code>pgdir_walk()</code>通过遍历两级页表来查找条目。以某种方式恢复巨大的简单页表会很好——JOS 中的进程将查看它以弄清楚它们的地址空间中发生了什么。</p>
<p>这个页面描述了 JOS 通过利用分页硬件使用的一个巧妙的技巧——分页硬件非常适合将一组碎片页面放在一个连续的地址空间中。事实证明，我们已经有一个表，其中包含指向所有碎片页表的指针：它是页目录！</p>
<p>因此，我们可以使用页目录作为页表，在虚拟地址空间中某个连续的 2^22 字节范围内映射我们概念上的巨大 2^22 字节页表（由 1024 个页面表示）。我们可以通过将 PDE 条目标记为只读来确保用户进程不能修改他们的页表。</p>
<p>解释一下，每个4GB虚拟地址空间对应一个页目录，一个页目录包含2^10（10bits）个页表，每个页表有 2^10(10bits)页，每页的大小是 2^12B(12bits)，最终形成4GB地址空间。</p>
<p><img src="/img/20211124224000.png" alt=""></p>
<p>CR3指向页目录，解析一个线性地址，MMU会跟据其PDX，PTX和OFFSET三个部分依次去在页目录（通过目录项找到页表）和页表（通过表项找到页）中进行索引。</p>
<p>但是处理器分不清楚页表、页目录，它只是根据以下过程来进行查找：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pd = lcr3(); </span><br><span class="line">pt = *(pd+4*PDX); </span><br><span class="line">page = *(pt+4*PTX);</span><br></pre></td></tr></table></figure></p>
<p>UVPT是页目录中的一个特殊的entry，它指向的是页目录自身。若UVPT的索引值是V，如果我们用一个PDX和PTX都是V的线性地址去进行解析，就会发现由于在页目录中对第V个entry的索引仍然是页目录本身的地址，这个地址最终解析出的就是页目录的物理地址（你可以理解为页目录本身就是一个页表，这种方式下我们连续两次解析到页目录本身的地址）。在JOS中，V=0x3BD，所以UVPD的虚拟地址是<code>(0x3BD &lt;&lt; 22)|(0x3BD &lt;&lt; 12)</code>。</p>
<p>同理，如果PDX为V而PTX不为V，则会解析出各个页表的地址。在JOS中，V=0x3BD，所以UVPT的虚拟地址是<code>(0x3BD &lt;&lt; 22)</code>。通过这种方式，用户可以在UVPT内存区中访问到页目录和各个页表。<br><img src="/img/20211124224001.png" alt=""></p>
<h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h4><p>首先从主函数<code>fork()</code>入手，其大体结构可以仿造<code>user/dumbfork.c</code>写，但是有关键几处不同：</p>
<ul>
<li>设置<code>page fault handler</code>，即<code>page fault upcall</code>调用的函数</li>
<li><code>duppage</code>的范围不同，<code>fork()</code>不需要复制内核区域的映射</li>
<li>为子进程设置<code>page fault upcall</code>，之所以这么做，是因为<code>sys_exofork()</code>并不会复制父进程的<code>e-&gt;env_pgfault_upcall</code>给子进程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">envid_t</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;fork not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    set_pgfault_handler(pgfault);</span><br><span class="line">    <span class="type">envid_t</span> e_id = sys_exofork();</span><br><span class="line">    <span class="keyword">if</span> (e_id &lt; <span class="number">0</span>) panic(<span class="string">&quot;fork: %e&quot;</span>, e_id);</span><br><span class="line">    <span class="keyword">if</span> (e_id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parent</span></span><br><span class="line">    <span class="comment">// extern unsigned char end[];</span></span><br><span class="line">    <span class="comment">// for ((uint8_t *) addr = UTEXT; addr &lt; end; addr += PGSIZE)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uintptr_t</span> addr = UTEXT; addr &lt; USTACKTOP; addr += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) ) &#123;</span><br><span class="line">            <span class="comment">// dup page to child</span></span><br><span class="line">            duppage(e_id, PGNUM(addr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// alloc page for exception stack</span></span><br><span class="line">    <span class="type">int</span> r = sys_page_alloc(e_id, (<span class="type">void</span> *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_W | PTE_P);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) panic(<span class="string">&quot;fork: %e&quot;</span>,r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DO NOT FORGET</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">void</span> _pgfault_upcall();</span><br><span class="line">    r = sys_env_set_pgfault_upcall(e_id, _pgfault_upcall);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) panic(<span class="string">&quot;fork: set upcall for child fail, %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mark the child environment runnable</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_env_set_status(e_id, ENV_RUNNABLE)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;sys_env_set_status: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="duppage-函数"><a href="#duppage-函数" class="headerlink" title="duppage()函数"></a>duppage()函数</h4><p>该函数的作用是复制父、子进程的页面映射。尤其注意一个权限问题。由于<code>sys_page_map()</code>页面的权限有硬性要求，因此必须要修正一下权限。之前没有修正导致一直报错，后来发现页面权限为<code>0x865</code>，不符合<code>sys_page_map()</code>要求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">duppage</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">unsigned</span> pn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;duppage not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">envid_t</span> this_env_id = sys_getenvid();</span><br><span class="line">    <span class="type">void</span> * va = (<span class="type">void</span> *)(pn * PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> perm = uvpt[pn] &amp; <span class="number">0xFFF</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (perm &amp; PTE_W) || (perm &amp; PTE_COW) ) &#123;</span><br><span class="line">        <span class="comment">// marked as COW and read-only</span></span><br><span class="line">        perm |= PTE_COW;</span><br><span class="line">        perm &amp;= ~PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// IMPORTANT: adjust permission to the syscall</span></span><br><span class="line">    perm &amp;= PTE_SYSCALL;</span><br><span class="line">    <span class="comment">// cprintf(&quot;fromenvid = %x, toenvid = %x, dup page %d, addr = %08p, perm = %03x\n&quot;,this_env_id, envid, pn, va, perm);</span></span><br><span class="line">    <span class="keyword">if</span>((r = sys_page_map(this_env_id, va, envid, va, perm)) &lt; <span class="number">0</span>) </span><br><span class="line">        panic(<span class="string">&quot;duppage: %e&quot;</span>,r);</span><br><span class="line">    <span class="keyword">if</span>((r = sys_page_map(this_env_id, va, this_env_id, va, perm)) &lt; <span class="number">0</span>) </span><br><span class="line">        panic(<span class="string">&quot;duppage: %e&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pgfault-函数"><a href="#pgfault-函数" class="headerlink" title="pgfault() 函数"></a>pgfault() 函数</h4><p>这是<code>_pgfault_upcall</code>中调用的页错误处理函数。在调用之前，父子进程的页错误地址都引用同一页物理内存，该函数作用是分配一个物理页面使得两者独立。</p>
<p>首先，它分配一个页面，映射到了交换区<code>PFTEMP</code>这个虚拟地址，然后通过<code>memmove()</code>函数将<code>addr</code>所在页面拷贝至<code>PFTEMP</code>，此时有两个物理页保存了同样的内容。再将<code>addr</code>也映射到<code>PFTEMP</code>对应的物理页，最后解除了<code>PFTEMP</code>的映射，此时就只有<code>addr</code>指向新分配的物理页了，如此就完成了错误处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">pgfault</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *addr = (<span class="type">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">    <span class="type">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></span><br><span class="line">    <span class="comment">// copy-on-write page.  If not, panic.</span></span><br><span class="line">    <span class="comment">// Hint:</span></span><br><span class="line">    <span class="comment">//   Use the read-only page table mappings at uvpt</span></span><br><span class="line">    <span class="comment">//   (see &lt;inc/memlayout.h&gt;).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> ((err &amp; FEC_WR)==<span class="number">0</span> || (uvpt[PGNUM(addr)] &amp; PTE_COW)==<span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;pgfault: invalid user trap frame&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></span><br><span class="line">    <span class="comment">// copy the data from the old page to the new page, then move the new</span></span><br><span class="line">    <span class="comment">// page to the old page&#x27;s address.</span></span><br><span class="line">    <span class="comment">// Hint:</span></span><br><span class="line">    <span class="comment">//   You should make three system calls.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;pgfault not implemented&quot;);</span></span><br><span class="line">    <span class="type">envid_t</span> envid = sys_getenvid();</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_alloc(envid, (<span class="type">void</span> *)PFTEMP, PTE_P | PTE_W | PTE_U)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;pgfault: page allocation failed %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    memmove(PFTEMP, addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(envid, addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;pgfault: page unmap failed (%e)&quot;</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_map(envid, PFTEMP, envid, addr, PTE_P | PTE_W |PTE_U)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;pgfault: page map failed (%e)&quot;</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = sys_page_unmap(envid, PFTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;pgfault: page unmap failed (%e)&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Part-C-抢占式多进程处理-amp-进程间通信"><a href="#Part-C-抢占式多进程处理-amp-进程间通信" class="headerlink" title="Part C: 抢占式多进程处理 &amp; 进程间通信"></a>Part C: 抢占式多进程处理 &amp; 进程间通信</h2><p>作为 lab4 的最后一步，我们要修改内核使之能抢占一些不配合的进程占用的资源，以及允许进程之间的通信。</p>
<h3 id="Part-I-时钟中断以及抢占"><a href="#Part-I-时钟中断以及抢占" class="headerlink" title="Part I: 时钟中断以及抢占"></a>Part I: 时钟中断以及抢占</h3><p>尝试运行一下 user/spin 测试，该测试建立一个子进程，该子进程获得 CPU 资源后就进入死循环，这样内核以及父进程都无法再次获得 CPU。这显然是操作系统需要避免的。为了允许内核从一个正在运行的进程抢夺 CPU 资源，我们需要支持来自硬件时钟的外部硬件中断。</p>
<h4 id="Interrupt-discipline"><a href="#Interrupt-discipline" class="headerlink" title="Interrupt discipline"></a>Interrupt discipline</h4><p>外部中断用 IRQ(Interrupt Request) 表示。一共有 16 种 IRQ，IRQ的编号到IDT表项的映射并不是固定的。<code>picirq.c</code>的<code>pic_init()</code>将会把0-15号IRQ映射到<code>IDT</code>表项中对应的<code>IRQ_OFFSET</code>-<code>IRQ_OFFSET+15</code>。</p>
<p><code>IRQ_OFFSET</code>被定义为32（在<code>inc/trap.h</code>中），那么<code>IDT</code>表项的32-47就对应了15种<code>IRQ</code>，时钟中断是<code>IRQ 0</code>。这样设置不会让处理器异常和IRQ重叠。</p>
<p>Lab3中介绍 x86 的所有异常可以用中断向量 0~31 表示，对应 IDT 的第 0~31 项。例如，页错误产生一个中断向量为 14 的异常。大于 32 的中断向量表示的都是中断</p>
<p>相对 xv6，在 JOS 中我们中了一个关键的简化：在内核态时禁用外部设备中断。外部中断使用<code>%eflag</code>寄存器的<code>FL_IF</code>位控制。当该位置 1 时，开启中断。由于我们的简化，我们只在进入以及离开内核时需要修改这个位。</p>
<p>我们需要确保在用户态时<code>FL_IF</code>置 1，使得当有中断发生时，可以被处理。我们在<code>bootloader</code>的第一条指令<code>cli</code>就关闭了中断，然后再也没有开启过。</p>
<p>exercise13要求我们修改<code>kern/trap.c</code>和<code>kern/trapentry.S</code>，来初始化IDT中的入口，为IRQ 0到15提供处理函数。然后修改<code>env_alloc</code>，确保用户环境能够在使能中断时运行。</p>
<p>比较简单，跟 Lab3 中的 Exercise 4 大同小异。相关的常数定义在<code>inc/trap.h</code>中可以找到。</p>
<p>在<code>kern/trapentry.S</code>中加入：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IRQs</span></span><br><span class="line">TRAPHANDLER(handler32, IRQ_OFFSET + IRQ_TIMER)</span><br><span class="line">TRAPHANDLER(handler33, IRQ_OFFSET + IRQ_KBD)</span><br><span class="line">TRAPHANDLER(handler36, IRQ_OFFSET + IRQ_SERIAL)</span><br><span class="line">TRAPHANDLER(handler39, IRQ_OFFSET + IRQ_SPURIOUS)</span><br><span class="line">TRAPHANDLER(handler46, IRQ_OFFSET + IRQ_IDE)</span><br><span class="line">TRAPHANDLER(handler51, IRQ_OFFSET + IRQ_ERROR)</span><br></pre></td></tr></table></figure></p>
<p>在<code>kern/trap.c</code>的<code>trap_init()</code>中加入：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// IRQs</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">handler32</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">handler33</span><span class="params">()</span>;   </span><br><span class="line">    <span class="type">void</span> <span class="title function_">handler36</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">handler39</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">handler46</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">handler51</span><span class="params">()</span>;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// IRQs</span></span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], <span class="number">0</span>, GD_KT, handler32, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_KBD], <span class="number">0</span>, GD_KT, handler33, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL], <span class="number">0</span>, GD_KT, handler36, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], <span class="number">0</span>, GD_KT, handler39, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_IDE], <span class="number">0</span>, GD_KT, handler46, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], <span class="number">0</span>, GD_KT, handler51, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意，<code>SETGATE</code>中<code>istrap</code>参数需要设置为0。根据<code>SETGATE</code>的注释，两个值的区别在于，设为<code>1</code>就会在开始处理中断时将<code>FL_IF</code>位重新置1，而设为<code>0</code>则保持<code>FL_IF</code>位不变。根据这里的需求，显然应该置0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up a normal interrupt/trap gate descriptor.</span></span><br><span class="line"><span class="comment">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span></span><br><span class="line">    <span class="comment">//   see section 9.6.1.3 of the i386 reference: &quot;The difference between</span></span><br><span class="line">    <span class="comment">//   an interrupt gate and a trap gate is in the effect on IF (the</span></span><br><span class="line">    <span class="comment">//   interrupt-enable flag). An interrupt that vectors through an</span></span><br><span class="line">    <span class="comment">//   interrupt gate resets IF, thereby preventing other interrupts from</span></span><br><span class="line">    <span class="comment">//   interfering with the current interrupt handler. A subsequent IRET</span></span><br><span class="line">    <span class="comment">//   instruction restores IF to the value in the EFLAGS image on the</span></span><br><span class="line">    <span class="comment">//   stack. An interrupt through a trap gate does not change IF.&quot;</span></span><br><span class="line"><span class="comment">// - sel: Code segment selector for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - off: Offset in code segment for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - dpl: Descriptor Privilege Level -</span></span><br><span class="line"><span class="comment">//    the privilege level required for software to invoke</span></span><br><span class="line"><span class="comment">//    this interrupt/trap gate explicitly using an int instruction.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)            \</span></span><br><span class="line"><span class="meta">&#123;                               \</span></span><br><span class="line"><span class="meta">    (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff;     \</span></span><br><span class="line"><span class="meta">    (gate).gd_sel = (sel);                  \</span></span><br><span class="line"><span class="meta">    (gate).gd_args = 0;                 \</span></span><br><span class="line"><span class="meta">    (gate).gd_rsv1 = 0;                 \</span></span><br><span class="line"><span class="meta">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \</span></span><br><span class="line"><span class="meta">    (gate).gd_s = 0;                    \</span></span><br><span class="line"><span class="meta">    (gate).gd_dpl = (dpl);                  \</span></span><br><span class="line"><span class="meta">    (gate).gd_p = 1;                    \</span></span><br><span class="line"><span class="meta">    (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16;       \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在<code>kern/env.c</code>的<code>env_alloc()</code>中加入：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable interrupts while in user mode.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure></p>
<h4 id="Handling-Clock-Interrupts"><a href="#Handling-Clock-Interrupts" class="headerlink" title="Handling Clock Interrupts"></a>Handling Clock Interrupts</h4><p>在<code>user/spin</code>程序中，子进程开启后就陷入死循环，此后 kernel 无法再获得控制权。我们需要让硬件周期性地产生时钟中断，强制将控制权交给 kernel，使得我们能够切换到其他进程。</p>
<p>Exercise 14需要修改<code>trap_dispatch()</code>函数，当时钟中断到达时，执行新的环境。</p>
<p>直接在<code>trap_dispatch()</code>中添加时钟中断的分支即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle clock interrupts. Don&#x27;t forget to acknowledge the</span></span><br><span class="line"><span class="comment">// interrupt using lapic_eoi() before calling the scheduler!</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</span><br><span class="line">    lapic_eoi();</span><br><span class="line">    sched_yield();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Part-II-进程间通信-IPC"><a href="#Part-II-进程间通信-IPC" class="headerlink" title="Part II: 进程间通信(IPC)"></a>Part II: 进程间通信(IPC)</h3><p>在之前的 Lab 中，我们一直在讲操作系统是如何隔离各个进程的，怎么让程序感觉独占一台机器的。操作系统的另一个重要功能就是允许进程之间相互通信。</p>
<h4 id="IPC-in-JOS"><a href="#IPC-in-JOS" class="headerlink" title="IPC in JOS"></a>IPC in JOS</h4><p>我们将实现两个系统调用：<code>sys_ipc_recv</code>以及<code>sys_ipc_try_send</code>，再将他们封装为两个库函数，<code>ipc_recv</code>和<code>ipc_send</code>以支持通信。</p>
<p>用户环境可以通过jos系统的IPC机制向其他用户环境发送“消息”（message）。这个消息分为两部分：一个32-bit的值，以及一个可选的单页映射。允许用户环境传递页映射是一种比发送32-bit更有效的数据传递方式（很容易实现共享内存）。</p>
<h4 id="发送和接收消息"><a href="#发送和接收消息" class="headerlink" title="发送和接收消息"></a>发送和接收消息</h4><p>进程使用<code>sys_ipc_recv</code>来接收消息。该系统调用会将程序挂起，让出 CPU 资源，直到收到消息。在这个时期，任一进程都能给他发送信息，不限于父子进程。<br>为了发送信息，进程会调用<code>sys_ipc_try_send</code>，以接收者的进程<code>id</code>以及要发送的值为参数。如果接收者已经调用了<code>sys_ipc_recv</code>，则成功发送消息并返回0。否则返回<code>E_IPC_NOT_RECV</code>表明目标进程并没有接收消息。</p>
<p>用户空间的库函数<code>ipc_recv()</code>将会负责调用<code>sys_ipc_recv()</code>，然后在当前环境的<code>struct Env</code>中查找接收值的信息。相似地，库函数<code>ipc_send()</code>负责重复调用<code>sys_ipc_try_send()</code>直到发送成功。</p>
<h4 id="传递页面"><a href="#传递页面" class="headerlink" title="传递页面"></a>传递页面</h4><p>当进程调用<code>sys_ipc_recv</code>并提供一个<code>UTOP</code>以下的合法虚拟地址<code>dstva</code>(必须位于用户空间)时，进程表示它希望能接收一个页面映射。如果发送者发送一个页面，该页面就会被映射到接收者的<code>dstva</code>。同时，之前位于<code>dstva</code>的页面映射会被覆盖。</p>
<p>当进程调用<code>sys_ipc_try_send</code>并提供一个<code>UTOP</code>以下的合法虚拟地址<code>srcva</code>(必须位于用户空间)，表明发送者希望发送位于<code>srcva</code>的页面给接收者，权限设置为<code>perm</code>。当IPC成功进行之后，发送方会保持<code>srcva</code>处的映射关系，但是接受方同样也会在其地址<code>dstva</code>处映射这个页面。那此时这个页面就成了发送方到接受方的共享页面。</p>
<p>在一个成功的 IPC 之后，发送者和接受者将共享一个物理页。</p>
<p>注意，如果发送方和接收方之间的任意一方没有声明需要传输的是一个页面，那就不会有页面进行传输。</p>
<p>在任何IPC结束之后，内核将会设置接受方的<code>struct Env</code>的<code>env_ipc_perm</code>成员。如果没有接受页面则设置为0，如果接受页面则设置为接收到的页面权限<code>perm</code>。</p>
<h4 id="Implementing-IPC"><a href="#Implementing-IPC" class="headerlink" title="Implementing IPC"></a>Implementing IPC</h4><p>exercise 15实现<code>kern/syscall.c</code>中的<code>sys_ipc_recv()</code>和<code>sys_ipc_try_send()</code>。</p>
<p>当我们需要在这些有关IPC的例程中调用<code>envid2env()</code>时，需要将参数<code>checkperm</code>设置为0，这意味着任何环境都被允许与其他环境进行IPC。</p>
<p>然后实现<code>lib/ipc.c</code>中的<code>ipc_recv()</code>和<code>ipc_send()</code>的封装。</p>
<p>首先需要仔细阅读<code>inc/env.h</code>了解用于传递消息的数据结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lab 4 IPC</span></span><br><span class="line"><span class="type">bool</span> env_ipc_recving;       <span class="comment">// Env is blocked receiving</span></span><br><span class="line"><span class="type">void</span> *env_ipc_dstva;        <span class="comment">// VA at which to map received page</span></span><br><span class="line"><span class="type">uint32_t</span> env_ipc_value;     <span class="comment">// Data value sent to us</span></span><br><span class="line"><span class="type">envid_t</span> env_ipc_from;       <span class="comment">// envid of the sender</span></span><br><span class="line"><span class="type">int</span> env_ipc_perm;       <span class="comment">// Perm of page mapping received</span></span><br></pre></td></tr></table></figure></p>
<p>然后需要注意的是通信流程。</p>
<ol>
<li>调用<code>ipc_recv</code>，设置好<code>Env</code>结构体中的相关<code>field</code></li>
<li>调用<code>ipc_send</code>，它会通过<code>envid</code>找到接收进程，并读取<code>Env</code>中刚才设置好的<code>field</code>，进行通信。</li>
<li>最后返回实际上是在<code>ipc_send</code>中设置好<code>reg_eax</code>，在调用结束，退出内核态时返回。</li>
</ol>
<p>首先从调用过程入手，这部分比较简单。</p>
<h4 id="lib-部分"><a href="#lib-部分" class="headerlink" title="lib 部分"></a>lib 部分</h4><p><code>ipc_recv</code>中，如果<code>pg</code>不为空，则收到的页会被映射到这里。如果<code>from_env_store</code>不为空，则把sender的<code>envid</code>存到这里。如果系统调用失败了，<code>*fromenv</code>和<code>*perm</code>这两个都会被赋值为0。</p>
<p>如果不需要共享页面，则把作为参数的虚拟地址设为<code>UTOP</code>，这个地址在下面的系统调用实现中，会被忽略掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">ipc_recv</span><span class="params">(<span class="type">envid_t</span> *from_env_store, <span class="type">void</span> *pg, <span class="type">int</span> *perm_store)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;ipc_recv not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (pg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        r = sys_ipc_recv(pg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = sys_ipc_recv((<span class="type">void</span> *) UTOP);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// failed</span></span><br><span class="line">        <span class="keyword">if</span> (from_env_store != <span class="literal">NULL</span>) *from_env_store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (perm_store != <span class="literal">NULL</span>) *perm_store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (from_env_store != <span class="literal">NULL</span>) </span><br><span class="line">            *from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">        <span class="keyword">if</span> (perm_store != <span class="literal">NULL</span>) </span><br><span class="line">            *perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">        <span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数就是会不停地尝试，在这个while里也要调用<code>sys_yield</code>防止一直占用CPU。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_send</span><span class="params">(<span class="type">envid_t</span> to_env, <span class="type">uint32_t</span> val, <span class="type">void</span> *pg, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;ipc_send not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> (pg == <span class="literal">NULL</span>) pg = (<span class="type">void</span> *)UTOP;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        r = sys_ipc_try_send(to_env, val, pg, perm);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> &amp;&amp; r != -E_IPC_NOT_RECV) </span><br><span class="line">            panic(<span class="string">&quot;ipc send failed: %e&quot;</span>, r);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125; <span class="keyword">while</span> (r != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sys_ipc_recv()</code>首先检查<code>dstva</code>是否合法，这里如果<code>dstva</code>等于<code>UTOP</code>的其实也是合法的，只是不需要去映射地址。然后获取到相应的<code>env</code>对象，设置其ipc数据域，并把当前的<code>env</code>设置成不能运行，直至接收完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 接收</span><br><span class="line">static int</span><br><span class="line">sys_ipc_recv(void *dstva)</span><br><span class="line">&#123;</span><br><span class="line">    // LAB 4: Your code here.</span><br><span class="line">    // panic(&quot;sys_ipc_recv not implemented&quot;);</span><br><span class="line">    </span><br><span class="line">    // wrong, because when we don&#x27;t want to share page, we set dstva=UTOP</span><br><span class="line">    // but we can still pass value</span><br><span class="line">    // if ( (uintptr_t) dstva &gt;= UTOP) return -E_INVAL;</span><br><span class="line">    if ((uintptr_t) dstva &lt; UTOP &amp;&amp; PGOFF(dstva) != 0) return -E_INVAL;</span><br><span class="line"></span><br><span class="line">    envid_t envid = sys_getenvid();</span><br><span class="line">    struct Env *e;</span><br><span class="line">    // do not check permission</span><br><span class="line">    if (envid2env(envid, &amp;e, 0) &lt; 0) return -E_BAD_ENV;</span><br><span class="line">    </span><br><span class="line">    e-&gt;env_ipc_recving = true;</span><br><span class="line">    e-&gt;env_ipc_dstva = dstva;</span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    sys_yield();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sys_ipc_try_send()</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try to send &#x27;value&#x27; to the target env &#x27;envid&#x27;.</span></span><br><span class="line"><span class="comment">// If srcva &lt; UTOP, then also send page currently mapped at &#x27;srcva&#x27;,</span></span><br><span class="line"><span class="comment">// so that receiver gets a duplicate mapping of the same page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The send fails with a return value of -E_IPC_NOT_RECV if the</span></span><br><span class="line"><span class="comment">// target is not blocked, waiting for an IPC.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The send also can fail for the other reasons listed below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Otherwise, the send succeeds, and the target&#x27;s ipc fields are</span></span><br><span class="line"><span class="comment">// updated as follows:</span></span><br><span class="line"><span class="comment">//    env_ipc_recving is set to 0 to block future sends;</span></span><br><span class="line"><span class="comment">//    env_ipc_from is set to the sending envid;</span></span><br><span class="line"><span class="comment">//    env_ipc_value is set to the &#x27;value&#x27; parameter;</span></span><br><span class="line"><span class="comment">//    env_ipc_perm is set to &#x27;perm&#x27; if a page was transferred, 0 otherwise.</span></span><br><span class="line"><span class="comment">// The target environment is marked runnable again, returning 0</span></span><br><span class="line"><span class="comment">// from the paused sys_ipc_recv system call.  (Hint: does the</span></span><br><span class="line"><span class="comment">// sys_ipc_recv function ever actually return?)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the sender wants to send a page but the receiver isn&#x27;t asking for one,</span></span><br><span class="line"><span class="comment">// then no page mapping is transferred, but no error occurs.</span></span><br><span class="line"><span class="comment">// The ipc only happens when no errors occur.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn&#x27;t currently exist.</span></span><br><span class="line"><span class="comment">//		(No need to check permissions.)</span></span><br><span class="line"><span class="comment">//	-E_IPC_NOT_RECV if envid is not currently blocked in sys_ipc_recv,</span></span><br><span class="line"><span class="comment">//		or another environment managed to send first.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &lt; UTOP but srcva is not page-aligned.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &lt; UTOP and perm is inappropriate</span></span><br><span class="line"><span class="comment">//		(see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &lt; UTOP but srcva is not mapped in the caller&#x27;s</span></span><br><span class="line"><span class="comment">//		address space.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if (perm &amp; PTE_W), but srcva is read-only in the</span></span><br><span class="line"><span class="comment">//		current environment&#x27;s address space.</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if there&#x27;s not enough memory to map srcva in envid&#x27;s</span></span><br><span class="line"><span class="comment">//		address space.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_try_send</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">uint32_t</span> value, <span class="type">void</span> *srcva, <span class="type">unsigned</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">tar_env</span>;</span></span><br><span class="line">	<span class="comment">// check target env</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid, &amp;tar_env, <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// check recver status</span></span><br><span class="line">	<span class="keyword">if</span>(!tar_env-&gt;env_ipc_recving)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// page send</span></span><br><span class="line">	<span class="keyword">if</span>((<span class="type">uintptr_t</span>)srcva &lt; UTOP)&#123;</span><br><span class="line">		<span class="comment">//page valid check</span></span><br><span class="line">		<span class="keyword">if</span>(PGOFF(srcva))&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// perm valid check</span></span><br><span class="line">		<span class="keyword">if</span>(perm &amp; (~PTE_SYSCALL) || !(perm &amp; PTE_U) || !(perm &amp; PTE_P))&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// page find</span></span><br><span class="line">		<span class="type">pte_t</span> * pte;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">pginfo</span>;</span></span><br><span class="line">		pginfo = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pte);</span><br><span class="line">		<span class="keyword">if</span>(!pginfo)&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// sender &amp; receiver PTE_W</span></span><br><span class="line">		<span class="keyword">if</span>((perm &amp; PTE_W) &amp;&amp; !((*pte) &amp; PTE_W))&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// dst check</span></span><br><span class="line">		<span class="keyword">if</span>((<span class="type">uintptr_t</span>)(tar_env-&gt;env_ipc_dstva) &lt; UTOP)&#123;</span><br><span class="line">			<span class="comment">// insert page map</span></span><br><span class="line">			<span class="keyword">if</span>(page_insert(tar_env-&gt;env_pgdir, pginfo, tar_env-&gt;env_ipc_dstva, perm) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// insert success</span></span><br><span class="line">			tar_env-&gt;env_ipc_perm = perm;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tar_env-&gt;env_ipc_perm = <span class="number">0</span>;</span><br><span class="line">	tar_env-&gt;env_ipc_value = value;</span><br><span class="line">	<span class="comment">// tar status</span></span><br><span class="line">	tar_env-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">	tar_env-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">	tar_env-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	tar_env-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在这次lab中，您将实现spawn，这是一个加载和运行磁盘可执行文件的库调用。然后，您将充实kernel和库操作系统，以在控制台上运行Shell。</p>
<h2 id="文件系统初步"><a href="#文件系统初步" class="headerlink" title="文件系统初步"></a>文件系统初步</h2><p>JOS文件系统设计相比Linux等系统的文件系统如ext2，ext3等，要简化不少。它不支持用户和权限特性，也不支持硬链接，符号链接，时间戳以及特殊设备文件等。</p>
<h3 id="磁盘文件系统结构"><a href="#磁盘文件系统结构" class="headerlink" title="磁盘文件系统结构"></a>磁盘文件系统结构</h3><p>大部分Unix文件系统会将磁盘空间分为inode和data两个部分，如linux就是这样的，其中inode用于存储文件的元数据，比如文件类型(常规、目录、符号链接等），权限，文件大小，创建/修改/访问时间，文件数据块信息等，我们运行的<code>ls -l</code>看到的内容，都是存储在inode而不是数据块中的。数据部分通常分为很多数据块，数据块用于存储文件的数据信息以及目录的元数据(目录元数据包括目录下文件的inode，文件名，文件类型等)。</p>
<p>文件和目录在逻辑上都由一系列数据块组成，这些数据块可能分散在整个磁盘中，就像虚拟地址空间的页面可以分散在整个物理内存中一样。文件系统环境隐藏了块布局的细节，提供了用于读取和写入文件内任意偏移量的字节序列的接口。文件系统环境在内部处理对目录的所有修改，作为执行文件创建和删除等操作的一部分。我们的文件系统允许用户环境直接读取目录元数据（例如，使用 read），这意味着用户环境可以自己执行目录扫描操作（例如，实现 ls 程序），而不必依赖到文件系统的特殊系统调用。这种目录扫描方法的缺点，也是大多数现代 UNIX 变体不鼓励它的原因，是它使应用程序依赖于目录元数据的格式，从而很难在不改变或至少改变文件系统的内部布局的情况下重新编译应用程序。</p>
<h3 id="磁盘扇区、数据块"><a href="#磁盘扇区、数据块" class="headerlink" title="磁盘扇区、数据块"></a>磁盘扇区、数据块</h3><p>扇区是磁盘的物理属性，通常一个扇区大小为512字节，而数据块则是操作系统使用磁盘的一个逻辑属性，一个块大小通常是扇区的整数倍，在JOS中一个扇区是512Bytes，一个块大小为4KB，跟我们物理内存的页大小一致。UNIX xv6 文件系统使用 512 字节的块大小，与底层磁盘的扇区大小相同。然而，大多数现代文件系统使用更大的块大小，因为存储空间变得更便宜，并且以更大的粒度管理存储更有效。我们的文件系统将使用 4096 字节的块大小，方便地匹配处理器的页面大小。</p>
<p>文件系统实际上以块为单位分配和使用磁盘存储。注意这两个术语之间的区别：扇区大小是磁盘硬件的属性，而块大小是使用磁盘的操作系统的一个方面。文件系统的块大小必须是底层磁盘扇区大小的倍数。</p>
<h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><p>文件系统通常在磁盘上“易于查找”的位置（例如开头或结尾）保留某些磁盘块，以保存描述整个文件系统属性的元数据，例如块大小、磁盘大小、查找根目录所需的任何元数据、文件系统上次挂载的时间、文件系统上次检查错误的时间等。这些特殊块被称为超级块。</p>
<p>我们的文件系统将只有一个超级块，它始终位于磁盘上的块 1。它的布局由<code>inc/fs.h</code>中的<code>struct Super</code>定义。块 0 通常保留用于保存引导加载程序和分区表，因此文件系统通常不使用第一个磁盘块。许多“真正的”文件系统维护多个超级块，在磁盘的多个间隔很宽的区域中复制，因此如果其中一个被损坏或磁盘在该区域出现介质错误，则仍然可以找到其他超级块并用于访问文件系统。</p>
<h3 id="文件元数据"><a href="#文件元数据" class="headerlink" title="文件元数据"></a>文件元数据</h3><p>在我们的文件系统中描述文件的元数据的布局由<code>inc/fs.h</code>中的<code>struct File</code>描述。此元数据包括文件的名称、大小、类型（常规文件或目录）以及指向组成文件的块的指针。如上所述，我们没有<code>inode</code>，因此此元数据存储在磁盘上的目录条目中。与大多数“真实”文件系统不同，为简单起见，我们将使用这种文件结构来表示文件元数据，因为它同时出现在磁盘和内存中。</p>
<p><img src="/img/20211128114300.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> s_magic;               <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">        <span class="type">uint32_t</span> s_nblocks;             <span class="comment">// Total number of blocks on disk</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>             <span class="comment">// Root directory node</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct File</code>中的<code>f_direct</code>数组包含空间来存储文件的前 10 个（NDIRECT）块的块号，我们称之为文件的直接块。对于大小不超过<code>10*4096 = 40KB</code>的小文件，这意味着所有文件块的块号将直接适合文件结构本身。然而，对于较大的文件，我们需要一个地方来保存文件的其余块编号。因此，对于任何大于 40KB 的文件，我们分配一个额外的磁盘块，称为文件的间接块，以容纳多达<code>4096/4 = 1024</code>个额外的块号。因此，我们的文件系统允许文件最大为 1034 个块，或略高于 4 兆字节。为了支持更大的文件，“真正的”文件系统通常也支持双重和三重间接块。</p>
<p><img src="/img/20211128114301.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> f_name[MAXNAMELEN];    <span class="comment">// filename</span></span><br><span class="line">    <span class="type">off_t</span> f_size;           <span class="comment">// file size in bytes</span></span><br><span class="line">    <span class="type">uint32_t</span> f_type;        <span class="comment">// file type</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block pointers.</span></span><br><span class="line">    <span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line">    <span class="type">uint32_t</span> f_direct[NDIRECT]; <span class="comment">// direct blocks</span></span><br><span class="line">    <span class="type">uint32_t</span> f_indirect;        <span class="comment">// indirect block</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pad out to 256 bytes; must do arithmetic in case we&#x27;re compiling</span></span><br><span class="line">    <span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line">    <span class="type">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">&#125; __attribute__((packed));  <span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></table></figure>
<h3 id="目录与常规文件"><a href="#目录与常规文件" class="headerlink" title="目录与常规文件"></a>目录与常规文件</h3><p>我们文件系统中的 File 结构可以表示一个普通文件或一个目录； 这两种类型的“文件”通过文件结构中的类型字段来区分。文件系统以完全相同的方式管理常规文件和目录文件，除了它根本不解释与常规文件关联的数据块的内容，而文件系统将目录文件的内容解释为一系列 描述目录中的文件和子目录的文件结构。</p>
<p>我们文件系统中的超级块包含一个文件结构（结构 Super 中的根字段），它保存文件系统根目录的元数据。该目录文件的内容是描述位于文件系统根目录中的文件和目录的文件结构序列。根目录中的任何子目录又可能包含更多表示子子目录的文件结构，依此类推。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h3><p>操作系统中的文件系统环境需要能够访问磁盘，但是我们还没有在内核中实现任何磁盘访问功能。我们没有采用传统的“单片”操作系统策略，即在内核中添加IDE磁盘驱动程序以及允许文件系统访问它的必要的系统调用，而是将IDE磁盘驱动程序实现为用户级文件系统环境的一部分。我们仍然需要稍微修改内核，以便进行设置，使文件系统环境具有实现磁盘访问本身所需的特权。</p>
<p>只要我们依赖于polling(轮询)、基于“programmed I/O”(PIO)的磁盘访问，并且不使用磁盘中断，就很容易在用户空间中实现磁盘访问。也可以在用户模式下实现中断驱动的设备驱动程序(例如，L3和L4内核是这样做的)，但是难度更大，因为内核必须实现设备中断并将它们分派到正确的用户模式环境中。</p>
<p>x86处理器使用EFLAGS寄存器中的IOPL位来确定是否允许保护模式代码执行特殊的设备I/O指令，比如IN和OUT指令。由于我们需要访问的所有IDE磁盘寄存器都位于x86的I/O空间中，而不是内存映射，所以为了允许文件系统访问这些寄存器，我们只需要给文件系统环境提供“I/O privilege”。实际上，EFLAGS寄存器中的IOPL位为内核提供了一个简单的“all-or-nothing”(全有或全无)方法来控制用户模式代码是否可以访问I/O空间。在我们的示例中，我们希望文件系统environment能够访问I/O空间，但是我们根本不希望任何其他environment能够访问I/O空间。</p>
<p>Exercise 1. <code>i386_init</code>通过将类型<code>ENV_TYPE_FS</code>传递给环境创建函数<code>env_create</code>来标识文件系统环境。在<code>env.c</code>中修改<code>env_create</code>，以便它赋予文件系统environment I/O特权，但永远不要将该特权授予任何其他环境。</p>
<p>这个地方代码还是比较简单的，毕竟之前为用户环境开中断也是设置的<code>eflags</code>的<code>FL_IF</code>位，这里就是设置<code>eflags</code>的<code>IOPL</code>位<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_create</span><span class="params">(<span class="type">uint8_t</span> *binary, <span class="type">size_t</span> size, <span class="keyword">enum</span> EnvType type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">        <span class="type">int</span> result = env_alloc(&amp;env, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(result &lt; <span class="number">0</span>)</span><br><span class="line">                panic(<span class="string">&quot;env_create: env_alloc error&quot;</span>);</span><br><span class="line">        load_icode(env, binary, size);</span><br><span class="line">        env-&gt;env_type = type;</span><br><span class="line">        <span class="comment">// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.</span></span><br><span class="line">        <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">        <span class="keyword">if</span> (type == ENV_TYPE_FS)</span><br><span class="line">                env-&gt;env_tf.tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Question1.当您随后从一种environment切换到另一种environment时，是否还需要执行其他操作以确保正确保存和恢复此I/O特权设置？ 为什么？</p>
<p>answer：这肯定是不用的，每次切换进程都会保存上下文，切回来的时候恢复上下文。</p>
<h3 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h3><p>在我们的文件系统中，我们将借助处理器的虚拟内存系统实现一个简单的“buffer cache”（实际上只是一个block cache）。 block cache的代码在<code>fs/bc.c</code>中。（这里其实就暗示了文件系统读写的单位是一个block而不是扇区）。</p>
<p>我们的文件系统将仅限于处理3GB或更小的磁盘。我们保留文件系统environment的地址空间的一个大的、固定的3GB区域，从<code>0x10000000</code> (<code>DISKMAP</code>)到<code>0xD0000000</code>(<code>DISKMAP+DISKMAX</code>)，作为磁盘的“内存映射”版本。例如，disk block 0映射到虚拟地址<code>0x10000000</code>，disk block 1映射到虚拟地址<code>0x10001000</code>(一个块4KB)，以此类推。<code>fs/bc.c</code>中的<code>diskaddr</code>函数实现了从 disk block numbers到虚拟地址的转换(以及一些完整性(sanity)检查)。</p>
<p>由于我们的文件系统environment具有自己的虚拟地址空间，而与系统中其他environment的虚拟地址空间无关，并且文件系统environment唯一需要做的就是实现文件访问，因此我们以这种方式保留大多数文件系统environment的地址空间。 由于现代磁盘大于3GB，因此在32位计算机上执行真实文件系统会很尴尬。 在具有64位地址空间的机器上，这种buffer cache管理方法仍然是合理的。</p>
<p>当然，将整个磁盘读取到内存中要花很长时间，所以我们以请求分页(demand paging)的形式实现，其中我们只在磁盘映射区域分配页和从磁盘读取相应的块来响应一个在这个地区发生的页面错误。</p>
<p><code>ide_read()</code>的单位是扇区，不是磁盘块，通过<code>outb</code>指令设置读取的扇区数，通过<code>insl</code>指令读取磁盘数据到对应的虚拟地址<code>addr</code>处。<code>bc_pgfault</code>中分配了一页物理页，然后从磁盘中读取出错的addr那一块数据(8个扇区）到分配的物理页中，然后清除分配页的dirty标记，最后调用<code>block_is_free</code>检查对应磁盘块确保磁盘块已经分配。注意这里检查磁盘块是否已经分配要在最后检查，是因为<code>bitmap</code>的值是在<code>fs_init</code>时指定的为<code>diskaddr(2)</code>，即<code>0x10002000</code>，在准备读取第二个磁盘块发生页错误进入<code>bgfault</code>时，此时<code>bitmap</code>对应块还没有从磁盘读取并映射好，所以要在最后检查。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ide_read</span><span class="params">(<span class="type">uint32_t</span> secno, <span class="type">void</span> *dst, <span class="type">size_t</span> nsecs)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">        assert(nsecs &lt;= <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">        ide_wait_ready(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        outb(<span class="number">0x1F2</span>, nsecs);</span><br><span class="line">        outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">        outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        outb(<span class="number">0x1F6</span>, <span class="number">0xE0</span> | ((diskno&amp;<span class="number">1</span>)&lt;&lt;<span class="number">4</span>) | ((secno&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0x0F</span>));</span><br><span class="line">        outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);      <span class="comment">// CMD 0x20 means read sector</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; nsecs &gt; <span class="number">0</span>; nsecs--, dst += SECTSIZE) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((r = ide_wait_ready(<span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>fs/fs.c</code>中的<code>fs_init</code>函数是如何使用<code>block cache</code>的一个主要示例。在初始化块缓存之后，它简单将指向块缓存的指针存储到<code>super</code>全局变量中的磁盘映射区域。在这之后，我们可以简单地从<code>super structure</code>中读取，就像它们在内存中一样，并且我们的页面错误处理程序将根据需要从磁盘中读取它们。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the file system</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">fs_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> File) == <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find a JOS disk.  Use the second IDE disk (number 1) if available.</span></span><br><span class="line">        <span class="keyword">if</span> (ide_probe_disk1())</span><br><span class="line">                ide_set_disk(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                ide_set_disk(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bc_init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set &quot;super&quot; to point to the super block.</span></span><br><span class="line">        super = diskaddr(<span class="number">1</span>);</span><br><span class="line">        check_super();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Exercise 2. 在<code>fs/bc.c</code>中实现<code>bc_pgfault</code>和<code>flush_block</code>函数。<code>bc_pgfault</code>是一个页面错误处理程序，就像您在上一个lab中为copy-on-write fork的写的页面处理程序一样，不同之处在于<code>bc_pgfault</code>的工作是响应页面错误从磁盘加载页面。 编写此代码时，请记住，<code>addr</code>可能未与<code>block</code>对齐，并且<code>ide_read</code>在扇区而不是<code>block</code>中操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fault any disk block that is read in to memory by</span></span><br><span class="line"><span class="comment">// loading it from disk.只说从disk又不说disk哪个扇区</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">bc_pgfault</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *addr = (<span class="type">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">	<span class="type">uint32_t</span> blockno = ((<span class="type">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the fault was within the block cache region</span></span><br><span class="line">	<span class="keyword">if</span> (addr &lt; (<span class="type">void</span>*)DISKMAP || addr &gt;= (<span class="type">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">		panic(<span class="string">&quot;page fault in FS: eip %08x, va %08x, err %04x&quot;</span>,</span><br><span class="line">		      utf-&gt;utf_eip, addr, utf-&gt;utf_err);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sanity check the block number.</span></span><br><span class="line">	<span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">		panic(<span class="string">&quot;reading non-existent block %08x\n&quot;</span>, blockno);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a page in the disk map region, read the contents</span></span><br><span class="line">	<span class="comment">// of the block from the disk into that page.</span></span><br><span class="line">	<span class="comment">// Hint: first round addr to page boundary. fs/ide.c has code to read</span></span><br><span class="line">	<span class="comment">// the disk.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 5: you code here:</span></span><br><span class="line">	addr = (<span class="type">void</span> *)ROUNDDOWN(addr, BLKSIZE);</span><br><span class="line">	<span class="keyword">if</span>((r=sys_page_alloc(<span class="number">0</span>, addr, PTE_P | PTE_U | PTE_W))&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;in bc_pgfault,out of memory: %e&quot;</span>, r);</span><br><span class="line">	<span class="keyword">if</span>((r=ide_read(blockno*<span class="number">8</span>, addr, BLKSECTS))&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;in bc_pgfault, ide_read: %e&quot;</span>, r);</span><br><span class="line">	<span class="comment">// Clear the dirty bit for the disk block page since we just read the</span></span><br><span class="line">	<span class="comment">// block from disk</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;in bc_pgfault, sys_page_map: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the block we read was allocated. (exercise for</span></span><br><span class="line">	<span class="comment">// the reader: why do we do this *after* reading the block</span></span><br><span class="line">	<span class="comment">// in?)</span></span><br><span class="line">	<span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))</span><br><span class="line">		panic(<span class="string">&quot;reading free block %08x\n&quot;</span>, blockno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>flush_block()</code>函数用于在写入磁盘数据到块缓存后，调用<code>ide_write()</code>写入块缓存数据到磁盘中。写入完成后，也要通过<code>sys_page_map()</code>清除块缓存的<code>dirty</code>标记(每次写入物理页的时候，处理器会自动标记该页为<code>dirty</code>，即设置<code>PTE_D</code>标记)。注意，在<code>flush_block()</code>中，如果该地址并没有映射或者并没有<code>dirty</code>，则不需要做任何事情。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flush the contents of the block containing VA out to disk if</span></span><br><span class="line"><span class="comment">// necessary, then clear the PTE_D bit using sys_page_map.</span></span><br><span class="line"><span class="comment">// If the block is not in the block cache or is not dirty, does</span></span><br><span class="line"><span class="comment">// nothing.</span></span><br><span class="line"><span class="comment">// Hint: Use va_is_mapped, va_is_dirty, and ide_write.</span></span><br><span class="line"><span class="comment">// Hint: Use the PTE_SYSCALL constant when calling sys_page_map.</span></span><br><span class="line"><span class="comment">// Hint: Don&#x27;t forget to round addr down.</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">flush_block</span><span class="params">(<span class="type">void</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> blockno = ((<span class="type">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &lt; (<span class="type">void</span>*)DISKMAP || addr &gt;= (<span class="type">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">        panic(<span class="string">&quot;flush_block of bad va %08x&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    addr = ROUNDDOWN(addr, BLKSIZE);</span><br><span class="line">    <span class="keyword">if</span> (va_is_mapped(addr) &amp;&amp; va_is_dirty(addr)) &#123;</span><br><span class="line">        ide_write(blockno*BLKSECTS, addr, BLKSECTS);</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)]&amp;PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;in flush_block, sys_page_map: %e&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>bc.c</code>中的<code>bc_init</code>用于完成块缓存初始化，它完成下面几件事：</p>
<ol>
<li>设置页错误处理函数为<code>bc_pgfault</code>。</li>
<li>调用check_bc()。</li>
<li>读取磁盘块1的数据到函数局部变量super对应的地址中。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bc_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Super</span> <span class="title">super</span>;</span></span><br><span class="line">        set_pgfault_handler(bc_pgfault);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cache the super block by reading it once</span></span><br><span class="line">        memmove(&amp;super, diskaddr(<span class="number">1</span>), <span class="keyword">sizeof</span> super);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="块位图"><a href="#块位图" class="headerlink" title="块位图"></a>块位图</h3><p>在<code>fs_init</code>设置<code>bitmap</code>指针后，可以认为<code>bitmap</code>就是一个位数组，每个块占据一位。可以通过<code>block_is_free</code>检查块位图中的对应块是否空闲，如果为1表示空闲，为0已经使用。JOS中第0，1，2块分别给<code>bootloader</code>，<code>superblock</code>以及<code>bitmap</code>使用了。此外，因为在文件系统中加入了<code>user</code>目录和<code>fs</code>目录的文件，导致JOS文件系统一共用掉了0-110这111个文件块，下一个空闲文件块从111开始。</p>
<p>使用<code>free_block</code>作为模型在<code>fs/fs.c</code>中实现<code>alloc_block</code>。它应该在位图中找到一个空闲磁盘块，标记它该磁盘块已被使用，并返回该磁盘块号。当您分配一个块时，您应该立即使用<code>flush_block</code>将更改后的位图块刷新到磁盘，以保持文件系统的一致性。</p>
<p>使用位图标记一个块是否被使用过。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark a block free in the bitmap</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">free_block</span><span class="params">(<span class="type">uint32_t</span> blockno)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Blockno zero is the null pointer of block numbers.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 0 块启动块</span></span><br><span class="line">	<span class="keyword">if</span> (blockno == <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;attempt to free zero block&quot;</span>);</span><br><span class="line">	bitmap[blockno/<span class="number">32</span>] |= <span class="number">1</span>&lt;&lt;(blockno%<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Search the bitmap for a free block and allocate it.  When you</span></span><br><span class="line"><span class="comment">// allocate a block, immediately flush the changed bitmap block</span></span><br><span class="line"><span class="comment">// to disk.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return block number allocated on success,</span></span><br><span class="line"><span class="comment">// -E_NO_DISK if we are out of blocks.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">alloc_block</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The bitmap consists of one or more blocks.  A single bitmap block</span></span><br><span class="line">	<span class="comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span></span><br><span class="line">	<span class="comment">// super-&gt;s_nblocks blocks in the disk altogether.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>; i &lt; super-&gt;s_nblocks; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (block_is_free(i)) &#123;</span><br><span class="line">			bitmap[i/<span class="number">32</span>] &amp;=  ~(<span class="number">1</span>&lt;&lt;(i%<span class="number">32</span>));</span><br><span class="line">            <span class="comment">// 或者</span></span><br><span class="line">            <span class="comment">// bitmap[blockno/32] ^= 1&lt;&lt;(blockno%32);</span></span><br><span class="line">			flush_block(&amp;bitmap[i/<span class="number">32</span>]);</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// panic(&quot;alloc_block not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>在<code>fs/fs.c</code>中有很多文件操作相关的函数，这里的主要几个结构体要说明下：</p>
<ul>
<li><code>struct File</code>用于存储文件元数据，前面提到过。</li>
<li><code>struct Fd</code>用于文件模拟层，类似文件描述符，如文件ID，文件打开模式，文件偏移都存储在Fd中。一个进程同时最多打开 MAXFD(32) 个文件。</li>
</ul>
<p>文件系统进程还维护了一个打开文件的描述符表，即<code>opentab</code>数组，数组元素为<code>struct OpenFile</code>。<code>OpenFile</code>结构体用于存储打开文件信息，包括文件<code>ID</code>，<code>struct File</code>以及<code>struct Fd</code>。JOS同时打开的文件数一共为 MAXOPEN(1024) 个。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> &#123;</span>                                                              </span><br><span class="line">    <span class="type">uint32_t</span> o_fileid;  <span class="comment">// file id                                             </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>    <span class="comment">// mapped descriptor for open file                 </span></span><br><span class="line">    <span class="type">int</span> o_mode;     <span class="comment">// open mode                                               </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">o_fd</span>;</span>    <span class="comment">// Fd page                                             </span></span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd_dev_id;</span><br><span class="line">    <span class="type">off_t</span> fd_offset;</span><br><span class="line">    <span class="type">int</span> fd_omode;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">// File server files</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">FdFile</span> <span class="title">fd_file</span>;</span></span><br><span class="line">    &#125;;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>文件操作函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_block_walk(<span class="keyword">struct</span> File *f, <span class="type">uint32_t</span> filebno, <span class="type">uint32_t</span> **ppdiskbno, <span class="type">bool</span> alloc)</span><br></pre></td></tr></table></figure></p>
<p>这个函数是查找文件第<code>filebno</code>块的数据块的地址，查到的地址存储在<code>ppdiskbno</code>中。注意这里要检查间接块，如果alloc为1且寻址的块号<code>&gt;=NDIRECT</code>，而间接块没有分配的话需要分配一个间接块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_get_block(<span class="keyword">struct</span> File *f, <span class="type">uint32_t</span> filebno, <span class="type">char</span> **blk)</span><br></pre></td></tr></table></figure>
<p>查找文件第<code>filebno</code>块的块地址，并将块地址在虚拟内存中映射的地址存储在<code>blk</code>中(即将<code>diskaddr(blockno)</code>存到blk中)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir_lookup(<span class="keyword">struct</span> File *dir, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> File **file)</span><br></pre></td></tr></table></figure>
<p>在目录<code>dir</code>中查找名为<code>name</code>的文件，如果找到了设置<code>*file</code>为找到的文件。因为目录的数据块存储的是<code>struct File</code>列表，可以据此来查找文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_open(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> File **pf)</span><br></pre></td></tr></table></figure>
<p>打开文件，设置<code>*pf</code>为查找到的文件指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_create(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> File *pf)</span><br></pre></td></tr></table></figure>
<p>创建路径/文件，在pf存储创建好的文件指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_read(<span class="keyword">struct</span> File *f, <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span><br></pre></td></tr></table></figure>
<p>从文件的<code>offset</code>处开始读取<code>count</code>个字节到<code>buf</code>中，返回实际读取的字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_write(<span class="keyword">struct</span> File *f, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span><br></pre></td></tr></table></figure>
<p>从文件<code>offset</code>处开始写入<code>buf</code>中的<code>count</code>字节，返回实际写入的字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_truncate_blocks(<span class="keyword">struct</span> File *f, <span class="type">off_t</span> newsize);</span><br></pre></td></tr></table></figure>
<p>将文件设置为缩小后的新大小，清空那些被释放的物理块。</p>
<p>Exercise 4：实现<code>file_block_walk</code>函数和<code>file_get_block</code>函数。<br>　　<br>回答：<code>file_block_walk</code>函数寻找一个文件结构<code>f</code>中的第<code>fileno</code>个块指向的磁盘块编号放入<code>ppdiskbno</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">file_block_walk</span><span class="params">(<span class="keyword">struct</span> File *f, <span class="type">uint32_t</span> filebno, <span class="type">uint32_t</span> **ppdiskbno, <span class="type">bool</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filebno &gt;= NDIRECT + NINDIRECT)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> (filebno &lt; NDIRECT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ppdiskbno)</span><br><span class="line">            *ppdiskbno = f-&gt;f_direct + filebno;</span><br><span class="line">         <span class="comment">//把f-&gt;f_direct第filebno个槽的地址给它</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!alloc &amp;&amp; !f-&gt;f_indirect)</span><br><span class="line">        <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">    <span class="keyword">if</span> (!f-&gt;f_indirect) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">        f-&gt;f_indirect = r;</span><br><span class="line">        <span class="built_in">memset</span>(diskaddr(r), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">        flush_block(diskaddr(r));</span><br><span class="line">        <span class="comment">//每次对磁盘映射区域的块修改后都应该刷新回磁盘</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//捋一下，现在我们要的是存着f第filebno块块号的那个槽的地址</span></span><br><span class="line">	<span class="comment">//即f-&gt;f_indirect与f-&gt;f_direct都是存着块号，而*ppdiskbno要的是存着块号的那个槽的地址</span></span><br><span class="line">	   </span><br><span class="line">    <span class="keyword">if</span> (ppdiskbno)</span><br><span class="line">        *ppdiskbno = (<span class="type">uint32_t</span>*)diskaddr(f-&gt;f_indirect) + filebno - NDIRECT;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>file_get_block</code>函数先调用<code>file_walk_block</code>函数找到文件中的目标块，然后将其转换为地址空间中的地址赋值给<code>blk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">file_get_block</span><span class="params">(<span class="keyword">struct</span> File *f, <span class="type">uint32_t</span> filebno, <span class="type">char</span> **blk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">uint32_t</span> *ppdiskbno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ppdiskbno, <span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="comment">//ppdiskbno是f的第filebno块的块号所在的槽的地址</span></span><br><span class="line">	<span class="comment">//blk要的是这个块映射到内存里的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*ppdiskbno == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//就算是直接块也是有可能还未分配</span></span><br><span class="line">        <span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">        *ppdiskbno = r;</span><br><span class="line">        <span class="built_in">memset</span>(diskaddr(r), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">        flush_block(diskaddr(r));</span><br><span class="line">        <span class="comment">//每次对磁盘映射区域的块修改后都应该刷新回磁盘</span></span><br><span class="line">    &#125;</span><br><span class="line">    *blk = diskaddr(*ppdiskbno);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h3><p>既然我们已经在文件系统environment本身中拥有了必要的功能，那么我们必须让希望使用文件系统的其他environment也可以访问它。由于其他environment不能直接调用文件系统environment中的函数，所以我们将通过构建在JOS IPC机制之上的remote procedure call(远程过程调用)或者RPC、抽象来公开对文件系统环境的访问。从图形上看，下面是其他environment对 the file system server (比如read)的调用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	  Regular env           FS env</span><br><span class="line">   +---------------+   +---------------+</span><br><span class="line">   |      read     |   |   file_read   |</span><br><span class="line">   |   (lib/fd.c)  |   |   (fs/fs.c)   |</span><br><span class="line">...|.......|.......|...|.......^.......|...............</span><br><span class="line">   |       v       |   |       |       | RPC mechanism</span><br><span class="line">   |  devfile_read |   |  serve_read   |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |     fsipc     |   |     serve     |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |   ipc_send    |   |   ipc_recv    |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   +-------|-------+   +-------|-------+</span><br><span class="line">           |                   |</span><br><span class="line">           +---------&gt;---------+</span><br></pre></td></tr></table></figure></p>
<p>在虚线下的部分是普通进程如何发送一个读请求到文件系统服务进程的机制。首先<code>read</code>操作文件描述符，分发给合适的设备读函数<code>devfile_read</code>。<code>devfile_read</code>函数实现读取磁盘文件，作为客户端文件操作函数。然后建立请求结构的参数，调用<code>fsipc</code>函数来发送IPC请求并解析返回的结果。</p>
<p>文件系统服务端的代码在<code>fs/serv.c</code>中，服务进程在serve函数中循环，循环等待直到收到1个IPC请求。然后分发给合适的处理函数，最后通过IPC发回结果。对于读请求，服务端会分发给<code>serve_read</code>函数</p>
<p>在JOS实现的IPC机制中，允许进程发送1个32位数和1个页。为了实现发送1个请求从客户端到服务端，我们使用32位数来表示请求类型，存储参数在联合<code>Fsipc</code>位于共享页中。在客户端我们一直共享<code>fsipcbuf</code>所在页，在服务端我们映射请求页到<code>fsreq</code>地址(0x0ffff000)。</p>
<p>服务端也会通过IPC发送结果。我们使用32位数作为函数的返回码。<code>FSREQ_READ</code>和<code>FSREQ_STAT</code>函数也会返回数据，它们将数据写入共享页返回给客户端。不需要在响应 IPC 中发送此页面，因为客户端首先与文件系统服务器共享它。 此外，在其响应中，<code>FSREQ_OPEN</code>与客户端共享一个新的“Fd页面”。 我们将很快返回到文件描述符页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Fsipc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">        <span class="type">int</span> req_omode;</span><br><span class="line">    &#125; open;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_set_size</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> req_fileid;</span><br><span class="line">        <span class="type">off_t</span> req_size;</span><br><span class="line">    &#125; set_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> req_fileid;</span><br><span class="line">        <span class="type">size_t</span> req_n;</span><br><span class="line">    &#125; read;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> ret_buf[PGSIZE];</span><br><span class="line">    &#125; readRet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_write</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> req_fileid;</span><br><span class="line">        <span class="type">size_t</span> req_n;</span><br><span class="line">        <span class="type">char</span> req_buf[PGSIZE - (<span class="keyword">sizeof</span>(<span class="type">int</span>) + <span class="keyword">sizeof</span>(<span class="type">size_t</span>))];</span><br><span class="line">    &#125; write;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_stat</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> req_fileid;</span><br><span class="line">    &#125; stat;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsret_stat</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> ret_name[MAXNAMELEN];</span><br><span class="line">        <span class="type">off_t</span> ret_size;</span><br><span class="line">        <span class="type">int</span> ret_isdir;</span><br><span class="line">    &#125; statRet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_flush</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> req_fileid;</span><br><span class="line">    &#125; flush;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">    &#125; remove;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure Fsipc is one page</span></span><br><span class="line">    <span class="type">char</span> _pad[PGSIZE];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里需要了解一下<code>union Fsipc</code>，文件系统中客户端和服务端通过IPC进行通信，通信的数据格式就是<code>union Fsipc</code>，它里面的每一个成员对应一种文件系统的操作请求。每次客户端发来请求，都会将参数放入一个<code>union Fsipc</code>映射的物理页到服务端。同时服务端还会将处理后的结果放入到<code>Fsipc</code>内，传递给客户端。文件服务端进行的地址空间布局如下：<br><img src="/img/20211128114305.png" alt=""></p>
<p><code>OpenFile</code>结构是服务端进程维护的一个映射，它将一个真实文件<code>struct File</code>和用户客户端打开的文件描述符<code>struct Fd</code>对应到一起。每个被打开文件对应的<code>struct Fd</code>都被映射到<code>FILEEVA(0xd0000000)</code>往上的1个物理页，服务端和打开这个文件的客户端进程共享这个物理页。客户端进程和文件系统服务端通信时使用<code>0_fileid</code>来指定要操作的文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> o_fileid;      <span class="comment">// file id</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>    <span class="comment">// mapped descriptor for open file</span></span><br><span class="line">        <span class="type">int</span> o_mode;             <span class="comment">// open mode</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">o_fd</span>;</span>        <span class="comment">// Fd page</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>文件系统默认最大同时可以打开的文件个数为1024，所以有1024个<code>strcut Openfile</code>，对应着服务端进程地址空间0xd0000000往上的1024个物理页，用于映射这些对应的<code>struct Fd</code>。</p>
<p><code>struct Fd</code>是1个抽象层，JOS和Linux一样，所有的IO都是文件，所以用户看到的都是<code>Fd</code>代表的文件。但是<code>Fd</code>会记录其对应的具体对象，比如真实文件、Socket和管道等等。现在只用文件，所以union中只有1个<code>FdFile</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd_dev_id;</span><br><span class="line">    <span class="type">off_t</span> fd_offset;</span><br><span class="line">    <span class="type">int</span> fd_omode;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">// File server files</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">FdFile</span> <span class="title">fd_file</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Exercise 5.在<code>fs/servlet.c</code>中实现<code>serve_read</code>。<code>serve_read</code>的繁重工作将由<code>fs/fs.c</code>中已经实现的<code>file_read</code>来完成(反过来，它只是对<code>file_get_block</code>的一系列调用)。<code>serve_read</code>只需要提供用于文件读取的RPC接口。查看<code>serve_set_size</code>中的注释和代码，了解应该如何构造<code>server</code>函数。</p>
<p>做这个得弄清楚这些概念:</p>
<ul>
<li><code>regular</code>进程访问文件的整个流程。</li>
<li>在IPC通信过程中，<code>fsipcbuf</code>(客户端)与<code>fsreq</code>(服务端)共享页面。</li>
<li>保存着open file基本信息的<code>Fd page</code>页面(在内存空间0xD0000000以上)</li>
<li>服务端的私有结构体<code>OpenFile</code></li>
<li>设备结构体<code>dev</code>，设备有三种，devfile、devpipe、devcons</li>
<li><code>OpenFile-&gt;o_fileid</code>跟<code>OpenFile-&gt;o_fd-&gt;fd_file.id</code>以及<code>Fsipc-&gt;read-&gt;req_fileid</code>的关系!</li>
</ul>
<p>在<code>devfile_read()</code>里，<code>fsipcbuf.read.req_fileid = fd-&gt;fd_file.id;</code>这是客户端根据在0xD0000000以上的第<code>fdnum</code>个<code>fd page</code>的<code>fd-&gt;fd_file.id</code>告诉服务器端要读的是id为这个的文件。</p>
<p>在<code>serve_open()</code>里，<code>o-&gt;o_fd-&gt;fd_file.id = o-&gt;o_fileid;</code>这是服务器端将open file与它的Fd page对应起来。</p>
<p>首先来看一下整个read的流程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inc/fd.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd_dev_id;</span><br><span class="line">	<span class="type">off_t</span> fd_offset;</span><br><span class="line">	<span class="type">int</span> fd_omode;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">// File server files</span></span><br><span class="line">		<span class="comment">// 这应该就是目标文件id，在客户端赋值给了fsipcbuf.read.req_fileid</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">FdFile</span> <span class="title">fd_file</span>;</span> <span class="comment">//struct FdFile &#123;int id; &#125;;</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fs/serv.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> &#123;</span> </span><br><span class="line">    <span class="comment">//This memory is kept private to the file server.</span></span><br><span class="line">	<span class="type">uint32_t</span> o_fileid;	<span class="comment">// file id。 The client uses file IDs to communicate with the server.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span>	<span class="comment">// mapped descriptor for open file应该是打开的那个文件的file pointer</span></span><br><span class="line">	<span class="type">int</span> o_mode;		<span class="comment">// open mode</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">o_fd</span>;</span>	<span class="comment">// Fd page是一个专门记录着这个open file的基本信息的页面</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inc/fs.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> f_name[MAXNAMELEN];	<span class="comment">// filename</span></span><br><span class="line">	<span class="type">off_t</span> f_size;			<span class="comment">// file size in bytes</span></span><br><span class="line">	<span class="type">uint32_t</span> f_type;		<span class="comment">// file type</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block pointers.</span></span><br><span class="line">	<span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line">	<span class="comment">// 这里存的是块号还是块的地址？</span></span><br><span class="line">	<span class="type">uint32_t</span> f_direct[NDIRECT];	<span class="comment">// direct blocks</span></span><br><span class="line">	<span class="type">uint32_t</span> f_indirect;		<span class="comment">// indirect block</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pad out to 256 bytes; must do arithmetic in case we&#x27;re compiling</span></span><br><span class="line">	<span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line">	<span class="comment">// 扩展到256字节;必须做算术，以防我们在64位机器上编译fsformat。</span></span><br><span class="line">	<span class="type">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">&#125; __attribute__((packed));	<span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></table></figure></p>
<p><code>lib/fd.c/read()</code>根据<code>fdnum</code>在内存空间0xD0000000以上找到一个<code>struct Fd</code>页面命名为<code>fd</code>，页面内保存着一个open file的基本信息。然后根据<code>fd</code>内的<code>fd_dev_id</code>找到对应设备<code>dev</code>，很明显这里是<code>devfile</code>，然后调用<code>(*devfile-&gt;dev_read)(fd, buf, n)</code>。该函数返回读到的字节总数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span></span><br><span class="line">	    || (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_WRONLY) &#123;</span><br><span class="line">		cprintf(<span class="string">&quot;[%08x] read %d -- bad mode\n&quot;</span>, thisenv-&gt;env_id, fdnum);</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;dev_read)</span><br><span class="line">		<span class="keyword">return</span> -E_NOT_SUPP;</span><br><span class="line">	<span class="keyword">return</span> (*dev-&gt;dev_read)(fd, buf, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>lib/file.c/devfile_read()</code>通过IPC共享的页面上的<code>union Fsipc</code>中存储请求的参数。在客户端，我们总是在<code>fsipcbuf</code>共享页面。设置好<code>fsipcbuf</code>的参数，调用<code>fsipc</code>去向服务器端发送<code>read</code>请求。请求成功后结果也是保存在共享页面<code>fsipcbuf</code>中，然后读到指定的<code>buf</code>就行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">devfile_read</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Make an FSREQ_READ request to the file system server after</span></span><br><span class="line">	<span class="comment">// filling fsipcbuf.read with the request arguments.  The</span></span><br><span class="line">	<span class="comment">// bytes read will be written back to fsipcbuf by the file</span></span><br><span class="line">	<span class="comment">// system server.</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	fsipcbuf.read.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">    <span class="comment">//这个id就是指的当前位置？current position？</span></span><br><span class="line">	fsipcbuf.read.req_n = n;</span><br><span class="line">	<span class="keyword">if</span> ((r = fsipc(FSREQ_READ, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	assert(r &lt;= n);</span><br><span class="line">	assert(r &lt;= PGSIZE);</span><br><span class="line">	memmove(buf, fsipcbuf.readRet.ret_buf, r);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>lib/file.c/fsipc()</code>这个函数就是负责跟文件系统<code>server</code>进程间通信的。发送请求并接受结果。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fsipc</span><span class="params">(<span class="type">unsigned</span> type, <span class="type">void</span> *dstva)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">envid_t</span> fsenv;</span><br><span class="line">	<span class="keyword">if</span> (fsenv == <span class="number">0</span>)</span><br><span class="line">		fsenv = ipc_find_env(ENV_TYPE_FS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(fsipcbuf) == PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (debug)</span><br><span class="line">		cprintf(<span class="string">&quot;[%08x] fsipc %d %08x\n&quot;</span>, thisenv-&gt;env_id, type, *(<span class="type">uint32_t</span> *)&amp;fsipcbuf);</span><br><span class="line"></span><br><span class="line">	ipc_send(fsenv, type, &amp;fsipcbuf, PTE_P | PTE_W | PTE_U);</span><br><span class="line">	<span class="keyword">return</span> ipc_recv(<span class="literal">NULL</span>, dstva, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>fs/serv.c/serve()</code>中<code>ipc_recv</code>的返回值是32位字<code>env_ipc_value</code>，即<code>fsipc</code>里<code>ipc_send</code>过来的<code>type</code>，根据这个<code>type</code>判断进入哪个处理函数，这里很明显<code>type==FSREQ_READ</code>。</p>
<ol>
<li>从IPC接受1个请求类型<code>req</code>以及数据页<code>fsreq</code></li>
<li>然后根据<code>req</code>来执行相应的服务端处理函数</li>
<li>将相应服务端函数的执行结果(如果产生了数据也则有pg)通过IPC发送回调用进程</li>
<li>将映射好的物理页<code>fsreq</code>取消映射</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> req, whom;</span><br><span class="line">	<span class="type">int</span> perm, r;</span><br><span class="line">	<span class="type">void</span> *pg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		perm = <span class="number">0</span>;</span><br><span class="line">		req = ipc_recv((<span class="type">int32_t</span> *) &amp;whom, fsreq, &amp;perm);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// All requests must contain an argument page</span></span><br><span class="line">		<span class="keyword">if</span> (!(perm &amp; PTE_P)) &#123;</span><br><span class="line">			cprintf(<span class="string">&quot;Invalid request from %08x: no argument page\n&quot;</span>,</span><br><span class="line">				whom);</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">// just leave it hanging...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		pg = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (req == FSREQ_OPEN) &#123;</span><br><span class="line">			r = serve_open(whom, (<span class="keyword">struct</span> Fsreq_open*)fsreq, &amp;pg, &amp;perm);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req &lt; ARRAY_SIZE(handlers) &amp;&amp; handlers[req]) &#123;</span><br><span class="line">			r = handlers[req](whom, fsreq);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cprintf(<span class="string">&quot;Invalid request code %d from %08x\n&quot;</span>, req, whom);</span><br><span class="line">			r = -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		ipc_send(whom, r, pg, perm);</span><br><span class="line">		sys_page_unmap(<span class="number">0</span>, fsreq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端函数定义在handler数组，通过请求号进行调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*fshandler)</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">union</span> Fsipc *req)</span>;</span><br><span class="line"></span><br><span class="line">fshandler handlers[] = &#123;</span><br><span class="line">    <span class="comment">// Open is handled specially because it passes pages</span></span><br><span class="line">    <span class="comment">/* [FSREQ_OPEN] =       (fshandler)serve_open, */</span></span><br><span class="line">    [FSREQ_READ] =          serve_read,</span><br><span class="line">    [FSREQ_STAT] =          serve_stat,</span><br><span class="line">    [FSREQ_FLUSH] =         (fshandler)serve_flush,</span><br><span class="line">    [FSREQ_WRITE] =         (fshandler)serve_write,</span><br><span class="line">    [FSREQ_SET_SIZE] =      (fshandler)serve_set_size,</span><br><span class="line">    [FSREQ_SYNC] =          serve_sync</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NHANDLERS (sizeof(handlers)/sizeof(handlers[0]))</span></span><br></pre></td></tr></table></figure></p>
<p>这个结构体定义了一些函数指针，做题的时候需要注意。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">        .dev_id =       <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">        .dev_name =     <span class="string">&quot;file&quot;</span>,</span><br><span class="line">        .dev_read =     devfile_read,</span><br><span class="line">        .dev_close =    devfile_flush,</span><br><span class="line">        .dev_stat =     devfile_stat,</span><br><span class="line">        .dev_write =    devfile_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于读文件请求，调用<code>serve_read</code>函数来处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">serve_read</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">union</span> Fsipc *ipc)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> *<span class="title">req</span> =</span> &amp;ipc-&gt;read;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> *<span class="title">ret</span> =</span> &amp;ipc-&gt;readRet;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debug)</span><br><span class="line">                cprintf(<span class="string">&quot;serve_read %08x %08x %08x\n&quot;</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">        <span class="type">int</span> r, req_n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        req_n = req-&gt;req_n &gt; PGSIZE ? PGSIZE : req-&gt;req_n;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_read(o-&gt;o_file, ret-&gt;ret_buf, req_n, o-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先从<code>Fsipc</code>中获取读请求的结构体，然后在<code>openfile</code>中查找<code>fileid</code>对应的<code>Openfile</code>结构体，紧接着从<code>openfile</code>长相的<code>o_file</code>中读取内容到保存返回结果的<code>ret_buf</code>中，并移动文件偏移指针。</p>
<p>然后我们可以看一下用户进程发送读取请求的函数<code>devfile_read</code>，主要操作是封装<code>Fsipc</code>设置请求类型为<code>FSREQ_READ</code>，在接受到返回后，将返回结果拷贝到自己的<code>buf</code>中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">devfile_read</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">        fsipcbuf.read.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">        fsipcbuf.read.req_n = n;</span><br><span class="line">        <span class="keyword">if</span> ((r = fsipc(FSREQ_READ, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        assert(r &lt;= n);</span><br><span class="line">        assert(r &lt;= PGSIZE);</span><br><span class="line">        memmove(buf, fsipcbuf.readRet.ret_buf, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Exercise 6.在<code>fs/server.c</code>中实现<code>serve_write</code>，在<code>lib/file.c</code>中实现<code>devfile_write</code>。实现与read请求类似。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fs/serv.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">serve_write</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">struct</span> Fsreq_write *req)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (debug)</span><br><span class="line">                cprintf(<span class="string">&quot;serve_write %08x %08x %08x\n&quot;</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">        <span class="type">int</span> r, req_n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;o)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        req_n = req-&gt;req_n &gt; PGSIZE ? PGSIZE : req-&gt;req_n;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_write(o-&gt;o_file, req-&gt;req_buf, req_n, o-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib/file.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">devfile_write</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="keyword">sizeof</span>(fsipcbuf.write.req_buf))</span><br><span class="line">                n = <span class="keyword">sizeof</span>(fsipcbuf.write.req_buf);</span><br><span class="line">        fsipcbuf.write.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">        fsipcbuf.write.req_n = n;</span><br><span class="line">        memmove(fsipcbuf.write.req_buf, buf, n);</span><br><span class="line">        <span class="keyword">if</span> ((r = fsipc(FSREQ_WRITE, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spawning-Processes-衍生程序，派生程序"><a href="#Spawning-Processes-衍生程序，派生程序" class="headerlink" title="Spawning Processes(衍生程序，派生程序)"></a>Spawning Processes(衍生程序，派生程序)</h3><p>我们已经给出了<code>spawn</code>的代码(参见<code>lib/spawn.c</code>)，它创建一个新环境，从文件系统加载一个程序映像到其中，然后启动运行这个程序的子环境。然后父进程继续独立于子进程运行。<code>spawn</code>函数的作用类似于UNIX中的fork，然后在子进程中立即执行exec。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spawn a child process from a program image loaded from the file system.</span></span><br><span class="line"><span class="comment">// prog: the pathname of the program to run.</span></span><br><span class="line"><span class="comment">// argv: pointer to null-terminated array of pointers to strings,</span></span><br><span class="line"><span class="comment">//       which will be passed to the child as its command-line arguments.</span></span><br><span class="line"><span class="comment">// Returns child envid on success, &lt; 0 on failure.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">spawn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *prog, <span class="type">const</span> <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> elf_buf[<span class="number">512</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">child_tf</span>;</span></span><br><span class="line">    <span class="type">envid_t</span> child;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd, i, r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>;</span></span><br><span class="line">    <span class="type">int</span> perm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This code follows this procedure:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Open the program file.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Read the ELF header, as you have before, and sanity check its</span></span><br><span class="line">    <span class="comment">//     magic number.  (Check out your load_icode!)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Use sys_exofork() to create a new environment.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Set child_tf to an initial struct Trapframe for the child.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Call the init_stack() function above to set up</span></span><br><span class="line">    <span class="comment">//     the initial stack page for the child environment.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Map all of the program&#x27;s segments that are of p_type</span></span><br><span class="line">    <span class="comment">//     ELF_PROG_LOAD into the new environment&#x27;s address space.</span></span><br><span class="line">    <span class="comment">//     Use the p_flags field in the Proghdr for each segment</span></span><br><span class="line">    <span class="comment">//     to determine how to map the segment:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//      * If the ELF flags do not include ELF_PROG_FLAG_WRITE,</span></span><br><span class="line">    <span class="comment">//    then the segment contains text and read-only data.</span></span><br><span class="line">    <span class="comment">//    Use read_map() to read the contents of this segment,</span></span><br><span class="line">    <span class="comment">//    and map the pages it returns directly into the child</span></span><br><span class="line">    <span class="comment">//    so that multiple instances of the same program</span></span><br><span class="line">    <span class="comment">//    will share the same copy of the program text.</span></span><br><span class="line">    <span class="comment">//    Be sure to map the program text read-only in the child.</span></span><br><span class="line">    <span class="comment">//    Read_map is like read but returns a pointer to the data in</span></span><br><span class="line">    <span class="comment">//    *blk rather than copying the data into another buffer.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//      * If the ELF segment flags DO include ELF_PROG_FLAG_WRITE,</span></span><br><span class="line">    <span class="comment">//    then the segment contains read/write data and bss.</span></span><br><span class="line">    <span class="comment">//    As with load_icode() in Lab 3, such an ELF segment</span></span><br><span class="line">    <span class="comment">//    occupies p_memsz bytes in memory, but only the FIRST</span></span><br><span class="line">    <span class="comment">//    p_filesz bytes of the segment are actually loaded</span></span><br><span class="line">    <span class="comment">//    from the executable file - you must clear the rest to zero.</span></span><br><span class="line">    <span class="comment">//    For each page to be mapped for a read/write segment,</span></span><br><span class="line">    <span class="comment">//    allocate a page in the parent temporarily at UTEMP,</span></span><br><span class="line">    <span class="comment">//    read() the appropriate portion of the file into that page</span></span><br><span class="line">    <span class="comment">//    and/or use memset() to zero non-loaded portions.</span></span><br><span class="line">    <span class="comment">//    (You can avoid calling memset(), if you like, if</span></span><br><span class="line">    <span class="comment">//    page_alloc() returns zeroed pages already.)</span></span><br><span class="line">    <span class="comment">//    Then insert the page mapping into the child.</span></span><br><span class="line">    <span class="comment">//    Look at init_stack() for inspiration.</span></span><br><span class="line">    <span class="comment">//    Be sure you understand why you can&#x27;t use read_map() here.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//     Note: None of the segment addresses or lengths above</span></span><br><span class="line">    <span class="comment">//     are guaranteed to be page-aligned, so you must deal with</span></span><br><span class="line">    <span class="comment">//     these non-page-aligned values appropriately.</span></span><br><span class="line">    <span class="comment">//     The ELF linker does, however, guarantee that no two segments</span></span><br><span class="line">    <span class="comment">//     will overlap on the same page; and it guarantees that</span></span><br><span class="line">    <span class="comment">//     PGOFF(ph-&gt;p_offset) == PGOFF(ph-&gt;p_va).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Call sys_env_set_trapframe(child, &amp;child_tf) to set up the</span></span><br><span class="line">    <span class="comment">//     correct initial eip and esp values in the child.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//   - Start the child process running with sys_env_set_status().</span></span><br><span class="line">    <span class="keyword">if</span> ((r = open(prog, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    fd = r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read elf header</span></span><br><span class="line">    elf = (<span class="keyword">struct</span> Elf*) elf_buf;</span><br><span class="line">    <span class="keyword">if</span> (readn(fd, elf_buf, <span class="keyword">sizeof</span>(elf_buf)) != <span class="keyword">sizeof</span>(elf_buf) || elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        cprintf(<span class="string">&quot;elf magic %08x want %08x\n&quot;</span>, elf-&gt;e_magic, ELF_MAGIC);</span><br><span class="line">        <span class="keyword">return</span> -E_NOT_EXEC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create new child environment</span></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_exofork()) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    child = r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up trap frame, including initial stack.</span></span><br><span class="line">    child_tf = envs[ENVX(child)].env_tf;</span><br><span class="line">    child_tf.tf_eip = elf-&gt;e_entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = init_stack(child, argv, &amp;(child_tf.tf_esp))) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up program segments as defined in ELF header.</span></span><br><span class="line">    ph = (<span class="keyword">struct</span> Proghdr*) (elf_buf + elf-&gt;e_phoff);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elf-&gt;e_phnum; i++, ph++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PROG_LOAD)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        perm = PTE_P | PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PROG_FLAG_WRITE)</span><br><span class="line">            perm |= PTE_W;</span><br><span class="line">        <span class="keyword">if</span> ((r = map_segment(child, ph-&gt;p_va, ph-&gt;p_memsz, fd, ph-&gt;p_filesz, ph-&gt;p_offset, perm)) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy shared library state.</span></span><br><span class="line">    <span class="keyword">if</span> ((r = copy_shared_pages(child)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;copy_shared_pages: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_env_set_trapframe(child, &amp;child_tf)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;sys_env_set_trapframe: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = sys_env_set_status(child, ENV_RUNNABLE)) &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;sys_env_set_status: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    sys_env_destroy(child);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们实现了<code>spawn</code>而不是unix风格的exec，因为spawn更容易从用户空间以“exokernel fashion”(一种方式)实现，而不需要内核的特殊帮助。考虑一下要在用户空间中实现exec需要做些什么，并确保您理解为什么这么做更难些。</p>
<p>Exercise 7. 依赖于新的系统调用<code>sys_env_set_trapframe</code>来初始化新创建环境的状态的<code>spawn</code>。在<code>kern/syscall.c</code>中实现<code>sys_env_set_trapframe</code>(不要忘记在<code>syscall()</code>中添加新的系统调用的分派)。</p>
<p><code>sys_env_set_trapframe</code>函数实现简单，主要是用来拷贝父进程的寄存器。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_trapframe</span><span class="params">(<span class="type">envid_t</span> envid, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = envid2env(envid, &amp;e, <span class="literal">true</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    user_mem_assert(e, tf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe), PTE_U);</span><br><span class="line">    e-&gt;env_tf = *tf;</span><br><span class="line">    e-&gt;env_tf.tf_cs |= <span class="number">3</span>;</span><br><span class="line">    e-&gt;env_tf.tf_eflags |= FL_IF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h3><p>UNIX文件描述符是一个通用的概念，它还包括pipes, console I/O等。在JOS中，每种设备类型都有一个对应的<code>struct Dev</code>，带有指向为该类型实现的read/write等函数的指针。<code>lib/fd.c</code>在此基础上实现了通用的类unix文件描述符接口。每个<code>struct Fd</code>都指示其设备类型，<code>lib/fd.c</code>中的大多数函数只是简单地将操作分派给适当<code>struct Dev</code>中的函数。</p>
<p><code>lib/fd.c</code>还在每个应用程序环境的地址空间中维护从<code>FDTABLE(0xD0000000)</code>开始的 file descriptor table region。在这个区域每个<code>struct Fd</code>都保留着一个页。在任何给定时间，只有在使用相应的文件描述符时才映射特定的文件描述符表页。每个文件描述符在从FILEDATA开始的区域中都有一个可选的“data page”，设备可以使用这些“data page”。</p>
<p>我们希望跨<code>fork</code>和<code>spawn</code>共享文件描述符状态，但是文件描述符状态保存在用户空间内存中。而且在fork时，内存将被标记为copy-on-write，因此状态将被复制而不是共享。(这意味着环境无法在自己没有打开的文件中进行查找，而且管道也不能跨fork工作)。在<code>spawn</code>时，内存将被留在后面，根本不复制。(实际上，派生的环境一开始没有打开的文件描述符)</p>
<p>我们将更改<code>fork</code>，以确定“library operating system”使用的内存区域应该总是共享的。我们将在页表条目中设置一个未使用的位，而不是在某个地方hard-code(硬编码)一个区域列表(就像我们在<code>fork</code>中使用PTE_COW位一样)。</p>
<p>我们在<code>inc/lib.h</code>中定义了一个新的<code>PTE_SHARE</code>位。这个位是三个PTE位之一，在 Intel and AMD manuals中被标记为“available for software use”。我们将建立这样一个约定:如果页表条目设置了这个位，那么PTE应该在<code>fork</code>和<code>spawn</code>时从父环境直接复制到子环境。注意，这与标记为copy-on-write不同：如第一段所述，我们希望确保共享页面的更新。</p>
<p>Exercise 8：改变<code>duppage</code>函数实现上述变化，如果页表入口有设置<code>PTE_SHARE</code>位，那么直接拷贝映射。类似地，实现<code>copy_shared_pages</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">duppage</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">unsigned</span> pn)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *addr;</span><br><span class="line">    <span class="type">pte_t</span> pte;</span><br><span class="line">    <span class="type">int</span> perm;</span><br><span class="line"></span><br><span class="line">    addr = (<span class="type">void</span> *)((<span class="type">uint32_t</span>)pn * PGSIZE);</span><br><span class="line">    pte = uvpt[pn];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_SHARE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(sys_getenvid(), addr, envid, addr, pte &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            panic(<span class="string">&quot;duppage: page mapping failed %e&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        perm = PTE_P | PTE_U;</span><br><span class="line">        <span class="keyword">if</span> ((pte &amp; PTE_W) || (pte &amp; PTE_COW))</span><br><span class="line">            perm |= PTE_COW;</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(thisenv-&gt;env_id, addr, envid, addr, perm)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;duppage: page remapping failed %e&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (perm &amp; PTE_COW) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r = sys_page_map(thisenv-&gt;env_id, addr, thisenv-&gt;env_id, addr, perm)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                panic(<span class="string">&quot;duppage: page remapping failed %e&quot;</span>, r);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>copy_shared_pages</code>应该循环遍历当前进程中的所有页表条目(就像fork所做的那样)，将设置了<code>PTE_SHARE</code>位的任何页映射复制到子进程中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">copy_shared_pages</span><span class="params">(<span class="type">envid_t</span> child)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="type">int</span> r,i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PGNUM(USTACKTOP); i ++)&#123; </span><br><span class="line">	<span class="comment">// uvpd、uvpt应该是个全局数组变量，</span></span><br><span class="line">    <span class="comment">// 但是数组元素对应的pde、pte具体是什么应该取决于lcr3设置的是哪个环境的内存空间</span></span><br><span class="line">		<span class="keyword">if</span>((uvpd[i/<span class="number">1024</span>] &amp; PTE_P) &amp;&amp; (uvpt[i] &amp; PTE_P) &amp;&amp; (uvpt[i] &amp; PTE_SHARE))&#123; </span><br><span class="line">            <span class="comment">//i跟pte一一对应，而i/1024就是该pte所在的页表</span></span><br><span class="line">			<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, PGADDR(i/<span class="number">1024</span>, i%<span class="number">1024</span>, <span class="number">0</span>), child, PGADDR(i/<span class="number">1024</span>, i%<span class="number">1024</span>, <span class="number">0</span>), uvpt[i] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要让shell工作，我们需要一种方法来键入它。QEMU一直在显示我们写入到CGA显示器和串行端口的输出，但到目前为止，我们只在内核监视器中接受输入。在QEMU中，在图形化窗口中键入的输入显示为从键盘到JOS的输入，而在控制台中键入的输入显示为串行端口上的字符。<code>kern/console.c</code>已经包含了自lab 1以来内核监视器一直使用的键盘和串行驱动程序，但是现在您需要将它们附加到系统的其他部分。</p>
<p>Exercise 9. 在你的<code>kern/trap.c</code>，调用<code>kbd_intr</code>处理<code>trap IRQ_OFFSET+IRQ_KBD</code>，调用<code>serial_intr</code>处理<code>trap IRQ_OFFSET+IRQ_SERIAL</code>。</p>
<p>我们在<code>lib/console.c</code>中为您实现了控制台输入/输出文件类型。<code>kbd_intr</code>和<code>serial_intr</code>用最近读取的输入填充缓冲区，而控制台文件类型耗尽缓冲区(控制台文件类型默认用于<code>stdin/stdout</code>，除非用户重定向它们)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kern/trap.c/trap_dispatch()</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_KBD)&#123;</span><br><span class="line">	kbd_intr();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_SERIAL)&#123;</span><br><span class="line">	serial_intr();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>稍微看一下这两个函数。<code>kbd_proc_data()</code>是从键盘读入character就返回，如果没输入就返回-1<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kbd_intr</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    cons_intr(kbd_proc_data);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//serial_proc_data()很明显就是从串行端口读一个data</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serial_intr</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (serial_exists)</span><br><span class="line">		cons_intr(serial_proc_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个函数都调用下边这个<code>cons_intr</code>，这个函数就是从键盘读入的一行填充到<code>cons.buf</code>。而<code>cons</code>如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">uint8_t</span> buf[CONSBUFSIZE];</span><br><span class="line">        <span class="type">uint32_t</span> rpos;</span><br><span class="line">        <span class="type">uint32_t</span> wpos;</span><br><span class="line">&#125; cons;</span><br></pre></td></tr></table></figure></p>
<p>当函数指针所接收到的数据不为-1时，把收到的数据加入到buf中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cons_intr</span><span class="params">(<span class="type">int</span> (*proc)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((c = (*proc)()) != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		cons.buf[cons.wpos++] = c;</span><br><span class="line">		<span class="keyword">if</span> (cons.wpos == CONSBUFSIZE)</span><br><span class="line">			cons.wpos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与<code>kbd_intr</code>有关的是下边这个函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get data from the keyboard.  If we finish a character, return it.  Else 0.</span></span><br><span class="line"><span class="comment"> * Return -1 if no data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">kbd_proc_data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="type">uint8_t</span> data;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> shift;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((inb(KBSTATP) &amp; KBS_DIB) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    data = inb(KBDATAP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="number">0xE0</span>) &#123;</span><br><span class="line">        <span class="comment">// E0 escape character</span></span><br><span class="line">        shift |= E0ESC;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">        <span class="comment">// Key released</span></span><br><span class="line">        data = (shift &amp; E0ESC ? data : data &amp; <span class="number">0x7F</span>);</span><br><span class="line">        shift &amp;= ~(shiftcode[data] | E0ESC);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shift &amp; E0ESC) &#123;</span><br><span class="line">        <span class="comment">// Last character was an E0 escape; or with 0x80</span></span><br><span class="line">        data |= <span class="number">0x80</span>;</span><br><span class="line">        shift &amp;= ~E0ESC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shift |= shiftcode[data];</span><br><span class="line">    shift ^= togglecode[data];</span><br><span class="line"></span><br><span class="line">    c = charcode[shift &amp; (CTL | SHIFT)][data];</span><br><span class="line">    <span class="keyword">if</span> (shift &amp; CAPSLOCK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            c += <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">            c += <span class="string">&#x27;a&#x27;</span> - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process special keys</span></span><br><span class="line">    <span class="comment">// Ctrl-Alt-Del: reboot</span></span><br><span class="line">    <span class="keyword">if</span> (!(~shift &amp; (CTL | ALT)) &amp;&amp; c == KEY_DEL) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;Rebooting!\n&quot;</span>);</span><br><span class="line">        outb(<span class="number">0x92</span>, <span class="number">0x3</span>); <span class="comment">// courtesy of Chris Frost</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h2><p>运行<code>make run-icode</code>或者<code>make run-icode-nox</code>。这将运行内核并启动<code>user/icode</code>。<code>icode</code>执行<code>init</code>，它将把控制台设置为文件描述符0和1(标准输入和标准输出)。然后它会<code>spawn sh</code>，也就是<code>shell</code>。你应该能够运行以下命令:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello world | <span class="built_in">cat</span></span><br><span class="line"><span class="built_in">cat</span> lorem |<span class="built_in">cat</span></span><br><span class="line"><span class="built_in">cat</span> lorem |num</span><br><span class="line"><span class="built_in">cat</span> lorem |num |num |num |num |num</span><br><span class="line">lsfd</span><br></pre></td></tr></table></figure></p>
<p>注意，用户库例程cprintf直接打印到控制台，而不使用文件描述符代码。这对于调试非常有用，但是对于piping into other programs却不是很有用。要将输出打印到特定的文件描述符(例如，1，标准输出)，请使用fprintf(1, “…”, …)。 printf(“…”, …)是打印到FD 1的捷径。有关示例，请参见user/lsfd.c。</p>
<p>Exercise 10. shell不支持I/O重定向。如果能运行<code>sh &lt;script</code>就更好，而不是像上面那样手工输入<code>script</code>中的所有命令。将<code>&lt;</code>的I/O重定向添加到<code>user/sh.c</code>。通过在shell中键入<code>sh &lt;script</code>测试您的实现</p>
<p>运行<code>make run-testshell</code>来测试您的<code>shell</code>。<code>testshell</code>只是将上面的命令(也可以在<code>fs/testshell.sh</code>中找到)提供给shell，然后检查输出是否匹配<code>fs/testshell.key</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:	<span class="comment">// Input redirection</span></span><br><span class="line">	<span class="comment">// Grab the filename from the argument list</span></span><br><span class="line">	<span class="keyword">if</span> (gettoken(<span class="number">0</span>, &amp;t) != <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">		cprintf(<span class="string">&quot;syntax error: &lt; not followed by word\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> ((fd = open(t, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		cprintf(<span class="string">&quot;open %s for read: %e&quot;</span>, t, fd);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (fd != <span class="number">0</span>) &#123;</span><br><span class="line">		dup(fd, <span class="number">0</span>); <span class="comment">//应该是让文件描述符0也作为fd对应的那个open file的struct Fd页面</span></span><br><span class="line">		close(fd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//panic(&quot;&lt; redirection not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>为什么好多函数的<code>envid_t</code>参数总是设成0？在<code>envid2env()</code>函数中有这样如下定义。所以设成0就e就默认是<code>curenv</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If envid is zero, return the current environment.</span></span><br><span class="line">    <span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">        *env_store = curenv;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>Challenge的要求即为清空掉所有的没有被访问的页面。那么对于单个页面，只需要调用<code>flush_block()</code>，之后通过系统调用<code>unmap</code>就可以了。<code>evict_policy()</code>即对于所有的block做一个便利，清除所有从未被访问过的页面。具体代码内容如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// challenge</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">evict_block</span><span class="params">(<span class="type">void</span> *addr)</span>&#123;</span><br><span class="line">	<span class="type">uint32_t</span> blockno = ((<span class="type">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line">	<span class="keyword">if</span>(addr &lt; (<span class="type">void</span>*)DISKMAP || addr &gt;= (<span class="type">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">		panic(<span class="string">&quot;evict_block of bad va %08x&quot;</span>, addr);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	addr = ROUNDDOWN(addr, BLKSIZE);</span><br><span class="line">	flush_block(addr);</span><br><span class="line">	<span class="keyword">if</span>((r = sys_page_unmap(<span class="number">0</span>, addr)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;in evict block, sys_page_unmap: %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">evict_policy</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">uint32_t</span> blockno;</span><br><span class="line">	<span class="keyword">for</span>(blockno = <span class="number">3</span>; blockno &lt; DISKSIZE / BLKSIZE; ++blockno)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(uvpt[PGNUM(diskaddr(blockno))]&amp;PTE_A))&#123;</span><br><span class="line">			evict_block(diskaddr(blockno));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="lab6"><a href="#lab6" class="headerlink" title="lab6"></a>lab6</h1><h2 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h2><p>我们已经实现了1个文件系统，当然OS还需要1个网络栈，在本次实验中我们将实现1个网卡驱动，这个网卡基于Intel 82540EM芯片，也就是熟知的E1000网卡。</p>
<p>网卡驱动不足以使你的OS能连接上Internet。在LAB6新增加的代码中，我们提供了1个网络栈(network stack)和网络服务器(network server)在<code>net/</code>目录和<code>kern/</code>目录下。</p>
<p>本次新增加的文件如下：</p>
<ul>
<li><code>net/lwip</code>目录：开源轻量级TCP/IP协议组件包括1个网络栈</li>
<li><code>net/timer.c</code>：定时器功能测试程序</li>
<li><code>net/ns.h</code>：网卡驱动相关的参数宏定义和函数声明</li>
<li><code>net/testinput.c</code>：收包功能测试程序</li>
<li><code>net/input.c</code>：收包功能的用户态函数</li>
<li><code>net/testoutput.c</code>：发包功能测试程序</li>
<li><code>net/output.c</code>：发包功能的用户态函数</li>
<li><code>net/serv.c</code>：网络服务器的实现</li>
<li><code>kern/e1000.c</code>：网卡驱动的内核实现</li>
<li><code>kern/e1000.h</code>：网卡驱动实现相关的参数宏定义和函数声明</li>
</ul>
<p>除了实现网卡驱动，我们还要实现1个系统调用接口来访问驱动。我们需要实现网络服务器代码来传输网络数据包在网络栈和驱动之间。同时网络服务器也能使用文件系统中的文件。</p>
<p>大部分内核驱动代码必须从零开始编写，这次实验比前面的实验提供更少的指导：没有骨架文件、没有系统调用接口等。总之一句话，要实现这次实验需要阅读很多提供的指导说明手册，才能完成实验。</p>
<h2 id="QEMU’s-virtual-network"><a href="#QEMU’s-virtual-network" class="headerlink" title="QEMU’s virtual network"></a>QEMU’s virtual network</h2><p>我们将会使用QEMU用户态网络栈，因为它运行不需要管理员权限。</p>
<p>在默认情况下，QEMU会提供一个运行在IP为10.0.2.2的虚拟路由器并且分配给JOS一个10.0.2.15的IP地址。为了简单起见，我们把这些默认设置硬编码在了<code>net/ns.h</code>中。</p>
<p>尽管QEMU的虚拟网络允许JOS和互联网做任意的连接，但是JOS的10.0.2.15 IP地址在QEMU运行的虚拟网络之外没有任何意义(QEMU就像一个NAT)，所以我们不能直接和JOS中运行的se服务器连接，即使是运行QEMU的宿主机上也不行。为了解决这个问题，我们通过配置QEMU，让JOS的一些端口和宿主机的某些端口相连，让服务器运行在这些端口上，从而让数据在宿主机和虚拟网络之间进行交换。</p>
<p>我们将在端口7（echo）和80（http）运行端口。为了避免端口冲突，makefile里实现了端口转发。可以通过运行<code>make which-ports</code>来找出QEMU转发的端口，也可以通过<code>make nc-7</code>和<code>make nc-80</code>来和运行在这些端口上的服务器交互。</p>
<h3 id="Packet-Inspection"><a href="#Packet-Inspection" class="headerlink" title="Packet Inspection"></a>Packet Inspection</h3><p>makefile也配置了QEMU的网络栈来记录各种进入和出去的数据包到<code>qemu.pcap</code>文件中。为了获得hex/ASCII的转换，我们可以使用<code>tcpdump</code>命令(Linux下非常有用的网络抓包分析工具，具体的参数说明可以用man tcpdump)：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -XXnr qemu.pcap</span><br></pre></td></tr></table></figure></p>
<h3 id="Debugging-the-E1000"><a href="#Debugging-the-E1000" class="headerlink" title="Debugging the E1000　　"></a>Debugging the E1000　　</h3><p>很幸运我们使用的是模拟硬件，E1000网卡运行为软件，模拟的E1000网卡能以用户可读的形式，向我们汇报有用的信息，比如内部状态和问题。</p>
<p>模拟E1000网卡能产生一系列debug输出，通过打开特殊的日志通道，来捕获输出信息：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Flag</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>tx</td>
<td>Log packet transmit operations</td>
</tr>
<tr>
<td>txerr</td>
<td>Log transmit ring errors</td>
</tr>
<tr>
<td>rx</td>
<td>Log changes to RCTL</td>
</tr>
<tr>
<td>rxfilter</td>
<td>Log filtering of incoming packets</td>
</tr>
<tr>
<td>rxerr</td>
<td>Log receive ring errors</td>
</tr>
<tr>
<td>unknown</td>
<td>Log reads and writes of unknown registers</td>
</tr>
<tr>
<td>eeprom</td>
<td>Log reads from the EEPROM</td>
</tr>
<tr>
<td>interrupt</td>
<td>Log interrupts and changes to interrupt registers.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="The-Network-Server"><a href="#The-Network-Server" class="headerlink" title="The Network Server"></a>The Network Server</h3><p>从零开始写1个网络栈是很难的。这里，我们使用lwIP开源TCP/IP协议组件来实现网络栈。在这个实验中，我们只需知道lwIP是一个黑盒，它实现了BSD的socket接口并且有一个数据包input port和数据包output port。</p>
<p>网络服务器其实是由以下四个environments组成的</p>
<ol>
<li>核心网络服务 environment(包括socket调用分发和lwIP</li>
<li>输入environment</li>
<li>输出environment</li>
<li>计时environment</li>
</ol>
<p>下图显示了各个environments以及它们之间的关系。图中展示了整个系统包括设备驱动。在本次实验中，我们将实现被标记为绿色的那些部分。<br><img src="/img/20211129222000.png" alt=""></p>
<p>其实整个网络服务器实现与文件系统的实现类似，也是通过IPC机制来在各个environment之间进行数据交互。</p>
<p>本次实验中QEMU因为不是MIT修改过的版本，所以改为：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/yuhao/6.828/qemu/i386-softmmu/qemu-system-i386 -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log -smp 1 -drive file=obj/fs/fs.img,index=1,media=disk,format=raw -netdev user,<span class="built_in">id</span>=u1 -device e1000,netdev=u1 -nic user,hostfwd=tcp::26001-:7 -nic user,hostfwd=tcp::26002-:80 -nic user,hostfwd=udp::26001-:7 -object filter-dump,<span class="built_in">id</span>=f1,netdev=u1,file=qemu.pcap</span><br></pre></td></tr></table></figure></p>
<h3 id="The-Core-Network-Server-Environment"><a href="#The-Core-Network-Server-Environment" class="headerlink" title="The Core Network Server Environment　　"></a>The Core Network Server Environment　　</h3><p>核心网络服务environment由<code>socket</code>调用分发器和lwIP组成。<code>socket</code>调用分发和文件服务器的工作方式类似。用户 environment通过<code>stubs</code>（定义在<code>lib/nsipc.c</code>）向核心网络environment发送IPC消息。查看<code>lib/nsipc.c</code>可以发现，核心网络服务器的工作方式和文件服务器是类似的：<code>i386_init</code>创建了NS environment，类型为<code>NS_TYPE_NS</code>，因此我们遍历<code>envs</code>，找到这个特殊的environment type。对于每一个用户environment的IPC，网络服务器中的IPC分发器会调用由lwIP提供的BSD socket接口来实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send an IP request to the network server, and wait for a reply.</span></span><br><span class="line"><span class="comment">// The request body should be in nsipcbuf, and parts of the response</span></span><br><span class="line"><span class="comment">// may be written back to nsipcbuf.</span></span><br><span class="line"><span class="comment">// type: request code, passed as the simple integer IPC value.</span></span><br><span class="line"><span class="comment">// Returns 0 if successful, &lt; 0 on failure.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">nsipc</span><span class="params">(<span class="type">unsigned</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">envid_t</span> nsenv;</span><br><span class="line">    <span class="keyword">if</span> (nsenv == <span class="number">0</span>)</span><br><span class="line">        nsenv = ipc_find_env(ENV_TYPE_NS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(nsipcbuf) == PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">        cprintf(<span class="string">&quot;[%08x] nsipc %d\n&quot;</span>, thisenv-&gt;env_id, type);</span><br><span class="line"></span><br><span class="line">    ipc_send(nsenv, type, &amp;nsipcbuf, PTE_P|PTE_W|PTE_U);</span><br><span class="line">    <span class="keyword">return</span> ipc_recv(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>普通的用户environment不直接使用<code>nsipc_*</code>调用。通常它们都使用<code>lib/sockets.c</code>中提供的基于文件描述符的sockets API。因此，用户environment通过文件描述符来引用<code>socket</code>，就像引用普通的磁盘文件一样。虽然<code>socket</code>有许多特殊的操作(比如<code>connect</code>、<code>accept</code>等等)，但是像<code>read</code>，<code>write</code>，<code>close</code>这样的操作也是通过<code>lib/fd.c</code>中正常的文件描述符device-dispatcher代码。就像文件服务器会为所有打开的文件维护一个内部独有的ID，lwIP也会为每个打开的socket维护一个独有的ID。在文件服务器或者网络服务器中，我们使用存储在<code>struct Fd</code>中的信息来映射每个environment的文件描述符到相应的ID空间中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fd2sockid</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">sfd</span>;</span></span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((r = fd_lookup(fd, &amp;sfd)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">if</span> (sfd-&gt;fd_dev_id != devsock.dev_id)</span><br><span class="line">                <span class="keyword">return</span> -E_NOT_SUPP;</span><br><span class="line">        <span class="keyword">return</span> sfd-&gt;fd_sock.sockid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">alloc_sockfd</span><span class="params">(<span class="type">int</span> sockid)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">sfd</span>;</span></span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((r = fd_alloc(&amp;sfd)) &lt; <span class="number">0</span></span><br><span class="line">            || (r = sys_page_alloc(<span class="number">0</span>, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                nsipc_close(sockid);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sfd-&gt;fd_dev_id = devsock.dev_id;</span><br><span class="line">        sfd-&gt;fd_omode = O_RDWR;</span><br><span class="line">        sfd-&gt;fd_sock.sockid = sockid;</span><br><span class="line">        <span class="keyword">return</span> fd2num(sfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">accept</span><span class="params">(<span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = fd2sockid(s)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = nsipc_accept(r, addr, addrlen)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> alloc_sockfd(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">bind</span><span class="params">(<span class="type">int</span> s, <span class="keyword">struct</span> sockaddr *name, <span class="type">socklen_t</span> namelen)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = fd2sockid(s)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> nsipc_bind(r, name, namelen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> how)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = fd2sockid(s)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> nsipc_shutdown(r, how);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">devsock_close</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (pageref(fd) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> nsipc_close(fd-&gt;fd_sock.sockid);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">connect</span><span class="params">(<span class="type">int</span> s, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *name, <span class="type">socklen_t</span> namelen)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = fd2sockid(s)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> nsipc_connect(r, name, namelen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">listen</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = fd2sockid(s)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> nsipc_listen(r, backlog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">devsock_read</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> nsipc_recv(fd-&gt;fd_sock.sockid, buf, n, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">devsock_write</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> nsipc_send(fd-&gt;fd_sock.sockid, buf, n, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">devsock_stat</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="keyword">struct</span> Stat *stat)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(stat-&gt;st_name, <span class="string">&quot;&lt;sock&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = nsipc_socket(domain, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">return</span> alloc_sockfd(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然看起来文件服务器和网络服务器的IPC分发器工作方式相同，但是事实上有一个非常重要的区别。有些BSD socket的操作，例如accept和recv可能会永远阻塞。如果分发器让lwIP运行其中一个堵塞调用，那么很可能分发器会阻塞，因此整个系统在某一时刻只能有一个网络调用，显然，这是不能让人接收的。因此网络服务器使用用户级线程去避免整个服务器environment的阻塞。对于每一个到来的IPC，分发器都会创建一个线程，然后由它对请求进行处理。即使这个线程阻塞了，那么也仅仅只是它进入休眠状态，而其他的线程照样能继续运行。</p>
<p>除了核心网络environment之外，还有其他三个辅助的environment。除了从用户程序中获取消息以外，核心网络 environment的分发器还从input environment和timer environment处获取信息。</p>
<h3 id="The-Output-Environment"><a href="#The-Output-Environment" class="headerlink" title="The Output Environment　"></a>The Output Environment　</h3><p>当处理用户environment的socket调用时，lwIP会产生packet用于网卡的传输。lwIP会将需要发送的packet通过<code>NSREQ_OUTPUT IPC</code>发送给output helper environment，packet的内容存放在IPC的共享页中。output environment负责接收这些信息并且通过系统调用接口将这些packet转发到相应的设备驱动(我们即将实现)。</p>
<h3 id="The-Input-Environment"><a href="#The-Input-Environment" class="headerlink" title="The Input Environment"></a>The Input Environment</h3><p>网卡得到的packet需要注入到lwIP中。对于设备驱动获得的每一个packet，input environment需要通过相应的系统调用将它们从内核中抽取出来，然后通过<code>NSREQ_INPUT IPC</code>发送给核心服务器environment。</p>
<p>packet input的功能从核心网络environment中剥离出来了，因为接收IPC并且同时接收或等待来自设备驱动的packet对于JOS是非常困难的。因为JOS中没有select这样能够允许environment监听多个输入源并且判断出哪个源已经准备好了。</p>
<p>当我们实现完网卡驱动和系统调用接口后<code>net/input.c</code>和<code>net/output.c</code>中就是我们要实现的2个用户态函数。</p>
<h3 id="The-Timer-Environment"><a href="#The-Timer-Environment" class="headerlink" title="The Timer Environment　　　　　　　"></a>The Timer Environment　　　　　　　</h3><p>timer environment会定期地向核心网络服务器发送<code>NSREQ_TIMER IPC</code>，通知它又过去了一个时间间隔，而lwIP会利用这些时间信息去实现各种的网络超时。</p>
<h2 id="Part-A-Initialization-and-transmitting-packets"><a href="#Part-A-Initialization-and-transmitting-packets" class="headerlink" title="Part A: Initialization and transmitting packets"></a>Part A: Initialization and transmitting packets</h2><p>我们的内核中还没有时间的概念，所以我们需要加上它。现在每隔10ms都有一个由硬件产生的时钟中断。每次出现一个时钟中断的时候，我们都对一个变量进行加操作，表示过去了10ms。这实现在kern/time.c中，但是并未归并到内核中。<br>　　<br>Exercise 1：在<code>kern/trap.c</code>中增加1个<code>time_tick</code>调用来处理每次时钟中断，实现<code>sys_time_msec</code>系统调用，使用户空间能读取时间。<br>　<br>首先在<code>kern/trap.c</code>的<code>trap_dispatch</code>函数中，对于<code>IRQ_OFFSET + IRQ_TIMER</code>中断添加<code>time_tick</code>调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kern/trap.c</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</span><br><span class="line">        lapic_eoi();</span><br><span class="line">        time_tick();</span><br><span class="line">        sched_yield();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kern/time.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">time_tick</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    ticks++;</span><br><span class="line">    <span class="keyword">if</span> (ticks * <span class="number">10</span> &lt; ticks)</span><br><span class="line">        panic(<span class="string">&quot;time_tick: time overflowed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下去就是添加获取时间的系统调用，具体流程和之前的一样，主要是在<code>kern/syscall.c</code>的中实现<code>sys_time_msec</code>函数，在该函数中调用<code>time_msec</code>函数来获得系统时间。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kern/syscall.c</span></span><br><span class="line"><span class="comment">// Return the current time.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_time_msec</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> time_msec();</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//kern/time.c</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">time_msec</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">return</span> ticks * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过运行<code>make INIT_CFLAGS=-DTEST_NO_NS run-testtime</code>来测试计时器共，将会看到从5到1的倒计时。其中<code>-DTEST_NO_NS</code>禁止启动网络服务器environment，因为我们暂时还没实现。</p>
<h3 id="The-Network-Interface-Card"><a href="#The-Network-Interface-Card" class="headerlink" title="The Network Interface Card"></a>The Network Interface Card</h3><p>　　要写1个驱动必须要深入硬件和软件接口，在本次实验中我们将给1个高层次综述关于如何与E1000网卡交互，但是你需要去使用Intel的帮助手册来实现驱动。</p>
<h3 id="PCI-Interface"><a href="#PCI-Interface" class="headerlink" title="PCI Interface"></a>PCI Interface</h3><p>E1000网卡是一个PCI设备，这说明它是插入主板的PCI总线。PCI总线有地址总线、数据总线和中断总线，从而允许CPU能访问PCI设备，PCI设备也能读写内存。一个PCI设备在使用之前需要被发现并且初始化。发现的过程是指遍历PCI总线找到已经连接的设备。初始化是指为设备分配IO和内存空间并且指定IRQ线的过程。</p>
<p>PCI是外围设备互连(Peripheral Component Interconnect)的简称，是在目前计算机系统中得到广泛应用的通用总线接口标准：　　</p>
<ul>
<li>在一个PCI系统中，最多可以有256根PCI总线，一般主机上只会用到其中很少的几条。</li>
<li>在一根PCI总线上可以连接多个物理设备，可以是一个网卡、显卡或者声卡等，最多不超过32个。</li>
<li>一个PCI物理设备可以有多个功能，比如同时提供视频解析和声音解析，最多可提供8个功能。</li>
<li>每个功能对应1个256字节的PCI配置空间。</li>
</ul>
<p>我们在<code>kern/pci.c</code>中已经提供了PCI相关的代码。为了在启动过程中实现PCI的初始化，相关的PCI代码遍历了PCI总线进行设备查找。当发现一个设备时，它会读取它的vendor ID和device ID，把这两个值作为<code>key</code>去查询<code>pci_attach_vendor</code>数组。该数组元素是<code>struct pci_driver</code>类型的，如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> &#123;</span></span><br><span class="line">　　<span class="type">uint32_t</span> key1, key2;</span><br><span class="line">　　<span class="type">int</span> (*attachfn) (<span class="keyword">struct</span> pci_func *pcif);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果被发现设备的vendor ID和device ID和数组中的某个表项是匹配的，那么接下来就会调用该表项的<code>attachfn</code>函数进行初始化工作。(设备也能被class识别，我们在<code>kern/pci.c</code>中也提供了其它驱动表)</p>
<p>当我们向查询1个特定PCI设备的配置空间时，需要向I/O地址<code>[0cf8，0cfb]</code>写入1个4字节的查询码指定总线号：设备号：功能号以及其配置地址空间中的查询位置。PCI Host Bridge将监听对于这个I/O端口的写入，并将查询结果写入到<code>[0cfc，0cff]</code>，我们可以从这个地址读出1个32位整数表示查询到的相应信息。</p>
<p><code>attach</code>函数通过一个 PCI 函数来初始化。 PCI 卡可以提供多种功能，而 E1000 只提供一种功能。以下是我们在 JOS 中表示 PCI 功能的方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_func</span> &#123;</span></span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">pci_bus</span> 　　*<span class="title">bus</span>;</span></span><br><span class="line">　　<span class="type">uint32_t</span>　　　　　dev;</span><br><span class="line">　　<span class="type">uint32_t</span>　　　　　func;</span><br><span class="line">　　<span class="type">uint32_t</span>　　　　　dev_id;</span><br><span class="line">　　<span class="type">uint32_t</span>　　　　　dev_clasee;</span><br><span class="line">　　<span class="type">uint32_t</span>　　　　　reg_base[<span class="number">6</span>];</span><br><span class="line">　　<span class="type">uint32_t</span>　　　　　reg_size[<span class="number">6</span>];</span><br><span class="line">　　<span class="type">uint8_t</span>　　　　　  irq_line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述结构的最后三个表项是最吸引我们的地方，其中记录了该设备的内存、IO和中断资源的信息。<code>reg_base</code>和<code>reg_size</code>数组包含了最多6个Base Address Register（BAR）的信息。<code>reg_base</code>记录了memory-mapped IO region的基内存地址或者基IO端口，<code>reg_size</code>则记录了<code>reg_base</code>对应的内存区域的大小或者IO端口的数目，<code>irq_line</code>则表示分配给设备中断用的IRQ线。</p>
<p>当设备的<code>attachfn</code>被调用时，设备已经被找到了，但是还不能用。这说明相关代码还没有确定分配给设备的资源，比如地址空间和IRQ线，其实就是<code>struct pci_fun</code>中的后三项还没被填充。<code>attachfn</code>函数需要调用<code>pci_func_enable</code>来分配相应的资源，填充<code>struct pci_func</code>，使设备运行起来。</p>
<p>每一个PCI设备都有它映射的内存地址空间和I/O区域，除此之外，PCI设备还有配置空间，一共有256字节，其中前64字节是标准化的，提供了厂商号、设备号、版本号等信息，唯一标示1个PCI设备，同时提供最多6个的IO地址区域。<br><img src="/img/1638326044.jpg" alt=""></p>
<p>Exercise 3：实现1个<code>attach</code>函数来初始化E1000网卡，在<code>pci_attach_vendor</code>数组中增加1个表项来触发，可以在参考手册的5.2章节来找到82450EM的vendor ID和device ID。目前暂时使用<code>pci_func_enable</code>来使能E1000网卡设备，初始化工作放到后面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pci_func_enable</span><span class="params">(<span class="keyword">struct</span> pci_func *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    pci_conf_write(f, PCI_COMMAND_STATUS_REG,</span><br><span class="line">                   PCI_COMMAND_IO_ENABLE |</span><br><span class="line">                   PCI_COMMAND_MEM_ENABLE |</span><br><span class="line">                   PCI_COMMAND_MASTER_ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> bar_width;</span><br><span class="line">    <span class="type">uint32_t</span> bar;</span><br><span class="line">    <span class="keyword">for</span> (bar = PCI_MAPREG_START; bar &lt; PCI_MAPREG_END;</span><br><span class="line">        bar += bar_width)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> oldv = pci_conf_read(f, bar);</span><br><span class="line"></span><br><span class="line">        bar_width = <span class="number">4</span>;</span><br><span class="line">        pci_conf_write(f, bar, <span class="number">0xffffffff</span>);</span><br><span class="line">        <span class="type">uint32_t</span> rv = pci_conf_read(f, bar);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rv == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> regnum = PCI_MAPREG_NUM(bar);</span><br><span class="line">        <span class="type">uint32_t</span> base, size;</span><br><span class="line">        <span class="keyword">if</span> (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_MEM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (PCI_MAPREG_MEM_TYPE(rv) == PCI_MAPREG_MEM_TYPE_64BIT)</span><br><span class="line">                bar_width = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">            size = PCI_MAPREG_MEM_SIZE(rv);</span><br><span class="line">            base = PCI_MAPREG_MEM_ADDR(oldv);</span><br><span class="line">            <span class="keyword">if</span> (pci_show_addrs)</span><br><span class="line">                cprintf(<span class="string">&quot;  mem region %d: %d bytes at 0x%x\n&quot;</span>,</span><br><span class="line">                        regnum, size, base);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            size = PCI_MAPREG_IO_SIZE(rv);</span><br><span class="line">            base = PCI_MAPREG_IO_ADDR(oldv);</span><br><span class="line">            <span class="keyword">if</span> (pci_show_addrs)</span><br><span class="line">                cprintf(<span class="string">&quot;  io region %d: %d bytes at 0x%x\n&quot;</span>,</span><br><span class="line">                        regnum, size, base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pci_conf_write(f, bar, oldv);</span><br><span class="line">        f-&gt;reg_base[regnum] = base;</span><br><span class="line">        f-&gt;reg_size[regnum] = size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &amp;&amp; !base)</span><br><span class="line">            cprintf(<span class="string">&quot;PCI device %02x:%02x.%d (%04x:%04x) &quot;</span></span><br><span class="line">                    <span class="string">&quot;may be misconfigured: &quot;</span></span><br><span class="line">                    <span class="string">&quot;region %d: base 0x%x, size %d\n&quot;</span>,</span><br><span class="line">                    f-&gt;bus-&gt;busno, f-&gt;dev, f-&gt;func,</span><br><span class="line">                    PCI_VENDOR(f-&gt;dev_id), PCI_PRODUCT(f-&gt;dev_id),</span><br><span class="line">                    regnum, base, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;PCI function %02x:%02x.%d (%04x:%04x) enabled\n&quot;</span>,</span><br><span class="line">            f-&gt;bus-&gt;busno, f-&gt;dev, f-&gt;func,</span><br><span class="line">            PCI_VENDOR(f-&gt;dev_id), PCI_PRODUCT(f-&gt;dev_id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回答：在JOS中是如何对PCI设备进行初始化的，这部分模块主要定义在<code>pci.c</code>中，JOS会在系统初始化时调用<code>pci_init</code>函数来进行设备初始化(在<code>kern/init.c</code>的<code>i386_init</code>函数中)。</p>
<p>首先来看一些最基本的变量和函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pci_attach_class matches the class and subclass of a PCI device</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">pci_attach_class</span>[] =</span> &#123;</span><br><span class="line">    &#123; PCI_CLASS_BRIDGE, PCI_SUBCLASS_BRIDGE_PCI, &amp;pci_bridge_attach &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pci_attach_vendor matches the vendor ID and device ID of a PCI device. key1</span></span><br><span class="line"><span class="comment">// and key2 should be the vendor ID and device ID respectively</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">pci_attach_vendor</span>[] =</span> &#123;</span><br><span class="line">    &#123; PCI_E1000_VENDOR, PCI_E1000_DEVICE, &amp;pci_e1000_attach &#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">pci_conf1_set_addr</span><span class="params">(<span class="type">uint32_t</span> bus,</span></span><br><span class="line"><span class="params">           <span class="type">uint32_t</span> dev,</span></span><br><span class="line"><span class="params">           <span class="type">uint32_t</span> func,</span></span><br><span class="line"><span class="params">           <span class="type">uint32_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(bus &lt; <span class="number">256</span>);</span><br><span class="line">    assert(dev &lt; <span class="number">32</span>);</span><br><span class="line">    assert(func &lt; <span class="number">8</span>);</span><br><span class="line">    assert(offset &lt; <span class="number">256</span>);</span><br><span class="line">    assert((offset &amp; <span class="number">0x3</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> v = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) |        <span class="comment">// config-space</span></span><br><span class="line">        (bus &lt;&lt; <span class="number">16</span>) | (dev &lt;&lt; <span class="number">11</span>) | (func &lt;&lt; <span class="number">8</span>) | (offset);</span><br><span class="line">    outl(pci_conf1_addr_ioport, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">pci_conf_read</span><span class="params">(<span class="keyword">struct</span> pci_func *f, <span class="type">uint32_t</span> off)</span></span><br><span class="line">&#123;</span><br><span class="line">    pci_conf1_set_addr(f-&gt;bus-&gt;busno, f-&gt;dev, f-&gt;func, off);</span><br><span class="line">    <span class="keyword">return</span> inl(pci_conf1_data_ioport);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">pci_conf_write</span><span class="params">(<span class="keyword">struct</span> pci_func *f, <span class="type">uint32_t</span> off, <span class="type">uint32_t</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">    pci_conf1_set_addr(f-&gt;bus-&gt;busno, f-&gt;dev, f-&gt;func, off);</span><br><span class="line">    outl(pci_conf1_data_ioport, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>pci_attach_class</code>和<code>pci_attach_vendor</code>2个数组就是设备数组，3个函数是堆PCI设备最基本的读状态和写状态的函数：　　　</p>
<ul>
<li><code>pci_conf_read</code>函数是读取PCI配置空间中特定位置的配置值</li>
<li><code>pci_conf_write</code>函数是设置PCI配置空间中特定位置的配置值</li>
<li><code>pci_conf1_set_addr</code>函数是负责设置需要读写的具体设备</li>
</ul>
<p>这里涉及的2个I/O端口正是我们上面提到的操作PCI设备的IO端口。接下来我们看看如何初始化PCI设备，进入<code>pic_init</code>函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pci_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pci_bus</span> <span class="title">root_bus</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;root_bus, <span class="number">0</span>, <span class="keyword">sizeof</span>(root_bus));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pci_scan_bus(&amp;root_bus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">pci_scan_bus</span><span class="params">(<span class="keyword">struct</span> pci_bus *bus)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> totaldev = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_func</span> <span class="title">df</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;df, <span class="number">0</span>, <span class="keyword">sizeof</span>(df));</span><br><span class="line">    df.bus = bus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (df.dev = <span class="number">0</span>; df.dev &lt; <span class="number">32</span>; df.dev++) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> bhlc = pci_conf_read(&amp;df, PCI_BHLC_REG);</span><br><span class="line">        <span class="keyword">if</span> (PCI_HDRTYPE_TYPE(bhlc) &gt; <span class="number">1</span>)     <span class="comment">// Unsupported or no device</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        totaldev++;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pci_func</span> <span class="title">f</span> =</span> df;</span><br><span class="line">        <span class="keyword">for</span> (f.func = <span class="number">0</span>; f.func &lt; (PCI_HDRTYPE_MULTIFN(bhlc) ? <span class="number">8</span> : <span class="number">1</span>);</span><br><span class="line">             f.func++) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">pci_func</span> <span class="title">af</span> =</span> f;</span><br><span class="line"></span><br><span class="line">            af.dev_id = pci_conf_read(&amp;f, PCI_ID_REG);</span><br><span class="line">            <span class="keyword">if</span> (PCI_VENDOR(af.dev_id) == <span class="number">0xffff</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">uint32_t</span> intr = pci_conf_read(&amp;af, PCI_INTERRUPT_REG);</span><br><span class="line">            af.irq_line = PCI_INTERRUPT_LINE(intr);</span><br><span class="line"></span><br><span class="line">            af.dev_class = pci_conf_read(&amp;af, PCI_CLASS_REG);</span><br><span class="line">            <span class="keyword">if</span> (pci_show_devs)</span><br><span class="line">                pci_print_func(&amp;af);</span><br><span class="line">            pci_attach(&amp;af);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totaldev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>pci_init</code>函数中，<code>root_bus</code>被全部清0，然后交给<code>pci_scan_bus</code>函数来扫描这条总线上的所有设备，说明在JOS中E1000网卡是连接在0号总线上的。<code>pci_scan_bus</code>函数来顺次查找0号总线上的32个设备，如果发现其存在，那么顺次扫描它们每个功能对应的配置地址空间，将一些关键的控制参数读入到<code>pci_func</code>中进行保存。</p>
<p>得到<code>pci_func</code>函数后，被传入<code>pci_attach</code>函数去查找是否为已存在的设备，并用相应的初始化函数来初始化设备。</p>
<p>通过查阅手册，我们知道E1000网卡的Vendor ID为0x8086，Device ID为0x100E，所以我们先实现1个e1000网卡初始化函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kern/e1000.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> JOS_KERN_E1000_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JOS_KERN_E1000_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;kern/pci.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pci_e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// SOL &gt;= 6</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kern/e1000.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pci_e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span></span><br><span class="line">&#123;</span><br><span class="line">    pci_func_enable(pcif);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kern/pci.c</span></span><br><span class="line"><span class="comment">// pci_attach_vendor matches the vendor ID and device ID of a PCI device. key1</span></span><br><span class="line"><span class="comment">// and key2 should be the vendor ID and device ID respectively</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">pci_attach_vendor</span>[] =</span> &#123;</span><br><span class="line">        &#123; PCI_VENDOR_ID, PCI_DEVICE_ID, &amp;e1000_init &#125;,</span><br><span class="line">        &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kern/pcireg.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCI_VENDOR_ID                           0x8086</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCI_DEVICE_ID                           0x100E</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Memory-mapped-I-O"><a href="#Memory-mapped-I-O" class="headerlink" title="Memory-mapped I/O"></a>Memory-mapped I/O</h3><p>软件通过memory-mapped IO（MMIO）和E1000网卡进行通信。我们已经在JOS两次见到过它了：对于CGA和LAPIC都是通过直接读写“内存”来控制和访问的。但是这些读写操作都是不经过DRAM的，而是直接进入设备。</p>
<p><code>pci_func_enable</code>为E1000网卡分配了一个MMIO区域，并且将它的基地址和大小存储在了BAR0中，也就是<code>reg_base[0]</code>和<code>reg_size[0]</code>中。这是一段为设备分配的物理地址，意味着你需要通过虚拟内存访问它。因为MMIO区域通常都被放在非常高的物理地址上（通常高于3GB），因此我们不能直接使用<code>KADDR</code>去访问它，因为JOS 256MB的内存限制。所以我们需要建立一个新的内存映射。我们将会使用高于<code>MMIOBASE</code>的区域（lab4中的<code>mmio_map_region</code>将会保证我们不会复写LAPIC的映射）。因为PCI设备的初始化发生在JOS创建user environment之前，所以我们可以在<code>kern_pgdir</code>创建映射，从而保证它永远可用。</p>
<p>Exercise 4：在E1000网卡的初始化函数中，通过调用<code>mmio_map_region</code>函数来为E1000网卡的BAR0建立一个虚拟内存映射。你需要使用1个变量记录下该映射地址以便之后可以访问映射的寄存器。查看在<code>kern/lapic.c</code>中的<code>lapic</code>变量，效仿它的做法。假如你使用1个指针指向设备寄存器映射地址，那么你必须声明它为<code>volatile</code>，否则编译器会运行缓存该值和重新排序内存访问序列。</p>
<p>为了测试你的映射，可以尝试答应处设备状态寄出去，该寄存器为4个字节，值为0x80080783，表示全双工1000MB/S。</p>
<p>根据练习的提示，仿照lapic中的做法，在<code>kern/e1000.c</code>中声明1个全局变量<code>e1000</code>，该变量是1个指针，指向映射地址。然后调用<code>mmio_map_region</code>函数来申请内存建立映射，输出状态寄存器的值。关于寄存器位置和相关掩码，我们需要查看开发手册，设置宏定义，这一步可以借鉴QEMU的e1000_hw.h文件，拷贝相关定义到<code>kern/e1000.h</code>中。代码如下，具体的宏定义可以参考github。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pci_e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span></span><br><span class="line">&#123;</span><br><span class="line">    pci_func_enable(pcif);</span><br><span class="line"></span><br><span class="line">    e1000 = mmio_map_region(pcif-&gt;reg_base[<span class="number">0</span>], pcif-&gt;reg_size[<span class="number">0</span>]);</span><br><span class="line">    cprintf(<span class="string">&quot;e1000: bar0  %x size0 %x\n&quot;</span>, pcif-&gt;reg_base[<span class="number">0</span>], pcif-&gt;reg_size[<span class="number">0</span>]);</span><br><span class="line">    cprintf(<span class="string">&quot;e1000: status %x\n&quot;</span>, e1000[STATUS/<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>我们可以想象通过读写E1000网卡的寄存器来发送和接收<code>packet</code>，但这实在是太慢了，而且需要E1000暂存<code>packets</code>。因此E1000使用Direct Access Memory(DMA)来直接从内存中读写<code>packets</code>而不通过CPU。驱动的作用就是负责为发送和接收队列分配内存，建立DMA描述符，以及配置E1000网卡，让它知道这些队列的位置，不过之后的所有事情都是异步。在发送<code>packet</code>的时候，驱动会将它拷贝到<code>transmit</code>队列的下一个DMA描述符中，然后通知E1000网卡另外一个包到了。E1000网卡会在能够发送下一个<code>packet</code>的时候，将<code>packet</code>从描述符中拷贝出来。同样，当E1000网卡接收到一个<code>packet</code>的时候，就会将它拷贝到接收队列的下一个DMA描述符中，并且在合适的时机，驱动会将它从中读取出来。<br>　　<br>从高层次来看，接收和发送队列是非常相似的，都是由一系列的描述符组成。但是这些descriptor具体的结构是不同的，每个描述符都包含了一些flag以及存储packet数据的物理地址。<br>　　<br>队列由循环数组构成，这表示当网卡或者驱动到达了数组的末尾时，它又会转回数组的头部。每个循环数组都有一个<code>head</code>指针和<code>tail</code>指针，这两个指针之间的部分就是队列的内容。网卡总是从<code>head</code>消耗描述符并且移动<code>head</code>指针，同时，驱动总是向尾部添加描述符并且移动<code>tail</code>指针。发送队列的描述符代表等待被发送的<code>packet</code>。对于接收队列，队列中的描述符是一些闲置的描述符，网卡可以将收到的<code>packet</code>放进去。</p>
<p>这些指向数组的指针和描述符中packet buffer的地址都必须是物理地址，因为硬件直接和物理RAM发生DMA，并不经过MMU。</p>
<h3 id="Transmitting-Packets"><a href="#Transmitting-Packets" class="headerlink" title="Transmitting Packets"></a>Transmitting Packets</h3><p>E1000网卡的发送和接收函数是独立的，因此我们能一次处理其中一个。我们将首先实现发送<code>packet</code>的操作，因为没有发送就不能接收。<br>　　<br>首先，我们要做的是初始化网卡的发包。根据14.5章节描述的步骤，发送操作初始化的第一步就是建立发送队列，具体队列结构的描述在3.4章节，描述符的结构在3.3.3章节。我们不会使用E1000网卡的TCP offload特性，所以我们专注于”legacy transmit descriptor format”。</p>
<h4 id="C-Structures"><a href="#C-Structures" class="headerlink" title="C Structures"></a>C Structures</h4><p>我们会发现用C的结构描述E1000网卡的结构是相当容易的。就像我们之前遇到过的<code>struct Trapframe</code>，C结构能让你精确地控制数据在内存中的布局。C会在结构的各个元素间插入空白用于对齐，但是对于E1000里的结构这都不是问题。例如，传统的发送描述符如下图所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">63      48 47 40 39   32 31  24 23   16 15      0</span><br><span class="line">+-----------------------------------------------+</span><br><span class="line">|               buffer address                  |</span><br><span class="line">+---------+-----+--------+-----+-------+--------+</span><br><span class="line">| special | CSS | status | cmd |  CSO  | length |</span><br><span class="line">+---------+-----+--------+-----+-------+--------+</span><br></pre></td></tr></table></figure></p>
<p>按照从上往下，从右往左的顺序读取，我们可以发现，<code>struct tx_desc</code>刚好是对齐的，因此不会有空白填充。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> addr;</span><br><span class="line">    <span class="type">uint16_t</span> length;</span><br><span class="line">    <span class="type">uint8_t</span> cso;</span><br><span class="line">    <span class="type">uint8_t</span> cmd;</span><br><span class="line">    <span class="type">uint8_t</span> status;</span><br><span class="line">    <span class="type">uint8_t</span> css;</span><br><span class="line">    <span class="type">uint16_t</span> special;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们的驱动需要为发送描述符数组和发送描述符指向的<code>packet buffers</code>预留内存。对于这一点，我们有很多实现方法，包括可以通过动态地分配页面并将它们存放在全局变量中。我们用哪种方法，需要记住的是E1000总是直接访问物理内存的，这意味着任何它访问的buffer都必须在物理空间上是连续的。<br>　　<br>同样，我们有很多方法处理<code>packet buffer</code>。最简单的就是像最开始我们说的那样，在驱动初始化的时候为每个描述符的<code>packet buffer</code>预留空间，之后就在这些预留的<code>buffer</code>中对<code>packet</code>进行进出拷贝。Ethernet packet最大有1518个byte，这就表明了这些buffer至少要多大。更加复杂的驱动可以动态地获取packet buffer（为了降低网络使用率比较低的时候带来的浪费）或者直接提供由用户空间提供的buffers，不过一开始简单点总是好的。<br>　　<br>Exercise 5：根据14.5章节的描述，实现发包初始化，同时借鉴13章节(寄存器初始化)、3.3.3章节((发送描述符)和3.4章节(发送描述符数组)。<br>　　<br>记住发送描述数组的对弈要求和数组长度的限制。TDLEN必须是128字节对齐的，每个发送描述符是16字节的，你的发送描述符数组大小需要是8的倍数。在JOS中不要超过64个描述符，以防不好测试发送环形队列溢出情况。</p>
<p>这里需要查看开发手册14.5章节关于发送初始化的描述，主要步骤如下：</p>
<ul>
<li>为发送描述符队列分配一块连续空间，设置<code>TDBAL</code>和<code>TDBAH</code>寄存器的值指向起始地址，其中<code>TDBAL</code>为32位地址，<code>TDBAL</code>和<code>TDBAH</code>表示64位地址。</li>
<li>设置<code>TDLEN</code>寄存器的值为描述符队列的大小，以字节计算。</li>
<li>设置发送队列的<code>Head</code>指针(TDH)和<code>Tail</code>指针(TDT)寄存器的值为0。</li>
<li>初始化发送控制<code>TCTL</code>寄存器的值，包括设置Enable位为1(<code>TCTL.EN</code>)、<code>TCTL.PSP</code>位为1、<code>TCTL.CT</code>位为10h、<code>TCTL.COLD</code>位为40h。</li>
<li>设置<code>TIPG</code>寄存器为期望值</li>
</ul>
<p>首先是发送队列的设置，这里采用最简单的方法，声明发送描述符结构体和<code>packet buffer</code>结构体，并定义1个64大小的全局发送描述符数组和1个64大小的<code>packet buffer</code>数组，即都使用静态分配的方法。由于packet最大为1518字节，根据后面接收描述符的配置，将<code>packet buffer</code>设置为2048字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kern/e1000.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> addr;</span><br><span class="line">    <span class="type">uint16_t</span> length;</span><br><span class="line">    <span class="type">uint8_t</span> cso;</span><br><span class="line">    <span class="type">uint8_t</span> cmd;</span><br><span class="line">    <span class="type">uint8_t</span> status;</span><br><span class="line">    <span class="type">uint8_t</span> css;</span><br><span class="line">    <span class="type">uint16_t</span> special;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet</span></span></span><br><span class="line"><span class="class">&#123;</span>       </span><br><span class="line">    <span class="type">char</span> body[<span class="number">2048</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//kern/e1000.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> <span class="title">tx_d</span>[<span class="title">TXRING_LEN</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span> (<span class="title">PGSIZE</span>)))</span></span><br><span class="line"><span class="class">        =</span> &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet</span> <span class="title">pbuf</span>[<span class="title">TXRING_LEN</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span> (<span class="title">PGSIZE</span>)))</span></span><br><span class="line"><span class="class">        =</span> &#123;&#123;&#123;<span class="number">0</span>&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>pci_enable_attach</code>函数中初始化相关寄存器的设置和发送描述符初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">init_desc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; TXRING_LEN; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;tx_d[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(tx_d[i]));</span><br><span class="line">        tx_d[i].addr = PADDR(&amp;pbuf[i]);</span><br><span class="line">        tx_d[i].status = TXD_STAT_DD;</span><br><span class="line">        tx_d[i].cmd = TXD_CMD_RS | TXD_CMD_EOP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pci_e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span></span><br><span class="line">&#123;</span><br><span class="line">    pci_func_enable(pcif);</span><br><span class="line">    init_desc();</span><br><span class="line"></span><br><span class="line">    e1000 = mmio_map_region(pcif-&gt;reg_base[<span class="number">0</span>], pcif-&gt;reg_size[<span class="number">0</span>]);</span><br><span class="line">    cprintf(<span class="string">&quot;e1000: bar0  %x size0 %x\n&quot;</span>, pcif-&gt;reg_base[<span class="number">0</span>], pcif-&gt;reg_size[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    e1000[TDBAL/<span class="number">4</span>] = PADDR(tx_d);</span><br><span class="line">    e1000[TDBAH/<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    e1000[TDLEN/<span class="number">4</span>] = TXRING_LEN * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tx_desc);</span><br><span class="line">    e1000[TDH/<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    e1000[TDT/<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    e1000[TCTL/<span class="number">4</span>] = TCTL_EN | TCTL_PSP | (TCTL_CT &amp; (<span class="number">0x10</span> &lt;&lt; <span class="number">4</span>)) | (TCTL_COLD &amp; (<span class="number">0x40</span> &lt;&lt; <span class="number">12</span>));</span><br><span class="line">    e1000[TIPG/<span class="number">4</span>] = <span class="number">10</span> | (<span class="number">8</span> &lt;&lt; <span class="number">10</span>) | (<span class="number">12</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">    cprintf(<span class="string">&quot;e1000: status %x\n&quot;</span>, e1000[STATUS/<span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在完成了exercise 5之后，发送已经初始化完成。我们需要实现包的发送工作，然后让用户空间能够通过系统调用获取这些包。为了发送一个包，我们需要将它加入到发送队列的尾部，这意味着我们要将<code>packet</code>拷贝到下一个packet buffer，并且更新TDT寄存器，从而告诉网卡，已经有另一个<code>packet</code>进入发送队列了。(需要注意的是，TDT是一个指向transmit descriptor array的index，而不是一个byte offset)</p>
<p>但是，发送队列只有这么大。如果网卡迟迟没有发送<code>packet</code>，发送队列满了怎么办？为了检测这种情况，我们需要反馈给E1000网卡一些信息。不幸的是，我们并不能直接使用<code>TDH</code>寄存器，文档中明确声明，读取该寄存器的值是不可靠的。然而，如果我们在发送描述符的command filed设置了RS位，那么当网卡发送了这个描述符中的包之后，就会设置该描述符的status域的DD位。如果一个描述符的DD位被设置了，那么我们就可以知道循环利用这个描述符是安全的，可以利用它去发送下一个packet。</p>
<p>如果当用户调用了发包的系统调用，但是下一个描述符的DD位没有设置怎么办？这是否代表发送队列满了么？遇到这种情况我们应该如何处理？我们可以选择简单地直接丢弃这个packet。许多网络协议都对这种情况有弹性的设置，但是如果我们丢弃了很多packet的话，协议可能就无法恢复了。我们也许可以告诉user environment我们需要重新发送，就像<code>sys_ipc_try_send</code>中做的一样。我们可以让驱动一直处于自旋状态，直到有一个发送描述符被释放，但是这可能会造成比较大的性能问题，因为JOS内核不是设计成能阻塞的。最后，我们可以让transmitting environment睡眠并且要求网卡在有transmit descriptor被释放的时候发送一个中断。</p>
<p>Exercise 6：写一个函数通过检查下一个描述符是否可用来发送一个包，拷贝数据包内容到下一个描述符中，更新TDT，确保你能正确解决发送队列满了的情况。</p>
<p>回答：在初始化工作中我们已经设置发送描述符的状态位为DD，即表示可用，只要在发送函数里获取<code>Tail</code>指针寄存器的值，判断该指针指向的发送描述符是否可用，如果可用将数据包内容拷贝到描述符中，并更新描述符的状态位和<code>TDT</code>寄存器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_transmit</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> tail = e1000[TDT/<span class="number">4</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> *<span class="title">nxt</span> =</span> &amp;tx_d[tail];</span><br><span class="line">    <span class="comment">// find the last ex_desc with tail.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((nxt-&gt;status &amp; TXD_STAT_DD) != TXD_STAT_DD)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; TBUFFSIZE)</span><br><span class="line">        len = TBUFFSIZE;</span><br><span class="line"></span><br><span class="line">    memmove(&amp;pbuf[tail], addr, len);</span><br><span class="line">    nxt-&gt;length = (<span class="type">uint16_t</span>)len;</span><br><span class="line">    nxt-&gt;status &amp;= !TXD_STAT_DD;</span><br><span class="line">    e1000[TDT/<span class="number">4</span>] = (tail + <span class="number">1</span>) % TXRING_LEN;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你完成发包代码后，可以在内核中调用该函数来测试代码正确性。运行<code>make E1000_DEBUG=TXERR,TX qemu</code>测试，你会看到如下输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e1000: index 0: 0x271f00 : 9000002a 0</span><br></pre></td></tr></table></figure></p>
<p>其中每一行表示1个发送的数据包，<code>index</code>给出了在发送描述符数组中的索引，之后的为该描述符中<code>packet buffer</code>的地址，然后是cmd/CSO/length标志位，最后是special/CSS/status标志位。</p>
<p>Exercise 7：添加1个系统调用来让用户空间可以发送数据包。具体的接口实现取决于自己。</p>
<p>仿照<code>sys_ipc_try_send</code>调用，在系统调用涉及的文件中添加调用号和接口函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kern/syscall.c</span></span><br><span class="line"><span class="comment">// Send network packet</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_netpacket_try_send</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    user_mem_assert(curenv, addr, len, PTE_U);</span><br><span class="line">    <span class="keyword">return</span> e1000_transmit(addr, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Transmitting-Packets-Network-Server"><a href="#Transmitting-Packets-Network-Server" class="headerlink" title="Transmitting Packets: Network Server"></a>Transmitting Packets: Network Server</h3><p>现在我们已经有了访问设备驱动发送端的系统调用接口，那么该发送一些<code>packets</code>了。output helper environment的作用就是不断做如下的循环：从核心网络服务器中接收<code>NSREQ_OUTPUT</code>类型的IPC消息，然后用我们自己写的系统调用将含有这些IPC消息的<code>packet</code>发送到网卡驱动。</p>
<p><code>NSREQ_OUTPUT</code>的IPC消息是由<code>net/lwip/jos/jif/jif.c</code>中的<code>low_level_output</code>发送的，它将lwIP stack和JOS的网络系统连在了一起。每一个IPC都会包含一个由union Nsipc组成的页，其中<code>packet</code>存放在<code>struct jif_pkt</code>字段中（见<code>inc/ns.h</code>）。<code>struct jif_pkt</code>如下所示：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jif_pkt</span> &#123;</span></span><br><span class="line">　　<span class="type">int</span> 　　jp_len;</span><br><span class="line">　　<span class="type">char</span>　  jp_data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>jp_len</code>代表了<code>packet</code>的长度。IPC page之后的所有字节都代表了<code>packet</code>的内容。使用一个长度为0的数组，例如<code>jp_data</code>，在<code>struct jif_pkt</code>的结尾，是C中一种比较通用的方式，用于代表一个未提前指定长度的<code>buffer</code>。因为C中并没有做任何边界检测，只要你确定<code>struct</code>之后有足够的未被使用的内存，我们就可以认为<code>jp_data</code>是任意大小的数组。</p>
<p>我们需要搞清楚当设备驱动的发送队列中没有空间的时候，设备驱动，output environment和核心网络服务器三者之间的关系。核心网络服务器通过IPC将packet发送给output environment。如果output environment因为驱动中没有足够的缓存空间用于存放新的packet而阻塞，核心网络服务器会一直阻塞直到output environment接受了IPC为止。</p>
<p>Exercise 8：实现<code>net/output.c</code>。</p>
<p>回答：这里主要是实现output environment的工作。<code>net/testoutput.c</code>是测试发包的代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">envid_t</span> output_envid;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">jif_pkt</span> *<span class="title">pkt</span> =</span> (<span class="keyword">struct</span> jif_pkt*)REQVA;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">umain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">envid_t</span> ns_envid = sys_getenvid();</span><br><span class="line">    <span class="type">int</span> i, r;</span><br><span class="line"></span><br><span class="line">    binaryname = <span class="string">&quot;testoutput&quot;</span>;</span><br><span class="line"></span><br><span class="line">    output_envid = fork();</span><br><span class="line">    <span class="keyword">if</span> (output_envid &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;error forking&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (output_envid == <span class="number">0</span>) &#123;</span><br><span class="line">        output(ns_envid);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;       </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TESTOUTPUT_COUNT; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, pkt, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line">        pkt-&gt;jp_len = <span class="built_in">snprintf</span>(pkt-&gt;jp_data,</span><br><span class="line">                       PGSIZE - <span class="keyword">sizeof</span>(pkt-&gt;jp_len),</span><br><span class="line">                       <span class="string">&quot;Packet %02d&quot;</span>, i);</span><br><span class="line">        cprintf(<span class="string">&quot;Transmitting packet %d\n&quot;</span>, i);</span><br><span class="line">        ipc_send(output_envid, NSREQ_OUTPUT, pkt, PTE_P|PTE_W|PTE_U);</span><br><span class="line">        sys_page_unmap(<span class="number">0</span>, pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spin for a while, just in case IPC&#x27;s or packets need to be flushed</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TESTOUTPUT_COUNT*<span class="number">2</span>; i++)</span><br><span class="line">        sys_yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>testoutput.c</code>中，先<code>fork</code>1个environment，即output environment，然后运行需要实现的<code>output</code>函数，在原先environment中通过<code>ipc_send</code>发送数据包的内容。所以在output environment中，就需要实现通过<code>ipc_recv</code>接受到IPC信息时，如果为<code>NSREQ_OUTPUT</code>，那么调用发包系统调用来发送数据包到网卡驱动。</p>
<h2 id="Part-B-Receiving-packets-and-the-web-server"><a href="#Part-B-Receiving-packets-and-the-web-server" class="headerlink" title="Part B: Receiving packets and the web server"></a>Part B: Receiving packets and the web server</h2><h3 id="Receiving-Packets"><a href="#Receiving-Packets" class="headerlink" title="Receiving Packets"></a>Receiving Packets</h3><p>与发包类似，我们必须配置E1000网卡来接受包并提供接收描述符队列和接收描述符。</p>
<p>接收队列和发送队列非常相似，不同的是它由空的<code>packet buffer</code>组成，等待被即将到来的<code>packet</code>填充。因此，当网络暂停的时候，发送队列是空的，但是接收队列是满的。当E1000接收到一个<code>packet</code>时，它会首先检查这个<code>packet</code>是否满足该网卡的configured filters（比如，这个包的目的地址是不是该E1000的MAC地址）并且忽略那些不符合这些filter的<code>packet</code>。否则，E1000尝试获取从接收队列获取下一个空闲的描述符。如果<code>Head</code>指针（<code>RDH</code>）已经追赶上了<code>Tail</code>指针（<code>RDT</code>），那么说明接收队列已经用完了空闲的descriptor，因此网卡就会丢弃这个<code>packet</code>。如果还有空闲的接收描述符，它会将packet data拷贝到描述符包含的<code>buffer</code>中，并且设置描述符的<code>DD</code>（descriptor done）和<code>EOP</code>（End of Packet）状态位，然后增加<code>RDH</code>。</p>
<p>如果E1000网卡收到一个<code>packet</code>，它的数据大于一个接收描述符的packet buffer，它会继续从接收队列中获取尽可能多的描述符，用来存放<code>packet</code>的所有内容。为了表明这样的情况，它会在每个<code>descriptor</code>中都设置<code>DD</code>状态位，但只在最后一个<code>descriptor</code>中设置<code>EOP</code>状态位。我们可以让驱动对这种情况进行处理，或者只是简单地对对网卡进行配置，让它不接收这样的“long packet”，但是我们要确保我们的receive buffer能够接收最大的标志Ethernet packet（1518字节）。</p>
<p>Exercise 10：建立接收队列和配置E1000网卡，无须支持”long packets”和multicast。暂时不要配置使用中断，同时忽略CRC。</p>
<p>默认情况下，网卡会过滤所有的<code>packet</code>，我们必须配置接收地址寄存器(<code>RAL</code>和<code>RAH</code>)为网卡的MAC地址以使得能接受发送给该网卡的包。目前可以简单地硬编码QEMU的默认MAC地址52:54:00:12:34:56。注意字节顺序MAC地址从左到右是从低地址到高地址的，所以52:54:00:12为低32位，34:56为高16位</p>
<p>E1000网卡只支持一系列特殊的receive buffer大小。假如我们配置receive packet buffers足够大并关闭long packets，那么我们就无需担心跨越多个receive buffer的包。同时记住接收队列和packet buffer也必须是连续的物理内存。我们必需使用至少128个接收描述符。</p>
<p>整个流程跟发包初始化配置类似。主要相关工作如下：</p>
<ul>
<li>设置接受地址寄存器(RAL/RAH)为网卡的MAC地址。</li>
<li>初始化<code>multicast</code>表数组为0。</li>
<li>设置中断相关寄存器的值，这里我们关闭中断</li>
<li>为接收描述符队列分配一块连续空间，设置<code>RDBAL</code>和<code>RDBAH</code>寄存器的值指向起始地址，其中<code>RDBAL</code>为32位地址，<code>RDBAL</code>和<code>RDBAH</code>表示64位地址。</li>
<li>设置<code>RDLEN</code>寄存器的值为描述符队列的大小，以字节计算。</li>
<li>设置接收队列的<code>Head</code>指针(<code>RDH</code>)和<code>Tail</code>指针(<code>RDT</code>)寄存器的值为0。<code>Head</code>指针指向第1个可用的描述符，<code>Tail</code>指向最后1个可用描述符的下一个描述符。如果将<code>Head</code>指针和<code>Tail</code>指针初始化为0，那么将接收不到数据包，应该将<code>Tail</code>指针初始化为最后1个可用描述符即<code>RDLEN-1</code>，因为像上面描述的当<code>RDH</code>等于<code>RDT</code>的时候，网卡认为队列满了，会丢弃数据包。</li>
<li>设置接收控制寄存器<code>RCTL</code>的值，主要包括设置<code>RCTL.EN</code>标志位为1(激活)、<code>RCTL.LBM</code>标志位为00(关闭回环)、<code>RCTL.BSIZE</code>标志位为00和<code>RCTL.BSEX</code>位为0(<code>buffer</code>大小为2048字节)、<code>RCTL.SECRC</code>标志位为1(忽略校验)。</li>
</ul>
<p>下边的代码与上述描述一一对应。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 为描述符列表分配静态内存 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tx_desc</span> <span class="title">tx_d</span>[<span class="title">TXRING_LEN</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span>(<span class="title">PGSIZE</span>)))</span></span><br><span class="line"><span class="class">        =</span> &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet</span> <span class="title">pbuf</span>[<span class="title">TXRING_LEN</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span>(<span class="title">PGSIZE</span>)))</span></span><br><span class="line"><span class="class">        =</span> &#123;&#123;&#123;<span class="number">0</span>&#125;&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> <span class="title">rx_d</span>[<span class="title">RXRING_LEN</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span>(<span class="title">PGSIZE</span>)))</span></span><br><span class="line"><span class="class">        =</span> &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet</span> <span class="title">prbuf</span>[<span class="title">RXRING_LEN</span>] __<span class="title">attribute__</span>((<span class="title">aligned</span>(<span class="title">PGSIZE</span>)))</span></span><br><span class="line"><span class="class">        =</span> &#123;&#123;&#123;<span class="number">0</span>&#125;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">init_desc</span><span class="params">()</span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; RXRING_LEN; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;rx_d[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(rx_d[i]));</span><br><span class="line">        rx_d[i].addr = PADDR(&amp;prbuf[i]);</span><br><span class="line">        rx_d[i].status = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">pci_e1000_attach</span><span class="params">(<span class="keyword">struct</span> pci_func *pcif)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">   e1000[RA/<span class="number">4</span>] = mac[<span class="number">0</span>];</span><br><span class="line">    e1000[RA/<span class="number">4</span>+<span class="number">1</span>] = mac[<span class="number">1</span>];</span><br><span class="line">    e1000[RA/<span class="number">4</span>+<span class="number">1</span>] |= RAV;</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;e1000: mac address %x:%x\n&quot;</span>, mac[<span class="number">1</span>], mac[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span>*)&amp;e1000[MTA/<span class="number">4</span>], <span class="number">0</span>, <span class="number">128</span> * <span class="number">4</span>);</span><br><span class="line">    e1000[ICS/<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    e1000[IMS/<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//e1000[IMC/4] = 0xFFFF;</span></span><br><span class="line">    e1000[RDBAL/<span class="number">4</span>] = PADDR(rx_d);</span><br><span class="line">    e1000[RDBAH/<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    e1000[RDLEN/<span class="number">4</span>] = RXRING_LEN * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rx_desc);</span><br><span class="line">    e1000[RDH/<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    e1000[RDT/<span class="number">4</span>] = RXRING_LEN - <span class="number">1</span>;</span><br><span class="line">    e1000[RCTL/<span class="number">4</span>] = RCTL_EN | RCTL_LBM_NO | RCTL_SECRC | RCTL_BSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完成后，运行<code>make E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER run-net_testinput</code>，<code>testinput</code>会发送ARP广播，QEMU会自动回应。</p>
<p>现在我们要实现接收包。为了接收<code>packet</code>，我们的驱动需要跟踪到底从哪个描述符中获取下一个received packet。和发送时相似，文档中说明从软件中读取RDH寄存器也是不可靠的。所以，为了确定一个<code>packet</code>是否被发送到描述符的packet buffer中，我们需要读取该描述符的<code>DD</code>状态位。如果<code>DD</code>已经被置位，那么我们可以将packet data从描述符的packet buffer中拷贝出来，然后通过更新队列的RDT告诉网卡该描述符已经被释放了。</p>
<p>如果<code>DD</code>没有被置位，那么说明没有接收到任何packet。这和发送端队列已满的情况是一样的，在这种情况下，我们可以做很多事情。我们可以简单地返回一个“try again”的error并且要求调用者继续尝试。这种方法对于发送队列已满的情况是有效的，因为那种情况是短暂的，但是对于空的接收队列就不合适了，因为接收队列可能很长时间处于空的状态。</p>
<p>第二种方法就是将calling environment挂起，直到接收队列中有packet可以处理。这种方法和<code>sys_ipc_recv</code>和相似。就像在IPC中所做的，每个CPU只有一个kernel stack，一旦我们离开kernel，那么栈上的state就会消失。我们需要设置一个<code>flag</code>来表明这个environment是因为接收队列被挂起的并且记录下系统调用参数。这种方法的缺点有点复杂：E1000网卡必须被配置成能产生接收中断并且驱动还需要能够对中断进行处理，为了让等待packet的environment能恢复过来。</p>
<p>Exercise 11：写1个函数来从E1000网卡接收1个包，并添加1个系统调用暴露给用户空间。确保你能处理接收队列为空的情况。</p>
<p>与发包类似，读取<code>RDT</code>寄存器的值，判断最后1个可用描述符的下一个描述符的标志位是否为<code>DD</code>，如果是则拷贝该描述符中的<code>buffer</code>，清除<code>DD</code>位，并增加<code>RDT</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">e1000_receive</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> buflen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> tail = (e1000[RDT/<span class="number">4</span>] + <span class="number">1</span>) % RXRING_LEN;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span> *<span class="title">nxt</span> =</span> &amp;rx_d[tail];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((nxt-&gt;status &amp; RXD_STAT_DD) != RXD_STAT_DD) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nxt-&gt;length &lt; buflen)</span><br><span class="line">        buflen = nxt-&gt;length;</span><br><span class="line"></span><br><span class="line">    memmove(addr, &amp;prbuf[tail], buflen);</span><br><span class="line">    nxt-&gt;status &amp;= !RXD_STAT_DD;</span><br><span class="line">    e1000[RDT/<span class="number">4</span>] = tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buflen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Receiving-Packets-Network-Server"><a href="#Receiving-Packets-Network-Server" class="headerlink" title="Receiving Packets: Network Server"></a>Receiving Packets: Network Server</h3><p>在网络服务器input environment中，我们将需要使用新添加的收包系统调用来接收数据包并通过<code>NSREQ_INPUT IPC</code>消息传递给核心网络服务器environment。</p>
<p>Exercise 12：实现<code>net/input.c</code></p>
<p>回答：这里主要是实现input environment的工作。<code>net/testinput.c</code>是测试收包的代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">umain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">envid_t</span> ns_envid = sys_getenvid();</span><br><span class="line">    <span class="type">int</span> i, r, first = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    binaryname = <span class="string">&quot;testinput&quot;</span>;</span><br><span class="line"></span><br><span class="line">    output_envid = fork();</span><br><span class="line">    <span class="keyword">if</span> (output_envid &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;error forking&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (output_envid == <span class="number">0</span>) &#123;</span><br><span class="line">        output(ns_envid);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input_envid = fork();</span><br><span class="line">    <span class="keyword">if</span> (input_envid &lt; <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;error forking&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (input_envid == <span class="number">0</span>) &#123;</span><br><span class="line">        input(ns_envid);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;Sending ARP announcement...\n&quot;</span>);</span><br><span class="line">    announce();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">envid_t</span> whom;</span><br><span class="line">        <span class="type">int</span> perm;</span><br><span class="line"></span><br><span class="line">        <span class="type">int32_t</span> req = ipc_recv((<span class="type">int32_t</span> *)&amp;whom, pkt, &amp;perm);</span><br><span class="line">        <span class="keyword">if</span> (req &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;ipc_recv: %e&quot;</span>, req);</span><br><span class="line">        <span class="keyword">if</span> (whom != input_envid)</span><br><span class="line">            panic(<span class="string">&quot;IPC from unexpected environment %08x&quot;</span>, whom);</span><br><span class="line">        <span class="keyword">if</span> (req != NSREQ_INPUT)</span><br><span class="line">            panic(<span class="string">&quot;Unexpected IPC %d&quot;</span>, req);</span><br><span class="line"></span><br><span class="line">        hexdump(<span class="string">&quot;input: &quot;</span>, pkt-&gt;jp_data, pkt-&gt;jp_len);</span><br><span class="line">        cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only indicate that we&#x27;re waiting for packets once</span></span><br><span class="line">        <span class="comment">// we&#x27;ve received the ARP reply</span></span><br><span class="line">        <span class="keyword">if</span> (first)</span><br><span class="line">            cprintf(<span class="string">&quot;Waiting for packets...\n&quot;</span>);</span><br><span class="line">        first = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>fork</code>了2个新的environment，其中1个执行output，发送ARP广播，另外1个执行input，接收QEMU的回应。通过<code>ipc_recv</code>来获得input environment收到的数据包。</p>
<p>在<code>net/input.c</code>的<code>input</code>函数中通过调用收包系统调用从网卡驱动处获得数据包，这里的注意点是根据注释有可能收包太快，发送给网络服务器，但是网络服务器可能读取过慢，导致相应的内容被冲刷，所以我们采用10页的缓冲来存放从网卡驱动获得的数据包。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">input</span><span class="params">(<span class="type">envid_t</span> ns_envid)</span></span><br><span class="line">&#123;   </span><br><span class="line">    binaryname = <span class="string">&quot;ns_input&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, r;</span><br><span class="line">    <span class="type">int32_t</span> length;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">jif_pkt</span> *<span class="title">cpkt</span> =</span> pkt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, (<span class="type">void</span>*)((<span class="type">uintptr_t</span>)pkt + i * PGSIZE), PTE_P | PTE_U | PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>((length = sys_netpacket_recv((<span class="type">void</span>*)((<span class="type">uintptr_t</span>)cpkt + <span class="keyword">sizeof</span>(cpkt-&gt;jp_len)), PGSIZE - <span class="keyword">sizeof</span>(cpkt-&gt;jp_len))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// cprintf(&quot;len: %d\n&quot;, length);</span></span><br><span class="line">            sys_yield();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cpkt-&gt;jp_len = length;</span><br><span class="line">        ipc_send(ns_envid, NSREQ_INPUT, cpkt, PTE_P | PTE_U);</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">        cpkt = (<span class="keyword">struct</span> jif_pkt*)((<span class="type">uintptr_t</span>)pkt + i * PGSIZE);</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-Web-Server"><a href="#The-Web-Server" class="headerlink" title="The Web Server"></a>The Web Server</h3><p>1个简单的web服务器将发送1个文件内容给请求客户端。JOS已经在<code>user/httpd.c</code>文件中提供可骨架代码，处理socket连接和Http头转义。</p>
<p>Exercise 13：实现<code>user/httpd.c</code>文件中的<code>send_file</code>函数和<code>send_data</code>函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">send_file</span><span class="params">(<span class="keyword">struct</span> http_request *req)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">off_t</span> file_size = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(req-&gt;url, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> send_error(req, <span class="number">404</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = fstat(fd, &amp;st)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> send_error(req, <span class="number">404</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st.st_isdir)</span><br><span class="line">        <span class="keyword">return</span> send_error(req, <span class="number">404</span>);</span><br><span class="line"></span><br><span class="line">    file_size = st.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = send_header(req, <span class="number">200</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = send_size(req, file_size)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = send_content_type(req)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = send_header_fin(req)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line">    r = send_data(req, fd);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">send_data</span><span class="params">(<span class="keyword">struct</span> http_request *req, <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        r = read(fd, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        <span class="keyword">if</span>(write(req-&gt;sock, buf, r) != r)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/14/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%94%B6%E9%9B%86/" rel="prev" title="常用算法收集">
      <i class="fa fa-chevron-left"></i> 常用算法收集
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/12/04/%E8%A7%A3%E8%AF%BBraft/" rel="next" title="解读Raft">
      解读Raft <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#lab1"><span class="nav-number">1.</span> <span class="nav-text">lab1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MIT6-828-%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.</span> <span class="nav-text">MIT6.828 实验环境配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-2-The-Boot-Loader"><span class="nav-number">1.2.</span> <span class="nav-text">Part 2: The Boot Loader</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#boot-S"><span class="nav-number">1.2.1.</span> <span class="nav-text">boot.S</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95boot-S"><span class="nav-number">1.2.2.</span> <span class="nav-text">调试boot.S</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8"><span class="nav-number">1.3.</span> <span class="nav-text">加载内核</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part3%EF%BC%9AThe-Kernel"><span class="nav-number">1.4.</span> <span class="nav-text">Part3：The Kernel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BD%8D%E7%BD%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.1.</span> <span class="nav-text">使用虚拟内存来解决位置依赖问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-7"><span class="nav-number">1.4.2.</span> <span class="nav-text">Exercise 7</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E5%88%B0%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="nav-number">1.4.3.</span> <span class="nav-text">格式化输出到控制台</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-8"><span class="nav-number">1.4.4.</span> <span class="nav-text">Exercise 8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.4.5.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="nav-number">1.4.6.</span> <span class="nav-text">栈的行为</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.7.</span> <span class="nav-text">调用函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E"><span class="nav-number">1.4.8.</span> <span class="nav-text">函数返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-10"><span class="nav-number">1.4.9.</span> <span class="nav-text">Exercise 10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%82%E5%AF%9Ftest-backtrace%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88"><span class="nav-number">1.4.10.</span> <span class="nav-text">观察test_backtrace函数调用栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0backtrace"><span class="nav-number">1.4.11.</span> <span class="nav-text">实现backtrace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96Symbol-Table"><span class="nav-number">1.4.12.</span> <span class="nav-text">读取Symbol Table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#debuginfo-eip%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE%E5%9C%B0%E5%9D%80%E5%AF%BB%E6%89%BE%E8%A1%8C%E5%8F%B7%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">1.4.13.</span> <span class="nav-text">debuginfo_eip函数实现根据地址寻找行号的功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%99%E5%86%85%E6%A0%B8%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%A2%9E%E5%8A%A0backtrace%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%B9%B6%E5%9C%A8mon-backtrace%E4%B8%AD%E5%A2%9E%E5%8A%A0%E6%89%93%E5%8D%B0%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%81%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%E8%A1%8C%E5%8F%B7"><span class="nav-number">1.4.14.</span> <span class="nav-text">给内核模拟器增加backtrace命令，并在mon_backtrace中增加打印文件名、函数名和行号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8mon-backtrace%E4%B8%AD%E5%A2%9E%E5%8A%A0%E6%89%93%E5%8D%B0%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%81%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%E8%A1%8C%E5%8F%B7"><span class="nav-number">1.4.15.</span> <span class="nav-text">在mon_backtrace中增加打印文件名、函数名和行号</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lab2"><span class="nav-number">2.</span> <span class="nav-text">lab2</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">2.1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E9%A1%BE%EF%BC%9A%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%8C%E6%88%90%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-number">2.1.1.</span> <span class="nav-text">回顾：未初始化完成的内存映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Part-1%E4%BB%BB%E5%8A%A1%E6%80%BB%E8%A7%88"><span class="nav-number">2.1.2.</span> <span class="nav-text">Part 1任务总览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#va-list-va-start%E7%AD%89%E7%AD%89"><span class="nav-number">2.1.3.</span> <span class="nav-text">va_list va_start等等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">2.1.4.</span> <span class="nav-text">两个内存分配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page%E5%88%86%E9%85%8D%E5%99%A8"><span class="nav-number">2.1.5.</span> <span class="nav-text">page分配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page%E5%88%86%E9%85%8D%E5%99%A8boot-alloc"><span class="nav-number">2.1.6.</span> <span class="nav-text">page分配器boot_alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%88%86%E9%85%8D%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.1.7.</span> <span class="nav-text">内核内存布局和分配器初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%BE%97%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF"><span class="nav-number">2.1.7.1.</span> <span class="nav-text">获得物理内存信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">2.1.7.2.</span> <span class="nav-text">内存布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.1.7.3.</span> <span class="nav-text">分配器初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-2-Part-2%EF%BC%9A%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-number">2.2.</span> <span class="nav-text">Lab 2 Part 2：内核内存映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E3%80%81%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-number">2.2.1.</span> <span class="nav-text">虚拟地址、线性地址和物理地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">2.2.2.</span> <span class="nav-text">x86内存管理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E3%80%81%E7%BA%BF%E6%80%A7%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">虚拟、线性和物理地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E6%AD%A5%E6%98%A0%E5%B0%84%E6%80%BB%E8%A7%88"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">两步映射总览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Segment-Translation"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">Segment Translation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8Descriptor-Table"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">描述符表Descriptor Table</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6Descriptor"><span class="nav-number">2.2.2.5.</span> <span class="nav-text">描述符Descriptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E7%AC%A6Selector"><span class="nav-number">2.2.2.6.</span> <span class="nav-text">选择符Selector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8Csegment%E6%9C%89%E5%85%B3%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">2.2.2.7.</span> <span class="nav-text">和segment有关的寄存器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Page-Translation"><span class="nav-number">2.2.3.</span> <span class="nav-text">Page Translation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E5%9F%9F%E5%AF%B9%E5%BA%94%E9%95%BF%E5%BA%A6"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">每个域对应长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Entry%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">Entry格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E4%BB%A3%E7%A0%81"><span class="nav-number">2.2.4.</span> <span class="nav-text">可以使用的工具代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mmu-h"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">mmu.h</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%8F%96%E5%87%BAPage-Table-Entry"><span class="nav-number">2.2.5.</span> <span class="nav-text">根据虚拟地址取出Page Table Entry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E4%B8%80%E6%AE%B5%E7%A9%BA%E9%97%B4"><span class="nav-number">2.2.6.</span> <span class="nav-text">映射一段空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Page-Table%E7%BB%84%E7%BB%87%E6%80%BB%E7%BB%93"><span class="nav-number">2.2.7.</span> <span class="nav-text">Page Table组织总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E6%98%A0%E5%B0%84%E7%9A%84%E5%87%BD%E6%95%B0%E4%BB%AC"><span class="nav-number">2.2.8.</span> <span class="nav-text">建立映射的函数们</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E5%86%85%E6%A0%B8%E5%BB%BA%E7%AB%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="nav-number">2.2.9.</span> <span class="nav-text">为内核建立虚拟地址映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E5%92%8C%E6%95%85%E9%9A%9C%E9%9A%94%E7%A6%BB"><span class="nav-number">2.2.9.1.</span> <span class="nav-text">权限和故障隔离</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E7%94%A8%E6%88%B7%E5%BB%BA%E7%AB%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="nav-number">2.2.10.</span> <span class="nav-text">为用户建立虚拟地址映射</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lab3"><span class="nav-number">3.</span> <span class="nav-text">lab3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-number">3.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-A-%E7%94%A8%E6%88%B7%E7%8E%AF%E5%A2%83%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">3.2.</span> <span class="nav-text">Part A: 用户环境和异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Environment-State"><span class="nav-number">3.2.1.</span> <span class="nav-text">Environment State</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E7%8E%AF%E5%A2%83%E6%95%B0%E7%BB%84"><span class="nav-number">3.3.</span> <span class="nav-text">分配环境数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90"><span class="nav-number">3.3.1.</span> <span class="nav-text">错误分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">3.3.2.</span> <span class="nav-text">解决办法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">3.3.3.</span> <span class="nav-text">创建和运行环境</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="nav-number">3.4.</span> <span class="nav-text">处理中断和异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.4.1.</span> <span class="nav-text">中断和异常的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">一个例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD"><span class="nav-number">3.4.2.</span> <span class="nav-text">嵌套的异常和中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8-IDT"><span class="nav-number">3.4.3.</span> <span class="nav-text">建立中断描述符表(IDT)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-B-%E7%BC%BA%E9%A1%B5%E9%94%99%E8%AF%AF%EF%BC%8C%E6%96%AD%E7%82%B9%E5%BC%82%E5%B8%B8%E4%BB%A5%E5%8F%8A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">3.5.</span> <span class="nav-text">Part B: 缺页错误，断点异常以及系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%BC%BA%E9%A1%B5%E9%94%99%E8%AF%AF"><span class="nav-number">3.5.1.</span> <span class="nav-text">处理缺页错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%AD%E7%82%B9%E5%BC%82%E5%B8%B8"><span class="nav-number">3.5.2.</span> <span class="nav-text">断点异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">3.5.3.</span> <span class="nav-text">系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%EF%BC%9AGCC%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">补充知识：GCC内联汇编</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8"><span class="nav-number">3.5.4.</span> <span class="nav-text">用户进程启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%94%99%E8%AF%AF-amp-%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="nav-number">3.5.5.</span> <span class="nav-text">页错误 &amp; 内存保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TA%E2%80%99s-Exercise"><span class="nav-number">3.5.6.</span> <span class="nav-text">TA’s Exercise</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">3.5.6.1.</span> <span class="nav-text">整体流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.5.6.2.</span> <span class="nav-text">调用过程及代码实现</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lab4"><span class="nav-number">4.</span> <span class="nav-text">lab4</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="nav-number">4.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-A-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E6%94%AF%E6%8C%81%E5%8F%8A%E5%8D%8F%E5%90%8C%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86"><span class="nav-number">4.2.</span> <span class="nav-text">Part A: 多处理器支持及协同多任务处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E6%94%AF%E6%8C%81"><span class="nav-number">4.2.1.</span> <span class="nav-text">多处理器支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%AF%BC%E5%BA%94%E7%94%A8%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">4.2.2.</span> <span class="nav-text">引导应用处理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-%E7%8A%B6%E6%80%81%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.2.3.</span> <span class="nav-text">CPU 状态和初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%84%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.2.4.</span> <span class="nav-text">各处理器中断初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">4.2.5.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E5%86%85%E6%A0%B8%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.5.1.</span> <span class="nav-text">大内核锁的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8%E8%BF%99%E5%87%A0%E5%A4%84%E5%8A%A0%E5%A4%A7%E5%86%85%E6%A0%B8%E9%94%81"><span class="nav-number">4.2.5.2.</span> <span class="nav-text">为什么要在这几处加大内核锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E4%B8%8D%E5%90%8C%E6%A0%88"><span class="nav-number">4.2.5.3.</span> <span class="nav-text">为什么要用不同栈</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2%E8%B0%83%E5%BA%A6"><span class="nav-number">4.2.6.</span> <span class="nav-text">轮询调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.2.7.</span> <span class="nav-text">系统调用：创建进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-B-%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%E7%9A%84-Fork"><span class="nav-number">4.3.</span> <span class="nav-text">Part B: 写时拷贝的 Fork</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E5%88%AB%E7%9A%84%E9%A1%B5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">4.3.1.</span> <span class="nav-text">用户级别的页错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AD%A3%E5%B8%B8%E6%A0%88%E5%92%8C%E5%BC%82%E5%B8%B8%E6%A0%88"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">进程的正常栈和异常栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E9%A1%B5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.1.2.</span> <span class="nav-text">用户页错误处理函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E9%A1%B5%E9%94%99%E8%AF%AF%E5%85%A5%E5%8F%A3"><span class="nav-number">4.3.2.</span> <span class="nav-text">用户模式页错误入口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-Copy-on-Write-Fork"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">实现 Copy-on-Write Fork</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UVPT"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">UVPT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#fork%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">fork函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#duppage-%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.2.4.</span> <span class="nav-text">duppage()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pgfault-%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.2.5.</span> <span class="nav-text">pgfault() 函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-C-%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86-amp-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">4.4.</span> <span class="nav-text">Part C: 抢占式多进程处理 &amp; 进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Part-I-%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E4%BB%A5%E5%8F%8A%E6%8A%A2%E5%8D%A0"><span class="nav-number">4.4.1.</span> <span class="nav-text">Part I: 时钟中断以及抢占</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Interrupt-discipline"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">Interrupt discipline</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Handling-Clock-Interrupts"><span class="nav-number">4.4.1.2.</span> <span class="nav-text">Handling Clock Interrupts</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Part-II-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-IPC"><span class="nav-number">4.4.2.</span> <span class="nav-text">Part II: 进程间通信(IPC)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IPC-in-JOS"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">IPC in JOS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">发送和接收消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E9%A1%B5%E9%9D%A2"><span class="nav-number">4.4.2.3.</span> <span class="nav-text">传递页面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Implementing-IPC"><span class="nav-number">4.4.2.4.</span> <span class="nav-text">Implementing IPC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lib-%E9%83%A8%E5%88%86"><span class="nav-number">4.4.2.5.</span> <span class="nav-text">lib 部分</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lab5"><span class="nav-number">5.</span> <span class="nav-text">lab5</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">5.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%AD%A5"><span class="nav-number">5.2.</span> <span class="nav-text">文件系统初步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-number">5.2.1.</span> <span class="nav-text">磁盘文件系统结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E6%89%87%E5%8C%BA%E3%80%81%E6%95%B0%E6%8D%AE%E5%9D%97"><span class="nav-number">5.2.2.</span> <span class="nav-text">磁盘扇区、数据块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B6%85%E7%BA%A7%E5%9D%97"><span class="nav-number">5.2.3.</span> <span class="nav-text">超级块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">5.2.4.</span> <span class="nav-text">文件元数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E4%B8%8E%E5%B8%B8%E8%A7%84%E6%96%87%E4%BB%B6"><span class="nav-number">5.2.5.</span> <span class="nav-text">目录与常规文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.3.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Disk-Access"><span class="nav-number">5.3.1.</span> <span class="nav-text">Disk Access</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Block-Cache"><span class="nav-number">5.3.2.</span> <span class="nav-text">The Block Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9D%97%E4%BD%8D%E5%9B%BE"><span class="nav-number">5.3.3.</span> <span class="nav-text">块位图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.4.</span> <span class="nav-text">文件操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-file-system-interface"><span class="nav-number">5.3.5.</span> <span class="nav-text">The file system interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spawning-Processes-%E8%A1%8D%E7%94%9F%E7%A8%8B%E5%BA%8F%EF%BC%8C%E6%B4%BE%E7%94%9F%E7%A8%8B%E5%BA%8F"><span class="nav-number">5.3.6.</span> <span class="nav-text">Spawning Processes(衍生程序，派生程序)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sharing-library-state-across-fork-and-spawn"><span class="nav-number">5.3.7.</span> <span class="nav-text">Sharing library state across fork and spawn</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Shell"><span class="nav-number">5.4.</span> <span class="nav-text">The Shell</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lab6"><span class="nav-number">6.</span> <span class="nav-text">lab6</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction-1"><span class="nav-number">6.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QEMU%E2%80%99s-virtual-network"><span class="nav-number">6.2.</span> <span class="nav-text">QEMU’s virtual network</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Packet-Inspection"><span class="nav-number">6.2.1.</span> <span class="nav-text">Packet Inspection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Debugging-the-E1000"><span class="nav-number">6.2.2.</span> <span class="nav-text">Debugging the E1000　　</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Network-Server"><span class="nav-number">6.2.3.</span> <span class="nav-text">The Network Server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Core-Network-Server-Environment"><span class="nav-number">6.2.4.</span> <span class="nav-text">The Core Network Server Environment　　</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Output-Environment"><span class="nav-number">6.2.5.</span> <span class="nav-text">The Output Environment　</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Input-Environment"><span class="nav-number">6.2.6.</span> <span class="nav-text">The Input Environment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Timer-Environment"><span class="nav-number">6.2.7.</span> <span class="nav-text">The Timer Environment　　　　　　　</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-A-Initialization-and-transmitting-packets"><span class="nav-number">6.3.</span> <span class="nav-text">Part A: Initialization and transmitting packets</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Network-Interface-Card"><span class="nav-number">6.3.1.</span> <span class="nav-text">The Network Interface Card</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PCI-Interface"><span class="nav-number">6.3.2.</span> <span class="nav-text">PCI Interface</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Memory-mapped-I-O"><span class="nav-number">6.3.3.</span> <span class="nav-text">Memory-mapped I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DMA"><span class="nav-number">6.3.4.</span> <span class="nav-text">DMA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transmitting-Packets"><span class="nav-number">6.3.5.</span> <span class="nav-text">Transmitting Packets</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-Structures"><span class="nav-number">6.3.5.1.</span> <span class="nav-text">C Structures</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transmitting-Packets-Network-Server"><span class="nav-number">6.3.6.</span> <span class="nav-text">Transmitting Packets: Network Server</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-B-Receiving-packets-and-the-web-server"><span class="nav-number">6.4.</span> <span class="nav-text">Part B: Receiving packets and the web server</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Receiving-Packets"><span class="nav-number">6.4.1.</span> <span class="nav-text">Receiving Packets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Receiving-Packets-Network-Server"><span class="nav-number">6.4.2.</span> <span class="nav-text">Receiving Packets: Network Server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Web-Server"><span class="nav-number">6.4.3.</span> <span class="nav-text">The Web Server</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao Yu</p>
  <div class="site-description" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuhao0102" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuhao0102" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuhhpc0203@gmail.com" title="E-Mail → mailto:yuhhpc0203@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
